begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|HADOOP_TREAT_SUBJECT_EXTERNAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|HADOOP_TREAT_SUBJECT_EXTERNAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_TOKEN_FILES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UGIExceptionMessages
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|PlatformName
operator|.
name|IBM_JAVA
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessControlContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Principal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|DestroyFailedException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|Subject
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|callback
operator|.
name|CallbackHandler
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosPrincipal
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosTicket
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
operator|.
name|LoginModuleControlFlag
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|spi
operator|.
name|LoginModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MetricsRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableGaugeInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableGaugeLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableQuantiles
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableRate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SaslRpcServer
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|KerberosUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * User and group information for Hadoop.  * This class wraps around a JAAS Subject and provides methods to determine the  * user's username and groups. It supports both the Windows, Unix and Kerberos   * login modules.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|UserGroupInformation
specifier|public
class|class
name|UserGroupInformation
block|{
annotation|@
name|VisibleForTesting
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|UserGroupInformation
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Percentage of the ticket window to use before we renew ticket.    */
DECL|field|TICKET_RENEW_WINDOW
specifier|private
specifier|static
specifier|final
name|float
name|TICKET_RENEW_WINDOW
init|=
literal|0.80f
decl_stmt|;
DECL|field|shouldRenewImmediatelyForTests
specifier|private
specifier|static
name|boolean
name|shouldRenewImmediatelyForTests
init|=
literal|false
decl_stmt|;
DECL|field|HADOOP_USER_NAME
specifier|static
specifier|final
name|String
name|HADOOP_USER_NAME
init|=
literal|"HADOOP_USER_NAME"
decl_stmt|;
DECL|field|HADOOP_PROXY_USER
specifier|static
specifier|final
name|String
name|HADOOP_PROXY_USER
init|=
literal|"HADOOP_PROXY_USER"
decl_stmt|;
comment|/**    * For the purposes of unit tests, we want to test login    * from keytab and don't want to wait until the renew    * window (controlled by TICKET_RENEW_WINDOW).    * @param immediate true if we should login without waiting for ticket window    */
annotation|@
name|VisibleForTesting
DECL|method|setShouldRenewImmediatelyForTests (boolean immediate)
specifier|public
specifier|static
name|void
name|setShouldRenewImmediatelyForTests
parameter_list|(
name|boolean
name|immediate
parameter_list|)
block|{
name|shouldRenewImmediatelyForTests
operator|=
name|immediate
expr_stmt|;
block|}
comment|/**     * UgiMetrics maintains UGI activity statistics    * and publishes them through the metrics interfaces.    */
annotation|@
name|Metrics
argument_list|(
name|about
operator|=
literal|"User and group related metrics"
argument_list|,
name|context
operator|=
literal|"ugi"
argument_list|)
DECL|class|UgiMetrics
specifier|static
class|class
name|UgiMetrics
block|{
DECL|field|registry
specifier|final
name|MetricsRegistry
name|registry
init|=
operator|new
name|MetricsRegistry
argument_list|(
literal|"UgiMetrics"
argument_list|)
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Rate of successful kerberos logins and latency (milliseconds)"
argument_list|)
DECL|field|loginSuccess
name|MutableRate
name|loginSuccess
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Rate of failed kerberos logins and latency (milliseconds)"
argument_list|)
DECL|field|loginFailure
name|MutableRate
name|loginFailure
decl_stmt|;
DECL|field|getGroups
annotation|@
name|Metric
argument_list|(
literal|"GetGroups"
argument_list|)
name|MutableRate
name|getGroups
decl_stmt|;
DECL|field|getGroupsQuantiles
name|MutableQuantiles
index|[]
name|getGroupsQuantiles
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Renewal failures since startup"
argument_list|)
DECL|field|renewalFailuresTotal
specifier|private
name|MutableGaugeLong
name|renewalFailuresTotal
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Renewal failures since last successful login"
argument_list|)
DECL|field|renewalFailures
specifier|private
name|MutableGaugeInt
name|renewalFailures
decl_stmt|;
DECL|method|create ()
specifier|static
name|UgiMetrics
name|create
parameter_list|()
block|{
return|return
name|DefaultMetricsSystem
operator|.
name|instance
argument_list|()
operator|.
name|register
argument_list|(
operator|new
name|UgiMetrics
argument_list|()
argument_list|)
return|;
block|}
DECL|method|reattach ()
specifier|static
name|void
name|reattach
parameter_list|()
block|{
name|metrics
operator|=
name|UgiMetrics
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
DECL|method|addGetGroups (long latency)
name|void
name|addGetGroups
parameter_list|(
name|long
name|latency
parameter_list|)
block|{
name|getGroups
operator|.
name|add
argument_list|(
name|latency
argument_list|)
expr_stmt|;
if|if
condition|(
name|getGroupsQuantiles
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|MutableQuantiles
name|q
range|:
name|getGroupsQuantiles
control|)
block|{
name|q
operator|.
name|add
argument_list|(
name|latency
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getRenewalFailures ()
name|MutableGaugeInt
name|getRenewalFailures
parameter_list|()
block|{
return|return
name|renewalFailures
return|;
block|}
block|}
comment|/**    * A login module that looks at the Kerberos, Unix, or Windows principal and    * adds the corresponding UserName.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|HadoopLoginModule
specifier|public
specifier|static
class|class
name|HadoopLoginModule
implements|implements
name|LoginModule
block|{
DECL|field|subject
specifier|private
name|Subject
name|subject
decl_stmt|;
annotation|@
name|Override
DECL|method|abort ()
specifier|public
name|boolean
name|abort
parameter_list|()
throws|throws
name|LoginException
block|{
return|return
literal|true
return|;
block|}
DECL|method|getCanonicalUser (Class<T> cls)
specifier|private
parameter_list|<
name|T
extends|extends
name|Principal
parameter_list|>
name|T
name|getCanonicalUser
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|cls
parameter_list|)
block|{
for|for
control|(
name|T
name|user
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|cls
argument_list|)
control|)
block|{
return|return
name|user
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|commit ()
specifier|public
name|boolean
name|commit
parameter_list|()
throws|throws
name|LoginException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"hadoop login commit"
argument_list|)
expr_stmt|;
block|}
comment|// if we already have a user, we are done.
if|if
condition|(
operator|!
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"using existing subject:"
operator|+
name|subject
operator|.
name|getPrincipals
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|Principal
name|user
init|=
literal|null
decl_stmt|;
comment|// if we are using kerberos, try it out
if|if
condition|(
name|isAuthenticationMethodEnabled
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
condition|)
block|{
name|user
operator|=
name|getCanonicalUser
argument_list|(
name|KerberosPrincipal
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"using kerberos user:"
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
block|}
comment|//If we don't have a kerberos user and security is disabled, check
comment|//if user is specified in the environment or properties
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
operator|&&
operator|(
name|user
operator|==
literal|null
operator|)
condition|)
block|{
name|String
name|envUser
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_USER_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|envUser
operator|==
literal|null
condition|)
block|{
name|envUser
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_USER_NAME
argument_list|)
expr_stmt|;
block|}
name|user
operator|=
name|envUser
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|User
argument_list|(
name|envUser
argument_list|)
expr_stmt|;
block|}
comment|// use the OS user
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
name|user
operator|=
name|getCanonicalUser
argument_list|(
name|OS_PRINCIPAL_CLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"using local user:"
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we found the user, add our principal
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using user: \""
operator|+
name|user
operator|+
literal|"\" with name "
operator|+
name|user
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|User
name|userEntry
init|=
literal|null
decl_stmt|;
try|try
block|{
name|userEntry
operator|=
operator|new
name|User
argument_list|(
name|user
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
call|(
name|LoginException
call|)
argument_list|(
operator|new
name|LoginException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User entry: \""
operator|+
name|userEntry
operator|.
name|toString
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
name|userEntry
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't find user in "
operator|+
name|subject
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LoginException
argument_list|(
literal|"Can't find user name"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|initialize (Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)
specifier|public
name|void
name|initialize
parameter_list|(
name|Subject
name|subject
parameter_list|,
name|CallbackHandler
name|callbackHandler
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|sharedState
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|login ()
specifier|public
name|boolean
name|login
parameter_list|()
throws|throws
name|LoginException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"hadoop login"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|logout ()
specifier|public
name|boolean
name|logout
parameter_list|()
throws|throws
name|LoginException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"hadoop logout"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Reattach the class's metrics to a new metric system.    */
DECL|method|reattachMetrics ()
specifier|public
specifier|static
name|void
name|reattachMetrics
parameter_list|()
block|{
name|UgiMetrics
operator|.
name|reattach
argument_list|()
expr_stmt|;
block|}
comment|/** Metrics to track UGI activity */
DECL|field|metrics
specifier|static
name|UgiMetrics
name|metrics
init|=
name|UgiMetrics
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/** The auth method to use */
DECL|field|authenticationMethod
specifier|private
specifier|static
name|AuthenticationMethod
name|authenticationMethod
decl_stmt|;
comment|/** Server-side groups fetching service */
DECL|field|groups
specifier|private
specifier|static
name|Groups
name|groups
decl_stmt|;
comment|/** Min time (in seconds) before relogin for Kerberos */
DECL|field|kerberosMinSecondsBeforeRelogin
specifier|private
specifier|static
name|long
name|kerberosMinSecondsBeforeRelogin
decl_stmt|;
comment|/** The configuration to use */
comment|/*    * This config is a temporary one for backward compatibility.    * It means whether to treat the subject passed to    * UserGroupInformation(Subject) as external. If true,    * -  no renewal thread will be created to do the renew credential    * -  reloginFromKeytab() and reloginFromTicketCache will not renew    *    credential.    * and it assumes that the owner of the subject to renew; if false, it means    * to retain the old behavior prior to fixing HADOOP-13558 and HADOOP-13805.    * The default is false.    */
DECL|field|treatSubjectExternal
specifier|private
specifier|static
name|boolean
name|treatSubjectExternal
init|=
literal|false
decl_stmt|;
comment|/*    * Some test need the renewal thread to be created even if it does    *   UserGroupInformation.loginUserFromSubject(subject);    * The test code may set this variable to true via    *   setEnableRenewThreadCreationForTest(boolean)    * method.    */
DECL|field|enableRenewThreadCreationForTest
specifier|private
specifier|static
name|boolean
name|enableRenewThreadCreationForTest
init|=
literal|false
decl_stmt|;
DECL|field|conf
specifier|private
specifier|static
name|Configuration
name|conf
decl_stmt|;
comment|/**Environment variable pointing to the token cache file*/
DECL|field|HADOOP_TOKEN_FILE_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_TOKEN_FILE_LOCATION
init|=
literal|"HADOOP_TOKEN_FILE_LOCATION"
decl_stmt|;
comment|/**     * A method to initialize the fields that depend on a configuration.    * Must be called before useKerberos or groups is used.    */
DECL|method|ensureInitialized ()
specifier|private
specifier|static
name|void
name|ensureInitialized
parameter_list|()
block|{
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|UserGroupInformation
operator|.
name|class
init|)
block|{
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
comment|// someone might have beat us
name|initialize
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Initialize UGI and related classes.    * @param conf the configuration to use    */
DECL|method|initialize (Configuration conf, boolean overrideNameRules)
specifier|private
specifier|static
specifier|synchronized
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|overrideNameRules
parameter_list|)
block|{
name|authenticationMethod
operator|=
name|SecurityUtil
operator|.
name|getAuthenticationMethod
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|overrideNameRules
operator|||
operator|!
name|HadoopKerberosName
operator|.
name|hasRulesBeenSet
argument_list|()
condition|)
block|{
try|try
block|{
name|HadoopKerberosName
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Problem with Kerberos auth_to_local name configuration"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|kerberosMinSecondsBeforeRelogin
operator|=
literal|1000L
operator|*
name|conf
operator|.
name|getLong
argument_list|(
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN
argument_list|,
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid attribute value for "
operator|+
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN
operator|+
literal|" of "
operator|+
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN
argument_list|)
argument_list|)
throw|;
block|}
comment|// If we haven't set up testing groups, use the configuration to find it
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
name|Groups
operator|.
name|getUserToGroupsMappingService
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|UserGroupInformation
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
if|if
condition|(
name|metrics
operator|.
name|getGroupsQuantiles
operator|==
literal|null
condition|)
block|{
name|int
index|[]
name|intervals
init|=
name|conf
operator|.
name|getInts
argument_list|(
name|HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS
argument_list|)
decl_stmt|;
if|if
condition|(
name|intervals
operator|!=
literal|null
operator|&&
name|intervals
operator|.
name|length
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|length
init|=
name|intervals
operator|.
name|length
decl_stmt|;
name|MutableQuantiles
index|[]
name|getGroupsQuantiles
init|=
operator|new
name|MutableQuantiles
index|[
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|getGroupsQuantiles
index|[
name|i
index|]
operator|=
name|metrics
operator|.
name|registry
operator|.
name|newQuantiles
argument_list|(
literal|"getGroups"
operator|+
name|intervals
index|[
name|i
index|]
operator|+
literal|"s"
argument_list|,
literal|"Get groups"
argument_list|,
literal|"ops"
argument_list|,
literal|"latency"
argument_list|,
name|intervals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|getGroupsQuantiles
operator|=
name|getGroupsQuantiles
expr_stmt|;
block|}
block|}
name|treatSubjectExternal
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HADOOP_TREAT_SUBJECT_EXTERNAL_KEY
argument_list|,
name|HADOOP_TREAT_SUBJECT_EXTERNAL_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|treatSubjectExternal
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Config "
operator|+
name|HADOOP_TREAT_SUBJECT_EXTERNAL_KEY
operator|+
literal|" is set to "
operator|+
literal|"true, the owner of the subject passed to "
operator|+
literal|" UserGroupInformation(Subject) is supposed to renew the "
operator|+
literal|"credential."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the static configuration for UGI.    * In particular, set the security authentication mechanism and the    * group look up service.    * @param conf the configuration to use    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|setConfiguration (Configuration conf)
specifier|public
specifier|static
name|void
name|setConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|initialize
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setEnableRenewThreadCreationForTest (boolean b)
specifier|static
name|void
name|setEnableRenewThreadCreationForTest
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
name|enableRenewThreadCreationForTest
operator|=
name|b
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|getEnableRenewThreadCreationForTest ()
specifier|static
name|boolean
name|getEnableRenewThreadCreationForTest
parameter_list|()
block|{
return|return
name|enableRenewThreadCreationForTest
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|reset ()
specifier|public
specifier|static
name|void
name|reset
parameter_list|()
block|{
name|authenticationMethod
operator|=
literal|null
expr_stmt|;
name|conf
operator|=
literal|null
expr_stmt|;
name|groups
operator|=
literal|null
expr_stmt|;
name|kerberosMinSecondsBeforeRelogin
operator|=
literal|0
expr_stmt|;
name|setLoginUser
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|HadoopKerberosName
operator|.
name|setRules
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setEnableRenewThreadCreationForTest
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine if UserGroupInformation is using Kerberos to determine    * user identities or is relying on simple authentication    *     * @return true if UGI is working in a secure environment    */
DECL|method|isSecurityEnabled ()
specifier|public
specifier|static
name|boolean
name|isSecurityEnabled
parameter_list|()
block|{
return|return
operator|!
name|isAuthenticationMethodEnabled
argument_list|(
name|AuthenticationMethod
operator|.
name|SIMPLE
argument_list|)
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|isAuthenticationMethodEnabled (AuthenticationMethod method)
specifier|private
specifier|static
name|boolean
name|isAuthenticationMethodEnabled
parameter_list|(
name|AuthenticationMethod
name|method
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
return|return
operator|(
name|authenticationMethod
operator|==
name|method
operator|)
return|;
block|}
comment|/**    * Information about the logged in user.    */
DECL|field|loginUser
specifier|private
specifier|static
name|UserGroupInformation
name|loginUser
init|=
literal|null
decl_stmt|;
DECL|field|keytabPrincipal
specifier|private
specifier|static
name|String
name|keytabPrincipal
init|=
literal|null
decl_stmt|;
DECL|field|keytabFile
specifier|private
specifier|static
name|String
name|keytabFile
init|=
literal|null
decl_stmt|;
DECL|field|subject
specifier|private
specifier|final
name|Subject
name|subject
decl_stmt|;
comment|// All non-static fields must be read-only caches that come from the subject.
DECL|field|user
specifier|private
specifier|final
name|User
name|user
decl_stmt|;
DECL|field|isKeytab
specifier|private
specifier|final
name|boolean
name|isKeytab
decl_stmt|;
DECL|field|isKrbTkt
specifier|private
specifier|final
name|boolean
name|isKrbTkt
decl_stmt|;
DECL|field|isLoginExternal
specifier|private
specifier|final
name|boolean
name|isLoginExternal
decl_stmt|;
DECL|field|OS_LOGIN_MODULE_NAME
specifier|private
specifier|static
name|String
name|OS_LOGIN_MODULE_NAME
decl_stmt|;
DECL|field|OS_PRINCIPAL_CLASS
specifier|private
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
name|OS_PRINCIPAL_CLASS
decl_stmt|;
DECL|field|windows
specifier|private
specifier|static
specifier|final
name|boolean
name|windows
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"Windows"
argument_list|)
decl_stmt|;
DECL|field|is64Bit
specifier|private
specifier|static
specifier|final
name|boolean
name|is64Bit
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.arch"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"64"
argument_list|)
operator|||
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.arch"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"s390x"
argument_list|)
decl_stmt|;
DECL|field|aix
specifier|private
specifier|static
specifier|final
name|boolean
name|aix
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|equals
argument_list|(
literal|"AIX"
argument_list|)
decl_stmt|;
comment|/* Return the OS login module class name */
DECL|method|getOSLoginModuleName ()
specifier|private
specifier|static
name|String
name|getOSLoginModuleName
parameter_list|()
block|{
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
if|if
condition|(
name|windows
condition|)
block|{
return|return
name|is64Bit
condition|?
literal|"com.ibm.security.auth.module.Win64LoginModule"
else|:
literal|"com.ibm.security.auth.module.NTLoginModule"
return|;
block|}
elseif|else
if|if
condition|(
name|aix
condition|)
block|{
return|return
name|is64Bit
condition|?
literal|"com.ibm.security.auth.module.AIX64LoginModule"
else|:
literal|"com.ibm.security.auth.module.AIXLoginModule"
return|;
block|}
else|else
block|{
return|return
literal|"com.ibm.security.auth.module.LinuxLoginModule"
return|;
block|}
block|}
else|else
block|{
return|return
name|windows
condition|?
literal|"com.sun.security.auth.module.NTLoginModule"
else|:
literal|"com.sun.security.auth.module.UnixLoginModule"
return|;
block|}
block|}
comment|/* Return the OS principal class */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getOsPrincipalClass ()
specifier|private
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
name|getOsPrincipalClass
parameter_list|()
block|{
name|ClassLoader
name|cl
init|=
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|principalClass
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
if|if
condition|(
name|is64Bit
condition|)
block|{
name|principalClass
operator|=
literal|"com.ibm.security.auth.UsernamePrincipal"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|windows
condition|)
block|{
name|principalClass
operator|=
literal|"com.ibm.security.auth.NTUserPrincipal"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aix
condition|)
block|{
name|principalClass
operator|=
literal|"com.ibm.security.auth.AIXPrincipal"
expr_stmt|;
block|}
else|else
block|{
name|principalClass
operator|=
literal|"com.ibm.security.auth.LinuxPrincipal"
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|principalClass
operator|=
name|windows
condition|?
literal|"com.sun.security.auth.NTUserPrincipal"
else|:
literal|"com.sun.security.auth.UnixPrincipal"
expr_stmt|;
block|}
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
operator|)
name|cl
operator|.
name|loadClass
argument_list|(
name|principalClass
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to find JAAS classes:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
static|static
block|{
name|OS_LOGIN_MODULE_NAME
operator|=
name|getOSLoginModuleName
argument_list|()
expr_stmt|;
name|OS_PRINCIPAL_CLASS
operator|=
name|getOsPrincipalClass
argument_list|()
expr_stmt|;
block|}
DECL|class|RealUser
specifier|private
specifier|static
class|class
name|RealUser
implements|implements
name|Principal
block|{
DECL|field|realUser
specifier|private
specifier|final
name|UserGroupInformation
name|realUser
decl_stmt|;
DECL|method|RealUser (UserGroupInformation realUser)
name|RealUser
parameter_list|(
name|UserGroupInformation
name|realUser
parameter_list|)
block|{
name|this
operator|.
name|realUser
operator|=
name|realUser
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|getUserName
argument_list|()
return|;
block|}
DECL|method|getRealUser ()
specifier|public
name|UserGroupInformation
name|getRealUser
parameter_list|()
block|{
return|return
name|realUser
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|realUser
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|RealUser
operator|)
name|o
operator|)
operator|.
name|realUser
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * A JAAS configuration that defines the login modules that we want    * to use for login.    */
DECL|class|HadoopConfiguration
specifier|private
specifier|static
class|class
name|HadoopConfiguration
extends|extends
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
block|{
DECL|field|SIMPLE_CONFIG_NAME
specifier|private
specifier|static
specifier|final
name|String
name|SIMPLE_CONFIG_NAME
init|=
literal|"hadoop-simple"
decl_stmt|;
DECL|field|USER_KERBEROS_CONFIG_NAME
specifier|private
specifier|static
specifier|final
name|String
name|USER_KERBEROS_CONFIG_NAME
init|=
literal|"hadoop-user-kerberos"
decl_stmt|;
DECL|field|KEYTAB_KERBEROS_CONFIG_NAME
specifier|private
specifier|static
specifier|final
name|String
name|KEYTAB_KERBEROS_CONFIG_NAME
init|=
literal|"hadoop-keytab-kerberos"
decl_stmt|;
DECL|field|BASIC_JAAS_OPTIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|BASIC_JAAS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|String
name|jaasEnvVar
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"HADOOP_JAAS_DEBUG"
argument_list|)
decl_stmt|;
if|if
condition|(
name|jaasEnvVar
operator|!=
literal|null
operator|&&
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|jaasEnvVar
argument_list|)
condition|)
block|{
name|BASIC_JAAS_OPTIONS
operator|.
name|put
argument_list|(
literal|"debug"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|OS_SPECIFIC_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|OS_SPECIFIC_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|OS_LOGIN_MODULE_NAME
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|BASIC_JAAS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|HADOOP_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|HADOOP_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|HadoopLoginModule
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|BASIC_JAAS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|USER_KERBEROS_OPTIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|USER_KERBEROS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useDefaultCcache"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useTicketCache"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
name|String
name|ticketCache
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ticketCache
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
comment|// The first value searched when "useDefaultCcache" is used.
name|System
operator|.
name|setProperty
argument_list|(
literal|"KRB5CCNAME"
argument_list|,
name|ticketCache
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"ticketCache"
argument_list|,
name|ticketCache
argument_list|)
expr_stmt|;
block|}
block|}
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"renewTGT"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|USER_KERBEROS_OPTIONS
operator|.
name|putAll
argument_list|(
name|BASIC_JAAS_OPTIONS
argument_list|)
expr_stmt|;
block|}
DECL|field|USER_KERBEROS_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|USER_KERBEROS_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|KerberosUtil
operator|.
name|getKrb5LoginModuleName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|OPTIONAL
argument_list|,
name|USER_KERBEROS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|KEYTAB_KERBEROS_OPTIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|KEYTAB_KERBEROS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"credsType"
argument_list|,
literal|"both"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useKeyTab"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"storeKey"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"refreshKrb5Config"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|putAll
argument_list|(
name|BASIC_JAAS_OPTIONS
argument_list|)
expr_stmt|;
block|}
DECL|field|KEYTAB_KERBEROS_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|KEYTAB_KERBEROS_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|KerberosUtil
operator|.
name|getKrb5LoginModuleName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|KEYTAB_KERBEROS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|SIMPLE_CONF
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|SIMPLE_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|OS_SPECIFIC_LOGIN
block|,
name|HADOOP_LOGIN
block|}
decl_stmt|;
DECL|field|USER_KERBEROS_CONF
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|USER_KERBEROS_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|OS_SPECIFIC_LOGIN
block|,
name|USER_KERBEROS_LOGIN
block|,
name|HADOOP_LOGIN
block|}
decl_stmt|;
DECL|field|KEYTAB_KERBEROS_CONF
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|KEYTAB_KERBEROS_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|KEYTAB_KERBEROS_LOGIN
block|,
name|HADOOP_LOGIN
block|}
decl_stmt|;
annotation|@
name|Override
DECL|method|getAppConfigurationEntry (String appName)
specifier|public
name|AppConfigurationEntry
index|[]
name|getAppConfigurationEntry
parameter_list|(
name|String
name|appName
parameter_list|)
block|{
if|if
condition|(
name|SIMPLE_CONFIG_NAME
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
return|return
name|SIMPLE_CONF
return|;
block|}
elseif|else
if|if
condition|(
name|USER_KERBEROS_CONFIG_NAME
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
return|return
name|USER_KERBEROS_CONF
return|;
block|}
elseif|else
if|if
condition|(
name|KEYTAB_KERBEROS_CONFIG_NAME
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useKeytab"
argument_list|,
name|prependFileAuthority
argument_list|(
name|keytabFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"keyTab"
argument_list|,
name|keytabFile
argument_list|)
expr_stmt|;
block|}
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"principal"
argument_list|,
name|keytabPrincipal
argument_list|)
expr_stmt|;
return|return
name|KEYTAB_KERBEROS_CONF
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
DECL|method|prependFileAuthority (String keytabPath)
specifier|private
specifier|static
name|String
name|prependFileAuthority
parameter_list|(
name|String
name|keytabPath
parameter_list|)
block|{
return|return
name|keytabPath
operator|.
name|startsWith
argument_list|(
literal|"file://"
argument_list|)
condition|?
name|keytabPath
else|:
literal|"file://"
operator|+
name|keytabPath
return|;
block|}
comment|/**    * Represents a javax.security configuration that is created at runtime.    */
DECL|class|DynamicConfiguration
specifier|private
specifier|static
class|class
name|DynamicConfiguration
extends|extends
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
block|{
DECL|field|ace
specifier|private
name|AppConfigurationEntry
index|[]
name|ace
decl_stmt|;
DECL|method|DynamicConfiguration (AppConfigurationEntry[] ace)
name|DynamicConfiguration
parameter_list|(
name|AppConfigurationEntry
index|[]
name|ace
parameter_list|)
block|{
name|this
operator|.
name|ace
operator|=
name|ace
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getAppConfigurationEntry (String appName)
specifier|public
name|AppConfigurationEntry
index|[]
name|getAppConfigurationEntry
parameter_list|(
name|String
name|appName
parameter_list|)
block|{
return|return
name|ace
return|;
block|}
block|}
specifier|private
specifier|static
name|LoginContext
DECL|method|newLoginContext (String appName, Subject subject, javax.security.auth.login.Configuration loginConf)
name|newLoginContext
parameter_list|(
name|String
name|appName
parameter_list|,
name|Subject
name|subject
parameter_list|,
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
name|loginConf
parameter_list|)
throws|throws
name|LoginException
block|{
comment|// Temporarily switch the thread's ContextClassLoader to match this
comment|// class's classloader, so that we can properly load HadoopLoginModule
comment|// from the JAAS libraries.
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|ClassLoader
name|oldCCL
init|=
name|t
operator|.
name|getContextClassLoader
argument_list|()
decl_stmt|;
name|t
operator|.
name|setContextClassLoader
argument_list|(
name|HadoopLoginModule
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
return|return
operator|new
name|LoginContext
argument_list|(
name|appName
argument_list|,
name|subject
argument_list|,
literal|null
argument_list|,
name|loginConf
argument_list|)
return|;
block|}
finally|finally
block|{
name|t
operator|.
name|setContextClassLoader
argument_list|(
name|oldCCL
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getLogin ()
specifier|private
name|LoginContext
name|getLogin
parameter_list|()
block|{
return|return
name|user
operator|.
name|getLogin
argument_list|()
return|;
block|}
DECL|method|setLogin (LoginContext login)
specifier|private
name|void
name|setLogin
parameter_list|(
name|LoginContext
name|login
parameter_list|)
block|{
name|user
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a UserGroupInformation for the given subject.    * This does not change the subject or acquire new credentials.    *    * The creator of subject is responsible for renewing credentials.    * @param subject the user's subject    */
DECL|method|UserGroupInformation (Subject subject)
name|UserGroupInformation
parameter_list|(
name|Subject
name|subject
parameter_list|)
block|{
name|this
argument_list|(
name|subject
argument_list|,
name|treatSubjectExternal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a UGI from the given subject.    * @param subject the subject    * @param isLoginExternal if the subject's keytab is managed by other UGI.    *                       Setting this to true will prevent UGI from attempting    *                       to login the keytab, or to renew it.    */
DECL|method|UserGroupInformation (Subject subject, final boolean isLoginExternal)
specifier|private
name|UserGroupInformation
parameter_list|(
name|Subject
name|subject
parameter_list|,
specifier|final
name|boolean
name|isLoginExternal
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
name|this
operator|.
name|user
operator|=
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
name|this
operator|.
name|isKeytab
operator|=
name|KerberosUtil
operator|.
name|hasKerberosKeyTab
argument_list|(
name|subject
argument_list|)
expr_stmt|;
name|this
operator|.
name|isKrbTkt
operator|=
name|KerberosUtil
operator|.
name|hasKerberosTicket
argument_list|(
name|subject
argument_list|)
expr_stmt|;
name|this
operator|.
name|isLoginExternal
operator|=
name|isLoginExternal
expr_stmt|;
block|}
comment|/**    * checks if logged in using kerberos    * @return true if the subject logged via keytab or has a Kerberos TGT    */
DECL|method|hasKerberosCredentials ()
specifier|public
name|boolean
name|hasKerberosCredentials
parameter_list|()
block|{
return|return
name|isKeytab
operator|||
name|isKrbTkt
return|;
block|}
comment|/**    * Return the current user, including any doAs in the current stack.    * @return the current user    * @throws IOException if login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|synchronized
DECL|method|getCurrentUser ()
specifier|static
name|UserGroupInformation
name|getCurrentUser
parameter_list|()
throws|throws
name|IOException
block|{
name|AccessControlContext
name|context
init|=
name|AccessController
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|Subject
name|subject
init|=
name|Subject
operator|.
name|getSubject
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|subject
operator|==
literal|null
operator|||
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|getLoginUser
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
return|;
block|}
block|}
comment|/**    * Find the most appropriate UserGroupInformation to use    *    * @param ticketCachePath    The Kerberos ticket cache path, or NULL    *                           if none is specfied    * @param user               The user name, or NULL if none is specified.    *    * @return                   The most appropriate UserGroupInformation    */
DECL|method|getBestUGI ( String ticketCachePath, String user)
specifier|public
specifier|static
name|UserGroupInformation
name|getBestUGI
parameter_list|(
name|String
name|ticketCachePath
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ticketCachePath
operator|!=
literal|null
condition|)
block|{
return|return
name|getUGIFromTicketCache
argument_list|(
name|ticketCachePath
argument_list|,
name|user
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
return|return
name|getCurrentUser
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|createRemoteUser
argument_list|(
name|user
argument_list|)
return|;
block|}
block|}
comment|/**    * Create a UserGroupInformation from a Kerberos ticket cache.    *     * @param user                The principal name to load from the ticket    *                            cache    * @param ticketCache     the path to the ticket cache file    *    * @throws IOException        if the kerberos login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getUGIFromTicketCache ( String ticketCache, String user)
specifier|public
specifier|static
name|UserGroupInformation
name|getUGIFromTicketCache
parameter_list|(
name|String
name|ticketCache
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isAuthenticationMethodEnabled
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
condition|)
block|{
return|return
name|getBestUGI
argument_list|(
literal|null
argument_list|,
name|user
argument_list|)
return|;
block|}
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|krbOptions
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
name|krbOptions
operator|.
name|put
argument_list|(
literal|"useDefaultCcache"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// The first value searched when "useDefaultCcache" is used.
name|System
operator|.
name|setProperty
argument_list|(
literal|"KRB5CCNAME"
argument_list|,
name|ticketCache
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|krbOptions
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"useTicketCache"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"useKeyTab"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"ticketCache"
argument_list|,
name|ticketCache
argument_list|)
expr_stmt|;
block|}
name|krbOptions
operator|.
name|put
argument_list|(
literal|"renewTGT"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|putAll
argument_list|(
name|HadoopConfiguration
operator|.
name|BASIC_JAAS_OPTIONS
argument_list|)
expr_stmt|;
name|AppConfigurationEntry
name|ace
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|KerberosUtil
operator|.
name|getKrb5LoginModuleName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|krbOptions
argument_list|)
decl_stmt|;
name|DynamicConfiguration
name|dynConf
init|=
operator|new
name|DynamicConfiguration
argument_list|(
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|ace
block|}
argument_list|)
decl_stmt|;
name|LoginContext
name|login
init|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|USER_KERBEROS_CONFIG_NAME
argument_list|,
literal|null
argument_list|,
name|dynConf
argument_list|)
decl_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|Subject
name|loginSubject
init|=
name|login
operator|.
name|getSubject
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Principal
argument_list|>
name|loginPrincipals
init|=
name|loginSubject
operator|.
name|getPrincipals
argument_list|()
decl_stmt|;
if|if
condition|(
name|loginPrincipals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No login principals found!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|loginPrincipals
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"found more than one principal in the ticket cache file "
operator|+
name|ticketCache
argument_list|)
expr_stmt|;
block|}
name|User
name|ugiUser
init|=
operator|new
name|User
argument_list|(
name|loginPrincipals
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|,
name|login
argument_list|)
decl_stmt|;
name|loginSubject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
name|ugiUser
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|loginSubject
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|ugi
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
name|ugi
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
name|KerberosAuthException
name|kae
init|=
operator|new
name|KerberosAuthException
argument_list|(
name|FAILURE_TO_LOGIN
argument_list|,
name|le
argument_list|)
decl_stmt|;
name|kae
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|kae
operator|.
name|setTicketCacheFile
argument_list|(
name|ticketCache
argument_list|)
expr_stmt|;
throw|throw
name|kae
throw|;
block|}
block|}
comment|/**    * Create a UserGroupInformation from a Subject with Kerberos principal.    *    * @param subject             The KerberosPrincipal to use in UGI.    *                            The creator of subject is responsible for    *                            renewing credentials.    *    * @throws IOException    * @throws KerberosAuthException if the kerberos login fails    */
DECL|method|getUGIFromSubject (Subject subject)
specifier|public
specifier|static
name|UserGroupInformation
name|getUGIFromSubject
parameter_list|(
name|Subject
name|subject
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|subject
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|SUBJECT_MUST_NOT_BE_NULL
argument_list|)
throw|;
block|}
if|if
condition|(
name|subject
operator|.
name|getPrincipals
argument_list|(
name|KerberosPrincipal
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|SUBJECT_MUST_CONTAIN_PRINCIPAL
argument_list|)
throw|;
block|}
name|KerberosPrincipal
name|principal
init|=
name|subject
operator|.
name|getPrincipals
argument_list|(
name|KerberosPrincipal
operator|.
name|class
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|User
name|ugiUser
init|=
operator|new
name|User
argument_list|(
name|principal
operator|.
name|getName
argument_list|()
argument_list|,
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
name|ugiUser
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
decl_stmt|;
name|ugi
operator|.
name|setLogin
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|ugi
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
comment|/**    * Get the currently logged in user.    * @return the logged in user    * @throws IOException if login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|synchronized
DECL|method|getLoginUser ()
specifier|static
name|UserGroupInformation
name|getLoginUser
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|loginUser
operator|==
literal|null
condition|)
block|{
name|loginUserFromSubject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|loginUser
return|;
block|}
comment|/**    * remove the login method that is followed by a space from the username    * e.g. "jack (auth:SIMPLE)" -> "jack"    *    * @param userName    * @return userName without login method    */
DECL|method|trimLoginMethod (String userName)
specifier|public
specifier|static
name|String
name|trimLoginMethod
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
name|int
name|spaceIndex
init|=
name|userName
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|spaceIndex
operator|>=
literal|0
condition|)
block|{
name|userName
operator|=
name|userName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|spaceIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|userName
return|;
block|}
comment|/**    * Log in a user using the given subject    * @param subject the subject to use when logging in a user, or null to    * create a new subject.    *    * If subject is not null, the creator of subject is responsible for renewing    * credentials.    *    * @throws IOException if login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|synchronized
DECL|method|loginUserFromSubject (Subject subject)
specifier|static
name|void
name|loginUserFromSubject
parameter_list|(
name|Subject
name|subject
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|boolean
name|externalSubject
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|subject
operator|==
literal|null
condition|)
block|{
name|subject
operator|=
operator|new
name|Subject
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Treat subject external: "
operator|+
name|treatSubjectExternal
operator|+
literal|". When true, assuming keytab is managed extenally since "
operator|+
literal|" logged in from subject"
argument_list|)
expr_stmt|;
block|}
name|externalSubject
operator|=
name|treatSubjectExternal
expr_stmt|;
block|}
name|LoginContext
name|login
init|=
name|newLoginContext
argument_list|(
name|authenticationMethod
operator|.
name|getLoginAppName
argument_list|()
argument_list|,
name|subject
argument_list|,
operator|new
name|HadoopConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|realUser
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|,
name|externalSubject
argument_list|)
decl_stmt|;
name|realUser
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
name|realUser
operator|.
name|setAuthenticationMethod
argument_list|(
name|authenticationMethod
argument_list|)
expr_stmt|;
comment|// If the HADOOP_PROXY_USER environment variable or property
comment|// is specified, create a proxy user as the logged in user.
name|String
name|proxyUser
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_PROXY_USER
argument_list|)
decl_stmt|;
if|if
condition|(
name|proxyUser
operator|==
literal|null
condition|)
block|{
name|proxyUser
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_PROXY_USER
argument_list|)
expr_stmt|;
block|}
name|loginUser
operator|=
name|proxyUser
operator|==
literal|null
condition|?
name|realUser
else|:
name|createProxyUser
argument_list|(
name|proxyUser
argument_list|,
name|realUser
argument_list|)
expr_stmt|;
name|String
name|tokenFileLocation
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_TOKEN_FILES
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenFileLocation
operator|==
literal|null
condition|)
block|{
name|tokenFileLocation
operator|=
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_TOKEN_FILES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tokenFileLocation
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|tokenFileName
range|:
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|tokenFileLocation
argument_list|)
control|)
block|{
if|if
condition|(
name|tokenFileName
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|File
name|tokenFile
init|=
operator|new
name|File
argument_list|(
name|tokenFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenFile
operator|.
name|exists
argument_list|()
operator|&&
name|tokenFile
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|Credentials
name|cred
init|=
name|Credentials
operator|.
name|readTokenStorageFile
argument_list|(
name|tokenFile
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|loginUser
operator|.
name|addCredentials
argument_list|(
name|cred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"tokenFile("
operator|+
name|tokenFileName
operator|+
literal|") does not exist"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|String
name|fileLocation
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_TOKEN_FILE_LOCATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileLocation
operator|!=
literal|null
condition|)
block|{
comment|// Load the token storage file and put all of the tokens into the
comment|// user. Don't use the FileSystem API for reading since it has a lock
comment|// cycle (HADOOP-9212).
name|File
name|source
init|=
operator|new
name|File
argument_list|(
name|fileLocation
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reading credentials from location set in {}: {}"
argument_list|,
name|HADOOP_TOKEN_FILE_LOCATION
argument_list|,
name|source
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|source
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Source file "
operator|+
name|source
operator|.
name|getCanonicalPath
argument_list|()
operator|+
literal|" from "
operator|+
name|HADOOP_TOKEN_FILE_LOCATION
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
name|Credentials
name|cred
init|=
name|Credentials
operator|.
name|readTokenStorageFile
argument_list|(
name|source
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loaded {} tokens"
argument_list|,
name|cred
operator|.
name|numberOfTokens
argument_list|()
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|addCredentials
argument_list|(
name|cred
argument_list|)
expr_stmt|;
block|}
name|loginUser
operator|.
name|spawnAutoRenewalThreadForUserCreds
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failure to login"
argument_list|,
name|le
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|FAILURE_TO_LOGIN
argument_list|,
name|le
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"UGI loginUser:"
operator|+
name|loginUser
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|VisibleForTesting
DECL|method|setLoginUser (UserGroupInformation ugi)
specifier|public
specifier|synchronized
specifier|static
name|void
name|setLoginUser
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
comment|// if this is to become stable, should probably logout the currently
comment|// logged in ugi if it's different
name|loginUser
operator|=
name|ugi
expr_stmt|;
block|}
comment|/**    * Is this user logged in from a keytab file?    * @return true if the credentials are from a keytab file.    */
DECL|method|isFromKeytab ()
specifier|public
name|boolean
name|isFromKeytab
parameter_list|()
block|{
return|return
name|isKeytab
return|;
block|}
comment|/**    * Get the Kerberos TGT    * @return the user's TGT or null if none was found    */
DECL|method|getTGT ()
specifier|private
specifier|synchronized
name|KerberosTicket
name|getTGT
parameter_list|()
block|{
name|Set
argument_list|<
name|KerberosTicket
argument_list|>
name|tickets
init|=
name|subject
operator|.
name|getPrivateCredentials
argument_list|(
name|KerberosTicket
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|KerberosTicket
name|ticket
range|:
name|tickets
control|)
block|{
if|if
condition|(
name|SecurityUtil
operator|.
name|isOriginalTGT
argument_list|(
name|ticket
argument_list|)
condition|)
block|{
return|return
name|ticket
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getRefreshTime (KerberosTicket tgt)
specifier|private
name|long
name|getRefreshTime
parameter_list|(
name|KerberosTicket
name|tgt
parameter_list|)
block|{
name|long
name|start
init|=
name|tgt
operator|.
name|getStartTime
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|long
name|end
init|=
name|tgt
operator|.
name|getEndTime
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
return|return
name|start
operator|+
call|(
name|long
call|)
argument_list|(
operator|(
name|end
operator|-
name|start
operator|)
operator|*
name|TICKET_RENEW_WINDOW
argument_list|)
return|;
block|}
comment|/**    * Should relogin if security is enabled using Kerberos, and    * the Subject is not owned by another UGI.    * @return true if this UGI should relogin    */
DECL|method|shouldRelogin ()
specifier|private
name|boolean
name|shouldRelogin
parameter_list|()
block|{
return|return
name|isSecurityEnabled
argument_list|()
operator|&&
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|==
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|&&
operator|!
name|isLoginExternal
return|;
block|}
comment|/**Spawn a thread to do periodic renewals of kerberos credentials*/
DECL|method|spawnAutoRenewalThreadForUserCreds ()
specifier|private
name|void
name|spawnAutoRenewalThreadForUserCreds
parameter_list|()
block|{
if|if
condition|(
name|getEnableRenewThreadCreationForTest
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Spawning thread to auto renew user credential since "
operator|+
literal|" enableRenewThreadCreationForTest was set to true."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|shouldRelogin
argument_list|()
operator|||
name|isKeytab
condition|)
block|{
return|return;
block|}
comment|//spawn thread only if we have kerb credentials
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|String
name|cmd
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hadoop.kerberos.kinit.command"
argument_list|,
literal|"kinit"
argument_list|)
decl_stmt|;
name|KerberosTicket
name|tgt
init|=
name|getTGT
argument_list|()
decl_stmt|;
if|if
condition|(
name|tgt
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|long
name|nextRefresh
init|=
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
decl_stmt|;
name|RetryPolicy
name|rp
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Current time is "
operator|+
name|now
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Next refresh is "
operator|+
name|nextRefresh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|now
operator|<
name|nextRefresh
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|nextRefresh
operator|-
name|now
argument_list|)
expr_stmt|;
block|}
name|Shell
operator|.
name|execCommand
argument_list|(
name|cmd
argument_list|,
literal|"-R"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"renewed ticket"
argument_list|)
expr_stmt|;
block|}
name|reloginFromTicketCache
argument_list|()
expr_stmt|;
name|tgt
operator|=
name|getTGT
argument_list|()
expr_stmt|;
if|if
condition|(
name|tgt
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No TGT after renewal. Aborting renew thread for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|nextRefresh
operator|=
name|Math
operator|.
name|max
argument_list|(
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
argument_list|,
name|now
operator|+
name|kerberosMinSecondsBeforeRelogin
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|renewalFailures
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rp
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Terminating renewal thread"
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|metrics
operator|.
name|renewalFailuresTotal
operator|.
name|incr
argument_list|()
expr_stmt|;
specifier|final
name|long
name|tgtEndTime
init|=
name|tgt
operator|.
name|getEndTime
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception encountered while running the renewal "
operator|+
literal|"command for {}. (TGT end time:{}, renewalFailures: {},"
operator|+
literal|"renewalFailuresTotal: {})"
argument_list|,
name|getUserName
argument_list|()
argument_list|,
name|tgtEndTime
argument_list|,
name|metrics
operator|.
name|renewalFailures
argument_list|,
name|metrics
operator|.
name|renewalFailuresTotal
argument_list|,
name|ie
argument_list|)
expr_stmt|;
specifier|final
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|rp
operator|==
literal|null
condition|)
block|{
comment|// Use a dummy maxRetries to create the policy. The policy will
comment|// only be used to get next retry time with exponential back-off.
comment|// The final retry time will be later limited within the
comment|// tgt endTime in getNextTgtRenewalTime.
name|rp
operator|=
name|RetryPolicies
operator|.
name|exponentialBackoffRetry
argument_list|(
name|Long
operator|.
name|SIZE
operator|-
literal|2
argument_list|,
name|kerberosMinSecondsBeforeRelogin
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|nextRefresh
operator|=
name|getNextTgtRenewalTime
argument_list|(
name|tgtEndTime
argument_list|,
name|now
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception when calculating next tgt renewal time"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|metrics
operator|.
name|renewalFailures
operator|.
name|incr
argument_list|()
expr_stmt|;
comment|// retry until close enough to tgt endTime.
if|if
condition|(
name|now
operator|>
name|nextRefresh
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"TGT is expired. Aborting renew thread for {}."
argument_list|,
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
argument_list|)
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"TGT Renewer for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get time for next login retry. This will allow the thread to retry with    * exponential back-off, until tgt endtime.    * Last retry is {@link #kerberosMinSecondsBeforeRelogin} before endtime.    *    * @param tgtEndTime EndTime of the tgt.    * @param now Current time.    * @param rp The retry policy.    * @return Time for next login retry.    */
annotation|@
name|VisibleForTesting
DECL|method|getNextTgtRenewalTime (final long tgtEndTime, final long now, final RetryPolicy rp)
specifier|static
name|long
name|getNextTgtRenewalTime
parameter_list|(
specifier|final
name|long
name|tgtEndTime
parameter_list|,
specifier|final
name|long
name|now
parameter_list|,
specifier|final
name|RetryPolicy
name|rp
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|long
name|lastRetryTime
init|=
name|tgtEndTime
operator|-
name|kerberosMinSecondsBeforeRelogin
decl_stmt|;
specifier|final
name|RetryPolicy
operator|.
name|RetryAction
name|ra
init|=
name|rp
operator|.
name|shouldRetry
argument_list|(
literal|null
argument_list|,
name|metrics
operator|.
name|renewalFailures
operator|.
name|value
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|Math
operator|.
name|min
argument_list|(
name|lastRetryTime
argument_list|,
name|now
operator|+
name|ra
operator|.
name|delayMillis
argument_list|)
return|;
block|}
comment|/**    * Log a user in from a keytab file. Loads a user identity from a keytab    * file and logs them in. They become the currently logged-in user.    * @param user the principal name to load from the keytab    * @param path the path to the keytab file    * @throws IOException    * @throws KerberosAuthException if it's a kerberos login exception.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|synchronized
DECL|method|loginUserFromKeytab (String user, String path )
specifier|static
name|void
name|loginUserFromKeytab
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
return|return;
name|keytabFile
operator|=
name|path
expr_stmt|;
name|keytabPrincipal
operator|=
name|user
expr_stmt|;
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|LoginContext
name|login
decl_stmt|;
name|long
name|start
init|=
literal|0
decl_stmt|;
try|try
block|{
name|login
operator|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|KEYTAB_KERBEROS_CONFIG_NAME
argument_list|,
name|subject
argument_list|,
operator|new
name|HadoopConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|start
operator|=
name|Time
operator|.
name|now
argument_list|()
expr_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|loginSuccess
operator|.
name|add
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
name|loginUser
operator|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|loginFailure
operator|.
name|add
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
name|KerberosAuthException
name|kae
init|=
operator|new
name|KerberosAuthException
argument_list|(
name|LOGIN_FAILURE
argument_list|,
name|le
argument_list|)
decl_stmt|;
name|kae
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|kae
operator|.
name|setKeytabFile
argument_list|(
name|path
argument_list|)
expr_stmt|;
throw|throw
name|kae
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Login successful for user "
operator|+
name|keytabPrincipal
operator|+
literal|" using keytab file "
operator|+
name|keytabFile
argument_list|)
expr_stmt|;
block|}
comment|/**    * Log the current user out who previously logged in using keytab.    * This method assumes that the user logged in by calling    * {@link #loginUserFromKeytab(String, String)}.    *    * @throws IOException    * @throws KerberosAuthException if a failure occurred in logout,    * or if the user did not log in by invoking loginUserFromKeyTab() before.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|logoutUserFromKeytab ()
specifier|public
name|void
name|logoutUserFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
operator|||
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
condition|)
block|{
return|return;
block|}
name|LoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|login
operator|==
literal|null
operator|||
name|keytabFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|MUST_FIRST_LOGIN_FROM_KEYTAB
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initiating logout for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|UserGroupInformation
operator|.
name|class
init|)
block|{
name|login
operator|.
name|logout
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
name|KerberosAuthException
name|kae
init|=
operator|new
name|KerberosAuthException
argument_list|(
name|LOGOUT_FAILURE
argument_list|,
name|le
argument_list|)
decl_stmt|;
name|kae
operator|.
name|setUser
argument_list|(
name|user
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|kae
operator|.
name|setKeytabFile
argument_list|(
name|keytabFile
argument_list|)
expr_stmt|;
throw|throw
name|kae
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Logout successful for user "
operator|+
name|keytabPrincipal
operator|+
literal|" using keytab file "
operator|+
name|keytabFile
argument_list|)
expr_stmt|;
block|}
comment|/**    * Re-login a user from keytab if TGT is expired or is close to expiry.    *     * @throws IOException    * @throws KerberosAuthException if it's a kerberos login exception.    */
DECL|method|checkTGTAndReloginFromKeytab ()
specifier|public
specifier|synchronized
name|void
name|checkTGTAndReloginFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
operator|||
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|||
operator|!
name|isKeytab
condition|)
block|{
return|return;
block|}
name|KerberosTicket
name|tgt
init|=
name|getTGT
argument_list|()
decl_stmt|;
if|if
condition|(
name|tgt
operator|!=
literal|null
operator|&&
operator|!
name|shouldRenewImmediatelyForTests
operator|&&
name|Time
operator|.
name|now
argument_list|()
operator|<
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
condition|)
block|{
return|return;
block|}
name|reloginFromKeytab
argument_list|()
expr_stmt|;
block|}
comment|// if the first kerberos ticket is not TGT, then remove and destroy it since
comment|// the kerberos library of jdk always use the first kerberos ticket as TGT.
comment|// See HADOOP-13433 for more details.
annotation|@
name|VisibleForTesting
DECL|method|fixKerberosTicketOrder ()
name|void
name|fixKerberosTicketOrder
parameter_list|()
block|{
name|Set
argument_list|<
name|Object
argument_list|>
name|creds
init|=
name|getSubject
argument_list|()
operator|.
name|getPrivateCredentials
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|creds
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|iter
init|=
name|creds
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|cred
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|cred
operator|instanceof
name|KerberosTicket
condition|)
block|{
name|KerberosTicket
name|ticket
init|=
operator|(
name|KerberosTicket
operator|)
name|cred
decl_stmt|;
if|if
condition|(
operator|!
name|ticket
operator|.
name|getServer
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"krbtgt"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The first kerberos ticket is not TGT"
operator|+
literal|"(the server principal is {}), remove and destroy it."
argument_list|,
name|ticket
operator|.
name|getServer
argument_list|()
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
name|ticket
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DestroyFailedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"destroy ticket failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return;
block|}
block|}
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Warning, no kerberos ticket found while attempting to renew ticket"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Re-Login a user in from a keytab file. Loads a user identity from a keytab    * file and logs them in. They become the currently logged-in user. This    * method assumes that {@link #loginUserFromKeytab(String, String)} had    * happened already.    * The Subject field of this UserGroupInformation object is updated to have    * the new credentials.    * @throws IOException    * @throws KerberosAuthException on a failure    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|reloginFromKeytab ()
specifier|public
specifier|synchronized
name|void
name|reloginFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|shouldRelogin
argument_list|()
operator|||
operator|!
name|isKeytab
condition|)
block|{
return|return;
block|}
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|shouldRenewImmediatelyForTests
operator|&&
operator|!
name|hasSufficientTimeElapsed
argument_list|(
name|now
argument_list|)
condition|)
block|{
return|return;
block|}
name|KerberosTicket
name|tgt
init|=
name|getTGT
argument_list|()
decl_stmt|;
comment|//Return if TGT is valid and is not going to expire soon.
if|if
condition|(
name|tgt
operator|!=
literal|null
operator|&&
operator|!
name|shouldRenewImmediatelyForTests
operator|&&
name|now
operator|<
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
condition|)
block|{
return|return;
block|}
name|LoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|login
operator|==
literal|null
operator|||
name|keytabFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|MUST_FIRST_LOGIN_FROM_KEYTAB
argument_list|)
throw|;
block|}
name|long
name|start
init|=
literal|0
decl_stmt|;
comment|// register most recent relogin attempt
name|user
operator|.
name|setLastLogin
argument_list|(
name|now
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initiating logout for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|UserGroupInformation
operator|.
name|class
init|)
block|{
comment|// clear up the kerberos state. But the tokens are not cleared! As per
comment|// the Java kerberos login module code, only the kerberos credentials
comment|// are cleared
name|login
operator|.
name|logout
argument_list|()
expr_stmt|;
comment|// login and also update the subject field of this instance to
comment|// have the new credentials (pass it to the LoginContext constructor)
name|login
operator|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|KEYTAB_KERBEROS_CONFIG_NAME
argument_list|,
name|getSubject
argument_list|()
argument_list|,
operator|new
name|HadoopConfiguration
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initiating re-login for "
operator|+
name|keytabPrincipal
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|Time
operator|.
name|now
argument_list|()
expr_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|fixKerberosTicketOrder
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|loginSuccess
operator|.
name|add
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|loginFailure
operator|.
name|add
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
name|KerberosAuthException
name|kae
init|=
operator|new
name|KerberosAuthException
argument_list|(
name|LOGIN_FAILURE
argument_list|,
name|le
argument_list|)
decl_stmt|;
name|kae
operator|.
name|setPrincipal
argument_list|(
name|keytabPrincipal
argument_list|)
expr_stmt|;
name|kae
operator|.
name|setKeytabFile
argument_list|(
name|keytabFile
argument_list|)
expr_stmt|;
throw|throw
name|kae
throw|;
block|}
block|}
comment|/**    * Re-Login a user in from the ticket cache.  This    * method assumes that login had happened already.    * The Subject field of this UserGroupInformation object is updated to have    * the new credentials.    * @throws IOException    * @throws KerberosAuthException on a failure    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|reloginFromTicketCache ()
specifier|public
specifier|synchronized
name|void
name|reloginFromTicketCache
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|shouldRelogin
argument_list|()
operator|||
operator|!
name|isKrbTkt
condition|)
block|{
return|return;
block|}
name|LoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|login
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|MUST_FIRST_LOGIN
argument_list|)
throw|;
block|}
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasSufficientTimeElapsed
argument_list|(
name|now
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// register most recent relogin attempt
name|user
operator|.
name|setLastLogin
argument_list|(
name|now
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initiating logout for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//clear up the kerberos state. But the tokens are not cleared! As per
comment|//the Java kerberos login module code, only the kerberos credentials
comment|//are cleared
name|login
operator|.
name|logout
argument_list|()
expr_stmt|;
comment|//login and also update the subject field of this instance to
comment|//have the new credentials (pass it to the LoginContext constructor)
name|login
operator|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|USER_KERBEROS_CONFIG_NAME
argument_list|,
name|getSubject
argument_list|()
argument_list|,
operator|new
name|HadoopConfiguration
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initiating re-login for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|fixKerberosTicketOrder
argument_list|()
expr_stmt|;
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
name|KerberosAuthException
name|kae
init|=
operator|new
name|KerberosAuthException
argument_list|(
name|LOGIN_FAILURE
argument_list|,
name|le
argument_list|)
decl_stmt|;
name|kae
operator|.
name|setUser
argument_list|(
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|kae
throw|;
block|}
block|}
comment|/**    * Log a user in from a keytab file. Loads a user identity from a keytab    * file and login them in. This new user does not affect the currently    * logged-in user.    * @param user the principal name to load from the keytab    * @param path the path to the keytab file    * @throws IOException if the keytab file can't be read    */
specifier|public
specifier|synchronized
DECL|method|loginUserFromKeytabAndReturnUGI (String user, String path )
specifier|static
name|UserGroupInformation
name|loginUserFromKeytabAndReturnUGI
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
return|return
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
return|;
name|String
name|oldKeytabFile
init|=
literal|null
decl_stmt|;
name|String
name|oldKeytabPrincipal
init|=
literal|null
decl_stmt|;
name|long
name|start
init|=
literal|0
decl_stmt|;
try|try
block|{
name|oldKeytabFile
operator|=
name|keytabFile
expr_stmt|;
name|oldKeytabPrincipal
operator|=
name|keytabPrincipal
expr_stmt|;
name|keytabFile
operator|=
name|path
expr_stmt|;
name|keytabPrincipal
operator|=
name|user
expr_stmt|;
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|LoginContext
name|login
init|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|KEYTAB_KERBEROS_CONFIG_NAME
argument_list|,
name|subject
argument_list|,
operator|new
name|HadoopConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|start
operator|=
name|Time
operator|.
name|now
argument_list|()
expr_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|loginSuccess
operator|.
name|add
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|newLoginUser
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|newLoginUser
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
name|newLoginUser
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
expr_stmt|;
return|return
name|newLoginUser
return|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|loginFailure
operator|.
name|add
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
name|KerberosAuthException
name|kae
init|=
operator|new
name|KerberosAuthException
argument_list|(
name|LOGIN_FAILURE
argument_list|,
name|le
argument_list|)
decl_stmt|;
name|kae
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|kae
operator|.
name|setKeytabFile
argument_list|(
name|path
argument_list|)
expr_stmt|;
throw|throw
name|kae
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|oldKeytabFile
operator|!=
literal|null
condition|)
name|keytabFile
operator|=
name|oldKeytabFile
expr_stmt|;
if|if
condition|(
name|oldKeytabPrincipal
operator|!=
literal|null
condition|)
name|keytabPrincipal
operator|=
name|oldKeytabPrincipal
expr_stmt|;
block|}
block|}
DECL|method|hasSufficientTimeElapsed (long now)
specifier|private
name|boolean
name|hasSufficientTimeElapsed
parameter_list|(
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|now
operator|-
name|user
operator|.
name|getLastLogin
argument_list|()
operator|<
name|kerberosMinSecondsBeforeRelogin
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not attempting to re-login since the last re-login was "
operator|+
literal|"attempted less than "
operator|+
operator|(
name|kerberosMinSecondsBeforeRelogin
operator|/
literal|1000
operator|)
operator|+
literal|" seconds before. Last Login="
operator|+
name|user
operator|.
name|getLastLogin
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Did the login happen via keytab    * @return true or false    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|isLoginKeytabBased ()
specifier|public
specifier|synchronized
specifier|static
name|boolean
name|isLoginKeytabBased
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getLoginUser
argument_list|()
operator|.
name|isKeytab
return|;
block|}
comment|/**    * Did the login happen via ticket cache    * @return true or false    */
DECL|method|isLoginTicketBased ()
specifier|public
specifier|static
name|boolean
name|isLoginTicketBased
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getLoginUser
argument_list|()
operator|.
name|isKrbTkt
return|;
block|}
comment|/**    * Create a user from a login name. It is intended to be used for remote    * users in RPC, since it won't have any credentials.    * @param user the full user principal name, must not be empty or null    * @return the UserGroupInformation for the remote user.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createRemoteUser (String user)
specifier|public
specifier|static
name|UserGroupInformation
name|createRemoteUser
parameter_list|(
name|String
name|user
parameter_list|)
block|{
return|return
name|createRemoteUser
argument_list|(
name|user
argument_list|,
name|AuthMethod
operator|.
name|SIMPLE
argument_list|)
return|;
block|}
comment|/**    * Create a user from a login name. It is intended to be used for remote    * users in RPC, since it won't have any credentials.    * @param user the full user principal name, must not be empty or null    * @return the UserGroupInformation for the remote user.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createRemoteUser (String user, AuthMethod authMethod)
specifier|public
specifier|static
name|UserGroupInformation
name|createRemoteUser
parameter_list|(
name|String
name|user
parameter_list|,
name|AuthMethod
name|authMethod
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
literal|null
operator|||
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null user"
argument_list|)
throw|;
block|}
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|result
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|result
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * existing types of authentications' methods    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|enum|AuthenticationMethod
specifier|public
enum|enum
name|AuthenticationMethod
block|{
comment|// currently we support only one auth per method, but eventually a
comment|// subtype is needed to differentiate, ex. if digest is token or ldap
DECL|enumConstant|SIMPLE
name|SIMPLE
parameter_list|(
name|AuthMethod
operator|.
name|SIMPLE
parameter_list|,
name|HadoopConfiguration
operator|.
name|SIMPLE_CONFIG_NAME
parameter_list|)
operator|,
DECL|enumConstant|KERBEROS
constructor|KERBEROS(AuthMethod.KERBEROS
operator|,
constructor|HadoopConfiguration.USER_KERBEROS_CONFIG_NAME
block|)
enum|,
DECL|enumConstant|TOKEN
name|TOKEN
parameter_list|(
name|AuthMethod
operator|.
name|TOKEN
parameter_list|)
operator|,
DECL|enumConstant|CERTIFICATE
constructor|CERTIFICATE(null
block|)
operator|,
DECL|enumConstant|KERBEROS_SSL
name|KERBEROS_SSL
argument_list|(
literal|null
argument_list|)
operator|,
DECL|enumConstant|PROXY
name|PROXY
argument_list|(
literal|null
argument_list|)
expr_stmt|;
end_class

begin_decl_stmt
DECL|field|authMethod
specifier|private
specifier|final
name|AuthMethod
name|authMethod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|loginAppName
specifier|private
specifier|final
name|String
name|loginAppName
decl_stmt|;
end_decl_stmt

begin_constructor
DECL|method|AuthenticationMethod (AuthMethod authMethod)
specifier|private
name|AuthenticationMethod
parameter_list|(
name|AuthMethod
name|authMethod
parameter_list|)
block|{
name|this
argument_list|(
name|authMethod
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
end_constructor

begin_constructor
DECL|method|AuthenticationMethod (AuthMethod authMethod, String loginAppName)
specifier|private
name|AuthenticationMethod
parameter_list|(
name|AuthMethod
name|authMethod
parameter_list|,
name|String
name|loginAppName
parameter_list|)
block|{
name|this
operator|.
name|authMethod
operator|=
name|authMethod
expr_stmt|;
name|this
operator|.
name|loginAppName
operator|=
name|loginAppName
expr_stmt|;
block|}
end_constructor

begin_function
DECL|method|getAuthMethod ()
specifier|public
name|AuthMethod
name|getAuthMethod
parameter_list|()
block|{
return|return
name|authMethod
return|;
block|}
end_function

begin_function
DECL|method|getLoginAppName ()
name|String
name|getLoginAppName
parameter_list|()
block|{
if|if
condition|(
name|loginAppName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" login authentication is not supported"
argument_list|)
throw|;
block|}
return|return
name|loginAppName
return|;
block|}
end_function

begin_function
DECL|method|valueOf (AuthMethod authMethod)
specifier|public
specifier|static
name|AuthenticationMethod
name|valueOf
parameter_list|(
name|AuthMethod
name|authMethod
parameter_list|)
block|{
for|for
control|(
name|AuthenticationMethod
name|value
range|:
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|value
operator|.
name|getAuthMethod
argument_list|()
operator|==
name|authMethod
condition|)
block|{
return|return
name|value
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"no authentication method for "
operator|+
name|authMethod
argument_list|)
throw|;
block|}
end_function

begin_comment
unit|};
comment|/**    * Create a proxy user using username of the effective user and the ugi of the    * real user.    * @param user    * @param realUser    * @return proxyUser ugi    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createProxyUser (String user, UserGroupInformation realUser)
specifier|public
specifier|static
name|UserGroupInformation
name|createProxyUser
parameter_list|(
name|String
name|user
parameter_list|,
name|UserGroupInformation
name|realUser
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
literal|null
operator|||
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null user"
argument_list|)
throw|;
block|}
if|if
condition|(
name|realUser
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null real user"
argument_list|)
throw|;
block|}
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Principal
argument_list|>
name|principals
init|=
name|subject
operator|.
name|getPrincipals
argument_list|()
decl_stmt|;
name|principals
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|principals
operator|.
name|add
argument_list|(
operator|new
name|RealUser
argument_list|(
name|realUser
argument_list|)
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|result
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|result
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|PROXY
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**    * get RealUser (vs. EffectiveUser)    * @return realUser running over proxy user    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getRealUser ()
specifier|public
name|UserGroupInformation
name|getRealUser
parameter_list|()
block|{
for|for
control|(
name|RealUser
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|RealUser
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getRealUser
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
end_function

begin_comment
comment|/**    * This class is used for storing the groups for testing. It stores a local    * map that has the translation of usernames to groups.    */
end_comment

begin_class
DECL|class|TestingGroups
specifier|private
specifier|static
class|class
name|TestingGroups
extends|extends
name|Groups
block|{
DECL|field|userToGroupsMapping
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|userToGroupsMapping
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|underlyingImplementation
specifier|private
name|Groups
name|underlyingImplementation
decl_stmt|;
DECL|method|TestingGroups (Groups underlyingImplementation)
specifier|private
name|TestingGroups
parameter_list|(
name|Groups
name|underlyingImplementation
parameter_list|)
block|{
name|super
argument_list|(
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|underlyingImplementation
operator|=
name|underlyingImplementation
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getGroups (String user)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getGroups
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|userToGroupsMapping
operator|.
name|get
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|underlyingImplementation
operator|.
name|getGroups
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|setUserGroups (String user, String[] groups)
specifier|private
name|void
name|setUserGroups
parameter_list|(
name|String
name|user
parameter_list|,
name|String
index|[]
name|groups
parameter_list|)
block|{
name|userToGroupsMapping
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|groups
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/**    * Create a UGI for testing HDFS and MapReduce    * @param user the full user principal name    * @param userGroups the names of the groups that the user belongs to    * @return a fake user for running unit tests    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createUserForTesting (String user, String[] userGroups)
specifier|public
specifier|static
name|UserGroupInformation
name|createUserForTesting
parameter_list|(
name|String
name|user
parameter_list|,
name|String
index|[]
name|userGroups
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|createRemoteUser
argument_list|(
name|user
argument_list|)
decl_stmt|;
comment|// make sure that the testing object is setup
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
operator|new
name|TestingGroups
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
comment|// add the user groups
operator|(
operator|(
name|TestingGroups
operator|)
name|groups
operator|)
operator|.
name|setUserGroups
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|userGroups
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
end_function

begin_comment
comment|/**    * Create a proxy user UGI for testing HDFS and MapReduce    *     * @param user    *          the full user principal name for effective user    * @param realUser    *          UGI of the real user    * @param userGroups    *          the names of the groups that the user belongs to    * @return a fake user for running unit tests    */
end_comment

begin_function
DECL|method|createProxyUserForTesting (String user, UserGroupInformation realUser, String[] userGroups)
specifier|public
specifier|static
name|UserGroupInformation
name|createProxyUserForTesting
parameter_list|(
name|String
name|user
parameter_list|,
name|UserGroupInformation
name|realUser
parameter_list|,
name|String
index|[]
name|userGroups
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|createProxyUser
argument_list|(
name|user
argument_list|,
name|realUser
argument_list|)
decl_stmt|;
comment|// make sure that the testing object is setup
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
operator|new
name|TestingGroups
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
comment|// add the user groups
operator|(
operator|(
name|TestingGroups
operator|)
name|groups
operator|)
operator|.
name|setUserGroups
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|userGroups
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
end_function

begin_comment
comment|/**    * Get the user's login name.    * @return the user's name up to the first '/' or '@'.    */
end_comment

begin_function
DECL|method|getShortUserName ()
specifier|public
name|String
name|getShortUserName
parameter_list|()
block|{
for|for
control|(
name|User
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getShortName
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
end_function

begin_function
DECL|method|getPrimaryGroupName ()
specifier|public
name|String
name|getPrimaryGroupName
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|groups
init|=
name|getGroups
argument_list|()
decl_stmt|;
if|if
condition|(
name|groups
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"There is no primary group for UGI "
operator|+
name|this
argument_list|)
throw|;
block|}
return|return
name|groups
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get the user's full principal name.    * @return the user's full principal name.    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getUserName ()
specifier|public
name|String
name|getUserName
parameter_list|()
block|{
return|return
name|user
operator|.
name|getName
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Add a TokenIdentifier to this UGI. The TokenIdentifier has typically been    * authenticated by the RPC layer as belonging to the user represented by this    * UGI.    *     * @param tokenId    *          tokenIdentifier to be added    * @return true on successful add of new tokenIdentifier    */
end_comment

begin_function
DECL|method|addTokenIdentifier (TokenIdentifier tokenId)
specifier|public
specifier|synchronized
name|boolean
name|addTokenIdentifier
parameter_list|(
name|TokenIdentifier
name|tokenId
parameter_list|)
block|{
return|return
name|subject
operator|.
name|getPublicCredentials
argument_list|()
operator|.
name|add
argument_list|(
name|tokenId
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get the set of TokenIdentifiers belonging to this UGI    *     * @return the set of TokenIdentifiers belonging to this UGI    */
end_comment

begin_function
DECL|method|getTokenIdentifiers ()
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|TokenIdentifier
argument_list|>
name|getTokenIdentifiers
parameter_list|()
block|{
return|return
name|subject
operator|.
name|getPublicCredentials
argument_list|(
name|TokenIdentifier
operator|.
name|class
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Add a token to this UGI    *     * @param token Token to be added    * @return true on successful add of new token    */
end_comment

begin_function
DECL|method|addToken (Token<? extends TokenIdentifier> token)
specifier|public
name|boolean
name|addToken
parameter_list|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
return|return
operator|(
name|token
operator|!=
literal|null
operator|)
condition|?
name|addToken
argument_list|(
name|token
operator|.
name|getService
argument_list|()
argument_list|,
name|token
argument_list|)
else|:
literal|false
return|;
block|}
end_function

begin_comment
comment|/**    * Add a named token to this UGI    *     * @param alias Name of the token    * @param token Token to be added    * @return true on successful add of new token    */
end_comment

begin_function
DECL|method|addToken (Text alias, Token<? extends TokenIdentifier> token)
specifier|public
name|boolean
name|addToken
parameter_list|(
name|Text
name|alias
parameter_list|,
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
synchronized|synchronized
init|(
name|subject
init|)
block|{
name|getCredentialsInternal
argument_list|()
operator|.
name|addToken
argument_list|(
name|alias
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Obtain the collection of tokens associated with this user.    *     * @return an unmodifiable collection of tokens associated with user    */
end_comment

begin_function
DECL|method|getTokens ()
specifier|public
name|Collection
argument_list|<
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|getTokens
parameter_list|()
block|{
synchronized|synchronized
init|(
name|subject
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|getCredentialsInternal
argument_list|()
operator|.
name|getAllTokens
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Obtain the tokens in credentials form associated with this user.    *     * @return Credentials of tokens associated with this user    */
end_comment

begin_function
DECL|method|getCredentials ()
specifier|public
name|Credentials
name|getCredentials
parameter_list|()
block|{
synchronized|synchronized
init|(
name|subject
init|)
block|{
name|Credentials
name|creds
init|=
operator|new
name|Credentials
argument_list|(
name|getCredentialsInternal
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|iter
init|=
name|creds
operator|.
name|getAllTokens
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|isPrivate
argument_list|()
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|creds
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Add the given Credentials to this user.    * @param credentials of tokens and secrets    */
end_comment

begin_function
DECL|method|addCredentials (Credentials credentials)
specifier|public
name|void
name|addCredentials
parameter_list|(
name|Credentials
name|credentials
parameter_list|)
block|{
synchronized|synchronized
init|(
name|subject
init|)
block|{
name|getCredentialsInternal
argument_list|()
operator|.
name|addAll
argument_list|(
name|credentials
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|getCredentialsInternal ()
specifier|private
specifier|synchronized
name|Credentials
name|getCredentialsInternal
parameter_list|()
block|{
specifier|final
name|Credentials
name|credentials
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Credentials
argument_list|>
name|credentialsSet
init|=
name|subject
operator|.
name|getPrivateCredentials
argument_list|(
name|Credentials
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|credentialsSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|credentials
operator|=
name|credentialsSet
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|credentials
operator|=
operator|new
name|Credentials
argument_list|()
expr_stmt|;
name|subject
operator|.
name|getPrivateCredentials
argument_list|()
operator|.
name|add
argument_list|(
name|credentials
argument_list|)
expr_stmt|;
block|}
return|return
name|credentials
return|;
block|}
end_function

begin_comment
comment|/**    * Get the group names for this user. {@link #getGroups()} is less    * expensive alternative when checking for a contained element.    * @return the list of users with the primary group first. If the command    *    fails, it returns an empty list.    */
end_comment

begin_function
DECL|method|getGroupNames ()
specifier|public
name|String
index|[]
name|getGroupNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|groups
init|=
name|getGroups
argument_list|()
decl_stmt|;
return|return
name|groups
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|groups
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get the group names for this user.    * @return the list of users with the primary group first. If the command    *    fails, it returns an empty list.    */
end_comment

begin_function
DECL|method|getGroups ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getGroups
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|groups
operator|.
name|getGroups
argument_list|(
name|getShortUserName
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to get groups for user "
operator|+
name|getShortUserName
argument_list|()
operator|+
literal|" by "
operator|+
name|ie
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"TRACE"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Return the username.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|getUserName
argument_list|()
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" (auth:"
operator|+
name|getAuthenticationMethod
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" via "
argument_list|)
operator|.
name|append
argument_list|(
name|getRealUser
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Sets the authentication method in the subject    *     * @param authMethod    */
end_comment

begin_function
specifier|public
specifier|synchronized
DECL|method|setAuthenticationMethod (AuthenticationMethod authMethod)
name|void
name|setAuthenticationMethod
parameter_list|(
name|AuthenticationMethod
name|authMethod
parameter_list|)
block|{
name|user
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Sets the authentication method in the subject    *     * @param authMethod    */
end_comment

begin_function
DECL|method|setAuthenticationMethod (AuthMethod authMethod)
specifier|public
name|void
name|setAuthenticationMethod
parameter_list|(
name|AuthMethod
name|authMethod
parameter_list|)
block|{
name|user
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|valueOf
argument_list|(
name|authMethod
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Get the authentication method from the subject    *     * @return AuthenticationMethod in the subject, null if not present.    */
end_comment

begin_function
DECL|method|getAuthenticationMethod ()
specifier|public
specifier|synchronized
name|AuthenticationMethod
name|getAuthenticationMethod
parameter_list|()
block|{
return|return
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Get the authentication method from the real user's subject.  If there    * is no real user, return the given user's authentication method.    *     * @return AuthenticationMethod in the subject, null if not present.    */
end_comment

begin_function
DECL|method|getRealAuthenticationMethod ()
specifier|public
specifier|synchronized
name|AuthenticationMethod
name|getRealAuthenticationMethod
parameter_list|()
block|{
name|UserGroupInformation
name|ugi
init|=
name|getRealUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|ugi
operator|==
literal|null
condition|)
block|{
name|ugi
operator|=
name|this
expr_stmt|;
block|}
return|return
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the authentication method of a ugi. If the authentication method is    * PROXY, returns the authentication method of the real user.    *     * @param ugi    * @return AuthenticationMethod    */
end_comment

begin_function
DECL|method|getRealAuthenticationMethod ( UserGroupInformation ugi)
specifier|public
specifier|static
name|AuthenticationMethod
name|getRealAuthenticationMethod
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
name|AuthenticationMethod
name|authMethod
init|=
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthenticationMethod
operator|.
name|PROXY
condition|)
block|{
name|authMethod
operator|=
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getAuthenticationMethod
argument_list|()
expr_stmt|;
block|}
return|return
name|authMethod
return|;
block|}
end_function

begin_comment
comment|/**    * Compare the subjects to see if they are equal to each other.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|subject
operator|==
operator|(
operator|(
name|UserGroupInformation
operator|)
name|o
operator|)
operator|.
name|subject
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Return the hash of the subject.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|subject
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get the underlying subject from this ugi.    * @return the subject that represents this user.    */
end_comment

begin_function
DECL|method|getSubject ()
specifier|protected
name|Subject
name|getSubject
parameter_list|()
block|{
return|return
name|subject
return|;
block|}
end_function

begin_comment
comment|/**    * Run the given action as the user.    * @param<T> the return type of the run method    * @param action the method to execute    * @return the value from the run method    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|doAs (PrivilegedAction<T> action)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|doAs
parameter_list|(
name|PrivilegedAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
block|{
name|logPrivilegedAction
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
name|Subject
operator|.
name|doAs
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Run the given action as the user, potentially throwing an exception.    * @param<T> the return type of the run method    * @param action the method to execute    * @return the value from the run method    * @throws IOException if the action throws an IOException    * @throws Error if the action throws an Error    * @throws RuntimeException if the action throws a RuntimeException    * @throws InterruptedException if the action throws an InterruptedException    * @throws UndeclaredThrowableException if the action throws something else    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|doAs (PrivilegedExceptionAction<T> action )
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|doAs
parameter_list|(
name|PrivilegedExceptionAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|logPrivilegedAction
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
name|Subject
operator|.
name|doAs
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|pae
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"PrivilegedActionException as:"
operator|+
name|this
operator|+
literal|" cause:"
operator|+
name|cause
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"PrivilegedActionException with no "
operator|+
literal|"underlying cause. UGI ["
operator|+
name|this
operator|+
literal|"]"
operator|+
literal|": "
operator|+
name|pae
argument_list|,
name|pae
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|InterruptedException
condition|)
block|{
throw|throw
operator|(
name|InterruptedException
operator|)
name|cause
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UndeclaredThrowableException
argument_list|(
name|cause
argument_list|)
throw|;
block|}
block|}
block|}
end_function

begin_function
DECL|method|logPrivilegedAction (Subject subject, Object action)
specifier|private
name|void
name|logPrivilegedAction
parameter_list|(
name|Subject
name|subject
parameter_list|,
name|Object
name|action
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// would be nice if action included a descriptive toString()
name|String
name|where
init|=
operator|new
name|Throwable
argument_list|()
operator|.
name|getStackTrace
argument_list|()
index|[
literal|2
index|]
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"PrivilegedAction as:"
operator|+
name|this
operator|+
literal|" from:"
operator|+
name|where
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|logAllUserInfo (UserGroupInformation ugi)
specifier|public
specifier|static
name|void
name|logAllUserInfo
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"UGI: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"+RealUGI: "
operator|+
name|ugi
operator|.
name|getRealUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"+LoginUGI: "
operator|+
name|ugi
operator|.
name|getLoginUser
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Token
argument_list|<
name|?
argument_list|>
name|token
range|:
name|ugi
operator|.
name|getTokens
argument_list|()
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"+UGI token:"
operator|+
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
DECL|method|print ()
specifier|private
name|void
name|print
parameter_list|()
throws|throws
name|IOException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"User: "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Group Ids: "
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|String
index|[]
name|groups
init|=
name|getGroupNames
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Groups: "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groups
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|groups
index|[
name|i
index|]
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * A test method to print out the current user's UGI.    * @param args if there are two arguments, read the user from the keytab    * and print it out.    * @throws Exception    */
end_comment

begin_function
DECL|method|main (String [] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Getting UGI for current user"
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|getCurrentUser
argument_list|()
decl_stmt|;
name|ugi
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"UGI: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Auth method "
operator|+
name|ugi
operator|.
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab "
operator|+
name|ugi
operator|.
name|isKeytab
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"============================================================"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Getting UGI from keytab...."
argument_list|)
expr_stmt|;
name|loginUserFromKeytab
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|getCurrentUser
argument_list|()
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Auth method "
operator|+
name|loginUser
operator|.
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab "
operator|+
name|loginUser
operator|.
name|isKeytab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

unit|}
end_unit

