begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_TOKEN_FILES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_TOKENS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UGIExceptionMessages
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|PlatformName
operator|.
name|IBM_JAVA
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|getTrimmedStringCollection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessControlContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Principal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|DestroyFailedException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|Subject
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|callback
operator|.
name|CallbackHandler
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosPrincipal
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosTicket
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
operator|.
name|LoginModuleControlFlag
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|Parameters
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|spi
operator|.
name|LoginModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MetricsRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableGaugeInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableGaugeLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableQuantiles
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableRate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SaslRpcServer
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|KerberosUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * User and group information for Hadoop.  * This class wraps around a JAAS Subject and provides methods to determine the  * user's username and groups. It supports both the Windows, Unix and Kerberos   * login modules.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|UserGroupInformation
specifier|public
class|class
name|UserGroupInformation
block|{
annotation|@
name|VisibleForTesting
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|UserGroupInformation
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Percentage of the ticket window to use before we renew ticket.    */
DECL|field|TICKET_RENEW_WINDOW
specifier|private
specifier|static
specifier|final
name|float
name|TICKET_RENEW_WINDOW
init|=
literal|0.80f
decl_stmt|;
DECL|field|shouldRenewImmediatelyForTests
specifier|private
specifier|static
name|boolean
name|shouldRenewImmediatelyForTests
init|=
literal|false
decl_stmt|;
DECL|field|HADOOP_USER_NAME
specifier|static
specifier|final
name|String
name|HADOOP_USER_NAME
init|=
literal|"HADOOP_USER_NAME"
decl_stmt|;
DECL|field|HADOOP_PROXY_USER
specifier|static
specifier|final
name|String
name|HADOOP_PROXY_USER
init|=
literal|"HADOOP_PROXY_USER"
decl_stmt|;
comment|/**    * For the purposes of unit tests, we want to test login    * from keytab and don't want to wait until the renew    * window (controlled by TICKET_RENEW_WINDOW).    * @param immediate true if we should login without waiting for ticket window    */
annotation|@
name|VisibleForTesting
DECL|method|setShouldRenewImmediatelyForTests (boolean immediate)
specifier|public
specifier|static
name|void
name|setShouldRenewImmediatelyForTests
parameter_list|(
name|boolean
name|immediate
parameter_list|)
block|{
name|shouldRenewImmediatelyForTests
operator|=
name|immediate
expr_stmt|;
block|}
comment|/**     * UgiMetrics maintains UGI activity statistics    * and publishes them through the metrics interfaces.    */
annotation|@
name|Metrics
argument_list|(
name|about
operator|=
literal|"User and group related metrics"
argument_list|,
name|context
operator|=
literal|"ugi"
argument_list|)
DECL|class|UgiMetrics
specifier|static
class|class
name|UgiMetrics
block|{
DECL|field|registry
specifier|final
name|MetricsRegistry
name|registry
init|=
operator|new
name|MetricsRegistry
argument_list|(
literal|"UgiMetrics"
argument_list|)
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Rate of successful kerberos logins and latency (milliseconds)"
argument_list|)
DECL|field|loginSuccess
name|MutableRate
name|loginSuccess
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Rate of failed kerberos logins and latency (milliseconds)"
argument_list|)
DECL|field|loginFailure
name|MutableRate
name|loginFailure
decl_stmt|;
DECL|field|getGroups
annotation|@
name|Metric
argument_list|(
literal|"GetGroups"
argument_list|)
name|MutableRate
name|getGroups
decl_stmt|;
DECL|field|getGroupsQuantiles
name|MutableQuantiles
index|[]
name|getGroupsQuantiles
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Renewal failures since startup"
argument_list|)
DECL|field|renewalFailuresTotal
specifier|private
name|MutableGaugeLong
name|renewalFailuresTotal
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Renewal failures since last successful login"
argument_list|)
DECL|field|renewalFailures
specifier|private
name|MutableGaugeInt
name|renewalFailures
decl_stmt|;
DECL|method|create ()
specifier|static
name|UgiMetrics
name|create
parameter_list|()
block|{
return|return
name|DefaultMetricsSystem
operator|.
name|instance
argument_list|()
operator|.
name|register
argument_list|(
operator|new
name|UgiMetrics
argument_list|()
argument_list|)
return|;
block|}
DECL|method|reattach ()
specifier|static
name|void
name|reattach
parameter_list|()
block|{
name|metrics
operator|=
name|UgiMetrics
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
DECL|method|addGetGroups (long latency)
name|void
name|addGetGroups
parameter_list|(
name|long
name|latency
parameter_list|)
block|{
name|getGroups
operator|.
name|add
argument_list|(
name|latency
argument_list|)
expr_stmt|;
if|if
condition|(
name|getGroupsQuantiles
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|MutableQuantiles
name|q
range|:
name|getGroupsQuantiles
control|)
block|{
name|q
operator|.
name|add
argument_list|(
name|latency
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getRenewalFailures ()
name|MutableGaugeInt
name|getRenewalFailures
parameter_list|()
block|{
return|return
name|renewalFailures
return|;
block|}
block|}
comment|/**    * A login module that looks at the Kerberos, Unix, or Windows principal and    * adds the corresponding UserName.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|HadoopLoginModule
specifier|public
specifier|static
class|class
name|HadoopLoginModule
implements|implements
name|LoginModule
block|{
DECL|field|subject
specifier|private
name|Subject
name|subject
decl_stmt|;
annotation|@
name|Override
DECL|method|abort ()
specifier|public
name|boolean
name|abort
parameter_list|()
throws|throws
name|LoginException
block|{
return|return
literal|true
return|;
block|}
DECL|method|getCanonicalUser (Class<T> cls)
specifier|private
parameter_list|<
name|T
extends|extends
name|Principal
parameter_list|>
name|T
name|getCanonicalUser
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|cls
parameter_list|)
block|{
for|for
control|(
name|T
name|user
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|cls
argument_list|)
control|)
block|{
return|return
name|user
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|commit ()
specifier|public
name|boolean
name|commit
parameter_list|()
throws|throws
name|LoginException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"hadoop login commit"
argument_list|)
expr_stmt|;
block|}
comment|// if we already have a user, we are done.
if|if
condition|(
operator|!
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"using existing subject:"
operator|+
name|subject
operator|.
name|getPrincipals
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|Principal
name|user
init|=
name|getCanonicalUser
argument_list|(
name|KerberosPrincipal
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"using kerberos user:"
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
block|}
comment|//If we don't have a kerberos user and security is disabled, check
comment|//if user is specified in the environment or properties
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
operator|&&
operator|(
name|user
operator|==
literal|null
operator|)
condition|)
block|{
name|String
name|envUser
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_USER_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|envUser
operator|==
literal|null
condition|)
block|{
name|envUser
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_USER_NAME
argument_list|)
expr_stmt|;
block|}
name|user
operator|=
name|envUser
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|User
argument_list|(
name|envUser
argument_list|)
expr_stmt|;
block|}
comment|// use the OS user
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
name|user
operator|=
name|getCanonicalUser
argument_list|(
name|OS_PRINCIPAL_CLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"using local user:"
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we found the user, add our principal
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using user: \""
operator|+
name|user
operator|+
literal|"\" with name "
operator|+
name|user
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|User
name|userEntry
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// LoginContext will be attached later unless it's an external
comment|// subject.
name|AuthenticationMethod
name|authMethod
init|=
operator|(
name|user
operator|instanceof
name|KerberosPrincipal
operator|)
condition|?
name|AuthenticationMethod
operator|.
name|KERBEROS
else|:
name|AuthenticationMethod
operator|.
name|SIMPLE
decl_stmt|;
name|userEntry
operator|=
operator|new
name|User
argument_list|(
name|user
operator|.
name|getName
argument_list|()
argument_list|,
name|authMethod
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
call|(
name|LoginException
call|)
argument_list|(
operator|new
name|LoginException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User entry: \""
operator|+
name|userEntry
operator|.
name|toString
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
name|userEntry
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't find user in "
operator|+
name|subject
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LoginException
argument_list|(
literal|"Can't find user name"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|initialize (Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)
specifier|public
name|void
name|initialize
parameter_list|(
name|Subject
name|subject
parameter_list|,
name|CallbackHandler
name|callbackHandler
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|sharedState
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|login ()
specifier|public
name|boolean
name|login
parameter_list|()
throws|throws
name|LoginException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"hadoop login"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|logout ()
specifier|public
name|boolean
name|logout
parameter_list|()
throws|throws
name|LoginException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"hadoop logout"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Reattach the class's metrics to a new metric system.    */
DECL|method|reattachMetrics ()
specifier|public
specifier|static
name|void
name|reattachMetrics
parameter_list|()
block|{
name|UgiMetrics
operator|.
name|reattach
argument_list|()
expr_stmt|;
block|}
comment|/** Metrics to track UGI activity */
DECL|field|metrics
specifier|static
name|UgiMetrics
name|metrics
init|=
name|UgiMetrics
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/** The auth method to use */
DECL|field|authenticationMethod
specifier|private
specifier|static
name|AuthenticationMethod
name|authenticationMethod
decl_stmt|;
comment|/** Server-side groups fetching service */
DECL|field|groups
specifier|private
specifier|static
name|Groups
name|groups
decl_stmt|;
comment|/** Min time (in seconds) before relogin for Kerberos */
DECL|field|kerberosMinSecondsBeforeRelogin
specifier|private
specifier|static
name|long
name|kerberosMinSecondsBeforeRelogin
decl_stmt|;
comment|/** Boolean flag to enable auto-renewal for keytab based loging. */
DECL|field|kerberosKeyTabLoginRenewalEnabled
specifier|private
specifier|static
name|boolean
name|kerberosKeyTabLoginRenewalEnabled
decl_stmt|;
comment|/** A reference to Kerberos login auto renewal thread. */
DECL|field|kerberosLoginRenewalExecutor
specifier|private
specifier|static
name|Optional
argument_list|<
name|ExecutorService
argument_list|>
name|kerberosLoginRenewalExecutor
init|=
name|Optional
operator|.
name|empty
argument_list|()
decl_stmt|;
comment|/** The configuration to use */
DECL|field|conf
specifier|private
specifier|static
name|Configuration
name|conf
decl_stmt|;
comment|/**Environment variable pointing to the token cache file*/
DECL|field|HADOOP_TOKEN_FILE_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_TOKEN_FILE_LOCATION
init|=
literal|"HADOOP_TOKEN_FILE_LOCATION"
decl_stmt|;
comment|/** Environment variable pointing to the base64 tokens. */
DECL|field|HADOOP_TOKEN
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_TOKEN
init|=
literal|"HADOOP_TOKEN"
decl_stmt|;
DECL|method|isInitialized ()
specifier|public
specifier|static
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|conf
operator|!=
literal|null
return|;
block|}
comment|/**     * A method to initialize the fields that depend on a configuration.    * Must be called before useKerberos or groups is used.    */
DECL|method|ensureInitialized ()
specifier|private
specifier|static
name|void
name|ensureInitialized
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|UserGroupInformation
operator|.
name|class
init|)
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
comment|// someone might have beat us
name|initialize
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Initialize UGI and related classes.    * @param conf the configuration to use    */
DECL|method|initialize (Configuration conf, boolean overrideNameRules)
specifier|private
specifier|static
specifier|synchronized
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|overrideNameRules
parameter_list|)
block|{
name|authenticationMethod
operator|=
name|SecurityUtil
operator|.
name|getAuthenticationMethod
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|overrideNameRules
operator|||
operator|!
name|HadoopKerberosName
operator|.
name|hasRulesBeenSet
argument_list|()
condition|)
block|{
try|try
block|{
name|HadoopKerberosName
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Problem with Kerberos auth_to_local name configuration"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|kerberosMinSecondsBeforeRelogin
operator|=
literal|1000L
operator|*
name|conf
operator|.
name|getLong
argument_list|(
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN
argument_list|,
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid attribute value for "
operator|+
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN
operator|+
literal|" of "
operator|+
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN
argument_list|)
argument_list|)
throw|;
block|}
name|kerberosKeyTabLoginRenewalEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED
argument_list|,
name|HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
comment|// If we haven't set up testing groups, use the configuration to find it
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
name|Groups
operator|.
name|getUserToGroupsMappingService
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|UserGroupInformation
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
if|if
condition|(
name|metrics
operator|.
name|getGroupsQuantiles
operator|==
literal|null
condition|)
block|{
name|int
index|[]
name|intervals
init|=
name|conf
operator|.
name|getInts
argument_list|(
name|HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS
argument_list|)
decl_stmt|;
if|if
condition|(
name|intervals
operator|!=
literal|null
operator|&&
name|intervals
operator|.
name|length
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|length
init|=
name|intervals
operator|.
name|length
decl_stmt|;
name|MutableQuantiles
index|[]
name|getGroupsQuantiles
init|=
operator|new
name|MutableQuantiles
index|[
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|getGroupsQuantiles
index|[
name|i
index|]
operator|=
name|metrics
operator|.
name|registry
operator|.
name|newQuantiles
argument_list|(
literal|"getGroups"
operator|+
name|intervals
index|[
name|i
index|]
operator|+
literal|"s"
argument_list|,
literal|"Get groups"
argument_list|,
literal|"ops"
argument_list|,
literal|"latency"
argument_list|,
name|intervals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|getGroupsQuantiles
operator|=
name|getGroupsQuantiles
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Set the static configuration for UGI.    * In particular, set the security authentication mechanism and the    * group look up service.    * @param conf the configuration to use    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|setConfiguration (Configuration conf)
specifier|public
specifier|static
name|void
name|setConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|initialize
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|reset ()
specifier|public
specifier|static
name|void
name|reset
parameter_list|()
block|{
name|authenticationMethod
operator|=
literal|null
expr_stmt|;
name|conf
operator|=
literal|null
expr_stmt|;
name|groups
operator|=
literal|null
expr_stmt|;
name|kerberosMinSecondsBeforeRelogin
operator|=
literal|0
expr_stmt|;
name|kerberosKeyTabLoginRenewalEnabled
operator|=
literal|false
expr_stmt|;
name|kerberosLoginRenewalExecutor
operator|=
name|Optional
operator|.
name|empty
argument_list|()
expr_stmt|;
name|setLoginUser
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|HadoopKerberosName
operator|.
name|setRules
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine if UserGroupInformation is using Kerberos to determine    * user identities or is relying on simple authentication    *     * @return true if UGI is working in a secure environment    */
DECL|method|isSecurityEnabled ()
specifier|public
specifier|static
name|boolean
name|isSecurityEnabled
parameter_list|()
block|{
return|return
operator|!
name|isAuthenticationMethodEnabled
argument_list|(
name|AuthenticationMethod
operator|.
name|SIMPLE
argument_list|)
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|isAuthenticationMethodEnabled (AuthenticationMethod method)
specifier|private
specifier|static
name|boolean
name|isAuthenticationMethodEnabled
parameter_list|(
name|AuthenticationMethod
name|method
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
return|return
operator|(
name|authenticationMethod
operator|==
name|method
operator|)
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
annotation|@
name|VisibleForTesting
DECL|method|isKerberosKeyTabLoginRenewalEnabled ()
specifier|static
name|boolean
name|isKerberosKeyTabLoginRenewalEnabled
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
return|return
name|kerberosKeyTabLoginRenewalEnabled
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
annotation|@
name|VisibleForTesting
DECL|method|getKerberosLoginRenewalExecutor ()
specifier|static
name|Optional
argument_list|<
name|ExecutorService
argument_list|>
name|getKerberosLoginRenewalExecutor
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
return|return
name|kerberosLoginRenewalExecutor
return|;
block|}
comment|/**    * Information about the logged in user.    */
DECL|field|loginUserRef
specifier|private
specifier|static
specifier|final
name|AtomicReference
argument_list|<
name|UserGroupInformation
argument_list|>
name|loginUserRef
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|subject
specifier|private
specifier|final
name|Subject
name|subject
decl_stmt|;
comment|// All non-static fields must be read-only caches that come from the subject.
DECL|field|user
specifier|private
specifier|final
name|User
name|user
decl_stmt|;
DECL|field|OS_LOGIN_MODULE_NAME
specifier|private
specifier|static
name|String
name|OS_LOGIN_MODULE_NAME
decl_stmt|;
DECL|field|OS_PRINCIPAL_CLASS
specifier|private
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
name|OS_PRINCIPAL_CLASS
decl_stmt|;
DECL|field|windows
specifier|private
specifier|static
specifier|final
name|boolean
name|windows
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"Windows"
argument_list|)
decl_stmt|;
DECL|field|is64Bit
specifier|private
specifier|static
specifier|final
name|boolean
name|is64Bit
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.arch"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"64"
argument_list|)
operator|||
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.arch"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"s390x"
argument_list|)
decl_stmt|;
DECL|field|aix
specifier|private
specifier|static
specifier|final
name|boolean
name|aix
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|equals
argument_list|(
literal|"AIX"
argument_list|)
decl_stmt|;
comment|/* Return the OS login module class name */
DECL|method|getOSLoginModuleName ()
specifier|private
specifier|static
name|String
name|getOSLoginModuleName
parameter_list|()
block|{
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
if|if
condition|(
name|windows
condition|)
block|{
return|return
name|is64Bit
condition|?
literal|"com.ibm.security.auth.module.Win64LoginModule"
else|:
literal|"com.ibm.security.auth.module.NTLoginModule"
return|;
block|}
elseif|else
if|if
condition|(
name|aix
condition|)
block|{
return|return
name|is64Bit
condition|?
literal|"com.ibm.security.auth.module.AIX64LoginModule"
else|:
literal|"com.ibm.security.auth.module.AIXLoginModule"
return|;
block|}
else|else
block|{
return|return
literal|"com.ibm.security.auth.module.LinuxLoginModule"
return|;
block|}
block|}
else|else
block|{
return|return
name|windows
condition|?
literal|"com.sun.security.auth.module.NTLoginModule"
else|:
literal|"com.sun.security.auth.module.UnixLoginModule"
return|;
block|}
block|}
comment|/* Return the OS principal class */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getOsPrincipalClass ()
specifier|private
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
name|getOsPrincipalClass
parameter_list|()
block|{
name|ClassLoader
name|cl
init|=
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|principalClass
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
if|if
condition|(
name|is64Bit
condition|)
block|{
name|principalClass
operator|=
literal|"com.ibm.security.auth.UsernamePrincipal"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|windows
condition|)
block|{
name|principalClass
operator|=
literal|"com.ibm.security.auth.NTUserPrincipal"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aix
condition|)
block|{
name|principalClass
operator|=
literal|"com.ibm.security.auth.AIXPrincipal"
expr_stmt|;
block|}
else|else
block|{
name|principalClass
operator|=
literal|"com.ibm.security.auth.LinuxPrincipal"
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|principalClass
operator|=
name|windows
condition|?
literal|"com.sun.security.auth.NTUserPrincipal"
else|:
literal|"com.sun.security.auth.UnixPrincipal"
expr_stmt|;
block|}
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
operator|)
name|cl
operator|.
name|loadClass
argument_list|(
name|principalClass
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to find JAAS classes:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
static|static
block|{
name|OS_LOGIN_MODULE_NAME
operator|=
name|getOSLoginModuleName
argument_list|()
expr_stmt|;
name|OS_PRINCIPAL_CLASS
operator|=
name|getOsPrincipalClass
argument_list|()
expr_stmt|;
block|}
DECL|class|RealUser
specifier|private
specifier|static
class|class
name|RealUser
implements|implements
name|Principal
block|{
DECL|field|realUser
specifier|private
specifier|final
name|UserGroupInformation
name|realUser
decl_stmt|;
DECL|method|RealUser (UserGroupInformation realUser)
name|RealUser
parameter_list|(
name|UserGroupInformation
name|realUser
parameter_list|)
block|{
name|this
operator|.
name|realUser
operator|=
name|realUser
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|getUserName
argument_list|()
return|;
block|}
DECL|method|getRealUser ()
specifier|public
name|UserGroupInformation
name|getRealUser
parameter_list|()
block|{
return|return
name|realUser
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|realUser
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|RealUser
operator|)
name|o
operator|)
operator|.
name|realUser
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
name|HadoopLoginContext
DECL|method|newLoginContext (String appName, Subject subject, HadoopConfiguration loginConf)
name|newLoginContext
parameter_list|(
name|String
name|appName
parameter_list|,
name|Subject
name|subject
parameter_list|,
name|HadoopConfiguration
name|loginConf
parameter_list|)
throws|throws
name|LoginException
block|{
comment|// Temporarily switch the thread's ContextClassLoader to match this
comment|// class's classloader, so that we can properly load HadoopLoginModule
comment|// from the JAAS libraries.
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|ClassLoader
name|oldCCL
init|=
name|t
operator|.
name|getContextClassLoader
argument_list|()
decl_stmt|;
name|t
operator|.
name|setContextClassLoader
argument_list|(
name|HadoopLoginModule
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
return|return
operator|new
name|HadoopLoginContext
argument_list|(
name|appName
argument_list|,
name|subject
argument_list|,
name|loginConf
argument_list|)
return|;
block|}
finally|finally
block|{
name|t
operator|.
name|setContextClassLoader
argument_list|(
name|oldCCL
argument_list|)
expr_stmt|;
block|}
block|}
comment|// return the LoginContext only if it's managed by the ugi.  externally
comment|// managed login contexts will be ignored.
DECL|method|getLogin ()
specifier|private
name|HadoopLoginContext
name|getLogin
parameter_list|()
block|{
name|LoginContext
name|login
init|=
name|user
operator|.
name|getLogin
argument_list|()
decl_stmt|;
return|return
operator|(
name|login
operator|instanceof
name|HadoopLoginContext
operator|)
condition|?
operator|(
name|HadoopLoginContext
operator|)
name|login
else|:
literal|null
return|;
block|}
DECL|method|setLogin (LoginContext login)
specifier|private
name|void
name|setLogin
parameter_list|(
name|LoginContext
name|login
parameter_list|)
block|{
name|user
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a UserGroupInformation for the given subject.    * This does not change the subject or acquire new credentials.    *    * The creator of subject is responsible for renewing credentials.    * @param subject the user's subject    */
DECL|method|UserGroupInformation (Subject subject)
name|UserGroupInformation
parameter_list|(
name|Subject
name|subject
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
comment|// do not access ANY private credentials since they are mutable
comment|// during a relogin.  no principal locking necessary since
comment|// relogin/logout does not remove User principal.
name|this
operator|.
name|user
operator|=
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|user
operator|==
literal|null
operator|||
name|user
operator|.
name|getName
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Subject does not contain a valid User"
argument_list|)
throw|;
block|}
block|}
comment|/**    * checks if logged in using kerberos    * @return true if the subject logged via keytab or has a Kerberos TGT    */
DECL|method|hasKerberosCredentials ()
specifier|public
name|boolean
name|hasKerberosCredentials
parameter_list|()
block|{
return|return
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|==
name|AuthenticationMethod
operator|.
name|KERBEROS
return|;
block|}
comment|/**    * Return the current user, including any doAs in the current stack.    * @return the current user    * @throws IOException if login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getCurrentUser ()
specifier|public
specifier|static
name|UserGroupInformation
name|getCurrentUser
parameter_list|()
throws|throws
name|IOException
block|{
name|AccessControlContext
name|context
init|=
name|AccessController
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|Subject
name|subject
init|=
name|Subject
operator|.
name|getSubject
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|subject
operator|==
literal|null
operator|||
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|getLoginUser
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
return|;
block|}
block|}
comment|/**    * Find the most appropriate UserGroupInformation to use    *    * @param ticketCachePath    The Kerberos ticket cache path, or NULL    *                           if none is specfied    * @param user               The user name, or NULL if none is specified.    *    * @return                   The most appropriate UserGroupInformation    */
DECL|method|getBestUGI ( String ticketCachePath, String user)
specifier|public
specifier|static
name|UserGroupInformation
name|getBestUGI
parameter_list|(
name|String
name|ticketCachePath
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ticketCachePath
operator|!=
literal|null
condition|)
block|{
return|return
name|getUGIFromTicketCache
argument_list|(
name|ticketCachePath
argument_list|,
name|user
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
return|return
name|getCurrentUser
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|createRemoteUser
argument_list|(
name|user
argument_list|)
return|;
block|}
block|}
comment|/**    * Create a UserGroupInformation from a Kerberos ticket cache.    *     * @param user                The principal name to load from the ticket    *                            cache    * @param ticketCache     the path to the ticket cache file    *    * @throws IOException        if the kerberos login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getUGIFromTicketCache ( String ticketCache, String user)
specifier|public
specifier|static
name|UserGroupInformation
name|getUGIFromTicketCache
parameter_list|(
name|String
name|ticketCache
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isAuthenticationMethodEnabled
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
condition|)
block|{
return|return
name|getBestUGI
argument_list|(
literal|null
argument_list|,
name|user
argument_list|)
return|;
block|}
name|LoginParams
name|params
init|=
operator|new
name|LoginParams
argument_list|()
decl_stmt|;
name|params
operator|.
name|put
argument_list|(
name|LoginParam
operator|.
name|PRINCIPAL
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
name|LoginParam
operator|.
name|CCACHE
argument_list|,
name|ticketCache
argument_list|)
expr_stmt|;
return|return
name|doSubjectLogin
argument_list|(
literal|null
argument_list|,
name|params
argument_list|)
return|;
block|}
comment|/**    * Create a UserGroupInformation from a Subject with Kerberos principal.    *    * @param subject             The KerberosPrincipal to use in UGI.    *                            The creator of subject is responsible for    *                            renewing credentials.    *    * @throws IOException    * @throws KerberosAuthException if the kerberos login fails    */
DECL|method|getUGIFromSubject (Subject subject)
specifier|public
specifier|static
name|UserGroupInformation
name|getUGIFromSubject
parameter_list|(
name|Subject
name|subject
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|subject
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|SUBJECT_MUST_NOT_BE_NULL
argument_list|)
throw|;
block|}
if|if
condition|(
name|subject
operator|.
name|getPrincipals
argument_list|(
name|KerberosPrincipal
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|SUBJECT_MUST_CONTAIN_PRINCIPAL
argument_list|)
throw|;
block|}
comment|// null params indicate external subject login.  no login context will
comment|// be attached.
return|return
name|doSubjectLogin
argument_list|(
name|subject
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Get the currently logged in user.  If no explicit login has occurred,    * the user will automatically be logged in with either kerberos credentials    * if available, or as the local OS user, based on security settings.    * @return the logged in user    * @throws IOException if login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getLoginUser ()
specifier|public
specifier|static
name|UserGroupInformation
name|getLoginUser
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|loginUser
init|=
name|loginUserRef
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// a potential race condition exists only for the initial creation of
comment|// the login user.  there's no need to penalize all subsequent calls
comment|// with sychronization overhead so optimistically create a login user
comment|// and discard if we lose the race.
if|if
condition|(
name|loginUser
operator|==
literal|null
condition|)
block|{
name|UserGroupInformation
name|newLoginUser
init|=
name|createLoginUser
argument_list|(
literal|null
argument_list|)
decl_stmt|;
do|do
block|{
comment|// it's extremely unlikely that the login user will be non-null
comment|// (lost CAS race), but be nulled before the subsequent get, but loop
comment|// for correctness.
if|if
condition|(
name|loginUserRef
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|newLoginUser
argument_list|)
condition|)
block|{
name|loginUser
operator|=
name|newLoginUser
expr_stmt|;
comment|// only spawn renewal if this login user is the winner.
name|loginUser
operator|.
name|spawnAutoRenewalThreadForUserCreds
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loginUser
operator|=
name|loginUserRef
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|loginUser
operator|==
literal|null
condition|)
do|;
block|}
return|return
name|loginUser
return|;
block|}
comment|/**    * remove the login method that is followed by a space from the username    * e.g. "jack (auth:SIMPLE)" {@literal ->} "jack"    *    * @param userName    * @return userName without login method    */
DECL|method|trimLoginMethod (String userName)
specifier|public
specifier|static
name|String
name|trimLoginMethod
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
name|int
name|spaceIndex
init|=
name|userName
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|spaceIndex
operator|>=
literal|0
condition|)
block|{
name|userName
operator|=
name|userName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|spaceIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|userName
return|;
block|}
comment|/**    * Log in a user using the given subject    * @param subject the subject to use when logging in a user, or null to    * create a new subject.    *    * If subject is not null, the creator of subject is responsible for renewing    * credentials.    *    * @throws IOException if login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|loginUserFromSubject (Subject subject)
specifier|public
specifier|static
name|void
name|loginUserFromSubject
parameter_list|(
name|Subject
name|subject
parameter_list|)
throws|throws
name|IOException
block|{
name|setLoginUser
argument_list|(
name|createLoginUser
argument_list|(
name|subject
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
DECL|method|createLoginUser (Subject subject)
name|UserGroupInformation
name|createLoginUser
parameter_list|(
name|Subject
name|subject
parameter_list|)
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|realUser
init|=
name|doSubjectLogin
argument_list|(
name|subject
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|loginUser
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// If the HADOOP_PROXY_USER environment variable or property
comment|// is specified, create a proxy user as the logged in user.
name|String
name|proxyUser
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_PROXY_USER
argument_list|)
decl_stmt|;
if|if
condition|(
name|proxyUser
operator|==
literal|null
condition|)
block|{
name|proxyUser
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_PROXY_USER
argument_list|)
expr_stmt|;
block|}
name|loginUser
operator|=
name|proxyUser
operator|==
literal|null
condition|?
name|realUser
else|:
name|createProxyUser
argument_list|(
name|proxyUser
argument_list|,
name|realUser
argument_list|)
expr_stmt|;
comment|// Load tokens from files
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|tokenFileLocations
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|tokenFileLocations
operator|.
name|addAll
argument_list|(
name|getTrimmedStringCollection
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_TOKEN_FILES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tokenFileLocations
operator|.
name|addAll
argument_list|(
name|getTrimmedStringCollection
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_TOKEN_FILES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tokenFileLocations
operator|.
name|addAll
argument_list|(
name|getTrimmedStringCollection
argument_list|(
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_TOKEN_FILE_LOCATION
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|tokenFileLocation
range|:
name|tokenFileLocations
control|)
block|{
if|if
condition|(
name|tokenFileLocation
operator|!=
literal|null
operator|&&
name|tokenFileLocation
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|File
name|tokenFile
init|=
operator|new
name|File
argument_list|(
name|tokenFileLocation
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reading credentials from location {}"
argument_list|,
name|tokenFile
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokenFile
operator|.
name|exists
argument_list|()
operator|&&
name|tokenFile
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|Credentials
name|cred
init|=
name|Credentials
operator|.
name|readTokenStorageFile
argument_list|(
name|tokenFile
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loaded {} tokens from {}"
argument_list|,
name|cred
operator|.
name|numberOfTokens
argument_list|()
argument_list|,
name|tokenFile
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|addCredentials
argument_list|(
name|cred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Token file {} does not exist"
argument_list|,
name|tokenFile
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Load tokens from base64 encoding
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|tokensBase64
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|tokensBase64
operator|.
name|addAll
argument_list|(
name|getTrimmedStringCollection
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_TOKENS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tokensBase64
operator|.
name|addAll
argument_list|(
name|getTrimmedStringCollection
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_TOKENS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tokensBase64
operator|.
name|addAll
argument_list|(
name|getTrimmedStringCollection
argument_list|(
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_TOKEN
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numTokenBase64
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|tokenBase64
range|:
name|tokensBase64
control|)
block|{
if|if
condition|(
name|tokenBase64
operator|!=
literal|null
operator|&&
name|tokenBase64
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Token
argument_list|<
name|TokenIdentifier
argument_list|>
name|token
init|=
operator|new
name|Token
argument_list|<>
argument_list|()
decl_stmt|;
name|token
operator|.
name|decodeFromUrlString
argument_list|(
name|tokenBase64
argument_list|)
expr_stmt|;
name|Credentials
name|cred
init|=
operator|new
name|Credentials
argument_list|()
decl_stmt|;
name|cred
operator|.
name|addToken
argument_list|(
name|token
operator|.
name|getService
argument_list|()
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|addCredentials
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|numTokenBase64
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot add token {}: {}"
argument_list|,
name|tokenBase64
argument_list|,
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|numTokenBase64
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loaded {} base64 tokens"
argument_list|,
name|numTokenBase64
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"failure to load login credentials"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"UGI loginUser:"
operator|+
name|loginUser
argument_list|)
expr_stmt|;
block|}
return|return
name|loginUser
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|VisibleForTesting
DECL|method|setLoginUser (UserGroupInformation ugi)
specifier|public
specifier|static
name|void
name|setLoginUser
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
comment|// if this is to become stable, should probably logout the currently
comment|// logged in ugi if it's different
name|loginUserRef
operator|.
name|set
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
DECL|method|getKeytab ()
specifier|private
name|String
name|getKeytab
parameter_list|()
block|{
name|HadoopLoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
return|return
operator|(
name|login
operator|!=
literal|null
operator|)
condition|?
name|login
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
name|LoginParam
operator|.
name|KEYTAB
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**    * Is the ugi managed by the UGI or an external subject?    * @return true if managed by UGI.    */
DECL|method|isHadoopLogin ()
specifier|private
name|boolean
name|isHadoopLogin
parameter_list|()
block|{
comment|// checks if the private hadoop login context is managing the ugi.
return|return
name|getLogin
argument_list|()
operator|!=
literal|null
return|;
block|}
comment|/**    * Is this user logged in from a keytab file managed by the UGI?    * @return true if the credentials are from a keytab file.    */
DECL|method|isFromKeytab ()
specifier|public
name|boolean
name|isFromKeytab
parameter_list|()
block|{
comment|// can't simply check if keytab is present since a relogin failure will
comment|// have removed the keytab from priv creds.  instead, check login params.
return|return
name|hasKerberosCredentials
argument_list|()
operator|&&
name|isHadoopLogin
argument_list|()
operator|&&
name|getKeytab
argument_list|()
operator|!=
literal|null
return|;
block|}
comment|/**    *  Is this user logged in from a ticket (but no keytab) managed by the UGI?    * @return true if the credentials are from a ticket cache.    */
DECL|method|isFromTicket ()
specifier|private
name|boolean
name|isFromTicket
parameter_list|()
block|{
return|return
name|hasKerberosCredentials
argument_list|()
operator|&&
name|isHadoopLogin
argument_list|()
operator|&&
name|getKeytab
argument_list|()
operator|==
literal|null
return|;
block|}
comment|/**    * Get the Kerberos TGT    * @return the user's TGT or null if none was found    */
DECL|method|getTGT ()
specifier|private
name|KerberosTicket
name|getTGT
parameter_list|()
block|{
name|Set
argument_list|<
name|KerberosTicket
argument_list|>
name|tickets
init|=
name|subject
operator|.
name|getPrivateCredentials
argument_list|(
name|KerberosTicket
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|KerberosTicket
name|ticket
range|:
name|tickets
control|)
block|{
if|if
condition|(
name|SecurityUtil
operator|.
name|isOriginalTGT
argument_list|(
name|ticket
argument_list|)
condition|)
block|{
return|return
name|ticket
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getRefreshTime (KerberosTicket tgt)
specifier|private
name|long
name|getRefreshTime
parameter_list|(
name|KerberosTicket
name|tgt
parameter_list|)
block|{
name|long
name|start
init|=
name|tgt
operator|.
name|getStartTime
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|long
name|end
init|=
name|tgt
operator|.
name|getEndTime
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
return|return
name|start
operator|+
call|(
name|long
call|)
argument_list|(
operator|(
name|end
operator|-
name|start
operator|)
operator|*
name|TICKET_RENEW_WINDOW
argument_list|)
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|method|shouldRelogin ()
specifier|public
name|boolean
name|shouldRelogin
parameter_list|()
block|{
return|return
name|hasKerberosCredentials
argument_list|()
operator|&&
name|isHadoopLogin
argument_list|()
return|;
block|}
comment|/**    * Spawn a thread to do periodic renewals of kerberos credentials. NEVER    * directly call this method. This method should only be used for ticket cache    * based kerberos credentials.    *    * @param force - used by tests to forcibly spawn thread    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|VisibleForTesting
DECL|method|spawnAutoRenewalThreadForUserCreds (boolean force)
name|void
name|spawnAutoRenewalThreadForUserCreds
parameter_list|(
name|boolean
name|force
parameter_list|)
block|{
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
operator|!
name|shouldRelogin
argument_list|()
operator|||
name|isFromKeytab
argument_list|()
operator|)
condition|)
block|{
return|return;
block|}
comment|//spawn thread only if we have kerb credentials
name|KerberosTicket
name|tgt
init|=
name|getTGT
argument_list|()
decl_stmt|;
if|if
condition|(
name|tgt
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|cmd
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hadoop.kerberos.kinit.command"
argument_list|,
literal|"kinit"
argument_list|)
decl_stmt|;
name|long
name|nextRefresh
init|=
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
decl_stmt|;
name|executeAutoRenewalTask
argument_list|(
name|getUserName
argument_list|()
argument_list|,
operator|new
name|TicketCacheRenewalRunnable
argument_list|(
name|tgt
argument_list|,
name|cmd
argument_list|,
name|nextRefresh
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Spawn a thread to do periodic renewals of kerberos credentials from a    * keytab file.    */
DECL|method|spawnAutoRenewalThreadForKeytab ()
specifier|private
name|void
name|spawnAutoRenewalThreadForKeytab
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldRelogin
argument_list|()
operator|||
name|isFromTicket
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// spawn thread only if we have kerb credentials
name|KerberosTicket
name|tgt
init|=
name|getTGT
argument_list|()
decl_stmt|;
if|if
condition|(
name|tgt
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|long
name|nextRefresh
init|=
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
decl_stmt|;
name|executeAutoRenewalTask
argument_list|(
name|getUserName
argument_list|()
argument_list|,
operator|new
name|KeytabRenewalRunnable
argument_list|(
name|tgt
argument_list|,
name|nextRefresh
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Spawn a thread to do periodic renewals of kerberos credentials from a    * keytab file. NEVER directly call this method.    *    * @param userName Name of the user for which login needs to be renewed.    * @param task  The reference of the login renewal task.    */
DECL|method|executeAutoRenewalTask (final String userName, AutoRenewalForUserCredsRunnable task)
specifier|private
name|void
name|executeAutoRenewalTask
parameter_list|(
specifier|final
name|String
name|userName
parameter_list|,
name|AutoRenewalForUserCredsRunnable
name|task
parameter_list|)
block|{
name|kerberosLoginRenewalExecutor
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
operator|new
name|ThreadFactory
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"TGT Renewer for "
operator|+
name|userName
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|kerberosLoginRenewalExecutor
operator|.
name|get
argument_list|()
operator|.
name|submit
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|/**    * An abstract class which encapsulates the functionality required to    * auto renew Kerbeors TGT. The concrete implementations of this class    * are expected to provide implementation required to perform actual    * TGT renewal (see {@code TicketCacheRenewalRunnable} and    * {@code KeytabRenewalRunnable}).    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|VisibleForTesting
DECL|class|AutoRenewalForUserCredsRunnable
specifier|abstract
class|class
name|AutoRenewalForUserCredsRunnable
implements|implements
name|Runnable
block|{
DECL|field|tgt
specifier|private
name|KerberosTicket
name|tgt
decl_stmt|;
DECL|field|rp
specifier|private
name|RetryPolicy
name|rp
decl_stmt|;
DECL|field|nextRefresh
specifier|private
name|long
name|nextRefresh
decl_stmt|;
DECL|field|runRenewalLoop
specifier|private
name|boolean
name|runRenewalLoop
init|=
literal|true
decl_stmt|;
DECL|method|AutoRenewalForUserCredsRunnable (KerberosTicket tgt, long nextRefresh)
name|AutoRenewalForUserCredsRunnable
parameter_list|(
name|KerberosTicket
name|tgt
parameter_list|,
name|long
name|nextRefresh
parameter_list|)
block|{
name|this
operator|.
name|tgt
operator|=
name|tgt
expr_stmt|;
name|this
operator|.
name|nextRefresh
operator|=
name|nextRefresh
expr_stmt|;
name|this
operator|.
name|rp
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|setRunRenewalLoop (boolean runRenewalLoop)
specifier|public
name|void
name|setRunRenewalLoop
parameter_list|(
name|boolean
name|runRenewalLoop
parameter_list|)
block|{
name|this
operator|.
name|runRenewalLoop
operator|=
name|runRenewalLoop
expr_stmt|;
block|}
comment|/**      * This method is used to perform renewal of kerberos login ticket.      * The concrete implementations of this class should provide specific      * logic required to perform renewal as part of this method.      */
DECL|method|relogin ()
specifier|protected
specifier|abstract
name|void
name|relogin
parameter_list|()
throws|throws
name|IOException
function_decl|;
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
do|do
block|{
try|try
block|{
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Current time is "
operator|+
name|now
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Next refresh is "
operator|+
name|nextRefresh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|now
operator|<
name|nextRefresh
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|nextRefresh
operator|-
name|now
argument_list|)
expr_stmt|;
block|}
name|relogin
argument_list|()
expr_stmt|;
name|tgt
operator|=
name|getTGT
argument_list|()
expr_stmt|;
if|if
condition|(
name|tgt
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No TGT after renewal. Aborting renew thread for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|nextRefresh
operator|=
name|Math
operator|.
name|max
argument_list|(
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
argument_list|,
name|now
operator|+
name|kerberosMinSecondsBeforeRelogin
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|renewalFailures
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rp
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Terminating renewal thread"
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|metrics
operator|.
name|renewalFailuresTotal
operator|.
name|incr
argument_list|()
expr_stmt|;
specifier|final
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|tgt
operator|.
name|isDestroyed
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"TGT is destroyed. "
operator|+
literal|"Aborting renew thread for %s."
argument_list|,
name|getUserName
argument_list|()
argument_list|)
argument_list|,
name|ie
argument_list|)
expr_stmt|;
return|return;
block|}
name|long
name|tgtEndTime
decl_stmt|;
comment|// As described in HADOOP-15593 we need to handle the case when
comment|// tgt.getEndTime() throws NPE because of JDK issue JDK-8147772
comment|// NPE is only possible if this issue is not fixed in the JDK
comment|// currently used
try|try
block|{
name|tgtEndTime
operator|=
name|tgt
operator|.
name|getEndTime
argument_list|()
operator|.
name|getTime
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|npe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"NPE thrown while getting "
operator|+
literal|"KerberosTicket endTime. Aborting renew thread for %s."
argument_list|,
name|getUserName
argument_list|()
argument_list|)
argument_list|,
name|ie
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Exception encountered while running the "
operator|+
literal|"renewal command for %s. "
operator|+
literal|"(TGT end time:%d, renewalFailures: %d, "
operator|+
literal|"renewalFailuresTotal: %d)"
argument_list|,
name|getUserName
argument_list|()
argument_list|,
name|tgtEndTime
argument_list|,
name|metrics
operator|.
name|renewalFailures
operator|.
name|value
argument_list|()
argument_list|,
name|metrics
operator|.
name|renewalFailuresTotal
operator|.
name|value
argument_list|()
argument_list|)
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
literal|null
condition|)
block|{
comment|// Use a dummy maxRetries to create the policy. The policy will
comment|// only be used to get next retry time with exponential back-off.
comment|// The final retry time will be later limited within the
comment|// tgt endTime in getNextTgtRenewalTime.
name|rp
operator|=
name|RetryPolicies
operator|.
name|exponentialBackoffRetry
argument_list|(
name|Long
operator|.
name|SIZE
operator|-
literal|2
argument_list|,
name|kerberosMinSecondsBeforeRelogin
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|nextRefresh
operator|=
name|getNextTgtRenewalTime
argument_list|(
name|tgtEndTime
argument_list|,
name|now
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception when calculating next tgt renewal time"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|metrics
operator|.
name|renewalFailures
operator|.
name|incr
argument_list|()
expr_stmt|;
comment|// retry until close enough to tgt endTime.
if|if
condition|(
name|now
operator|>
name|nextRefresh
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"TGT is expired. Aborting renew thread for {}."
argument_list|,
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
do|while
condition|(
name|runRenewalLoop
condition|)
do|;
block|}
block|}
comment|/**    * A concrete implementation of {@code AutoRenewalForUserCredsRunnable} class    * which performs TGT renewal using kinit command.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|VisibleForTesting
DECL|class|TicketCacheRenewalRunnable
specifier|final
class|class
name|TicketCacheRenewalRunnable
extends|extends
name|AutoRenewalForUserCredsRunnable
block|{
DECL|field|kinitCmd
specifier|private
name|String
name|kinitCmd
decl_stmt|;
DECL|method|TicketCacheRenewalRunnable (KerberosTicket tgt, String kinitCmd, long nextRefresh)
name|TicketCacheRenewalRunnable
parameter_list|(
name|KerberosTicket
name|tgt
parameter_list|,
name|String
name|kinitCmd
parameter_list|,
name|long
name|nextRefresh
parameter_list|)
block|{
name|super
argument_list|(
name|tgt
argument_list|,
name|nextRefresh
argument_list|)
expr_stmt|;
name|this
operator|.
name|kinitCmd
operator|=
name|kinitCmd
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|relogin ()
specifier|public
name|void
name|relogin
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|output
init|=
name|Shell
operator|.
name|execCommand
argument_list|(
name|kinitCmd
argument_list|,
literal|"-R"
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renewed ticket. kinit output: {}"
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|reloginFromTicketCache
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * A concrete implementation of {@code AutoRenewalForUserCredsRunnable} class    * which performs TGT renewal using specified keytab.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|VisibleForTesting
DECL|class|KeytabRenewalRunnable
specifier|final
class|class
name|KeytabRenewalRunnable
extends|extends
name|AutoRenewalForUserCredsRunnable
block|{
DECL|method|KeytabRenewalRunnable (KerberosTicket tgt, long nextRefresh)
name|KeytabRenewalRunnable
parameter_list|(
name|KerberosTicket
name|tgt
parameter_list|,
name|long
name|nextRefresh
parameter_list|)
block|{
name|super
argument_list|(
name|tgt
argument_list|,
name|nextRefresh
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|relogin ()
specifier|public
name|void
name|relogin
parameter_list|()
throws|throws
name|IOException
block|{
name|reloginFromKeytab
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get time for next login retry. This will allow the thread to retry with    * exponential back-off, until tgt endtime.    * Last retry is {@link #kerberosMinSecondsBeforeRelogin} before endtime.    *    * @param tgtEndTime EndTime of the tgt.    * @param now Current time.    * @param rp The retry policy.    * @return Time for next login retry.    */
annotation|@
name|VisibleForTesting
DECL|method|getNextTgtRenewalTime (final long tgtEndTime, final long now, final RetryPolicy rp)
specifier|static
name|long
name|getNextTgtRenewalTime
parameter_list|(
specifier|final
name|long
name|tgtEndTime
parameter_list|,
specifier|final
name|long
name|now
parameter_list|,
specifier|final
name|RetryPolicy
name|rp
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|long
name|lastRetryTime
init|=
name|tgtEndTime
operator|-
name|kerberosMinSecondsBeforeRelogin
decl_stmt|;
specifier|final
name|RetryPolicy
operator|.
name|RetryAction
name|ra
init|=
name|rp
operator|.
name|shouldRetry
argument_list|(
literal|null
argument_list|,
name|metrics
operator|.
name|renewalFailures
operator|.
name|value
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|Math
operator|.
name|min
argument_list|(
name|lastRetryTime
argument_list|,
name|now
operator|+
name|ra
operator|.
name|delayMillis
argument_list|)
return|;
block|}
comment|/**    * Log a user in from a keytab file. Loads a user identity from a keytab    * file and logs them in. They become the currently logged-in user.    * @param user the principal name to load from the keytab    * @param path the path to the keytab file    * @throws IOException    * @throws KerberosAuthException if it's a kerberos login exception.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
DECL|method|loginUserFromKeytab (String user, String path )
specifier|static
name|void
name|loginUserFromKeytab
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
return|return;
name|UserGroupInformation
name|u
init|=
name|loginUserFromKeytabAndReturnUGI
argument_list|(
name|user
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|isKerberosKeyTabLoginRenewalEnabled
argument_list|()
condition|)
block|{
name|u
operator|.
name|spawnAutoRenewalThreadForKeytab
argument_list|()
expr_stmt|;
block|}
name|setLoginUser
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Login successful for user {} using keytab file {}. Keytab auto"
operator|+
literal|" renewal enabled : {}"
argument_list|,
name|user
argument_list|,
name|path
argument_list|,
name|isKerberosKeyTabLoginRenewalEnabled
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Log the current user out who previously logged in using keytab.    * This method assumes that the user logged in by calling    * {@link #loginUserFromKeytab(String, String)}.    *    * @throws IOException    * @throws KerberosAuthException if a failure occurred in logout,    * or if the user did not log in by invoking loginUserFromKeyTab() before.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|logoutUserFromKeytab ()
specifier|public
name|void
name|logoutUserFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|hasKerberosCredentials
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Shutdown the background task performing login renewal.
if|if
condition|(
name|getKerberosLoginRenewalExecutor
argument_list|()
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|getKerberosLoginRenewalExecutor
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
name|HadoopLoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
name|String
name|keytabFile
init|=
name|getKeytab
argument_list|()
decl_stmt|;
if|if
condition|(
name|login
operator|==
literal|null
operator|||
name|keytabFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|MUST_FIRST_LOGIN_FROM_KEYTAB
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initiating logout for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// hadoop login context internally locks credentials.
name|login
operator|.
name|logout
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
name|KerberosAuthException
name|kae
init|=
operator|new
name|KerberosAuthException
argument_list|(
name|LOGOUT_FAILURE
argument_list|,
name|le
argument_list|)
decl_stmt|;
name|kae
operator|.
name|setUser
argument_list|(
name|user
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|kae
operator|.
name|setKeytabFile
argument_list|(
name|keytabFile
argument_list|)
expr_stmt|;
throw|throw
name|kae
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Logout successful for user "
operator|+
name|getUserName
argument_list|()
operator|+
literal|" using keytab file "
operator|+
name|keytabFile
argument_list|)
expr_stmt|;
block|}
comment|/**    * Re-login a user from keytab if TGT is expired or is close to expiry.    *     * @throws IOException    * @throws KerberosAuthException if it's a kerberos login exception.    */
DECL|method|checkTGTAndReloginFromKeytab ()
specifier|public
name|void
name|checkTGTAndReloginFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
name|reloginFromKeytab
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// if the first kerberos ticket is not TGT, then remove and destroy it since
comment|// the kerberos library of jdk always use the first kerberos ticket as TGT.
comment|// See HADOOP-13433 for more details.
annotation|@
name|VisibleForTesting
DECL|method|fixKerberosTicketOrder ()
name|void
name|fixKerberosTicketOrder
parameter_list|()
block|{
name|Set
argument_list|<
name|Object
argument_list|>
name|creds
init|=
name|getSubject
argument_list|()
operator|.
name|getPrivateCredentials
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|creds
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|iter
init|=
name|creds
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|cred
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|cred
operator|instanceof
name|KerberosTicket
condition|)
block|{
name|KerberosTicket
name|ticket
init|=
operator|(
name|KerberosTicket
operator|)
name|cred
decl_stmt|;
if|if
condition|(
name|ticket
operator|.
name|isDestroyed
argument_list|()
operator|||
name|ticket
operator|.
name|getServer
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ticket is already destroyed, remove it."
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ticket
operator|.
name|getServer
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"krbtgt"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The first kerberos ticket is not TGT"
operator|+
literal|"(the server principal is {}), remove and destroy it."
argument_list|,
name|ticket
operator|.
name|getServer
argument_list|()
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
name|ticket
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DestroyFailedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"destroy ticket failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return;
block|}
block|}
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Warning, no kerberos ticket found while attempting to renew ticket"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Re-Login a user in from a keytab file. Loads a user identity from a keytab    * file and logs them in. They become the currently logged-in user. This    * method assumes that {@link #loginUserFromKeytab(String, String)} had    * happened already.    * The Subject field of this UserGroupInformation object is updated to have    * the new credentials.    * @throws IOException    * @throws KerberosAuthException on a failure    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|reloginFromKeytab ()
specifier|public
name|void
name|reloginFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
name|reloginFromKeytab
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|reloginFromKeytab (boolean checkTGT)
specifier|private
name|void
name|reloginFromKeytab
parameter_list|(
name|boolean
name|checkTGT
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|shouldRelogin
argument_list|()
operator|||
operator|!
name|isFromKeytab
argument_list|()
condition|)
block|{
return|return;
block|}
name|HadoopLoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|login
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|MUST_FIRST_LOGIN_FROM_KEYTAB
argument_list|)
throw|;
block|}
if|if
condition|(
name|checkTGT
condition|)
block|{
name|KerberosTicket
name|tgt
init|=
name|getTGT
argument_list|()
decl_stmt|;
if|if
condition|(
name|tgt
operator|!=
literal|null
operator|&&
operator|!
name|shouldRenewImmediatelyForTests
operator|&&
name|Time
operator|.
name|now
argument_list|()
operator|<
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|relogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
comment|/**    * Re-Login a user in from the ticket cache.  This    * method assumes that login had happened already.    * The Subject field of this UserGroupInformation object is updated to have    * the new credentials.    * @throws IOException    * @throws KerberosAuthException on a failure    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|reloginFromTicketCache ()
specifier|public
name|void
name|reloginFromTicketCache
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|shouldRelogin
argument_list|()
operator|||
operator|!
name|isFromTicket
argument_list|()
condition|)
block|{
return|return;
block|}
name|HadoopLoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|login
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|KerberosAuthException
argument_list|(
name|MUST_FIRST_LOGIN
argument_list|)
throw|;
block|}
name|relogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
DECL|method|relogin (HadoopLoginContext login)
specifier|private
name|void
name|relogin
parameter_list|(
name|HadoopLoginContext
name|login
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ensure the relogin is atomic to avoid leaving credentials in an
comment|// inconsistent state.  prevents other ugi instances, SASL, and SPNEGO
comment|// from accessing or altering credentials during the relogin.
synchronized|synchronized
init|(
name|login
operator|.
name|getSubjectLock
argument_list|()
init|)
block|{
comment|// another racing thread may have beat us to the relogin.
if|if
condition|(
name|login
operator|==
name|getLogin
argument_list|()
condition|)
block|{
name|unprotectedRelogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|unprotectedRelogin (HadoopLoginContext login)
specifier|private
name|void
name|unprotectedRelogin
parameter_list|(
name|HadoopLoginContext
name|login
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|login
operator|.
name|getSubjectLock
argument_list|()
argument_list|)
assert|;
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasSufficientTimeElapsed
argument_list|(
name|now
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// register most recent relogin attempt
name|user
operator|.
name|setLastLogin
argument_list|(
name|now
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initiating logout for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//clear up the kerberos state. But the tokens are not cleared! As per
comment|//the Java kerberos login module code, only the kerberos credentials
comment|//are cleared
name|login
operator|.
name|logout
argument_list|()
expr_stmt|;
comment|//login and also update the subject field of this instance to
comment|//have the new credentials (pass it to the LoginContext constructor)
name|login
operator|=
name|newLoginContext
argument_list|(
name|login
operator|.
name|getAppName
argument_list|()
argument_list|,
name|login
operator|.
name|getSubject
argument_list|()
argument_list|,
name|login
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initiating re-login for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
comment|// this should be unnecessary.  originally added due to improper locking
comment|// of the subject during relogin.
name|fixKerberosTicketOrder
argument_list|()
expr_stmt|;
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
name|KerberosAuthException
name|kae
init|=
operator|new
name|KerberosAuthException
argument_list|(
name|LOGIN_FAILURE
argument_list|,
name|le
argument_list|)
decl_stmt|;
name|kae
operator|.
name|setUser
argument_list|(
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|kae
throw|;
block|}
block|}
comment|/**    * Log a user in from a keytab file. Loads a user identity from a keytab    * file and login them in. This new user does not affect the currently    * logged-in user.    * @param user the principal name to load from the keytab    * @param path the path to the keytab file    * @throws IOException if the keytab file can't be read    */
specifier|public
DECL|method|loginUserFromKeytabAndReturnUGI (String user, String path )
specifier|static
name|UserGroupInformation
name|loginUserFromKeytabAndReturnUGI
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
return|return
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
return|;
name|LoginParams
name|params
init|=
operator|new
name|LoginParams
argument_list|()
decl_stmt|;
name|params
operator|.
name|put
argument_list|(
name|LoginParam
operator|.
name|PRINCIPAL
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
name|LoginParam
operator|.
name|KEYTAB
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|doSubjectLogin
argument_list|(
literal|null
argument_list|,
name|params
argument_list|)
return|;
block|}
DECL|method|hasSufficientTimeElapsed (long now)
specifier|private
name|boolean
name|hasSufficientTimeElapsed
parameter_list|(
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
operator|!
name|shouldRenewImmediatelyForTests
operator|&&
name|now
operator|-
name|user
operator|.
name|getLastLogin
argument_list|()
operator|<
name|kerberosMinSecondsBeforeRelogin
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not attempting to re-login since the last re-login was "
operator|+
literal|"attempted less than "
operator|+
operator|(
name|kerberosMinSecondsBeforeRelogin
operator|/
literal|1000
operator|)
operator|+
literal|" seconds before. Last Login="
operator|+
name|user
operator|.
name|getLastLogin
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Did the login happen via keytab    * @return true or false    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|isLoginKeytabBased ()
specifier|public
specifier|static
name|boolean
name|isLoginKeytabBased
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getLoginUser
argument_list|()
operator|.
name|isFromKeytab
argument_list|()
return|;
block|}
comment|/**    * Did the login happen via ticket cache    * @return true or false    */
DECL|method|isLoginTicketBased ()
specifier|public
specifier|static
name|boolean
name|isLoginTicketBased
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getLoginUser
argument_list|()
operator|.
name|isFromTicket
argument_list|()
return|;
block|}
comment|/**    * Create a user from a login name. It is intended to be used for remote    * users in RPC, since it won't have any credentials.    * @param user the full user principal name, must not be empty or null    * @return the UserGroupInformation for the remote user.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createRemoteUser (String user)
specifier|public
specifier|static
name|UserGroupInformation
name|createRemoteUser
parameter_list|(
name|String
name|user
parameter_list|)
block|{
return|return
name|createRemoteUser
argument_list|(
name|user
argument_list|,
name|AuthMethod
operator|.
name|SIMPLE
argument_list|)
return|;
block|}
comment|/**    * Create a user from a login name. It is intended to be used for remote    * users in RPC, since it won't have any credentials.    * @param user the full user principal name, must not be empty or null    * @return the UserGroupInformation for the remote user.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createRemoteUser (String user, AuthMethod authMethod)
specifier|public
specifier|static
name|UserGroupInformation
name|createRemoteUser
parameter_list|(
name|String
name|user
parameter_list|,
name|AuthMethod
name|authMethod
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
literal|null
operator|||
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null user"
argument_list|)
throw|;
block|}
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|result
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
decl_stmt|;
name|result
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * existing types of authentications' methods    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|enum|AuthenticationMethod
specifier|public
enum|enum
name|AuthenticationMethod
block|{
comment|// currently we support only one auth per method, but eventually a
comment|// subtype is needed to differentiate, ex. if digest is token or ldap
DECL|enumConstant|SIMPLE
name|SIMPLE
parameter_list|(
name|AuthMethod
operator|.
name|SIMPLE
parameter_list|,
name|HadoopConfiguration
operator|.
name|SIMPLE_CONFIG_NAME
parameter_list|)
operator|,
DECL|enumConstant|KERBEROS
constructor|KERBEROS(AuthMethod.KERBEROS
operator|,
constructor|HadoopConfiguration.KERBEROS_CONFIG_NAME
block|)
enum|,
DECL|enumConstant|TOKEN
name|TOKEN
parameter_list|(
name|AuthMethod
operator|.
name|TOKEN
parameter_list|)
operator|,
DECL|enumConstant|CERTIFICATE
constructor|CERTIFICATE(null
block|)
operator|,
DECL|enumConstant|KERBEROS_SSL
name|KERBEROS_SSL
argument_list|(
literal|null
argument_list|)
operator|,
DECL|enumConstant|PROXY
name|PROXY
argument_list|(
literal|null
argument_list|)
expr_stmt|;
end_class

begin_decl_stmt
DECL|field|authMethod
specifier|private
specifier|final
name|AuthMethod
name|authMethod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
DECL|field|loginAppName
specifier|private
specifier|final
name|String
name|loginAppName
decl_stmt|;
end_decl_stmt

begin_constructor
DECL|method|AuthenticationMethod (AuthMethod authMethod)
specifier|private
name|AuthenticationMethod
parameter_list|(
name|AuthMethod
name|authMethod
parameter_list|)
block|{
name|this
argument_list|(
name|authMethod
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
end_constructor

begin_constructor
DECL|method|AuthenticationMethod (AuthMethod authMethod, String loginAppName)
specifier|private
name|AuthenticationMethod
parameter_list|(
name|AuthMethod
name|authMethod
parameter_list|,
name|String
name|loginAppName
parameter_list|)
block|{
name|this
operator|.
name|authMethod
operator|=
name|authMethod
expr_stmt|;
name|this
operator|.
name|loginAppName
operator|=
name|loginAppName
expr_stmt|;
block|}
end_constructor

begin_function
DECL|method|getAuthMethod ()
specifier|public
name|AuthMethod
name|getAuthMethod
parameter_list|()
block|{
return|return
name|authMethod
return|;
block|}
end_function

begin_function
DECL|method|getLoginAppName ()
name|String
name|getLoginAppName
parameter_list|()
block|{
if|if
condition|(
name|loginAppName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|this
operator|+
literal|" login authentication is not supported"
argument_list|)
throw|;
block|}
return|return
name|loginAppName
return|;
block|}
end_function

begin_function
DECL|method|valueOf (AuthMethod authMethod)
specifier|public
specifier|static
name|AuthenticationMethod
name|valueOf
parameter_list|(
name|AuthMethod
name|authMethod
parameter_list|)
block|{
for|for
control|(
name|AuthenticationMethod
name|value
range|:
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|value
operator|.
name|getAuthMethod
argument_list|()
operator|==
name|authMethod
condition|)
block|{
return|return
name|value
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"no authentication method for "
operator|+
name|authMethod
argument_list|)
throw|;
block|}
end_function

begin_comment
unit|};
comment|/**    * Create a proxy user using username of the effective user and the ugi of the    * real user.    * @param user    * @param realUser    * @return proxyUser ugi    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createProxyUser (String user, UserGroupInformation realUser)
specifier|public
specifier|static
name|UserGroupInformation
name|createProxyUser
parameter_list|(
name|String
name|user
parameter_list|,
name|UserGroupInformation
name|realUser
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
literal|null
operator|||
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null user"
argument_list|)
throw|;
block|}
if|if
condition|(
name|realUser
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null real user"
argument_list|)
throw|;
block|}
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Principal
argument_list|>
name|principals
init|=
name|subject
operator|.
name|getPrincipals
argument_list|()
decl_stmt|;
name|principals
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
argument_list|,
name|AuthenticationMethod
operator|.
name|PROXY
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|principals
operator|.
name|add
argument_list|(
operator|new
name|RealUser
argument_list|(
name|realUser
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * get RealUser (vs. EffectiveUser)    * @return realUser running over proxy user    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getRealUser ()
specifier|public
name|UserGroupInformation
name|getRealUser
parameter_list|()
block|{
for|for
control|(
name|RealUser
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|RealUser
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getRealUser
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
end_function

begin_comment
comment|/**    * This class is used for storing the groups for testing. It stores a local    * map that has the translation of usernames to groups.    */
end_comment

begin_class
DECL|class|TestingGroups
specifier|private
specifier|static
class|class
name|TestingGroups
extends|extends
name|Groups
block|{
DECL|field|userToGroupsMapping
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|userToGroupsMapping
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|underlyingImplementation
specifier|private
name|Groups
name|underlyingImplementation
decl_stmt|;
DECL|method|TestingGroups (Groups underlyingImplementation)
specifier|private
name|TestingGroups
parameter_list|(
name|Groups
name|underlyingImplementation
parameter_list|)
block|{
name|super
argument_list|(
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|underlyingImplementation
operator|=
name|underlyingImplementation
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getGroups (String user)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getGroups
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|userToGroupsMapping
operator|.
name|get
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|underlyingImplementation
operator|.
name|getGroups
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|setUserGroups (String user, String[] groups)
specifier|private
name|void
name|setUserGroups
parameter_list|(
name|String
name|user
parameter_list|,
name|String
index|[]
name|groups
parameter_list|)
block|{
name|userToGroupsMapping
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|groups
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/**    * Create a UGI for testing HDFS and MapReduce    * @param user the full user principal name    * @param userGroups the names of the groups that the user belongs to    * @return a fake user for running unit tests    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createUserForTesting (String user, String[] userGroups)
specifier|public
specifier|static
name|UserGroupInformation
name|createUserForTesting
parameter_list|(
name|String
name|user
parameter_list|,
name|String
index|[]
name|userGroups
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|createRemoteUser
argument_list|(
name|user
argument_list|)
decl_stmt|;
comment|// make sure that the testing object is setup
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
operator|new
name|TestingGroups
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
comment|// add the user groups
operator|(
operator|(
name|TestingGroups
operator|)
name|groups
operator|)
operator|.
name|setUserGroups
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|userGroups
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
end_function

begin_comment
comment|/**    * Create a proxy user UGI for testing HDFS and MapReduce    *     * @param user    *          the full user principal name for effective user    * @param realUser    *          UGI of the real user    * @param userGroups    *          the names of the groups that the user belongs to    * @return a fake user for running unit tests    */
end_comment

begin_function
DECL|method|createProxyUserForTesting (String user, UserGroupInformation realUser, String[] userGroups)
specifier|public
specifier|static
name|UserGroupInformation
name|createProxyUserForTesting
parameter_list|(
name|String
name|user
parameter_list|,
name|UserGroupInformation
name|realUser
parameter_list|,
name|String
index|[]
name|userGroups
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|createProxyUser
argument_list|(
name|user
argument_list|,
name|realUser
argument_list|)
decl_stmt|;
comment|// make sure that the testing object is setup
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
operator|new
name|TestingGroups
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
comment|// add the user groups
operator|(
operator|(
name|TestingGroups
operator|)
name|groups
operator|)
operator|.
name|setUserGroups
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|userGroups
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
end_function

begin_comment
comment|/**    * Get the user's login name.    * @return the user's name up to the first '/' or '@'.    */
end_comment

begin_function
DECL|method|getShortUserName ()
specifier|public
name|String
name|getShortUserName
parameter_list|()
block|{
return|return
name|user
operator|.
name|getShortName
argument_list|()
return|;
block|}
end_function

begin_function
DECL|method|getPrimaryGroupName ()
specifier|public
name|String
name|getPrimaryGroupName
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|groups
init|=
name|getGroups
argument_list|()
decl_stmt|;
if|if
condition|(
name|groups
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"There is no primary group for UGI "
operator|+
name|this
argument_list|)
throw|;
block|}
return|return
name|groups
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get the user's full principal name.    * @return the user's full principal name.    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getUserName ()
specifier|public
name|String
name|getUserName
parameter_list|()
block|{
return|return
name|user
operator|.
name|getName
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Add a TokenIdentifier to this UGI. The TokenIdentifier has typically been    * authenticated by the RPC layer as belonging to the user represented by this    * UGI.    *     * @param tokenId    *          tokenIdentifier to be added    * @return true on successful add of new tokenIdentifier    */
end_comment

begin_function
DECL|method|addTokenIdentifier (TokenIdentifier tokenId)
specifier|public
specifier|synchronized
name|boolean
name|addTokenIdentifier
parameter_list|(
name|TokenIdentifier
name|tokenId
parameter_list|)
block|{
return|return
name|subject
operator|.
name|getPublicCredentials
argument_list|()
operator|.
name|add
argument_list|(
name|tokenId
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get the set of TokenIdentifiers belonging to this UGI    *     * @return the set of TokenIdentifiers belonging to this UGI    */
end_comment

begin_function
DECL|method|getTokenIdentifiers ()
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|TokenIdentifier
argument_list|>
name|getTokenIdentifiers
parameter_list|()
block|{
return|return
name|subject
operator|.
name|getPublicCredentials
argument_list|(
name|TokenIdentifier
operator|.
name|class
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Add a token to this UGI    *     * @param token Token to be added    * @return true on successful add of new token    */
end_comment

begin_function
DECL|method|addToken (Token<? extends TokenIdentifier> token)
specifier|public
name|boolean
name|addToken
parameter_list|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
return|return
operator|(
name|token
operator|!=
literal|null
operator|)
condition|?
name|addToken
argument_list|(
name|token
operator|.
name|getService
argument_list|()
argument_list|,
name|token
argument_list|)
else|:
literal|false
return|;
block|}
end_function

begin_comment
comment|/**    * Add a named token to this UGI    *     * @param alias Name of the token    * @param token Token to be added    * @return true on successful add of new token    */
end_comment

begin_function
DECL|method|addToken (Text alias, Token<? extends TokenIdentifier> token)
specifier|public
name|boolean
name|addToken
parameter_list|(
name|Text
name|alias
parameter_list|,
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
synchronized|synchronized
init|(
name|subject
init|)
block|{
name|getCredentialsInternal
argument_list|()
operator|.
name|addToken
argument_list|(
name|alias
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Obtain the collection of tokens associated with this user.    *     * @return an unmodifiable collection of tokens associated with user    */
end_comment

begin_function
DECL|method|getTokens ()
specifier|public
name|Collection
argument_list|<
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|getTokens
parameter_list|()
block|{
synchronized|synchronized
init|(
name|subject
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|getCredentialsInternal
argument_list|()
operator|.
name|getAllTokens
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Obtain the tokens in credentials form associated with this user.    *     * @return Credentials of tokens associated with this user    */
end_comment

begin_function
DECL|method|getCredentials ()
specifier|public
name|Credentials
name|getCredentials
parameter_list|()
block|{
synchronized|synchronized
init|(
name|subject
init|)
block|{
name|Credentials
name|creds
init|=
operator|new
name|Credentials
argument_list|(
name|getCredentialsInternal
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|iter
init|=
name|creds
operator|.
name|getAllTokens
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|isPrivate
argument_list|()
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|creds
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Add the given Credentials to this user.    * @param credentials of tokens and secrets    */
end_comment

begin_function
DECL|method|addCredentials (Credentials credentials)
specifier|public
name|void
name|addCredentials
parameter_list|(
name|Credentials
name|credentials
parameter_list|)
block|{
synchronized|synchronized
init|(
name|subject
init|)
block|{
name|getCredentialsInternal
argument_list|()
operator|.
name|addAll
argument_list|(
name|credentials
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|getCredentialsInternal ()
specifier|private
specifier|synchronized
name|Credentials
name|getCredentialsInternal
parameter_list|()
block|{
specifier|final
name|Credentials
name|credentials
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Credentials
argument_list|>
name|credentialsSet
init|=
name|subject
operator|.
name|getPrivateCredentials
argument_list|(
name|Credentials
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|credentialsSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|credentials
operator|=
name|credentialsSet
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|credentials
operator|=
operator|new
name|Credentials
argument_list|()
expr_stmt|;
name|subject
operator|.
name|getPrivateCredentials
argument_list|()
operator|.
name|add
argument_list|(
name|credentials
argument_list|)
expr_stmt|;
block|}
return|return
name|credentials
return|;
block|}
end_function

begin_comment
comment|/**    * Get the group names for this user. {@link #getGroups()} is less    * expensive alternative when checking for a contained element.    * @return the list of users with the primary group first. If the command    *    fails, it returns an empty list.    */
end_comment

begin_function
DECL|method|getGroupNames ()
specifier|public
name|String
index|[]
name|getGroupNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|groups
init|=
name|getGroups
argument_list|()
decl_stmt|;
return|return
name|groups
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|groups
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get the group names for this user.    * @return the list of users with the primary group first. If the command    *    fails, it returns an empty list.    */
end_comment

begin_function
DECL|method|getGroups ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getGroups
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|groups
operator|.
name|getGroups
argument_list|(
name|getShortUserName
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to get groups for user "
operator|+
name|getShortUserName
argument_list|()
operator|+
literal|" by "
operator|+
name|ie
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"TRACE"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Return the username.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|getUserName
argument_list|()
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" (auth:"
operator|+
name|getAuthenticationMethod
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" via "
argument_list|)
operator|.
name|append
argument_list|(
name|getRealUser
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Sets the authentication method in the subject    *     * @param authMethod    */
end_comment

begin_function
specifier|public
specifier|synchronized
DECL|method|setAuthenticationMethod (AuthenticationMethod authMethod)
name|void
name|setAuthenticationMethod
parameter_list|(
name|AuthenticationMethod
name|authMethod
parameter_list|)
block|{
name|user
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Sets the authentication method in the subject    *     * @param authMethod    */
end_comment

begin_function
DECL|method|setAuthenticationMethod (AuthMethod authMethod)
specifier|public
name|void
name|setAuthenticationMethod
parameter_list|(
name|AuthMethod
name|authMethod
parameter_list|)
block|{
name|user
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|valueOf
argument_list|(
name|authMethod
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Get the authentication method from the subject    *     * @return AuthenticationMethod in the subject, null if not present.    */
end_comment

begin_function
DECL|method|getAuthenticationMethod ()
specifier|public
specifier|synchronized
name|AuthenticationMethod
name|getAuthenticationMethod
parameter_list|()
block|{
return|return
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Get the authentication method from the real user's subject.  If there    * is no real user, return the given user's authentication method.    *     * @return AuthenticationMethod in the subject, null if not present.    */
end_comment

begin_function
DECL|method|getRealAuthenticationMethod ()
specifier|public
specifier|synchronized
name|AuthenticationMethod
name|getRealAuthenticationMethod
parameter_list|()
block|{
name|UserGroupInformation
name|ugi
init|=
name|getRealUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|ugi
operator|==
literal|null
condition|)
block|{
name|ugi
operator|=
name|this
expr_stmt|;
block|}
return|return
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the authentication method of a ugi. If the authentication method is    * PROXY, returns the authentication method of the real user.    *     * @param ugi    * @return AuthenticationMethod    */
end_comment

begin_function
DECL|method|getRealAuthenticationMethod ( UserGroupInformation ugi)
specifier|public
specifier|static
name|AuthenticationMethod
name|getRealAuthenticationMethod
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
name|AuthenticationMethod
name|authMethod
init|=
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthenticationMethod
operator|.
name|PROXY
condition|)
block|{
name|authMethod
operator|=
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getAuthenticationMethod
argument_list|()
expr_stmt|;
block|}
return|return
name|authMethod
return|;
block|}
end_function

begin_comment
comment|/**    * Compare the subjects to see if they are equal to each other.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|subject
operator|==
operator|(
operator|(
name|UserGroupInformation
operator|)
name|o
operator|)
operator|.
name|subject
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Return the hash of the subject.    */
end_comment

begin_function
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|subject
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get the underlying subject from this ugi.    * @return the subject that represents this user.    */
end_comment

begin_function
DECL|method|getSubject ()
specifier|protected
name|Subject
name|getSubject
parameter_list|()
block|{
return|return
name|subject
return|;
block|}
end_function

begin_comment
comment|/**    * Run the given action as the user.    * @param<T> the return type of the run method    * @param action the method to execute    * @return the value from the run method    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|doAs (PrivilegedAction<T> action)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|doAs
parameter_list|(
name|PrivilegedAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
block|{
name|logPrivilegedAction
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
name|Subject
operator|.
name|doAs
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Run the given action as the user, potentially throwing an exception.    * @param<T> the return type of the run method    * @param action the method to execute    * @return the value from the run method    * @throws IOException if the action throws an IOException    * @throws Error if the action throws an Error    * @throws RuntimeException if the action throws a RuntimeException    * @throws InterruptedException if the action throws an InterruptedException    * @throws UndeclaredThrowableException if the action throws something else    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|doAs (PrivilegedExceptionAction<T> action )
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|doAs
parameter_list|(
name|PrivilegedExceptionAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|logPrivilegedAction
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
name|Subject
operator|.
name|doAs
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|pae
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"PrivilegedActionException as:"
operator|+
name|this
operator|+
literal|" cause:"
operator|+
name|cause
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cause
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"PrivilegedActionException with no "
operator|+
literal|"underlying cause. UGI ["
operator|+
name|this
operator|+
literal|"]"
operator|+
literal|": "
operator|+
name|pae
argument_list|,
name|pae
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|InterruptedException
condition|)
block|{
throw|throw
operator|(
name|InterruptedException
operator|)
name|cause
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UndeclaredThrowableException
argument_list|(
name|cause
argument_list|)
throw|;
block|}
block|}
block|}
end_function

begin_function
DECL|method|logPrivilegedAction (Subject subject, Object action)
specifier|private
name|void
name|logPrivilegedAction
parameter_list|(
name|Subject
name|subject
parameter_list|,
name|Object
name|action
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// would be nice if action included a descriptive toString()
name|String
name|where
init|=
operator|new
name|Throwable
argument_list|()
operator|.
name|getStackTrace
argument_list|()
index|[
literal|2
index|]
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"PrivilegedAction as:"
operator|+
name|this
operator|+
literal|" from:"
operator|+
name|where
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Log current UGI and token information into specified log.    * @param ugi - UGI    * @throws IOException    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"KMS"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|method|logUserInfo (Logger log, String caption, UserGroupInformation ugi)
specifier|public
specifier|static
name|void
name|logUserInfo
parameter_list|(
name|Logger
name|log
parameter_list|,
name|String
name|caption
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|caption
operator|+
literal|" UGI: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
for|for
control|(
name|Token
argument_list|<
name|?
argument_list|>
name|token
range|:
name|ugi
operator|.
name|getTokens
argument_list|()
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"+token:"
operator|+
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * Log all (current, real, login) UGI and token info into specified log.    * @param ugi - UGI    * @throws IOException    */
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"KMS"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|method|logAllUserInfo (Logger log, UserGroupInformation ugi)
specifier|public
specifier|static
name|void
name|logAllUserInfo
parameter_list|(
name|Logger
name|log
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logUserInfo
argument_list|(
name|log
argument_list|,
literal|"Current"
argument_list|,
name|ugi
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|logUserInfo
argument_list|(
name|log
argument_list|,
literal|"Real"
argument_list|,
name|ugi
operator|.
name|getRealUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|logUserInfo
argument_list|(
name|log
argument_list|,
literal|"Login"
argument_list|,
name|ugi
operator|.
name|getLoginUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Log all (current, real, login) UGI and token info into UGI debug log.    * @param ugi - UGI    * @throws IOException    */
end_comment

begin_function
DECL|method|logAllUserInfo (UserGroupInformation ugi)
specifier|public
specifier|static
name|void
name|logAllUserInfo
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
name|logAllUserInfo
argument_list|(
name|LOG
argument_list|,
name|ugi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|print ()
specifier|private
name|void
name|print
parameter_list|()
throws|throws
name|IOException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"User: "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Group Ids: "
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|String
index|[]
name|groups
init|=
name|getGroupNames
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Groups: "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groups
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|groups
index|[
name|i
index|]
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Login a subject with the given parameters.  If the subject is null,    * the login context used to create the subject will be attached.    * @param subject to login, null for new subject.    * @param params for login, null for externally managed ugi.    * @return UserGroupInformation for subject    * @throws IOException    */
end_comment

begin_function
DECL|method|doSubjectLogin ( Subject subject, LoginParams params)
specifier|private
specifier|static
name|UserGroupInformation
name|doSubjectLogin
parameter_list|(
name|Subject
name|subject
parameter_list|,
name|LoginParams
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
comment|// initial default login.
if|if
condition|(
name|subject
operator|==
literal|null
operator|&&
name|params
operator|==
literal|null
condition|)
block|{
name|params
operator|=
name|LoginParams
operator|.
name|getDefaults
argument_list|()
expr_stmt|;
block|}
name|HadoopConfiguration
name|loginConf
init|=
operator|new
name|HadoopConfiguration
argument_list|(
name|params
argument_list|)
decl_stmt|;
try|try
block|{
name|HadoopLoginContext
name|login
init|=
name|newLoginContext
argument_list|(
name|authenticationMethod
operator|.
name|getLoginAppName
argument_list|()
argument_list|,
name|subject
argument_list|,
name|loginConf
argument_list|)
decl_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|login
operator|.
name|getSubject
argument_list|()
argument_list|)
decl_stmt|;
comment|// attach login context for relogin unless this was a pre-existing
comment|// subject.
if|if
condition|(
name|subject
operator|==
literal|null
condition|)
block|{
name|params
operator|.
name|put
argument_list|(
name|LoginParam
operator|.
name|PRINCIPAL
argument_list|,
name|ugi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|ugi
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
return|return
name|ugi
return|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
name|KerberosAuthException
name|kae
init|=
operator|new
name|KerberosAuthException
argument_list|(
name|FAILURE_TO_LOGIN
argument_list|,
name|le
argument_list|)
decl_stmt|;
if|if
condition|(
name|params
operator|!=
literal|null
condition|)
block|{
name|kae
operator|.
name|setPrincipal
argument_list|(
name|params
operator|.
name|get
argument_list|(
name|LoginParam
operator|.
name|PRINCIPAL
argument_list|)
argument_list|)
expr_stmt|;
name|kae
operator|.
name|setKeytabFile
argument_list|(
name|params
operator|.
name|get
argument_list|(
name|LoginParam
operator|.
name|KEYTAB
argument_list|)
argument_list|)
expr_stmt|;
name|kae
operator|.
name|setTicketCacheFile
argument_list|(
name|params
operator|.
name|get
argument_list|(
name|LoginParam
operator|.
name|CCACHE
argument_list|)
argument_list|)
expr_stmt|;
block|}
throw|throw
name|kae
throw|;
block|}
block|}
end_function

begin_comment
comment|// parameters associated with kerberos logins.  may be extended to support
end_comment

begin_comment
comment|// additional authentication methods.
end_comment

begin_enum
DECL|enum|LoginParam
enum|enum
name|LoginParam
block|{
DECL|enumConstant|PRINCIPAL
name|PRINCIPAL
block|,
DECL|enumConstant|KEYTAB
name|KEYTAB
block|,
DECL|enumConstant|CCACHE
name|CCACHE
block|,   }
end_enum

begin_comment
comment|// explicitly private to prevent external tampering.
end_comment

begin_class
DECL|class|LoginParams
specifier|private
specifier|static
class|class
name|LoginParams
extends|extends
name|EnumMap
argument_list|<
name|LoginParam
argument_list|,
name|String
argument_list|>
implements|implements
name|Parameters
block|{
DECL|method|LoginParams ()
name|LoginParams
parameter_list|()
block|{
name|super
argument_list|(
name|LoginParam
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// do not add null values, nor allow existing values to be overriden.
annotation|@
name|Override
DECL|method|put (LoginParam param, String val)
specifier|public
name|String
name|put
parameter_list|(
name|LoginParam
name|param
parameter_list|,
name|String
name|val
parameter_list|)
block|{
name|boolean
name|add
init|=
name|val
operator|!=
literal|null
operator|&&
operator|!
name|containsKey
argument_list|(
name|param
argument_list|)
decl_stmt|;
return|return
name|add
condition|?
name|super
operator|.
name|put
argument_list|(
name|param
argument_list|,
name|val
argument_list|)
else|:
literal|null
return|;
block|}
DECL|method|getDefaults ()
specifier|static
name|LoginParams
name|getDefaults
parameter_list|()
block|{
name|LoginParams
name|params
init|=
operator|new
name|LoginParams
argument_list|()
decl_stmt|;
name|params
operator|.
name|put
argument_list|(
name|LoginParam
operator|.
name|PRINCIPAL
argument_list|,
name|System
operator|.
name|getenv
argument_list|(
literal|"KRB5PRINCIPAL"
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
name|LoginParam
operator|.
name|KEYTAB
argument_list|,
name|System
operator|.
name|getenv
argument_list|(
literal|"KRB5KEYTAB"
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|put
argument_list|(
name|LoginParam
operator|.
name|CCACHE
argument_list|,
name|System
operator|.
name|getenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|params
return|;
block|}
block|}
end_class

begin_comment
comment|// wrapper to allow access to fields necessary to recreate the same login
end_comment

begin_comment
comment|// context for relogin.  explicitly private to prevent external tampering.
end_comment

begin_class
DECL|class|HadoopLoginContext
specifier|private
specifier|static
class|class
name|HadoopLoginContext
extends|extends
name|LoginContext
block|{
DECL|field|appName
specifier|private
specifier|final
name|String
name|appName
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|HadoopConfiguration
name|conf
decl_stmt|;
DECL|field|isLoggedIn
specifier|private
name|AtomicBoolean
name|isLoggedIn
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|method|HadoopLoginContext (String appName, Subject subject, HadoopConfiguration conf)
name|HadoopLoginContext
parameter_list|(
name|String
name|appName
parameter_list|,
name|Subject
name|subject
parameter_list|,
name|HadoopConfiguration
name|conf
parameter_list|)
throws|throws
name|LoginException
block|{
name|super
argument_list|(
name|appName
argument_list|,
name|subject
argument_list|,
literal|null
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|appName
operator|=
name|appName
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
DECL|method|getAppName ()
name|String
name|getAppName
parameter_list|()
block|{
return|return
name|appName
return|;
block|}
DECL|method|getConfiguration ()
name|HadoopConfiguration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|// the locking model for logins cannot rely on ugi instance synchronization
comment|// since a subject will be referenced by multiple ugi instances.
DECL|method|getSubjectLock ()
name|Object
name|getSubjectLock
parameter_list|()
block|{
name|Subject
name|subject
init|=
name|getSubject
argument_list|()
decl_stmt|;
comment|// if subject is null, the login context will create the subject
comment|// so just lock on this context.
return|return
operator|(
name|subject
operator|==
literal|null
operator|)
condition|?
name|this
else|:
name|subject
operator|.
name|getPrivateCredentials
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|login ()
specifier|public
name|void
name|login
parameter_list|()
throws|throws
name|LoginException
block|{
synchronized|synchronized
init|(
name|getSubjectLock
argument_list|()
init|)
block|{
name|MutableRate
name|metric
init|=
name|metrics
operator|.
name|loginFailure
decl_stmt|;
name|long
name|start
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
try|try
block|{
name|super
operator|.
name|login
argument_list|()
expr_stmt|;
name|isLoggedIn
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|metric
operator|=
name|metrics
operator|.
name|loginSuccess
expr_stmt|;
block|}
finally|finally
block|{
name|metric
operator|.
name|add
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|logout ()
specifier|public
name|void
name|logout
parameter_list|()
throws|throws
name|LoginException
block|{
synchronized|synchronized
init|(
name|getSubjectLock
argument_list|()
init|)
block|{
if|if
condition|(
name|isLoggedIn
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|super
operator|.
name|logout
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * A JAAS configuration that defines the login modules that we want    * to use for login.    */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|HadoopConfiguration
specifier|private
specifier|static
class|class
name|HadoopConfiguration
extends|extends
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
block|{
DECL|field|KRB5_LOGIN_MODULE
specifier|static
specifier|final
name|String
name|KRB5_LOGIN_MODULE
init|=
name|KerberosUtil
operator|.
name|getKrb5LoginModuleName
argument_list|()
decl_stmt|;
DECL|field|SIMPLE_CONFIG_NAME
specifier|static
specifier|final
name|String
name|SIMPLE_CONFIG_NAME
init|=
literal|"hadoop-simple"
decl_stmt|;
DECL|field|KERBEROS_CONFIG_NAME
specifier|static
specifier|final
name|String
name|KERBEROS_CONFIG_NAME
init|=
literal|"hadoop-kerberos"
decl_stmt|;
DECL|field|BASIC_JAAS_OPTIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|BASIC_JAAS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
if|if
condition|(
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|System
operator|.
name|getenv
argument_list|(
literal|"HADOOP_JAAS_DEBUG"
argument_list|)
argument_list|)
condition|)
block|{
name|BASIC_JAAS_OPTIONS
operator|.
name|put
argument_list|(
literal|"debug"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|OS_SPECIFIC_LOGIN
specifier|static
specifier|final
name|AppConfigurationEntry
name|OS_SPECIFIC_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|OS_LOGIN_MODULE_NAME
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|BASIC_JAAS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|HADOOP_LOGIN
specifier|static
specifier|final
name|AppConfigurationEntry
name|HADOOP_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|HadoopLoginModule
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|BASIC_JAAS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|params
specifier|private
specifier|final
name|LoginParams
name|params
decl_stmt|;
DECL|method|HadoopConfiguration (LoginParams params)
name|HadoopConfiguration
parameter_list|(
name|LoginParams
name|params
parameter_list|)
block|{
name|this
operator|.
name|params
operator|=
name|params
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getParameters ()
specifier|public
name|LoginParams
name|getParameters
parameter_list|()
block|{
return|return
name|params
return|;
block|}
annotation|@
name|Override
DECL|method|getAppConfigurationEntry (String appName)
specifier|public
name|AppConfigurationEntry
index|[]
name|getAppConfigurationEntry
parameter_list|(
name|String
name|appName
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|AppConfigurationEntry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// login of external subject passes no params.  technically only
comment|// existing credentials should be used but other components expect
comment|// the login to succeed with local user fallback if no principal.
if|if
condition|(
name|params
operator|==
literal|null
operator|||
name|appName
operator|.
name|equals
argument_list|(
name|SIMPLE_CONFIG_NAME
argument_list|)
condition|)
block|{
name|entries
operator|.
name|add
argument_list|(
name|OS_SPECIFIC_LOGIN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|appName
operator|.
name|equals
argument_list|(
name|KERBEROS_CONFIG_NAME
argument_list|)
condition|)
block|{
comment|// existing semantics are the initial default login allows local user
comment|// fallback. this is not allowed when a principal explicitly
comment|// specified or during a relogin.
if|if
condition|(
operator|!
name|params
operator|.
name|containsKey
argument_list|(
name|LoginParam
operator|.
name|PRINCIPAL
argument_list|)
condition|)
block|{
name|entries
operator|.
name|add
argument_list|(
name|OS_SPECIFIC_LOGIN
argument_list|)
expr_stmt|;
block|}
name|entries
operator|.
name|add
argument_list|(
name|getKerberosEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|entries
operator|.
name|add
argument_list|(
name|HADOOP_LOGIN
argument_list|)
expr_stmt|;
return|return
name|entries
operator|.
name|toArray
argument_list|(
operator|new
name|AppConfigurationEntry
index|[
literal|0
index|]
argument_list|)
return|;
block|}
DECL|method|getKerberosEntry ()
specifier|private
name|AppConfigurationEntry
name|getKerberosEntry
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|BASIC_JAAS_OPTIONS
argument_list|)
decl_stmt|;
name|LoginModuleControlFlag
name|controlFlag
init|=
name|LoginModuleControlFlag
operator|.
name|OPTIONAL
decl_stmt|;
comment|// kerberos login is mandatory if principal is specified.  principal
comment|// will not be set for initial default login, but will always be set
comment|// for relogins.
specifier|final
name|String
name|principal
init|=
name|params
operator|.
name|get
argument_list|(
name|LoginParam
operator|.
name|PRINCIPAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|principal
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"principal"
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|controlFlag
operator|=
name|LoginModuleControlFlag
operator|.
name|REQUIRED
expr_stmt|;
block|}
comment|// use keytab if given else fallback to ticket cache.
if|if
condition|(
name|IBM_JAVA
condition|)
block|{
if|if
condition|(
name|params
operator|.
name|containsKey
argument_list|(
name|LoginParam
operator|.
name|KEYTAB
argument_list|)
condition|)
block|{
specifier|final
name|String
name|keytab
init|=
name|params
operator|.
name|get
argument_list|(
name|LoginParam
operator|.
name|KEYTAB
argument_list|)
decl_stmt|;
if|if
condition|(
name|keytab
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"useKeytab"
argument_list|,
name|prependFileAuthority
argument_list|(
name|keytab
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|options
operator|.
name|put
argument_list|(
literal|"useDefaultKeytab"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
name|options
operator|.
name|put
argument_list|(
literal|"credsType"
argument_list|,
literal|"both"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|ticketCache
init|=
name|params
operator|.
name|get
argument_list|(
name|LoginParam
operator|.
name|CCACHE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ticketCache
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"useCcache"
argument_list|,
name|prependFileAuthority
argument_list|(
name|ticketCache
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|options
operator|.
name|put
argument_list|(
literal|"useDefaultCcache"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
name|options
operator|.
name|put
argument_list|(
literal|"renewTGT"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|params
operator|.
name|containsKey
argument_list|(
name|LoginParam
operator|.
name|KEYTAB
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"useKeyTab"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|keytab
init|=
name|params
operator|.
name|get
argument_list|(
name|LoginParam
operator|.
name|KEYTAB
argument_list|)
decl_stmt|;
if|if
condition|(
name|keytab
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"keyTab"
argument_list|,
name|keytab
argument_list|)
expr_stmt|;
block|}
name|options
operator|.
name|put
argument_list|(
literal|"storeKey"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|options
operator|.
name|put
argument_list|(
literal|"useTicketCache"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|String
name|ticketCache
init|=
name|params
operator|.
name|get
argument_list|(
name|LoginParam
operator|.
name|CCACHE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ticketCache
operator|!=
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"ticketCache"
argument_list|,
name|ticketCache
argument_list|)
expr_stmt|;
block|}
name|options
operator|.
name|put
argument_list|(
literal|"renewTGT"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
name|options
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
name|options
operator|.
name|put
argument_list|(
literal|"refreshKrb5Config"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
return|return
operator|new
name|AppConfigurationEntry
argument_list|(
name|KRB5_LOGIN_MODULE
argument_list|,
name|controlFlag
argument_list|,
name|options
argument_list|)
return|;
block|}
DECL|method|prependFileAuthority (String keytabPath)
specifier|private
specifier|static
name|String
name|prependFileAuthority
parameter_list|(
name|String
name|keytabPath
parameter_list|)
block|{
return|return
name|keytabPath
operator|.
name|startsWith
argument_list|(
literal|"file://"
argument_list|)
condition|?
name|keytabPath
else|:
literal|"file://"
operator|+
name|keytabPath
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * A test method to print out the current user's UGI.    * @param args if there are two arguments, read the user from the keytab    * and print it out.    * @throws Exception    */
end_comment

begin_function
DECL|method|main (String [] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Getting UGI for current user"
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|getCurrentUser
argument_list|()
decl_stmt|;
name|ugi
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"UGI: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Auth method "
operator|+
name|ugi
operator|.
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab "
operator|+
name|ugi
operator|.
name|isFromKeytab
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"============================================================"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Getting UGI from keytab...."
argument_list|)
expr_stmt|;
name|loginUserFromKeytab
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|getCurrentUser
argument_list|()
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|loginUgi
init|=
name|getLoginUser
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Auth method "
operator|+
name|loginUgi
operator|.
name|getAuthenticationMethod
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab "
operator|+
name|loginUgi
operator|.
name|isFromKeytab
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

unit|}
end_unit

