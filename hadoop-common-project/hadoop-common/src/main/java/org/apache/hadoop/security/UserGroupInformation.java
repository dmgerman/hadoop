begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_AUTHENTICATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessControlContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Principal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|Subject
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|callback
operator|.
name|CallbackHandler
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosKey
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosPrincipal
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosTicket
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
operator|.
name|LoginModuleControlFlag
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|spi
operator|.
name|LoginModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableRate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|KerberosName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|KerberosUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_comment
comment|/**  * User and group information for Hadoop.  * This class wraps around a JAAS Subject and provides methods to determine the  * user's username and groups. It supports both the Windows, Unix and Kerberos   * login modules.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|,
literal|"HBase"
block|,
literal|"Hive"
block|,
literal|"Oozie"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|UserGroupInformation
specifier|public
class|class
name|UserGroupInformation
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|UserGroupInformation
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Percentage of the ticket window to use before we renew ticket.    */
DECL|field|TICKET_RENEW_WINDOW
specifier|private
specifier|static
specifier|final
name|float
name|TICKET_RENEW_WINDOW
init|=
literal|0.80f
decl_stmt|;
DECL|field|HADOOP_USER_NAME
specifier|static
specifier|final
name|String
name|HADOOP_USER_NAME
init|=
literal|"HADOOP_USER_NAME"
decl_stmt|;
comment|/**     * UgiMetrics maintains UGI activity statistics    * and publishes them through the metrics interfaces.    */
annotation|@
name|Metrics
argument_list|(
name|about
operator|=
literal|"User and group related metrics"
argument_list|,
name|context
operator|=
literal|"ugi"
argument_list|)
DECL|class|UgiMetrics
specifier|static
class|class
name|UgiMetrics
block|{
annotation|@
name|Metric
argument_list|(
literal|"Rate of successful kerberos logins and latency (milliseconds)"
argument_list|)
DECL|field|loginSuccess
name|MutableRate
name|loginSuccess
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Rate of failed kerberos logins and latency (milliseconds)"
argument_list|)
DECL|field|loginFailure
name|MutableRate
name|loginFailure
decl_stmt|;
DECL|method|create ()
specifier|static
name|UgiMetrics
name|create
parameter_list|()
block|{
return|return
name|DefaultMetricsSystem
operator|.
name|instance
argument_list|()
operator|.
name|register
argument_list|(
operator|new
name|UgiMetrics
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * A login module that looks at the Kerberos, Unix, or Windows principal and    * adds the corresponding UserName.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|HadoopLoginModule
specifier|public
specifier|static
class|class
name|HadoopLoginModule
implements|implements
name|LoginModule
block|{
DECL|field|subject
specifier|private
name|Subject
name|subject
decl_stmt|;
annotation|@
name|Override
DECL|method|abort ()
specifier|public
name|boolean
name|abort
parameter_list|()
throws|throws
name|LoginException
block|{
return|return
literal|true
return|;
block|}
DECL|method|getCanonicalUser (Class<T> cls)
specifier|private
parameter_list|<
name|T
extends|extends
name|Principal
parameter_list|>
name|T
name|getCanonicalUser
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|cls
parameter_list|)
block|{
for|for
control|(
name|T
name|user
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|cls
argument_list|)
control|)
block|{
return|return
name|user
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|commit ()
specifier|public
name|boolean
name|commit
parameter_list|()
throws|throws
name|LoginException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"hadoop login commit"
argument_list|)
expr_stmt|;
block|}
comment|// if we already have a user, we are done.
if|if
condition|(
operator|!
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"using existing subject:"
operator|+
name|subject
operator|.
name|getPrincipals
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|Principal
name|user
init|=
literal|null
decl_stmt|;
comment|// if we are using kerberos, try it out
if|if
condition|(
name|useKerberos
condition|)
block|{
name|user
operator|=
name|getCanonicalUser
argument_list|(
name|KerberosPrincipal
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"using kerberos user:"
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
block|}
comment|//If we don't have a kerberos user and security is disabled, check
comment|//if user is specified in the environment or properties
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
operator|&&
operator|(
name|user
operator|==
literal|null
operator|)
condition|)
block|{
name|String
name|envUser
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_USER_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|envUser
operator|==
literal|null
condition|)
block|{
name|envUser
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_USER_NAME
argument_list|)
expr_stmt|;
block|}
name|user
operator|=
name|envUser
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|User
argument_list|(
name|envUser
argument_list|)
expr_stmt|;
block|}
comment|// use the OS user
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
name|user
operator|=
name|getCanonicalUser
argument_list|(
name|OS_PRINCIPAL_CLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"using local user:"
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we found the user, add our principal
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't find user in "
operator|+
name|subject
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LoginException
argument_list|(
literal|"Can't find user name"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|initialize (Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)
specifier|public
name|void
name|initialize
parameter_list|(
name|Subject
name|subject
parameter_list|,
name|CallbackHandler
name|callbackHandler
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|sharedState
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|login ()
specifier|public
name|boolean
name|login
parameter_list|()
throws|throws
name|LoginException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"hadoop login"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|logout ()
specifier|public
name|boolean
name|logout
parameter_list|()
throws|throws
name|LoginException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"hadoop logout"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/** Metrics to track UGI activity */
DECL|field|metrics
specifier|static
name|UgiMetrics
name|metrics
init|=
name|UgiMetrics
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/** Are the static variables that depend on configuration initialized? */
DECL|field|isInitialized
specifier|private
specifier|static
name|boolean
name|isInitialized
init|=
literal|false
decl_stmt|;
comment|/** Should we use Kerberos configuration? */
DECL|field|useKerberos
specifier|private
specifier|static
name|boolean
name|useKerberos
decl_stmt|;
comment|/** Server-side groups fetching service */
DECL|field|groups
specifier|private
specifier|static
name|Groups
name|groups
decl_stmt|;
comment|/** The configuration to use */
DECL|field|conf
specifier|private
specifier|static
name|Configuration
name|conf
decl_stmt|;
comment|/** Leave 10 minutes between relogin attempts. */
DECL|field|MIN_TIME_BEFORE_RELOGIN
specifier|private
specifier|static
specifier|final
name|long
name|MIN_TIME_BEFORE_RELOGIN
init|=
literal|10
operator|*
literal|60
operator|*
literal|1000L
decl_stmt|;
comment|/**Environment variable pointing to the token cache file*/
DECL|field|HADOOP_TOKEN_FILE_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_TOKEN_FILE_LOCATION
init|=
literal|"HADOOP_TOKEN_FILE_LOCATION"
decl_stmt|;
comment|/**     * A method to initialize the fields that depend on a configuration.    * Must be called before useKerberos or groups is used.    */
DECL|method|ensureInitialized ()
specifier|private
specifier|static
specifier|synchronized
name|void
name|ensureInitialized
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isInitialized
condition|)
block|{
name|initialize
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|,
name|KerberosName
operator|.
name|hasRulesBeenSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initialize UGI and related classes.    * @param conf the configuration to use    */
DECL|method|initialize (Configuration conf, boolean skipRulesSetting)
specifier|private
specifier|static
specifier|synchronized
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|skipRulesSetting
parameter_list|)
block|{
name|initUGI
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// give the configuration on how to translate Kerberos names
try|try
block|{
if|if
condition|(
operator|!
name|skipRulesSetting
condition|)
block|{
name|HadoopKerberosName
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Problem with Kerberos auth_to_local name "
operator|+
literal|"configuration"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
comment|/**    * Set the configuration values for UGI.    * @param conf the configuration to use    */
DECL|method|initUGI (Configuration conf)
specifier|private
specifier|static
specifier|synchronized
name|void
name|initUGI
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|value
init|=
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_SECURITY_AUTHENTICATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
literal|"simple"
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|useKerberos
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"kerberos"
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|useKerberos
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid attribute value for "
operator|+
name|HADOOP_SECURITY_AUTHENTICATION
operator|+
literal|" of "
operator|+
name|value
argument_list|)
throw|;
block|}
comment|// If we haven't set up testing groups, use the configuration to find it
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
name|Groups
operator|.
name|getUserToGroupsMappingService
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|isInitialized
operator|=
literal|true
expr_stmt|;
name|UserGroupInformation
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|/**    * Set the static configuration for UGI.    * In particular, set the security authentication mechanism and the    * group look up service.    * @param conf the configuration to use    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|setConfiguration (Configuration conf)
specifier|public
specifier|static
name|void
name|setConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|initialize
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine if UserGroupInformation is using Kerberos to determine    * user identities or is relying on simple authentication    *     * @return true if UGI is working in a secure environment    */
DECL|method|isSecurityEnabled ()
specifier|public
specifier|static
name|boolean
name|isSecurityEnabled
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
return|return
name|useKerberos
return|;
block|}
comment|/**    * Information about the logged in user.    */
DECL|field|loginUser
specifier|private
specifier|static
name|UserGroupInformation
name|loginUser
init|=
literal|null
decl_stmt|;
DECL|field|keytabPrincipal
specifier|private
specifier|static
name|String
name|keytabPrincipal
init|=
literal|null
decl_stmt|;
DECL|field|keytabFile
specifier|private
specifier|static
name|String
name|keytabFile
init|=
literal|null
decl_stmt|;
DECL|field|subject
specifier|private
specifier|final
name|Subject
name|subject
decl_stmt|;
comment|// All non-static fields must be read-only caches that come from the subject.
DECL|field|user
specifier|private
specifier|final
name|User
name|user
decl_stmt|;
DECL|field|isKeytab
specifier|private
specifier|final
name|boolean
name|isKeytab
decl_stmt|;
DECL|field|isKrbTkt
specifier|private
specifier|final
name|boolean
name|isKrbTkt
decl_stmt|;
DECL|field|OS_LOGIN_MODULE_NAME
specifier|private
specifier|static
name|String
name|OS_LOGIN_MODULE_NAME
decl_stmt|;
DECL|field|OS_PRINCIPAL_CLASS
specifier|private
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
name|OS_PRINCIPAL_CLASS
decl_stmt|;
DECL|field|windows
specifier|private
specifier|static
specifier|final
name|boolean
name|windows
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"Windows"
argument_list|)
decl_stmt|;
comment|/* Return the OS login module class name */
DECL|method|getOSLoginModuleName ()
specifier|private
specifier|static
name|String
name|getOSLoginModuleName
parameter_list|()
block|{
if|if
condition|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.vendor"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"IBM"
argument_list|)
condition|)
block|{
return|return
name|windows
condition|?
literal|"com.ibm.security.auth.module.NTLoginModule"
else|:
literal|"com.ibm.security.auth.module.LinuxLoginModule"
return|;
block|}
else|else
block|{
return|return
name|windows
condition|?
literal|"com.sun.security.auth.module.NTLoginModule"
else|:
literal|"com.sun.security.auth.module.UnixLoginModule"
return|;
block|}
block|}
comment|/* Return the OS principal class */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getOsPrincipalClass ()
specifier|private
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
name|getOsPrincipalClass
parameter_list|()
block|{
name|ClassLoader
name|cl
init|=
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.vendor"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"IBM"
argument_list|)
condition|)
block|{
if|if
condition|(
name|windows
condition|)
block|{
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
operator|)
name|cl
operator|.
name|loadClass
argument_list|(
literal|"com.ibm.security.auth.UsernamePrincipal"
argument_list|)
return|;
block|}
else|else
block|{
return|return
call|(
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
call|)
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.arch"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"64"
argument_list|)
condition|?
name|cl
operator|.
name|loadClass
argument_list|(
literal|"com.ibm.security.auth.UsernamePrincipal"
argument_list|)
else|:
name|cl
operator|.
name|loadClass
argument_list|(
literal|"com.ibm.security.auth.LinuxPrincipal"
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
call|(
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
call|)
argument_list|(
name|windows
condition|?
name|cl
operator|.
name|loadClass
argument_list|(
literal|"com.sun.security.auth.NTUserPrincipal"
argument_list|)
else|:
name|cl
operator|.
name|loadClass
argument_list|(
literal|"com.sun.security.auth.UnixPrincipal"
argument_list|)
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to find JAAS classes:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
static|static
block|{
name|OS_LOGIN_MODULE_NAME
operator|=
name|getOSLoginModuleName
argument_list|()
expr_stmt|;
name|OS_PRINCIPAL_CLASS
operator|=
name|getOsPrincipalClass
argument_list|()
expr_stmt|;
block|}
DECL|class|RealUser
specifier|private
specifier|static
class|class
name|RealUser
implements|implements
name|Principal
block|{
DECL|field|realUser
specifier|private
specifier|final
name|UserGroupInformation
name|realUser
decl_stmt|;
DECL|method|RealUser (UserGroupInformation realUser)
name|RealUser
parameter_list|(
name|UserGroupInformation
name|realUser
parameter_list|)
block|{
name|this
operator|.
name|realUser
operator|=
name|realUser
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|getUserName
argument_list|()
return|;
block|}
DECL|method|getRealUser ()
specifier|public
name|UserGroupInformation
name|getRealUser
parameter_list|()
block|{
return|return
name|realUser
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|realUser
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|RealUser
operator|)
name|o
operator|)
operator|.
name|realUser
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * A JAAS configuration that defines the login modules that we want    * to use for login.    */
DECL|class|HadoopConfiguration
specifier|private
specifier|static
class|class
name|HadoopConfiguration
extends|extends
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
block|{
DECL|field|SIMPLE_CONFIG_NAME
specifier|private
specifier|static
specifier|final
name|String
name|SIMPLE_CONFIG_NAME
init|=
literal|"hadoop-simple"
decl_stmt|;
DECL|field|USER_KERBEROS_CONFIG_NAME
specifier|private
specifier|static
specifier|final
name|String
name|USER_KERBEROS_CONFIG_NAME
init|=
literal|"hadoop-user-kerberos"
decl_stmt|;
DECL|field|KEYTAB_KERBEROS_CONFIG_NAME
specifier|private
specifier|static
specifier|final
name|String
name|KEYTAB_KERBEROS_CONFIG_NAME
init|=
literal|"hadoop-keytab-kerberos"
decl_stmt|;
DECL|field|BASIC_JAAS_OPTIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|BASIC_JAAS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|String
name|jaasEnvVar
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"HADOOP_JAAS_DEBUG"
argument_list|)
decl_stmt|;
if|if
condition|(
name|jaasEnvVar
operator|!=
literal|null
operator|&&
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|jaasEnvVar
argument_list|)
condition|)
block|{
name|BASIC_JAAS_OPTIONS
operator|.
name|put
argument_list|(
literal|"debug"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|OS_SPECIFIC_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|OS_SPECIFIC_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|OS_LOGIN_MODULE_NAME
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|BASIC_JAAS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|HADOOP_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|HADOOP_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|HadoopLoginModule
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|BASIC_JAAS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|USER_KERBEROS_OPTIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|USER_KERBEROS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useTicketCache"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"renewTGT"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|String
name|ticketCache
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ticketCache
operator|!=
literal|null
condition|)
block|{
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"ticketCache"
argument_list|,
name|ticketCache
argument_list|)
expr_stmt|;
block|}
name|USER_KERBEROS_OPTIONS
operator|.
name|putAll
argument_list|(
name|BASIC_JAAS_OPTIONS
argument_list|)
expr_stmt|;
block|}
DECL|field|USER_KERBEROS_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|USER_KERBEROS_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|KerberosUtil
operator|.
name|getKrb5LoginModuleName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|OPTIONAL
argument_list|,
name|USER_KERBEROS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|KEYTAB_KERBEROS_OPTIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|KEYTAB_KERBEROS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useKeyTab"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"storeKey"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"refreshKrb5Config"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|putAll
argument_list|(
name|BASIC_JAAS_OPTIONS
argument_list|)
expr_stmt|;
block|}
DECL|field|KEYTAB_KERBEROS_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|KEYTAB_KERBEROS_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|KerberosUtil
operator|.
name|getKrb5LoginModuleName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|KEYTAB_KERBEROS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|SIMPLE_CONF
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|SIMPLE_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|OS_SPECIFIC_LOGIN
block|,
name|HADOOP_LOGIN
block|}
decl_stmt|;
DECL|field|USER_KERBEROS_CONF
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|USER_KERBEROS_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|OS_SPECIFIC_LOGIN
block|,
name|USER_KERBEROS_LOGIN
block|,
name|HADOOP_LOGIN
block|}
decl_stmt|;
DECL|field|KEYTAB_KERBEROS_CONF
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|KEYTAB_KERBEROS_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|KEYTAB_KERBEROS_LOGIN
block|,
name|HADOOP_LOGIN
block|}
decl_stmt|;
annotation|@
name|Override
DECL|method|getAppConfigurationEntry (String appName)
specifier|public
name|AppConfigurationEntry
index|[]
name|getAppConfigurationEntry
parameter_list|(
name|String
name|appName
parameter_list|)
block|{
if|if
condition|(
name|SIMPLE_CONFIG_NAME
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
return|return
name|SIMPLE_CONF
return|;
block|}
elseif|else
if|if
condition|(
name|USER_KERBEROS_CONFIG_NAME
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
return|return
name|USER_KERBEROS_CONF
return|;
block|}
elseif|else
if|if
condition|(
name|KEYTAB_KERBEROS_CONFIG_NAME
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"keyTab"
argument_list|,
name|keytabFile
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"principal"
argument_list|,
name|keytabPrincipal
argument_list|)
expr_stmt|;
return|return
name|KEYTAB_KERBEROS_CONF
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
DECL|field|HADOOP_LOGIN_CONFIG
specifier|public
specifier|static
specifier|final
name|HadoopConfiguration
name|HADOOP_LOGIN_CONFIG
init|=
operator|new
name|HadoopConfiguration
argument_list|()
decl_stmt|;
comment|/**    * Represents a javax.security configuration that is created at runtime.    */
DECL|class|DynamicConfiguration
specifier|private
specifier|static
class|class
name|DynamicConfiguration
extends|extends
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
block|{
DECL|field|ace
specifier|private
name|AppConfigurationEntry
index|[]
name|ace
decl_stmt|;
DECL|method|DynamicConfiguration (AppConfigurationEntry[] ace)
name|DynamicConfiguration
parameter_list|(
name|AppConfigurationEntry
index|[]
name|ace
parameter_list|)
block|{
name|this
operator|.
name|ace
operator|=
name|ace
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getAppConfigurationEntry (String appName)
specifier|public
name|AppConfigurationEntry
index|[]
name|getAppConfigurationEntry
parameter_list|(
name|String
name|appName
parameter_list|)
block|{
return|return
name|ace
return|;
block|}
block|}
specifier|private
specifier|static
name|LoginContext
DECL|method|newLoginContext (String appName, Subject subject, javax.security.auth.login.Configuration loginConf)
name|newLoginContext
parameter_list|(
name|String
name|appName
parameter_list|,
name|Subject
name|subject
parameter_list|,
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
name|loginConf
parameter_list|)
throws|throws
name|LoginException
block|{
comment|// Temporarily switch the thread's ContextClassLoader to match this
comment|// class's classloader, so that we can properly load HadoopLoginModule
comment|// from the JAAS libraries.
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|ClassLoader
name|oldCCL
init|=
name|t
operator|.
name|getContextClassLoader
argument_list|()
decl_stmt|;
name|t
operator|.
name|setContextClassLoader
argument_list|(
name|HadoopLoginModule
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
return|return
operator|new
name|LoginContext
argument_list|(
name|appName
argument_list|,
name|subject
argument_list|,
literal|null
argument_list|,
name|loginConf
argument_list|)
return|;
block|}
finally|finally
block|{
name|t
operator|.
name|setContextClassLoader
argument_list|(
name|oldCCL
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getLogin ()
specifier|private
name|LoginContext
name|getLogin
parameter_list|()
block|{
return|return
name|user
operator|.
name|getLogin
argument_list|()
return|;
block|}
DECL|method|setLogin (LoginContext login)
specifier|private
name|void
name|setLogin
parameter_list|(
name|LoginContext
name|login
parameter_list|)
block|{
name|user
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a UserGroupInformation for the given subject.    * This does not change the subject or acquire new credentials.    * @param subject the user's subject    */
DECL|method|UserGroupInformation (Subject subject)
name|UserGroupInformation
parameter_list|(
name|Subject
name|subject
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
name|this
operator|.
name|user
operator|=
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
name|this
operator|.
name|isKeytab
operator|=
operator|!
name|subject
operator|.
name|getPrivateCredentials
argument_list|(
name|KerberosKey
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|this
operator|.
name|isKrbTkt
operator|=
operator|!
name|subject
operator|.
name|getPrivateCredentials
argument_list|(
name|KerberosTicket
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
block|}
comment|/**    * checks if logged in using kerberos    * @return true if the subject logged via keytab or has a Kerberos TGT    */
DECL|method|hasKerberosCredentials ()
specifier|public
name|boolean
name|hasKerberosCredentials
parameter_list|()
block|{
return|return
name|isKeytab
operator|||
name|isKrbTkt
return|;
block|}
comment|/**    * Return the current user, including any doAs in the current stack.    * @return the current user    * @throws IOException if login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|synchronized
DECL|method|getCurrentUser ()
specifier|static
name|UserGroupInformation
name|getCurrentUser
parameter_list|()
throws|throws
name|IOException
block|{
name|AccessControlContext
name|context
init|=
name|AccessController
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|Subject
name|subject
init|=
name|Subject
operator|.
name|getSubject
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|subject
operator|==
literal|null
operator|||
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|getLoginUser
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
return|;
block|}
block|}
comment|/**    * Find the most appropriate UserGroupInformation to use    *    * @param ticketCachePath    The Kerberos ticket cache path, or NULL    *                           if none is specfied    * @param user               The user name, or NULL if none is specified.    *    * @return                   The most appropriate UserGroupInformation    */
DECL|method|getBestUGI ( String ticketCachePath, String user)
specifier|public
specifier|static
name|UserGroupInformation
name|getBestUGI
parameter_list|(
name|String
name|ticketCachePath
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ticketCachePath
operator|!=
literal|null
condition|)
block|{
return|return
name|getUGIFromTicketCache
argument_list|(
name|ticketCachePath
argument_list|,
name|user
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
return|return
name|getCurrentUser
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|createRemoteUser
argument_list|(
name|user
argument_list|)
return|;
block|}
block|}
comment|/**    * Create a UserGroupInformation from a Kerberos ticket cache.    *     * @param user                The principal name to load from the ticket    *                            cache    * @param ticketCachePath     the path to the ticket cache file    *    * @throws IOException        if the kerberos login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getUGIFromTicketCache ( String ticketCache, String user)
specifier|public
specifier|static
name|UserGroupInformation
name|getUGIFromTicketCache
parameter_list|(
name|String
name|ticketCache
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
block|{
return|return
name|getBestUGI
argument_list|(
literal|null
argument_list|,
name|user
argument_list|)
return|;
block|}
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|krbOptions
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"useTicketCache"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"useKeyTab"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"renewTGT"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|put
argument_list|(
literal|"ticketCache"
argument_list|,
name|ticketCache
argument_list|)
expr_stmt|;
name|krbOptions
operator|.
name|putAll
argument_list|(
name|HadoopConfiguration
operator|.
name|BASIC_JAAS_OPTIONS
argument_list|)
expr_stmt|;
name|AppConfigurationEntry
name|ace
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|KerberosUtil
operator|.
name|getKrb5LoginModuleName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|krbOptions
argument_list|)
decl_stmt|;
name|DynamicConfiguration
name|dynConf
init|=
operator|new
name|DynamicConfiguration
argument_list|(
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|ace
block|}
argument_list|)
decl_stmt|;
name|LoginContext
name|login
init|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|USER_KERBEROS_CONFIG_NAME
argument_list|,
literal|null
argument_list|,
name|dynConf
argument_list|)
decl_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|Subject
name|loginSubject
init|=
name|login
operator|.
name|getSubject
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Principal
argument_list|>
name|loginPrincipals
init|=
name|loginSubject
operator|.
name|getPrincipals
argument_list|()
decl_stmt|;
if|if
condition|(
name|loginPrincipals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No login principals found!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|loginPrincipals
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"found more than one principal in the ticket cache file "
operator|+
name|ticketCache
argument_list|)
expr_stmt|;
block|}
name|User
name|ugiUser
init|=
operator|new
name|User
argument_list|(
name|loginPrincipals
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|,
name|login
argument_list|)
decl_stmt|;
name|loginSubject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
name|ugiUser
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|loginSubject
argument_list|)
decl_stmt|;
name|ugi
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
name|ugi
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failure to login using ticket cache file "
operator|+
name|ticketCache
argument_list|,
name|le
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the currently logged in user.    * @return the logged in user    * @throws IOException if login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|synchronized
DECL|method|getLoginUser ()
specifier|static
name|UserGroupInformation
name|getLoginUser
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|loginUser
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|LoginContext
name|login
decl_stmt|;
if|if
condition|(
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|login
operator|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|USER_KERBEROS_CONFIG_NAME
argument_list|,
name|subject
argument_list|,
name|HADOOP_LOGIN_CONFIG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|login
operator|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|SIMPLE_CONFIG_NAME
argument_list|,
name|subject
argument_list|,
name|HADOOP_LOGIN_CONFIG
argument_list|)
expr_stmt|;
block|}
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|loginUser
operator|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|setAuthenticationMethod
argument_list|(
name|isSecurityEnabled
argument_list|()
condition|?
name|AuthenticationMethod
operator|.
name|KERBEROS
else|:
name|AuthenticationMethod
operator|.
name|SIMPLE
argument_list|)
expr_stmt|;
name|loginUser
operator|=
operator|new
name|UserGroupInformation
argument_list|(
name|login
operator|.
name|getSubject
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|fileLocation
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_TOKEN_FILE_LOCATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileLocation
operator|!=
literal|null
operator|&&
name|isSecurityEnabled
argument_list|()
condition|)
block|{
comment|// load the token storage file and put all of the tokens into the
comment|// user.
name|Credentials
name|cred
init|=
name|Credentials
operator|.
name|readTokenStorageFile
argument_list|(
operator|new
name|Path
argument_list|(
literal|"file:///"
operator|+
name|fileLocation
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|Token
argument_list|<
name|?
argument_list|>
name|token
range|:
name|cred
operator|.
name|getAllTokens
argument_list|()
control|)
block|{
name|loginUser
operator|.
name|addToken
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
name|loginUser
operator|.
name|spawnAutoRenewalThreadForUserCreds
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failure to login"
argument_list|,
name|le
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"UGI loginUser:"
operator|+
name|loginUser
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|loginUser
return|;
block|}
comment|/**    * Is this user logged in from a keytab file?    * @return true if the credentials are from a keytab file.    */
DECL|method|isFromKeytab ()
specifier|public
name|boolean
name|isFromKeytab
parameter_list|()
block|{
return|return
name|isKeytab
return|;
block|}
comment|/**    * Get the Kerberos TGT    * @return the user's TGT or null if none was found    */
DECL|method|getTGT ()
specifier|private
specifier|synchronized
name|KerberosTicket
name|getTGT
parameter_list|()
block|{
name|Set
argument_list|<
name|KerberosTicket
argument_list|>
name|tickets
init|=
name|subject
operator|.
name|getPrivateCredentials
argument_list|(
name|KerberosTicket
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|KerberosTicket
name|ticket
range|:
name|tickets
control|)
block|{
if|if
condition|(
name|SecurityUtil
operator|.
name|isOriginalTGT
argument_list|(
name|ticket
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found tgt "
operator|+
name|ticket
argument_list|)
expr_stmt|;
block|}
return|return
name|ticket
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getRefreshTime (KerberosTicket tgt)
specifier|private
name|long
name|getRefreshTime
parameter_list|(
name|KerberosTicket
name|tgt
parameter_list|)
block|{
name|long
name|start
init|=
name|tgt
operator|.
name|getStartTime
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|long
name|end
init|=
name|tgt
operator|.
name|getEndTime
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
return|return
name|start
operator|+
call|(
name|long
call|)
argument_list|(
operator|(
name|end
operator|-
name|start
operator|)
operator|*
name|TICKET_RENEW_WINDOW
argument_list|)
return|;
block|}
comment|/**Spawn a thread to do periodic renewals of kerberos credentials*/
DECL|method|spawnAutoRenewalThreadForUserCreds ()
specifier|private
name|void
name|spawnAutoRenewalThreadForUserCreds
parameter_list|()
block|{
if|if
condition|(
name|isSecurityEnabled
argument_list|()
condition|)
block|{
comment|//spawn thread only if we have kerb credentials
if|if
condition|(
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|==
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|&&
operator|!
name|isKeytab
condition|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|String
name|cmd
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hadoop.kerberos.kinit.command"
argument_list|,
literal|"kinit"
argument_list|)
decl_stmt|;
name|KerberosTicket
name|tgt
init|=
name|getTGT
argument_list|()
decl_stmt|;
if|if
condition|(
name|tgt
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|long
name|nextRefresh
init|=
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Current time is "
operator|+
name|now
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Next refresh is "
operator|+
name|nextRefresh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|now
operator|<
name|nextRefresh
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|nextRefresh
operator|-
name|now
argument_list|)
expr_stmt|;
block|}
name|Shell
operator|.
name|execCommand
argument_list|(
name|cmd
argument_list|,
literal|"-R"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"renewed ticket"
argument_list|)
expr_stmt|;
block|}
name|reloginFromTicketCache
argument_list|()
expr_stmt|;
name|tgt
operator|=
name|getTGT
argument_list|()
expr_stmt|;
if|if
condition|(
name|tgt
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No TGT after renewal. Aborting renew thread for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|nextRefresh
operator|=
name|Math
operator|.
name|max
argument_list|(
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
argument_list|,
name|now
operator|+
name|MIN_TIME_BEFORE_RELOGIN
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Terminating renewal thread"
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception encountered while running the"
operator|+
literal|" renewal command. Aborting renew thread. "
operator|+
name|ie
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
argument_list|)
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"TGT Renewer for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Log a user in from a keytab file. Loads a user identity from a keytab    * file and logs them in. They become the currently logged-in user.    * @param user the principal name to load from the keytab    * @param path the path to the keytab file    * @throws IOException if the keytab file can't be read    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|synchronized
DECL|method|loginUserFromKeytab (String user, String path )
specifier|static
name|void
name|loginUserFromKeytab
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
return|return;
name|keytabFile
operator|=
name|path
expr_stmt|;
name|keytabPrincipal
operator|=
name|user
expr_stmt|;
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|LoginContext
name|login
decl_stmt|;
name|long
name|start
init|=
literal|0
decl_stmt|;
try|try
block|{
name|login
operator|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|KEYTAB_KERBEROS_CONFIG_NAME
argument_list|,
name|subject
argument_list|,
name|HADOOP_LOGIN_CONFIG
argument_list|)
expr_stmt|;
name|start
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|loginSuccess
operator|.
name|add
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
name|loginUser
operator|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|loginFailure
operator|.
name|add
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Login failure for "
operator|+
name|user
operator|+
literal|" from keytab "
operator|+
name|path
argument_list|,
name|le
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Login successful for user "
operator|+
name|keytabPrincipal
operator|+
literal|" using keytab file "
operator|+
name|keytabFile
argument_list|)
expr_stmt|;
block|}
comment|/**    * Re-login a user from keytab if TGT is expired or is close to expiry.    *     * @throws IOException    */
DECL|method|checkTGTAndReloginFromKeytab ()
specifier|public
specifier|synchronized
name|void
name|checkTGTAndReloginFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
operator|||
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|||
operator|!
name|isKeytab
condition|)
return|return;
name|KerberosTicket
name|tgt
init|=
name|getTGT
argument_list|()
decl_stmt|;
if|if
condition|(
name|tgt
operator|!=
literal|null
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
condition|)
block|{
return|return;
block|}
name|reloginFromKeytab
argument_list|()
expr_stmt|;
block|}
comment|/**    * Re-Login a user in from a keytab file. Loads a user identity from a keytab    * file and logs them in. They become the currently logged-in user. This    * method assumes that {@link #loginUserFromKeytab(String, String)} had     * happened already.    * The Subject field of this UserGroupInformation object is updated to have    * the new credentials.    * @throws IOException on a failure    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|reloginFromKeytab ()
specifier|public
specifier|synchronized
name|void
name|reloginFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
operator|||
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|||
operator|!
name|isKeytab
condition|)
return|return;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasSufficientTimeElapsed
argument_list|(
name|now
argument_list|)
condition|)
block|{
return|return;
block|}
name|KerberosTicket
name|tgt
init|=
name|getTGT
argument_list|()
decl_stmt|;
comment|//Return if TGT is valid and is not going to expire soon.
if|if
condition|(
name|tgt
operator|!=
literal|null
operator|&&
name|now
operator|<
name|getRefreshTime
argument_list|(
name|tgt
argument_list|)
condition|)
block|{
return|return;
block|}
name|LoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|login
operator|==
literal|null
operator|||
name|keytabFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"loginUserFromKeyTab must be done first"
argument_list|)
throw|;
block|}
name|long
name|start
init|=
literal|0
decl_stmt|;
comment|// register most recent relogin attempt
name|user
operator|.
name|setLastLogin
argument_list|(
name|now
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initiating logout for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|UserGroupInformation
operator|.
name|class
init|)
block|{
comment|// clear up the kerberos state. But the tokens are not cleared! As per
comment|// the Java kerberos login module code, only the kerberos credentials
comment|// are cleared
name|login
operator|.
name|logout
argument_list|()
expr_stmt|;
comment|// login and also update the subject field of this instance to
comment|// have the new credentials (pass it to the LoginContext constructor)
name|login
operator|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|KEYTAB_KERBEROS_CONFIG_NAME
argument_list|,
name|getSubject
argument_list|()
argument_list|,
name|HADOOP_LOGIN_CONFIG
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initiating re-login for "
operator|+
name|keytabPrincipal
argument_list|)
expr_stmt|;
name|start
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|loginSuccess
operator|.
name|add
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|loginFailure
operator|.
name|add
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Login failure for "
operator|+
name|keytabPrincipal
operator|+
literal|" from keytab "
operator|+
name|keytabFile
argument_list|,
name|le
argument_list|)
throw|;
block|}
block|}
comment|/**    * Re-Login a user in from the ticket cache.  This    * method assumes that login had happened already.    * The Subject field of this UserGroupInformation object is updated to have    * the new credentials.    * @throws IOException on a failure    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|reloginFromTicketCache ()
specifier|public
specifier|synchronized
name|void
name|reloginFromTicketCache
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
operator|||
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
operator|||
operator|!
name|isKrbTkt
condition|)
return|return;
name|LoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|login
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"login must be done first"
argument_list|)
throw|;
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasSufficientTimeElapsed
argument_list|(
name|now
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// register most recent relogin attempt
name|user
operator|.
name|setLastLogin
argument_list|(
name|now
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initiating logout for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
comment|//clear up the kerberos state. But the tokens are not cleared! As per
comment|//the Java kerberos login module code, only the kerberos credentials
comment|//are cleared
name|login
operator|.
name|logout
argument_list|()
expr_stmt|;
comment|//login and also update the subject field of this instance to
comment|//have the new credentials (pass it to the LoginContext constructor)
name|login
operator|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|USER_KERBEROS_CONFIG_NAME
argument_list|,
name|getSubject
argument_list|()
argument_list|,
name|HADOOP_LOGIN_CONFIG
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initiating re-login for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Login failure for "
operator|+
name|getUserName
argument_list|()
argument_list|,
name|le
argument_list|)
throw|;
block|}
block|}
comment|/**    * Log a user in from a keytab file. Loads a user identity from a keytab    * file and login them in. This new user does not affect the currently    * logged-in user.    * @param user the principal name to load from the keytab    * @param path the path to the keytab file    * @throws IOException if the keytab file can't be read    */
specifier|public
specifier|synchronized
DECL|method|loginUserFromKeytabAndReturnUGI (String user, String path )
specifier|static
name|UserGroupInformation
name|loginUserFromKeytabAndReturnUGI
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
return|return
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
return|;
name|String
name|oldKeytabFile
init|=
literal|null
decl_stmt|;
name|String
name|oldKeytabPrincipal
init|=
literal|null
decl_stmt|;
name|long
name|start
init|=
literal|0
decl_stmt|;
try|try
block|{
name|oldKeytabFile
operator|=
name|keytabFile
expr_stmt|;
name|oldKeytabPrincipal
operator|=
name|keytabPrincipal
expr_stmt|;
name|keytabFile
operator|=
name|path
expr_stmt|;
name|keytabPrincipal
operator|=
name|user
expr_stmt|;
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|LoginContext
name|login
init|=
name|newLoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|KEYTAB_KERBEROS_CONFIG_NAME
argument_list|,
name|subject
argument_list|,
name|HADOOP_LOGIN_CONFIG
argument_list|)
decl_stmt|;
name|start
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|loginSuccess
operator|.
name|add
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|newLoginUser
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
decl_stmt|;
name|newLoginUser
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
name|newLoginUser
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|)
expr_stmt|;
return|return
name|newLoginUser
return|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|metrics
operator|.
name|loginFailure
operator|.
name|add
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Login failure for "
operator|+
name|user
operator|+
literal|" from keytab "
operator|+
name|path
argument_list|,
name|le
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|oldKeytabFile
operator|!=
literal|null
condition|)
name|keytabFile
operator|=
name|oldKeytabFile
expr_stmt|;
if|if
condition|(
name|oldKeytabPrincipal
operator|!=
literal|null
condition|)
name|keytabPrincipal
operator|=
name|oldKeytabPrincipal
expr_stmt|;
block|}
block|}
DECL|method|hasSufficientTimeElapsed (long now)
specifier|private
name|boolean
name|hasSufficientTimeElapsed
parameter_list|(
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|now
operator|-
name|user
operator|.
name|getLastLogin
argument_list|()
operator|<
name|MIN_TIME_BEFORE_RELOGIN
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not attempting to re-login since the last re-login was "
operator|+
literal|"attempted less than "
operator|+
operator|(
name|MIN_TIME_BEFORE_RELOGIN
operator|/
literal|1000
operator|)
operator|+
literal|" seconds"
operator|+
literal|" before."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Did the login happen via keytab    * @return true or false    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|isLoginKeytabBased ()
specifier|public
specifier|synchronized
specifier|static
name|boolean
name|isLoginKeytabBased
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getLoginUser
argument_list|()
operator|.
name|isKeytab
return|;
block|}
comment|/**    * Create a user from a login name. It is intended to be used for remote    * users in RPC, since it won't have any credentials.    * @param user the full user principal name, must not be empty or null    * @return the UserGroupInformation for the remote user.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createRemoteUser (String user)
specifier|public
specifier|static
name|UserGroupInformation
name|createRemoteUser
parameter_list|(
name|String
name|user
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
literal|null
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|user
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null user"
argument_list|)
throw|;
block|}
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|result
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
decl_stmt|;
name|result
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|SIMPLE
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * existing types of authentications' methods    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|enum|AuthenticationMethod
specifier|public
specifier|static
enum|enum
name|AuthenticationMethod
block|{
DECL|enumConstant|SIMPLE
name|SIMPLE
block|,
DECL|enumConstant|KERBEROS
name|KERBEROS
block|,
DECL|enumConstant|TOKEN
name|TOKEN
block|,
DECL|enumConstant|CERTIFICATE
name|CERTIFICATE
block|,
DECL|enumConstant|KERBEROS_SSL
name|KERBEROS_SSL
block|,
DECL|enumConstant|PROXY
name|PROXY
block|;   }
comment|/**    * Create a proxy user using username of the effective user and the ugi of the    * real user.    * @param user    * @param realUser    * @return proxyUser ugi    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createProxyUser (String user, UserGroupInformation realUser)
specifier|public
specifier|static
name|UserGroupInformation
name|createProxyUser
parameter_list|(
name|String
name|user
parameter_list|,
name|UserGroupInformation
name|realUser
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
literal|null
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|user
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null user"
argument_list|)
throw|;
block|}
if|if
condition|(
name|realUser
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null real user"
argument_list|)
throw|;
block|}
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Principal
argument_list|>
name|principals
init|=
name|subject
operator|.
name|getPrincipals
argument_list|()
decl_stmt|;
name|principals
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|principals
operator|.
name|add
argument_list|(
operator|new
name|RealUser
argument_list|(
name|realUser
argument_list|)
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|result
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
decl_stmt|;
name|result
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|PROXY
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * get RealUser (vs. EffectiveUser)    * @return realUser running over proxy user    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getRealUser ()
specifier|public
name|UserGroupInformation
name|getRealUser
parameter_list|()
block|{
for|for
control|(
name|RealUser
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|RealUser
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getRealUser
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * This class is used for storing the groups for testing. It stores a local    * map that has the translation of usernames to groups.    */
DECL|class|TestingGroups
specifier|private
specifier|static
class|class
name|TestingGroups
extends|extends
name|Groups
block|{
DECL|field|userToGroupsMapping
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|userToGroupsMapping
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|underlyingImplementation
specifier|private
name|Groups
name|underlyingImplementation
decl_stmt|;
DECL|method|TestingGroups (Groups underlyingImplementation)
specifier|private
name|TestingGroups
parameter_list|(
name|Groups
name|underlyingImplementation
parameter_list|)
block|{
name|super
argument_list|(
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|underlyingImplementation
operator|=
name|underlyingImplementation
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getGroups (String user)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getGroups
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|userToGroupsMapping
operator|.
name|get
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|underlyingImplementation
operator|.
name|getGroups
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|setUserGroups (String user, String[] groups)
specifier|private
name|void
name|setUserGroups
parameter_list|(
name|String
name|user
parameter_list|,
name|String
index|[]
name|groups
parameter_list|)
block|{
name|userToGroupsMapping
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|groups
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create a UGI for testing HDFS and MapReduce    * @param user the full user principal name    * @param userGroups the names of the groups that the user belongs to    * @return a fake user for running unit tests    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|createUserForTesting (String user, String[] userGroups)
specifier|public
specifier|static
name|UserGroupInformation
name|createUserForTesting
parameter_list|(
name|String
name|user
parameter_list|,
name|String
index|[]
name|userGroups
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|createRemoteUser
argument_list|(
name|user
argument_list|)
decl_stmt|;
comment|// make sure that the testing object is setup
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
operator|new
name|TestingGroups
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
comment|// add the user groups
operator|(
operator|(
name|TestingGroups
operator|)
name|groups
operator|)
operator|.
name|setUserGroups
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|userGroups
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
comment|/**    * Create a proxy user UGI for testing HDFS and MapReduce    *     * @param user    *          the full user principal name for effective user    * @param realUser    *          UGI of the real user    * @param userGroups    *          the names of the groups that the user belongs to    * @return a fake user for running unit tests    */
DECL|method|createProxyUserForTesting (String user, UserGroupInformation realUser, String[] userGroups)
specifier|public
specifier|static
name|UserGroupInformation
name|createProxyUserForTesting
parameter_list|(
name|String
name|user
parameter_list|,
name|UserGroupInformation
name|realUser
parameter_list|,
name|String
index|[]
name|userGroups
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|createProxyUser
argument_list|(
name|user
argument_list|,
name|realUser
argument_list|)
decl_stmt|;
comment|// make sure that the testing object is setup
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
operator|new
name|TestingGroups
argument_list|(
name|groups
argument_list|)
expr_stmt|;
block|}
comment|// add the user groups
operator|(
operator|(
name|TestingGroups
operator|)
name|groups
operator|)
operator|.
name|setUserGroups
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|userGroups
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
comment|/**    * Get the user's login name.    * @return the user's name up to the first '/' or '@'.    */
DECL|method|getShortUserName ()
specifier|public
name|String
name|getShortUserName
parameter_list|()
block|{
for|for
control|(
name|User
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getShortName
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get the user's full principal name.    * @return the user's full principal name.    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getUserName ()
specifier|public
name|String
name|getUserName
parameter_list|()
block|{
return|return
name|user
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**    * Add a TokenIdentifier to this UGI. The TokenIdentifier has typically been    * authenticated by the RPC layer as belonging to the user represented by this    * UGI.    *     * @param tokenId    *          tokenIdentifier to be added    * @return true on successful add of new tokenIdentifier    */
DECL|method|addTokenIdentifier (TokenIdentifier tokenId)
specifier|public
specifier|synchronized
name|boolean
name|addTokenIdentifier
parameter_list|(
name|TokenIdentifier
name|tokenId
parameter_list|)
block|{
return|return
name|subject
operator|.
name|getPublicCredentials
argument_list|()
operator|.
name|add
argument_list|(
name|tokenId
argument_list|)
return|;
block|}
comment|/**    * Get the set of TokenIdentifiers belonging to this UGI    *     * @return the set of TokenIdentifiers belonging to this UGI    */
DECL|method|getTokenIdentifiers ()
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|TokenIdentifier
argument_list|>
name|getTokenIdentifiers
parameter_list|()
block|{
return|return
name|subject
operator|.
name|getPublicCredentials
argument_list|(
name|TokenIdentifier
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**    * Add a token to this UGI    *     * @param token Token to be added    * @return true on successful add of new token    */
DECL|method|addToken (Token<? extends TokenIdentifier> token)
specifier|public
specifier|synchronized
name|boolean
name|addToken
parameter_list|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
return|return
name|subject
operator|.
name|getPrivateCredentials
argument_list|()
operator|.
name|add
argument_list|(
name|token
argument_list|)
return|;
block|}
comment|/**    * Obtain the collection of tokens associated with this user.    *     * @return an unmodifiable collection of tokens associated with user    */
specifier|public
specifier|synchronized
DECL|method|getTokens ()
name|Collection
argument_list|<
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|getTokens
parameter_list|()
block|{
name|Set
argument_list|<
name|Object
argument_list|>
name|creds
init|=
name|subject
operator|.
name|getPrivateCredentials
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|creds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|creds
control|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Token
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|(
name|Token
argument_list|<
name|?
argument_list|>
operator|)
name|o
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**    * Get the group names for this user.    * @return the list of users with the primary group first. If the command    *    fails, it returns an empty list.    */
DECL|method|getGroupNames ()
specifier|public
specifier|synchronized
name|String
index|[]
name|getGroupNames
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|groups
operator|.
name|getGroups
argument_list|(
name|getShortUserName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|result
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|result
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No groups available for user "
operator|+
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
block|}
comment|/**    * Return the username.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|getUserName
argument_list|()
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" (auth:"
operator|+
name|getAuthenticationMethod
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" via "
argument_list|)
operator|.
name|append
argument_list|(
name|getRealUser
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Sets the authentication method in the subject    *     * @param authMethod    */
specifier|public
specifier|synchronized
DECL|method|setAuthenticationMethod (AuthenticationMethod authMethod)
name|void
name|setAuthenticationMethod
parameter_list|(
name|AuthenticationMethod
name|authMethod
parameter_list|)
block|{
name|user
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the authentication method from the subject    *     * @return AuthenticationMethod in the subject, null if not present.    */
DECL|method|getAuthenticationMethod ()
specifier|public
specifier|synchronized
name|AuthenticationMethod
name|getAuthenticationMethod
parameter_list|()
block|{
return|return
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
return|;
block|}
comment|/**    * Returns the authentication method of a ugi. If the authentication method is    * PROXY, returns the authentication method of the real user.    *     * @param ugi    * @return AuthenticationMethod    */
DECL|method|getRealAuthenticationMethod ( UserGroupInformation ugi)
specifier|public
specifier|static
name|AuthenticationMethod
name|getRealAuthenticationMethod
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
name|AuthenticationMethod
name|authMethod
init|=
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthenticationMethod
operator|.
name|PROXY
condition|)
block|{
name|authMethod
operator|=
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getAuthenticationMethod
argument_list|()
expr_stmt|;
block|}
return|return
name|authMethod
return|;
block|}
comment|/**    * Compare the subjects to see if they are equal to each other.    */
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|subject
operator|==
operator|(
operator|(
name|UserGroupInformation
operator|)
name|o
operator|)
operator|.
name|subject
return|;
block|}
block|}
comment|/**    * Return the hash of the subject.    */
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|subject
argument_list|)
return|;
block|}
comment|/**    * Get the underlying subject from this ugi.    * @return the subject that represents this user.    */
DECL|method|getSubject ()
specifier|protected
name|Subject
name|getSubject
parameter_list|()
block|{
return|return
name|subject
return|;
block|}
comment|/**    * Run the given action as the user.    * @param<T> the return type of the run method    * @param action the method to execute    * @return the value from the run method    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|doAs (PrivilegedAction<T> action)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|doAs
parameter_list|(
name|PrivilegedAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
block|{
name|logPrivilegedAction
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
name|Subject
operator|.
name|doAs
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**    * Run the given action as the user, potentially throwing an exception.    * @param<T> the return type of the run method    * @param action the method to execute    * @return the value from the run method    * @throws IOException if the action throws an IOException    * @throws Error if the action throws an Error    * @throws RuntimeException if the action throws a RuntimeException    * @throws InterruptedException if the action throws an InterruptedException    * @throws UndeclaredThrowableException if the action throws something else    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|doAs (PrivilegedExceptionAction<T> action )
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|doAs
parameter_list|(
name|PrivilegedExceptionAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|logPrivilegedAction
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
name|Subject
operator|.
name|doAs
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|pae
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"PriviledgedActionException as:"
operator|+
name|this
operator|+
literal|" cause:"
operator|+
name|cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|InterruptedException
condition|)
block|{
throw|throw
operator|(
name|InterruptedException
operator|)
name|cause
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UndeclaredThrowableException
argument_list|(
name|pae
argument_list|,
literal|"Unknown exception in doAs"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|logPrivilegedAction (Subject subject, Object action)
specifier|private
name|void
name|logPrivilegedAction
parameter_list|(
name|Subject
name|subject
parameter_list|,
name|Object
name|action
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// would be nice if action included a descriptive toString()
name|String
name|where
init|=
operator|new
name|Throwable
argument_list|()
operator|.
name|getStackTrace
argument_list|()
index|[
literal|2
index|]
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"PrivilegedAction as:"
operator|+
name|this
operator|+
literal|" from:"
operator|+
name|where
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|print ()
specifier|private
name|void
name|print
parameter_list|()
throws|throws
name|IOException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"User: "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Group Ids: "
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|String
index|[]
name|groups
init|=
name|getGroupNames
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Groups: "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groups
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|groups
index|[
name|i
index|]
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**    * A test method to print out the current user's UGI.    * @param args if there are two arguments, read the user from the keytab    * and print it out.    * @throws Exception    */
DECL|method|main (String [] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Getting UGI for current user"
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|getCurrentUser
argument_list|()
decl_stmt|;
name|ugi
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"UGI: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Auth method "
operator|+
name|ugi
operator|.
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab "
operator|+
name|ugi
operator|.
name|isKeytab
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"============================================================"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Getting UGI from keytab...."
argument_list|)
expr_stmt|;
name|loginUserFromKeytab
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|getCurrentUser
argument_list|()
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Auth method "
operator|+
name|loginUser
operator|.
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab "
operator|+
name|loginUser
operator|.
name|isKeytab
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

