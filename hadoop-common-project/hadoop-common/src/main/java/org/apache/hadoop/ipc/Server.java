begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ipc
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RpcConstants
operator|.
name|AUTHORIZATION_FAILED_CALL_ID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RpcConstants
operator|.
name|CONNECTION_CONTEXT_CALL_ID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RpcConstants
operator|.
name|CURRENT_VERSION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RpcConstants
operator|.
name|HEADER_LEN_AFTER_HRPC_PART
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RpcConstants
operator|.
name|PING_CALL_ID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ServerSocket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|CancelledKeyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Channels
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SelectionKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Selector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ServerSocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|WritableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimerTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|Sasl
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|SaslException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|SaslServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Public
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
operator|.
name|IntegerRanges
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|CallQueueManager
operator|.
name|CallQueueOverflowException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
operator|.
name|RpcInvoker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
operator|.
name|VersionMismatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|metrics
operator|.
name|RpcDetailedMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|metrics
operator|.
name|RpcMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|IpcConnectionContextProtos
operator|.
name|IpcConnectionContextProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcKindProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcRequestHeaderProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcResponseHeaderProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcResponseHeaderProto
operator|.
name|RpcErrorCodeProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcResponseHeaderProto
operator|.
name|RpcStatusProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcSaslProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcSaslProto
operator|.
name|SaslAuth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcSaslProto
operator|.
name|SaslState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SaslPropertiesResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SaslRpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SaslRpcServer
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|AuthenticationMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AuthorizationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|PolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ProxyUsers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ServiceAuthorizationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ProtoUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|SpanId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Tracer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|databind
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|CodedOutputStream
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/** An abstract IPC service.  IPC calls take a single {@link Writable} as a  * parameter, and return a {@link Writable} as their value.  A service runs on  * a port and is defined by a parameter class and a value class.  *   * @see Client  */
end_comment

begin_class
annotation|@
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|Server
specifier|public
specifier|abstract
class|class
name|Server
block|{
DECL|field|authorize
specifier|private
specifier|final
name|boolean
name|authorize
decl_stmt|;
DECL|field|enabledAuthMethods
specifier|private
name|List
argument_list|<
name|AuthMethod
argument_list|>
name|enabledAuthMethods
decl_stmt|;
DECL|field|negotiateResponse
specifier|private
name|RpcSaslProto
name|negotiateResponse
decl_stmt|;
DECL|field|exceptionsHandler
specifier|private
name|ExceptionsHandler
name|exceptionsHandler
init|=
operator|new
name|ExceptionsHandler
argument_list|()
decl_stmt|;
DECL|field|tracer
specifier|private
name|Tracer
name|tracer
decl_stmt|;
DECL|field|alignmentContext
specifier|private
name|AlignmentContext
name|alignmentContext
decl_stmt|;
comment|/**    * Logical name of the server used in metrics and monitor.    */
DECL|field|serverName
specifier|private
specifier|final
name|String
name|serverName
decl_stmt|;
comment|/**    * Add exception classes for which server won't log stack traces.    *    * @param exceptionClass exception classes    */
DECL|method|addTerseExceptions (Class<?>.... exceptionClass)
specifier|public
name|void
name|addTerseExceptions
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|exceptionClass
parameter_list|)
block|{
name|exceptionsHandler
operator|.
name|addTerseLoggingExceptions
argument_list|(
name|exceptionClass
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add exception classes which server won't log at all.    *    * @param exceptionClass exception classes    */
DECL|method|addSuppressedLoggingExceptions (Class<?>.... exceptionClass)
specifier|public
name|void
name|addSuppressedLoggingExceptions
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|exceptionClass
parameter_list|)
block|{
name|exceptionsHandler
operator|.
name|addSuppressedLoggingExceptions
argument_list|(
name|exceptionClass
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set alignment context to pass state info thru RPC.    *    * @param alignmentContext alignment state context    */
DECL|method|setAlignmentContext (AlignmentContext alignmentContext)
specifier|public
name|void
name|setAlignmentContext
parameter_list|(
name|AlignmentContext
name|alignmentContext
parameter_list|)
block|{
name|this
operator|.
name|alignmentContext
operator|=
name|alignmentContext
expr_stmt|;
block|}
comment|/**    * ExceptionsHandler manages Exception groups for special handling    * e.g., terse exception group for concise logging messages    */
DECL|class|ExceptionsHandler
specifier|static
class|class
name|ExceptionsHandler
block|{
DECL|field|terseExceptions
specifier|private
specifier|volatile
name|Set
argument_list|<
name|String
argument_list|>
name|terseExceptions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|suppressedExceptions
specifier|private
specifier|volatile
name|Set
argument_list|<
name|String
argument_list|>
name|suppressedExceptions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Add exception classes for which server won't log stack traces.      * Optimized for infrequent invocation.      * @param exceptionClass exception classes       */
DECL|method|addTerseLoggingExceptions (Class<?>.... exceptionClass)
name|void
name|addTerseLoggingExceptions
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|exceptionClass
parameter_list|)
block|{
comment|// Thread-safe replacement of terseExceptions.
name|terseExceptions
operator|=
name|addExceptions
argument_list|(
name|terseExceptions
argument_list|,
name|exceptionClass
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add exception classes which server won't log at all.      * Optimized for infrequent invocation.      * @param exceptionClass exception classes      */
DECL|method|addSuppressedLoggingExceptions (Class<?>.... exceptionClass)
name|void
name|addSuppressedLoggingExceptions
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|exceptionClass
parameter_list|)
block|{
comment|// Thread-safe replacement of suppressedExceptions.
name|suppressedExceptions
operator|=
name|addExceptions
argument_list|(
name|suppressedExceptions
argument_list|,
name|exceptionClass
argument_list|)
expr_stmt|;
block|}
DECL|method|isTerseLog (Class<?> t)
name|boolean
name|isTerseLog
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
return|return
name|terseExceptions
operator|.
name|contains
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|isSuppressedLog (Class<?> t)
name|boolean
name|isSuppressedLog
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
return|return
name|suppressedExceptions
operator|.
name|contains
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Return a new set containing all the exceptions in exceptionsSet      * and exceptionClass.      * @return      */
DECL|method|addExceptions ( final Set<String> exceptionsSet, Class<?>[] exceptionClass)
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|addExceptions
parameter_list|(
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|exceptionsSet
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|exceptionClass
parameter_list|)
block|{
comment|// Make a copy of the exceptionSet for performing modification
specifier|final
name|HashSet
argument_list|<
name|String
argument_list|>
name|newSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|exceptionsSet
argument_list|)
decl_stmt|;
comment|// Add all class names into the HashSet
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|name
range|:
name|exceptionClass
control|)
block|{
name|newSet
operator|.
name|add
argument_list|(
name|name
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|newSet
argument_list|)
return|;
block|}
block|}
comment|/**    * If the user accidentally sends an HTTP GET to an IPC port, we detect this    * and send back a nicer response.    */
DECL|field|HTTP_GET_BYTES
specifier|private
specifier|static
specifier|final
name|ByteBuffer
name|HTTP_GET_BYTES
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
literal|"GET "
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * An HTTP response to send back if we detect an HTTP request to our IPC    * port.    */
DECL|field|RECEIVED_HTTP_REQ_RESPONSE
specifier|static
specifier|final
name|String
name|RECEIVED_HTTP_REQ_RESPONSE
init|=
literal|"HTTP/1.1 404 Not Found\r\n"
operator|+
literal|"Content-type: text/plain\r\n\r\n"
operator|+
literal|"It looks like you are making an HTTP request to a Hadoop IPC port. "
operator|+
literal|"This is not the correct port for the web interface on this daemon.\r\n"
decl_stmt|;
comment|/**    * Initial and max size of response buffer    */
DECL|field|INITIAL_RESP_BUF_SIZE
specifier|static
name|int
name|INITIAL_RESP_BUF_SIZE
init|=
literal|10240
decl_stmt|;
DECL|class|RpcKindMapValue
specifier|static
class|class
name|RpcKindMapValue
block|{
DECL|field|rpcRequestWrapperClass
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|rpcRequestWrapperClass
decl_stmt|;
DECL|field|rpcInvoker
specifier|final
name|RpcInvoker
name|rpcInvoker
decl_stmt|;
DECL|method|RpcKindMapValue (Class<? extends Writable> rpcRequestWrapperClass, RpcInvoker rpcInvoker)
name|RpcKindMapValue
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|rpcRequestWrapperClass
parameter_list|,
name|RpcInvoker
name|rpcInvoker
parameter_list|)
block|{
name|this
operator|.
name|rpcInvoker
operator|=
name|rpcInvoker
expr_stmt|;
name|this
operator|.
name|rpcRequestWrapperClass
operator|=
name|rpcRequestWrapperClass
expr_stmt|;
block|}
block|}
DECL|field|rpcKindMap
specifier|static
name|Map
argument_list|<
name|RPC
operator|.
name|RpcKind
argument_list|,
name|RpcKindMapValue
argument_list|>
name|rpcKindMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
comment|/**    * Register a RPC kind and the class to deserialize the rpc request.    *     * Called by static initializers of rpcKind Engines    * @param rpcKind    * @param rpcRequestWrapperClass - this class is used to deserialze the    *  the rpc request.    *  @param rpcInvoker - use to process the calls on SS.    */
DECL|method|registerProtocolEngine (RPC.RpcKind rpcKind, Class<? extends Writable> rpcRequestWrapperClass, RpcInvoker rpcInvoker)
specifier|public
specifier|static
name|void
name|registerProtocolEngine
parameter_list|(
name|RPC
operator|.
name|RpcKind
name|rpcKind
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|rpcRequestWrapperClass
parameter_list|,
name|RpcInvoker
name|rpcInvoker
parameter_list|)
block|{
name|RpcKindMapValue
name|old
init|=
name|rpcKindMap
operator|.
name|put
argument_list|(
name|rpcKind
argument_list|,
operator|new
name|RpcKindMapValue
argument_list|(
name|rpcRequestWrapperClass
argument_list|,
name|rpcInvoker
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|rpcKindMap
operator|.
name|put
argument_list|(
name|rpcKind
argument_list|,
name|old
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ReRegistration of rpcKind: "
operator|+
name|rpcKind
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"rpcKind="
operator|+
name|rpcKind
operator|+
literal|", rpcRequestWrapperClass="
operator|+
name|rpcRequestWrapperClass
operator|+
literal|", rpcInvoker="
operator|+
name|rpcInvoker
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getRpcRequestWrapper ( RpcKindProto rpcKind)
specifier|public
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|getRpcRequestWrapper
parameter_list|(
name|RpcKindProto
name|rpcKind
parameter_list|)
block|{
if|if
condition|(
name|rpcRequestClass
operator|!=
literal|null
condition|)
return|return
name|rpcRequestClass
return|;
name|RpcKindMapValue
name|val
init|=
name|rpcKindMap
operator|.
name|get
argument_list|(
name|ProtoUtil
operator|.
name|convert
argument_list|(
name|rpcKind
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|val
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|val
operator|.
name|rpcRequestWrapperClass
return|;
block|}
DECL|method|getRpcInvoker (RPC.RpcKind rpcKind)
specifier|public
specifier|static
name|RpcInvoker
name|getRpcInvoker
parameter_list|(
name|RPC
operator|.
name|RpcKind
name|rpcKind
parameter_list|)
block|{
name|RpcKindMapValue
name|val
init|=
name|rpcKindMap
operator|.
name|get
argument_list|(
name|rpcKind
argument_list|)
decl_stmt|;
return|return
operator|(
name|val
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|val
operator|.
name|rpcInvoker
return|;
block|}
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Server
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|AUDITLOG
specifier|public
specifier|static
specifier|final
name|Logger
name|AUDITLOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"SecurityLogger."
operator|+
name|Server
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|AUTH_FAILED_FOR
specifier|private
specifier|static
specifier|final
name|String
name|AUTH_FAILED_FOR
init|=
literal|"Auth failed for "
decl_stmt|;
DECL|field|AUTH_SUCCESSFUL_FOR
specifier|private
specifier|static
specifier|final
name|String
name|AUTH_SUCCESSFUL_FOR
init|=
literal|"Auth successful for "
decl_stmt|;
DECL|field|SERVER
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Server
argument_list|>
name|SERVER
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Server
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|PROTOCOL_CACHE
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|PROTOCOL_CACHE
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|getProtocolClass (String protocolName, Configuration conf)
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getProtocolClass
parameter_list|(
name|String
name|protocolName
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|protocol
init|=
name|PROTOCOL_CACHE
operator|.
name|get
argument_list|(
name|protocolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|protocol
operator|==
literal|null
condition|)
block|{
name|protocol
operator|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|protocolName
argument_list|)
expr_stmt|;
name|PROTOCOL_CACHE
operator|.
name|put
argument_list|(
name|protocolName
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
block|}
return|return
name|protocol
return|;
block|}
comment|/** Returns the server instance called under or null.  May be called under    * {@link #call(Writable, long)} implementations, and under {@link Writable}    * methods of paramters and return values.  Permits applications to access    * the server context.*/
DECL|method|get ()
specifier|public
specifier|static
name|Server
name|get
parameter_list|()
block|{
return|return
name|SERVER
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** This is set to Call object before Handler invokes an RPC and reset    * after the call returns.    */
DECL|field|CurCall
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Call
argument_list|>
name|CurCall
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Call
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Get the current call */
annotation|@
name|VisibleForTesting
DECL|method|getCurCall ()
specifier|public
specifier|static
name|ThreadLocal
argument_list|<
name|Call
argument_list|>
name|getCurCall
parameter_list|()
block|{
return|return
name|CurCall
return|;
block|}
comment|/**    * Returns the currently active RPC call's sequential ID number.  A negative    * call ID indicates an invalid value, such as if there is no currently active    * RPC call.    *     * @return int sequential ID number of currently active RPC call    */
DECL|method|getCallId ()
specifier|public
specifier|static
name|int
name|getCallId
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|call
operator|!=
literal|null
condition|?
name|call
operator|.
name|callId
else|:
name|RpcConstants
operator|.
name|INVALID_CALL_ID
return|;
block|}
comment|/**    * @return The current active RPC call's retry count. -1 indicates the retry    *         cache is not supported in the client side.    */
DECL|method|getCallRetryCount ()
specifier|public
specifier|static
name|int
name|getCallRetryCount
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|call
operator|!=
literal|null
condition|?
name|call
operator|.
name|retryCount
else|:
name|RpcConstants
operator|.
name|INVALID_RETRY_COUNT
return|;
block|}
comment|/** Returns the remote side ip address when invoked inside an RPC     *  Returns null incase of an error.    */
DECL|method|getRemoteIp ()
specifier|public
specifier|static
name|InetAddress
name|getRemoteIp
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
operator|(
name|call
operator|!=
literal|null
operator|)
condition|?
name|call
operator|.
name|getHostInetAddress
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**    * Returns the SASL qop for the current call, if the current call is    * set, and the SASL negotiation is done. Otherwise return null. Note    * that CurCall is thread local object. So in fact, different handler    * threads will process different CurCall object.    *    * Also, only return for RPC calls, not supported for other protocols.    * @return the QOP of the current connection.    */
DECL|method|getEstablishedQOP ()
specifier|public
specifier|static
name|String
name|getEstablishedQOP
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|==
literal|null
operator|||
operator|!
operator|(
name|call
operator|instanceof
name|RpcCall
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RpcCall
name|rpcCall
init|=
operator|(
name|RpcCall
operator|)
name|call
decl_stmt|;
return|return
name|rpcCall
operator|.
name|connection
operator|.
name|getEstablishedQOP
argument_list|()
return|;
block|}
comment|/**    * Returns the clientId from the current RPC request    */
DECL|method|getClientId ()
specifier|public
specifier|static
name|byte
index|[]
name|getClientId
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|call
operator|!=
literal|null
condition|?
name|call
operator|.
name|clientId
else|:
name|RpcConstants
operator|.
name|DUMMY_CLIENT_ID
return|;
block|}
comment|/** Returns remote address as a string when invoked inside an RPC.    *  Returns null in case of an error.    */
DECL|method|getRemoteAddress ()
specifier|public
specifier|static
name|String
name|getRemoteAddress
parameter_list|()
block|{
name|InetAddress
name|addr
init|=
name|getRemoteIp
argument_list|()
decl_stmt|;
return|return
operator|(
name|addr
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|addr
operator|.
name|getHostAddress
argument_list|()
return|;
block|}
comment|/** Returns the RPC remote user when invoked inside an RPC.  Note this    *  may be different than the current user if called within another doAs    *  @return connection's UGI or null if not an RPC    */
DECL|method|getRemoteUser ()
specifier|public
specifier|static
name|UserGroupInformation
name|getRemoteUser
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
operator|(
name|call
operator|!=
literal|null
operator|)
condition|?
name|call
operator|.
name|getRemoteUser
argument_list|()
else|:
literal|null
return|;
block|}
DECL|method|getProtocol ()
specifier|public
specifier|static
name|String
name|getProtocol
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
operator|(
name|call
operator|!=
literal|null
operator|)
condition|?
name|call
operator|.
name|getProtocol
argument_list|()
else|:
literal|null
return|;
block|}
comment|/** Return true if the invocation was through an RPC.    */
DECL|method|isRpcInvocation ()
specifier|public
specifier|static
name|boolean
name|isRpcInvocation
parameter_list|()
block|{
return|return
name|CurCall
operator|.
name|get
argument_list|()
operator|!=
literal|null
return|;
block|}
comment|/**    * Return the priority level assigned by call queue to an RPC    * Returns 0 in case no priority is assigned.    */
DECL|method|getPriorityLevel ()
specifier|public
specifier|static
name|int
name|getPriorityLevel
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|call
operator|!=
literal|null
condition|?
name|call
operator|.
name|getPriorityLevel
argument_list|()
else|:
literal|0
return|;
block|}
DECL|field|bindAddress
specifier|private
name|String
name|bindAddress
decl_stmt|;
DECL|field|port
specifier|private
name|int
name|port
decl_stmt|;
comment|// port we listen on
DECL|field|handlerCount
specifier|private
name|int
name|handlerCount
decl_stmt|;
comment|// number of handler threads
DECL|field|readThreads
specifier|private
name|int
name|readThreads
decl_stmt|;
comment|// number of read threads
DECL|field|readerPendingConnectionQueue
specifier|private
name|int
name|readerPendingConnectionQueue
decl_stmt|;
comment|// number of connections to queue per read thread
DECL|field|rpcRequestClass
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|rpcRequestClass
decl_stmt|;
comment|// class used for deserializing the rpc request
DECL|field|rpcMetrics
specifier|final
specifier|protected
name|RpcMetrics
name|rpcMetrics
decl_stmt|;
DECL|field|rpcDetailedMetrics
specifier|final
specifier|protected
name|RpcDetailedMetrics
name|rpcDetailedMetrics
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|portRangeConfig
specifier|private
name|String
name|portRangeConfig
init|=
literal|null
decl_stmt|;
DECL|field|secretManager
specifier|private
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
name|secretManager
decl_stmt|;
DECL|field|saslPropsResolver
specifier|private
name|SaslPropertiesResolver
name|saslPropsResolver
decl_stmt|;
DECL|field|serviceAuthorizationManager
specifier|private
name|ServiceAuthorizationManager
name|serviceAuthorizationManager
init|=
operator|new
name|ServiceAuthorizationManager
argument_list|()
decl_stmt|;
DECL|field|maxQueueSize
specifier|private
name|int
name|maxQueueSize
decl_stmt|;
DECL|field|maxRespSize
specifier|private
specifier|final
name|int
name|maxRespSize
decl_stmt|;
DECL|field|responseBuffer
specifier|private
specifier|final
name|ThreadLocal
argument_list|<
name|ResponseBuffer
argument_list|>
name|responseBuffer
init|=
operator|new
name|ThreadLocal
argument_list|<
name|ResponseBuffer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|ResponseBuffer
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|ResponseBuffer
argument_list|(
name|INITIAL_RESP_BUF_SIZE
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|socketSendBufferSize
specifier|private
name|int
name|socketSendBufferSize
decl_stmt|;
DECL|field|maxDataLength
specifier|private
specifier|final
name|int
name|maxDataLength
decl_stmt|;
DECL|field|tcpNoDelay
specifier|private
specifier|final
name|boolean
name|tcpNoDelay
decl_stmt|;
comment|// if T then disable Nagle's Algorithm
DECL|field|running
specifier|volatile
specifier|private
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|// true while server runs
DECL|field|callQueue
specifier|private
name|CallQueueManager
argument_list|<
name|Call
argument_list|>
name|callQueue
decl_stmt|;
comment|// maintains the set of client connections and handles idle timeouts
DECL|field|connectionManager
specifier|private
name|ConnectionManager
name|connectionManager
decl_stmt|;
DECL|field|listener
specifier|private
name|Listener
name|listener
init|=
literal|null
decl_stmt|;
comment|// Auxiliary listeners maintained as in a map, to allow
comment|// arbitrary number of of auxiliary listeners. A map from
comment|// the port to the listener binding to it.
DECL|field|auxiliaryListenerMap
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Listener
argument_list|>
name|auxiliaryListenerMap
decl_stmt|;
DECL|field|responder
specifier|private
name|Responder
name|responder
init|=
literal|null
decl_stmt|;
DECL|field|handlers
specifier|private
name|Handler
index|[]
name|handlers
init|=
literal|null
decl_stmt|;
DECL|field|logSlowRPC
specifier|private
name|boolean
name|logSlowRPC
init|=
literal|false
decl_stmt|;
comment|/**    * Checks if LogSlowRPC is set true.    * @return true, if LogSlowRPC is set true, false, otherwise.    */
DECL|method|isLogSlowRPC ()
specifier|protected
name|boolean
name|isLogSlowRPC
parameter_list|()
block|{
return|return
name|logSlowRPC
return|;
block|}
comment|/**    * Sets slow RPC flag.    * @param logSlowRPCFlag    */
annotation|@
name|VisibleForTesting
DECL|method|setLogSlowRPC (boolean logSlowRPCFlag)
specifier|protected
name|void
name|setLogSlowRPC
parameter_list|(
name|boolean
name|logSlowRPCFlag
parameter_list|)
block|{
name|this
operator|.
name|logSlowRPC
operator|=
name|logSlowRPCFlag
expr_stmt|;
block|}
comment|/**    * Logs a Slow RPC Request.    *    * @param methodName - RPC Request method name    * @param processingTime - Processing Time.    *    * if this request took too much time relative to other requests    * we consider that as a slow RPC. 3 is a magic number that comes    * from 3 sigma deviation. A very simple explanation can be found    * by searching for 68-95-99.7 rule. We flag an RPC as slow RPC    * if and only if it falls above 99.7% of requests. We start this logic    * only once we have enough sample size.    */
DECL|method|logSlowRpcCalls (String methodName, int processingTime)
name|void
name|logSlowRpcCalls
parameter_list|(
name|String
name|methodName
parameter_list|,
name|int
name|processingTime
parameter_list|)
block|{
specifier|final
name|int
name|deviation
init|=
literal|3
decl_stmt|;
comment|// 1024 for minSampleSize just a guess -- not a number computed based on
comment|// sample size analysis. It is chosen with the hope that this
comment|// number is high enough to avoid spurious logging, yet useful
comment|// in practice.
specifier|final
name|int
name|minSampleSize
init|=
literal|1024
decl_stmt|;
specifier|final
name|double
name|threeSigma
init|=
name|rpcMetrics
operator|.
name|getProcessingMean
argument_list|()
operator|+
operator|(
name|rpcMetrics
operator|.
name|getProcessingStdDev
argument_list|()
operator|*
name|deviation
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|rpcMetrics
operator|.
name|getProcessingSampleCount
argument_list|()
operator|>
name|minSampleSize
operator|)
operator|&&
operator|(
name|processingTime
operator|>
name|threeSigma
operator|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isWarnEnabled
argument_list|()
condition|)
block|{
name|String
name|client
init|=
name|CurCall
operator|.
name|get
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Slow RPC : "
operator|+
name|methodName
operator|+
literal|" took "
operator|+
name|processingTime
operator|+
literal|" milliseconds to process from client "
operator|+
name|client
argument_list|)
expr_stmt|;
block|}
name|rpcMetrics
operator|.
name|incrSlowRpc
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateMetrics (String name, int queueTime, int processingTime, boolean deferredCall)
name|void
name|updateMetrics
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|queueTime
parameter_list|,
name|int
name|processingTime
parameter_list|,
name|boolean
name|deferredCall
parameter_list|)
block|{
name|rpcMetrics
operator|.
name|addRpcQueueTime
argument_list|(
name|queueTime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deferredCall
condition|)
block|{
name|rpcMetrics
operator|.
name|addRpcProcessingTime
argument_list|(
name|processingTime
argument_list|)
expr_stmt|;
name|rpcDetailedMetrics
operator|.
name|addProcessingTime
argument_list|(
name|name
argument_list|,
name|processingTime
argument_list|)
expr_stmt|;
name|callQueue
operator|.
name|addResponseTime
argument_list|(
name|name
argument_list|,
name|getPriorityLevel
argument_list|()
argument_list|,
name|queueTime
argument_list|,
name|processingTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLogSlowRPC
argument_list|()
condition|)
block|{
name|logSlowRpcCalls
argument_list|(
name|name
argument_list|,
name|processingTime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|updateDeferredMetrics (String name, long processingTime)
name|void
name|updateDeferredMetrics
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|processingTime
parameter_list|)
block|{
name|rpcMetrics
operator|.
name|addDeferredRpcProcessingTime
argument_list|(
name|processingTime
argument_list|)
expr_stmt|;
name|rpcDetailedMetrics
operator|.
name|addDeferredProcessingTime
argument_list|(
name|name
argument_list|,
name|processingTime
argument_list|)
expr_stmt|;
block|}
comment|/**    * A convenience method to bind to a given address and report     * better exceptions if the address is not a valid host.    * @param socket the socket to bind    * @param address the address to bind to    * @param backlog the number of connections allowed in the queue    * @throws BindException if the address can't be bound    * @throws UnknownHostException if the address isn't a valid host name    * @throws IOException other random errors from bind    */
DECL|method|bind (ServerSocket socket, InetSocketAddress address, int backlog)
specifier|public
specifier|static
name|void
name|bind
parameter_list|(
name|ServerSocket
name|socket
parameter_list|,
name|InetSocketAddress
name|address
parameter_list|,
name|int
name|backlog
parameter_list|)
throws|throws
name|IOException
block|{
name|bind
argument_list|(
name|socket
argument_list|,
name|address
argument_list|,
name|backlog
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|bind (ServerSocket socket, InetSocketAddress address, int backlog, Configuration conf, String rangeConf)
specifier|public
specifier|static
name|void
name|bind
parameter_list|(
name|ServerSocket
name|socket
parameter_list|,
name|InetSocketAddress
name|address
parameter_list|,
name|int
name|backlog
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|rangeConf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|IntegerRanges
name|range
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rangeConf
operator|!=
literal|null
condition|)
block|{
name|range
operator|=
name|conf
operator|.
name|getRange
argument_list|(
name|rangeConf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|==
literal|null
operator|||
name|range
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|address
operator|.
name|getPort
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
name|socket
operator|.
name|bind
argument_list|(
name|address
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Integer
name|port
range|:
name|range
control|)
block|{
if|if
condition|(
name|socket
operator|.
name|isBound
argument_list|()
condition|)
break|break;
try|try
block|{
name|InetSocketAddress
name|temp
init|=
operator|new
name|InetSocketAddress
argument_list|(
name|address
operator|.
name|getAddress
argument_list|()
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|socket
operator|.
name|bind
argument_list|(
name|temp
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
comment|//Ignored
block|}
block|}
if|if
condition|(
operator|!
name|socket
operator|.
name|isBound
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|BindException
argument_list|(
literal|"Could not find a free port in "
operator|+
name|range
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SocketException
name|e
parameter_list|)
block|{
throw|throw
name|NetUtils
operator|.
name|wrapException
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|,
name|address
operator|.
name|getHostName
argument_list|()
argument_list|,
name|address
operator|.
name|getPort
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a handle to the rpcMetrics (required in tests)    * @return rpc metrics    */
annotation|@
name|VisibleForTesting
DECL|method|getRpcMetrics ()
specifier|public
name|RpcMetrics
name|getRpcMetrics
parameter_list|()
block|{
return|return
name|rpcMetrics
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getRpcDetailedMetrics ()
specifier|public
name|RpcDetailedMetrics
name|getRpcDetailedMetrics
parameter_list|()
block|{
return|return
name|rpcDetailedMetrics
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getHandlers ()
name|Iterable
argument_list|<
name|?
extends|extends
name|Thread
argument_list|>
name|getHandlers
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|handlers
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getConnections ()
name|Connection
index|[]
name|getConnections
parameter_list|()
block|{
return|return
name|connectionManager
operator|.
name|toArray
argument_list|()
return|;
block|}
comment|/**    * Refresh the service authorization ACL for the service handled by this server.    */
DECL|method|refreshServiceAcl (Configuration conf, PolicyProvider provider)
specifier|public
name|void
name|refreshServiceAcl
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|PolicyProvider
name|provider
parameter_list|)
block|{
name|serviceAuthorizationManager
operator|.
name|refresh
argument_list|(
name|conf
argument_list|,
name|provider
argument_list|)
expr_stmt|;
block|}
comment|/**    * Refresh the service authorization ACL for the service handled by this server    * using the specified Configuration.    */
annotation|@
name|Private
DECL|method|refreshServiceAclWithLoadedConfiguration (Configuration conf, PolicyProvider provider)
specifier|public
name|void
name|refreshServiceAclWithLoadedConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|PolicyProvider
name|provider
parameter_list|)
block|{
name|serviceAuthorizationManager
operator|.
name|refreshWithLoadedConfiguration
argument_list|(
name|conf
argument_list|,
name|provider
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a handle to the serviceAuthorizationManager (required in tests)    * @return instance of ServiceAuthorizationManager for this server    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
DECL|method|getServiceAuthorizationManager ()
specifier|public
name|ServiceAuthorizationManager
name|getServiceAuthorizationManager
parameter_list|()
block|{
return|return
name|serviceAuthorizationManager
return|;
block|}
DECL|method|getQueueClassPrefix ()
specifier|private
name|String
name|getQueueClassPrefix
parameter_list|()
block|{
return|return
name|CommonConfigurationKeys
operator|.
name|IPC_NAMESPACE
operator|+
literal|"."
operator|+
name|port
return|;
block|}
DECL|method|getQueueClass ( String prefix, Configuration conf)
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|BlockingQueue
argument_list|<
name|Call
argument_list|>
argument_list|>
name|getQueueClass
parameter_list|(
name|String
name|prefix
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|name
init|=
name|prefix
operator|+
literal|"."
operator|+
name|CommonConfigurationKeys
operator|.
name|IPC_CALLQUEUE_IMPL_KEY
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|queueClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|name
argument_list|,
name|LinkedBlockingQueue
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|CallQueueManager
operator|.
name|convertQueueClass
argument_list|(
name|queueClass
argument_list|,
name|Call
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|getSchedulerClass ( String prefix, Configuration conf)
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|RpcScheduler
argument_list|>
name|getSchedulerClass
parameter_list|(
name|String
name|prefix
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|schedulerKeyname
init|=
name|prefix
operator|+
literal|"."
operator|+
name|CommonConfigurationKeys
operator|.
name|IPC_SCHEDULER_IMPL_KEY
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|schedulerClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|schedulerKeyname
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Patch the configuration for legacy fcq configuration that does not have
comment|// a separate scheduler setting
if|if
condition|(
name|schedulerClass
operator|==
literal|null
condition|)
block|{
name|String
name|queueKeyName
init|=
name|prefix
operator|+
literal|"."
operator|+
name|CommonConfigurationKeys
operator|.
name|IPC_CALLQUEUE_IMPL_KEY
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|queueClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|queueKeyName
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|queueClass
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|queueClass
operator|.
name|getCanonicalName
argument_list|()
operator|.
name|equals
argument_list|(
name|FairCallQueue
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
condition|)
block|{
name|conf
operator|.
name|setClass
argument_list|(
name|schedulerKeyname
argument_list|,
name|DecayRpcScheduler
operator|.
name|class
argument_list|,
name|RpcScheduler
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|schedulerClass
operator|=
name|conf
operator|.
name|getClass
argument_list|(
name|schedulerKeyname
argument_list|,
name|DefaultRpcScheduler
operator|.
name|class
argument_list|)
expr_stmt|;
return|return
name|CallQueueManager
operator|.
name|convertSchedulerClass
argument_list|(
name|schedulerClass
argument_list|)
return|;
block|}
comment|/*    * Refresh the call queue    */
DECL|method|refreshCallQueue (Configuration conf)
specifier|public
specifier|synchronized
name|void
name|refreshCallQueue
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// Create the next queue
name|String
name|prefix
init|=
name|getQueueClassPrefix
argument_list|()
decl_stmt|;
name|this
operator|.
name|maxQueueSize
operator|=
name|handlerCount
operator|*
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_HANDLER_QUEUE_SIZE_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_HANDLER_QUEUE_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|callQueue
operator|.
name|swapQueue
argument_list|(
name|getSchedulerClass
argument_list|(
name|prefix
argument_list|,
name|conf
argument_list|)
argument_list|,
name|getQueueClass
argument_list|(
name|prefix
argument_list|,
name|conf
argument_list|)
argument_list|,
name|maxQueueSize
argument_list|,
name|prefix
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get from config if client backoff is enabled on that port.    */
DECL|method|getClientBackoffEnable ( String prefix, Configuration conf)
specifier|static
name|boolean
name|getClientBackoffEnable
parameter_list|(
name|String
name|prefix
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|name
init|=
name|prefix
operator|+
literal|"."
operator|+
name|CommonConfigurationKeys
operator|.
name|IPC_BACKOFF_ENABLE
decl_stmt|;
return|return
name|conf
operator|.
name|getBoolean
argument_list|(
name|name
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_BACKOFF_ENABLE_DEFAULT
argument_list|)
return|;
block|}
comment|/** A generic call queued for handling. */
DECL|class|Call
specifier|public
specifier|static
class|class
name|Call
implements|implements
name|Schedulable
implements|,
name|PrivilegedExceptionAction
argument_list|<
name|Void
argument_list|>
block|{
DECL|field|callId
specifier|final
name|int
name|callId
decl_stmt|;
comment|// the client's call id
DECL|field|retryCount
specifier|final
name|int
name|retryCount
decl_stmt|;
comment|// the retry count of the call
DECL|field|timestamp
name|long
name|timestamp
decl_stmt|;
comment|// time received when response is null
comment|// time served when response is not null
DECL|field|responseWaitCount
specifier|private
name|AtomicInteger
name|responseWaitCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|rpcKind
specifier|final
name|RPC
operator|.
name|RpcKind
name|rpcKind
decl_stmt|;
DECL|field|clientId
specifier|final
name|byte
index|[]
name|clientId
decl_stmt|;
DECL|field|traceScope
specifier|private
specifier|final
name|TraceScope
name|traceScope
decl_stmt|;
comment|// the HTrace scope on the server side
DECL|field|callerContext
specifier|private
specifier|final
name|CallerContext
name|callerContext
decl_stmt|;
comment|// the call context
DECL|field|deferredResponse
specifier|private
name|boolean
name|deferredResponse
init|=
literal|false
decl_stmt|;
DECL|field|priorityLevel
specifier|private
name|int
name|priorityLevel
decl_stmt|;
comment|// the priority level assigned by scheduler, 0 by default
DECL|method|Call ()
name|Call
parameter_list|()
block|{
name|this
argument_list|(
name|RpcConstants
operator|.
name|INVALID_CALL_ID
argument_list|,
name|RpcConstants
operator|.
name|INVALID_RETRY_COUNT
argument_list|,
name|RPC
operator|.
name|RpcKind
operator|.
name|RPC_BUILTIN
argument_list|,
name|RpcConstants
operator|.
name|DUMMY_CLIENT_ID
argument_list|)
expr_stmt|;
block|}
DECL|method|Call (Call call)
name|Call
parameter_list|(
name|Call
name|call
parameter_list|)
block|{
name|this
argument_list|(
name|call
operator|.
name|callId
argument_list|,
name|call
operator|.
name|retryCount
argument_list|,
name|call
operator|.
name|rpcKind
argument_list|,
name|call
operator|.
name|clientId
argument_list|,
name|call
operator|.
name|traceScope
argument_list|,
name|call
operator|.
name|callerContext
argument_list|)
expr_stmt|;
block|}
DECL|method|Call (int id, int retryCount, RPC.RpcKind kind, byte[] clientId)
name|Call
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|retryCount
parameter_list|,
name|RPC
operator|.
name|RpcKind
name|kind
parameter_list|,
name|byte
index|[]
name|clientId
parameter_list|)
block|{
name|this
argument_list|(
name|id
argument_list|,
name|retryCount
argument_list|,
name|kind
argument_list|,
name|clientId
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
comment|// primarily TestNamenodeRetryCache
DECL|method|Call (int id, int retryCount, Void ignore1, Void ignore2, RPC.RpcKind kind, byte[] clientId)
specifier|public
name|Call
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|retryCount
parameter_list|,
name|Void
name|ignore1
parameter_list|,
name|Void
name|ignore2
parameter_list|,
name|RPC
operator|.
name|RpcKind
name|kind
parameter_list|,
name|byte
index|[]
name|clientId
parameter_list|)
block|{
name|this
argument_list|(
name|id
argument_list|,
name|retryCount
argument_list|,
name|kind
argument_list|,
name|clientId
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|Call (int id, int retryCount, RPC.RpcKind kind, byte[] clientId, TraceScope traceScope, CallerContext callerContext)
name|Call
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|retryCount
parameter_list|,
name|RPC
operator|.
name|RpcKind
name|kind
parameter_list|,
name|byte
index|[]
name|clientId
parameter_list|,
name|TraceScope
name|traceScope
parameter_list|,
name|CallerContext
name|callerContext
parameter_list|)
block|{
name|this
operator|.
name|callId
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|retryCount
operator|=
name|retryCount
expr_stmt|;
name|this
operator|.
name|timestamp
operator|=
name|Time
operator|.
name|now
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcKind
operator|=
name|kind
expr_stmt|;
name|this
operator|.
name|clientId
operator|=
name|clientId
expr_stmt|;
name|this
operator|.
name|traceScope
operator|=
name|traceScope
expr_stmt|;
name|this
operator|.
name|callerContext
operator|=
name|callerContext
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Call#"
operator|+
name|callId
operator|+
literal|" Retry#"
operator|+
name|retryCount
return|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|Void
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
literal|null
return|;
block|}
comment|// should eventually be abstract but need to avoid breaking tests
DECL|method|getRemoteUser ()
specifier|public
name|UserGroupInformation
name|getRemoteUser
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getHostInetAddress ()
specifier|public
name|InetAddress
name|getHostInetAddress
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|getHostAddress ()
specifier|public
name|String
name|getHostAddress
parameter_list|()
block|{
name|InetAddress
name|addr
init|=
name|getHostInetAddress
argument_list|()
decl_stmt|;
return|return
operator|(
name|addr
operator|!=
literal|null
operator|)
condition|?
name|addr
operator|.
name|getHostAddress
argument_list|()
else|:
literal|null
return|;
block|}
DECL|method|getProtocol ()
specifier|public
name|String
name|getProtocol
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * Allow a IPC response to be postponed instead of sent immediately      * after the handler returns from the proxy method.  The intended use      * case is freeing up the handler thread when the response is known,      * but an expensive pre-condition must be satisfied before it's sent      * to the client.      */
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|}
argument_list|)
DECL|method|postponeResponse ()
specifier|public
specifier|final
name|void
name|postponeResponse
parameter_list|()
block|{
name|int
name|count
init|=
name|responseWaitCount
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
assert|assert
name|count
operator|>
literal|0
operator|:
literal|"response has already been sent"
assert|;
block|}
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|}
argument_list|)
DECL|method|sendResponse ()
specifier|public
specifier|final
name|void
name|sendResponse
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|count
init|=
name|responseWaitCount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
assert|assert
name|count
operator|>=
literal|0
operator|:
literal|"response has already been sent"
assert|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|doResponse
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceStability
operator|.
name|Unstable
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|}
argument_list|)
DECL|method|abortResponse (Throwable t)
specifier|public
specifier|final
name|void
name|abortResponse
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|IOException
block|{
comment|// don't send response if the call was already sent or aborted.
if|if
condition|(
name|responseWaitCount
operator|.
name|getAndSet
argument_list|(
operator|-
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
name|doResponse
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doResponse (Throwable t)
name|void
name|doResponse
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|IOException
block|{}
comment|// For Schedulable
annotation|@
name|Override
DECL|method|getUserGroupInformation ()
specifier|public
name|UserGroupInformation
name|getUserGroupInformation
parameter_list|()
block|{
return|return
name|getRemoteUser
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getPriorityLevel ()
specifier|public
name|int
name|getPriorityLevel
parameter_list|()
block|{
return|return
name|this
operator|.
name|priorityLevel
return|;
block|}
DECL|method|setPriorityLevel (int priorityLevel)
specifier|public
name|void
name|setPriorityLevel
parameter_list|(
name|int
name|priorityLevel
parameter_list|)
block|{
name|this
operator|.
name|priorityLevel
operator|=
name|priorityLevel
expr_stmt|;
block|}
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|method|deferResponse ()
specifier|public
name|void
name|deferResponse
parameter_list|()
block|{
name|this
operator|.
name|deferredResponse
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|method|isResponseDeferred ()
specifier|public
name|boolean
name|isResponseDeferred
parameter_list|()
block|{
return|return
name|this
operator|.
name|deferredResponse
return|;
block|}
DECL|method|setDeferredResponse (Writable response)
specifier|public
name|void
name|setDeferredResponse
parameter_list|(
name|Writable
name|response
parameter_list|)
block|{     }
DECL|method|setDeferredError (Throwable t)
specifier|public
name|void
name|setDeferredError
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{     }
block|}
comment|/** A RPC extended call queued for handling. */
DECL|class|RpcCall
specifier|private
class|class
name|RpcCall
extends|extends
name|Call
block|{
DECL|field|connection
specifier|final
name|Connection
name|connection
decl_stmt|;
comment|// connection to client
DECL|field|rpcRequest
specifier|final
name|Writable
name|rpcRequest
decl_stmt|;
comment|// Serialized Rpc request from client
DECL|field|rpcResponse
name|ByteBuffer
name|rpcResponse
decl_stmt|;
comment|// the response for this call
DECL|field|bufferedHeader
specifier|private
name|RpcResponseHeaderProto
name|bufferedHeader
decl_stmt|;
comment|// the response header
DECL|field|bufferedRv
specifier|private
name|Writable
name|bufferedRv
decl_stmt|;
comment|// the byte response
DECL|method|RpcCall (RpcCall call)
name|RpcCall
parameter_list|(
name|RpcCall
name|call
parameter_list|)
block|{
name|super
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|call
operator|.
name|connection
expr_stmt|;
name|this
operator|.
name|rpcRequest
operator|=
name|call
operator|.
name|rpcRequest
expr_stmt|;
name|this
operator|.
name|bufferedRv
operator|=
name|call
operator|.
name|bufferedRv
expr_stmt|;
name|this
operator|.
name|bufferedHeader
operator|=
name|call
operator|.
name|bufferedHeader
expr_stmt|;
block|}
DECL|method|RpcCall (Connection connection, int id)
name|RpcCall
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|this
argument_list|(
name|connection
argument_list|,
name|id
argument_list|,
name|RpcConstants
operator|.
name|INVALID_RETRY_COUNT
argument_list|)
expr_stmt|;
block|}
DECL|method|RpcCall (Connection connection, int id, int retryCount)
name|RpcCall
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|retryCount
parameter_list|)
block|{
name|this
argument_list|(
name|connection
argument_list|,
name|id
argument_list|,
name|retryCount
argument_list|,
literal|null
argument_list|,
name|RPC
operator|.
name|RpcKind
operator|.
name|RPC_BUILTIN
argument_list|,
name|RpcConstants
operator|.
name|DUMMY_CLIENT_ID
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|RpcCall (Connection connection, int id, int retryCount, Writable param, RPC.RpcKind kind, byte[] clientId, TraceScope traceScope, CallerContext context)
name|RpcCall
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|retryCount
parameter_list|,
name|Writable
name|param
parameter_list|,
name|RPC
operator|.
name|RpcKind
name|kind
parameter_list|,
name|byte
index|[]
name|clientId
parameter_list|,
name|TraceScope
name|traceScope
parameter_list|,
name|CallerContext
name|context
parameter_list|)
block|{
name|super
argument_list|(
name|id
argument_list|,
name|retryCount
argument_list|,
name|kind
argument_list|,
name|clientId
argument_list|,
name|traceScope
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|rpcRequest
operator|=
name|param
expr_stmt|;
block|}
DECL|method|setBufferedHeader (RpcResponseHeaderProto header)
specifier|public
name|void
name|setBufferedHeader
parameter_list|(
name|RpcResponseHeaderProto
name|header
parameter_list|)
block|{
name|this
operator|.
name|bufferedHeader
operator|=
name|header
expr_stmt|;
block|}
DECL|method|setBufferedRv (Writable rv)
specifier|public
name|void
name|setBufferedRv
parameter_list|(
name|Writable
name|rv
parameter_list|)
block|{
name|this
operator|.
name|bufferedRv
operator|=
name|rv
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getProtocol ()
specifier|public
name|String
name|getProtocol
parameter_list|()
block|{
return|return
literal|"rpc"
return|;
block|}
annotation|@
name|Override
DECL|method|getRemoteUser ()
specifier|public
name|UserGroupInformation
name|getRemoteUser
parameter_list|()
block|{
return|return
name|connection
operator|.
name|user
return|;
block|}
annotation|@
name|Override
DECL|method|getHostInetAddress ()
specifier|public
name|InetAddress
name|getHostInetAddress
parameter_list|()
block|{
return|return
name|connection
operator|.
name|getHostInetAddress
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|Void
name|run
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|connection
operator|.
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
name|Server
operator|.
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": skipped "
operator|+
name|this
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Writable
name|value
init|=
literal|null
decl_stmt|;
name|ResponseParams
name|responseParams
init|=
operator|new
name|ResponseParams
argument_list|()
decl_stmt|;
try|try
block|{
name|value
operator|=
name|call
argument_list|(
name|rpcKind
argument_list|,
name|connection
operator|.
name|protocolName
argument_list|,
name|rpcRequest
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|populateResponseParamsOnError
argument_list|(
name|e
argument_list|,
name|responseParams
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isResponseDeferred
argument_list|()
condition|)
block|{
name|setupResponse
argument_list|(
name|this
argument_list|,
name|responseParams
operator|.
name|returnStatus
argument_list|,
name|responseParams
operator|.
name|detailedErr
argument_list|,
name|value
argument_list|,
name|responseParams
operator|.
name|errorClass
argument_list|,
name|responseParams
operator|.
name|error
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deferring response for callId: "
operator|+
name|this
operator|.
name|callId
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * @param t              the {@link java.lang.Throwable} to use to set      *                       errorInfo      * @param responseParams the {@link ResponseParams} instance to populate      */
DECL|method|populateResponseParamsOnError (Throwable t, ResponseParams responseParams)
specifier|private
name|void
name|populateResponseParamsOnError
parameter_list|(
name|Throwable
name|t
parameter_list|,
name|ResponseParams
name|responseParams
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|UndeclaredThrowableException
condition|)
block|{
name|t
operator|=
name|t
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
name|logException
argument_list|(
name|Server
operator|.
name|LOG
argument_list|,
name|t
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|RpcServerException
condition|)
block|{
name|RpcServerException
name|rse
init|=
operator|(
operator|(
name|RpcServerException
operator|)
name|t
operator|)
decl_stmt|;
name|responseParams
operator|.
name|returnStatus
operator|=
name|rse
operator|.
name|getRpcStatusProto
argument_list|()
expr_stmt|;
name|responseParams
operator|.
name|detailedErr
operator|=
name|rse
operator|.
name|getRpcErrorCodeProto
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|responseParams
operator|.
name|returnStatus
operator|=
name|RpcStatusProto
operator|.
name|ERROR
expr_stmt|;
name|responseParams
operator|.
name|detailedErr
operator|=
name|RpcErrorCodeProto
operator|.
name|ERROR_APPLICATION
expr_stmt|;
block|}
name|responseParams
operator|.
name|errorClass
operator|=
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|responseParams
operator|.
name|error
operator|=
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// Remove redundant error class name from the beginning of the
comment|// stack trace
name|String
name|exceptionHdr
init|=
name|responseParams
operator|.
name|errorClass
operator|+
literal|": "
decl_stmt|;
if|if
condition|(
name|responseParams
operator|.
name|error
operator|.
name|startsWith
argument_list|(
name|exceptionHdr
argument_list|)
condition|)
block|{
name|responseParams
operator|.
name|error
operator|=
name|responseParams
operator|.
name|error
operator|.
name|substring
argument_list|(
name|exceptionHdr
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setResponse (ByteBuffer response)
name|void
name|setResponse
parameter_list|(
name|ByteBuffer
name|response
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|rpcResponse
operator|=
name|response
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doResponse (Throwable t)
name|void
name|doResponse
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|RpcCall
name|call
init|=
name|this
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
comment|// clone the call to prevent a race with another thread stomping
comment|// on the response while being sent.  the original call is
comment|// effectively discarded since the wait count won't hit zero
name|call
operator|=
operator|new
name|RpcCall
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setupResponse
argument_list|(
name|call
argument_list|,
name|RpcStatusProto
operator|.
name|FATAL
argument_list|,
name|RpcErrorCodeProto
operator|.
name|ERROR_RPC_SERVER
argument_list|,
literal|null
argument_list|,
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alignmentContext
operator|!=
literal|null
condition|)
block|{
comment|// rebuild response with state context in header
name|RpcResponseHeaderProto
operator|.
name|Builder
name|responseHeader
init|=
name|call
operator|.
name|bufferedHeader
operator|.
name|toBuilder
argument_list|()
decl_stmt|;
name|alignmentContext
operator|.
name|updateResponseState
argument_list|(
name|responseHeader
argument_list|)
expr_stmt|;
name|RpcResponseHeaderProto
name|builtHeader
init|=
name|responseHeader
operator|.
name|build
argument_list|()
decl_stmt|;
name|setupResponse
argument_list|(
name|call
argument_list|,
name|builtHeader
argument_list|,
name|call
operator|.
name|bufferedRv
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|sendResponse
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
comment|/**      * Send a deferred response, ignoring errors.      */
DECL|method|sendDeferedResponse ()
specifier|private
name|void
name|sendDeferedResponse
parameter_list|()
block|{
try|try
block|{
name|connection
operator|.
name|sendResponse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// For synchronous calls, application code is done once it's returned
comment|// from a method. It does not expect to receive an error.
comment|// This is equivalent to what happens in synchronous calls when the
comment|// Responder is not able to send out the response.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to send deferred response. ThreadName="
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", CallId="
operator|+
name|callId
operator|+
literal|", hostname="
operator|+
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|setDeferredResponse (Writable response)
specifier|public
name|void
name|setDeferredResponse
parameter_list|(
name|Writable
name|response
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|connection
operator|.
name|getServer
argument_list|()
operator|.
name|running
condition|)
block|{
try|try
block|{
name|setupResponse
argument_list|(
name|this
argument_list|,
name|RpcStatusProto
operator|.
name|SUCCESS
argument_list|,
literal|null
argument_list|,
name|response
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// For synchronous calls, application code is done once it has
comment|// returned from a method. It does not expect to receive an error.
comment|// This is equivalent to what happens in synchronous calls when the
comment|// response cannot be sent.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to setup deferred successful response. ThreadName="
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", Call="
operator|+
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
name|sendDeferedResponse
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|setDeferredError (Throwable t)
specifier|public
name|void
name|setDeferredError
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|connection
operator|.
name|getServer
argument_list|()
operator|.
name|running
condition|)
block|{
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
name|t
operator|=
operator|new
name|IOException
argument_list|(
literal|"User code indicated an error without an exception"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|ResponseParams
name|responseParams
init|=
operator|new
name|ResponseParams
argument_list|()
decl_stmt|;
name|populateResponseParamsOnError
argument_list|(
name|t
argument_list|,
name|responseParams
argument_list|)
expr_stmt|;
name|setupResponse
argument_list|(
name|this
argument_list|,
name|responseParams
operator|.
name|returnStatus
argument_list|,
name|responseParams
operator|.
name|detailedErr
argument_list|,
literal|null
argument_list|,
name|responseParams
operator|.
name|errorClass
argument_list|,
name|responseParams
operator|.
name|error
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// For synchronous calls, application code is done once it has
comment|// returned from a method. It does not expect to receive an error.
comment|// This is equivalent to what happens in synchronous calls when the
comment|// response cannot be sent.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to setup deferred error response. ThreadName="
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", Call="
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
name|sendDeferedResponse
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Holds response parameters. Defaults set to work for successful      * invocations      */
DECL|class|ResponseParams
specifier|private
class|class
name|ResponseParams
block|{
DECL|field|errorClass
name|String
name|errorClass
init|=
literal|null
decl_stmt|;
DECL|field|error
name|String
name|error
init|=
literal|null
decl_stmt|;
DECL|field|detailedErr
name|RpcErrorCodeProto
name|detailedErr
init|=
literal|null
decl_stmt|;
DECL|field|returnStatus
name|RpcStatusProto
name|returnStatus
init|=
name|RpcStatusProto
operator|.
name|SUCCESS
decl_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|rpcRequest
operator|+
literal|" from "
operator|+
name|connection
return|;
block|}
block|}
comment|/** Listens on the socket. Creates jobs for the handler threads*/
DECL|class|Listener
specifier|private
class|class
name|Listener
extends|extends
name|Thread
block|{
DECL|field|acceptChannel
specifier|private
name|ServerSocketChannel
name|acceptChannel
init|=
literal|null
decl_stmt|;
comment|//the accept channel
DECL|field|selector
specifier|private
name|Selector
name|selector
init|=
literal|null
decl_stmt|;
comment|//the selector that we use for the server
DECL|field|readers
specifier|private
name|Reader
index|[]
name|readers
init|=
literal|null
decl_stmt|;
DECL|field|currentReader
specifier|private
name|int
name|currentReader
init|=
literal|0
decl_stmt|;
DECL|field|address
specifier|private
name|InetSocketAddress
name|address
decl_stmt|;
comment|//the address we bind at
DECL|field|listenPort
specifier|private
name|int
name|listenPort
decl_stmt|;
comment|//the port we bind at
DECL|field|backlogLength
specifier|private
name|int
name|backlogLength
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_SERVER_LISTEN_QUEUE_SIZE_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_SERVER_LISTEN_QUEUE_SIZE_DEFAULT
argument_list|)
decl_stmt|;
DECL|method|Listener (int port)
name|Listener
parameter_list|(
name|int
name|port
parameter_list|)
throws|throws
name|IOException
block|{
name|address
operator|=
operator|new
name|InetSocketAddress
argument_list|(
name|bindAddress
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|// Create a new server socket and set to non blocking mode
name|acceptChannel
operator|=
name|ServerSocketChannel
operator|.
name|open
argument_list|()
expr_stmt|;
name|acceptChannel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Bind the server socket to the local host and port
name|bind
argument_list|(
name|acceptChannel
operator|.
name|socket
argument_list|()
argument_list|,
name|address
argument_list|,
name|backlogLength
argument_list|,
name|conf
argument_list|,
name|portRangeConfig
argument_list|)
expr_stmt|;
comment|//Could be an ephemeral port
name|this
operator|.
name|listenPort
operator|=
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalPort
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"Listener at "
operator|+
name|bindAddress
operator|+
literal|"/"
operator|+
name|this
operator|.
name|listenPort
argument_list|)
expr_stmt|;
comment|// create a selector;
name|selector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
name|readers
operator|=
operator|new
name|Reader
index|[
name|readThreads
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|readThreads
condition|;
name|i
operator|++
control|)
block|{
name|Reader
name|reader
init|=
operator|new
name|Reader
argument_list|(
literal|"Socket Reader #"
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" for port "
operator|+
name|port
argument_list|)
decl_stmt|;
name|readers
index|[
name|i
index|]
operator|=
name|reader
expr_stmt|;
name|reader
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Register accepts on the server socket with the selector.
name|acceptChannel
operator|.
name|register
argument_list|(
name|selector
argument_list|,
name|SelectionKey
operator|.
name|OP_ACCEPT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"IPC Server listener on "
operator|+
name|port
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|class|Reader
specifier|private
class|class
name|Reader
extends|extends
name|Thread
block|{
DECL|field|pendingConnections
specifier|final
specifier|private
name|BlockingQueue
argument_list|<
name|Connection
argument_list|>
name|pendingConnections
decl_stmt|;
DECL|field|readSelector
specifier|private
specifier|final
name|Selector
name|readSelector
decl_stmt|;
DECL|method|Reader (String name)
name|Reader
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|pendingConnections
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Connection
argument_list|>
argument_list|(
name|readerPendingConnectionQueue
argument_list|)
expr_stmt|;
name|this
operator|.
name|readSelector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|doRunLoop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|readSelector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error closing read selector in "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|doRunLoop ()
specifier|private
specifier|synchronized
name|void
name|doRunLoop
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
name|SelectionKey
name|key
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// consume as many connections as currently queued to avoid
comment|// unbridled acceptance of connections that starves the select
name|int
name|size
init|=
name|pendingConnections
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|size
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Connection
name|conn
init|=
name|pendingConnections
operator|.
name|take
argument_list|()
decl_stmt|;
name|conn
operator|.
name|channel
operator|.
name|register
argument_list|(
name|readSelector
argument_list|,
name|SelectionKey
operator|.
name|OP_READ
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
name|readSelector
operator|.
name|select
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|readSelector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|key
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isReadable
argument_list|()
condition|)
block|{
name|doRead
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|cke
parameter_list|)
block|{
comment|// something else closed the connection, ex. responder or
comment|// the listener doing an idle scan.  ignore it and let them
comment|// clean up.
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": connection aborted from "
operator|+
name|key
operator|.
name|attachment
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|key
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
comment|// unexpected -- log it
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" unexpectedly interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in Reader"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|re
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Bug in read selector!"
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|ExitUtil
operator|.
name|terminate
argument_list|(
literal|1
argument_list|,
literal|"Bug in read selector!"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**        * Updating the readSelector while it's being used is not thread-safe,        * so the connection must be queued.  The reader will drain the queue        * and update its readSelector before performing the next select        */
DECL|method|addConnection (Connection conn)
specifier|public
name|void
name|addConnection
parameter_list|(
name|Connection
name|conn
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|pendingConnections
operator|.
name|put
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|readSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
block|}
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
assert|assert
operator|!
name|running
assert|;
name|readSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
try|try
block|{
name|super
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|super
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
name|SERVER
operator|.
name|set
argument_list|(
name|Server
operator|.
name|this
argument_list|)
expr_stmt|;
name|connectionManager
operator|.
name|startIdleScan
argument_list|()
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|SelectionKey
name|key
init|=
literal|null
decl_stmt|;
try|try
block|{
name|getSelector
argument_list|()
operator|.
name|select
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|getSelector
argument_list|()
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|key
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isAcceptable
argument_list|()
condition|)
name|doAccept
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{             }
name|key
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
comment|// we can run out of memory if we have too many threads
comment|// log the event and sleep for a minute and give
comment|// some thread(s) a chance to finish
name|LOG
operator|.
name|warn
argument_list|(
literal|"Out of Memory in server select"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|connectionManager
operator|.
name|closeIdle
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ie
parameter_list|)
block|{}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|close
argument_list|()
expr_stmt|;
name|selector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{ }
name|selector
operator|=
literal|null
expr_stmt|;
name|acceptChannel
operator|=
literal|null
expr_stmt|;
comment|// close all connections
name|connectionManager
operator|.
name|stopIdleScan
argument_list|()
expr_stmt|;
name|connectionManager
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|closeCurrentConnection (SelectionKey key, Throwable e)
specifier|private
name|void
name|closeCurrentConnection
parameter_list|(
name|SelectionKey
name|key
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|Connection
name|c
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
DECL|method|getAddress ()
name|InetSocketAddress
name|getAddress
parameter_list|()
block|{
return|return
operator|(
name|InetSocketAddress
operator|)
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalSocketAddress
argument_list|()
return|;
block|}
DECL|method|doAccept (SelectionKey key)
name|void
name|doAccept
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
throws|,
name|OutOfMemoryError
block|{
name|ServerSocketChannel
name|server
init|=
operator|(
name|ServerSocketChannel
operator|)
name|key
operator|.
name|channel
argument_list|()
decl_stmt|;
name|SocketChannel
name|channel
decl_stmt|;
while|while
condition|(
operator|(
name|channel
operator|=
name|server
operator|.
name|accept
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|channel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setTcpNoDelay
argument_list|(
name|tcpNoDelay
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setKeepAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Reader
name|reader
init|=
name|getReader
argument_list|()
decl_stmt|;
name|Connection
name|c
init|=
name|connectionManager
operator|.
name|register
argument_list|(
name|channel
argument_list|,
name|this
operator|.
name|listenPort
argument_list|)
decl_stmt|;
comment|// If the connectionManager can't take it, close the connection.
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
name|connectionManager
operator|.
name|droppedConnections
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|key
operator|.
name|attach
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// so closeCurrentConnection can get the object
name|reader
operator|.
name|addConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doRead (SelectionKey key)
name|void
name|doRead
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|int
name|count
decl_stmt|;
name|Connection
name|c
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|c
operator|.
name|setLastContact
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|count
operator|=
name|c
operator|.
name|readAndProcess
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ieo
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": readAndProcess caught InterruptedException"
argument_list|,
name|ieo
argument_list|)
expr_stmt|;
throw|throw
name|ieo
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Any exceptions that reach here are fatal unexpected internal errors
comment|// that could not be sent to the client.
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": readAndProcess from client "
operator|+
name|c
operator|+
literal|" threw exception ["
operator|+
name|e
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|count
operator|=
operator|-
literal|1
expr_stmt|;
comment|//so that the (count< 0) block is executed
block|}
comment|// setupResponse will signal the connection should be closed when a
comment|// fatal response is sent.
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|c
operator|.
name|shouldClose
argument_list|()
condition|)
block|{
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|setLastContact
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doStop ()
specifier|synchronized
name|void
name|doStop
parameter_list|()
block|{
if|if
condition|(
name|selector
operator|!=
literal|null
condition|)
block|{
name|selector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|acceptChannel
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|":Exception in closing listener socket. "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Reader
name|r
range|:
name|readers
control|)
block|{
name|r
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getSelector ()
specifier|synchronized
name|Selector
name|getSelector
parameter_list|()
block|{
return|return
name|selector
return|;
block|}
comment|// The method that will return the next reader to work with
comment|// Simplistic implementation of round robin for now
DECL|method|getReader ()
name|Reader
name|getReader
parameter_list|()
block|{
name|currentReader
operator|=
operator|(
name|currentReader
operator|+
literal|1
operator|)
operator|%
name|readers
operator|.
name|length
expr_stmt|;
return|return
name|readers
index|[
name|currentReader
index|]
return|;
block|}
block|}
comment|// Sends responses of RPC back to clients.
DECL|class|Responder
specifier|private
class|class
name|Responder
extends|extends
name|Thread
block|{
DECL|field|writeSelector
specifier|private
specifier|final
name|Selector
name|writeSelector
decl_stmt|;
DECL|field|pending
specifier|private
name|int
name|pending
decl_stmt|;
comment|// connections waiting to register
DECL|field|PURGE_INTERVAL
specifier|final
specifier|static
name|int
name|PURGE_INTERVAL
init|=
literal|900000
decl_stmt|;
comment|// 15mins
DECL|method|Responder ()
name|Responder
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|setName
argument_list|(
literal|"IPC Server Responder"
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writeSelector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
comment|// create a selector
name|pending
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
name|SERVER
operator|.
name|set
argument_list|(
name|Server
operator|.
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|doRunLoop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|writeSelector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't close write selector in "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|doRunLoop ()
specifier|private
name|void
name|doRunLoop
parameter_list|()
block|{
name|long
name|lastPurgeTime
init|=
literal|0
decl_stmt|;
comment|// last check for old calls.
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|waitPending
argument_list|()
expr_stmt|;
comment|// If a channel is being registered, wait.
name|writeSelector
operator|.
name|select
argument_list|(
name|PURGE_INTERVAL
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|writeSelector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SelectionKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isWritable
argument_list|()
condition|)
block|{
name|doAsyncWrite
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|cke
parameter_list|)
block|{
comment|// something else closed the connection, ex. reader or the
comment|// listener doing an idle scan.  ignore it and let them clean
comment|// up
name|RpcCall
name|call
init|=
operator|(
name|RpcCall
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": connection aborted from "
operator|+
name|call
operator|.
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": doAsyncWrite threw exception "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|lastPurgeTime
operator|+
name|PURGE_INTERVAL
condition|)
block|{
continue|continue;
block|}
name|lastPurgeTime
operator|=
name|now
expr_stmt|;
comment|//
comment|// If there were some calls that have not been sent out for a
comment|// long time, discard them.
comment|//
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking for old call responses."
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|RpcCall
argument_list|>
name|calls
decl_stmt|;
comment|// get the list of channels from list of keys.
synchronized|synchronized
init|(
name|writeSelector
operator|.
name|keys
argument_list|()
init|)
block|{
name|calls
operator|=
operator|new
name|ArrayList
argument_list|<
name|RpcCall
argument_list|>
argument_list|(
name|writeSelector
operator|.
name|keys
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|iter
operator|=
name|writeSelector
operator|.
name|keys
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SelectionKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|RpcCall
name|call
init|=
operator|(
name|RpcCall
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
operator|&&
name|key
operator|.
name|channel
argument_list|()
operator|==
name|call
operator|.
name|connection
operator|.
name|channel
condition|)
block|{
name|calls
operator|.
name|add
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|RpcCall
name|call
range|:
name|calls
control|)
block|{
name|doPurge
argument_list|(
name|call
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
comment|//
comment|// we can run out of memory if we have too many threads
comment|// log the event and sleep for a minute and give
comment|// some thread(s) a chance to finish
comment|//
name|LOG
operator|.
name|warn
argument_list|(
literal|"Out of Memory in server select"
argument_list|,
name|e
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ie
parameter_list|)
block|{}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in Responder"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|doAsyncWrite (SelectionKey key)
specifier|private
name|void
name|doAsyncWrite
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|RpcCall
name|call
init|=
operator|(
name|RpcCall
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|key
operator|.
name|channel
argument_list|()
operator|!=
name|call
operator|.
name|connection
operator|.
name|channel
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"doAsyncWrite: bad channel"
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
init|)
block|{
if|if
condition|(
name|processResponse
argument_list|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
argument_list|,
literal|false
argument_list|)
condition|)
block|{
try|try
block|{
name|key
operator|.
name|interestOps
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|e
parameter_list|)
block|{
comment|/* The Listener/reader might have closed the socket.              * We don't explicitly cancel the key, so not sure if this will              * ever fire.              * This warning could be removed.              */
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while changing ops : "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Remove calls that have been pending in the responseQueue
comment|// for a long time.
comment|//
DECL|method|doPurge (RpcCall call, long now)
specifier|private
name|void
name|doPurge
parameter_list|(
name|RpcCall
name|call
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|LinkedList
argument_list|<
name|RpcCall
argument_list|>
name|responseQueue
init|=
name|call
operator|.
name|connection
operator|.
name|responseQueue
decl_stmt|;
synchronized|synchronized
init|(
name|responseQueue
init|)
block|{
name|Iterator
argument_list|<
name|RpcCall
argument_list|>
name|iter
init|=
name|responseQueue
operator|.
name|listIterator
argument_list|(
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|call
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|now
operator|>
name|call
operator|.
name|timestamp
operator|+
name|PURGE_INTERVAL
condition|)
block|{
name|closeConnection
argument_list|(
name|call
operator|.
name|connection
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|// Processes one response. Returns true if there are no more pending
comment|// data for this channel.
comment|//
DECL|method|processResponse (LinkedList<RpcCall> responseQueue, boolean inHandler)
specifier|private
name|boolean
name|processResponse
parameter_list|(
name|LinkedList
argument_list|<
name|RpcCall
argument_list|>
name|responseQueue
parameter_list|,
name|boolean
name|inHandler
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|error
init|=
literal|true
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
comment|// there is more data for this channel.
name|int
name|numElements
init|=
literal|0
decl_stmt|;
name|RpcCall
name|call
init|=
literal|null
decl_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|responseQueue
init|)
block|{
comment|//
comment|// If there are no items for this channel, then we are done
comment|//
name|numElements
operator|=
name|responseQueue
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|numElements
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
comment|// no more data for this channel.
block|}
comment|//
comment|// Extract the first call
comment|//
name|call
operator|=
name|responseQueue
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|SocketChannel
name|channel
init|=
name|call
operator|.
name|connection
operator|.
name|channel
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": responding to "
operator|+
name|call
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Send as much data as we can in the non-blocking fashion
comment|//
name|int
name|numBytes
init|=
name|channelWrite
argument_list|(
name|channel
argument_list|,
name|call
operator|.
name|rpcResponse
argument_list|)
decl_stmt|;
if|if
condition|(
name|numBytes
operator|<
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|call
operator|.
name|rpcResponse
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
comment|//Clear out the response buffer so it can be collected
name|call
operator|.
name|rpcResponse
operator|=
literal|null
expr_stmt|;
name|call
operator|.
name|connection
operator|.
name|decRpcCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|numElements
operator|==
literal|1
condition|)
block|{
comment|// last call fully processes.
name|done
operator|=
literal|true
expr_stmt|;
comment|// no more data for this channel.
block|}
else|else
block|{
name|done
operator|=
literal|false
expr_stmt|;
comment|// more calls pending to be sent.
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": responding to "
operator|+
name|call
operator|+
literal|" Wrote "
operator|+
name|numBytes
operator|+
literal|" bytes."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//
comment|// If we were unable to write the entire response out, then
comment|// insert in Selector queue.
comment|//
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|addFirst
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|inHandler
condition|)
block|{
comment|// set the serve time when the response has to be sent later
name|call
operator|.
name|timestamp
operator|=
name|Time
operator|.
name|now
argument_list|()
expr_stmt|;
name|incPending
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Wakeup the thread blocked on select, only then can the call
comment|// to channel.register() complete.
name|writeSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
name|channel
operator|.
name|register
argument_list|(
name|writeSelector
argument_list|,
name|SelectionKey
operator|.
name|OP_WRITE
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
comment|//Its ok. channel might be closed else where.
name|done
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|decPending
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": responding to "
operator|+
name|call
operator|+
literal|" Wrote partial "
operator|+
name|numBytes
operator|+
literal|" bytes."
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
literal|false
expr_stmt|;
comment|// everything went off well
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|error
operator|&&
name|call
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", call "
operator|+
name|call
operator|+
literal|": output error"
argument_list|)
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
comment|// error. no more data for this channel.
name|closeConnection
argument_list|(
name|call
operator|.
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|done
return|;
block|}
comment|//
comment|// Enqueue a response from the application.
comment|//
DECL|method|doRespond (RpcCall call)
name|void
name|doRespond
parameter_list|(
name|RpcCall
name|call
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
init|)
block|{
comment|// must only wrap before adding to the responseQueue to prevent
comment|// postponed responses from being encrypted and sent out of order.
if|if
condition|(
name|call
operator|.
name|connection
operator|.
name|useWrap
condition|)
block|{
name|wrapWithSasl
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|addLast
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|processResponse
argument_list|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|incPending ()
specifier|private
specifier|synchronized
name|void
name|incPending
parameter_list|()
block|{
comment|// call waiting to be enqueued.
name|pending
operator|++
expr_stmt|;
block|}
DECL|method|decPending ()
specifier|private
specifier|synchronized
name|void
name|decPending
parameter_list|()
block|{
comment|// call done enqueueing.
name|pending
operator|--
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
block|}
DECL|method|waitPending ()
specifier|private
specifier|synchronized
name|void
name|waitPending
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|pending
operator|>
literal|0
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|enum|AuthProtocol
specifier|public
enum|enum
name|AuthProtocol
block|{
DECL|enumConstant|NONE
name|NONE
argument_list|(
literal|0
argument_list|)
block|,
DECL|enumConstant|SASL
name|SASL
argument_list|(
operator|-
literal|33
argument_list|)
block|;
DECL|field|callId
specifier|public
specifier|final
name|int
name|callId
decl_stmt|;
DECL|method|AuthProtocol (int callId)
name|AuthProtocol
parameter_list|(
name|int
name|callId
parameter_list|)
block|{
name|this
operator|.
name|callId
operator|=
name|callId
expr_stmt|;
block|}
DECL|method|valueOf (int callId)
specifier|static
name|AuthProtocol
name|valueOf
parameter_list|(
name|int
name|callId
parameter_list|)
block|{
for|for
control|(
name|AuthProtocol
name|authType
range|:
name|AuthProtocol
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|authType
operator|.
name|callId
operator|==
name|callId
condition|)
block|{
return|return
name|authType
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
empty_stmt|;
comment|/**    * Wrapper for RPC IOExceptions to be returned to the client.  Used to    * let exceptions bubble up to top of processOneRpc where the correct    * callId can be associated with the response.  Also used to prevent    * unnecessary stack trace logging if it's not an internal server error.     */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|FatalRpcServerException
specifier|private
specifier|static
class|class
name|FatalRpcServerException
extends|extends
name|RpcServerException
block|{
DECL|field|errCode
specifier|private
specifier|final
name|RpcErrorCodeProto
name|errCode
decl_stmt|;
DECL|method|FatalRpcServerException (RpcErrorCodeProto errCode, IOException ioe)
specifier|public
name|FatalRpcServerException
parameter_list|(
name|RpcErrorCodeProto
name|errCode
parameter_list|,
name|IOException
name|ioe
parameter_list|)
block|{
name|super
argument_list|(
name|ioe
operator|.
name|toString
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|this
operator|.
name|errCode
operator|=
name|errCode
expr_stmt|;
block|}
DECL|method|FatalRpcServerException (RpcErrorCodeProto errCode, String message)
specifier|public
name|FatalRpcServerException
parameter_list|(
name|RpcErrorCodeProto
name|errCode
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|this
argument_list|(
name|errCode
argument_list|,
operator|new
name|RpcServerException
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getRpcStatusProto ()
specifier|public
name|RpcStatusProto
name|getRpcStatusProto
parameter_list|()
block|{
return|return
name|RpcStatusProto
operator|.
name|FATAL
return|;
block|}
annotation|@
name|Override
DECL|method|getRpcErrorCodeProto ()
specifier|public
name|RpcErrorCodeProto
name|getRpcErrorCodeProto
parameter_list|()
block|{
return|return
name|errCode
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getCause
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Reads calls from a connection and queues them for handling. */
DECL|class|Connection
specifier|public
class|class
name|Connection
block|{
DECL|field|connectionHeaderRead
specifier|private
name|boolean
name|connectionHeaderRead
init|=
literal|false
decl_stmt|;
comment|// connection  header is read?
DECL|field|connectionContextRead
specifier|private
name|boolean
name|connectionContextRead
init|=
literal|false
decl_stmt|;
comment|//if connection context that
comment|//follows connection header is read
DECL|field|channel
specifier|private
name|SocketChannel
name|channel
decl_stmt|;
DECL|field|data
specifier|private
name|ByteBuffer
name|data
decl_stmt|;
DECL|field|dataLengthBuffer
specifier|private
name|ByteBuffer
name|dataLengthBuffer
decl_stmt|;
DECL|field|responseQueue
specifier|private
name|LinkedList
argument_list|<
name|RpcCall
argument_list|>
name|responseQueue
decl_stmt|;
comment|// number of outstanding rpcs
DECL|field|rpcCount
specifier|private
name|AtomicInteger
name|rpcCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|lastContact
specifier|private
name|long
name|lastContact
decl_stmt|;
DECL|field|dataLength
specifier|private
name|int
name|dataLength
decl_stmt|;
DECL|field|socket
specifier|private
name|Socket
name|socket
decl_stmt|;
comment|// Cache the remote host& port info so that even if the socket is
comment|// disconnected, we can say where it used to connect to.
DECL|field|hostAddress
specifier|private
name|String
name|hostAddress
decl_stmt|;
DECL|field|remotePort
specifier|private
name|int
name|remotePort
decl_stmt|;
DECL|field|addr
specifier|private
name|InetAddress
name|addr
decl_stmt|;
DECL|field|connectionContext
name|IpcConnectionContextProto
name|connectionContext
decl_stmt|;
DECL|field|protocolName
name|String
name|protocolName
decl_stmt|;
DECL|field|saslServer
name|SaslServer
name|saslServer
decl_stmt|;
DECL|field|authMethod
specifier|private
name|AuthMethod
name|authMethod
decl_stmt|;
DECL|field|authProtocol
specifier|private
name|AuthProtocol
name|authProtocol
decl_stmt|;
DECL|field|saslContextEstablished
specifier|private
name|boolean
name|saslContextEstablished
decl_stmt|;
DECL|field|connectionHeaderBuf
specifier|private
name|ByteBuffer
name|connectionHeaderBuf
init|=
literal|null
decl_stmt|;
DECL|field|unwrappedData
specifier|private
name|ByteBuffer
name|unwrappedData
decl_stmt|;
DECL|field|unwrappedDataLengthBuffer
specifier|private
name|ByteBuffer
name|unwrappedDataLengthBuffer
decl_stmt|;
DECL|field|serviceClass
specifier|private
name|int
name|serviceClass
decl_stmt|;
DECL|field|shouldClose
specifier|private
name|boolean
name|shouldClose
init|=
literal|false
decl_stmt|;
DECL|field|ingressPort
specifier|private
name|int
name|ingressPort
decl_stmt|;
DECL|field|user
name|UserGroupInformation
name|user
init|=
literal|null
decl_stmt|;
DECL|field|attemptingUser
specifier|public
name|UserGroupInformation
name|attemptingUser
init|=
literal|null
decl_stmt|;
comment|// user name before auth
comment|// Fake 'call' for failed authorization response
DECL|field|authFailedCall
specifier|private
specifier|final
name|RpcCall
name|authFailedCall
init|=
operator|new
name|RpcCall
argument_list|(
name|this
argument_list|,
name|AUTHORIZATION_FAILED_CALL_ID
argument_list|)
decl_stmt|;
DECL|field|sentNegotiate
specifier|private
name|boolean
name|sentNegotiate
init|=
literal|false
decl_stmt|;
DECL|field|useWrap
specifier|private
name|boolean
name|useWrap
init|=
literal|false
decl_stmt|;
DECL|method|Connection (SocketChannel channel, long lastContact, int ingressPort)
specifier|public
name|Connection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|lastContact
parameter_list|,
name|int
name|ingressPort
parameter_list|)
block|{
name|this
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
name|this
operator|.
name|lastContact
operator|=
name|lastContact
expr_stmt|;
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
comment|// the buffer is initialized to read the "hrpc" and after that to read
comment|// the length of the Rpc-packet (i.e 4 bytes)
name|this
operator|.
name|dataLengthBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|unwrappedData
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|unwrappedDataLengthBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|=
name|channel
operator|.
name|socket
argument_list|()
expr_stmt|;
name|this
operator|.
name|addr
operator|=
name|socket
operator|.
name|getInetAddress
argument_list|()
expr_stmt|;
name|this
operator|.
name|ingressPort
operator|=
name|ingressPort
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|hostAddress
operator|=
literal|"*Unknown*"
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|hostAddress
operator|=
name|addr
operator|.
name|getHostAddress
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|remotePort
operator|=
name|socket
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|this
operator|.
name|responseQueue
operator|=
operator|new
name|LinkedList
argument_list|<
name|RpcCall
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|socketSendBufferSize
operator|!=
literal|0
condition|)
block|{
try|try
block|{
name|socket
operator|.
name|setSendBufferSize
argument_list|(
name|socketSendBufferSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Connection: unable to set socket send buffer size to "
operator|+
name|socketSendBufferSize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getHostAddress
argument_list|()
operator|+
literal|":"
operator|+
name|remotePort
return|;
block|}
DECL|method|setShouldClose ()
name|boolean
name|setShouldClose
parameter_list|()
block|{
return|return
name|shouldClose
operator|=
literal|true
return|;
block|}
DECL|method|shouldClose ()
name|boolean
name|shouldClose
parameter_list|()
block|{
return|return
name|shouldClose
return|;
block|}
DECL|method|getHostAddress ()
specifier|public
name|String
name|getHostAddress
parameter_list|()
block|{
return|return
name|hostAddress
return|;
block|}
DECL|method|getIngressPort ()
specifier|public
name|int
name|getIngressPort
parameter_list|()
block|{
return|return
name|ingressPort
return|;
block|}
DECL|method|getHostInetAddress ()
specifier|public
name|InetAddress
name|getHostInetAddress
parameter_list|()
block|{
return|return
name|addr
return|;
block|}
DECL|method|getEstablishedQOP ()
specifier|public
name|String
name|getEstablishedQOP
parameter_list|()
block|{
comment|// In practice, saslServer should not be null when this is
comment|// called. If it is null, it must be either some
comment|// configuration mistake or it is called from unit test.
if|if
condition|(
name|saslServer
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"SASL server should not be null!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|(
name|String
operator|)
name|saslServer
operator|.
name|getNegotiatedProperty
argument_list|(
name|Sasl
operator|.
name|QOP
argument_list|)
return|;
block|}
DECL|method|setLastContact (long lastContact)
specifier|public
name|void
name|setLastContact
parameter_list|(
name|long
name|lastContact
parameter_list|)
block|{
name|this
operator|.
name|lastContact
operator|=
name|lastContact
expr_stmt|;
block|}
DECL|method|getLastContact ()
specifier|public
name|long
name|getLastContact
parameter_list|()
block|{
return|return
name|lastContact
return|;
block|}
DECL|method|getServer ()
specifier|public
name|Server
name|getServer
parameter_list|()
block|{
return|return
name|Server
operator|.
name|this
return|;
block|}
comment|/* Return true if the connection has no outstanding rpc */
DECL|method|isIdle ()
specifier|private
name|boolean
name|isIdle
parameter_list|()
block|{
return|return
name|rpcCount
operator|.
name|get
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/* Decrement the outstanding RPC count */
DECL|method|decRpcCount ()
specifier|private
name|void
name|decRpcCount
parameter_list|()
block|{
name|rpcCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/* Increment the outstanding RPC count */
DECL|method|incRpcCount ()
specifier|private
name|void
name|incRpcCount
parameter_list|()
block|{
name|rpcCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|getAuthorizedUgi (String authorizedId)
specifier|private
name|UserGroupInformation
name|getAuthorizedUgi
parameter_list|(
name|String
name|authorizedId
parameter_list|)
throws|throws
name|InvalidToken
throws|,
name|AccessControlException
block|{
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|TOKEN
condition|)
block|{
name|TokenIdentifier
name|tokenId
init|=
name|SaslRpcServer
operator|.
name|getIdentifier
argument_list|(
name|authorizedId
argument_list|,
name|secretManager
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|tokenId
operator|.
name|getUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|ugi
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Can't retrieve username from tokenIdentifier."
argument_list|)
throw|;
block|}
name|ugi
operator|.
name|addTokenIdentifier
argument_list|(
name|tokenId
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
else|else
block|{
return|return
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|authorizedId
argument_list|,
name|authMethod
argument_list|)
return|;
block|}
block|}
DECL|method|saslReadAndProcess (RpcWritable.Buffer buffer)
specifier|private
name|void
name|saslReadAndProcess
parameter_list|(
name|RpcWritable
operator|.
name|Buffer
name|buffer
parameter_list|)
throws|throws
name|RpcServerException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|RpcSaslProto
name|saslMessage
init|=
name|getMessage
argument_list|(
name|RpcSaslProto
operator|.
name|getDefaultInstance
argument_list|()
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|saslMessage
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|WRAP
case|:
block|{
if|if
condition|(
operator|!
name|saslContextEstablished
operator|||
operator|!
name|useWrap
condition|)
block|{
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
operator|new
name|SaslException
argument_list|(
literal|"Server is not wrapping data"
argument_list|)
argument_list|)
throw|;
block|}
comment|// loops over decoded data and calls processOneRpc
name|unwrapPacketAndProcessRpcs
argument_list|(
name|saslMessage
operator|.
name|getToken
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|saslProcess
argument_list|(
name|saslMessage
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Some exceptions ({@link RetriableException} and {@link StandbyException})      * that are wrapped as a cause of parameter e are unwrapped so that they can      * be sent as the true cause to the client side. In case of      * {@link InvalidToken} we go one level deeper to get the true cause.      *       * @param e the exception that may have a cause we want to unwrap.      * @return the true cause for some exceptions.      */
DECL|method|getTrueCause (IOException e)
specifier|private
name|Throwable
name|getTrueCause
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|e
decl_stmt|;
while|while
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cause
operator|instanceof
name|RetriableException
condition|)
block|{
return|return
name|cause
return|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|StandbyException
condition|)
block|{
return|return
name|cause
return|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|InvalidToken
condition|)
block|{
comment|// FIXME: hadoop method signatures are restricting the SASL
comment|// callbacks to only returning InvalidToken, but some services
comment|// need to throw other exceptions (ex. NN + StandyException),
comment|// so for now we'll tunnel the real exceptions via an
comment|// InvalidToken's cause which normally is not set
if|if
condition|(
name|cause
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|cause
operator|=
name|cause
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
return|return
name|cause
return|;
block|}
name|cause
operator|=
name|cause
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
comment|/**      * Process saslMessage and send saslResponse back      * @param saslMessage received SASL message      * @throws RpcServerException setup failed due to SASL negotiation      *         failure, premature or invalid connection context, or other state       *         errors. This exception needs to be sent to the client. This       *         exception will wrap {@link RetriableException},       *         {@link InvalidToken}, {@link StandbyException} or       *         {@link SaslException}.      * @throws IOException if sending reply fails      * @throws InterruptedException      */
DECL|method|saslProcess (RpcSaslProto saslMessage)
specifier|private
name|void
name|saslProcess
parameter_list|(
name|RpcSaslProto
name|saslMessage
parameter_list|)
throws|throws
name|RpcServerException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|saslContextEstablished
condition|)
block|{
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
operator|new
name|SaslException
argument_list|(
literal|"Negotiation is already complete"
argument_list|)
argument_list|)
throw|;
block|}
name|RpcSaslProto
name|saslResponse
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
name|saslResponse
operator|=
name|processSaslMessage
argument_list|(
name|saslMessage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|rpcMetrics
operator|.
name|incrAuthenticationFailures
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// attempting user could be null
name|IOException
name|tce
init|=
operator|(
name|IOException
operator|)
name|getTrueCause
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|AUDITLOG
operator|.
name|warn
argument_list|(
name|AUTH_FAILED_FOR
operator|+
name|this
operator|.
name|toString
argument_list|()
operator|+
literal|":"
operator|+
name|attemptingUser
operator|+
literal|" ("
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
operator|+
literal|") with true cause: ("
operator|+
name|tce
operator|.
name|getLocalizedMessage
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
throw|throw
name|tce
throw|;
block|}
if|if
condition|(
name|saslServer
operator|!=
literal|null
operator|&&
name|saslServer
operator|.
name|isComplete
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SASL server context established. Negotiated QoP is "
operator|+
name|saslServer
operator|.
name|getNegotiatedProperty
argument_list|(
name|Sasl
operator|.
name|QOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|user
operator|=
name|getAuthorizedUgi
argument_list|(
name|saslServer
operator|.
name|getAuthorizationID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SASL server successfully authenticated client: "
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
name|rpcMetrics
operator|.
name|incrAuthenticationSuccesses
argument_list|()
expr_stmt|;
name|AUDITLOG
operator|.
name|info
argument_list|(
name|AUTH_SUCCESSFUL_FOR
operator|+
name|user
argument_list|)
expr_stmt|;
name|saslContextEstablished
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RpcServerException
name|rse
parameter_list|)
block|{
comment|// don't re-wrap
throw|throw
name|rse
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_UNAUTHORIZED
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
comment|// send back response if any, may throw IOException
if|if
condition|(
name|saslResponse
operator|!=
literal|null
condition|)
block|{
name|doSaslReply
argument_list|(
name|saslResponse
argument_list|)
expr_stmt|;
block|}
comment|// do NOT enable wrapping until the last auth response is sent
if|if
condition|(
name|saslContextEstablished
condition|)
block|{
name|String
name|qop
init|=
operator|(
name|String
operator|)
name|saslServer
operator|.
name|getNegotiatedProperty
argument_list|(
name|Sasl
operator|.
name|QOP
argument_list|)
decl_stmt|;
comment|// SASL wrapping is only used if the connection has a QOP, and
comment|// the value is not auth.  ex. auth-int& auth-priv
name|useWrap
operator|=
operator|(
name|qop
operator|!=
literal|null
operator|&&
operator|!
literal|"auth"
operator|.
name|equalsIgnoreCase
argument_list|(
name|qop
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|useWrap
condition|)
block|{
name|disposeSasl
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Process a saslMessge.      * @param saslMessage received SASL message      * @return the sasl response to send back to client      * @throws SaslException if authentication or generating response fails,       *                       or SASL protocol mixup      * @throws IOException if a SaslServer cannot be created      * @throws AccessControlException if the requested authentication type       *         is not supported or trying to re-attempt negotiation.      * @throws InterruptedException      */
DECL|method|processSaslMessage (RpcSaslProto saslMessage)
specifier|private
name|RpcSaslProto
name|processSaslMessage
parameter_list|(
name|RpcSaslProto
name|saslMessage
parameter_list|)
throws|throws
name|SaslException
throws|,
name|IOException
throws|,
name|AccessControlException
throws|,
name|InterruptedException
block|{
specifier|final
name|RpcSaslProto
name|saslResponse
decl_stmt|;
specifier|final
name|SaslState
name|state
init|=
name|saslMessage
operator|.
name|getState
argument_list|()
decl_stmt|;
comment|// required
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|NEGOTIATE
case|:
block|{
if|if
condition|(
name|sentNegotiate
condition|)
block|{
comment|// FIXME shouldn't this be SaslException?
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Client already attempted negotiation"
argument_list|)
throw|;
block|}
name|saslResponse
operator|=
name|buildSaslNegotiateResponse
argument_list|()
expr_stmt|;
comment|// simple-only server negotiate response is success which client
comment|// interprets as switch to simple
if|if
condition|(
name|saslResponse
operator|.
name|getState
argument_list|()
operator|==
name|SaslState
operator|.
name|SUCCESS
condition|)
block|{
name|switchToSimple
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
name|INITIATE
case|:
block|{
if|if
condition|(
name|saslMessage
operator|.
name|getAuthsCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SaslException
argument_list|(
literal|"Client mechanism is malformed"
argument_list|)
throw|;
block|}
comment|// verify the client requested an advertised authType
name|SaslAuth
name|clientSaslAuth
init|=
name|saslMessage
operator|.
name|getAuths
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|negotiateResponse
operator|.
name|getAuthsList
argument_list|()
operator|.
name|contains
argument_list|(
name|clientSaslAuth
argument_list|)
condition|)
block|{
if|if
condition|(
name|sentNegotiate
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
name|clientSaslAuth
operator|.
name|getMethod
argument_list|()
operator|+
literal|" authentication is not enabled."
operator|+
literal|"  Available:"
operator|+
name|enabledAuthMethods
argument_list|)
throw|;
block|}
name|saslResponse
operator|=
name|buildSaslNegotiateResponse
argument_list|()
expr_stmt|;
break|break;
block|}
name|authMethod
operator|=
name|AuthMethod
operator|.
name|valueOf
argument_list|(
name|clientSaslAuth
operator|.
name|getMethod
argument_list|()
argument_list|)
expr_stmt|;
comment|// abort SASL for SIMPLE auth, server has already ensured that
comment|// SIMPLE is a legit option above.  we will send no response
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
name|switchToSimple
argument_list|()
expr_stmt|;
name|saslResponse
operator|=
literal|null
expr_stmt|;
break|break;
block|}
comment|// sasl server for tokens may already be instantiated
if|if
condition|(
name|saslServer
operator|==
literal|null
operator|||
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|TOKEN
condition|)
block|{
name|saslServer
operator|=
name|createSaslServer
argument_list|(
name|authMethod
argument_list|)
expr_stmt|;
block|}
name|saslResponse
operator|=
name|processSaslToken
argument_list|(
name|saslMessage
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RESPONSE
case|:
block|{
name|saslResponse
operator|=
name|processSaslToken
argument_list|(
name|saslMessage
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|SaslException
argument_list|(
literal|"Client sent unsupported state "
operator|+
name|state
argument_list|)
throw|;
block|}
return|return
name|saslResponse
return|;
block|}
DECL|method|processSaslToken (RpcSaslProto saslMessage)
specifier|private
name|RpcSaslProto
name|processSaslToken
parameter_list|(
name|RpcSaslProto
name|saslMessage
parameter_list|)
throws|throws
name|SaslException
block|{
if|if
condition|(
operator|!
name|saslMessage
operator|.
name|hasToken
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SaslException
argument_list|(
literal|"Client did not send a token"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|saslToken
init|=
name|saslMessage
operator|.
name|getToken
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Have read input token of size "
operator|+
name|saslToken
operator|.
name|length
operator|+
literal|" for processing by saslServer.evaluateResponse()"
argument_list|)
expr_stmt|;
block|}
name|saslToken
operator|=
name|saslServer
operator|.
name|evaluateResponse
argument_list|(
name|saslToken
argument_list|)
expr_stmt|;
return|return
name|buildSaslResponse
argument_list|(
name|saslServer
operator|.
name|isComplete
argument_list|()
condition|?
name|SaslState
operator|.
name|SUCCESS
else|:
name|SaslState
operator|.
name|CHALLENGE
argument_list|,
name|saslToken
argument_list|)
return|;
block|}
DECL|method|switchToSimple ()
specifier|private
name|void
name|switchToSimple
parameter_list|()
block|{
comment|// disable SASL and blank out any SASL server
name|authProtocol
operator|=
name|AuthProtocol
operator|.
name|NONE
expr_stmt|;
name|disposeSasl
argument_list|()
expr_stmt|;
block|}
DECL|method|buildSaslResponse (SaslState state, byte[] replyToken)
specifier|private
name|RpcSaslProto
name|buildSaslResponse
parameter_list|(
name|SaslState
name|state
parameter_list|,
name|byte
index|[]
name|replyToken
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Will send "
operator|+
name|state
operator|+
literal|" token of size "
operator|+
operator|(
operator|(
name|replyToken
operator|!=
literal|null
operator|)
condition|?
name|replyToken
operator|.
name|length
else|:
literal|null
operator|)
operator|+
literal|" from saslServer."
argument_list|)
expr_stmt|;
block|}
name|RpcSaslProto
operator|.
name|Builder
name|response
init|=
name|RpcSaslProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|response
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyToken
operator|!=
literal|null
condition|)
block|{
name|response
operator|.
name|setToken
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|replyToken
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|response
operator|.
name|build
argument_list|()
return|;
block|}
DECL|method|doSaslReply (Message message)
specifier|private
name|void
name|doSaslReply
parameter_list|(
name|Message
name|message
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|RpcCall
name|saslCall
init|=
operator|new
name|RpcCall
argument_list|(
name|this
argument_list|,
name|AuthProtocol
operator|.
name|SASL
operator|.
name|callId
argument_list|)
decl_stmt|;
name|setupResponse
argument_list|(
name|saslCall
argument_list|,
name|RpcStatusProto
operator|.
name|SUCCESS
argument_list|,
literal|null
argument_list|,
name|RpcWritable
operator|.
name|wrap
argument_list|(
name|message
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|saslCall
argument_list|)
expr_stmt|;
block|}
DECL|method|doSaslReply (Exception ioe)
specifier|private
name|void
name|doSaslReply
parameter_list|(
name|Exception
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|setupResponse
argument_list|(
name|authFailedCall
argument_list|,
name|RpcStatusProto
operator|.
name|FATAL
argument_list|,
name|RpcErrorCodeProto
operator|.
name|FATAL_UNAUTHORIZED
argument_list|,
literal|null
argument_list|,
name|ioe
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|ioe
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|authFailedCall
argument_list|)
expr_stmt|;
block|}
DECL|method|disposeSasl ()
specifier|private
name|void
name|disposeSasl
parameter_list|()
block|{
if|if
condition|(
name|saslServer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|saslServer
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SaslException
name|ignored
parameter_list|)
block|{         }
finally|finally
block|{
name|saslServer
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
DECL|method|checkDataLength (int dataLength)
specifier|private
name|void
name|checkDataLength
parameter_list|(
name|int
name|dataLength
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dataLength
operator|<
literal|0
condition|)
block|{
name|String
name|error
init|=
literal|"Unexpected data length "
operator|+
name|dataLength
operator|+
literal|"!! from "
operator|+
name|getHostAddress
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|dataLength
operator|>
name|maxDataLength
condition|)
block|{
name|String
name|error
init|=
literal|"Requested data length "
operator|+
name|dataLength
operator|+
literal|" is longer than maximum configured RPC length "
operator|+
name|maxDataLength
operator|+
literal|".  RPC came from "
operator|+
name|getHostAddress
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
block|}
comment|/**      * This method reads in a non-blocking fashion from the channel:       * this method is called repeatedly when data is present in the channel;       * when it has enough data to process one rpc it processes that rpc.      *       * On the first pass, it processes the connectionHeader,       * connectionContext (an outOfBand RPC) and at most one RPC request that       * follows that. On future passes it will process at most one RPC request.      *        * Quirky things: dataLengthBuffer (4 bytes) is used to read "hrpc" OR       * rpc request length.      *          * @return -1 in case of error, else num bytes read so far      * @throws IOException - internal error that should not be returned to      *         client, typically failure to respond to client      * @throws InterruptedException      */
DECL|method|readAndProcess ()
specifier|public
name|int
name|readAndProcess
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
while|while
condition|(
operator|!
name|shouldClose
argument_list|()
condition|)
block|{
comment|// stop if a fatal response has been sent.
comment|// dataLengthBuffer is used to read "hrpc" or the rpc-packet length
name|int
name|count
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|dataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|dataLengthBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|dataLengthBuffer
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
return|return
name|count
return|;
block|}
if|if
condition|(
operator|!
name|connectionHeaderRead
condition|)
block|{
comment|// Every connection is expected to send the header;
comment|// so far we read "hrpc" of the connection header.
if|if
condition|(
name|connectionHeaderBuf
operator|==
literal|null
condition|)
block|{
comment|// for the bytes that follow "hrpc", in the connection header
name|connectionHeaderBuf
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|HEADER_LEN_AFTER_HRPC_PART
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|connectionHeaderBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|connectionHeaderBuf
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
block|{
return|return
name|count
return|;
block|}
name|int
name|version
init|=
name|connectionHeaderBuf
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// TODO we should add handler for service class later
name|this
operator|.
name|setServiceClass
argument_list|(
name|connectionHeaderBuf
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
comment|// Check if it looks like the user is hitting an IPC port
comment|// with an HTTP GET - this is a common error, so we can
comment|// send back a simple string indicating as much.
if|if
condition|(
name|HTTP_GET_BYTES
operator|.
name|equals
argument_list|(
name|dataLengthBuffer
argument_list|)
condition|)
block|{
name|setupHttpRequestOnIpcPortResponse
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|RpcConstants
operator|.
name|HEADER
operator|.
name|equals
argument_list|(
name|dataLengthBuffer
argument_list|)
operator|||
name|version
operator|!=
name|CURRENT_VERSION
condition|)
block|{
comment|//Warning is ok since this is not supposed to happen.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Incorrect header or version mismatch from "
operator|+
name|hostAddress
operator|+
literal|":"
operator|+
name|remotePort
operator|+
literal|" got version "
operator|+
name|version
operator|+
literal|" expected version "
operator|+
name|CURRENT_VERSION
argument_list|)
expr_stmt|;
name|setupBadVersionResponse
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// this may switch us into SIMPLE
name|authProtocol
operator|=
name|initializeAuthContext
argument_list|(
name|connectionHeaderBuf
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// clear to next read rpc packet len
name|connectionHeaderBuf
operator|=
literal|null
expr_stmt|;
name|connectionHeaderRead
operator|=
literal|true
expr_stmt|;
continue|continue;
comment|// connection header read, now read  4 bytes rpc packet len
block|}
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
comment|// just read 4 bytes -  length of RPC packet
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|dataLength
operator|=
name|dataLengthBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|checkDataLength
argument_list|(
name|dataLength
argument_list|)
expr_stmt|;
comment|// Set buffer for reading EXACTLY the RPC-packet length and no more.
name|data
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|dataLength
argument_list|)
expr_stmt|;
block|}
comment|// Now read the RPC packet
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// to read length of future rpc packets
name|data
operator|.
name|flip
argument_list|()
expr_stmt|;
name|ByteBuffer
name|requestData
init|=
name|data
decl_stmt|;
name|data
operator|=
literal|null
expr_stmt|;
comment|// null out in case processOneRpc throws.
name|boolean
name|isHeaderRead
init|=
name|connectionContextRead
decl_stmt|;
name|processOneRpc
argument_list|(
name|requestData
argument_list|)
expr_stmt|;
comment|// the last rpc-request we processed could have simply been the
comment|// connectionContext; if so continue to read the first RPC.
if|if
condition|(
operator|!
name|isHeaderRead
condition|)
block|{
continue|continue;
block|}
block|}
return|return
name|count
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|initializeAuthContext (int authType)
specifier|private
name|AuthProtocol
name|initializeAuthContext
parameter_list|(
name|int
name|authType
parameter_list|)
throws|throws
name|IOException
block|{
name|AuthProtocol
name|authProtocol
init|=
name|AuthProtocol
operator|.
name|valueOf
argument_list|(
name|authType
argument_list|)
decl_stmt|;
if|if
condition|(
name|authProtocol
operator|==
literal|null
condition|)
block|{
name|IOException
name|ioe
init|=
operator|new
name|IpcException
argument_list|(
literal|"Unknown auth protocol:"
operator|+
name|authType
argument_list|)
decl_stmt|;
name|doSaslReply
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
name|boolean
name|isSimpleEnabled
init|=
name|enabledAuthMethods
operator|.
name|contains
argument_list|(
name|AuthMethod
operator|.
name|SIMPLE
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|authProtocol
condition|)
block|{
case|case
name|NONE
case|:
block|{
comment|// don't reply if client is simple and server is insecure
if|if
condition|(
operator|!
name|isSimpleEnabled
condition|)
block|{
name|IOException
name|ioe
init|=
operator|new
name|AccessControlException
argument_list|(
literal|"SIMPLE authentication is not enabled."
operator|+
literal|"  Available:"
operator|+
name|enabledAuthMethods
argument_list|)
decl_stmt|;
name|doSaslReply
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
break|break;
block|}
default|default:
block|{
break|break;
block|}
block|}
return|return
name|authProtocol
return|;
block|}
comment|/**      * Process the Sasl's Negotiate request, including the optimization of       * accelerating token negotiation.      * @return the response to Negotiate request - the list of enabled       *         authMethods and challenge if the TOKENS are supported.       * @throws SaslException - if attempt to generate challenge fails.      * @throws IOException - if it fails to create the SASL server for Tokens      */
DECL|method|buildSaslNegotiateResponse ()
specifier|private
name|RpcSaslProto
name|buildSaslNegotiateResponse
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|SaslException
throws|,
name|IOException
block|{
name|RpcSaslProto
name|negotiateMessage
init|=
name|negotiateResponse
decl_stmt|;
comment|// accelerate token negotiation by sending initial challenge
comment|// in the negotiation response
if|if
condition|(
name|enabledAuthMethods
operator|.
name|contains
argument_list|(
name|AuthMethod
operator|.
name|TOKEN
argument_list|)
condition|)
block|{
name|saslServer
operator|=
name|createSaslServer
argument_list|(
name|AuthMethod
operator|.
name|TOKEN
argument_list|)
expr_stmt|;
name|byte
index|[]
name|challenge
init|=
name|saslServer
operator|.
name|evaluateResponse
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|RpcSaslProto
operator|.
name|Builder
name|negotiateBuilder
init|=
name|RpcSaslProto
operator|.
name|newBuilder
argument_list|(
name|negotiateResponse
argument_list|)
decl_stmt|;
name|negotiateBuilder
operator|.
name|getAuthsBuilder
argument_list|(
literal|0
argument_list|)
comment|// TOKEN is always first
operator|.
name|setChallenge
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|challenge
argument_list|)
argument_list|)
expr_stmt|;
name|negotiateMessage
operator|=
name|negotiateBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|sentNegotiate
operator|=
literal|true
expr_stmt|;
return|return
name|negotiateMessage
return|;
block|}
DECL|method|createSaslServer (AuthMethod authMethod)
specifier|private
name|SaslServer
name|createSaslServer
parameter_list|(
name|AuthMethod
name|authMethod
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|saslProps
init|=
name|saslPropsResolver
operator|.
name|getServerProperties
argument_list|(
name|addr
argument_list|,
name|ingressPort
argument_list|)
decl_stmt|;
return|return
operator|new
name|SaslRpcServer
argument_list|(
name|authMethod
argument_list|)
operator|.
name|create
argument_list|(
name|this
argument_list|,
name|saslProps
argument_list|,
name|secretManager
argument_list|)
return|;
block|}
comment|/**      * Try to set up the response to indicate that the client version      * is incompatible with the server. This can contain special-case      * code to speak enough of past IPC protocols to pass back      * an exception to the caller.      * @param clientVersion the version the caller is using       * @throws IOException      */
DECL|method|setupBadVersionResponse (int clientVersion)
specifier|private
name|void
name|setupBadVersionResponse
parameter_list|(
name|int
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|errMsg
init|=
literal|"Server IPC version "
operator|+
name|CURRENT_VERSION
operator|+
literal|" cannot communicate with client version "
operator|+
name|clientVersion
decl_stmt|;
name|ByteArrayOutputStream
name|buffer
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|clientVersion
operator|>=
literal|9
condition|)
block|{
comment|// Versions>>9  understand the normal response
name|RpcCall
name|fakeCall
init|=
operator|new
name|RpcCall
argument_list|(
name|this
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|setupResponse
argument_list|(
name|fakeCall
argument_list|,
name|RpcStatusProto
operator|.
name|FATAL
argument_list|,
name|RpcErrorCodeProto
operator|.
name|FATAL_VERSION_MISMATCH
argument_list|,
literal|null
argument_list|,
name|VersionMismatch
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|errMsg
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|fakeCall
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clientVersion
operator|>=
literal|3
condition|)
block|{
name|RpcCall
name|fakeCall
init|=
operator|new
name|RpcCall
argument_list|(
name|this
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// Versions 3 to 8 use older response
name|setupResponseOldVersionFatal
argument_list|(
name|buffer
argument_list|,
name|fakeCall
argument_list|,
literal|null
argument_list|,
name|VersionMismatch
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|errMsg
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|fakeCall
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clientVersion
operator|==
literal|2
condition|)
block|{
comment|// Hadoop 0.18.3
name|RpcCall
name|fakeCall
init|=
operator|new
name|RpcCall
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// call ID
name|out
operator|.
name|writeBoolean
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// error
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|VersionMismatch
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|errMsg
argument_list|)
expr_stmt|;
name|fakeCall
operator|.
name|setResponse
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|buffer
operator|.
name|toByteArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|fakeCall
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setupHttpRequestOnIpcPortResponse ()
specifier|private
name|void
name|setupHttpRequestOnIpcPortResponse
parameter_list|()
throws|throws
name|IOException
block|{
name|RpcCall
name|fakeCall
init|=
operator|new
name|RpcCall
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fakeCall
operator|.
name|setResponse
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|RECEIVED_HTTP_REQ_RESPONSE
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|fakeCall
argument_list|)
expr_stmt|;
block|}
comment|/** Reads the connection context following the connection header      * @throws RpcServerException - if the header cannot be      *         deserialized, or the user is not authorized      */
DECL|method|processConnectionContext (RpcWritable.Buffer buffer)
specifier|private
name|void
name|processConnectionContext
parameter_list|(
name|RpcWritable
operator|.
name|Buffer
name|buffer
parameter_list|)
throws|throws
name|RpcServerException
block|{
comment|// allow only one connection context during a session
if|if
condition|(
name|connectionContextRead
condition|)
block|{
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
literal|"Connection context already processed"
argument_list|)
throw|;
block|}
name|connectionContext
operator|=
name|getMessage
argument_list|(
name|IpcConnectionContextProto
operator|.
name|getDefaultInstance
argument_list|()
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|protocolName
operator|=
name|connectionContext
operator|.
name|hasProtocol
argument_list|()
condition|?
name|connectionContext
operator|.
name|getProtocol
argument_list|()
else|:
literal|null
expr_stmt|;
name|UserGroupInformation
name|protocolUser
init|=
name|ProtoUtil
operator|.
name|getUgi
argument_list|(
name|connectionContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|authProtocol
operator|==
name|AuthProtocol
operator|.
name|NONE
condition|)
block|{
name|user
operator|=
name|protocolUser
expr_stmt|;
block|}
else|else
block|{
comment|// user is authenticated
name|user
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
argument_list|)
expr_stmt|;
comment|//Now we check if this is a proxy user case. If the protocol user is
comment|//different from the 'user', it is a proxy user scenario. However,
comment|//this is not allowed if user authenticated with DIGEST.
if|if
condition|(
operator|(
name|protocolUser
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|protocolUser
operator|.
name|getUserName
argument_list|()
operator|.
name|equals
argument_list|(
name|user
operator|.
name|getUserName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|TOKEN
condition|)
block|{
comment|// Not allowed to doAs if token authentication is used
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_UNAUTHORIZED
argument_list|,
operator|new
name|AccessControlException
argument_list|(
literal|"Authenticated user ("
operator|+
name|user
operator|+
literal|") doesn't match what the client claims to be ("
operator|+
name|protocolUser
operator|+
literal|")"
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
comment|// Effective user can be different from authenticated user
comment|// for simple auth or kerberos auth
comment|// The user is the real user. Now we create a proxy user
name|UserGroupInformation
name|realUser
init|=
name|user
decl_stmt|;
name|user
operator|=
name|UserGroupInformation
operator|.
name|createProxyUser
argument_list|(
name|protocolUser
operator|.
name|getUserName
argument_list|()
argument_list|,
name|realUser
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|authorizeConnection
argument_list|()
expr_stmt|;
comment|// don't set until after authz because connection isn't established
name|connectionContextRead
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
name|connectionManager
operator|.
name|incrUserConnections
argument_list|(
name|user
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Process a wrapped RPC Request - unwrap the SASL packet and process      * each embedded RPC request       * @param inBuf - SASL wrapped request of one or more RPCs      * @throws IOException - SASL packet cannot be unwrapped      * @throws InterruptedException      */
DECL|method|unwrapPacketAndProcessRpcs (byte[] inBuf)
specifier|private
name|void
name|unwrapPacketAndProcessRpcs
parameter_list|(
name|byte
index|[]
name|inBuf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Have read input token of size "
operator|+
name|inBuf
operator|.
name|length
operator|+
literal|" for processing by saslServer.unwrap()"
argument_list|)
expr_stmt|;
block|}
name|inBuf
operator|=
name|saslServer
operator|.
name|unwrap
argument_list|(
name|inBuf
argument_list|,
literal|0
argument_list|,
name|inBuf
operator|.
name|length
argument_list|)
expr_stmt|;
name|ReadableByteChannel
name|ch
init|=
name|Channels
operator|.
name|newChannel
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|inBuf
argument_list|)
argument_list|)
decl_stmt|;
comment|// Read all RPCs contained in the inBuf, even partial ones
while|while
condition|(
operator|!
name|shouldClose
argument_list|()
condition|)
block|{
comment|// stop if a fatal response has been sent.
name|int
name|count
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|unwrappedDataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
name|count
operator|=
name|channelRead
argument_list|(
name|ch
argument_list|,
name|unwrappedDataLengthBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|||
name|unwrappedDataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|unwrappedData
operator|==
literal|null
condition|)
block|{
name|unwrappedDataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|int
name|unwrappedDataLength
init|=
name|unwrappedDataLengthBuffer
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|unwrappedData
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|unwrappedDataLength
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|channelRead
argument_list|(
name|ch
argument_list|,
name|unwrappedData
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|||
name|unwrappedData
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|unwrappedData
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
name|unwrappedDataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|unwrappedData
operator|.
name|flip
argument_list|()
expr_stmt|;
name|ByteBuffer
name|requestData
init|=
name|unwrappedData
decl_stmt|;
name|unwrappedData
operator|=
literal|null
expr_stmt|;
comment|// null out in case processOneRpc throws.
name|processOneRpc
argument_list|(
name|requestData
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Process one RPC Request from buffer read from socket stream       *  - decode rpc in a rpc-Call      *  - handle out-of-band RPC requests such as the initial connectionContext      *  - A successfully decoded RpcCall will be deposited in RPC-Q and      *    its response will be sent later when the request is processed.      *       * Prior to this call the connectionHeader ("hrpc...") has been handled and      * if SASL then SASL has been established and the buf we are passed      * has been unwrapped from SASL.      *       * @param bb - contains the RPC request header and the rpc request      * @throws IOException - internal error that should not be returned to      *         client, typically failure to respond to client      * @throws InterruptedException      */
DECL|method|processOneRpc (ByteBuffer bb)
specifier|private
name|void
name|processOneRpc
parameter_list|(
name|ByteBuffer
name|bb
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// exceptions that escape this method are fatal to the connection.
comment|// setupResponse will use the rpc status to determine if the connection
comment|// should be closed.
name|int
name|callId
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|retry
init|=
name|RpcConstants
operator|.
name|INVALID_RETRY_COUNT
decl_stmt|;
try|try
block|{
specifier|final
name|RpcWritable
operator|.
name|Buffer
name|buffer
init|=
name|RpcWritable
operator|.
name|Buffer
operator|.
name|wrap
argument_list|(
name|bb
argument_list|)
decl_stmt|;
specifier|final
name|RpcRequestHeaderProto
name|header
init|=
name|getMessage
argument_list|(
name|RpcRequestHeaderProto
operator|.
name|getDefaultInstance
argument_list|()
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
name|callId
operator|=
name|header
operator|.
name|getCallId
argument_list|()
expr_stmt|;
name|retry
operator|=
name|header
operator|.
name|getRetryCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|" got #"
operator|+
name|callId
argument_list|)
expr_stmt|;
block|}
name|checkRpcHeaders
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|callId
operator|<
literal|0
condition|)
block|{
comment|// callIds typically used during connection setup
name|processRpcOutOfBandRequest
argument_list|(
name|header
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|connectionContextRead
condition|)
block|{
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
literal|"Connection context not established"
argument_list|)
throw|;
block|}
else|else
block|{
name|processRpcRequest
argument_list|(
name|header
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RpcServerException
name|rse
parameter_list|)
block|{
comment|// inform client of error, but do not rethrow else non-fatal
comment|// exceptions will close connection!
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": processOneRpc from client "
operator|+
name|this
operator|+
literal|" threw exception ["
operator|+
name|rse
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
comment|// use the wrapped exception if there is one.
name|Throwable
name|t
init|=
operator|(
name|rse
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|)
condition|?
name|rse
operator|.
name|getCause
argument_list|()
else|:
name|rse
decl_stmt|;
specifier|final
name|RpcCall
name|call
init|=
operator|new
name|RpcCall
argument_list|(
name|this
argument_list|,
name|callId
argument_list|,
name|retry
argument_list|)
decl_stmt|;
name|setupResponse
argument_list|(
name|call
argument_list|,
name|rse
operator|.
name|getRpcStatusProto
argument_list|()
argument_list|,
name|rse
operator|.
name|getRpcErrorCodeProto
argument_list|()
argument_list|,
literal|null
argument_list|,
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Verify RPC header is valid      * @param header - RPC request header      * @throws RpcServerException - header contains invalid values      */
DECL|method|checkRpcHeaders (RpcRequestHeaderProto header)
specifier|private
name|void
name|checkRpcHeaders
parameter_list|(
name|RpcRequestHeaderProto
name|header
parameter_list|)
throws|throws
name|RpcServerException
block|{
if|if
condition|(
operator|!
name|header
operator|.
name|hasRpcOp
argument_list|()
condition|)
block|{
name|String
name|err
init|=
literal|" IPC Server: No rpc op in rpcRequestHeader"
decl_stmt|;
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
name|err
argument_list|)
throw|;
block|}
if|if
condition|(
name|header
operator|.
name|getRpcOp
argument_list|()
operator|!=
name|RpcRequestHeaderProto
operator|.
name|OperationProto
operator|.
name|RPC_FINAL_PACKET
condition|)
block|{
name|String
name|err
init|=
literal|"IPC Server does not implement rpc header operation"
operator|+
name|header
operator|.
name|getRpcOp
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
name|err
argument_list|)
throw|;
block|}
comment|// If we know the rpc kind, get its class so that we can deserialize
comment|// (Note it would make more sense to have the handler deserialize but
comment|// we continue with this original design.
if|if
condition|(
operator|!
name|header
operator|.
name|hasRpcKind
argument_list|()
condition|)
block|{
name|String
name|err
init|=
literal|" IPC Server: No rpc kind in rpcRequestHeader"
decl_stmt|;
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
name|err
argument_list|)
throw|;
block|}
block|}
comment|/**      * Process an RPC Request       *   - the connection headers and context must have been already read.      *   - Based on the rpcKind, decode the rpcRequest.      *   - A successfully decoded RpcCall will be deposited in RPC-Q and      *     its response will be sent later when the request is processed.      * @param header - RPC request header      * @param buffer - stream to request payload      * @throws RpcServerException - generally due to fatal rpc layer issues      *   such as invalid header or deserialization error.  The call queue      *   may also throw a fatal or non-fatal exception on overflow.      * @throws IOException - fatal internal error that should/could not      *   be sent to client.      * @throws InterruptedException      */
DECL|method|processRpcRequest (RpcRequestHeaderProto header, RpcWritable.Buffer buffer)
specifier|private
name|void
name|processRpcRequest
parameter_list|(
name|RpcRequestHeaderProto
name|header
parameter_list|,
name|RpcWritable
operator|.
name|Buffer
name|buffer
parameter_list|)
throws|throws
name|RpcServerException
throws|,
name|InterruptedException
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|rpcRequestClass
init|=
name|getRpcRequestWrapper
argument_list|(
name|header
operator|.
name|getRpcKind
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpcRequestClass
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown rpc kind "
operator|+
name|header
operator|.
name|getRpcKind
argument_list|()
operator|+
literal|" from client "
operator|+
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|String
name|err
init|=
literal|"Unknown rpc kind in rpc header"
operator|+
name|header
operator|.
name|getRpcKind
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
name|err
argument_list|)
throw|;
block|}
name|Writable
name|rpcRequest
decl_stmt|;
try|try
block|{
comment|//Read the rpc request
name|rpcRequest
operator|=
name|buffer
operator|.
name|newInstance
argument_list|(
name|rpcRequestClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RpcServerException
name|rse
parameter_list|)
block|{
comment|// lets tests inject failures.
throw|throw
name|rse
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// includes runtime exception from newInstance
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to read call parameters for client "
operator|+
name|getHostAddress
argument_list|()
operator|+
literal|"on connection protocol "
operator|+
name|this
operator|.
name|protocolName
operator|+
literal|" for rpcKind "
operator|+
name|header
operator|.
name|getRpcKind
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|String
name|err
init|=
literal|"IPC server unable to read call parameters: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_DESERIALIZING_REQUEST
argument_list|,
name|err
argument_list|)
throw|;
block|}
name|TraceScope
name|traceScope
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|header
operator|.
name|hasTraceInfo
argument_list|()
condition|)
block|{
if|if
condition|(
name|tracer
operator|!=
literal|null
condition|)
block|{
comment|// If the incoming RPC included tracing info, always continue the
comment|// trace
name|SpanId
name|parentSpanId
init|=
operator|new
name|SpanId
argument_list|(
name|header
operator|.
name|getTraceInfo
argument_list|()
operator|.
name|getTraceId
argument_list|()
argument_list|,
name|header
operator|.
name|getTraceInfo
argument_list|()
operator|.
name|getParentId
argument_list|()
argument_list|)
decl_stmt|;
name|traceScope
operator|=
name|tracer
operator|.
name|newScope
argument_list|(
name|RpcClientUtil
operator|.
name|toTraceName
argument_list|(
name|rpcRequest
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|parentSpanId
argument_list|)
expr_stmt|;
name|traceScope
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alignmentContext
operator|!=
literal|null
condition|)
block|{
comment|// Check incoming RPC request's state.
name|alignmentContext
operator|.
name|receiveRequestState
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
name|CallerContext
name|callerContext
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|header
operator|.
name|hasCallerContext
argument_list|()
condition|)
block|{
name|callerContext
operator|=
operator|new
name|CallerContext
operator|.
name|Builder
argument_list|(
name|header
operator|.
name|getCallerContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|)
operator|.
name|setSignature
argument_list|(
name|header
operator|.
name|getCallerContext
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|RpcCall
name|call
init|=
operator|new
name|RpcCall
argument_list|(
name|this
argument_list|,
name|header
operator|.
name|getCallId
argument_list|()
argument_list|,
name|header
operator|.
name|getRetryCount
argument_list|()
argument_list|,
name|rpcRequest
argument_list|,
name|ProtoUtil
operator|.
name|convert
argument_list|(
name|header
operator|.
name|getRpcKind
argument_list|()
argument_list|)
argument_list|,
name|header
operator|.
name|getClientId
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|traceScope
argument_list|,
name|callerContext
argument_list|)
decl_stmt|;
comment|// Save the priority level assignment by the scheduler
name|call
operator|.
name|setPriorityLevel
argument_list|(
name|callQueue
operator|.
name|getPriorityLevel
argument_list|(
name|call
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|internalQueueCall
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RpcServerException
name|rse
parameter_list|)
block|{
throw|throw
name|rse
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|ERROR_RPC_SERVER
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
name|incRpcCount
argument_list|()
expr_stmt|;
comment|// Increment the rpc count
block|}
comment|/**      * Establish RPC connection setup by negotiating SASL if required, then      * reading and authorizing the connection header      * @param header - RPC header      * @param buffer - stream to request payload      * @throws RpcServerException - setup failed due to SASL      *         negotiation failure, premature or invalid connection context,      *         or other state errors. This exception needs to be sent to the       *         client.      * @throws IOException - failed to send a response back to the client      * @throws InterruptedException      */
DECL|method|processRpcOutOfBandRequest (RpcRequestHeaderProto header, RpcWritable.Buffer buffer)
specifier|private
name|void
name|processRpcOutOfBandRequest
parameter_list|(
name|RpcRequestHeaderProto
name|header
parameter_list|,
name|RpcWritable
operator|.
name|Buffer
name|buffer
parameter_list|)
throws|throws
name|RpcServerException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|int
name|callId
init|=
name|header
operator|.
name|getCallId
argument_list|()
decl_stmt|;
if|if
condition|(
name|callId
operator|==
name|CONNECTION_CONTEXT_CALL_ID
condition|)
block|{
comment|// SASL must be established prior to connection context
if|if
condition|(
name|authProtocol
operator|==
name|AuthProtocol
operator|.
name|SASL
operator|&&
operator|!
name|saslContextEstablished
condition|)
block|{
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
literal|"Connection header sent during SASL negotiation"
argument_list|)
throw|;
block|}
comment|// read and authorize the user
name|processConnectionContext
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|callId
operator|==
name|AuthProtocol
operator|.
name|SASL
operator|.
name|callId
condition|)
block|{
comment|// if client was switched to simple, ignore first SASL message
if|if
condition|(
name|authProtocol
operator|!=
name|AuthProtocol
operator|.
name|SASL
condition|)
block|{
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
literal|"SASL protocol not requested by client"
argument_list|)
throw|;
block|}
name|saslReadAndProcess
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|callId
operator|==
name|PING_CALL_ID
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received ping message"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_INVALID_RPC_HEADER
argument_list|,
literal|"Unknown out of band call #"
operator|+
name|callId
argument_list|)
throw|;
block|}
block|}
comment|/**      * Authorize proxy users to access this server      * @throws RpcServerException - user is not allowed to proxy      */
DECL|method|authorizeConnection ()
specifier|private
name|void
name|authorizeConnection
parameter_list|()
throws|throws
name|RpcServerException
block|{
try|try
block|{
comment|// If auth method is TOKEN, the token was obtained by the
comment|// real user for the effective user, therefore not required to
comment|// authorize real user. doAs is allowed only for simple or kerberos
comment|// authentication
if|if
condition|(
name|user
operator|!=
literal|null
operator|&&
name|user
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|TOKEN
operator|)
condition|)
block|{
name|ProxyUsers
operator|.
name|authorize
argument_list|(
name|user
argument_list|,
name|this
operator|.
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|authorize
argument_list|(
name|user
argument_list|,
name|protocolName
argument_list|,
name|getHostInetAddress
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Successfully authorized "
operator|+
name|connectionContext
argument_list|)
expr_stmt|;
block|}
name|rpcMetrics
operator|.
name|incrAuthorizationSuccesses
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AuthorizationException
name|ae
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Connection from "
operator|+
name|this
operator|+
literal|" for protocol "
operator|+
name|connectionContext
operator|.
name|getProtocol
argument_list|()
operator|+
literal|" is unauthorized for user "
operator|+
name|user
argument_list|)
expr_stmt|;
name|rpcMetrics
operator|.
name|incrAuthorizationFailures
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_UNAUTHORIZED
argument_list|,
name|ae
argument_list|)
throw|;
block|}
block|}
comment|/**      * Decode the a protobuf from the given input stream       * @return Message - decoded protobuf      * @throws RpcServerException - deserialization failed      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getMessage (Message message, RpcWritable.Buffer buffer)
parameter_list|<
name|T
extends|extends
name|Message
parameter_list|>
name|T
name|getMessage
parameter_list|(
name|Message
name|message
parameter_list|,
name|RpcWritable
operator|.
name|Buffer
name|buffer
parameter_list|)
throws|throws
name|RpcServerException
block|{
try|try
block|{
return|return
operator|(
name|T
operator|)
name|buffer
operator|.
name|getValue
argument_list|(
name|message
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ioe
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|protoClass
init|=
name|message
operator|.
name|getClass
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|FatalRpcServerException
argument_list|(
name|RpcErrorCodeProto
operator|.
name|FATAL_DESERIALIZING_REQUEST
argument_list|,
literal|"Error decoding "
operator|+
name|protoClass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
operator|+
name|ioe
argument_list|)
throw|;
block|}
block|}
comment|// ipc reader threads should invoke this directly, whereas handlers
comment|// must invoke call.sendResponse to allow lifecycle management of
comment|// external, postponed, deferred calls, etc.
DECL|method|sendResponse (RpcCall call)
specifier|private
name|void
name|sendResponse
parameter_list|(
name|RpcCall
name|call
parameter_list|)
throws|throws
name|IOException
block|{
name|responder
operator|.
name|doRespond
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get service class for connection      * @return the serviceClass      */
DECL|method|getServiceClass ()
specifier|public
name|int
name|getServiceClass
parameter_list|()
block|{
return|return
name|serviceClass
return|;
block|}
comment|/**      * Set service class for connection      * @param serviceClass the serviceClass to set      */
DECL|method|setServiceClass (int serviceClass)
specifier|public
name|void
name|setServiceClass
parameter_list|(
name|int
name|serviceClass
parameter_list|)
block|{
name|this
operator|.
name|serviceClass
operator|=
name|serviceClass
expr_stmt|;
block|}
DECL|method|close ()
specifier|private
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|disposeSasl
argument_list|()
expr_stmt|;
name|data
operator|=
literal|null
expr_stmt|;
name|dataLengthBuffer
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
return|return;
try|try
block|{
name|socket
operator|.
name|shutdownOutput
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring socket shutdown exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|socket
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|queueCall (Call call)
specifier|public
name|void
name|queueCall
parameter_list|(
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// external non-rpc calls don't need server exception wrapper.
try|try
block|{
name|internalQueueCall
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RpcServerException
name|rse
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|rse
operator|.
name|getCause
argument_list|()
throw|;
block|}
block|}
DECL|method|internalQueueCall (Call call)
specifier|private
name|void
name|internalQueueCall
parameter_list|(
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|callQueue
operator|.
name|put
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|// queue the call; maybe blocked here
block|}
catch|catch
parameter_list|(
name|CallQueueOverflowException
name|cqe
parameter_list|)
block|{
comment|// If rpc scheduler indicates back off based on performance degradation
comment|// such as response time or rpc queue is full, we will ask the client
comment|// to back off by throwing RetriableException. Whether the client will
comment|// honor RetriableException and retry depends the client and its policy.
comment|// For example, IPC clients using FailoverOnNetworkExceptionRetry handle
comment|// RetriableException.
name|rpcMetrics
operator|.
name|incrClientBackoff
argument_list|()
expr_stmt|;
comment|// unwrap retriable exception.
throw|throw
name|cqe
operator|.
name|getCause
argument_list|()
throw|;
block|}
block|}
comment|/** Handles queued calls . */
DECL|class|Handler
specifier|private
class|class
name|Handler
extends|extends
name|Thread
block|{
DECL|method|Handler (int instanceNumber)
specifier|public
name|Handler
parameter_list|(
name|int
name|instanceNumber
parameter_list|)
block|{
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"IPC Server handler "
operator|+
name|instanceNumber
operator|+
literal|" on default port "
operator|+
name|port
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
name|SERVER
operator|.
name|set
argument_list|(
name|Server
operator|.
name|this
argument_list|)
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|TraceScope
name|traceScope
init|=
literal|null
decl_stmt|;
try|try
block|{
specifier|final
name|Call
name|call
init|=
name|callQueue
operator|.
name|take
argument_list|()
decl_stmt|;
comment|// pop the queue; maybe blocked here
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|call
operator|+
literal|" for RpcKind "
operator|+
name|call
operator|.
name|rpcKind
argument_list|)
expr_stmt|;
block|}
name|CurCall
operator|.
name|set
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|.
name|traceScope
operator|!=
literal|null
condition|)
block|{
name|call
operator|.
name|traceScope
operator|.
name|reattach
argument_list|()
expr_stmt|;
name|traceScope
operator|=
name|call
operator|.
name|traceScope
expr_stmt|;
name|traceScope
operator|.
name|getSpan
argument_list|()
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"called"
argument_list|)
expr_stmt|;
block|}
comment|// always update the current call context
name|CallerContext
operator|.
name|setCurrent
argument_list|(
name|call
operator|.
name|callerContext
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|remoteUser
init|=
name|call
operator|.
name|getRemoteUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|remoteUser
operator|!=
literal|null
condition|)
block|{
name|remoteUser
operator|.
name|doAs
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|call
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
comment|// unexpected -- log it
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" unexpectedly interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|traceScope
operator|!=
literal|null
condition|)
block|{
name|traceScope
operator|.
name|getSpan
argument_list|()
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"unexpectedly interrupted: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" caught an exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|traceScope
operator|!=
literal|null
condition|)
block|{
name|traceScope
operator|.
name|getSpan
argument_list|()
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"Exception: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|CurCall
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|traceScope
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": exiting"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|logException (Logger logger, Throwable e, Call call)
name|void
name|logException
parameter_list|(
name|Logger
name|logger
parameter_list|,
name|Throwable
name|e
parameter_list|,
name|Call
name|call
parameter_list|)
block|{
if|if
condition|(
name|exceptionsHandler
operator|.
name|isSuppressedLog
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return;
comment|// Log nothing.
block|}
specifier|final
name|String
name|logMsg
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", call "
operator|+
name|call
decl_stmt|;
if|if
condition|(
name|exceptionsHandler
operator|.
name|isTerseLog
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
comment|// Don't log the whole stack trace. Way too noisy!
name|logger
operator|.
name|info
argument_list|(
name|logMsg
operator|+
literal|": "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|RuntimeException
operator|||
name|e
operator|instanceof
name|Error
condition|)
block|{
comment|// These exception types indicate something is probably wrong
comment|// on the server side, as opposed to just a normal exceptional
comment|// result.
name|logger
operator|.
name|warn
argument_list|(
name|logMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|info
argument_list|(
name|logMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|Server (String bindAddress, int port, Class<? extends Writable> paramClass, int handlerCount, Configuration conf)
specifier|protected
name|Server
parameter_list|(
name|String
name|bindAddress
parameter_list|,
name|int
name|port
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|paramClass
parameter_list|,
name|int
name|handlerCount
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|bindAddress
argument_list|,
name|port
argument_list|,
name|paramClass
argument_list|,
name|handlerCount
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|conf
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|port
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|Server (String bindAddress, int port, Class<? extends Writable> rpcRequestClass, int handlerCount, int numReaders, int queueSizePerHandler, Configuration conf, String serverName, SecretManager<? extends TokenIdentifier> secretManager)
specifier|protected
name|Server
parameter_list|(
name|String
name|bindAddress
parameter_list|,
name|int
name|port
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|rpcRequestClass
parameter_list|,
name|int
name|handlerCount
parameter_list|,
name|int
name|numReaders
parameter_list|,
name|int
name|queueSizePerHandler
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|serverName
parameter_list|,
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|secretManager
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|bindAddress
argument_list|,
name|port
argument_list|,
name|rpcRequestClass
argument_list|,
name|handlerCount
argument_list|,
name|numReaders
argument_list|,
name|queueSizePerHandler
argument_list|,
name|conf
argument_list|,
name|serverName
argument_list|,
name|secretManager
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**     * Constructs a server listening on the named port and address.  Parameters passed must    * be of the named class.  The<code>handlerCount</code> determines    * the number of handler threads that will be used to process calls.    * If queueSizePerHandler or numReaders are not -1 they will be used instead of parameters    * from configuration. Otherwise the configuration will be picked up.    *     * If rpcRequestClass is null then the rpcRequestClass must have been     * registered via {@link #registerProtocolEngine(RPC.RpcKind,    *  Class, RPC.RpcInvoker)}    * This parameter has been retained for compatibility with existing tests    * and usage.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|Server (String bindAddress, int port, Class<? extends Writable> rpcRequestClass, int handlerCount, int numReaders, int queueSizePerHandler, Configuration conf, String serverName, SecretManager<? extends TokenIdentifier> secretManager, String portRangeConfig)
specifier|protected
name|Server
parameter_list|(
name|String
name|bindAddress
parameter_list|,
name|int
name|port
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|rpcRequestClass
parameter_list|,
name|int
name|handlerCount
parameter_list|,
name|int
name|numReaders
parameter_list|,
name|int
name|queueSizePerHandler
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|serverName
parameter_list|,
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|secretManager
parameter_list|,
name|String
name|portRangeConfig
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|bindAddress
operator|=
name|bindAddress
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|portRangeConfig
operator|=
name|portRangeConfig
expr_stmt|;
name|this
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|this
operator|.
name|rpcRequestClass
operator|=
name|rpcRequestClass
expr_stmt|;
name|this
operator|.
name|handlerCount
operator|=
name|handlerCount
expr_stmt|;
name|this
operator|.
name|socketSendBufferSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
name|this
operator|.
name|auxiliaryListenerMap
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|maxDataLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_MAXIMUM_DATA_LENGTH
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_MAXIMUM_DATA_LENGTH_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|queueSizePerHandler
operator|!=
operator|-
literal|1
condition|)
block|{
name|this
operator|.
name|maxQueueSize
operator|=
name|handlerCount
operator|*
name|queueSizePerHandler
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|maxQueueSize
operator|=
name|handlerCount
operator|*
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_HANDLER_QUEUE_SIZE_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_HANDLER_QUEUE_SIZE_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|maxRespSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_RPC_MAX_RESPONSE_SIZE_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|numReaders
operator|!=
operator|-
literal|1
condition|)
block|{
name|this
operator|.
name|readThreads
operator|=
name|numReaders
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|readThreads
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_RPC_READ_THREADS_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_RPC_READ_THREADS_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|readerPendingConnectionQueue
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_RPC_READ_CONNECTION_QUEUE_SIZE_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_SERVER_RPC_READ_CONNECTION_QUEUE_SIZE_DEFAULT
argument_list|)
expr_stmt|;
comment|// Setup appropriate callqueue
specifier|final
name|String
name|prefix
init|=
name|getQueueClassPrefix
argument_list|()
decl_stmt|;
name|this
operator|.
name|callQueue
operator|=
operator|new
name|CallQueueManager
argument_list|<
name|Call
argument_list|>
argument_list|(
name|getQueueClass
argument_list|(
name|prefix
argument_list|,
name|conf
argument_list|)
argument_list|,
name|getSchedulerClass
argument_list|(
name|prefix
argument_list|,
name|conf
argument_list|)
argument_list|,
name|getClientBackoffEnable
argument_list|(
name|prefix
argument_list|,
name|conf
argument_list|)
argument_list|,
name|maxQueueSize
argument_list|,
name|prefix
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|secretManager
operator|=
operator|(
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
operator|)
name|secretManager
expr_stmt|;
name|this
operator|.
name|authorize
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// configure supported authentications
name|this
operator|.
name|enabledAuthMethods
operator|=
name|getAuthMethods
argument_list|(
name|secretManager
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|negotiateResponse
operator|=
name|buildNegotiateResponse
argument_list|(
name|enabledAuthMethods
argument_list|)
expr_stmt|;
comment|// Start the listener here and let it bind to the port
name|listener
operator|=
operator|new
name|Listener
argument_list|(
name|port
argument_list|)
expr_stmt|;
comment|// set the server port to the default listener port.
name|this
operator|.
name|port
operator|=
name|listener
operator|.
name|getAddress
argument_list|()
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|connectionManager
operator|=
operator|new
name|ConnectionManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcMetrics
operator|=
name|RpcMetrics
operator|.
name|create
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcDetailedMetrics
operator|=
name|RpcDetailedMetrics
operator|.
name|create
argument_list|(
name|this
operator|.
name|port
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpNoDelay
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_SERVER_TCPNODELAY_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_SERVER_TCPNODELAY_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setLogSlowRPC
argument_list|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_SERVER_LOG_SLOW_RPC
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_SERVER_LOG_SLOW_RPC_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create the responder here
name|responder
operator|=
operator|new
name|Responder
argument_list|()
expr_stmt|;
if|if
condition|(
name|secretManager
operator|!=
literal|null
operator|||
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|SaslRpcServer
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|saslPropsResolver
operator|=
name|SaslPropertiesResolver
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|exceptionsHandler
operator|.
name|addTerseLoggingExceptions
argument_list|(
name|StandbyException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|addAuxiliaryListener (int auxiliaryPort)
specifier|public
specifier|synchronized
name|void
name|addAuxiliaryListener
parameter_list|(
name|int
name|auxiliaryPort
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|auxiliaryListenerMap
operator|==
literal|null
condition|)
block|{
name|auxiliaryListenerMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|auxiliaryListenerMap
operator|.
name|containsKey
argument_list|(
name|auxiliaryPort
argument_list|)
operator|&&
name|auxiliaryPort
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"There is already a listener binding to: "
operator|+
name|auxiliaryPort
argument_list|)
throw|;
block|}
name|Listener
name|newListener
init|=
operator|new
name|Listener
argument_list|(
name|auxiliaryPort
argument_list|)
decl_stmt|;
comment|// in the case of port = 0, the listener would be on a != 0 port.
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding a server listener on port "
operator|+
name|newListener
operator|.
name|getAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
name|auxiliaryListenerMap
operator|.
name|put
argument_list|(
name|newListener
operator|.
name|getAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|,
name|newListener
argument_list|)
expr_stmt|;
block|}
DECL|method|buildNegotiateResponse (List<AuthMethod> authMethods)
specifier|private
name|RpcSaslProto
name|buildNegotiateResponse
parameter_list|(
name|List
argument_list|<
name|AuthMethod
argument_list|>
name|authMethods
parameter_list|)
throws|throws
name|IOException
block|{
name|RpcSaslProto
operator|.
name|Builder
name|negotiateBuilder
init|=
name|RpcSaslProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethods
operator|.
name|contains
argument_list|(
name|AuthMethod
operator|.
name|SIMPLE
argument_list|)
operator|&&
name|authMethods
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// SIMPLE-only servers return success in response to negotiate
name|negotiateBuilder
operator|.
name|setState
argument_list|(
name|SaslState
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|negotiateBuilder
operator|.
name|setState
argument_list|(
name|SaslState
operator|.
name|NEGOTIATE
argument_list|)
expr_stmt|;
for|for
control|(
name|AuthMethod
name|authMethod
range|:
name|authMethods
control|)
block|{
name|SaslRpcServer
name|saslRpcServer
init|=
operator|new
name|SaslRpcServer
argument_list|(
name|authMethod
argument_list|)
decl_stmt|;
name|SaslAuth
operator|.
name|Builder
name|builder
init|=
name|negotiateBuilder
operator|.
name|addAuthsBuilder
argument_list|()
operator|.
name|setMethod
argument_list|(
name|authMethod
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|setMechanism
argument_list|(
name|saslRpcServer
operator|.
name|mechanism
argument_list|)
decl_stmt|;
if|if
condition|(
name|saslRpcServer
operator|.
name|protocol
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setProtocol
argument_list|(
name|saslRpcServer
operator|.
name|protocol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saslRpcServer
operator|.
name|serverId
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setServerId
argument_list|(
name|saslRpcServer
operator|.
name|serverId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|negotiateBuilder
operator|.
name|build
argument_list|()
return|;
block|}
comment|// get the security type from the conf. implicitly include token support
comment|// if a secret manager is provided, or fail if token is the conf value but
comment|// there is no secret manager
DECL|method|getAuthMethods (SecretManager<?> secretManager, Configuration conf)
specifier|private
name|List
argument_list|<
name|AuthMethod
argument_list|>
name|getAuthMethods
parameter_list|(
name|SecretManager
argument_list|<
name|?
argument_list|>
name|secretManager
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|AuthenticationMethod
name|confAuthenticationMethod
init|=
name|SecurityUtil
operator|.
name|getAuthenticationMethod
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AuthMethod
argument_list|>
name|authMethods
init|=
operator|new
name|ArrayList
argument_list|<
name|AuthMethod
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|confAuthenticationMethod
operator|==
name|AuthenticationMethod
operator|.
name|TOKEN
condition|)
block|{
if|if
condition|(
name|secretManager
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AuthenticationMethod
operator|.
name|TOKEN
operator|+
literal|" authentication requires a secret manager"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|secretManager
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|AuthenticationMethod
operator|.
name|TOKEN
operator|+
literal|" authentication enabled for secret manager"
argument_list|)
expr_stmt|;
comment|// most preferred, go to the front of the line!
name|authMethods
operator|.
name|add
argument_list|(
name|AuthenticationMethod
operator|.
name|TOKEN
operator|.
name|getAuthMethod
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|authMethods
operator|.
name|add
argument_list|(
name|confAuthenticationMethod
operator|.
name|getAuthMethod
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server accepts auth methods:"
operator|+
name|authMethods
argument_list|)
expr_stmt|;
return|return
name|authMethods
return|;
block|}
DECL|method|closeConnection (Connection connection)
specifier|private
name|void
name|closeConnection
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|connectionManager
operator|.
name|close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
comment|/**    * Setup response for the IPC Call.    *     * @param call {@link Call} to which we are setting up the response    * @param status of the IPC call    * @param rv return value for the IPC Call, if the call was successful    * @param errorClass error class, if the the call failed    * @param error error message, if the call failed    * @throws IOException    */
DECL|method|setupResponse ( RpcCall call, RpcStatusProto status, RpcErrorCodeProto erCode, Writable rv, String errorClass, String error)
specifier|private
name|void
name|setupResponse
parameter_list|(
name|RpcCall
name|call
parameter_list|,
name|RpcStatusProto
name|status
parameter_list|,
name|RpcErrorCodeProto
name|erCode
parameter_list|,
name|Writable
name|rv
parameter_list|,
name|String
name|errorClass
parameter_list|,
name|String
name|error
parameter_list|)
throws|throws
name|IOException
block|{
comment|// fatal responses will cause the reader to close the connection.
if|if
condition|(
name|status
operator|==
name|RpcStatusProto
operator|.
name|FATAL
condition|)
block|{
name|call
operator|.
name|connection
operator|.
name|setShouldClose
argument_list|()
expr_stmt|;
block|}
name|RpcResponseHeaderProto
operator|.
name|Builder
name|headerBuilder
init|=
name|RpcResponseHeaderProto
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|headerBuilder
operator|.
name|setClientId
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|call
operator|.
name|clientId
argument_list|)
argument_list|)
expr_stmt|;
name|headerBuilder
operator|.
name|setCallId
argument_list|(
name|call
operator|.
name|callId
argument_list|)
expr_stmt|;
name|headerBuilder
operator|.
name|setRetryCount
argument_list|(
name|call
operator|.
name|retryCount
argument_list|)
expr_stmt|;
name|headerBuilder
operator|.
name|setStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|headerBuilder
operator|.
name|setServerIpcVersionNum
argument_list|(
name|CURRENT_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RpcStatusProto
operator|.
name|SUCCESS
condition|)
block|{
name|RpcResponseHeaderProto
name|header
init|=
name|headerBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
try|try
block|{
name|setupResponse
argument_list|(
name|call
argument_list|,
name|header
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error serializing call response for call "
operator|+
name|call
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Call back to same function - this is OK since the
comment|// buffer is reset at the top, and since status is changed
comment|// to ERROR it won't infinite loop.
name|setupResponse
argument_list|(
name|call
argument_list|,
name|RpcStatusProto
operator|.
name|ERROR
argument_list|,
name|RpcErrorCodeProto
operator|.
name|ERROR_SERIALIZING_RESPONSE
argument_list|,
literal|null
argument_list|,
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// Rpc Failure
name|headerBuilder
operator|.
name|setExceptionClassName
argument_list|(
name|errorClass
argument_list|)
expr_stmt|;
name|headerBuilder
operator|.
name|setErrorMsg
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|headerBuilder
operator|.
name|setErrorDetail
argument_list|(
name|erCode
argument_list|)
expr_stmt|;
name|setupResponse
argument_list|(
name|call
argument_list|,
name|headerBuilder
operator|.
name|build
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setupResponse (RpcCall call, RpcResponseHeaderProto header, Writable rv)
specifier|private
name|void
name|setupResponse
parameter_list|(
name|RpcCall
name|call
parameter_list|,
name|RpcResponseHeaderProto
name|header
parameter_list|,
name|Writable
name|rv
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|alignmentContext
operator|!=
literal|null
operator|&&
name|call
operator|.
name|bufferedHeader
operator|==
literal|null
operator|&&
name|call
operator|.
name|bufferedRv
operator|==
literal|null
condition|)
block|{
name|call
operator|.
name|setBufferedHeader
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|call
operator|.
name|setBufferedRv
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|response
decl_stmt|;
if|if
condition|(
name|rv
operator|==
literal|null
operator|||
operator|(
name|rv
operator|instanceof
name|RpcWritable
operator|.
name|ProtobufWrapper
operator|)
condition|)
block|{
name|response
operator|=
name|setupResponseForProtobuf
argument_list|(
name|header
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|response
operator|=
name|setupResponseForWritable
argument_list|(
name|header
argument_list|,
name|rv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|response
operator|.
name|length
operator|>
name|maxRespSize
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Large response size "
operator|+
name|response
operator|.
name|length
operator|+
literal|" for call "
operator|+
name|call
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|setResponse
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|setupResponseForWritable ( RpcResponseHeaderProto header, Writable rv)
specifier|private
name|byte
index|[]
name|setupResponseForWritable
parameter_list|(
name|RpcResponseHeaderProto
name|header
parameter_list|,
name|Writable
name|rv
parameter_list|)
throws|throws
name|IOException
block|{
name|ResponseBuffer
name|buf
init|=
name|responseBuffer
operator|.
name|get
argument_list|()
operator|.
name|reset
argument_list|()
decl_stmt|;
try|try
block|{
name|RpcWritable
operator|.
name|wrap
argument_list|(
name|header
argument_list|)
operator|.
name|writeTo
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|null
condition|)
block|{
name|RpcWritable
operator|.
name|wrap
argument_list|(
name|rv
argument_list|)
operator|.
name|writeTo
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toByteArray
argument_list|()
return|;
block|}
finally|finally
block|{
comment|// Discard a large buf and reset it back to smaller size
comment|// to free up heap.
if|if
condition|(
name|buf
operator|.
name|capacity
argument_list|()
operator|>
name|maxRespSize
condition|)
block|{
name|buf
operator|.
name|setCapacity
argument_list|(
name|INITIAL_RESP_BUF_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// writing to a pre-allocated array is the most efficient way to construct
comment|// a protobuf response.
DECL|method|setupResponseForProtobuf ( RpcResponseHeaderProto header, Writable rv)
specifier|private
name|byte
index|[]
name|setupResponseForProtobuf
parameter_list|(
name|RpcResponseHeaderProto
name|header
parameter_list|,
name|Writable
name|rv
parameter_list|)
throws|throws
name|IOException
block|{
name|Message
name|payload
init|=
operator|(
name|rv
operator|!=
literal|null
operator|)
condition|?
operator|(
operator|(
name|RpcWritable
operator|.
name|ProtobufWrapper
operator|)
name|rv
operator|)
operator|.
name|getMessage
argument_list|()
else|:
literal|null
decl_stmt|;
name|int
name|length
init|=
name|getDelimitedLength
argument_list|(
name|header
argument_list|)
decl_stmt|;
if|if
condition|(
name|payload
operator|!=
literal|null
condition|)
block|{
name|length
operator|+=
name|getDelimitedLength
argument_list|(
name|payload
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|length
operator|+
literal|4
index|]
decl_stmt|;
name|CodedOutputStream
name|cos
init|=
name|CodedOutputStream
operator|.
name|newInstance
argument_list|(
name|buf
argument_list|)
decl_stmt|;
comment|// the stream only supports little endian ints
name|cos
operator|.
name|writeRawByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|length
operator|>>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|cos
operator|.
name|writeRawByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|length
operator|>>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|cos
operator|.
name|writeRawByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|length
operator|>>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|cos
operator|.
name|writeRawByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|length
operator|>>>
literal|0
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|cos
operator|.
name|writeRawVarint32
argument_list|(
name|header
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|header
operator|.
name|writeTo
argument_list|(
name|cos
argument_list|)
expr_stmt|;
if|if
condition|(
name|payload
operator|!=
literal|null
condition|)
block|{
name|cos
operator|.
name|writeRawVarint32
argument_list|(
name|payload
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|payload
operator|.
name|writeTo
argument_list|(
name|cos
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
DECL|method|getDelimitedLength (Message message)
specifier|private
specifier|static
name|int
name|getDelimitedLength
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|int
name|length
init|=
name|message
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
return|return
name|length
operator|+
name|CodedOutputStream
operator|.
name|computeRawVarint32Size
argument_list|(
name|length
argument_list|)
return|;
block|}
comment|/**    * Setup response for the IPC Call on Fatal Error from a     * client that is using old version of Hadoop.    * The response is serialized using the previous protocol's response    * layout.    *     * @param response buffer to serialize the response into    * @param call {@link Call} to which we are setting up the response    * @param rv return value for the IPC Call, if the call was successful    * @param errorClass error class, if the the call failed    * @param error error message, if the call failed    * @throws IOException    */
DECL|method|setupResponseOldVersionFatal (ByteArrayOutputStream response, RpcCall call, Writable rv, String errorClass, String error)
specifier|private
name|void
name|setupResponseOldVersionFatal
parameter_list|(
name|ByteArrayOutputStream
name|response
parameter_list|,
name|RpcCall
name|call
parameter_list|,
name|Writable
name|rv
parameter_list|,
name|String
name|errorClass
parameter_list|,
name|String
name|error
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|OLD_VERSION_FATAL_STATUS
init|=
operator|-
literal|1
decl_stmt|;
name|response
operator|.
name|reset
argument_list|()
expr_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|response
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|call
operator|.
name|callId
argument_list|)
expr_stmt|;
comment|// write call id
name|out
operator|.
name|writeInt
argument_list|(
name|OLD_VERSION_FATAL_STATUS
argument_list|)
expr_stmt|;
comment|// write FATAL_STATUS
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|errorClass
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|call
operator|.
name|setResponse
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|response
operator|.
name|toByteArray
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|wrapWithSasl (RpcCall call)
specifier|private
name|void
name|wrapWithSasl
parameter_list|(
name|RpcCall
name|call
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|call
operator|.
name|connection
operator|.
name|saslServer
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|token
init|=
name|call
operator|.
name|rpcResponse
operator|.
name|array
argument_list|()
decl_stmt|;
comment|// synchronization may be needed since there can be multiple Handler
comment|// threads using saslServer to wrap responses.
synchronized|synchronized
init|(
name|call
operator|.
name|connection
operator|.
name|saslServer
init|)
block|{
name|token
operator|=
name|call
operator|.
name|connection
operator|.
name|saslServer
operator|.
name|wrap
argument_list|(
name|token
argument_list|,
literal|0
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding saslServer wrapped token of size "
operator|+
name|token
operator|.
name|length
operator|+
literal|" as call response."
argument_list|)
expr_stmt|;
comment|// rebuild with sasl header and payload
name|RpcResponseHeaderProto
name|saslHeader
init|=
name|RpcResponseHeaderProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setCallId
argument_list|(
name|AuthProtocol
operator|.
name|SASL
operator|.
name|callId
argument_list|)
operator|.
name|setStatus
argument_list|(
name|RpcStatusProto
operator|.
name|SUCCESS
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RpcSaslProto
name|saslMessage
init|=
name|RpcSaslProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setState
argument_list|(
name|SaslState
operator|.
name|WRAP
argument_list|)
operator|.
name|setToken
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|token
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|setupResponse
argument_list|(
name|call
argument_list|,
name|saslHeader
argument_list|,
name|RpcWritable
operator|.
name|wrap
argument_list|(
name|saslMessage
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getConf ()
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/** Sets the socket buffer size used for responding to RPCs */
DECL|method|setSocketSendBufSize (int size)
specifier|public
name|void
name|setSocketSendBufSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|socketSendBufferSize
operator|=
name|size
expr_stmt|;
block|}
DECL|method|setTracer (Tracer t)
specifier|public
name|void
name|setTracer
parameter_list|(
name|Tracer
name|t
parameter_list|)
block|{
name|this
operator|.
name|tracer
operator|=
name|t
expr_stmt|;
block|}
comment|/** Starts the service.  Must be called before any calls will be handled. */
DECL|method|start ()
specifier|public
specifier|synchronized
name|void
name|start
parameter_list|()
block|{
name|responder
operator|.
name|start
argument_list|()
expr_stmt|;
name|listener
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|auxiliaryListenerMap
operator|!=
literal|null
operator|&&
name|auxiliaryListenerMap
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Listener
name|newListener
range|:
name|auxiliaryListenerMap
operator|.
name|values
argument_list|()
control|)
block|{
name|newListener
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
name|handlers
operator|=
operator|new
name|Handler
index|[
name|handlerCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|handlerCount
condition|;
name|i
operator|++
control|)
block|{
name|handlers
index|[
name|i
index|]
operator|=
operator|new
name|Handler
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|handlers
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Stops the service.  No new calls will be handled after this is called. */
DECL|method|stop ()
specifier|public
specifier|synchronized
name|void
name|stop
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping server on "
operator|+
name|port
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|handlers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|handlerCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|handlers
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|handlers
index|[
name|i
index|]
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|listener
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|listener
operator|.
name|doStop
argument_list|()
expr_stmt|;
if|if
condition|(
name|auxiliaryListenerMap
operator|!=
literal|null
operator|&&
name|auxiliaryListenerMap
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Listener
name|newListener
range|:
name|auxiliaryListenerMap
operator|.
name|values
argument_list|()
control|)
block|{
name|newListener
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|newListener
operator|.
name|doStop
argument_list|()
expr_stmt|;
block|}
block|}
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcMetrics
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcDetailedMetrics
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/** Wait for the server to be stopped.    * Does not wait for all subthreads to finish.    *  See {@link #stop()}.    */
DECL|method|join ()
specifier|public
specifier|synchronized
name|void
name|join
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|running
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return the socket (ip+port) on which the RPC server is listening to.    * @return the socket (ip+port) on which the RPC server is listening to.    */
DECL|method|getListenerAddress ()
specifier|public
specifier|synchronized
name|InetSocketAddress
name|getListenerAddress
parameter_list|()
block|{
return|return
name|listener
operator|.
name|getAddress
argument_list|()
return|;
block|}
comment|/**    * Return the set of all the configured auxiliary socket addresses NameNode    * RPC is listening on. If there are none, or it is not configured at all, an    * empty set is returned.    * @return the set of all the auxiliary addresses on which the    *         RPC server is listening on.    */
DECL|method|getAuxiliaryListenerAddresses ()
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|InetSocketAddress
argument_list|>
name|getAuxiliaryListenerAddresses
parameter_list|()
block|{
name|Set
argument_list|<
name|InetSocketAddress
argument_list|>
name|allAddrs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|auxiliaryListenerMap
operator|!=
literal|null
operator|&&
name|auxiliaryListenerMap
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Listener
name|auxListener
range|:
name|auxiliaryListenerMap
operator|.
name|values
argument_list|()
control|)
block|{
name|allAddrs
operator|.
name|add
argument_list|(
name|auxListener
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|allAddrs
return|;
block|}
comment|/**     * Called for each call.     * @deprecated Use  {@link #call(RPC.RpcKind, String,    *  Writable, long)} instead    */
annotation|@
name|Deprecated
DECL|method|call (Writable param, long receiveTime)
specifier|public
name|Writable
name|call
parameter_list|(
name|Writable
name|param
parameter_list|,
name|long
name|receiveTime
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|call
argument_list|(
name|RPC
operator|.
name|RpcKind
operator|.
name|RPC_BUILTIN
argument_list|,
literal|null
argument_list|,
name|param
argument_list|,
name|receiveTime
argument_list|)
return|;
block|}
comment|/** Called for each call. */
DECL|method|call (RPC.RpcKind rpcKind, String protocol, Writable param, long receiveTime)
specifier|public
specifier|abstract
name|Writable
name|call
parameter_list|(
name|RPC
operator|.
name|RpcKind
name|rpcKind
parameter_list|,
name|String
name|protocol
parameter_list|,
name|Writable
name|param
parameter_list|,
name|long
name|receiveTime
parameter_list|)
throws|throws
name|Exception
function_decl|;
comment|/**    * Authorize the incoming client connection.    *     * @param user client user    * @param protocolName - the protocol    * @param addr InetAddress of incoming connection    * @throws AuthorizationException when the client isn't authorized to talk the protocol    */
DECL|method|authorize (UserGroupInformation user, String protocolName, InetAddress addr)
specifier|private
name|void
name|authorize
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|,
name|String
name|protocolName
parameter_list|,
name|InetAddress
name|addr
parameter_list|)
throws|throws
name|AuthorizationException
block|{
if|if
condition|(
name|authorize
condition|)
block|{
if|if
condition|(
name|protocolName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AuthorizationException
argument_list|(
literal|"Null protocol not authorized"
argument_list|)
throw|;
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|protocol
init|=
literal|null
decl_stmt|;
try|try
block|{
name|protocol
operator|=
name|getProtocolClass
argument_list|(
name|protocolName
argument_list|,
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cfne
parameter_list|)
block|{
throw|throw
operator|new
name|AuthorizationException
argument_list|(
literal|"Unknown protocol: "
operator|+
name|protocolName
argument_list|)
throw|;
block|}
name|serviceAuthorizationManager
operator|.
name|authorize
argument_list|(
name|user
argument_list|,
name|protocol
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the port on which the IPC Server is listening for incoming connections.    * This could be an ephemeral port too, in which case we return the real    * port on which the Server has bound.    * @return port on which IPC Server is listening    */
DECL|method|getPort ()
specifier|public
name|int
name|getPort
parameter_list|()
block|{
return|return
name|port
return|;
block|}
comment|/**    * The number of open RPC conections    * @return the number of open rpc connections    */
DECL|method|getNumOpenConnections ()
specifier|public
name|int
name|getNumOpenConnections
parameter_list|()
block|{
return|return
name|connectionManager
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Get the NumOpenConnections/User.    */
DECL|method|getNumOpenConnectionsPerUser ()
specifier|public
name|String
name|getNumOpenConnectionsPerUser
parameter_list|()
block|{
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|mapper
operator|.
name|writeValueAsString
argument_list|(
name|connectionManager
operator|.
name|getUserToConnectionsMap
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{     }
return|return
literal|null
return|;
block|}
comment|/**    * The number of RPC connections dropped due to    * too many connections.    * @return the number of dropped rpc connections    */
DECL|method|getNumDroppedConnections ()
specifier|public
name|long
name|getNumDroppedConnections
parameter_list|()
block|{
return|return
name|connectionManager
operator|.
name|getDroppedConnections
argument_list|()
return|;
block|}
comment|/**    * The number of rpc calls in the queue.    * @return The number of rpc calls in the queue.    */
DECL|method|getCallQueueLen ()
specifier|public
name|int
name|getCallQueueLen
parameter_list|()
block|{
return|return
name|callQueue
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isClientBackoffEnabled ()
specifier|public
name|boolean
name|isClientBackoffEnabled
parameter_list|()
block|{
return|return
name|callQueue
operator|.
name|isClientBackoffEnabled
argument_list|()
return|;
block|}
DECL|method|setClientBackoffEnabled (boolean value)
specifier|public
name|void
name|setClientBackoffEnabled
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|callQueue
operator|.
name|setClientBackoffEnabled
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * The maximum size of the rpc call queue of this server.    * @return The maximum size of the rpc call queue.    */
DECL|method|getMaxQueueSize ()
specifier|public
name|int
name|getMaxQueueSize
parameter_list|()
block|{
return|return
name|maxQueueSize
return|;
block|}
comment|/**    * The number of reader threads for this server.    * @return The number of reader threads.    */
DECL|method|getNumReaders ()
specifier|public
name|int
name|getNumReaders
parameter_list|()
block|{
return|return
name|readThreads
return|;
block|}
comment|/**    * When the read or write buffer size is larger than this limit, i/o will be     * done in chunks of this size. Most RPC requests and responses would be    * be smaller.    */
DECL|field|NIO_BUFFER_LIMIT
specifier|private
specifier|static
name|int
name|NIO_BUFFER_LIMIT
init|=
literal|8
operator|*
literal|1024
decl_stmt|;
comment|//should not be more than 64KB.
comment|/**    * This is a wrapper around {@link WritableByteChannel#write(ByteBuffer)}.    * If the amount of data is large, it writes to channel in smaller chunks.     * This is to avoid jdk from creating many direct buffers as the size of     * buffer increases. This also minimizes extra copies in NIO layer    * as a result of multiple write operations required to write a large     * buffer.      *    * @see WritableByteChannel#write(ByteBuffer)    */
DECL|method|channelWrite (WritableByteChannel channel, ByteBuffer buffer)
specifier|private
name|int
name|channelWrite
parameter_list|(
name|WritableByteChannel
name|channel
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
operator|(
name|buffer
operator|.
name|remaining
argument_list|()
operator|<=
name|NIO_BUFFER_LIMIT
operator|)
condition|?
name|channel
operator|.
name|write
argument_list|(
name|buffer
argument_list|)
else|:
name|channelIO
argument_list|(
literal|null
argument_list|,
name|channel
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|rpcMetrics
operator|.
name|incrSentBytes
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * This is a wrapper around {@link ReadableByteChannel#read(ByteBuffer)}.    * If the amount of data is large, it writes to channel in smaller chunks.     * This is to avoid jdk from creating many direct buffers as the size of     * ByteBuffer increases. There should not be any performance degredation.    *     * @see ReadableByteChannel#read(ByteBuffer)    */
DECL|method|channelRead (ReadableByteChannel channel, ByteBuffer buffer)
specifier|private
name|int
name|channelRead
parameter_list|(
name|ReadableByteChannel
name|channel
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
operator|(
name|buffer
operator|.
name|remaining
argument_list|()
operator|<=
name|NIO_BUFFER_LIMIT
operator|)
condition|?
name|channel
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
else|:
name|channelIO
argument_list|(
name|channel
argument_list|,
literal|null
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|rpcMetrics
operator|.
name|incrReceivedBytes
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Helper for {@link #channelRead(ReadableByteChannel, ByteBuffer)}    * and {@link #channelWrite(WritableByteChannel, ByteBuffer)}. Only    * one of readCh or writeCh should be non-null.    *     * @see #channelRead(ReadableByteChannel, ByteBuffer)    * @see #channelWrite(WritableByteChannel, ByteBuffer)    */
DECL|method|channelIO (ReadableByteChannel readCh, WritableByteChannel writeCh, ByteBuffer buf)
specifier|private
specifier|static
name|int
name|channelIO
parameter_list|(
name|ReadableByteChannel
name|readCh
parameter_list|,
name|WritableByteChannel
name|writeCh
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|originalLimit
init|=
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|int
name|initialRemaining
init|=
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|int
name|ioSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|NIO_BUFFER_LIMIT
argument_list|)
decl_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|ioSize
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|readCh
operator|==
literal|null
operator|)
condition|?
name|writeCh
operator|.
name|write
argument_list|(
name|buf
argument_list|)
else|:
name|readCh
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|ioSize
condition|)
block|{
break|break;
block|}
block|}
finally|finally
block|{
name|buf
operator|.
name|limit
argument_list|(
name|originalLimit
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|nBytes
init|=
name|initialRemaining
operator|-
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
return|return
operator|(
name|nBytes
operator|>
literal|0
operator|)
condition|?
name|nBytes
else|:
name|ret
return|;
block|}
DECL|class|ConnectionManager
specifier|private
class|class
name|ConnectionManager
block|{
DECL|field|count
specifier|final
specifier|private
name|AtomicInteger
name|count
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|droppedConnections
specifier|final
specifier|private
name|AtomicLong
name|droppedConnections
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|connections
specifier|final
specifier|private
name|Set
argument_list|<
name|Connection
argument_list|>
name|connections
decl_stmt|;
comment|/* Map to maintain the statistics per User */
DECL|field|userToConnectionsMap
specifier|final
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|userToConnectionsMap
decl_stmt|;
DECL|field|userToConnectionsMapLock
specifier|final
specifier|private
name|Object
name|userToConnectionsMapLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|idleScanTimer
specifier|final
specifier|private
name|Timer
name|idleScanTimer
decl_stmt|;
DECL|field|idleScanThreshold
specifier|final
specifier|private
name|int
name|idleScanThreshold
decl_stmt|;
DECL|field|idleScanInterval
specifier|final
specifier|private
name|int
name|idleScanInterval
decl_stmt|;
DECL|field|maxIdleTime
specifier|final
specifier|private
name|int
name|maxIdleTime
decl_stmt|;
DECL|field|maxIdleToClose
specifier|final
specifier|private
name|int
name|maxIdleToClose
decl_stmt|;
DECL|field|maxConnections
specifier|final
specifier|private
name|int
name|maxConnections
decl_stmt|;
DECL|method|ConnectionManager ()
name|ConnectionManager
parameter_list|()
block|{
name|this
operator|.
name|idleScanTimer
operator|=
operator|new
name|Timer
argument_list|(
literal|"IPC Server idle connection scanner for port "
operator|+
name|getPort
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|idleScanThreshold
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_IDLETHRESHOLD_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_IDLETHRESHOLD_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|idleScanInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_CONNECTION_IDLESCANINTERVAL_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_CONNECTION_IDLESCANINTERVAL_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxIdleTime
operator|=
literal|2
operator|*
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECTION_MAXIDLETIME_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxIdleToClose
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_KILL_MAX_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_KILL_MAX_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxConnections
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_SERVER_MAX_CONNECTIONS_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_SERVER_MAX_CONNECTIONS_DEFAULT
argument_list|)
expr_stmt|;
comment|// create a set with concurrency -and- a thread-safe iterator, add 2
comment|// for listener and idle closer threads
name|this
operator|.
name|connections
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|Connection
argument_list|,
name|Boolean
argument_list|>
argument_list|(
name|maxQueueSize
argument_list|,
literal|0.75f
argument_list|,
name|readThreads
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|userToConnectionsMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|add (Connection connection)
specifier|private
name|boolean
name|add
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|boolean
name|added
init|=
name|connections
operator|.
name|add
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|added
condition|)
block|{
name|count
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
DECL|method|remove (Connection connection)
specifier|private
name|boolean
name|remove
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|boolean
name|removed
init|=
name|connections
operator|.
name|remove
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
condition|)
block|{
name|count
operator|.
name|getAndDecrement
argument_list|()
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
DECL|method|incrUserConnections (String user)
name|void
name|incrUserConnections
parameter_list|(
name|String
name|user
parameter_list|)
block|{
synchronized|synchronized
init|(
name|userToConnectionsMapLock
init|)
block|{
name|Integer
name|count
init|=
name|userToConnectionsMap
operator|.
name|get
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|null
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|count
operator|++
expr_stmt|;
block|}
name|userToConnectionsMap
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|decrUserConnections (String user)
name|void
name|decrUserConnections
parameter_list|(
name|String
name|user
parameter_list|)
block|{
synchronized|synchronized
init|(
name|userToConnectionsMapLock
init|)
block|{
name|Integer
name|count
init|=
name|userToConnectionsMap
operator|.
name|get
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|null
condition|)
block|{
return|return;
block|}
else|else
block|{
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|userToConnectionsMap
operator|.
name|remove
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|userToConnectionsMap
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getUserToConnectionsMap ()
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getUserToConnectionsMap
parameter_list|()
block|{
return|return
name|userToConnectionsMap
return|;
block|}
DECL|method|getDroppedConnections ()
name|long
name|getDroppedConnections
parameter_list|()
block|{
return|return
name|droppedConnections
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|size ()
name|int
name|size
parameter_list|()
block|{
return|return
name|count
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|isFull ()
name|boolean
name|isFull
parameter_list|()
block|{
comment|// The check is disabled when maxConnections<= 0.
return|return
operator|(
operator|(
name|maxConnections
operator|>
literal|0
operator|)
operator|&&
operator|(
name|size
argument_list|()
operator|>=
name|maxConnections
operator|)
operator|)
return|;
block|}
DECL|method|toArray ()
name|Connection
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|connections
operator|.
name|toArray
argument_list|(
operator|new
name|Connection
index|[
literal|0
index|]
argument_list|)
return|;
block|}
DECL|method|register (SocketChannel channel, int ingressPort)
name|Connection
name|register
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|int
name|ingressPort
parameter_list|)
block|{
if|if
condition|(
name|isFull
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Connection
name|connection
init|=
operator|new
name|Connection
argument_list|(
name|channel
argument_list|,
name|Time
operator|.
name|now
argument_list|()
argument_list|,
name|ingressPort
argument_list|)
decl_stmt|;
name|add
argument_list|(
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server connection from "
operator|+
name|connection
operator|+
literal|"; # active connections: "
operator|+
name|size
argument_list|()
operator|+
literal|"; # queued calls: "
operator|+
name|callQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
return|;
block|}
DECL|method|close (Connection connection)
name|boolean
name|close
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|boolean
name|exists
init|=
name|remove
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": disconnecting client "
operator|+
name|connection
operator|+
literal|". Number of active connections: "
operator|+
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// only close if actually removed to avoid double-closing due
comment|// to possible races
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Remove authorized users only
if|if
condition|(
name|connection
operator|.
name|user
operator|!=
literal|null
operator|&&
name|connection
operator|.
name|connectionContextRead
condition|)
block|{
name|decrUserConnections
argument_list|(
name|connection
operator|.
name|user
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|exists
return|;
block|}
comment|// synch'ed to avoid explicit invocation upon OOM from colliding with
comment|// timer task firing
DECL|method|closeIdle (boolean scanAll)
specifier|synchronized
name|void
name|closeIdle
parameter_list|(
name|boolean
name|scanAll
parameter_list|)
block|{
name|long
name|minLastContact
init|=
name|Time
operator|.
name|now
argument_list|()
operator|-
name|maxIdleTime
decl_stmt|;
comment|// concurrent iterator might miss new connections added
comment|// during the iteration, but that's ok because they won't
comment|// be idle yet anyway and will be caught on next scan
name|int
name|closed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Connection
name|connection
range|:
name|connections
control|)
block|{
comment|// stop if connections dropped below threshold unless scanning all
if|if
condition|(
operator|!
name|scanAll
operator|&&
name|size
argument_list|()
operator|<
name|idleScanThreshold
condition|)
block|{
break|break;
block|}
comment|// stop if not scanning all and max connections are closed
if|if
condition|(
name|connection
operator|.
name|isIdle
argument_list|()
operator|&&
name|connection
operator|.
name|getLastContact
argument_list|()
operator|<
name|minLastContact
operator|&&
name|close
argument_list|(
name|connection
argument_list|)
operator|&&
operator|!
name|scanAll
operator|&&
operator|(
operator|++
name|closed
operator|==
name|maxIdleToClose
operator|)
condition|)
block|{
break|break;
block|}
block|}
block|}
DECL|method|closeAll ()
name|void
name|closeAll
parameter_list|()
block|{
comment|// use a copy of the connections to be absolutely sure the concurrent
comment|// iterator doesn't miss a connection
for|for
control|(
name|Connection
name|connection
range|:
name|toArray
argument_list|()
control|)
block|{
name|close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|startIdleScan ()
name|void
name|startIdleScan
parameter_list|()
block|{
name|scheduleIdleScanTask
argument_list|()
expr_stmt|;
block|}
DECL|method|stopIdleScan ()
name|void
name|stopIdleScan
parameter_list|()
block|{
name|idleScanTimer
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
DECL|method|scheduleIdleScanTask ()
specifier|private
name|void
name|scheduleIdleScanTask
parameter_list|()
block|{
if|if
condition|(
operator|!
name|running
condition|)
block|{
return|return;
block|}
name|TimerTask
name|idleScanTask
init|=
operator|new
name|TimerTask
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
operator|!
name|running
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": task running"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|closeIdle
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// explicitly reschedule so next execution occurs relative
comment|// to the end of this scan, not the beginning
name|scheduleIdleScanTask
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|idleScanTimer
operator|.
name|schedule
argument_list|(
name|idleScanTask
argument_list|,
name|idleScanInterval
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getServerName ()
specifier|public
name|String
name|getServerName
parameter_list|()
block|{
return|return
name|serverName
return|;
block|}
block|}
end_class

end_unit

