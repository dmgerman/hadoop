begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io.file.tfile
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|file
operator|.
name|tfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_comment
comment|/**  * Supporting Utility classes used by TFile, and shared by users of TFile.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|Utils
specifier|public
specifier|final
class|class
name|Utils
block|{
comment|/**    * Prevent the instantiation of Utils.    */
DECL|method|Utils ()
specifier|private
name|Utils
parameter_list|()
block|{
comment|// nothing
block|}
comment|/**    * Encoding an integer into a variable-length encoding format. Synonymous to    *<code>Utils#writeVLong(out, n)</code>.    *     * @param out    *          output stream    * @param n    *          The integer to be encoded    * @throws IOException    * @see Utils#writeVLong(DataOutput, long)    */
DECL|method|writeVInt (DataOutput out, int n)
specifier|public
specifier|static
name|void
name|writeVInt
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|writeVLong
argument_list|(
name|out
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/**    * Encoding a Long integer into a variable-length encoding format.    *<ul>    *<li>if n in [-32, 127): encode in one byte with the actual value.    * Otherwise,    *<li>if n in [-20*2^8, 20*2^8): encode in two bytes: byte[0] = n/256 - 52;    * byte[1]=n&0xff. Otherwise,    *<li>if n IN [-16*2^16, 16*2^16): encode in three bytes: byte[0]=n/2^16 -    * 88; byte[1]=(n>>8)&0xff; byte[2]=n&0xff. Otherwise,    *<li>if n in [-8*2^24, 8*2^24): encode in four bytes: byte[0]=n/2^24 - 112;    * byte[1] = (n>>16)&0xff; byte[2] = (n>>8)&0xff; byte[3]=n&0xff. Otherwise:    *<li>if n in [-2^31, 2^31): encode in five bytes: byte[0]=-125; byte[1] =    * (n>>24)&0xff; byte[2]=(n>>16)&0xff; byte[3]=(n>>8)&0xff; byte[4]=n&0xff;    *<li>if n in [-2^39, 2^39): encode in six bytes: byte[0]=-124; byte[1] =    * (n>>32)&0xff; byte[2]=(n>>24)&0xff; byte[3]=(n>>16)&0xff;    * byte[4]=(n>>8)&0xff; byte[5]=n&0xff    *<li>if n in [-2^47, 2^47): encode in seven bytes: byte[0]=-123; byte[1] =    * (n>>40)&0xff; byte[2]=(n>>32)&0xff; byte[3]=(n>>24)&0xff;    * byte[4]=(n>>16)&0xff; byte[5]=(n>>8)&0xff; byte[6]=n&0xff;    *<li>if n in [-2^55, 2^55): encode in eight bytes: byte[0]=-122; byte[1] =    * (n>>48)&0xff; byte[2] = (n>>40)&0xff; byte[3]=(n>>32)&0xff;    * byte[4]=(n>>24)&0xff; byte[5]=(n>>16)&0xff; byte[6]=(n>>8)&0xff;    * byte[7]=n&0xff;    *<li>if n in [-2^63, 2^63): encode in nine bytes: byte[0]=-121; byte[1] =    * (n>>54)&0xff; byte[2] = (n>>48)&0xff; byte[3] = (n>>40)&0xff;    * byte[4]=(n>>32)&0xff; byte[5]=(n>>24)&0xff; byte[6]=(n>>16)&0xff;    * byte[7]=(n>>8)&0xff; byte[8]=n&0xff;    *</ul>    *     * @param out    *          output stream    * @param n    *          the integer number    * @throws IOException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"fallthrough"
argument_list|)
DECL|method|writeVLong (DataOutput out, long n)
specifier|public
specifier|static
name|void
name|writeVLong
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|n
operator|<
literal|128
operator|)
operator|&&
operator|(
name|n
operator|>=
operator|-
literal|32
operator|)
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
name|long
name|un
init|=
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
operator|~
name|n
else|:
name|n
decl_stmt|;
comment|// how many bytes do we need to represent the number with sign bit?
name|int
name|len
init|=
operator|(
name|Long
operator|.
name|SIZE
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|un
argument_list|)
operator|)
operator|/
literal|8
operator|+
literal|1
decl_stmt|;
name|int
name|firstByte
init|=
call|(
name|int
call|)
argument_list|(
name|n
operator|>>
operator|(
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
comment|// fall it through to firstByte==-1, len=2.
name|firstByte
operator|>>=
literal|8
expr_stmt|;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|firstByte
operator|<
literal|20
operator|)
operator|&&
operator|(
name|firstByte
operator|>=
operator|-
literal|20
operator|)
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
name|firstByte
operator|-
literal|52
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// fall it through to firstByte==0/-1, len=3.
name|firstByte
operator|>>=
literal|8
expr_stmt|;
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|firstByte
operator|<
literal|16
operator|)
operator|&&
operator|(
name|firstByte
operator|>=
operator|-
literal|16
operator|)
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
name|firstByte
operator|-
literal|88
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeShort
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// fall it through to firstByte==0/-1, len=4.
name|firstByte
operator|>>=
literal|8
expr_stmt|;
case|case
literal|4
case|:
if|if
condition|(
operator|(
name|firstByte
operator|<
literal|8
operator|)
operator|&&
operator|(
name|firstByte
operator|>=
operator|-
literal|8
operator|)
condition|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
name|firstByte
operator|-
literal|112
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeShort
argument_list|(
operator|(
operator|(
name|int
operator|)
name|n
operator|)
operator|>>>
literal|8
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
name|out
operator|.
name|writeByte
argument_list|(
name|len
operator|-
literal|129
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
return|return;
case|case
literal|5
case|:
name|out
operator|.
name|writeByte
argument_list|(
name|len
operator|-
literal|129
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|n
operator|>>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
return|return;
case|case
literal|6
case|:
name|out
operator|.
name|writeByte
argument_list|(
name|len
operator|-
literal|129
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|n
operator|>>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeShort
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
return|return;
case|case
literal|7
case|:
name|out
operator|.
name|writeByte
argument_list|(
name|len
operator|-
literal|129
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|n
operator|>>>
literal|24
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeShort
argument_list|(
call|(
name|int
call|)
argument_list|(
name|n
operator|>>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
name|out
operator|.
name|writeByte
argument_list|(
name|len
operator|-
literal|129
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Internal error"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Decoding the variable-length integer. Synonymous to    *<code>(int)Utils#readVLong(in)</code>.    *     * @param in    *          input stream    * @return the decoded integer    * @throws IOException    *     * @see Utils#readVLong(DataInput)    */
DECL|method|readVInt (DataInput in)
specifier|public
specifier|static
name|int
name|readVInt
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|ret
init|=
name|readVLong
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|>
name|Integer
operator|.
name|MAX_VALUE
operator|)
operator|||
operator|(
name|ret
operator|<
name|Integer
operator|.
name|MIN_VALUE
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Number too large to be represented as Integer"
argument_list|)
throw|;
block|}
return|return
operator|(
name|int
operator|)
name|ret
return|;
block|}
comment|/**    * Decoding the variable-length integer. Suppose the value of the first byte    * is FB, and the following bytes are NB[*].    *<ul>    *<li>if (FB>= -32), return (long)FB;    *<li>if (FB in [-72, -33]), return (FB+52)<<8 + NB[0]&0xff;    *<li>if (FB in [-104, -73]), return (FB+88)<<16 + (NB[0]&0xff)<<8 +    * NB[1]&0xff;    *<li>if (FB in [-120, -105]), return (FB+112)<<24 + (NB[0]&0xff)<<16 +    * (NB[1]&0xff)<<8 + NB[2]&0xff;    *<li>if (FB in [-128, -121]), return interpret NB[FB+129] as a signed    * big-endian integer.    *     * @param in    *          input stream    * @return the decoded long integer.    * @throws IOException    */
DECL|method|readVLong (DataInput in)
specifier|public
specifier|static
name|long
name|readVLong
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|firstByte
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstByte
operator|>=
operator|-
literal|32
condition|)
block|{
return|return
name|firstByte
return|;
block|}
switch|switch
condition|(
operator|(
name|firstByte
operator|+
literal|128
operator|)
operator|/
literal|8
condition|)
block|{
case|case
literal|11
case|:
case|case
literal|10
case|:
case|case
literal|9
case|:
case|case
literal|8
case|:
case|case
literal|7
case|:
return|return
operator|(
operator|(
name|firstByte
operator|+
literal|52
operator|)
operator|<<
literal|8
operator|)
operator||
name|in
operator|.
name|readUnsignedByte
argument_list|()
return|;
case|case
literal|6
case|:
case|case
literal|5
case|:
case|case
literal|4
case|:
case|case
literal|3
case|:
return|return
operator|(
operator|(
name|firstByte
operator|+
literal|88
operator|)
operator|<<
literal|16
operator|)
operator||
name|in
operator|.
name|readUnsignedShort
argument_list|()
return|;
case|case
literal|2
case|:
case|case
literal|1
case|:
return|return
operator|(
operator|(
name|firstByte
operator|+
literal|112
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|in
operator|.
name|readUnsignedShort
argument_list|()
operator|<<
literal|8
operator|)
operator||
name|in
operator|.
name|readUnsignedByte
argument_list|()
return|;
case|case
literal|0
case|:
name|int
name|len
init|=
name|firstByte
operator|+
literal|129
decl_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|4
case|:
return|return
name|in
operator|.
name|readInt
argument_list|()
return|;
case|case
literal|5
case|:
return|return
operator|(
operator|(
name|long
operator|)
name|in
operator|.
name|readInt
argument_list|()
operator|)
operator|<<
literal|8
operator||
name|in
operator|.
name|readUnsignedByte
argument_list|()
return|;
case|case
literal|6
case|:
return|return
operator|(
operator|(
name|long
operator|)
name|in
operator|.
name|readInt
argument_list|()
operator|)
operator|<<
literal|16
operator||
name|in
operator|.
name|readUnsignedShort
argument_list|()
return|;
case|case
literal|7
case|:
return|return
operator|(
operator|(
name|long
operator|)
name|in
operator|.
name|readInt
argument_list|()
operator|)
operator|<<
literal|24
operator||
operator|(
name|in
operator|.
name|readUnsignedShort
argument_list|()
operator|<<
literal|8
operator|)
operator||
name|in
operator|.
name|readUnsignedByte
argument_list|()
return|;
case|case
literal|8
case|:
return|return
name|in
operator|.
name|readLong
argument_list|()
return|;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted VLong encoding"
argument_list|)
throw|;
block|}
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Internal error"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Write a String as a VInt n, followed by n Bytes as in Text format.    *     * @param out    * @param s    * @throws IOException    */
DECL|method|writeString (DataOutput out, String s)
specifier|public
specifier|static
name|void
name|writeString
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|String
name|s
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|Text
name|text
init|=
operator|new
name|Text
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
name|text
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|text
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|writeVInt
argument_list|(
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeVInt
argument_list|(
name|out
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Read a String as a VInt n, followed by n Bytes in Text format.    *     * @param in    *          The input stream.    * @return The string    * @throws IOException    */
DECL|method|readString (DataInput in)
specifier|public
specifier|static
name|String
name|readString
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
return|return
literal|null
return|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|Text
operator|.
name|decode
argument_list|(
name|buffer
argument_list|)
return|;
block|}
comment|/**    * A generic Version class. We suggest applications built on top of TFile use    * this class to maintain version information in their meta blocks.    *     * A version number consists of a major version and a minor version. The    * suggested usage of major and minor version number is to increment major    * version number when the new storage format is not backward compatible, and    * increment the minor version otherwise.    */
DECL|class|Version
specifier|public
specifier|static
specifier|final
class|class
name|Version
implements|implements
name|Comparable
argument_list|<
name|Version
argument_list|>
block|{
DECL|field|major
specifier|private
specifier|final
name|short
name|major
decl_stmt|;
DECL|field|minor
specifier|private
specifier|final
name|short
name|minor
decl_stmt|;
comment|/**      * Construct the Version object by reading from the input stream.      *       * @param in      *          input stream      * @throws IOException      */
DECL|method|Version (DataInput in)
specifier|public
name|Version
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|major
operator|=
name|in
operator|.
name|readShort
argument_list|()
expr_stmt|;
name|minor
operator|=
name|in
operator|.
name|readShort
argument_list|()
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param major      *          major version.      * @param minor      *          minor version.      */
DECL|method|Version (short major, short minor)
specifier|public
name|Version
parameter_list|(
name|short
name|major
parameter_list|,
name|short
name|minor
parameter_list|)
block|{
name|this
operator|.
name|major
operator|=
name|major
expr_stmt|;
name|this
operator|.
name|minor
operator|=
name|minor
expr_stmt|;
block|}
comment|/**      * Write the objec to a DataOutput. The serialized format of the Version is      * major version followed by minor version, both as big-endian short      * integers.      *       * @param out      *          The DataOutput object.      * @throws IOException      */
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeShort
argument_list|(
name|major
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeShort
argument_list|(
name|minor
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the major version.      *       * @return Major version.      */
DECL|method|getMajor ()
specifier|public
name|int
name|getMajor
parameter_list|()
block|{
return|return
name|major
return|;
block|}
comment|/**      * Get the minor version.      *       * @return The minor version.      */
DECL|method|getMinor ()
specifier|public
name|int
name|getMinor
parameter_list|()
block|{
return|return
name|minor
return|;
block|}
comment|/**      * Get the size of the serialized Version object.      *       * @return serialized size of the version object.      */
DECL|method|size ()
specifier|public
specifier|static
name|int
name|size
parameter_list|()
block|{
return|return
operator|(
name|Short
operator|.
name|SIZE
operator|+
name|Short
operator|.
name|SIZE
operator|)
operator|/
name|Byte
operator|.
name|SIZE
return|;
block|}
comment|/**      * Return a string representation of the version.      */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|new
name|StringBuilder
argument_list|(
literal|"v"
argument_list|)
operator|.
name|append
argument_list|(
name|major
argument_list|)
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
operator|.
name|append
argument_list|(
name|minor
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Test compatibility.      *       * @param other      *          The Version object to test compatibility with.      * @return true if both versions have the same major version number; false      *         otherwise.      */
DECL|method|compatibleWith (Version other)
specifier|public
name|boolean
name|compatibleWith
parameter_list|(
name|Version
name|other
parameter_list|)
block|{
return|return
name|major
operator|==
name|other
operator|.
name|major
return|;
block|}
comment|/**      * Compare this version with another version.      */
annotation|@
name|Override
DECL|method|compareTo (Version that)
specifier|public
name|int
name|compareTo
parameter_list|(
name|Version
name|that
parameter_list|)
block|{
if|if
condition|(
name|major
operator|!=
name|that
operator|.
name|major
condition|)
block|{
return|return
name|major
operator|-
name|that
operator|.
name|major
return|;
block|}
return|return
name|minor
operator|-
name|that
operator|.
name|minor
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|other
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|Version
operator|)
condition|)
return|return
literal|false
return|;
return|return
name|compareTo
argument_list|(
operator|(
name|Version
operator|)
name|other
argument_list|)
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|major
operator|<<
literal|16
operator|+
name|minor
operator|)
return|;
block|}
block|}
comment|/**    * Lower bound binary search. Find the index to the first element in the list    * that compares greater than or equal to key.    *     * @param<T>    *          Type of the input key.    * @param list    *          The list    * @param key    *          The input key.    * @param cmp    *          Comparator for the key.    * @return The index to the desired element if it exists; or list.size()    *         otherwise.    */
DECL|method|lowerBound (List<? extends T> list, T key, Comparator<? super T> cmp)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|lowerBound
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list
parameter_list|,
name|T
name|key
parameter_list|,
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
name|cmp
parameter_list|)
block|{
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|low
operator|<
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|T
name|midVal
init|=
name|list
operator|.
name|get
argument_list|(
name|mid
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|cmp
operator|.
name|compare
argument_list|(
name|midVal
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|low
return|;
block|}
comment|/**    * Upper bound binary search. Find the index to the first element in the list    * that compares greater than the input key.    *     * @param<T>    *          Type of the input key.    * @param list    *          The list    * @param key    *          The input key.    * @param cmp    *          Comparator for the key.    * @return The index to the desired element if it exists; or list.size()    *         otherwise.    */
DECL|method|upperBound (List<? extends T> list, T key, Comparator<? super T> cmp)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|upperBound
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|list
parameter_list|,
name|T
name|key
parameter_list|,
name|Comparator
argument_list|<
name|?
super|super
name|T
argument_list|>
name|cmp
parameter_list|)
block|{
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|low
operator|<
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|T
name|midVal
init|=
name|list
operator|.
name|get
argument_list|(
name|mid
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|cmp
operator|.
name|compare
argument_list|(
name|midVal
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|low
return|;
block|}
comment|/**    * Lower bound binary search. Find the index to the first element in the list    * that compares greater than or equal to key.    *     * @param<T>    *          Type of the input key.    * @param list    *          The list    * @param key    *          The input key.    * @return The index to the desired element if it exists; or list.size()    *         otherwise.    */
DECL|method|lowerBound (List<? extends Comparable<? super T>> list, T key)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|lowerBound
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|T
argument_list|>
argument_list|>
name|list
parameter_list|,
name|T
name|key
parameter_list|)
block|{
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|low
operator|<
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|Comparable
argument_list|<
name|?
super|super
name|T
argument_list|>
name|midVal
init|=
name|list
operator|.
name|get
argument_list|(
name|mid
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|midVal
operator|.
name|compareTo
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|low
return|;
block|}
comment|/**    * Upper bound binary search. Find the index to the first element in the list    * that compares greater than the input key.    *     * @param<T>    *          Type of the input key.    * @param list    *          The list    * @param key    *          The input key.    * @return The index to the desired element if it exists; or list.size()    *         otherwise.    */
DECL|method|upperBound (List<? extends Comparable<? super T>> list, T key)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|upperBound
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Comparable
argument_list|<
name|?
super|super
name|T
argument_list|>
argument_list|>
name|list
parameter_list|,
name|T
name|key
parameter_list|)
block|{
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|low
operator|<
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|Comparable
argument_list|<
name|?
super|super
name|T
argument_list|>
name|midVal
init|=
name|list
operator|.
name|get
argument_list|(
name|mid
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|midVal
operator|.
name|compareTo
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|low
return|;
block|}
block|}
end_class

end_unit

