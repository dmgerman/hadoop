begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.net
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/** The class represents a cluster of computer with a tree hierarchical  * network topology.  * For example, a cluster may be consists of many data centers filled   * with racks of computers.  * In a network topology, leaves represent data nodes (computers) and inner  * nodes represent switches/routers that manage traffic in/out of data centers  * or racks.    *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|NetworkTopology
specifier|public
class|class
name|NetworkTopology
block|{
DECL|field|DEFAULT_RACK
specifier|public
specifier|final
specifier|static
name|String
name|DEFAULT_RACK
init|=
literal|"/default-rack"
decl_stmt|;
DECL|field|DEFAULT_HOST_LEVEL
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_HOST_LEVEL
init|=
literal|2
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|NetworkTopology
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|class|InvalidTopologyException
specifier|public
specifier|static
class|class
name|InvalidTopologyException
extends|extends
name|RuntimeException
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|method|InvalidTopologyException (String msg)
specifier|public
name|InvalidTopologyException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get an instance of NetworkTopology based on the value of the configuration    * parameter net.topology.impl.    *     * @param conf the configuration to be used    * @return an instance of NetworkTopology    */
DECL|method|getInstance (Configuration conf)
specifier|public
specifier|static
name|NetworkTopology
name|getInstance
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|NET_TOPOLOGY_IMPL_KEY
argument_list|,
name|NetworkTopology
operator|.
name|class
argument_list|,
name|NetworkTopology
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/** InnerNode represents a switch/router of a data center or rack.    * Different from a leaf node, it has non-null children.    */
DECL|class|InnerNode
specifier|static
class|class
name|InnerNode
extends|extends
name|NodeBase
block|{
DECL|field|children
specifier|protected
name|List
argument_list|<
name|Node
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|numOfLeaves
specifier|private
name|int
name|numOfLeaves
decl_stmt|;
comment|/** Construct an InnerNode from a path-like string */
DECL|method|InnerNode (String path)
name|InnerNode
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|super
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/** Construct an InnerNode from its name and its network location */
DECL|method|InnerNode (String name, String location)
name|InnerNode
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|location
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
comment|/** Construct an InnerNode      * from its name, its network location, its parent, and its level */
DECL|method|InnerNode (String name, String location, InnerNode parent, int level)
name|InnerNode
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|location
parameter_list|,
name|InnerNode
name|parent
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|location
argument_list|,
name|parent
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
comment|/** @return its children */
DECL|method|getChildren ()
name|List
argument_list|<
name|Node
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|children
return|;
block|}
comment|/** @return the number of children this node has */
DECL|method|getNumOfChildren ()
name|int
name|getNumOfChildren
parameter_list|()
block|{
return|return
name|children
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Judge if this node represents a rack       * @return true if it has no child or its children are not InnerNodes      */
DECL|method|isRack ()
name|boolean
name|isRack
parameter_list|()
block|{
if|if
condition|(
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Node
name|firstChild
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChild
operator|instanceof
name|InnerNode
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Judge if this node is an ancestor of node<i>n</i>      *       * @param n a node      * @return true if this node is an ancestor of<i>n</i>      */
DECL|method|isAncestor (Node n)
name|boolean
name|isAncestor
parameter_list|(
name|Node
name|n
parameter_list|)
block|{
return|return
name|getPath
argument_list|(
name|this
argument_list|)
operator|.
name|equals
argument_list|(
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
argument_list|)
operator|||
operator|(
name|n
operator|.
name|getNetworkLocation
argument_list|()
operator|+
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
operator|)
operator|.
name|startsWith
argument_list|(
name|getPath
argument_list|(
name|this
argument_list|)
operator|+
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
argument_list|)
return|;
block|}
comment|/** Judge if this node is the parent of node<i>n</i>      *       * @param n a node      * @return true if this node is the parent of<i>n</i>      */
DECL|method|isParent (Node n)
name|boolean
name|isParent
parameter_list|(
name|Node
name|n
parameter_list|)
block|{
return|return
name|n
operator|.
name|getNetworkLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|getPath
argument_list|(
name|this
argument_list|)
argument_list|)
return|;
block|}
comment|/* Return a child name of this node who is an ancestor of node<i>n</i> */
DECL|method|getNextAncestorName (Node n)
specifier|private
name|String
name|getNextAncestorName
parameter_list|(
name|Node
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isAncestor
argument_list|(
name|n
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|this
operator|+
literal|"is not an ancestor of "
operator|+
name|n
argument_list|)
throw|;
block|}
name|String
name|name
init|=
name|n
operator|.
name|getNetworkLocation
argument_list|()
operator|.
name|substring
argument_list|(
name|getPath
argument_list|(
name|this
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|PATH_SEPARATOR
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|index
init|=
name|name
operator|.
name|indexOf
argument_list|(
name|PATH_SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
comment|/** Add node<i>n</i> to the subtree of this node       * @param n node to be added      * @return true if the node is added; false otherwise      */
DECL|method|add (Node n)
name|boolean
name|add
parameter_list|(
name|Node
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isAncestor
argument_list|(
name|n
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|n
operator|.
name|getName
argument_list|()
operator|+
literal|", which is located at "
operator|+
name|n
operator|.
name|getNetworkLocation
argument_list|()
operator|+
literal|", is not a decendent of "
operator|+
name|getPath
argument_list|(
name|this
argument_list|)
argument_list|)
throw|;
if|if
condition|(
name|isParent
argument_list|(
name|n
argument_list|)
condition|)
block|{
comment|// this node is the parent of n; add n directly
name|n
operator|.
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|n
operator|.
name|setLevel
argument_list|(
name|this
operator|.
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|n
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|children
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|children
operator|.
name|add
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|numOfLeaves
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// find the next ancestor node
name|String
name|parentName
init|=
name|getNextAncestorName
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|InnerNode
name|parentNode
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|parentName
argument_list|)
condition|)
block|{
name|parentNode
operator|=
operator|(
name|InnerNode
operator|)
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|parentNode
operator|==
literal|null
condition|)
block|{
comment|// create a new InnerNode
name|parentNode
operator|=
name|createParentNode
argument_list|(
name|parentName
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|parentNode
argument_list|)
expr_stmt|;
block|}
comment|// add n to the subtree of the next ancestor node
if|if
condition|(
name|parentNode
operator|.
name|add
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|numOfLeaves
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/**      * Creates a parent node to be added to the list of children.        * Creates a node using the InnerNode four argument constructor specifying       * the name, location, parent, and level of this node.      *       *<p>To be overridden in subclasses for specific InnerNode implementations,      * as alternative to overriding the full {@link #add(Node)} method.      *       * @param parentName The name of the parent node      * @return A new inner node      * @see InnerNode#InnerNode(String, String, InnerNode, int)      */
DECL|method|createParentNode (String parentName)
specifier|protected
name|InnerNode
name|createParentNode
parameter_list|(
name|String
name|parentName
parameter_list|)
block|{
return|return
operator|new
name|InnerNode
argument_list|(
name|parentName
argument_list|,
name|getPath
argument_list|(
name|this
argument_list|)
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|getLevel
argument_list|()
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/** Remove node<i>n</i> from the subtree of this node      * @param n node to be deleted       * @return true if the node is deleted; false otherwise      */
DECL|method|remove (Node n)
name|boolean
name|remove
parameter_list|(
name|Node
name|n
parameter_list|)
block|{
name|String
name|parent
init|=
name|n
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
name|String
name|currentPath
init|=
name|getPath
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isAncestor
argument_list|(
name|n
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|n
operator|.
name|getName
argument_list|()
operator|+
literal|", which is located at "
operator|+
name|parent
operator|+
literal|", is not a descendent of "
operator|+
name|currentPath
argument_list|)
throw|;
if|if
condition|(
name|isParent
argument_list|(
name|n
argument_list|)
condition|)
block|{
comment|// this node is the parent of n; remove n directly
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|n
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|children
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|numOfLeaves
operator|--
expr_stmt|;
name|n
operator|.
name|setParent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// find the next ancestor node: the parent node
name|String
name|parentName
init|=
name|getNextAncestorName
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|InnerNode
name|parentNode
init|=
literal|null
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|parentName
argument_list|)
condition|)
block|{
name|parentNode
operator|=
operator|(
name|InnerNode
operator|)
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|parentNode
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// remove n from the parent node
name|boolean
name|isRemoved
init|=
name|parentNode
operator|.
name|remove
argument_list|(
name|n
argument_list|)
decl_stmt|;
comment|// if the parent node has no children, remove the parent node too
if|if
condition|(
name|isRemoved
condition|)
block|{
if|if
condition|(
name|parentNode
operator|.
name|getNumOfChildren
argument_list|()
operator|==
literal|0
condition|)
block|{
name|children
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|numOfLeaves
operator|--
expr_stmt|;
block|}
return|return
name|isRemoved
return|;
block|}
block|}
comment|// end of remove
comment|/** Given a node's string representation, return a reference to the node      * @param loc string location of the form /rack/node      * @return null if the node is not found or the childnode is there but      * not an instance of {@link InnerNode}      */
DECL|method|getLoc (String loc)
specifier|private
name|Node
name|getLoc
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
if|if
condition|(
name|loc
operator|==
literal|null
operator|||
name|loc
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|this
return|;
name|String
index|[]
name|path
init|=
name|loc
operator|.
name|split
argument_list|(
name|PATH_SEPARATOR_STR
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|Node
name|childnode
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|childnode
operator|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|childnode
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// non-existing node
if|if
condition|(
name|path
operator|.
name|length
operator|==
literal|1
condition|)
return|return
name|childnode
return|;
if|if
condition|(
name|childnode
operator|instanceof
name|InnerNode
condition|)
block|{
return|return
operator|(
operator|(
name|InnerNode
operator|)
name|childnode
operator|)
operator|.
name|getLoc
argument_list|(
name|path
index|[
literal|1
index|]
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** get<i>leafIndex</i> leaf of this subtree       * if it is not in the<i>excludedNode</i>      *      * @param leafIndex an indexed leaf of the node      * @param excludedNode an excluded node (can be null)      * @return      */
DECL|method|getLeaf (int leafIndex, Node excludedNode)
name|Node
name|getLeaf
parameter_list|(
name|int
name|leafIndex
parameter_list|,
name|Node
name|excludedNode
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|// check if the excluded node a leaf
name|boolean
name|isLeaf
init|=
name|excludedNode
operator|==
literal|null
operator|||
operator|!
operator|(
name|excludedNode
operator|instanceof
name|InnerNode
operator|)
decl_stmt|;
comment|// calculate the total number of excluded leaf nodes
name|int
name|numOfExcludedLeaves
init|=
name|isLeaf
condition|?
literal|1
else|:
operator|(
operator|(
name|InnerNode
operator|)
name|excludedNode
operator|)
operator|.
name|getNumOfLeaves
argument_list|()
decl_stmt|;
if|if
condition|(
name|isLeafParent
argument_list|()
condition|)
block|{
comment|// children are leaves
if|if
condition|(
name|isLeaf
condition|)
block|{
comment|// excluded node is a leaf node
name|int
name|excludedIndex
init|=
name|children
operator|.
name|indexOf
argument_list|(
name|excludedNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|excludedIndex
operator|!=
operator|-
literal|1
operator|&&
name|leafIndex
operator|>=
literal|0
condition|)
block|{
comment|// excluded node is one of the children so adjust the leaf index
name|leafIndex
operator|=
name|leafIndex
operator|>=
name|excludedIndex
condition|?
name|leafIndex
operator|+
literal|1
else|:
name|leafIndex
expr_stmt|;
block|}
block|}
comment|// range check
if|if
condition|(
name|leafIndex
operator|<
literal|0
operator|||
name|leafIndex
operator|>=
name|this
operator|.
name|getNumOfChildren
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|children
operator|.
name|get
argument_list|(
name|leafIndex
argument_list|)
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|InnerNode
name|child
init|=
operator|(
name|InnerNode
operator|)
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|excludedNode
operator|==
literal|null
operator|||
name|excludedNode
operator|!=
name|child
condition|)
block|{
comment|// not the excludedNode
name|int
name|numOfLeaves
init|=
name|child
operator|.
name|getNumOfLeaves
argument_list|()
decl_stmt|;
if|if
condition|(
name|excludedNode
operator|!=
literal|null
operator|&&
name|child
operator|.
name|isAncestor
argument_list|(
name|excludedNode
argument_list|)
condition|)
block|{
name|numOfLeaves
operator|-=
name|numOfExcludedLeaves
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|+
name|numOfLeaves
operator|>
name|leafIndex
condition|)
block|{
comment|// the leaf is in the child subtree
return|return
name|child
operator|.
name|getLeaf
argument_list|(
name|leafIndex
operator|-
name|count
argument_list|,
name|excludedNode
argument_list|)
return|;
block|}
else|else
block|{
comment|// go to the next child
name|count
operator|=
name|count
operator|+
name|numOfLeaves
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// it is the excluededNode
comment|// skip it and set the excludedNode to be null
name|excludedNode
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
DECL|method|isLeafParent ()
specifier|protected
name|boolean
name|isLeafParent
parameter_list|()
block|{
return|return
name|isRack
argument_list|()
return|;
block|}
comment|/**       * Determine if children a leaves, default implementation calls {@link #isRack()}       *<p>To be overridden in subclasses for specific InnerNode implementations,       * as alternative to overriding the full {@link #getLeaf(int, Node)} method.       *        * @return true if children are leaves, false otherwise       */
DECL|method|areChildrenLeaves ()
specifier|protected
name|boolean
name|areChildrenLeaves
parameter_list|()
block|{
return|return
name|isRack
argument_list|()
return|;
block|}
comment|/**      * Get number of leaves.      */
DECL|method|getNumOfLeaves ()
name|int
name|getNumOfLeaves
parameter_list|()
block|{
return|return
name|numOfLeaves
return|;
block|}
block|}
comment|// end of InnerNode
comment|/**    * the root cluster map    */
DECL|field|clusterMap
name|InnerNode
name|clusterMap
decl_stmt|;
comment|/** Depth of all leaf nodes */
DECL|field|depthOfAllLeaves
specifier|private
name|int
name|depthOfAllLeaves
init|=
operator|-
literal|1
decl_stmt|;
comment|/** rack counter */
DECL|field|numOfRacks
specifier|protected
name|int
name|numOfRacks
init|=
literal|0
decl_stmt|;
comment|/** the lock used to manage access */
DECL|field|netlock
specifier|protected
name|ReadWriteLock
name|netlock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
DECL|method|NetworkTopology ()
specifier|public
name|NetworkTopology
parameter_list|()
block|{
name|clusterMap
operator|=
operator|new
name|InnerNode
argument_list|(
name|InnerNode
operator|.
name|ROOT
argument_list|)
expr_stmt|;
block|}
comment|/** Add a leaf node    * Update node counter& rack counter if necessary    * @param node node to be added; can be null    * @exception IllegalArgumentException if add a node to a leave                                           or node to be added is not a leaf    */
DECL|method|add (Node node)
specifier|public
name|void
name|add
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return;
name|String
name|oldTopoStr
init|=
name|this
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|InnerNode
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Not allow to add an inner node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|newDepth
init|=
name|NodeBase
operator|.
name|locationToDepth
argument_list|(
name|node
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
operator|+
literal|1
decl_stmt|;
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|depthOfAllLeaves
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|depthOfAllLeaves
operator|!=
name|newDepth
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error: can't add leaf node "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
operator|+
literal|" at depth "
operator|+
name|newDepth
operator|+
literal|" to topology:\n"
operator|+
name|oldTopoStr
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InvalidTopologyException
argument_list|(
literal|"Failed to add "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
operator|+
literal|": You cannot have a rack and a non-rack node at the same "
operator|+
literal|"level of the network topology."
argument_list|)
throw|;
block|}
name|Node
name|rack
init|=
name|getNodeForNetworkLocation
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|rack
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|rack
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected data node "
operator|+
name|node
operator|.
name|toString
argument_list|()
operator|+
literal|" at an illegal network location"
argument_list|)
throw|;
block|}
if|if
condition|(
name|clusterMap
operator|.
name|add
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding a new node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rack
operator|==
literal|null
condition|)
block|{
name|numOfRacks
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
if|if
condition|(
name|depthOfAllLeaves
operator|==
operator|-
literal|1
condition|)
block|{
name|depthOfAllLeaves
operator|=
name|node
operator|.
name|getLevel
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"NetworkTopology became:\n"
operator|+
name|this
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return a reference to the node given its string representation.    * Default implementation delegates to {@link #getNode(String)}.    *     *<p>To be overridden in subclasses for specific NetworkTopology     * implementations, as alternative to overriding the full {@link #add(Node)}    *  method.    *     * @param node The string representation of this node's network location is    * used to retrieve a Node object.     * @return a reference to the node; null if the node is not in the tree    *     * @see #add(Node)    * @see #getNode(String)    */
DECL|method|getNodeForNetworkLocation (Node node)
specifier|protected
name|Node
name|getNodeForNetworkLocation
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|node
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Given a string representation of a rack, return its children    * @param loc a path-like string representation of a rack    * @return a newly allocated list with all the node's children    */
DECL|method|getDatanodesInRack (String loc)
specifier|public
name|List
argument_list|<
name|Node
argument_list|>
name|getDatanodesInRack
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|loc
operator|=
name|NodeBase
operator|.
name|normalize
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NodeBase
operator|.
name|ROOT
operator|.
name|equals
argument_list|(
name|loc
argument_list|)
condition|)
block|{
name|loc
operator|=
name|loc
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|InnerNode
name|rack
init|=
operator|(
name|InnerNode
operator|)
name|clusterMap
operator|.
name|getLoc
argument_list|(
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|rack
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|(
name|rack
operator|.
name|getChildren
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Remove a node    * Update node counter and rack counter if necessary    * @param node node to be removed; can be null    */
DECL|method|remove (Node node)
specifier|public
name|void
name|remove
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return;
if|if
condition|(
name|node
operator|instanceof
name|InnerNode
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Not allow to remove an inner node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing a node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|clusterMap
operator|.
name|remove
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|InnerNode
name|rack
init|=
operator|(
name|InnerNode
operator|)
name|getNode
argument_list|(
name|node
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rack
operator|==
literal|null
condition|)
block|{
name|numOfRacks
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"NetworkTopology became:\n"
operator|+
name|this
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Check if the tree contains node<i>node</i>    *     * @param node a node    * @return true if<i>node</i> is already in the tree; false otherwise    */
DECL|method|contains (Node node)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Node
name|parent
init|=
name|node
operator|.
name|getParent
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
name|node
operator|.
name|getLevel
argument_list|()
init|;
name|parent
operator|!=
literal|null
operator|&&
name|level
operator|>
literal|0
condition|;
name|parent
operator|=
name|parent
operator|.
name|getParent
argument_list|()
operator|,
name|level
operator|--
control|)
block|{
if|if
condition|(
name|parent
operator|==
name|clusterMap
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Given a string representation of a node, return its reference    *     * @param loc    *          a path-like string representation of a node    * @return a reference to the node; null if the node is not in the tree    */
DECL|method|getNode (String loc)
specifier|public
name|Node
name|getNode
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|loc
operator|=
name|NodeBase
operator|.
name|normalize
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NodeBase
operator|.
name|ROOT
operator|.
name|equals
argument_list|(
name|loc
argument_list|)
condition|)
name|loc
operator|=
name|loc
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|clusterMap
operator|.
name|getLoc
argument_list|(
name|loc
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Given a string representation of a rack for a specific network    *  location    *     * To be overridden in subclasses for specific NetworkTopology     * implementations, as alternative to overriding the full     * {@link #getRack(String)} method.    * @param loc    *          a path-like string representation of a network location    * @return a rack string    */
DECL|method|getRack (String loc)
specifier|public
name|String
name|getRack
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
return|return
name|loc
return|;
block|}
comment|/** @return the total number of racks */
DECL|method|getNumOfRacks ()
specifier|public
name|int
name|getNumOfRacks
parameter_list|()
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|numOfRacks
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** @return the total number of leaf nodes */
DECL|method|getNumOfLeaves ()
specifier|public
name|int
name|getNumOfLeaves
parameter_list|()
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|clusterMap
operator|.
name|getNumOfLeaves
argument_list|()
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Return the distance between two nodes    * It is assumed that the distance from one node to its parent is 1    * The distance between two nodes is calculated by summing up their distances    * to their closest common ancestor.    * @param node1 one node    * @param node2 another node    * @return the distance between node1 and node2 which is zero if they are the same    *  or {@link Integer#MAX_VALUE} if node1 or node2 do not belong to the cluster    */
DECL|method|getDistance (Node node1, Node node2)
specifier|public
name|int
name|getDistance
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
if|if
condition|(
name|node1
operator|==
name|node2
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Node
name|n1
init|=
name|node1
decl_stmt|,
name|n2
init|=
name|node2
decl_stmt|;
name|int
name|dis
init|=
literal|0
decl_stmt|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|level1
init|=
name|node1
operator|.
name|getLevel
argument_list|()
decl_stmt|,
name|level2
init|=
name|node2
operator|.
name|getLevel
argument_list|()
decl_stmt|;
while|while
condition|(
name|n1
operator|!=
literal|null
operator|&&
name|level1
operator|>
name|level2
condition|)
block|{
name|n1
operator|=
name|n1
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|level1
operator|--
expr_stmt|;
name|dis
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|n2
operator|!=
literal|null
operator|&&
name|level2
operator|>
name|level1
condition|)
block|{
name|n2
operator|=
name|n2
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|level2
operator|--
expr_stmt|;
name|dis
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|n1
operator|!=
literal|null
operator|&&
name|n2
operator|!=
literal|null
operator|&&
name|n1
operator|.
name|getParent
argument_list|()
operator|!=
name|n2
operator|.
name|getParent
argument_list|()
condition|)
block|{
name|n1
operator|=
name|n1
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|n2
operator|=
name|n2
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|dis
operator|+=
literal|2
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|n1
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The cluster does not contain node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
if|if
condition|(
name|n2
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The cluster does not contain node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
return|return
name|dis
operator|+
literal|2
return|;
block|}
comment|/** Check if two nodes are on the same rack    * @param node1 one node (can be null)    * @param node2 another node (can be null)    * @return true if node1 and node2 are on the same rack; false otherwise    * @exception IllegalArgumentException when either node1 or node2 is null, or    * node1 or node2 do not belong to the cluster    */
DECL|method|isOnSameRack ( Node node1, Node node2)
specifier|public
name|boolean
name|isOnSameRack
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
if|if
condition|(
name|node1
operator|==
literal|null
operator|||
name|node2
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|isSameParents
argument_list|(
name|node1
argument_list|,
name|node2
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check if network topology is aware of NodeGroup    */
DECL|method|isNodeGroupAware ()
specifier|public
name|boolean
name|isNodeGroupAware
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**     * Return false directly as not aware of NodeGroup, to be override in sub-class    */
DECL|method|isOnSameNodeGroup (Node node1, Node node2)
specifier|public
name|boolean
name|isOnSameNodeGroup
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Compare the parents of each node for equality    *     *<p>To be overridden in subclasses for specific NetworkTopology     * implementations, as alternative to overriding the full     * {@link #isOnSameRack(Node, Node)} method.    *     * @param node1 the first node to compare    * @param node2 the second node to compare    * @return true if their parents are equal, false otherwise    *     * @see #isOnSameRack(Node, Node)    */
DECL|method|isSameParents (Node node1, Node node2)
specifier|protected
name|boolean
name|isSameParents
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
return|return
name|node1
operator|.
name|getParent
argument_list|()
operator|==
name|node2
operator|.
name|getParent
argument_list|()
return|;
block|}
DECL|field|r
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Random
argument_list|>
name|r
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Random
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Getter for thread-local Random, which provides better performance than    * a shared Random (even though Random is thread-safe).    *    * @return Thread-local Random.    */
DECL|method|getRandom ()
specifier|protected
name|Random
name|getRandom
parameter_list|()
block|{
name|Random
name|rand
init|=
name|r
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|rand
operator|==
literal|null
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
name|r
operator|.
name|set
argument_list|(
name|rand
argument_list|)
expr_stmt|;
block|}
return|return
name|rand
return|;
block|}
comment|/** randomly choose one node from<i>scope</i>    * if scope starts with ~, choose one from the all nodes except for the    * ones in<i>scope</i>; otherwise, choose one from<i>scope</i>    * @param scope range of nodes from which a node will be chosen    * @return the chosen node    */
DECL|method|chooseRandom (String scope)
specifier|public
name|Node
name|chooseRandom
parameter_list|(
name|String
name|scope
parameter_list|)
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
literal|"~"
argument_list|)
condition|)
block|{
return|return
name|chooseRandom
argument_list|(
name|NodeBase
operator|.
name|ROOT
argument_list|,
name|scope
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|chooseRandom
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|chooseRandom (String scope, String excludedScope)
specifier|private
name|Node
name|chooseRandom
parameter_list|(
name|String
name|scope
parameter_list|,
name|String
name|excludedScope
parameter_list|)
block|{
if|if
condition|(
name|excludedScope
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
name|excludedScope
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|excludedScope
operator|.
name|startsWith
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|excludedScope
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|Node
name|node
init|=
name|getNode
argument_list|(
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
return|return
name|node
return|;
block|}
name|InnerNode
name|innerNode
init|=
operator|(
name|InnerNode
operator|)
name|node
decl_stmt|;
name|int
name|numOfDatanodes
init|=
name|innerNode
operator|.
name|getNumOfLeaves
argument_list|()
decl_stmt|;
if|if
condition|(
name|excludedScope
operator|==
literal|null
condition|)
block|{
name|node
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|getNode
argument_list|(
name|excludedScope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
name|numOfDatanodes
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|numOfDatanodes
operator|-=
operator|(
operator|(
name|InnerNode
operator|)
name|node
operator|)
operator|.
name|getNumOfLeaves
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numOfDatanodes
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|InvalidTopologyException
argument_list|(
literal|"Failed to find datanode (scope=\""
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|scope
argument_list|)
operator|+
literal|"\" excludedScope=\""
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|excludedScope
argument_list|)
operator|+
literal|"\")."
argument_list|)
throw|;
block|}
name|int
name|leaveIndex
init|=
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|numOfDatanodes
argument_list|)
decl_stmt|;
return|return
name|innerNode
operator|.
name|getLeaf
argument_list|(
name|leaveIndex
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** return leaves in<i>scope</i>    * @param scope a path string    * @return leaves nodes under specific scope    */
DECL|method|getLeaves (String scope)
specifier|public
name|List
argument_list|<
name|Node
argument_list|>
name|getLeaves
parameter_list|(
name|String
name|scope
parameter_list|)
block|{
name|Node
name|node
init|=
name|getNode
argument_list|(
name|scope
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|leafNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
name|leafNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|InnerNode
name|innerNode
init|=
operator|(
name|InnerNode
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|innerNode
operator|.
name|getNumOfLeaves
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|leafNodes
operator|.
name|add
argument_list|(
name|innerNode
operator|.
name|getLeaf
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|leafNodes
return|;
block|}
comment|/** return the number of leaves in<i>scope</i> but not in<i>excludedNodes</i>    * if scope starts with ~, return the number of nodes that are not    * in<i>scope</i> and<i>excludedNodes</i>;     * @param scope a path string that may start with ~    * @param excludedNodes a list of nodes    * @return number of available nodes    */
DECL|method|countNumOfAvailableNodes (String scope, Collection<Node> excludedNodes)
specifier|public
name|int
name|countNumOfAvailableNodes
parameter_list|(
name|String
name|scope
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
block|{
name|boolean
name|isExcluded
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
literal|"~"
argument_list|)
condition|)
block|{
name|isExcluded
operator|=
literal|true
expr_stmt|;
name|scope
operator|=
name|scope
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|scope
operator|=
name|NodeBase
operator|.
name|normalize
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|// the number of nodes in both scope& excludedNodes
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Node
name|node
range|:
name|excludedNodes
control|)
block|{
if|if
condition|(
operator|(
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
operator|+
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
operator|)
operator|.
name|startsWith
argument_list|(
name|scope
operator|+
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
name|Node
name|n
init|=
name|getNode
argument_list|(
name|scope
argument_list|)
decl_stmt|;
name|int
name|scopeNodeCount
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|instanceof
name|InnerNode
condition|)
block|{
name|scopeNodeCount
operator|=
operator|(
operator|(
name|InnerNode
operator|)
name|n
operator|)
operator|.
name|getNumOfLeaves
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isExcluded
condition|)
block|{
return|return
name|clusterMap
operator|.
name|getNumOfLeaves
argument_list|()
operator|-
name|scopeNodeCount
operator|-
name|excludedNodes
operator|.
name|size
argument_list|()
operator|+
name|count
return|;
block|}
else|else
block|{
return|return
name|scopeNodeCount
operator|-
name|count
return|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** convert a network tree to a string */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// print the number of racks
name|StringBuilder
name|tree
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"Number of racks: "
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
name|numOfRacks
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// print the number of leaves
name|int
name|numOfLeaves
init|=
name|getNumOfLeaves
argument_list|()
decl_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"Expected number of leaves:"
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
name|numOfLeaves
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// print nodes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfLeaves
condition|;
name|i
operator|++
control|)
block|{
name|tree
operator|.
name|append
argument_list|(
name|NodeBase
operator|.
name|getPath
argument_list|(
name|clusterMap
operator|.
name|getLeaf
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|tree
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Divide networklocation string into two parts by last separator, and get     * the first part here.    *     * @param networkLocation    * @return    */
DECL|method|getFirstHalf (String networkLocation)
specifier|public
specifier|static
name|String
name|getFirstHalf
parameter_list|(
name|String
name|networkLocation
parameter_list|)
block|{
name|int
name|index
init|=
name|networkLocation
operator|.
name|lastIndexOf
argument_list|(
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
argument_list|)
decl_stmt|;
return|return
name|networkLocation
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/**    * Divide networklocation string into two parts by last separator, and get     * the second part here.    *     * @param networkLocation    * @return    */
DECL|method|getLastHalf (String networkLocation)
specifier|public
specifier|static
name|String
name|getLastHalf
parameter_list|(
name|String
name|networkLocation
parameter_list|)
block|{
name|int
name|index
init|=
name|networkLocation
operator|.
name|lastIndexOf
argument_list|(
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
argument_list|)
decl_stmt|;
return|return
name|networkLocation
operator|.
name|substring
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/**    * Returns an integer weight which specifies how far away {node} is away from    * {reader}. A lower value signifies that a node is closer.    *     * @param reader Node where data will be read    * @param node Replica of data    * @return weight    */
DECL|method|getWeight (Node reader, Node node)
specifier|protected
name|int
name|getWeight
parameter_list|(
name|Node
name|reader
parameter_list|,
name|Node
name|node
parameter_list|)
block|{
comment|// 0 is local, 1 is same rack, 2 is off rack
comment|// Start off by initializing to off rack
name|int
name|weight
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|reader
operator|==
name|node
condition|)
block|{
name|weight
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isOnSameRack
argument_list|(
name|reader
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|weight
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|weight
return|;
block|}
comment|/**    * Sort nodes array by network distance to<i>reader</i>.    *<p/>    * In a three-level topology, a node can be either local, on the same rack, or    * on a different rack from the reader. Sorting the nodes based on network    * distance from the reader reduces network traffic and improves performance.    *<p/>    * As an additional twist, we also randomize the nodes at each network    * distance using the provided random seed. This helps with load balancing    * when there is data skew.    *     * @param reader Node where data will be read    * @param nodes Available replicas with the requested data    * @param seed Used to seed the pseudo-random generator that randomizes the    *          set of nodes at each network distance.    */
DECL|method|sortByDistance (Node reader, Node[] nodes, int activeLen, long seed, boolean randomizeBlockLocationsPerBlock)
specifier|public
name|void
name|sortByDistance
parameter_list|(
name|Node
name|reader
parameter_list|,
name|Node
index|[]
name|nodes
parameter_list|,
name|int
name|activeLen
parameter_list|,
name|long
name|seed
parameter_list|,
name|boolean
name|randomizeBlockLocationsPerBlock
parameter_list|)
block|{
comment|/** Sort weights for the nodes array */
name|int
index|[]
name|weights
init|=
operator|new
name|int
index|[
name|activeLen
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|activeLen
condition|;
name|i
operator|++
control|)
block|{
name|weights
index|[
name|i
index|]
operator|=
name|getWeight
argument_list|(
name|reader
argument_list|,
name|nodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Add weight/node pairs to a TreeMap to sort
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Node
argument_list|>
argument_list|>
name|tree
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Node
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|activeLen
condition|;
name|i
operator|++
control|)
block|{
name|int
name|weight
init|=
name|weights
index|[
name|i
index|]
decl_stmt|;
name|Node
name|node
init|=
name|nodes
index|[
name|i
index|]
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|list
init|=
name|tree
operator|.
name|get
argument_list|(
name|weight
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
name|Lists
operator|.
name|newArrayListWithExpectedSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tree
operator|.
name|put
argument_list|(
name|weight
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|// Seed is normally the block id
comment|// This means we use the same pseudo-random order for each block, for
comment|// potentially better page cache usage.
comment|// Seed is not used if we want to randomize block location for every block
name|Random
name|rand
init|=
name|getRandom
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|randomizeBlockLocationsPerBlock
condition|)
block|{
name|rand
operator|.
name|setSeed
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Node
argument_list|>
name|list
range|:
name|tree
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
name|Collections
operator|.
name|shuffle
argument_list|(
name|list
argument_list|,
name|rand
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|n
range|:
name|list
control|)
block|{
name|nodes
index|[
name|idx
index|]
operator|=
name|n
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
name|idx
operator|==
name|activeLen
argument_list|,
literal|"Sorted the wrong number of nodes!"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

