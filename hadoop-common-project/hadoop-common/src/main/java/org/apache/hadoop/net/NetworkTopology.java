begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.net
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_comment
comment|/** The class represents a cluster of computer with a tree hierarchical  * network topology.  * For example, a cluster may be consists of many data centers filled   * with racks of computers.  * In a network topology, leaves represent data nodes (computers) and inner  * nodes represent switches/routers that manage traffic in/out of data centers  * or racks.    *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|NetworkTopology
specifier|public
class|class
name|NetworkTopology
block|{
DECL|field|DEFAULT_RACK
specifier|public
specifier|final
specifier|static
name|String
name|DEFAULT_RACK
init|=
literal|"/default-rack"
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NetworkTopology
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|PATH_SEPARATOR
specifier|private
specifier|static
specifier|final
name|char
name|PATH_SEPARATOR
init|=
literal|'/'
decl_stmt|;
DECL|field|PATH_SEPARATOR_STR
specifier|private
specifier|static
specifier|final
name|String
name|PATH_SEPARATOR_STR
init|=
literal|"/"
decl_stmt|;
DECL|field|ROOT
specifier|private
specifier|static
specifier|final
name|String
name|ROOT
init|=
literal|"/"
decl_stmt|;
DECL|class|InvalidTopologyException
specifier|public
specifier|static
class|class
name|InvalidTopologyException
extends|extends
name|RuntimeException
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|method|InvalidTopologyException (String msg)
specifier|public
name|InvalidTopologyException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get an instance of NetworkTopology based on the value of the configuration    * parameter net.topology.impl.    *     * @param conf the configuration to be used    * @return an instance of NetworkTopology    */
DECL|method|getInstance (Configuration conf)
specifier|public
specifier|static
name|NetworkTopology
name|getInstance
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getInstance
argument_list|(
name|conf
argument_list|,
name|InnerNodeImpl
operator|.
name|FACTORY
argument_list|)
return|;
block|}
DECL|method|getInstance (Configuration conf, InnerNode.Factory factory)
specifier|public
specifier|static
name|NetworkTopology
name|getInstance
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|InnerNode
operator|.
name|Factory
name|factory
parameter_list|)
block|{
name|NetworkTopology
name|nt
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|NET_TOPOLOGY_IMPL_KEY
argument_list|,
name|NetworkTopology
operator|.
name|class
argument_list|,
name|NetworkTopology
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
return|return
name|nt
operator|.
name|init
argument_list|(
name|factory
argument_list|)
return|;
block|}
DECL|method|init (InnerNode.Factory factory)
specifier|protected
name|NetworkTopology
name|init
parameter_list|(
name|InnerNode
operator|.
name|Factory
name|factory
parameter_list|)
block|{
if|if
condition|(
operator|!
name|factory
operator|.
name|equals
argument_list|(
name|this
operator|.
name|factory
argument_list|)
condition|)
block|{
comment|// the constructor has initialized the factory to default. So only init
comment|// again if another factory is specified.
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|clusterMap
operator|=
name|factory
operator|.
name|newInnerNode
argument_list|(
name|NodeBase
operator|.
name|ROOT
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|field|factory
name|InnerNode
operator|.
name|Factory
name|factory
decl_stmt|;
comment|/**    * the root cluster map    */
DECL|field|clusterMap
name|InnerNode
name|clusterMap
decl_stmt|;
comment|/** Depth of all leaf nodes */
DECL|field|depthOfAllLeaves
specifier|private
name|int
name|depthOfAllLeaves
init|=
operator|-
literal|1
decl_stmt|;
comment|/** rack counter */
DECL|field|numOfRacks
specifier|protected
name|int
name|numOfRacks
init|=
literal|0
decl_stmt|;
comment|/**    * Whether or not this cluster has ever consisted of more than 1 rack,    * according to the NetworkTopology.    */
DECL|field|clusterEverBeenMultiRack
specifier|private
name|boolean
name|clusterEverBeenMultiRack
init|=
literal|false
decl_stmt|;
comment|/** the lock used to manage access */
DECL|field|netlock
specifier|protected
name|ReadWriteLock
name|netlock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// keeping the constructor because other components like MR still uses this.
DECL|method|NetworkTopology ()
specifier|public
name|NetworkTopology
parameter_list|()
block|{
name|this
operator|.
name|factory
operator|=
name|InnerNodeImpl
operator|.
name|FACTORY
expr_stmt|;
name|this
operator|.
name|clusterMap
operator|=
name|factory
operator|.
name|newInnerNode
argument_list|(
name|NodeBase
operator|.
name|ROOT
argument_list|)
expr_stmt|;
block|}
comment|/** Add a leaf node    * Update node counter&amp; rack counter if necessary    * @param node node to be added; can be null    * @exception IllegalArgumentException if add a node to a leave                                           or node to be added is not a leaf    */
DECL|method|add (Node node)
specifier|public
name|void
name|add
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return;
name|int
name|newDepth
init|=
name|NodeBase
operator|.
name|locationToDepth
argument_list|(
name|node
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
operator|+
literal|1
decl_stmt|;
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|node
operator|instanceof
name|InnerNode
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Not allow to add an inner node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|depthOfAllLeaves
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|depthOfAllLeaves
operator|!=
name|newDepth
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error: can't add leaf node {} at depth {} to topology:{}\n"
argument_list|,
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|,
name|newDepth
argument_list|,
name|this
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InvalidTopologyException
argument_list|(
literal|"Failed to add "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
operator|+
literal|": You cannot have a rack and a non-rack node at the same "
operator|+
literal|"level of the network topology."
argument_list|)
throw|;
block|}
name|Node
name|rack
init|=
name|getNodeForNetworkLocation
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|rack
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|rack
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected data node "
operator|+
name|node
operator|.
name|toString
argument_list|()
operator|+
literal|" at an illegal network location"
argument_list|)
throw|;
block|}
if|if
condition|(
name|clusterMap
operator|.
name|add
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding a new node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rack
operator|==
literal|null
condition|)
block|{
name|incrementRacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
if|if
condition|(
name|depthOfAllLeaves
operator|==
operator|-
literal|1
condition|)
block|{
name|depthOfAllLeaves
operator|=
name|node
operator|.
name|getLevel
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"NetworkTopology became:\n{}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|incrementRacks ()
specifier|protected
name|void
name|incrementRacks
parameter_list|()
block|{
name|numOfRacks
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|clusterEverBeenMultiRack
operator|&&
name|numOfRacks
operator|>
literal|1
condition|)
block|{
name|clusterEverBeenMultiRack
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**    * Return a reference to the node given its string representation.    * Default implementation delegates to {@link #getNode(String)}.    *     *<p>To be overridden in subclasses for specific NetworkTopology     * implementations, as alternative to overriding the full {@link #add(Node)}    *  method.    *     * @param node The string representation of this node's network location is    * used to retrieve a Node object.     * @return a reference to the node; null if the node is not in the tree    *     * @see #add(Node)    * @see #getNode(String)    */
DECL|method|getNodeForNetworkLocation (Node node)
specifier|protected
name|Node
name|getNodeForNetworkLocation
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
return|return
name|getNode
argument_list|(
name|node
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Given a string representation of a rack, return its children    * @param loc a path-like string representation of a rack    * @return a newly allocated list with all the node's children    */
DECL|method|getDatanodesInRack (String loc)
specifier|public
name|List
argument_list|<
name|Node
argument_list|>
name|getDatanodesInRack
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|loc
operator|=
name|NodeBase
operator|.
name|normalize
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NodeBase
operator|.
name|ROOT
operator|.
name|equals
argument_list|(
name|loc
argument_list|)
condition|)
block|{
name|loc
operator|=
name|loc
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|InnerNode
name|rack
init|=
operator|(
name|InnerNode
operator|)
name|clusterMap
operator|.
name|getLoc
argument_list|(
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|rack
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|(
name|rack
operator|.
name|getChildren
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Remove a node    * Update node counter and rack counter if necessary    * @param node node to be removed; can be null    */
DECL|method|remove (Node node)
specifier|public
name|void
name|remove
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return;
if|if
condition|(
name|node
operator|instanceof
name|InnerNode
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Not allow to remove an inner node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing a node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|clusterMap
operator|.
name|remove
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|InnerNode
name|rack
init|=
operator|(
name|InnerNode
operator|)
name|getNode
argument_list|(
name|node
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rack
operator|==
literal|null
condition|)
block|{
name|numOfRacks
operator|--
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"NetworkTopology became:\n{}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Check if the tree contains node<i>node</i>    *     * @param node a node    * @return true if<i>node</i> is already in the tree; false otherwise    */
DECL|method|contains (Node node)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Node
name|parent
init|=
name|node
operator|.
name|getParent
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
name|node
operator|.
name|getLevel
argument_list|()
init|;
name|parent
operator|!=
literal|null
operator|&&
name|level
operator|>
literal|0
condition|;
name|parent
operator|=
name|parent
operator|.
name|getParent
argument_list|()
operator|,
name|level
operator|--
control|)
block|{
if|if
condition|(
name|parent
operator|==
name|clusterMap
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Given a string representation of a node, return its reference    *     * @param loc    *          a path-like string representation of a node    * @return a reference to the node; null if the node is not in the tree    */
DECL|method|getNode (String loc)
specifier|public
name|Node
name|getNode
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|loc
operator|=
name|NodeBase
operator|.
name|normalize
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NodeBase
operator|.
name|ROOT
operator|.
name|equals
argument_list|(
name|loc
argument_list|)
condition|)
name|loc
operator|=
name|loc
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|clusterMap
operator|.
name|getLoc
argument_list|(
name|loc
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @return true if this cluster has ever consisted of multiple racks, even if    *         it is not now a multi-rack cluster.    */
DECL|method|hasClusterEverBeenMultiRack ()
specifier|public
name|boolean
name|hasClusterEverBeenMultiRack
parameter_list|()
block|{
return|return
name|clusterEverBeenMultiRack
return|;
block|}
comment|/** Given a string representation of a rack for a specific network    *  location    *    * To be overridden in subclasses for specific NetworkTopology     * implementations, as alternative to overriding the full     * {@link #getRack(String)} method.    * @param loc    *          a path-like string representation of a network location    * @return a rack string    */
DECL|method|getRack (String loc)
specifier|public
name|String
name|getRack
parameter_list|(
name|String
name|loc
parameter_list|)
block|{
return|return
name|loc
return|;
block|}
comment|/** @return the total number of racks */
DECL|method|getNumOfRacks ()
specifier|public
name|int
name|getNumOfRacks
parameter_list|()
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|numOfRacks
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** @return the total number of leaf nodes */
DECL|method|getNumOfLeaves ()
specifier|public
name|int
name|getNumOfLeaves
parameter_list|()
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|clusterMap
operator|.
name|getNumOfLeaves
argument_list|()
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Return the distance between two nodes    * It is assumed that the distance from one node to its parent is 1    * The distance between two nodes is calculated by summing up their distances    * to their closest common ancestor.    * @param node1 one node    * @param node2 another node    * @return the distance between node1 and node2 which is zero if they are the same    *  or {@link Integer#MAX_VALUE} if node1 or node2 do not belong to the cluster    */
DECL|method|getDistance (Node node1, Node node2)
specifier|public
name|int
name|getDistance
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
if|if
condition|(
operator|(
name|node1
operator|!=
literal|null
operator|&&
name|node1
operator|.
name|equals
argument_list|(
name|node2
argument_list|)
operator|)
operator|||
operator|(
name|node1
operator|==
literal|null
operator|&&
name|node2
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|node1
operator|==
literal|null
operator|||
name|node2
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"One of the nodes is a null pointer"
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
name|Node
name|n1
init|=
name|node1
decl_stmt|,
name|n2
init|=
name|node2
decl_stmt|;
name|int
name|dis
init|=
literal|0
decl_stmt|;
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|level1
init|=
name|node1
operator|.
name|getLevel
argument_list|()
decl_stmt|,
name|level2
init|=
name|node2
operator|.
name|getLevel
argument_list|()
decl_stmt|;
while|while
condition|(
name|n1
operator|!=
literal|null
operator|&&
name|level1
operator|>
name|level2
condition|)
block|{
name|n1
operator|=
name|n1
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|level1
operator|--
expr_stmt|;
name|dis
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|n2
operator|!=
literal|null
operator|&&
name|level2
operator|>
name|level1
condition|)
block|{
name|n2
operator|=
name|n2
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|level2
operator|--
expr_stmt|;
name|dis
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|n1
operator|!=
literal|null
operator|&&
name|n2
operator|!=
literal|null
operator|&&
name|n1
operator|.
name|getParent
argument_list|()
operator|!=
name|n2
operator|.
name|getParent
argument_list|()
condition|)
block|{
name|n1
operator|=
name|n1
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|n2
operator|=
name|n2
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|dis
operator|+=
literal|2
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|n1
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The cluster does not contain node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
if|if
condition|(
name|n2
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The cluster does not contain node: "
operator|+
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
return|return
name|dis
operator|+
literal|2
return|;
block|}
comment|/** Return the distance between two nodes by comparing their network paths    * without checking if they belong to the same ancestor node by reference.    * It is assumed that the distance from one node to its parent is 1    * The distance between two nodes is calculated by summing up their distances    * to their closest common ancestor.    * @param node1 one node    * @param node2 another node    * @return the distance between node1 and node2    */
DECL|method|getDistanceByPath (Node node1, Node node2)
specifier|static
specifier|public
name|int
name|getDistanceByPath
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
if|if
condition|(
name|node1
operator|==
literal|null
operator|&&
name|node2
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|node1
operator|==
literal|null
operator|||
name|node2
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"One of the nodes is a null pointer"
argument_list|)
expr_stmt|;
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
name|String
index|[]
name|paths1
init|=
name|NodeBase
operator|.
name|getPathComponents
argument_list|(
name|node1
argument_list|)
decl_stmt|;
name|String
index|[]
name|paths2
init|=
name|NodeBase
operator|.
name|getPathComponents
argument_list|(
name|node2
argument_list|)
decl_stmt|;
name|int
name|dis
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|minLevel
init|=
name|Math
operator|.
name|min
argument_list|(
name|paths1
operator|.
name|length
argument_list|,
name|paths2
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|minLevel
condition|)
block|{
if|if
condition|(
operator|!
name|paths1
index|[
name|index
index|]
operator|.
name|equals
argument_list|(
name|paths2
index|[
name|index
index|]
argument_list|)
condition|)
block|{
comment|// Once the path starts to diverge,  compute the distance that include
comment|// the rest of paths.
name|dis
operator|+=
literal|2
operator|*
operator|(
name|minLevel
operator|-
name|index
operator|)
expr_stmt|;
break|break;
block|}
name|index
operator|++
expr_stmt|;
block|}
name|dis
operator|+=
name|Math
operator|.
name|abs
argument_list|(
name|paths1
operator|.
name|length
operator|-
name|paths2
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|dis
return|;
block|}
comment|/** Check if two nodes are on the same rack    * @param node1 one node (can be null)    * @param node2 another node (can be null)    * @return true if node1 and node2 are on the same rack; false otherwise    * @exception IllegalArgumentException when either node1 or node2 is null, or    * node1 or node2 do not belong to the cluster    */
DECL|method|isOnSameRack ( Node node1, Node node2)
specifier|public
name|boolean
name|isOnSameRack
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
if|if
condition|(
name|node1
operator|==
literal|null
operator|||
name|node2
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|isSameParents
argument_list|(
name|node1
argument_list|,
name|node2
argument_list|)
return|;
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check if network topology is aware of NodeGroup    */
DECL|method|isNodeGroupAware ()
specifier|public
name|boolean
name|isNodeGroupAware
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**     * Return false directly as not aware of NodeGroup, to be override in sub-class    */
DECL|method|isOnSameNodeGroup (Node node1, Node node2)
specifier|public
name|boolean
name|isOnSameNodeGroup
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Compare the parents of each node for equality    *     *<p>To be overridden in subclasses for specific NetworkTopology     * implementations, as alternative to overriding the full     * {@link #isOnSameRack(Node, Node)} method.    *     * @param node1 the first node to compare    * @param node2 the second node to compare    * @return true if their parents are equal, false otherwise    *     * @see #isOnSameRack(Node, Node)    */
DECL|method|isSameParents (Node node1, Node node2)
specifier|protected
name|boolean
name|isSameParents
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|)
block|{
return|return
name|node1
operator|.
name|getParent
argument_list|()
operator|==
name|node2
operator|.
name|getParent
argument_list|()
return|;
block|}
DECL|field|r
specifier|private
specifier|static
specifier|final
name|Random
name|r
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|setRandomSeed (long seed)
name|void
name|setRandomSeed
parameter_list|(
name|long
name|seed
parameter_list|)
block|{
name|r
operator|.
name|setSeed
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
comment|/**    * Randomly choose a node.    *    * @param scope range of nodes from which a node will be chosen    * @return the chosen node    *    * @see #chooseRandom(String, Collection)    */
DECL|method|chooseRandom (final String scope)
specifier|public
name|Node
name|chooseRandom
parameter_list|(
specifier|final
name|String
name|scope
parameter_list|)
block|{
return|return
name|chooseRandom
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Randomly choose one node from<i>scope</i>.    *    * If scope starts with ~, choose one from the all nodes except for the    * ones in<i>scope</i>; otherwise, choose one from<i>scope</i>.    * If excludedNodes is given, choose a node that's not in excludedNodes.    *    * @param scope range of nodes from which a node will be chosen    * @param excludedNodes nodes to be excluded from    * @return the chosen node    */
DECL|method|chooseRandom (final String scope, final Collection<Node> excludedNodes)
specifier|public
name|Node
name|chooseRandom
parameter_list|(
specifier|final
name|String
name|scope
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
literal|"~"
argument_list|)
condition|)
block|{
return|return
name|chooseRandom
argument_list|(
name|NodeBase
operator|.
name|ROOT
argument_list|,
name|scope
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|,
name|excludedNodes
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|chooseRandom
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
name|excludedNodes
argument_list|)
return|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|chooseRandom (final String scope, String excludedScope, final Collection<Node> excludedNodes)
specifier|protected
name|Node
name|chooseRandom
parameter_list|(
specifier|final
name|String
name|scope
parameter_list|,
name|String
name|excludedScope
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
block|{
if|if
condition|(
name|excludedScope
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
name|excludedScope
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|excludedScope
operator|.
name|startsWith
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|excludedScope
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|Node
name|node
init|=
name|getNode
argument_list|(
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
return|return
name|excludedNodes
operator|!=
literal|null
operator|&&
name|excludedNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|?
literal|null
else|:
name|node
return|;
block|}
name|InnerNode
name|innerNode
init|=
operator|(
name|InnerNode
operator|)
name|node
decl_stmt|;
name|int
name|numOfDatanodes
init|=
name|innerNode
operator|.
name|getNumOfLeaves
argument_list|()
decl_stmt|;
if|if
condition|(
name|excludedScope
operator|==
literal|null
condition|)
block|{
name|node
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|getNode
argument_list|(
name|excludedScope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
name|numOfDatanodes
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|numOfDatanodes
operator|-=
operator|(
operator|(
name|InnerNode
operator|)
name|node
operator|)
operator|.
name|getNumOfLeaves
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numOfDatanodes
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to find datanode (scope=\"{}\" excludedScope=\"{}\")."
operator|+
literal|" numOfDatanodes={}"
argument_list|,
name|scope
argument_list|,
name|excludedScope
argument_list|,
name|numOfDatanodes
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|availableNodes
decl_stmt|;
if|if
condition|(
name|excludedScope
operator|==
literal|null
condition|)
block|{
name|availableNodes
operator|=
name|countNumOfAvailableNodes
argument_list|(
name|scope
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|availableNodes
operator|=
name|countNumOfAvailableNodes
argument_list|(
literal|"~"
operator|+
name|excludedScope
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Choosing random from {} available nodes on node {},"
operator|+
literal|" scope={}, excludedScope={}, excludeNodes={}. numOfDatanodes={}."
argument_list|,
name|availableNodes
argument_list|,
name|innerNode
argument_list|,
name|scope
argument_list|,
name|excludedScope
argument_list|,
name|excludedNodes
argument_list|,
name|numOfDatanodes
argument_list|)
expr_stmt|;
name|Node
name|ret
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|availableNodes
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|chooseRandom
argument_list|(
name|innerNode
argument_list|,
name|node
argument_list|,
name|excludedNodes
argument_list|,
name|numOfDatanodes
argument_list|,
name|availableNodes
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"chooseRandom returning {}"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Randomly choose one node under<i>parentNode</i>, considering the exclude    * nodes and scope. Should be called with {@link #netlock}'s readlock held.    *    * @param parentNode        the parent node    * @param excludedScopeNode the node corresponding to the exclude scope.    * @param excludedNodes     a collection of nodes to be excluded from    * @param totalInScopeNodes total number of nodes under parentNode, excluding    *                          the excludedScopeNode    * @param availableNodes    number of available nodes under parentNode that    *                          could be chosen, excluding excludedNodes    * @return the chosen node, or null if none can be chosen    */
DECL|method|chooseRandom (final InnerNode parentNode, final Node excludedScopeNode, final Collection<Node> excludedNodes, final int totalInScopeNodes, final int availableNodes)
specifier|private
name|Node
name|chooseRandom
parameter_list|(
specifier|final
name|InnerNode
name|parentNode
parameter_list|,
specifier|final
name|Node
name|excludedScopeNode
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
specifier|final
name|int
name|totalInScopeNodes
parameter_list|,
specifier|final
name|int
name|availableNodes
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|totalInScopeNodes
operator|>=
name|availableNodes
operator|&&
name|availableNodes
operator|>
literal|0
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"%d should>= %d, and both should be positive."
argument_list|,
name|totalInScopeNodes
argument_list|,
name|availableNodes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|excludedNodes
operator|==
literal|null
operator|||
name|excludedNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// if there are no excludedNodes, randomly choose a node
specifier|final
name|int
name|index
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|totalInScopeNodes
argument_list|)
decl_stmt|;
return|return
name|parentNode
operator|.
name|getLeaf
argument_list|(
name|index
argument_list|,
name|excludedScopeNode
argument_list|)
return|;
block|}
comment|// excludedNodes non empty.
comment|// Choose the nth VALID node, where n is random. VALID meaning it can be
comment|// returned, after considering exclude scope and exclude nodes.
comment|// The probability of being chosen should be equal for all VALID nodes.
comment|// Notably, we do NOT choose nth node, and find the next valid node
comment|// if n is excluded - this will make the probability of the node immediately
comment|// after an excluded node higher.
comment|//
comment|// Start point is always 0 and that's fine, because the nth valid node
comment|// logic provides equal randomness.
comment|//
comment|// Consider this example, where 1,3,5 out of the 10 nodes are excluded:
comment|// 1 2 3 4 5 6 7 8 9 10
comment|// x   x   x
comment|// We will randomly choose the nth valid node where n is [0,6].
comment|// We do NOT choose a random number n and just use the closest valid node,
comment|// for example both n=3 and n=4 will choose 4, making it a 2/10 probability,
comment|// higher than the expected 1/7
comment|// totalInScopeNodes=10 and availableNodes=7 in this example.
name|int
name|nthValidToReturn
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|availableNodes
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"nthValidToReturn is {}"
argument_list|,
name|nthValidToReturn
argument_list|)
expr_stmt|;
name|Node
name|ret
init|=
name|parentNode
operator|.
name|getLeaf
argument_list|(
name|r
operator|.
name|nextInt
argument_list|(
name|totalInScopeNodes
argument_list|)
argument_list|,
name|excludedScopeNode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|excludedNodes
operator|.
name|contains
argument_list|(
name|ret
argument_list|)
condition|)
block|{
comment|// return if we're lucky enough to get a valid node at a random first pick
name|LOG
operator|.
name|debug
argument_list|(
literal|"Chosen node {} from first random"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|ret
operator|=
literal|null
expr_stmt|;
block|}
name|Node
name|lastValidNode
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|totalInScopeNodes
condition|;
operator|++
name|i
control|)
block|{
name|ret
operator|=
name|parentNode
operator|.
name|getLeaf
argument_list|(
name|i
argument_list|,
name|excludedScopeNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|excludedNodes
operator|.
name|contains
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
name|nthValidToReturn
operator|==
literal|0
condition|)
block|{
break|break;
block|}
operator|--
name|nthValidToReturn
expr_stmt|;
name|lastValidNode
operator|=
name|ret
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node {} is excluded, continuing."
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|null
operator|&&
name|lastValidNode
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"BUG: Found lastValidNode {} but not nth valid node. "
operator|+
literal|"parentNode={}, excludedScopeNode={}, excludedNodes={}, "
operator|+
literal|"totalInScopeNodes={}, availableNodes={}, nthValidToReturn={}."
argument_list|,
name|lastValidNode
argument_list|,
name|parentNode
argument_list|,
name|excludedScopeNode
argument_list|,
name|excludedNodes
argument_list|,
name|totalInScopeNodes
argument_list|,
name|availableNodes
argument_list|,
name|nthValidToReturn
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lastValidNode
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/** return leaves in<i>scope</i>    * @param scope a path string    * @return leaves nodes under specific scope    */
DECL|method|getLeaves (String scope)
specifier|public
name|List
argument_list|<
name|Node
argument_list|>
name|getLeaves
parameter_list|(
name|String
name|scope
parameter_list|)
block|{
name|Node
name|node
init|=
name|getNode
argument_list|(
name|scope
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|leafNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|InnerNode
operator|)
condition|)
block|{
name|leafNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|InnerNode
name|innerNode
init|=
operator|(
name|InnerNode
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|innerNode
operator|.
name|getNumOfLeaves
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|leafNodes
operator|.
name|add
argument_list|(
name|innerNode
operator|.
name|getLeaf
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|leafNodes
return|;
block|}
comment|/** return the number of leaves in<i>scope</i> but not in<i>excludedNodes</i>    * if scope starts with ~, return the number of nodes that are not    * in<i>scope</i> and<i>excludedNodes</i>;     * @param scope a path string that may start with ~    * @param excludedNodes a list of nodes    * @return number of available nodes    */
annotation|@
name|VisibleForTesting
DECL|method|countNumOfAvailableNodes (String scope, Collection<Node> excludedNodes)
specifier|public
name|int
name|countNumOfAvailableNodes
parameter_list|(
name|String
name|scope
parameter_list|,
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
block|{
name|boolean
name|isExcluded
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|scope
operator|.
name|startsWith
argument_list|(
literal|"~"
argument_list|)
condition|)
block|{
name|isExcluded
operator|=
literal|true
expr_stmt|;
name|scope
operator|=
name|scope
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|scope
operator|=
name|NodeBase
operator|.
name|normalize
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|int
name|excludedCountInScope
init|=
literal|0
decl_stmt|;
comment|// the number of nodes in both scope& excludedNodes
name|int
name|excludedCountOffScope
init|=
literal|0
decl_stmt|;
comment|// the number of nodes outside scope& excludedNodes
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|excludedNodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Node
name|node
range|:
name|excludedNodes
control|)
block|{
name|node
operator|=
name|getNode
argument_list|(
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|NodeBase
operator|.
name|getPath
argument_list|(
name|node
argument_list|)
operator|+
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
operator|)
operator|.
name|startsWith
argument_list|(
name|scope
operator|+
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
argument_list|)
condition|)
block|{
name|excludedCountInScope
operator|++
expr_stmt|;
block|}
else|else
block|{
name|excludedCountOffScope
operator|++
expr_stmt|;
block|}
block|}
block|}
name|Node
name|n
init|=
name|getNode
argument_list|(
name|scope
argument_list|)
decl_stmt|;
name|int
name|scopeNodeCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|null
condition|)
block|{
name|scopeNodeCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|instanceof
name|InnerNode
condition|)
block|{
name|scopeNodeCount
operator|=
operator|(
operator|(
name|InnerNode
operator|)
name|n
operator|)
operator|.
name|getNumOfLeaves
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isExcluded
condition|)
block|{
return|return
name|clusterMap
operator|.
name|getNumOfLeaves
argument_list|()
operator|-
name|scopeNodeCount
operator|-
name|excludedCountOffScope
return|;
block|}
else|else
block|{
return|return
name|scopeNodeCount
operator|-
name|excludedCountInScope
return|;
block|}
block|}
finally|finally
block|{
name|netlock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** convert a network tree to a string. */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// print the number of racks
name|StringBuilder
name|tree
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"Number of racks: "
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
name|numOfRacks
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// print the number of leaves
name|int
name|numOfLeaves
init|=
name|getNumOfLeaves
argument_list|()
decl_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"Expected number of leaves:"
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
name|numOfLeaves
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// print nodes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfLeaves
condition|;
name|i
operator|++
control|)
block|{
name|tree
operator|.
name|append
argument_list|(
name|NodeBase
operator|.
name|getPath
argument_list|(
name|clusterMap
operator|.
name|getLeaf
argument_list|(
name|i
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|tree
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Divide networklocation string into two parts by last separator, and get     * the first part here.    *     * @param networkLocation    * @return    */
DECL|method|getFirstHalf (String networkLocation)
specifier|public
specifier|static
name|String
name|getFirstHalf
parameter_list|(
name|String
name|networkLocation
parameter_list|)
block|{
name|int
name|index
init|=
name|networkLocation
operator|.
name|lastIndexOf
argument_list|(
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
argument_list|)
decl_stmt|;
return|return
name|networkLocation
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/**    * Divide networklocation string into two parts by last separator, and get     * the second part here.    *     * @param networkLocation    * @return    */
DECL|method|getLastHalf (String networkLocation)
specifier|public
specifier|static
name|String
name|getLastHalf
parameter_list|(
name|String
name|networkLocation
parameter_list|)
block|{
name|int
name|index
init|=
name|networkLocation
operator|.
name|lastIndexOf
argument_list|(
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
argument_list|)
decl_stmt|;
return|return
name|networkLocation
operator|.
name|substring
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/**    * Returns an integer weight which specifies how far away {node} is away from    * {reader}. A lower value signifies that a node is closer.    *     * @param reader Node where data will be read    * @param node Replica of data    * @return weight    */
DECL|method|getWeight (Node reader, Node node)
specifier|protected
name|int
name|getWeight
parameter_list|(
name|Node
name|reader
parameter_list|,
name|Node
name|node
parameter_list|)
block|{
comment|// 0 is local, 2 is same rack, and each level on each node increases the
comment|//weight by 1
comment|//Start off by initializing to Integer.MAX_VALUE
name|int
name|weight
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
operator|&&
name|node
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|equals
argument_list|(
name|node
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|maxReaderLevel
init|=
name|reader
operator|.
name|getLevel
argument_list|()
decl_stmt|;
name|int
name|maxNodeLevel
init|=
name|node
operator|.
name|getLevel
argument_list|()
decl_stmt|;
name|int
name|currentLevelToCompare
init|=
name|maxReaderLevel
operator|>
name|maxNodeLevel
condition|?
name|maxNodeLevel
else|:
name|maxReaderLevel
decl_stmt|;
name|Node
name|r
init|=
name|reader
decl_stmt|;
name|Node
name|n
init|=
name|node
decl_stmt|;
name|weight
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
operator|!=
literal|null
operator|&&
name|r
operator|.
name|getLevel
argument_list|()
operator|>
name|currentLevelToCompare
condition|)
block|{
name|r
operator|=
name|r
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|weight
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|!=
literal|null
operator|&&
name|n
operator|.
name|getLevel
argument_list|()
operator|>
name|currentLevelToCompare
condition|)
block|{
name|n
operator|=
name|n
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|weight
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|r
operator|!=
literal|null
operator|&&
name|n
operator|!=
literal|null
operator|&&
operator|!
name|r
operator|.
name|equals
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|r
operator|=
name|r
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|n
operator|=
name|n
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|weight
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|weight
return|;
block|}
comment|/**    * Returns an integer weight which specifies how far away<i>node</i> is    * from<i>reader</i>. A lower value signifies that a node is closer.    * It uses network location to calculate the weight    *    * @param reader Node where data will be read    * @param node Replica of data    * @return weight    */
DECL|method|getWeightUsingNetworkLocation (Node reader, Node node)
specifier|private
specifier|static
name|int
name|getWeightUsingNetworkLocation
parameter_list|(
name|Node
name|reader
parameter_list|,
name|Node
name|node
parameter_list|)
block|{
comment|//Start off by initializing to Integer.MAX_VALUE
name|int
name|weight
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
operator|&&
name|node
operator|!=
literal|null
condition|)
block|{
name|String
name|readerPath
init|=
name|normalizeNetworkLocationPath
argument_list|(
name|reader
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|nodePath
init|=
name|normalizeNetworkLocationPath
argument_list|(
name|node
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
decl_stmt|;
comment|//same rack
if|if
condition|(
name|readerPath
operator|.
name|equals
argument_list|(
name|nodePath
argument_list|)
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|weight
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|weight
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
index|[]
name|readerPathToken
init|=
name|readerPath
operator|.
name|split
argument_list|(
name|PATH_SEPARATOR_STR
argument_list|)
decl_stmt|;
name|String
index|[]
name|nodePathToken
init|=
name|nodePath
operator|.
name|split
argument_list|(
name|PATH_SEPARATOR_STR
argument_list|)
decl_stmt|;
name|int
name|maxLevelToCompare
init|=
name|readerPathToken
operator|.
name|length
operator|>
name|nodePathToken
operator|.
name|length
condition|?
name|nodePathToken
operator|.
name|length
else|:
name|readerPathToken
operator|.
name|length
decl_stmt|;
name|int
name|currentLevel
init|=
literal|1
decl_stmt|;
comment|//traverse through the path and calculate the distance
while|while
condition|(
name|currentLevel
operator|<
name|maxLevelToCompare
condition|)
block|{
if|if
condition|(
operator|!
name|readerPathToken
index|[
name|currentLevel
index|]
operator|.
name|equals
argument_list|(
name|nodePathToken
index|[
name|currentLevel
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
name|currentLevel
operator|++
expr_stmt|;
block|}
name|weight
operator|=
operator|(
name|readerPathToken
operator|.
name|length
operator|-
name|currentLevel
operator|)
operator|+
operator|(
name|nodePathToken
operator|.
name|length
operator|-
name|currentLevel
operator|)
expr_stmt|;
block|}
block|}
return|return
name|weight
return|;
block|}
comment|/** Normalize a path by stripping off any trailing {@link #PATH_SEPARATOR}.    * @param path path to normalize.    * @return the normalised path    * If<i>path</i>is null or empty {@link #ROOT} is returned    * @throws IllegalArgumentException if the first character of a non empty path    * is not {@link #PATH_SEPARATOR}    */
DECL|method|normalizeNetworkLocationPath (String path)
specifier|private
specifier|static
name|String
name|normalizeNetworkLocationPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
literal|null
operator|||
name|path
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ROOT
return|;
block|}
if|if
condition|(
name|path
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
name|PATH_SEPARATOR
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Network Location"
operator|+
literal|"path doesn't start with "
operator|+
name|PATH_SEPARATOR
operator|+
literal|": "
operator|+
name|path
argument_list|)
throw|;
block|}
name|int
name|len
init|=
name|path
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|charAt
argument_list|(
name|len
operator|-
literal|1
argument_list|)
operator|==
name|PATH_SEPARATOR
condition|)
block|{
return|return
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|len
operator|-
literal|1
argument_list|)
return|;
block|}
return|return
name|path
return|;
block|}
comment|/**    * Sort nodes array by network distance to<i>reader</i>.    *<p>    * In a three-level topology, a node can be either local, on the same rack,    * or on a different rack from the reader. Sorting the nodes based on network    * distance from the reader reduces network traffic and improves    * performance.    *<p>    * As an additional twist, we also randomize the nodes at each network    * distance. This helps with load balancing when there is data skew.    *    * @param reader    Node where data will be read    * @param nodes     Available replicas with the requested data    * @param activeLen Number of active nodes at the front of the array    */
DECL|method|sortByDistance (Node reader, Node[] nodes, int activeLen)
specifier|public
name|void
name|sortByDistance
parameter_list|(
name|Node
name|reader
parameter_list|,
name|Node
index|[]
name|nodes
parameter_list|,
name|int
name|activeLen
parameter_list|)
block|{
comment|/*      * This method is called if the reader is a datanode,      * so nonDataNodeReader flag is set to false.      */
name|sortByDistance
argument_list|(
name|reader
argument_list|,
name|nodes
argument_list|,
name|activeLen
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sort nodes array by network distance to<i>reader</i>.    *<p> using network location. This is used when the reader    * is not a datanode. Sorting the nodes based on network distance    * from the reader reduces network traffic and improves    * performance.    *<p>    *    * @param reader    Node where data will be read    * @param nodes     Available replicas with the requested data    * @param activeLen Number of active nodes at the front of the array    */
DECL|method|sortByDistanceUsingNetworkLocation (Node reader, Node[] nodes, int activeLen)
specifier|public
name|void
name|sortByDistanceUsingNetworkLocation
parameter_list|(
name|Node
name|reader
parameter_list|,
name|Node
index|[]
name|nodes
parameter_list|,
name|int
name|activeLen
parameter_list|)
block|{
comment|/*      * This method is called if the reader is not a datanode,      * so nonDataNodeReader flag is set to true.      */
name|sortByDistance
argument_list|(
name|reader
argument_list|,
name|nodes
argument_list|,
name|activeLen
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sort nodes array by network distance to<i>reader</i>.    *<p>    * As an additional twist, we also randomize the nodes at each network    * distance. This helps with load balancing when there is data skew.    *    * @param reader    Node where data will be read    * @param nodes     Available replicas with the requested data    * @param activeLen Number of active nodes at the front of the array    * @param nonDataNodeReader True if the reader is not a datanode    */
DECL|method|sortByDistance (Node reader, Node[] nodes, int activeLen, boolean nonDataNodeReader)
specifier|private
name|void
name|sortByDistance
parameter_list|(
name|Node
name|reader
parameter_list|,
name|Node
index|[]
name|nodes
parameter_list|,
name|int
name|activeLen
parameter_list|,
name|boolean
name|nonDataNodeReader
parameter_list|)
block|{
comment|/** Sort weights for the nodes array */
name|int
index|[]
name|weights
init|=
operator|new
name|int
index|[
name|activeLen
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|activeLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nonDataNodeReader
condition|)
block|{
name|weights
index|[
name|i
index|]
operator|=
name|getWeightUsingNetworkLocation
argument_list|(
name|reader
argument_list|,
name|nodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|weights
index|[
name|i
index|]
operator|=
name|getWeight
argument_list|(
name|reader
argument_list|,
name|nodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add weight/node pairs to a TreeMap to sort
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Node
argument_list|>
argument_list|>
name|tree
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Node
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|activeLen
condition|;
name|i
operator|++
control|)
block|{
name|int
name|weight
init|=
name|weights
index|[
name|i
index|]
decl_stmt|;
name|Node
name|node
init|=
name|nodes
index|[
name|i
index|]
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|list
init|=
name|tree
operator|.
name|get
argument_list|(
name|weight
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
name|Lists
operator|.
name|newArrayListWithExpectedSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tree
operator|.
name|put
argument_list|(
name|weight
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Node
argument_list|>
name|list
range|:
name|tree
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
name|Collections
operator|.
name|shuffle
argument_list|(
name|list
argument_list|,
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|n
range|:
name|list
control|)
block|{
name|nodes
index|[
name|idx
index|]
operator|=
name|n
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
name|idx
operator|==
name|activeLen
argument_list|,
literal|"Sorted the wrong number of nodes!"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

