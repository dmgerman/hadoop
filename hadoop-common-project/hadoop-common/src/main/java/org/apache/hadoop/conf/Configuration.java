begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.conf
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
package|;
end_package

begin_import
import|import
name|com
operator|.
name|ctc
operator|.
name|wstx
operator|.
name|api
operator|.
name|ReaderConfig
import|;
end_import

begin_import
import|import
name|com
operator|.
name|ctc
operator|.
name|wstx
operator|.
name|io
operator|.
name|StreamBootstrapper
import|;
end_import

begin_import
import|import
name|com
operator|.
name|ctc
operator|.
name|wstx
operator|.
name|io
operator|.
name|SystemId
import|;
end_import

begin_import
import|import
name|com
operator|.
name|ctc
operator|.
name|wstx
operator|.
name|stax
operator|.
name|WstxInputFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|core
operator|.
name|JsonFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|core
operator|.
name|JsonGenerator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|JarURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilderFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLInputFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamConstants
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamReader
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|Transformer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|dom
operator|.
name|DOMSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|stream
operator|.
name|StreamResult
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|map
operator|.
name|UnmodifiableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|alias
operator|.
name|CredentialProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|alias
operator|.
name|CredentialProvider
operator|.
name|CredentialEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|alias
operator|.
name|CredentialProviderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringInterner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|stax2
operator|.
name|XMLStreamReader2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Strings
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
operator|.
name|isBlank
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
operator|.
name|isNotBlank
import|;
end_import

begin_comment
comment|/**  * Provides access to configuration parameters.  *  *<h4 id="Resources">Resources</h4>  *  *<p>Configurations are specified by resources. A resource contains a set of  * name/value pairs as XML data. Each resource is named by either a   *<code>String</code> or by a {@link Path}. If named by a<code>String</code>,   * then the classpath is examined for a file with that name.  If named by a   *<code>Path</code>, then the local filesystem is examined directly, without   * referring to the classpath.  *  *<p>Unless explicitly turned off, Hadoop by default specifies two   * resources, loaded in-order from the classpath:<ol>  *<li><tt>  *<a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">  * core-default.xml</a></tt>: Read-only defaults for hadoop.</li>  *<li><tt>core-site.xml</tt>: Site-specific configuration for a given hadoop  * installation.</li>  *</ol>  * Applications may add additional resources, which are loaded  * subsequent to these resources in the order they are added.  *   *<h4 id="FinalParams">Final Parameters</h4>  *  *<p>Configuration parameters may be declared<i>final</i>.   * Once a resource declares a value final, no subsequently-loaded   * resource can alter that value.    * For example, one might define a final parameter with:  *<tt><pre>  *&lt;property&gt;  *&lt;name&gt;dfs.hosts.include&lt;/name&gt;  *&lt;value&gt;/etc/hadoop/conf/hosts.include&lt;/value&gt;  *<b>&lt;final&gt;true&lt;/final&gt;</b>  *&lt;/property&gt;</pre></tt>  *  * Administrators typically define parameters as final in   *<tt>core-site.xml</tt> for values that user applications may not alter.  *  *<h4 id="VariableExpansion">Variable Expansion</h4>  *  *<p>Value strings are first processed for<i>variable expansion</i>. The  * available properties are:<ol>  *<li>Other properties defined in this Configuration; and, if a name is  * undefined here,</li>  *<li>Environment variables in {@link System#getenv()} if a name starts with  * "env.", or</li>  *<li>Properties in {@link System#getProperties()}.</li>  *</ol>  *  *<p>For example, if a configuration resource contains the following property  * definitions:   *<tt><pre>  *&lt;property&gt;  *&lt;name&gt;basedir&lt;/name&gt;  *&lt;value&gt;/user/${<i>user.name</i>}&lt;/value&gt;  *&lt;/property&gt;  *    *&lt;property&gt;  *&lt;name&gt;tempdir&lt;/name&gt;  *&lt;value&gt;${<i>basedir</i>}/tmp&lt;/value&gt;  *&lt;/property&gt;  *  *&lt;property&gt;  *&lt;name&gt;otherdir&lt;/name&gt;  *&lt;value&gt;${<i>env.BASE_DIR</i>}/other&lt;/value&gt;  *&lt;/property&gt;  *</pre></tt>  *  *<p>When<tt>conf.get("tempdir")</tt> is called, then<tt>${<i>basedir</i>}</tt>  * will be resolved to another property in this Configuration, while  *<tt>${<i>user.name</i>}</tt> would then ordinarily be resolved to the value  * of the System property with that name.  *<p>When<tt>conf.get("otherdir")</tt> is called, then<tt>${<i>env.BASE_DIR</i>}</tt>  * will be resolved to the value of the<tt>${<i>BASE_DIR</i>}</tt> environment variable.  * It supports<tt>${<i>env.NAME:-default</i>}</tt> and<tt>${<i>env.NAME-default</i>}</tt> notations.  * The former is resolved to "default" if<tt>${<i>NAME</i>}</tt> environment variable is undefined  * or its value is empty.  * The latter behaves the same way only if<tt>${<i>NAME</i>}</tt> is undefined.  *<p>By default, warnings will be given to any deprecated configuration   * parameters and these are suppressible by configuring  *<tt>log4j.logger.org.apache.hadoop.conf.Configuration.deprecation</tt> in  * log4j.properties file.  *  *<h4 id="Tags">Tags</h4>  *  *<p>Optionally we can tag related properties together by using tag  * attributes. System tags are defined by hadoop.tags.system property. Users  * can define there own custom tags in  hadoop.tags.custom property.  *  *<p>For example, we can tag existing property as:  *<tt><pre>  *&lt;property&gt;  *&lt;name&gt;dfs.replication&lt;/name&gt;  *&lt;value&gt;3&lt;/value&gt;  *&lt;tag&gt;HDFS,REQUIRED&lt;/tag&gt;  *&lt;/property&gt;  *  *&lt;property&gt;  *&lt;name&gt;dfs.data.transfer.protection&lt;/name&gt;  *&lt;value&gt;3&lt;/value&gt;  *&lt;tag&gt;HDFS,SECURITY&lt;/tag&gt;  *&lt;/property&gt;  *</pre></tt>  *<p> Properties marked with tags can be retrieved with<tt>conf  * .getAllPropertiesByTag("HDFS")</tt> or<tt>conf.getAllPropertiesByTags  * (Arrays.asList("YARN","SECURITY"))</tt>.</p>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|Configuration
specifier|public
class|class
name|Configuration
implements|implements
name|Iterable
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
implements|,
name|Writable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|LOG_DEPRECATION
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG_DEPRECATION
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"org.apache.hadoop.conf.Configuration.deprecation"
argument_list|)
decl_stmt|;
DECL|field|TAGS
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|TAGS
init|=
name|ConcurrentHashMap
operator|.
name|newKeySet
argument_list|()
decl_stmt|;
DECL|field|quietmode
specifier|private
name|boolean
name|quietmode
init|=
literal|true
decl_stmt|;
DECL|field|DEFAULT_STRING_CHECK
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_STRING_CHECK
init|=
literal|"testingforemptydefaultvalue"
decl_stmt|;
DECL|field|restrictSystemPropsDefault
specifier|private
specifier|static
name|boolean
name|restrictSystemPropsDefault
init|=
literal|false
decl_stmt|;
DECL|field|restrictSystemProps
specifier|private
name|boolean
name|restrictSystemProps
init|=
name|restrictSystemPropsDefault
decl_stmt|;
DECL|field|allowNullValueProperties
specifier|private
name|boolean
name|allowNullValueProperties
init|=
literal|false
decl_stmt|;
DECL|class|Resource
specifier|private
specifier|static
class|class
name|Resource
block|{
DECL|field|resource
specifier|private
specifier|final
name|Object
name|resource
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|restrictParser
specifier|private
specifier|final
name|boolean
name|restrictParser
decl_stmt|;
DECL|method|Resource (Object resource)
specifier|public
name|Resource
parameter_list|(
name|Object
name|resource
parameter_list|)
block|{
name|this
argument_list|(
name|resource
argument_list|,
name|resource
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|Resource (Object resource, boolean useRestrictedParser)
specifier|public
name|Resource
parameter_list|(
name|Object
name|resource
parameter_list|,
name|boolean
name|useRestrictedParser
parameter_list|)
block|{
name|this
argument_list|(
name|resource
argument_list|,
name|resource
operator|.
name|toString
argument_list|()
argument_list|,
name|useRestrictedParser
argument_list|)
expr_stmt|;
block|}
DECL|method|Resource (Object resource, String name)
specifier|public
name|Resource
parameter_list|(
name|Object
name|resource
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|this
argument_list|(
name|resource
argument_list|,
name|name
argument_list|,
name|getRestrictParserDefault
argument_list|(
name|resource
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|Resource (Object resource, String name, boolean restrictParser)
specifier|public
name|Resource
parameter_list|(
name|Object
name|resource
parameter_list|,
name|String
name|name
parameter_list|,
name|boolean
name|restrictParser
parameter_list|)
block|{
name|this
operator|.
name|resource
operator|=
name|resource
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|restrictParser
operator|=
name|restrictParser
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getResource ()
specifier|public
name|Object
name|getResource
parameter_list|()
block|{
return|return
name|resource
return|;
block|}
DECL|method|isParserRestricted ()
specifier|public
name|boolean
name|isParserRestricted
parameter_list|()
block|{
return|return
name|restrictParser
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getRestrictParserDefault (Object resource)
specifier|private
specifier|static
name|boolean
name|getRestrictParserDefault
parameter_list|(
name|Object
name|resource
parameter_list|)
block|{
if|if
condition|(
name|resource
operator|instanceof
name|String
operator|||
operator|!
name|UserGroupInformation
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|UserGroupInformation
name|user
decl_stmt|;
try|try
block|{
name|user
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to determine current user"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|user
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
return|;
block|}
block|}
comment|/**    * List of configuration resources.    */
DECL|field|resources
specifier|private
name|ArrayList
argument_list|<
name|Resource
argument_list|>
name|resources
init|=
operator|new
name|ArrayList
argument_list|<
name|Resource
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * The value reported as the setting resource when a key is set    * by code rather than a file resource by dumpConfiguration.    */
DECL|field|UNKNOWN_RESOURCE
specifier|static
specifier|final
name|String
name|UNKNOWN_RESOURCE
init|=
literal|"Unknown"
decl_stmt|;
comment|/**    * List of configuration parameters marked<b>final</b>.     */
DECL|field|finalParameters
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|finalParameters
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|loadDefaults
specifier|private
name|boolean
name|loadDefaults
init|=
literal|true
decl_stmt|;
comment|/**    * Configuration objects    */
DECL|field|REGISTRY
specifier|private
specifier|static
specifier|final
name|WeakHashMap
argument_list|<
name|Configuration
argument_list|,
name|Object
argument_list|>
name|REGISTRY
init|=
operator|new
name|WeakHashMap
argument_list|<
name|Configuration
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Map to hold properties by there tag groupings.    */
DECL|field|propertyTagsMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Properties
argument_list|>
name|propertyTagsMap
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * List of default Resources. Resources are loaded in the order of the list     * entries    */
DECL|field|defaultResources
specifier|private
specifier|static
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|String
argument_list|>
name|defaultResources
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|ClassLoader
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|WeakReference
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
argument_list|>
DECL|field|CACHE_CLASSES
name|CACHE_CLASSES
init|=
operator|new
name|WeakHashMap
argument_list|<
name|ClassLoader
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|WeakReference
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Sentinel value to store negative cache results in {@link #CACHE_CLASSES}.    */
DECL|field|NEGATIVE_CACHE_SENTINEL
specifier|private
specifier|static
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|NEGATIVE_CACHE_SENTINEL
init|=
name|NegativeCacheSentinel
operator|.
name|class
decl_stmt|;
comment|/**    * Stores the mapping of key to the resource which modifies or loads     * the key most recently. Created lazily to avoid wasting memory.    */
DECL|field|updatingResource
specifier|private
specifier|volatile
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|updatingResource
decl_stmt|;
comment|/**    * Specify exact input factory to avoid time finding correct one.    * Factory is reusable across un-synchronized threads once initialized    */
DECL|field|XML_INPUT_FACTORY
specifier|private
specifier|static
specifier|final
name|WstxInputFactory
name|XML_INPUT_FACTORY
init|=
operator|new
name|WstxInputFactory
argument_list|()
decl_stmt|;
comment|/**    * Class to keep the information about the keys which replace the deprecated    * ones.    *     * This class stores the new keys which replace the deprecated keys and also    * gives a provision to have a custom message for each of the deprecated key    * that is being replaced. It also provides method to get the appropriate    * warning message which can be logged whenever the deprecated key is used.    */
DECL|class|DeprecatedKeyInfo
specifier|private
specifier|static
class|class
name|DeprecatedKeyInfo
block|{
DECL|field|newKeys
specifier|private
specifier|final
name|String
index|[]
name|newKeys
decl_stmt|;
DECL|field|customMessage
specifier|private
specifier|final
name|String
name|customMessage
decl_stmt|;
DECL|field|accessed
specifier|private
specifier|final
name|AtomicBoolean
name|accessed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|method|DeprecatedKeyInfo (String[] newKeys, String customMessage)
name|DeprecatedKeyInfo
parameter_list|(
name|String
index|[]
name|newKeys
parameter_list|,
name|String
name|customMessage
parameter_list|)
block|{
name|this
operator|.
name|newKeys
operator|=
name|newKeys
expr_stmt|;
name|this
operator|.
name|customMessage
operator|=
name|customMessage
expr_stmt|;
block|}
DECL|method|getWarningMessage (String key)
specifier|private
specifier|final
name|String
name|getWarningMessage
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|getWarningMessage
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Method to provide the warning message. It gives the custom message if      * non-null, and default message otherwise.      * @param key the associated deprecated key.      * @param source the property source.      * @return message that is to be logged when a deprecated key is used.      */
DECL|method|getWarningMessage (String key, String source)
specifier|private
name|String
name|getWarningMessage
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|source
parameter_list|)
block|{
name|String
name|warningMessage
decl_stmt|;
if|if
condition|(
name|customMessage
operator|==
literal|null
condition|)
block|{
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|" in "
operator|+
name|source
argument_list|)
expr_stmt|;
block|}
name|message
operator|.
name|append
argument_list|(
literal|" is deprecated. Instead, use "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|message
operator|.
name|append
argument_list|(
name|newKeys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|newKeys
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|warningMessage
operator|=
name|message
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|warningMessage
operator|=
name|customMessage
expr_stmt|;
block|}
return|return
name|warningMessage
return|;
block|}
DECL|method|getAndSetAccessed ()
name|boolean
name|getAndSetAccessed
parameter_list|()
block|{
return|return
name|accessed
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
return|;
block|}
DECL|method|clearAccessed ()
specifier|public
name|void
name|clearAccessed
parameter_list|()
block|{
name|accessed
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A pending addition to the global set of deprecated keys.    */
DECL|class|DeprecationDelta
specifier|public
specifier|static
class|class
name|DeprecationDelta
block|{
DECL|field|key
specifier|private
specifier|final
name|String
name|key
decl_stmt|;
DECL|field|newKeys
specifier|private
specifier|final
name|String
index|[]
name|newKeys
decl_stmt|;
DECL|field|customMessage
specifier|private
specifier|final
name|String
name|customMessage
decl_stmt|;
DECL|method|DeprecationDelta (String key, String[] newKeys, String customMessage)
name|DeprecationDelta
parameter_list|(
name|String
name|key
parameter_list|,
name|String
index|[]
name|newKeys
parameter_list|,
name|String
name|customMessage
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|newKeys
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|newKeys
operator|.
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|newKeys
operator|=
name|newKeys
expr_stmt|;
name|this
operator|.
name|customMessage
operator|=
name|customMessage
expr_stmt|;
block|}
DECL|method|DeprecationDelta (String key, String newKey, String customMessage)
specifier|public
name|DeprecationDelta
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|newKey
parameter_list|,
name|String
name|customMessage
parameter_list|)
block|{
name|this
argument_list|(
name|key
argument_list|,
operator|new
name|String
index|[]
block|{
name|newKey
block|}
argument_list|,
name|customMessage
argument_list|)
expr_stmt|;
block|}
DECL|method|DeprecationDelta (String key, String newKey)
specifier|public
name|DeprecationDelta
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|newKey
parameter_list|)
block|{
name|this
argument_list|(
name|key
argument_list|,
operator|new
name|String
index|[]
block|{
name|newKey
block|}
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|getKey ()
specifier|public
name|String
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|getNewKeys ()
specifier|public
name|String
index|[]
name|getNewKeys
parameter_list|()
block|{
return|return
name|newKeys
return|;
block|}
DECL|method|getCustomMessage ()
specifier|public
name|String
name|getCustomMessage
parameter_list|()
block|{
return|return
name|customMessage
return|;
block|}
block|}
comment|/**    * The set of all keys which are deprecated.    *    * DeprecationContext objects are immutable.    */
DECL|class|DeprecationContext
specifier|private
specifier|static
class|class
name|DeprecationContext
block|{
comment|/**      * Stores the deprecated keys, the new keys which replace the deprecated keys      * and custom message(if any provided).      */
DECL|field|deprecatedKeyMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|DeprecatedKeyInfo
argument_list|>
name|deprecatedKeyMap
decl_stmt|;
comment|/**      * Stores a mapping from superseding keys to the keys which they deprecate.      */
DECL|field|reverseDeprecatedKeyMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|reverseDeprecatedKeyMap
decl_stmt|;
comment|/**      * Create a new DeprecationContext by copying a previous DeprecationContext      * and adding some deltas.      *      * @param other   The previous deprecation context to copy, or null to start      *                from nothing.      * @param deltas  The deltas to apply.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|DeprecationContext (DeprecationContext other, DeprecationDelta[] deltas)
name|DeprecationContext
parameter_list|(
name|DeprecationContext
name|other
parameter_list|,
name|DeprecationDelta
index|[]
name|deltas
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|DeprecatedKeyInfo
argument_list|>
name|newDeprecatedKeyMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|DeprecatedKeyInfo
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newReverseDeprecatedKeyMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|other
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|DeprecatedKeyInfo
argument_list|>
name|entry
range|:
name|other
operator|.
name|deprecatedKeyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|newDeprecatedKeyMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|other
operator|.
name|reverseDeprecatedKeyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|newReverseDeprecatedKeyMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|DeprecationDelta
name|delta
range|:
name|deltas
control|)
block|{
if|if
condition|(
operator|!
name|newDeprecatedKeyMap
operator|.
name|containsKey
argument_list|(
name|delta
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|DeprecatedKeyInfo
name|newKeyInfo
init|=
operator|new
name|DeprecatedKeyInfo
argument_list|(
name|delta
operator|.
name|getNewKeys
argument_list|()
argument_list|,
name|delta
operator|.
name|getCustomMessage
argument_list|()
argument_list|)
decl_stmt|;
name|newDeprecatedKeyMap
operator|.
name|put
argument_list|(
name|delta
operator|.
name|key
argument_list|,
name|newKeyInfo
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|newKey
range|:
name|delta
operator|.
name|getNewKeys
argument_list|()
control|)
block|{
name|newReverseDeprecatedKeyMap
operator|.
name|put
argument_list|(
name|newKey
argument_list|,
name|delta
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|deprecatedKeyMap
operator|=
name|UnmodifiableMap
operator|.
name|decorate
argument_list|(
name|newDeprecatedKeyMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|reverseDeprecatedKeyMap
operator|=
name|UnmodifiableMap
operator|.
name|decorate
argument_list|(
name|newReverseDeprecatedKeyMap
argument_list|)
expr_stmt|;
block|}
DECL|method|getDeprecatedKeyMap ()
name|Map
argument_list|<
name|String
argument_list|,
name|DeprecatedKeyInfo
argument_list|>
name|getDeprecatedKeyMap
parameter_list|()
block|{
return|return
name|deprecatedKeyMap
return|;
block|}
DECL|method|getReverseDeprecatedKeyMap ()
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getReverseDeprecatedKeyMap
parameter_list|()
block|{
return|return
name|reverseDeprecatedKeyMap
return|;
block|}
block|}
DECL|field|defaultDeprecations
specifier|private
specifier|static
name|DeprecationDelta
index|[]
name|defaultDeprecations
init|=
operator|new
name|DeprecationDelta
index|[]
block|{
operator|new
name|DeprecationDelta
argument_list|(
literal|"topology.script.file.name"
argument_list|,
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY
argument_list|)
block|,
operator|new
name|DeprecationDelta
argument_list|(
literal|"topology.script.number.args"
argument_list|,
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY
argument_list|)
block|,
operator|new
name|DeprecationDelta
argument_list|(
literal|"hadoop.configured.node.mapping"
argument_list|,
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_CONFIGURED_NODE_MAPPING_KEY
argument_list|)
block|,
operator|new
name|DeprecationDelta
argument_list|(
literal|"topology.node.switch.mapping.impl"
argument_list|,
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY
argument_list|)
block|,
operator|new
name|DeprecationDelta
argument_list|(
literal|"dfs.df.interval"
argument_list|,
name|CommonConfigurationKeys
operator|.
name|FS_DF_INTERVAL_KEY
argument_list|)
block|,
operator|new
name|DeprecationDelta
argument_list|(
literal|"fs.default.name"
argument_list|,
name|CommonConfigurationKeys
operator|.
name|FS_DEFAULT_NAME_KEY
argument_list|)
block|,
operator|new
name|DeprecationDelta
argument_list|(
literal|"dfs.umaskmode"
argument_list|,
name|CommonConfigurationKeys
operator|.
name|FS_PERMISSIONS_UMASK_KEY
argument_list|)
block|,
operator|new
name|DeprecationDelta
argument_list|(
literal|"dfs.nfs.exports.allowed.hosts"
argument_list|,
name|CommonConfigurationKeys
operator|.
name|NFS_EXPORTS_ALLOWED_HOSTS_KEY
argument_list|)
block|}
decl_stmt|;
comment|/**    * The global DeprecationContext.    */
DECL|field|deprecationContext
specifier|private
specifier|static
name|AtomicReference
argument_list|<
name|DeprecationContext
argument_list|>
name|deprecationContext
init|=
operator|new
name|AtomicReference
argument_list|<
name|DeprecationContext
argument_list|>
argument_list|(
operator|new
name|DeprecationContext
argument_list|(
literal|null
argument_list|,
name|defaultDeprecations
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Adds a set of deprecated keys to the global deprecations.    *    * This method is lockless.  It works by means of creating a new    * DeprecationContext based on the old one, and then atomically swapping in    * the new context.  If someone else updated the context in between us reading    * the old context and swapping in the new one, we try again until we win the    * race.    *    * @param deltas   The deprecations to add.    */
DECL|method|addDeprecations (DeprecationDelta[] deltas)
specifier|public
specifier|static
name|void
name|addDeprecations
parameter_list|(
name|DeprecationDelta
index|[]
name|deltas
parameter_list|)
block|{
name|DeprecationContext
name|prev
decl_stmt|,
name|next
decl_stmt|;
do|do
block|{
name|prev
operator|=
name|deprecationContext
operator|.
name|get
argument_list|()
expr_stmt|;
name|next
operator|=
operator|new
name|DeprecationContext
argument_list|(
name|prev
argument_list|,
name|deltas
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|deprecationContext
operator|.
name|compareAndSet
argument_list|(
name|prev
argument_list|,
name|next
argument_list|)
condition|)
do|;
block|}
comment|/**    * Adds the deprecated key to the global deprecation map.    * It does not override any existing entries in the deprecation map.    * This is to be used only by the developers in order to add deprecation of    * keys, and attempts to call this method after loading resources once,    * would lead to<tt>UnsupportedOperationException</tt>    *     * If a key is deprecated in favor of multiple keys, they are all treated as     * aliases of each other, and setting any one of them resets all the others     * to the new value.    *    * If you have multiple deprecation entries to add, it is more efficient to    * use #addDeprecations(DeprecationDelta[] deltas) instead.    *     * @param key    * @param newKeys    * @param customMessage    * @deprecated use {@link #addDeprecation(String key, String newKey,       String customMessage)} instead    */
annotation|@
name|Deprecated
DECL|method|addDeprecation (String key, String[] newKeys, String customMessage)
specifier|public
specifier|static
name|void
name|addDeprecation
parameter_list|(
name|String
name|key
parameter_list|,
name|String
index|[]
name|newKeys
parameter_list|,
name|String
name|customMessage
parameter_list|)
block|{
name|addDeprecations
argument_list|(
operator|new
name|DeprecationDelta
index|[]
block|{
operator|new
name|DeprecationDelta
argument_list|(
name|key
argument_list|,
name|newKeys
argument_list|,
name|customMessage
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds the deprecated key to the global deprecation map.    * It does not override any existing entries in the deprecation map.    * This is to be used only by the developers in order to add deprecation of    * keys, and attempts to call this method after loading resources once,    * would lead to<tt>UnsupportedOperationException</tt>    *     * If you have multiple deprecation entries to add, it is more efficient to    * use #addDeprecations(DeprecationDelta[] deltas) instead.    *    * @param key    * @param newKey    * @param customMessage    */
DECL|method|addDeprecation (String key, String newKey, String customMessage)
specifier|public
specifier|static
name|void
name|addDeprecation
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|newKey
parameter_list|,
name|String
name|customMessage
parameter_list|)
block|{
name|addDeprecation
argument_list|(
name|key
argument_list|,
operator|new
name|String
index|[]
block|{
name|newKey
block|}
argument_list|,
name|customMessage
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds the deprecated key to the global deprecation map when no custom    * message is provided.    * It does not override any existing entries in the deprecation map.    * This is to be used only by the developers in order to add deprecation of    * keys, and attempts to call this method after loading resources once,    * would lead to<tt>UnsupportedOperationException</tt>    *     * If a key is deprecated in favor of multiple keys, they are all treated as     * aliases of each other, and setting any one of them resets all the others     * to the new value.    *     * If you have multiple deprecation entries to add, it is more efficient to    * use #addDeprecations(DeprecationDelta[] deltas) instead.    *    * @param key Key that is to be deprecated    * @param newKeys list of keys that take up the values of deprecated key    * @deprecated use {@link #addDeprecation(String key, String newKey)} instead    */
annotation|@
name|Deprecated
DECL|method|addDeprecation (String key, String[] newKeys)
specifier|public
specifier|static
name|void
name|addDeprecation
parameter_list|(
name|String
name|key
parameter_list|,
name|String
index|[]
name|newKeys
parameter_list|)
block|{
name|addDeprecation
argument_list|(
name|key
argument_list|,
name|newKeys
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds the deprecated key to the global deprecation map when no custom    * message is provided.    * It does not override any existing entries in the deprecation map.    * This is to be used only by the developers in order to add deprecation of    * keys, and attempts to call this method after loading resources once,    * would lead to<tt>UnsupportedOperationException</tt>    *     * If you have multiple deprecation entries to add, it is more efficient to    * use #addDeprecations(DeprecationDelta[] deltas) instead.    *    * @param key Key that is to be deprecated    * @param newKey key that takes up the value of deprecated key    */
DECL|method|addDeprecation (String key, String newKey)
specifier|public
specifier|static
name|void
name|addDeprecation
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|newKey
parameter_list|)
block|{
name|addDeprecation
argument_list|(
name|key
argument_list|,
operator|new
name|String
index|[]
block|{
name|newKey
block|}
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * checks whether the given<code>key</code> is deprecated.    *     * @param key the parameter which is to be checked for deprecation    * @return<code>true</code> if the key is deprecated and     *<code>false</code> otherwise.    */
DECL|method|isDeprecated (String key)
specifier|public
specifier|static
name|boolean
name|isDeprecated
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|deprecationContext
operator|.
name|get
argument_list|()
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|getDeprecatedKey (String key)
specifier|private
specifier|static
name|String
name|getDeprecatedKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|deprecationContext
operator|.
name|get
argument_list|()
operator|.
name|getReverseDeprecatedKeyMap
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|getDeprecatedKeyInfo (String key)
specifier|private
specifier|static
name|DeprecatedKeyInfo
name|getDeprecatedKeyInfo
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|deprecationContext
operator|.
name|get
argument_list|()
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * Sets all deprecated properties that are not currently set but have a    * corresponding new property that is set. Useful for iterating the    * properties when all deprecated properties for currently set properties    * need to be present.    */
DECL|method|setDeprecatedProperties ()
specifier|public
name|void
name|setDeprecatedProperties
parameter_list|()
block|{
name|DeprecationContext
name|deprecations
init|=
name|deprecationContext
operator|.
name|get
argument_list|()
decl_stmt|;
name|Properties
name|props
init|=
name|getProps
argument_list|()
decl_stmt|;
name|Properties
name|overlay
init|=
name|getOverlay
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|DeprecatedKeyInfo
argument_list|>
name|entry
range|:
name|deprecations
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|depKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|overlay
operator|.
name|contains
argument_list|(
name|depKey
argument_list|)
condition|)
block|{
for|for
control|(
name|String
name|newKey
range|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|newKeys
control|)
block|{
name|String
name|val
init|=
name|overlay
operator|.
name|getProperty
argument_list|(
name|newKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
name|props
operator|.
name|setProperty
argument_list|(
name|depKey
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|overlay
operator|.
name|setProperty
argument_list|(
name|depKey
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Checks for the presence of the property<code>name</code> in the    * deprecation map. Returns the first of the list of new keys if present    * in the deprecation map or the<code>name</code> itself. If the property    * is not presently set but the property map contains an entry for the    * deprecated key, the value of the deprecated key is set as the value for    * the provided property name.    *    * @param deprecations deprecation context    * @param name the property name    * @return the first property in the list of properties mapping    *         the<code>name</code> or the<code>name</code> itself.    */
DECL|method|handleDeprecation (DeprecationContext deprecations, String name)
specifier|private
name|String
index|[]
name|handleDeprecation
parameter_list|(
name|DeprecationContext
name|deprecations
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|!=
name|name
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
comment|// Initialize the return value with requested name
name|String
index|[]
name|names
init|=
operator|new
name|String
index|[]
block|{
name|name
block|}
decl_stmt|;
comment|// Deprecated keys are logged once and an updated names are returned
name|DeprecatedKeyInfo
name|keyInfo
init|=
name|deprecations
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|keyInfo
operator|.
name|getAndSetAccessed
argument_list|()
condition|)
block|{
name|logDeprecation
argument_list|(
name|keyInfo
operator|.
name|getWarningMessage
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Override return value for deprecated keys
name|names
operator|=
name|keyInfo
operator|.
name|newKeys
expr_stmt|;
block|}
comment|// If there are no overlay values we can return early
name|Properties
name|overlayProperties
init|=
name|getOverlay
argument_list|()
decl_stmt|;
if|if
condition|(
name|overlayProperties
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|names
return|;
block|}
comment|// Update properties and overlays with reverse lookup values
for|for
control|(
name|String
name|n
range|:
name|names
control|)
block|{
name|String
name|deprecatedKey
init|=
name|deprecations
operator|.
name|getReverseDeprecatedKeyMap
argument_list|()
operator|.
name|get
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|deprecatedKey
operator|!=
literal|null
operator|&&
operator|!
name|overlayProperties
operator|.
name|containsKey
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|String
name|deprecatedValue
init|=
name|overlayProperties
operator|.
name|getProperty
argument_list|(
name|deprecatedKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|deprecatedValue
operator|!=
literal|null
condition|)
block|{
name|getProps
argument_list|()
operator|.
name|setProperty
argument_list|(
name|n
argument_list|,
name|deprecatedValue
argument_list|)
expr_stmt|;
name|overlayProperties
operator|.
name|setProperty
argument_list|(
name|n
argument_list|,
name|deprecatedValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|names
return|;
block|}
DECL|method|handleDeprecation ()
specifier|private
name|void
name|handleDeprecation
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling deprecation for all properties in config..."
argument_list|)
expr_stmt|;
name|DeprecationContext
name|deprecations
init|=
name|deprecationContext
operator|.
name|get
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Object
argument_list|>
name|keys
init|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|keys
operator|.
name|addAll
argument_list|(
name|getProps
argument_list|()
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|item
range|:
name|keys
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling deprecation for "
operator|+
operator|(
name|String
operator|)
name|item
argument_list|)
expr_stmt|;
name|handleDeprecation
argument_list|(
name|deprecations
argument_list|,
operator|(
name|String
operator|)
name|item
argument_list|)
expr_stmt|;
block|}
block|}
static|static
block|{
comment|// Add default resources
name|addDefaultResource
argument_list|(
literal|"core-default.xml"
argument_list|)
expr_stmt|;
name|addDefaultResource
argument_list|(
literal|"core-site.xml"
argument_list|)
expr_stmt|;
comment|// print deprecation warning if hadoop-site.xml is found in classpath
name|ClassLoader
name|cL
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
decl_stmt|;
if|if
condition|(
name|cL
operator|==
literal|null
condition|)
block|{
name|cL
operator|=
name|Configuration
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cL
operator|.
name|getResource
argument_list|(
literal|"hadoop-site.xml"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DEPRECATED: hadoop-site.xml found in the classpath. "
operator|+
literal|"Usage of hadoop-site.xml is deprecated. Instead use core-site.xml, "
operator|+
literal|"mapred-site.xml and hdfs-site.xml to override properties of "
operator|+
literal|"core-default.xml, mapred-default.xml and hdfs-default.xml "
operator|+
literal|"respectively"
argument_list|)
expr_stmt|;
name|addDefaultResource
argument_list|(
literal|"hadoop-site.xml"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|properties
specifier|private
name|Properties
name|properties
decl_stmt|;
DECL|field|overlay
specifier|private
name|Properties
name|overlay
decl_stmt|;
DECL|field|classLoader
specifier|private
name|ClassLoader
name|classLoader
decl_stmt|;
block|{
name|classLoader
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
expr_stmt|;
if|if
condition|(
name|classLoader
operator|==
literal|null
condition|)
block|{
name|classLoader
operator|=
name|Configuration
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** A new configuration. */
DECL|method|Configuration ()
specifier|public
name|Configuration
parameter_list|()
block|{
name|this
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** A new configuration where the behavior of reading from the default     * resources can be turned off.    *     * If the parameter {@code loadDefaults} is false, the new instance    * will not load resources from the default files.     * @param loadDefaults specifies whether to load from the default files    */
DECL|method|Configuration (boolean loadDefaults)
specifier|public
name|Configuration
parameter_list|(
name|boolean
name|loadDefaults
parameter_list|)
block|{
name|this
operator|.
name|loadDefaults
operator|=
name|loadDefaults
expr_stmt|;
synchronized|synchronized
init|(
name|Configuration
operator|.
name|class
init|)
block|{
name|REGISTRY
operator|.
name|put
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * A new configuration with the same settings cloned from another.    *     * @param other the configuration from which to clone settings.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|Configuration (Configuration other)
specifier|public
name|Configuration
parameter_list|(
name|Configuration
name|other
parameter_list|)
block|{
synchronized|synchronized
init|(
name|other
init|)
block|{
comment|// Make sure we clone a finalized state
comment|// Resources like input streams can be processed only once
name|other
operator|.
name|getProps
argument_list|()
expr_stmt|;
name|this
operator|.
name|resources
operator|=
operator|(
name|ArrayList
argument_list|<
name|Resource
argument_list|>
operator|)
name|other
operator|.
name|resources
operator|.
name|clone
argument_list|()
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|properties
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|properties
operator|=
operator|(
name|Properties
operator|)
name|other
operator|.
name|properties
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|other
operator|.
name|overlay
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|overlay
operator|=
operator|(
name|Properties
operator|)
name|other
operator|.
name|overlay
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|restrictSystemProps
operator|=
name|other
operator|.
name|restrictSystemProps
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|updatingResource
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|updatingResource
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
argument_list|(
name|other
operator|.
name|updatingResource
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|finalParameters
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|finalParameters
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|finalParameters
argument_list|)
expr_stmt|;
name|this
operator|.
name|propertyTagsMap
operator|.
name|putAll
argument_list|(
name|other
operator|.
name|propertyTagsMap
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|Configuration
operator|.
name|class
init|)
block|{
name|REGISTRY
operator|.
name|put
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|classLoader
operator|=
name|other
operator|.
name|classLoader
expr_stmt|;
name|this
operator|.
name|loadDefaults
operator|=
name|other
operator|.
name|loadDefaults
expr_stmt|;
name|setQuietMode
argument_list|(
name|other
operator|.
name|getQuietMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reload existing configuration instances.    */
DECL|method|reloadExistingConfigurations ()
specifier|public
specifier|static
specifier|synchronized
name|void
name|reloadExistingConfigurations
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reloading "
operator|+
name|REGISTRY
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" existing configurations"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Configuration
name|conf
range|:
name|REGISTRY
operator|.
name|keySet
argument_list|()
control|)
block|{
name|conf
operator|.
name|reloadConfiguration
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Add a default resource. Resources are loaded in the order of the resources     * added.    * @param name file name. File should be present in the classpath.    */
DECL|method|addDefaultResource (String name)
specifier|public
specifier|static
specifier|synchronized
name|void
name|addDefaultResource
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|defaultResources
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|defaultResources
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|Configuration
name|conf
range|:
name|REGISTRY
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|conf
operator|.
name|loadDefaults
condition|)
block|{
name|conf
operator|.
name|reloadConfiguration
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|setRestrictSystemPropertiesDefault (boolean val)
specifier|public
specifier|static
name|void
name|setRestrictSystemPropertiesDefault
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|restrictSystemPropsDefault
operator|=
name|val
expr_stmt|;
block|}
DECL|method|setRestrictSystemProperties (boolean val)
specifier|public
name|void
name|setRestrictSystemProperties
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|this
operator|.
name|restrictSystemProps
operator|=
name|val
expr_stmt|;
block|}
comment|/**    * Add a configuration resource.     *     * The properties of this resource will override properties of previously     * added resources, unless they were marked<a href="#Final">final</a>.     *     * @param name resource to be added, the classpath is examined for a file     *             with that name.    */
DECL|method|addResource (String name)
specifier|public
name|void
name|addResource
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addResource (String name, boolean restrictedParser)
specifier|public
name|void
name|addResource
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|restrictedParser
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|name
argument_list|,
name|restrictedParser
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a configuration resource.     *     * The properties of this resource will override properties of previously     * added resources, unless they were marked<a href="#Final">final</a>.     *     * @param url url of the resource to be added, the local filesystem is     *            examined directly to find the resource, without referring to     *            the classpath.    */
DECL|method|addResource (URL url)
specifier|public
name|void
name|addResource
parameter_list|(
name|URL
name|url
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|url
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addResource (URL url, boolean restrictedParser)
specifier|public
name|void
name|addResource
parameter_list|(
name|URL
name|url
parameter_list|,
name|boolean
name|restrictedParser
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|url
argument_list|,
name|restrictedParser
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a configuration resource.     *     * The properties of this resource will override properties of previously     * added resources, unless they were marked<a href="#Final">final</a>.     *     * @param file file-path of resource to be added, the local filesystem is    *             examined directly to find the resource, without referring to     *             the classpath.    */
DECL|method|addResource (Path file)
specifier|public
name|void
name|addResource
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addResource (Path file, boolean restrictedParser)
specifier|public
name|void
name|addResource
parameter_list|(
name|Path
name|file
parameter_list|,
name|boolean
name|restrictedParser
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|file
argument_list|,
name|restrictedParser
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a configuration resource.     *     * The properties of this resource will override properties of previously     * added resources, unless they were marked<a href="#Final">final</a>.     *     * WARNING: The contents of the InputStream will be cached, by this method.     * So use this sparingly because it does increase the memory consumption.    *     * @param in InputStream to deserialize the object from. In will be read from    * when a get or set is called next.  After it is read the stream will be    * closed.     */
DECL|method|addResource (InputStream in)
specifier|public
name|void
name|addResource
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addResource (InputStream in, boolean restrictedParser)
specifier|public
name|void
name|addResource
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|boolean
name|restrictedParser
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|in
argument_list|,
name|restrictedParser
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a configuration resource.     *     * The properties of this resource will override properties of previously     * added resources, unless they were marked<a href="#Final">final</a>.     *     * @param in InputStream to deserialize the object from.    * @param name the name of the resource because InputStream.toString is not    * very descriptive some times.      */
DECL|method|addResource (InputStream in, String name)
specifier|public
name|void
name|addResource
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|in
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addResource (InputStream in, String name, boolean restrictedParser)
specifier|public
name|void
name|addResource
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|String
name|name
parameter_list|,
name|boolean
name|restrictedParser
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|in
argument_list|,
name|name
argument_list|,
name|restrictedParser
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a configuration resource.    *    * The properties of this resource will override properties of previously    * added resources, unless they were marked<a href="#Final">final</a>.    *    * @param conf Configuration object from which to load properties    */
DECL|method|addResource (Configuration conf)
specifier|public
name|void
name|addResource
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|addResourceObject
argument_list|(
operator|new
name|Resource
argument_list|(
name|conf
operator|.
name|getProps
argument_list|()
argument_list|,
name|conf
operator|.
name|restrictSystemProps
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reload configuration from previously added resources.    *    * This method will clear all the configuration read from the added     * resources, and final parameters. This will make the resources to     * be read again before accessing the values. Values that are added    * via set methods will overlay values read from the resources.    */
DECL|method|reloadConfiguration ()
specifier|public
specifier|synchronized
name|void
name|reloadConfiguration
parameter_list|()
block|{
name|properties
operator|=
literal|null
expr_stmt|;
comment|// trigger reload
name|finalParameters
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// clear site-limits
block|}
DECL|method|addResourceObject (Resource resource)
specifier|private
specifier|synchronized
name|void
name|addResourceObject
parameter_list|(
name|Resource
name|resource
parameter_list|)
block|{
name|resources
operator|.
name|add
argument_list|(
name|resource
argument_list|)
expr_stmt|;
comment|// add to resources
name|restrictSystemProps
operator||=
name|resource
operator|.
name|isParserRestricted
argument_list|()
expr_stmt|;
name|reloadConfiguration
argument_list|()
expr_stmt|;
block|}
DECL|field|MAX_SUBST
specifier|private
specifier|static
specifier|final
name|int
name|MAX_SUBST
init|=
literal|20
decl_stmt|;
DECL|field|SUB_START_IDX
specifier|private
specifier|static
specifier|final
name|int
name|SUB_START_IDX
init|=
literal|0
decl_stmt|;
DECL|field|SUB_END_IDX
specifier|private
specifier|static
specifier|final
name|int
name|SUB_END_IDX
init|=
name|SUB_START_IDX
operator|+
literal|1
decl_stmt|;
comment|/**    * This is a manual implementation of the following regex    * "\\$\\{[^\\}\\$\u0020]+\\}". It can be 15x more efficient than    * a regex matcher as demonstrated by HADOOP-11506. This is noticeable with    * Hadoop apps building on the assumption Configuration#get is an O(1)    * hash table lookup, especially when the eval is a long string.    *    * @param eval a string that may contain variables requiring expansion.    * @return a 2-element int array res such that    * eval.substring(res[0], res[1]) is "var" for the left-most occurrence of    * ${var} in eval. If no variable is found -1, -1 is returned.    */
DECL|method|findSubVariable (String eval)
specifier|private
specifier|static
name|int
index|[]
name|findSubVariable
parameter_list|(
name|String
name|eval
parameter_list|)
block|{
name|int
index|[]
name|result
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|int
name|matchStart
decl_stmt|;
name|int
name|leftBrace
decl_stmt|;
comment|// scanning for a brace first because it's less frequent than $
comment|// that can occur in nested class names
comment|//
name|match_loop
label|:
for|for
control|(
name|matchStart
operator|=
literal|1
operator|,
name|leftBrace
operator|=
name|eval
operator|.
name|indexOf
argument_list|(
literal|'{'
argument_list|,
name|matchStart
argument_list|)
init|;
comment|// minimum left brace position (follows '$')
name|leftBrace
operator|>
literal|0
comment|// right brace of a smallest valid expression "${c}"
operator|&&
name|leftBrace
operator|+
literal|"{c"
operator|.
name|length
argument_list|()
operator|<
name|eval
operator|.
name|length
argument_list|()
condition|;
name|leftBrace
operator|=
name|eval
operator|.
name|indexOf
argument_list|(
literal|'{'
argument_list|,
name|matchStart
argument_list|)
control|)
block|{
name|int
name|matchedLen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|eval
operator|.
name|charAt
argument_list|(
name|leftBrace
operator|-
literal|1
argument_list|)
operator|==
literal|'$'
condition|)
block|{
name|int
name|subStart
init|=
name|leftBrace
operator|+
literal|1
decl_stmt|;
comment|// after '{'
for|for
control|(
name|int
name|i
init|=
name|subStart
init|;
name|i
operator|<
name|eval
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|eval
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
literal|'}'
case|:
if|if
condition|(
name|matchedLen
operator|>
literal|0
condition|)
block|{
comment|// match
name|result
index|[
name|SUB_START_IDX
index|]
operator|=
name|subStart
expr_stmt|;
name|result
index|[
name|SUB_END_IDX
index|]
operator|=
name|subStart
operator|+
name|matchedLen
expr_stmt|;
break|break
name|match_loop
break|;
block|}
comment|// fall through to skip 1 char
case|case
literal|' '
case|:
case|case
literal|'$'
case|:
name|matchStart
operator|=
name|i
operator|+
literal|1
expr_stmt|;
continue|continue
name|match_loop
continue|;
default|default:
name|matchedLen
operator|++
expr_stmt|;
block|}
block|}
comment|// scanned from "${"  to the end of eval, and no reset via ' ', '$':
comment|//    no match!
break|break
name|match_loop
break|;
block|}
else|else
block|{
comment|// not a start of a variable
comment|//
name|matchStart
operator|=
name|leftBrace
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Attempts to repeatedly expand the value {@code expr} by replacing the    * left-most substring of the form "${var}" in the following precedence order    *<ol>    *<li>by the value of the environment variable "var" if defined</li>    *<li>by the value of the Java system property "var" if defined</li>    *<li>by the value of the configuration key "var" if defined</li>    *</ol>    *    * If var is unbounded the current state of expansion "prefix${var}suffix" is    * returned.    *<p>    * This function also detects self-referential substitutions, i.e.    *<pre>    *   {@code    *   foo.bar = ${foo.bar}    *   }    *</pre>    * If a cycle is detected then the original expr is returned. Loops    * involving multiple substitutions are not detected.    *    * @param expr the literal value of a config key    * @return null if expr is null, otherwise the value resulting from expanding    * expr using the algorithm above.    * @throws IllegalArgumentException when more than    * {@link Configuration#MAX_SUBST} replacements are required    */
DECL|method|substituteVars (String expr)
specifier|private
name|String
name|substituteVars
parameter_list|(
name|String
name|expr
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|eval
init|=
name|expr
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|MAX_SUBST
condition|;
name|s
operator|++
control|)
block|{
specifier|final
name|int
index|[]
name|varBounds
init|=
name|findSubVariable
argument_list|(
name|eval
argument_list|)
decl_stmt|;
if|if
condition|(
name|varBounds
index|[
name|SUB_START_IDX
index|]
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|eval
return|;
block|}
specifier|final
name|String
name|var
init|=
name|eval
operator|.
name|substring
argument_list|(
name|varBounds
index|[
name|SUB_START_IDX
index|]
argument_list|,
name|varBounds
index|[
name|SUB_END_IDX
index|]
argument_list|)
decl_stmt|;
name|String
name|val
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|restrictSystemProps
condition|)
block|{
try|try
block|{
if|if
condition|(
name|var
operator|.
name|startsWith
argument_list|(
literal|"env."
argument_list|)
operator|&&
literal|4
operator|<
name|var
operator|.
name|length
argument_list|()
condition|)
block|{
name|String
name|v
init|=
name|var
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|v
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|v
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
name|i
operator|<
name|v
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|&&
name|v
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|'-'
condition|)
block|{
name|val
operator|=
name|getenv
argument_list|(
name|v
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
operator|||
name|val
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|v
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|val
operator|=
name|getenv
argument_list|(
name|v
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
name|v
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|v
operator|.
name|length
argument_list|()
condition|)
block|{
name|val
operator|=
name|getenv
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
name|getProperty
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected SecurityException in Configuration"
argument_list|,
name|se
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
name|getRaw
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
return|return
name|eval
return|;
comment|// return literal ${var}: var is unbound
block|}
specifier|final
name|int
name|dollar
init|=
name|varBounds
index|[
name|SUB_START_IDX
index|]
operator|-
literal|"${"
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|final
name|int
name|afterRightBrace
init|=
name|varBounds
index|[
name|SUB_END_IDX
index|]
operator|+
literal|"}"
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|final
name|String
name|refVar
init|=
name|eval
operator|.
name|substring
argument_list|(
name|dollar
argument_list|,
name|afterRightBrace
argument_list|)
decl_stmt|;
comment|// detect self-referential values
if|if
condition|(
name|val
operator|.
name|contains
argument_list|(
name|refVar
argument_list|)
condition|)
block|{
return|return
name|expr
return|;
comment|// return original expression if there is a loop
block|}
comment|// substitute
name|eval
operator|=
name|eval
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dollar
argument_list|)
operator|+
name|val
operator|+
name|eval
operator|.
name|substring
argument_list|(
name|afterRightBrace
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Variable substitution depth too large: "
operator|+
name|MAX_SUBST
operator|+
literal|" "
operator|+
name|expr
argument_list|)
throw|;
block|}
DECL|method|getenv (String name)
name|String
name|getenv
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|System
operator|.
name|getenv
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|getProperty (String key)
name|String
name|getProperty
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|System
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * Get the value of the<code>name</code> property,<code>null</code> if    * no such property exists. If the key is deprecated, it returns the value of    * the first key which replaces the deprecated key and is not null.    *     * Values are processed for<a href="#VariableExpansion">variable expansion</a>     * before being returned.     *     * @param name the property name, will be trimmed before get value.    * @return the value of the<code>name</code> or its replacing property,     *         or null if no such property exists.    */
DECL|method|get (String name)
specifier|public
name|String
name|get
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
index|[]
name|names
init|=
name|handleDeprecation
argument_list|(
name|deprecationContext
operator|.
name|get
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|String
name|result
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|n
range|:
name|names
control|)
block|{
name|result
operator|=
name|substituteVars
argument_list|(
name|getProps
argument_list|()
operator|.
name|getProperty
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Set Configuration to allow keys without values during setup.  Intended    * for use during testing.    *    * @param val If true, will allow Configuration to store keys without values    */
annotation|@
name|VisibleForTesting
DECL|method|setAllowNullValueProperties ( boolean val )
specifier|public
name|void
name|setAllowNullValueProperties
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|this
operator|.
name|allowNullValueProperties
operator|=
name|val
expr_stmt|;
block|}
DECL|method|setRestrictSystemProps (boolean val)
specifier|public
name|void
name|setRestrictSystemProps
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|this
operator|.
name|restrictSystemProps
operator|=
name|val
expr_stmt|;
block|}
comment|/**    * Return existence of the<code>name</code> property, but only for    * names which have no valid value, usually non-existent or commented    * out in XML.    *    * @param name the property name    * @return true if the property<code>name</code> exists without value    */
annotation|@
name|VisibleForTesting
DECL|method|onlyKeyExists (String name)
specifier|public
name|boolean
name|onlyKeyExists
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
index|[]
name|names
init|=
name|handleDeprecation
argument_list|(
name|deprecationContext
operator|.
name|get
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|n
range|:
name|names
control|)
block|{
if|if
condition|(
name|getProps
argument_list|()
operator|.
name|getProperty
argument_list|(
name|n
argument_list|,
name|DEFAULT_STRING_CHECK
argument_list|)
operator|.
name|equals
argument_list|(
name|DEFAULT_STRING_CHECK
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Get the value of the<code>name</code> property as a trimmed<code>String</code>,     *<code>null</code> if no such property exists.     * If the key is deprecated, it returns the value of    * the first key which replaces the deprecated key and is not null    *     * Values are processed for<a href="#VariableExpansion">variable expansion</a>     * before being returned.     *     * @param name the property name.    * @return the value of the<code>name</code> or its replacing property,     *         or null if no such property exists.    */
DECL|method|getTrimmed (String name)
specifier|public
name|String
name|getTrimmed
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|value
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|value
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|value
operator|.
name|trim
argument_list|()
return|;
block|}
block|}
comment|/**    * Get the value of the<code>name</code> property as a trimmed<code>String</code>,     *<code>defaultValue</code> if no such property exists.     * See @{Configuration#getTrimmed} for more details.    *     * @param name          the property name.    * @param defaultValue  the property default value.    * @return              the value of the<code>name</code> or defaultValue    *                      if it is not set.    */
DECL|method|getTrimmed (String name, String defaultValue)
specifier|public
name|String
name|getTrimmed
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|String
name|ret
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|ret
operator|==
literal|null
condition|?
name|defaultValue
else|:
name|ret
return|;
block|}
comment|/**    * Get the value of the<code>name</code> property, without doing    *<a href="#VariableExpansion">variable expansion</a>.If the key is     * deprecated, it returns the value of the first key which replaces     * the deprecated key and is not null.    *     * @param name the property name.    * @return the value of the<code>name</code> property or     *         its replacing property and null if no such property exists.    */
DECL|method|getRaw (String name)
specifier|public
name|String
name|getRaw
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
index|[]
name|names
init|=
name|handleDeprecation
argument_list|(
name|deprecationContext
operator|.
name|get
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|String
name|result
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|n
range|:
name|names
control|)
block|{
name|result
operator|=
name|getProps
argument_list|()
operator|.
name|getProperty
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns alternative names (non-deprecated keys or previously-set deprecated keys)    * for a given non-deprecated key.    * If the given key is deprecated, return null.    *    * @param name property name.    * @return alternative names.    */
DECL|method|getAlternativeNames (String name)
specifier|private
name|String
index|[]
name|getAlternativeNames
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|altNames
index|[]
init|=
literal|null
decl_stmt|;
name|DeprecatedKeyInfo
name|keyInfo
init|=
literal|null
decl_stmt|;
name|DeprecationContext
name|cur
init|=
name|deprecationContext
operator|.
name|get
argument_list|()
decl_stmt|;
name|String
name|depKey
init|=
name|cur
operator|.
name|getReverseDeprecatedKeyMap
argument_list|()
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|depKey
operator|!=
literal|null
condition|)
block|{
name|keyInfo
operator|=
name|cur
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|get
argument_list|(
name|depKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyInfo
operator|.
name|newKeys
operator|.
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|getProps
argument_list|()
operator|.
name|containsKey
argument_list|(
name|depKey
argument_list|)
condition|)
block|{
comment|//if deprecated key is previously set explicitly
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|list
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|keyInfo
operator|.
name|newKeys
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|depKey
argument_list|)
expr_stmt|;
name|altNames
operator|=
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|altNames
operator|=
name|keyInfo
operator|.
name|newKeys
expr_stmt|;
block|}
block|}
block|}
return|return
name|altNames
return|;
block|}
comment|/**     * Set the<code>value</code> of the<code>name</code> property. If     *<code>name</code> is deprecated or there is a deprecated name associated to it,    * it sets the value to both names. Name will be trimmed before put into    * configuration.    *     * @param name property name.    * @param value property value.    */
DECL|method|set (String name, String value)
specifier|public
name|void
name|set
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**     * Set the<code>value</code> of the<code>name</code> property. If     *<code>name</code> is deprecated, it also sets the<code>value</code> to    * the keys that replace the deprecated key. Name will be trimmed before put    * into configuration.    *    * @param name property name.    * @param value property value.    * @param source the place that this configuration value came from     * (For debugging).    * @throws IllegalArgumentException when the value or name is null.    */
DECL|method|set (String name, String value, String source)
specifier|public
name|void
name|set
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|,
name|String
name|source
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|name
operator|!=
literal|null
argument_list|,
literal|"Property name must not be null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|value
operator|!=
literal|null
argument_list|,
literal|"The value of property %s must not be null"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|name
operator|.
name|trim
argument_list|()
expr_stmt|;
name|DeprecationContext
name|deprecations
init|=
name|deprecationContext
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|deprecations
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|getProps
argument_list|()
expr_stmt|;
block|}
name|getOverlay
argument_list|()
operator|.
name|setProperty
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|getProps
argument_list|()
operator|.
name|setProperty
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|String
name|newSource
init|=
operator|(
name|source
operator|==
literal|null
condition|?
literal|"programmatically"
else|:
name|source
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isDeprecated
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|putIntoUpdatingResource
argument_list|(
name|name
argument_list|,
operator|new
name|String
index|[]
block|{
name|newSource
block|}
argument_list|)
expr_stmt|;
name|String
index|[]
name|altNames
init|=
name|getAlternativeNames
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|altNames
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|n
range|:
name|altNames
control|)
block|{
if|if
condition|(
operator|!
name|n
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|getOverlay
argument_list|()
operator|.
name|setProperty
argument_list|(
name|n
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|getProps
argument_list|()
operator|.
name|setProperty
argument_list|(
name|n
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|putIntoUpdatingResource
argument_list|(
name|n
argument_list|,
operator|new
name|String
index|[]
block|{
name|newSource
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|String
index|[]
name|names
init|=
name|handleDeprecation
argument_list|(
name|deprecationContext
operator|.
name|get
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|String
name|altSource
init|=
literal|"because "
operator|+
name|name
operator|+
literal|" is deprecated"
decl_stmt|;
for|for
control|(
name|String
name|n
range|:
name|names
control|)
block|{
name|getOverlay
argument_list|()
operator|.
name|setProperty
argument_list|(
name|n
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|getProps
argument_list|()
operator|.
name|setProperty
argument_list|(
name|n
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|putIntoUpdatingResource
argument_list|(
name|n
argument_list|,
operator|new
name|String
index|[]
block|{
name|altSource
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|logDeprecation (String message)
name|void
name|logDeprecation
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|LOG_DEPRECATION
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
DECL|method|logDeprecationOnce (String name, String source)
name|void
name|logDeprecationOnce
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|source
parameter_list|)
block|{
name|DeprecatedKeyInfo
name|keyInfo
init|=
name|getDeprecatedKeyInfo
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyInfo
operator|!=
literal|null
operator|&&
operator|!
name|keyInfo
operator|.
name|getAndSetAccessed
argument_list|()
condition|)
block|{
name|LOG_DEPRECATION
operator|.
name|info
argument_list|(
name|keyInfo
operator|.
name|getWarningMessage
argument_list|(
name|name
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Unset a previously set property.    */
DECL|method|unset (String name)
specifier|public
specifier|synchronized
name|void
name|unset
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
index|[]
name|names
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|isDeprecated
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|names
operator|=
name|getAlternativeNames
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
operator|==
literal|null
condition|)
block|{
name|names
operator|=
operator|new
name|String
index|[]
block|{
name|name
block|}
expr_stmt|;
block|}
block|}
else|else
block|{
name|names
operator|=
name|handleDeprecation
argument_list|(
name|deprecationContext
operator|.
name|get
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|n
range|:
name|names
control|)
block|{
name|getOverlay
argument_list|()
operator|.
name|remove
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|getProps
argument_list|()
operator|.
name|remove
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sets a property if it is currently unset.    * @param name the property name    * @param value the new value    */
DECL|method|setIfUnset (String name, String value)
specifier|public
specifier|synchronized
name|void
name|setIfUnset
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|get
argument_list|(
name|name
argument_list|)
operator|==
literal|null
condition|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getOverlay ()
specifier|private
specifier|synchronized
name|Properties
name|getOverlay
parameter_list|()
block|{
if|if
condition|(
name|overlay
operator|==
literal|null
condition|)
block|{
name|overlay
operator|=
operator|new
name|Properties
argument_list|()
expr_stmt|;
block|}
return|return
name|overlay
return|;
block|}
comment|/**     * Get the value of the<code>name</code>. If the key is deprecated,    * it returns the value of the first key which replaces the deprecated key    * and is not null.    * If no such property exists,    * then<code>defaultValue</code> is returned.    *     * @param name property name, will be trimmed before get value.    * @param defaultValue default value.    * @return property value, or<code>defaultValue</code> if the property     *         doesn't exist.                        */
DECL|method|get (String name, String defaultValue)
specifier|public
name|String
name|get
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|String
index|[]
name|names
init|=
name|handleDeprecation
argument_list|(
name|deprecationContext
operator|.
name|get
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|String
name|result
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|n
range|:
name|names
control|)
block|{
name|result
operator|=
name|substituteVars
argument_list|(
name|getProps
argument_list|()
operator|.
name|getProperty
argument_list|(
name|n
argument_list|,
name|defaultValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**     * Get the value of the<code>name</code> property as an<code>int</code>.    *       * If no such property exists, the provided default value is returned,    * or if the specified value is not a valid<code>int</code>,    * then an error is thrown.    *     * @param name property name.    * @param defaultValue default value.    * @throws NumberFormatException when the value is invalid    * @return property value as an<code>int</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getInt (String name, int defaultValue)
specifier|public
name|int
name|getInt
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
name|String
name|hexString
init|=
name|getHexDigits
argument_list|(
name|valueString
argument_list|)
decl_stmt|;
if|if
condition|(
name|hexString
operator|!=
literal|null
condition|)
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|hexString
argument_list|,
literal|16
argument_list|)
return|;
block|}
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**    * Get the value of the<code>name</code> property as a set of comma-delimited    *<code>int</code> values.    *     * If no such property exists, an empty array is returned.    *     * @param name property name    * @return property value interpreted as an array of comma-delimited    *<code>int</code> values    */
DECL|method|getInts (String name)
specifier|public
name|int
index|[]
name|getInts
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
index|[]
name|strings
init|=
name|getTrimmedStrings
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
index|[]
name|ints
init|=
operator|new
name|int
index|[
name|strings
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ints
index|[
name|i
index|]
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|strings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|ints
return|;
block|}
comment|/**     * Set the value of the<code>name</code> property to an<code>int</code>.    *     * @param name property name.    * @param value<code>int</code> value of the property.    */
DECL|method|setInt (String name, int value)
specifier|public
name|void
name|setInt
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>long</code>.      * If no such property exists, the provided default value is returned,    * or if the specified value is not a valid<code>long</code>,    * then an error is thrown.    *     * @param name property name.    * @param defaultValue default value.    * @throws NumberFormatException when the value is invalid    * @return property value as a<code>long</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getLong (String name, long defaultValue)
specifier|public
name|long
name|getLong
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
name|String
name|hexString
init|=
name|getHexDigits
argument_list|(
name|valueString
argument_list|)
decl_stmt|;
if|if
condition|(
name|hexString
operator|!=
literal|null
condition|)
block|{
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|hexString
argument_list|,
literal|16
argument_list|)
return|;
block|}
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**    * Get the value of the<code>name</code> property as a<code>long</code> or    * human readable format. If no such property exists, the provided default    * value is returned, or if the specified value is not a valid    *<code>long</code> or human readable format, then an error is thrown. You    * can use the following suffix (case insensitive): k(kilo), m(mega), g(giga),    * t(tera), p(peta), e(exa)    *    * @param name property name.    * @param defaultValue default value.    * @throws NumberFormatException when the value is invalid    * @return property value as a<code>long</code>,    *         or<code>defaultValue</code>.    */
DECL|method|getLongBytes (String name, long defaultValue)
specifier|public
name|long
name|getLongBytes
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
return|return
name|StringUtils
operator|.
name|TraditionalBinaryPrefix
operator|.
name|string2long
argument_list|(
name|valueString
argument_list|)
return|;
block|}
DECL|method|getHexDigits (String value)
specifier|private
name|String
name|getHexDigits
parameter_list|(
name|String
name|value
parameter_list|)
block|{
name|boolean
name|negative
init|=
literal|false
decl_stmt|;
name|String
name|str
init|=
name|value
decl_stmt|;
name|String
name|hexString
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
condition|)
block|{
name|negative
operator|=
literal|true
expr_stmt|;
name|str
operator|=
name|value
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
literal|"0x"
argument_list|)
operator|||
name|str
operator|.
name|startsWith
argument_list|(
literal|"0X"
argument_list|)
condition|)
block|{
name|hexString
operator|=
name|str
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative
condition|)
block|{
name|hexString
operator|=
literal|"-"
operator|+
name|hexString
expr_stmt|;
block|}
return|return
name|hexString
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**     * Set the value of the<code>name</code> property to a<code>long</code>.    *     * @param name property name.    * @param value<code>long</code> value of the property.    */
DECL|method|setLong (String name, long value)
specifier|public
name|void
name|setLong
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>float</code>.      * If no such property exists, the provided default value is returned,    * or if the specified value is not a valid<code>float</code>,    * then an error is thrown.    *    * @param name property name.    * @param defaultValue default value.    * @throws NumberFormatException when the value is invalid    * @return property value as a<code>float</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getFloat (String name, float defaultValue)
specifier|public
name|float
name|getFloat
parameter_list|(
name|String
name|name
parameter_list|,
name|float
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
return|return
name|Float
operator|.
name|parseFloat
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**    * Set the value of the<code>name</code> property to a<code>float</code>.    *     * @param name property name.    * @param value property value.    */
DECL|method|setFloat (String name, float value)
specifier|public
name|void
name|setFloat
parameter_list|(
name|String
name|name
parameter_list|,
name|float
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|Float
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>double</code>.      * If no such property exists, the provided default value is returned,    * or if the specified value is not a valid<code>double</code>,    * then an error is thrown.    *    * @param name property name.    * @param defaultValue default value.    * @throws NumberFormatException when the value is invalid    * @return property value as a<code>double</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getDouble (String name, double defaultValue)
specifier|public
name|double
name|getDouble
parameter_list|(
name|String
name|name
parameter_list|,
name|double
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
return|return
name|Double
operator|.
name|parseDouble
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**    * Set the value of the<code>name</code> property to a<code>double</code>.    *     * @param name property name.    * @param value property value.    */
DECL|method|setDouble (String name, double value)
specifier|public
name|void
name|setDouble
parameter_list|(
name|String
name|name
parameter_list|,
name|double
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|Double
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>boolean</code>.      * If no such property is specified, or if the specified value is not a valid    *<code>boolean</code>, then<code>defaultValue</code> is returned.    *     * @param name property name.    * @param defaultValue default value.    * @return property value as a<code>boolean</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getBoolean (String name, boolean defaultValue)
specifier|public
name|boolean
name|getBoolean
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|valueString
operator|||
name|valueString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
if|if
condition|(
name|StringUtils
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"true"
argument_list|,
name|valueString
argument_list|)
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|StringUtils
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"false"
argument_list|,
name|valueString
argument_list|)
condition|)
return|return
literal|false
return|;
else|else
return|return
name|defaultValue
return|;
block|}
comment|/**     * Set the value of the<code>name</code> property to a<code>boolean</code>.    *     * @param name property name.    * @param value<code>boolean</code> value of the property.    */
DECL|method|setBoolean (String name, boolean value)
specifier|public
name|void
name|setBoolean
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the given property, if it is currently unset.    * @param name property name    * @param value new value    */
DECL|method|setBooleanIfUnset (String name, boolean value)
specifier|public
name|void
name|setBooleanIfUnset
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|value
parameter_list|)
block|{
name|setIfUnset
argument_list|(
name|name
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the value of the<code>name</code> property to the given type. This    * is equivalent to<code>set(&lt;name&gt;, value.toString())</code>.    * @param name property name    * @param value new value    */
DECL|method|setEnum (String name, T value)
specifier|public
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|setEnum
parameter_list|(
name|String
name|name
parameter_list|,
name|T
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return value matching this enumerated type.    * Note that the returned value is trimmed by this method.    * @param name Property name    * @param defaultValue Value returned if no mapping exists    * @throws IllegalArgumentException If mapping is illegal for the type    * provided    */
DECL|method|getEnum (String name, T defaultValue)
specifier|public
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|T
name|getEnum
parameter_list|(
name|String
name|name
parameter_list|,
name|T
name|defaultValue
parameter_list|)
block|{
specifier|final
name|String
name|val
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
literal|null
operator|==
name|val
condition|?
name|defaultValue
else|:
name|Enum
operator|.
name|valueOf
argument_list|(
name|defaultValue
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|enum|ParsedTimeDuration
enum|enum
name|ParsedTimeDuration
block|{
DECL|enumConstant|NS
name|NS
block|{
name|TimeUnit
name|unit
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|NANOSECONDS
return|;
block|}
name|String
name|suffix
parameter_list|()
block|{
return|return
literal|"ns"
return|;
block|}
block|}
block|,
DECL|enumConstant|US
name|US
block|{
name|TimeUnit
name|unit
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|MICROSECONDS
return|;
block|}
name|String
name|suffix
parameter_list|()
block|{
return|return
literal|"us"
return|;
block|}
block|}
block|,
DECL|enumConstant|MS
name|MS
block|{
name|TimeUnit
name|unit
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|MILLISECONDS
return|;
block|}
name|String
name|suffix
parameter_list|()
block|{
return|return
literal|"ms"
return|;
block|}
block|}
block|,
DECL|enumConstant|S
name|S
block|{
name|TimeUnit
name|unit
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|SECONDS
return|;
block|}
name|String
name|suffix
parameter_list|()
block|{
return|return
literal|"s"
return|;
block|}
block|}
block|,
DECL|enumConstant|M
name|M
block|{
name|TimeUnit
name|unit
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|MINUTES
return|;
block|}
name|String
name|suffix
parameter_list|()
block|{
return|return
literal|"m"
return|;
block|}
block|}
block|,
DECL|enumConstant|H
name|H
block|{
name|TimeUnit
name|unit
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|HOURS
return|;
block|}
name|String
name|suffix
parameter_list|()
block|{
return|return
literal|"h"
return|;
block|}
block|}
block|,
DECL|enumConstant|D
name|D
block|{
name|TimeUnit
name|unit
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|DAYS
return|;
block|}
name|String
name|suffix
parameter_list|()
block|{
return|return
literal|"d"
return|;
block|}
block|}
block|;
DECL|method|unit ()
specifier|abstract
name|TimeUnit
name|unit
parameter_list|()
function_decl|;
DECL|method|suffix ()
specifier|abstract
name|String
name|suffix
parameter_list|()
function_decl|;
DECL|method|unitFor (String s)
specifier|static
name|ParsedTimeDuration
name|unitFor
parameter_list|(
name|String
name|s
parameter_list|)
block|{
for|for
control|(
name|ParsedTimeDuration
name|ptd
range|:
name|values
argument_list|()
control|)
block|{
comment|// iteration order is in decl order, so SECONDS matched last
if|if
condition|(
name|s
operator|.
name|endsWith
argument_list|(
name|ptd
operator|.
name|suffix
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ptd
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|unitFor (TimeUnit unit)
specifier|static
name|ParsedTimeDuration
name|unitFor
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
for|for
control|(
name|ParsedTimeDuration
name|ptd
range|:
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|ptd
operator|.
name|unit
argument_list|()
operator|==
name|unit
condition|)
block|{
return|return
name|ptd
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Set the value of<code>name</code> to the given time duration. This    * is equivalent to<code>set(&lt;name&gt;, value +&lt;time suffix&gt;)</code>.    * @param name Property name    * @param value Time duration    * @param unit Unit of time    */
DECL|method|setTimeDuration (String name, long value, TimeUnit unit)
specifier|public
name|void
name|setTimeDuration
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|value
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|value
operator|+
name|ParsedTimeDuration
operator|.
name|unitFor
argument_list|(
name|unit
argument_list|)
operator|.
name|suffix
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return time duration in the given time unit. Valid units are encoded in    * properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds    * (ms), seconds (s), minutes (m), hours (h), and days (d).    * @param name Property name    * @param defaultValue Value returned if no mapping exists.    * @param unit Unit to convert the stored property, if it exists.    * @throws NumberFormatException If the property stripped of its unit is not    *         a number    */
DECL|method|getTimeDuration (String name, long defaultValue, TimeUnit unit)
specifier|public
name|long
name|getTimeDuration
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|defaultValue
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|String
name|vStr
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|vStr
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
else|else
block|{
return|return
name|getTimeDurationHelper
argument_list|(
name|name
argument_list|,
name|vStr
argument_list|,
name|unit
argument_list|)
return|;
block|}
block|}
DECL|method|getTimeDuration (String name, String defaultValue, TimeUnit unit)
specifier|public
name|long
name|getTimeDuration
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|defaultValue
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|String
name|vStr
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|vStr
condition|)
block|{
return|return
name|getTimeDurationHelper
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|,
name|unit
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getTimeDurationHelper
argument_list|(
name|name
argument_list|,
name|vStr
argument_list|,
name|unit
argument_list|)
return|;
block|}
block|}
comment|/**    * Return time duration in the given time unit. Valid units are encoded in    * properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds    * (ms), seconds (s), minutes (m), hours (h), and days (d).    * @param name Property name    * @param vStr The string value with time unit suffix to be converted.    * @param unit Unit to convert the stored property, if it exists.    */
DECL|method|getTimeDurationHelper (String name, String vStr, TimeUnit unit)
specifier|public
name|long
name|getTimeDurationHelper
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|vStr
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|vStr
operator|=
name|vStr
operator|.
name|trim
argument_list|()
expr_stmt|;
name|vStr
operator|=
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|vStr
argument_list|)
expr_stmt|;
name|ParsedTimeDuration
name|vUnit
init|=
name|ParsedTimeDuration
operator|.
name|unitFor
argument_list|(
name|vStr
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|vUnit
condition|)
block|{
name|logDeprecation
argument_list|(
literal|"No unit for "
operator|+
name|name
operator|+
literal|"("
operator|+
name|vStr
operator|+
literal|") assuming "
operator|+
name|unit
argument_list|)
expr_stmt|;
name|vUnit
operator|=
name|ParsedTimeDuration
operator|.
name|unitFor
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vStr
operator|=
name|vStr
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|vStr
operator|.
name|lastIndexOf
argument_list|(
name|vUnit
operator|.
name|suffix
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|raw
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|vStr
argument_list|)
decl_stmt|;
name|long
name|converted
init|=
name|unit
operator|.
name|convert
argument_list|(
name|raw
argument_list|,
name|vUnit
operator|.
name|unit
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|vUnit
operator|.
name|unit
argument_list|()
operator|.
name|convert
argument_list|(
name|converted
argument_list|,
name|unit
argument_list|)
operator|<
name|raw
condition|)
block|{
name|logDeprecation
argument_list|(
literal|"Possible loss of precision converting "
operator|+
name|vStr
operator|+
name|vUnit
operator|.
name|suffix
argument_list|()
operator|+
literal|" to "
operator|+
name|unit
operator|+
literal|" for "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|converted
return|;
block|}
DECL|method|getTimeDurations (String name, TimeUnit unit)
specifier|public
name|long
index|[]
name|getTimeDurations
parameter_list|(
name|String
name|name
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|String
index|[]
name|strings
init|=
name|getTrimmedStrings
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|long
index|[]
name|durations
init|=
operator|new
name|long
index|[
name|strings
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|durations
index|[
name|i
index|]
operator|=
name|getTimeDurationHelper
argument_list|(
name|name
argument_list|,
name|strings
index|[
name|i
index|]
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
name|durations
return|;
block|}
comment|/**    * Gets the Storage Size from the config, or returns the defaultValue. The    * unit of return value is specified in target unit.    *    * @param name - Key Name    * @param defaultValue - Default Value -- e.g. 100MB    * @param targetUnit - The units that we want result to be in.    * @return double -- formatted in target Units    */
DECL|method|getStorageSize (String name, String defaultValue, StorageUnit targetUnit)
specifier|public
name|double
name|getStorageSize
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|defaultValue
parameter_list|,
name|StorageUnit
name|targetUnit
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isNotBlank
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"Key cannot be blank."
argument_list|)
expr_stmt|;
name|String
name|vString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|isBlank
argument_list|(
name|vString
argument_list|)
condition|)
block|{
name|vString
operator|=
name|defaultValue
expr_stmt|;
block|}
comment|// Please note: There is a bit of subtlety here. If the user specifies
comment|// the default unit as "1GB", but the requested unit is MB, we will return
comment|// the format in MB even thought the default string is specified in GB.
comment|// Converts a string like "1GB" to to unit specified in targetUnit.
name|StorageSize
name|measure
init|=
name|StorageSize
operator|.
name|parse
argument_list|(
name|vString
argument_list|)
decl_stmt|;
return|return
name|convertStorageUnit
argument_list|(
name|measure
operator|.
name|getValue
argument_list|()
argument_list|,
name|measure
operator|.
name|getUnit
argument_list|()
argument_list|,
name|targetUnit
argument_list|)
return|;
block|}
comment|/**    * Gets storage size from a config file.    *    * @param name - Key to read.    * @param defaultValue - The default value to return in case the key is    * not present.    * @param targetUnit - The Storage unit that should be used    * for the return value.    * @return - double value in the Storage Unit specified.    */
DECL|method|getStorageSize (String name, double defaultValue, StorageUnit targetUnit)
specifier|public
name|double
name|getStorageSize
parameter_list|(
name|String
name|name
parameter_list|,
name|double
name|defaultValue
parameter_list|,
name|StorageUnit
name|targetUnit
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|targetUnit
argument_list|,
literal|"Conversion unit cannot be null."
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isNotBlank
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"Name cannot be blank."
argument_list|)
expr_stmt|;
name|String
name|vString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|isBlank
argument_list|(
name|vString
argument_list|)
condition|)
block|{
return|return
name|targetUnit
operator|.
name|getDefault
argument_list|(
name|defaultValue
argument_list|)
return|;
block|}
name|StorageSize
name|measure
init|=
name|StorageSize
operator|.
name|parse
argument_list|(
name|vString
argument_list|)
decl_stmt|;
return|return
name|convertStorageUnit
argument_list|(
name|measure
operator|.
name|getValue
argument_list|()
argument_list|,
name|measure
operator|.
name|getUnit
argument_list|()
argument_list|,
name|targetUnit
argument_list|)
return|;
block|}
comment|/**    * Sets Storage Size for the specified key.    *    * @param name - Key to set.    * @param value - The numeric value to set.    * @param unit - Storage Unit to be used.    */
DECL|method|setStorageSize (String name, double value, StorageUnit unit)
specifier|public
name|void
name|setStorageSize
parameter_list|(
name|String
name|name
parameter_list|,
name|double
name|value
parameter_list|,
name|StorageUnit
name|unit
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|value
operator|+
name|unit
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * convert the value from one storage unit to another.    *    * @param value - value    * @param sourceUnit - Source unit to convert from    * @param targetUnit - target unit.    * @return double.    */
DECL|method|convertStorageUnit (double value, StorageUnit sourceUnit, StorageUnit targetUnit)
specifier|private
name|double
name|convertStorageUnit
parameter_list|(
name|double
name|value
parameter_list|,
name|StorageUnit
name|sourceUnit
parameter_list|,
name|StorageUnit
name|targetUnit
parameter_list|)
block|{
name|double
name|byteValue
init|=
name|sourceUnit
operator|.
name|toBytes
argument_list|(
name|value
argument_list|)
decl_stmt|;
return|return
name|targetUnit
operator|.
name|fromBytes
argument_list|(
name|byteValue
argument_list|)
return|;
block|}
comment|/**    * Get the value of the<code>name</code> property as a<code>Pattern</code>.    * If no such property is specified, or if the specified value is not a valid    *<code>Pattern</code>, then<code>DefaultValue</code> is returned.    * Note that the returned value is NOT trimmed by this method.    *    * @param name property name    * @param defaultValue default value    * @return property value as a compiled Pattern, or defaultValue    */
DECL|method|getPattern (String name, Pattern defaultValue)
specifier|public
name|Pattern
name|getPattern
parameter_list|(
name|String
name|name
parameter_list|,
name|Pattern
name|defaultValue
parameter_list|)
block|{
name|String
name|valString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|valString
operator|||
name|valString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
try|try
block|{
return|return
name|Pattern
operator|.
name|compile
argument_list|(
name|valString
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|pse
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Regular expression '"
operator|+
name|valString
operator|+
literal|"' for property '"
operator|+
name|name
operator|+
literal|"' not valid. Using default"
argument_list|,
name|pse
argument_list|)
expr_stmt|;
return|return
name|defaultValue
return|;
block|}
block|}
comment|/**    * Set the given property to<code>Pattern</code>.    * If the pattern is passed as null, sets the empty pattern which results in    * further calls to getPattern(...) returning the default value.    *    * @param name property name    * @param pattern new value    */
DECL|method|setPattern (String name, Pattern pattern)
specifier|public
name|void
name|setPattern
parameter_list|(
name|String
name|name
parameter_list|,
name|Pattern
name|pattern
parameter_list|)
block|{
assert|assert
name|pattern
operator|!=
literal|null
operator|:
literal|"Pattern cannot be null"
assert|;
name|set
argument_list|(
name|name
argument_list|,
name|pattern
operator|.
name|pattern
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets information about why a property was set.  Typically this is the     * path to the resource objects (file, URL, etc.) the property came from, but    * it can also indicate that it was set programmatically, or because of the    * command line.    *    * @param name - The property name to get the source of.    * @return null - If the property or its source wasn't found. Otherwise,     * returns a list of the sources of the resource.  The older sources are    * the first ones in the list.  So for example if a configuration is set from    * the command line, and then written out to a file that is read back in the    * first entry would indicate that it was set from the command line, while    * the second one would indicate the file that the new configuration was read    * in from.    */
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|method|getPropertySources (String name)
specifier|public
specifier|synchronized
name|String
index|[]
name|getPropertySources
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
comment|// If properties is null, it means a resource was newly added
comment|// but the props were cleared so as to load it upon future
comment|// requests. So lets force a load by asking a properties list.
name|getProps
argument_list|()
expr_stmt|;
block|}
comment|// Return a null right away if our properties still
comment|// haven't loaded or the resource mapping isn't defined
if|if
condition|(
name|properties
operator|==
literal|null
operator|||
name|updatingResource
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|String
index|[]
name|source
init|=
name|updatingResource
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|source
argument_list|,
name|source
operator|.
name|length
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * A class that represents a set of positive integer ranges. It parses     * strings of the form: "2-3,5,7-" where ranges are separated by comma and     * the lower/upper bounds are separated by dash. Either the lower or upper     * bound may be omitted meaning all values up to or over. So the string     * above means 2, 3, 5, and 7, 8, 9, ...    */
DECL|class|IntegerRanges
specifier|public
specifier|static
class|class
name|IntegerRanges
implements|implements
name|Iterable
argument_list|<
name|Integer
argument_list|>
block|{
DECL|class|Range
specifier|private
specifier|static
class|class
name|Range
block|{
DECL|field|start
name|int
name|start
decl_stmt|;
DECL|field|end
name|int
name|end
decl_stmt|;
block|}
DECL|class|RangeNumberIterator
specifier|private
specifier|static
class|class
name|RangeNumberIterator
implements|implements
name|Iterator
argument_list|<
name|Integer
argument_list|>
block|{
DECL|field|internal
name|Iterator
argument_list|<
name|Range
argument_list|>
name|internal
decl_stmt|;
DECL|field|at
name|int
name|at
decl_stmt|;
DECL|field|end
name|int
name|end
decl_stmt|;
DECL|method|RangeNumberIterator (List<Range> ranges)
specifier|public
name|RangeNumberIterator
parameter_list|(
name|List
argument_list|<
name|Range
argument_list|>
name|ranges
parameter_list|)
block|{
if|if
condition|(
name|ranges
operator|!=
literal|null
condition|)
block|{
name|internal
operator|=
name|ranges
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
name|at
operator|=
operator|-
literal|1
expr_stmt|;
name|end
operator|=
operator|-
literal|2
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|at
operator|<=
name|end
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|internal
operator|!=
literal|null
condition|)
block|{
return|return
name|internal
operator|.
name|hasNext
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|Integer
name|next
parameter_list|()
block|{
if|if
condition|(
name|at
operator|<=
name|end
condition|)
block|{
name|at
operator|++
expr_stmt|;
return|return
name|at
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|internal
operator|!=
literal|null
condition|)
block|{
name|Range
name|found
init|=
name|internal
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
name|at
operator|=
name|found
operator|.
name|start
expr_stmt|;
name|end
operator|=
name|found
operator|.
name|end
expr_stmt|;
name|at
operator|++
expr_stmt|;
return|return
name|at
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
empty_stmt|;
DECL|field|ranges
name|List
argument_list|<
name|Range
argument_list|>
name|ranges
init|=
operator|new
name|ArrayList
argument_list|<
name|Range
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|IntegerRanges ()
specifier|public
name|IntegerRanges
parameter_list|()
block|{     }
DECL|method|IntegerRanges (String newValue)
specifier|public
name|IntegerRanges
parameter_list|(
name|String
name|newValue
parameter_list|)
block|{
name|StringTokenizer
name|itr
init|=
operator|new
name|StringTokenizer
argument_list|(
name|newValue
argument_list|,
literal|","
argument_list|)
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|rng
init|=
name|itr
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|rng
operator|.
name|split
argument_list|(
literal|"-"
argument_list|,
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
argument_list|<
literal|1
operator|||
name|parts
operator|.
name|length
argument_list|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"integer range badly formed: "
operator|+
name|rng
argument_list|)
throw|;
block|}
name|Range
name|r
init|=
operator|new
name|Range
argument_list|()
decl_stmt|;
name|r
operator|.
name|start
operator|=
name|convertToInt
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|r
operator|.
name|end
operator|=
name|convertToInt
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|.
name|end
operator|=
name|r
operator|.
name|start
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|start
operator|>
name|r
operator|.
name|end
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"IntegerRange from "
operator|+
name|r
operator|.
name|start
operator|+
literal|" to "
operator|+
name|r
operator|.
name|end
operator|+
literal|" is invalid"
argument_list|)
throw|;
block|}
name|ranges
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Convert a string to an int treating empty strings as the default value.      * @param value the string value      * @param defaultValue the value for if the string is empty      * @return the desired integer      */
DECL|method|convertToInt (String value, int defaultValue)
specifier|private
specifier|static
name|int
name|convertToInt
parameter_list|(
name|String
name|value
parameter_list|,
name|int
name|defaultValue
parameter_list|)
block|{
name|String
name|trim
init|=
name|value
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|trim
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|trim
argument_list|)
return|;
block|}
comment|/**      * Is the given value in the set of ranges      * @param value the value to check      * @return is the value in the ranges?      */
DECL|method|isIncluded (int value)
specifier|public
name|boolean
name|isIncluded
parameter_list|(
name|int
name|value
parameter_list|)
block|{
for|for
control|(
name|Range
name|r
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|r
operator|.
name|start
operator|<=
name|value
operator|&&
name|value
operator|<=
name|r
operator|.
name|end
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * @return true if there are no values in this range, else false.      */
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|ranges
operator|==
literal|null
operator|||
name|ranges
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Range
name|r
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
name|r
operator|.
name|start
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|r
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Get range start for the first integer range.      * @return range start.      */
DECL|method|getRangeStart ()
specifier|public
name|int
name|getRangeStart
parameter_list|()
block|{
if|if
condition|(
name|ranges
operator|==
literal|null
operator|||
name|ranges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|Range
name|r
init|=
name|ranges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|r
operator|.
name|start
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|RangeNumberIterator
argument_list|(
name|ranges
argument_list|)
return|;
block|}
block|}
comment|/**    * Parse the given attribute as a set of integer ranges    * @param name the attribute name    * @param defaultValue the default value if it is not set    * @return a new set of ranges from the configured value    */
DECL|method|getRange (String name, String defaultValue)
specifier|public
name|IntegerRanges
name|getRange
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
return|return
operator|new
name|IntegerRanges
argument_list|(
name|get
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|)
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * a collection of<code>String</code>s.      * If no such property is specified then empty collection is returned.    *<p>    * This is an optimized version of {@link #getStrings(String)}    *     * @param name property name.    * @return property value as a collection of<code>String</code>s.     */
DECL|method|getStringCollection (String name)
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getStringCollection
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|StringUtils
operator|.
name|getStringCollection
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * an array of<code>String</code>s.      * If no such property is specified then<code>null</code> is returned.    *     * @param name property name.    * @return property value as an array of<code>String</code>s,     *         or<code>null</code>.     */
DECL|method|getStrings (String name)
specifier|public
name|String
index|[]
name|getStrings
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|StringUtils
operator|.
name|getStrings
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * an array of<code>String</code>s.      * If no such property is specified then default value is returned.    *     * @param name property name.    * @param defaultValue The default value    * @return property value as an array of<code>String</code>s,     *         or default value.     */
DECL|method|getStrings (String name, String... defaultValue)
specifier|public
name|String
index|[]
name|getStrings
parameter_list|(
name|String
name|name
parameter_list|,
name|String
modifier|...
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
else|else
block|{
return|return
name|StringUtils
operator|.
name|getStrings
argument_list|(
name|valueString
argument_list|)
return|;
block|}
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * a collection of<code>String</code>s, trimmed of the leading and trailing whitespace.      * If no such property is specified then empty<code>Collection</code> is returned.    *    * @param name property name.    * @return property value as a collection of<code>String</code>s, or empty<code>Collection</code>     */
DECL|method|getTrimmedStringCollection (String name)
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getTrimmedStringCollection
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|valueString
condition|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|empty
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
return|return
name|empty
return|;
block|}
return|return
name|StringUtils
operator|.
name|getTrimmedStringCollection
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * an array of<code>String</code>s, trimmed of the leading and trailing whitespace.    * If no such property is specified then an empty array is returned.    *     * @param name property name.    * @return property value as an array of trimmed<code>String</code>s,     *         or empty array.     */
DECL|method|getTrimmedStrings (String name)
specifier|public
name|String
index|[]
name|getTrimmedStrings
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * an array of<code>String</code>s, trimmed of the leading and trailing whitespace.    * If no such property is specified then default value is returned.    *     * @param name property name.    * @param defaultValue The default value    * @return property value as an array of trimmed<code>String</code>s,     *         or default value.     */
DECL|method|getTrimmedStrings (String name, String... defaultValue)
specifier|public
name|String
index|[]
name|getTrimmedStrings
parameter_list|(
name|String
name|name
parameter_list|,
name|String
modifier|...
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|valueString
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
else|else
block|{
return|return
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|valueString
argument_list|)
return|;
block|}
block|}
comment|/**     * Set the array of string values for the<code>name</code> property as     * as comma delimited values.      *     * @param name property name.    * @param values The values    */
DECL|method|setStrings (String name, String... values)
specifier|public
name|void
name|setStrings
parameter_list|(
name|String
name|name
parameter_list|,
name|String
modifier|...
name|values
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|StringUtils
operator|.
name|arrayToString
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the value for a known password configuration element.    * In order to enable the elimination of clear text passwords in config,    * this method attempts to resolve the property name as an alias through    * the CredentialProvider API and conditionally fallsback to config.    * @param name property name    * @return password    */
DECL|method|getPassword (String name)
specifier|public
name|char
index|[]
name|getPassword
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|char
index|[]
name|pass
init|=
literal|null
decl_stmt|;
name|pass
operator|=
name|getPasswordFromCredentialProviders
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|null
condition|)
block|{
name|pass
operator|=
name|getPasswordFromConfig
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|pass
return|;
block|}
comment|/**    * Get the credential entry by name from a credential provider.    *    * Handle key deprecation.    *    * @param provider a credential provider    * @param name alias of the credential    * @return the credential entry or null if not found    */
DECL|method|getCredentialEntry (CredentialProvider provider, String name)
specifier|private
name|CredentialEntry
name|getCredentialEntry
parameter_list|(
name|CredentialProvider
name|provider
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|CredentialEntry
name|entry
init|=
name|provider
operator|.
name|getCredentialEntry
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
return|return
name|entry
return|;
block|}
comment|// The old name is stored in the credential provider.
name|String
name|oldName
init|=
name|getDeprecatedKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldName
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|provider
operator|.
name|getCredentialEntry
argument_list|(
name|oldName
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|logDeprecationOnce
argument_list|(
name|oldName
argument_list|,
name|provider
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
block|}
comment|// The name is deprecated.
name|DeprecatedKeyInfo
name|keyInfo
init|=
name|getDeprecatedKeyInfo
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyInfo
operator|!=
literal|null
operator|&&
name|keyInfo
operator|.
name|newKeys
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|newName
range|:
name|keyInfo
operator|.
name|newKeys
control|)
block|{
name|entry
operator|=
name|provider
operator|.
name|getCredentialEntry
argument_list|(
name|newName
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|logDeprecationOnce
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Try and resolve the provided element name as a credential provider    * alias.    * @param name alias of the provisioned credential    * @return password or null if not found    * @throws IOException    */
DECL|method|getPasswordFromCredentialProviders (String name)
specifier|public
name|char
index|[]
name|getPasswordFromCredentialProviders
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|char
index|[]
name|pass
init|=
literal|null
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|CredentialProvider
argument_list|>
name|providers
init|=
name|CredentialProviderFactory
operator|.
name|getProviders
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|providers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|CredentialProvider
name|provider
range|:
name|providers
control|)
block|{
try|try
block|{
name|CredentialEntry
name|entry
init|=
name|getCredentialEntry
argument_list|(
name|provider
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|pass
operator|=
name|entry
operator|.
name|getCredential
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't get key "
operator|+
name|name
operator|+
literal|" from key provider"
operator|+
literal|"of type: "
operator|+
name|provider
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"."
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Configuration problem with provider path."
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
return|return
name|pass
return|;
block|}
comment|/**    * Fallback to clear text passwords in configuration.    * @param name    * @return clear text password or null    */
DECL|method|getPasswordFromConfig (String name)
specifier|protected
name|char
index|[]
name|getPasswordFromConfig
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|char
index|[]
name|pass
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|getBoolean
argument_list|(
name|CredentialProvider
operator|.
name|CLEAR_TEXT_FALLBACK
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_CREDENTIAL_CLEAR_TEXT_FALLBACK_DEFAULT
argument_list|)
condition|)
block|{
name|String
name|passStr
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|passStr
operator|!=
literal|null
condition|)
block|{
name|pass
operator|=
name|passStr
operator|.
name|toCharArray
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|pass
return|;
block|}
comment|/**    * Get the socket address for<code>hostProperty</code> as a    *<code>InetSocketAddress</code>. If<code>hostProperty</code> is    *<code>null</code>,<code>addressProperty</code> will be used. This    * is useful for cases where we want to differentiate between host    * bind address and address clients should use to establish connection.    *    * @param hostProperty bind host property name.    * @param addressProperty address property name.    * @param defaultAddressValue the default value    * @param defaultPort the default port    * @return InetSocketAddress    */
DECL|method|getSocketAddr ( String hostProperty, String addressProperty, String defaultAddressValue, int defaultPort)
specifier|public
name|InetSocketAddress
name|getSocketAddr
parameter_list|(
name|String
name|hostProperty
parameter_list|,
name|String
name|addressProperty
parameter_list|,
name|String
name|defaultAddressValue
parameter_list|,
name|int
name|defaultPort
parameter_list|)
block|{
name|InetSocketAddress
name|bindAddr
init|=
name|getSocketAddr
argument_list|(
name|addressProperty
argument_list|,
name|defaultAddressValue
argument_list|,
name|defaultPort
argument_list|)
decl_stmt|;
specifier|final
name|String
name|host
init|=
name|get
argument_list|(
name|hostProperty
argument_list|)
decl_stmt|;
if|if
condition|(
name|host
operator|==
literal|null
operator|||
name|host
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|bindAddr
return|;
block|}
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|host
argument_list|,
name|bindAddr
operator|.
name|getPort
argument_list|()
argument_list|,
name|hostProperty
argument_list|)
return|;
block|}
comment|/**    * Get the socket address for<code>name</code> property as a    *<code>InetSocketAddress</code>.    * @param name property name.    * @param defaultAddress the default value    * @param defaultPort the default port    * @return InetSocketAddress    */
DECL|method|getSocketAddr ( String name, String defaultAddress, int defaultPort)
specifier|public
name|InetSocketAddress
name|getSocketAddr
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|defaultAddress
parameter_list|,
name|int
name|defaultPort
parameter_list|)
block|{
specifier|final
name|String
name|address
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|,
name|defaultAddress
argument_list|)
decl_stmt|;
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|address
argument_list|,
name|defaultPort
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/**    * Set the socket address for the<code>name</code> property as    * a<code>host:port</code>.    */
DECL|method|setSocketAddr (String name, InetSocketAddress addr)
specifier|public
name|void
name|setSocketAddr
parameter_list|(
name|String
name|name
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the socket address a client can use to connect for the    *<code>name</code> property as a<code>host:port</code>.  The wildcard    * address is replaced with the local host's address. If the host and address    * properties are configured the host component of the address will be combined    * with the port component of the addr to generate the address.  This is to allow    * optional control over which host name is used in multi-home bind-host    * cases where a host can have multiple names    * @param hostProperty the bind-host configuration name    * @param addressProperty the service address configuration name    * @param defaultAddressValue the service default address configuration value    * @param addr InetSocketAddress of the service listener    * @return InetSocketAddress for clients to connect    */
DECL|method|updateConnectAddr ( String hostProperty, String addressProperty, String defaultAddressValue, InetSocketAddress addr)
specifier|public
name|InetSocketAddress
name|updateConnectAddr
parameter_list|(
name|String
name|hostProperty
parameter_list|,
name|String
name|addressProperty
parameter_list|,
name|String
name|defaultAddressValue
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|)
block|{
specifier|final
name|String
name|host
init|=
name|get
argument_list|(
name|hostProperty
argument_list|)
decl_stmt|;
specifier|final
name|String
name|connectHostPort
init|=
name|getTrimmed
argument_list|(
name|addressProperty
argument_list|,
name|defaultAddressValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|host
operator|==
literal|null
operator|||
name|host
operator|.
name|isEmpty
argument_list|()
operator|||
name|connectHostPort
operator|==
literal|null
operator|||
name|connectHostPort
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//not our case, fall back to original logic
return|return
name|updateConnectAddr
argument_list|(
name|addressProperty
argument_list|,
name|addr
argument_list|)
return|;
block|}
specifier|final
name|String
name|connectHost
init|=
name|connectHostPort
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
comment|// Create connect address using client address hostname and server port.
return|return
name|updateConnectAddr
argument_list|(
name|addressProperty
argument_list|,
name|NetUtils
operator|.
name|createSocketAddrForHost
argument_list|(
name|connectHost
argument_list|,
name|addr
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Set the socket address a client can use to connect for the    *<code>name</code> property as a<code>host:port</code>.  The wildcard    * address is replaced with the local host's address.    * @param name property name.    * @param addr InetSocketAddress of a listener to store in the given property    * @return InetSocketAddress for clients to connect    */
DECL|method|updateConnectAddr (String name, InetSocketAddress addr)
specifier|public
name|InetSocketAddress
name|updateConnectAddr
parameter_list|(
name|String
name|name
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|)
block|{
specifier|final
name|InetSocketAddress
name|connectAddr
init|=
name|NetUtils
operator|.
name|getConnectAddress
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|setSocketAddr
argument_list|(
name|name
argument_list|,
name|connectAddr
argument_list|)
expr_stmt|;
return|return
name|connectAddr
return|;
block|}
comment|/**    * Load a class by name.    *     * @param name the class name.    * @return the class object.    * @throws ClassNotFoundException if the class is not found.    */
DECL|method|getClassByName (String name)
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getClassByName
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|ret
init|=
name|getClassByNameOrNull
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassNotFoundException
argument_list|(
literal|"Class "
operator|+
name|name
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Load a class by name, returning null rather than throwing an exception    * if it couldn't be loaded. This is to avoid the overhead of creating    * an exception.    *     * @param name the class name    * @return the class object, or null if it could not be found.    */
DECL|method|getClassByNameOrNull (String name)
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getClassByNameOrNull
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|WeakReference
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
name|map
decl_stmt|;
synchronized|synchronized
init|(
name|CACHE_CLASSES
init|)
block|{
name|map
operator|=
name|CACHE_CLASSES
operator|.
name|get
argument_list|(
name|classLoader
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
name|map
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|WeakHashMap
argument_list|<
name|String
argument_list|,
name|WeakReference
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|CACHE_CLASSES
operator|.
name|put
argument_list|(
name|classLoader
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
name|WeakReference
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|ref
init|=
name|map
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|!=
literal|null
condition|)
block|{
name|clazz
operator|=
name|ref
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|classLoader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// Leave a marker that the class isn't found
name|map
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|new
name|WeakReference
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|NEGATIVE_CACHE_SENTINEL
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// two putters can race here, but they'll put the same class
name|map
operator|.
name|put
argument_list|(
name|name
argument_list|,
operator|new
name|WeakReference
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|clazz
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|clazz
return|;
block|}
elseif|else
if|if
condition|(
name|clazz
operator|==
name|NEGATIVE_CACHE_SENTINEL
condition|)
block|{
return|return
literal|null
return|;
comment|// not found
block|}
else|else
block|{
comment|// cache hit
return|return
name|clazz
return|;
block|}
block|}
comment|/**     * Get the value of the<code>name</code> property    * as an array of<code>Class</code>.    * The value of the property specifies a list of comma separated class names.      * If no such property is specified, then<code>defaultValue</code> is     * returned.    *     * @param name the property name.    * @param defaultValue default value.    * @return property value as a<code>Class[]</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getClasses (String name, Class<?> ... defaultValue)
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|getClasses
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getRaw
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|valueString
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
name|String
index|[]
name|classnames
init|=
name|getTrimmedStrings
argument_list|(
name|name
argument_list|)
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|classes
init|=
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[
name|classnames
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|classnames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|classes
index|[
name|i
index|]
operator|=
name|getClassByName
argument_list|(
name|classnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|classes
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>Class</code>.      * If no such property is specified, then<code>defaultValue</code> is     * returned.    *     * @param name the class name.    * @param defaultValue default value.    * @return property value as a<code>Class</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getClass (String name, Class<?> defaultValue)
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getClass
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
try|try
block|{
return|return
name|getClassByName
argument_list|(
name|valueString
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>Class</code>    * implementing the interface specified by<code>xface</code>.    *       * If no such property is specified, then<code>defaultValue</code> is     * returned.    *     * An exception is thrown if the returned class does not implement the named    * interface.     *     * @param name the class name.    * @param defaultValue default value.    * @param xface the interface implemented by the named class.    * @return property value as a<code>Class</code>,     *         or<code>defaultValue</code>.    */
DECL|method|getClass (String name, Class<? extends U> defaultValue, Class<U> xface)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|Class
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|getClass
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|defaultValue
parameter_list|,
name|Class
argument_list|<
name|U
argument_list|>
name|xface
parameter_list|)
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|theClass
init|=
name|getClass
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|theClass
operator|!=
literal|null
operator|&&
operator|!
name|xface
operator|.
name|isAssignableFrom
argument_list|(
name|theClass
argument_list|)
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|theClass
operator|+
literal|" not "
operator|+
name|xface
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
elseif|else
if|if
condition|(
name|theClass
operator|!=
literal|null
condition|)
return|return
name|theClass
operator|.
name|asSubclass
argument_list|(
name|xface
argument_list|)
return|;
else|else
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the value of the<code>name</code> property as a<code>List</code>    * of objects implementing the interface specified by<code>xface</code>.    *     * An exception is thrown if any of the classes does not exist, or if it does    * not implement the named interface.    *     * @param name the property name.    * @param xface the interface implemented by the classes named by    *<code>name</code>.    * @return a<code>List</code> of objects implementing<code>xface</code>.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getInstances (String name, Class<U> xface)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|List
argument_list|<
name|U
argument_list|>
name|getInstances
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|U
argument_list|>
name|xface
parameter_list|)
block|{
name|List
argument_list|<
name|U
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|classes
init|=
name|getClasses
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|cl
range|:
name|classes
control|)
block|{
if|if
condition|(
operator|!
name|xface
operator|.
name|isAssignableFrom
argument_list|(
name|cl
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|cl
operator|+
literal|" does not implement "
operator|+
name|xface
argument_list|)
throw|;
block|}
name|ret
operator|.
name|add
argument_list|(
operator|(
name|U
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|cl
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**     * Set the value of the<code>name</code> property to the name of a     *<code>theClass</code> implementing the given interface<code>xface</code>.    *     * An exception is thrown if<code>theClass</code> does not implement the     * interface<code>xface</code>.     *     * @param name property name.    * @param theClass property value.    * @param xface the interface implemented by the named class.    */
DECL|method|setClass (String name, Class<?> theClass, Class<?> xface)
specifier|public
name|void
name|setClass
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|theClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|xface
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xface
operator|.
name|isAssignableFrom
argument_list|(
name|theClass
argument_list|)
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|theClass
operator|+
literal|" not "
operator|+
name|xface
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|set
argument_list|(
name|name
argument_list|,
name|theClass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**     * Get a local file under a directory named by<i>dirsProp</i> with    * the given<i>path</i>.  If<i>dirsProp</i> contains multiple directories,    * then one is chosen based on<i>path</i>'s hash code.  If the selected    * directory does not exist, an attempt is made to create it.    *     * @param dirsProp directory in which to locate the file.    * @param path file-path.    * @return local file under the directory with the given path.    */
DECL|method|getLocalPath (String dirsProp, String path)
specifier|public
name|Path
name|getLocalPath
parameter_list|(
name|String
name|dirsProp
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|dirs
init|=
name|getTrimmedStrings
argument_list|(
name|dirsProp
argument_list|)
decl_stmt|;
name|int
name|hashCode
init|=
name|path
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|this
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// try each local dir
name|int
name|index
init|=
operator|(
name|hashCode
operator|+
name|i
operator|&
name|Integer
operator|.
name|MAX_VALUE
operator|)
operator|%
name|dirs
operator|.
name|length
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|dirs
index|[
name|index
index|]
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|Path
name|dir
init|=
name|file
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
operator|||
name|fs
operator|.
name|exists
argument_list|(
name|dir
argument_list|)
condition|)
block|{
return|return
name|file
return|;
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not make "
operator|+
name|path
operator|+
literal|" in local directories from "
operator|+
name|dirsProp
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
name|hashCode
operator|+
name|i
operator|&
name|Integer
operator|.
name|MAX_VALUE
operator|)
operator|%
name|dirs
operator|.
name|length
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|dirsProp
operator|+
literal|"["
operator|+
name|index
operator|+
literal|"]="
operator|+
name|dirs
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No valid local directories in property: "
operator|+
name|dirsProp
argument_list|)
throw|;
block|}
comment|/**     * Get a local file name under a directory named in<i>dirsProp</i> with    * the given<i>path</i>.  If<i>dirsProp</i> contains multiple directories,    * then one is chosen based on<i>path</i>'s hash code.  If the selected    * directory does not exist, an attempt is made to create it.    *     * @param dirsProp directory in which to locate the file.    * @param path file-path.    * @return local file under the directory with the given path.    */
DECL|method|getFile (String dirsProp, String path)
specifier|public
name|File
name|getFile
parameter_list|(
name|String
name|dirsProp
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|dirs
init|=
name|getTrimmedStrings
argument_list|(
name|dirsProp
argument_list|)
decl_stmt|;
name|int
name|hashCode
init|=
name|path
operator|.
name|hashCode
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// try each local dir
name|int
name|index
init|=
operator|(
name|hashCode
operator|+
name|i
operator|&
name|Integer
operator|.
name|MAX_VALUE
operator|)
operator|%
name|dirs
operator|.
name|length
decl_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dirs
index|[
name|index
index|]
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|File
name|dir
init|=
name|file
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|exists
argument_list|()
operator|||
name|dir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
return|return
name|file
return|;
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No valid local directories in property: "
operator|+
name|dirsProp
argument_list|)
throw|;
block|}
comment|/**     * Get the {@link URL} for the named resource.    *     * @param name resource name.    * @return the url for the named resource.    */
DECL|method|getResource (String name)
specifier|public
name|URL
name|getResource
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|classLoader
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**     * Get an input stream attached to the configuration resource with the    * given<code>name</code>.    *     * @param name configuration resource name.    * @return an input stream attached to the resource.    */
DECL|method|getConfResourceAsInputStream (String name)
specifier|public
name|InputStream
name|getConfResourceAsInputStream
parameter_list|(
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|URL
name|url
init|=
name|getResource
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"found resource "
operator|+
name|name
operator|+
literal|" at "
operator|+
name|url
argument_list|)
expr_stmt|;
block|}
return|return
name|url
operator|.
name|openStream
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**     * Get a {@link Reader} attached to the configuration resource with the    * given<code>name</code>.    *     * @param name configuration resource name.    * @return a reader attached to the resource.    */
DECL|method|getConfResourceAsReader (String name)
specifier|public
name|Reader
name|getConfResourceAsReader
parameter_list|(
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|URL
name|url
init|=
name|getResource
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"found resource "
operator|+
name|name
operator|+
literal|" at "
operator|+
name|url
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|InputStreamReader
argument_list|(
name|url
operator|.
name|openStream
argument_list|()
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get the set of parameters marked final.    *    * @return final parameter set.    */
DECL|method|getFinalParameters ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getFinalParameters
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|setFinalParams
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|setFinalParams
operator|.
name|addAll
argument_list|(
name|finalParameters
argument_list|)
expr_stmt|;
return|return
name|setFinalParams
return|;
block|}
DECL|method|getProps ()
specifier|protected
specifier|synchronized
name|Properties
name|getProps
parameter_list|()
block|{
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
name|properties
operator|=
operator|new
name|Properties
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|backup
init|=
name|updatingResource
operator|!=
literal|null
condition|?
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
argument_list|(
name|updatingResource
argument_list|)
else|:
literal|null
decl_stmt|;
name|loadResources
argument_list|(
name|properties
argument_list|,
name|resources
argument_list|,
name|quietmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlay
operator|!=
literal|null
condition|)
block|{
name|properties
operator|.
name|putAll
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
if|if
condition|(
name|backup
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|overlay
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
index|[]
name|source
init|=
name|backup
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
name|updatingResource
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|properties
return|;
block|}
comment|/**    * Return the number of keys in the configuration.    *    * @return number of keys in the configuration.    */
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|getProps
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Clears all keys from the configuration.    */
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|getProps
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|getOverlay
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get an {@link Iterator} to go through the list of<code>String</code>     * key-value pairs in the configuration.    *     * @return an iterator over the entries.    */
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
comment|// Get a copy of just the string to string pairs. After the old object
comment|// methods that allow non-strings to be put into configurations are removed,
comment|// we could replace properties with a Map<String,String> and get rid of this
comment|// code.
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|getProps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|.
name|getKey
argument_list|()
operator|instanceof
name|String
operator|&&
name|item
operator|.
name|getValue
argument_list|()
operator|instanceof
name|String
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|item
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**    * Constructs a mapping of configuration and includes all properties that    * start with the specified configuration prefix.  Property names in the    * mapping are trimmed to remove the configuration prefix.    *    * @param confPrefix configuration prefix    * @return mapping of configuration properties with prefix stripped    */
DECL|method|getPropsWithPrefix (String confPrefix)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPropsWithPrefix
parameter_list|(
name|String
name|confPrefix
parameter_list|)
block|{
name|Properties
name|props
init|=
name|getProps
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|configMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|props
operator|.
name|stringPropertyNames
argument_list|()
control|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|confPrefix
argument_list|)
condition|)
block|{
name|String
name|value
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|keyName
init|=
name|name
operator|.
name|substring
argument_list|(
name|confPrefix
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|configMap
operator|.
name|put
argument_list|(
name|keyName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|configMap
return|;
block|}
DECL|method|parse (URL url, boolean restricted)
specifier|private
name|XMLStreamReader
name|parse
parameter_list|(
name|URL
name|url
parameter_list|,
name|boolean
name|restricted
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
block|{
if|if
condition|(
operator|!
name|quietmode
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"parsing URL "
operator|+
name|url
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|url
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|URLConnection
name|connection
init|=
name|url
operator|.
name|openConnection
argument_list|()
decl_stmt|;
if|if
condition|(
name|connection
operator|instanceof
name|JarURLConnection
condition|)
block|{
comment|// Disable caching for JarURLConnection to avoid sharing JarFile
comment|// with other users.
name|connection
operator|.
name|setUseCaches
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|parse
argument_list|(
name|connection
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|url
operator|.
name|toString
argument_list|()
argument_list|,
name|restricted
argument_list|)
return|;
block|}
DECL|method|parse (InputStream is, String systemIdStr, boolean restricted)
specifier|private
name|XMLStreamReader
name|parse
parameter_list|(
name|InputStream
name|is
parameter_list|,
name|String
name|systemIdStr
parameter_list|,
name|boolean
name|restricted
parameter_list|)
throws|throws
name|IOException
throws|,
name|XMLStreamException
block|{
if|if
condition|(
operator|!
name|quietmode
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"parsing input stream "
operator|+
name|is
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SystemId
name|systemId
init|=
name|SystemId
operator|.
name|construct
argument_list|(
name|systemIdStr
argument_list|)
decl_stmt|;
name|ReaderConfig
name|readerConfig
init|=
name|XML_INPUT_FACTORY
operator|.
name|createPrivateConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|restricted
condition|)
block|{
name|readerConfig
operator|.
name|setProperty
argument_list|(
name|XMLInputFactory
operator|.
name|SUPPORT_DTD
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|XML_INPUT_FACTORY
operator|.
name|createSR
argument_list|(
name|readerConfig
argument_list|,
name|systemId
argument_list|,
name|StreamBootstrapper
operator|.
name|getInstance
argument_list|(
literal|null
argument_list|,
name|systemId
argument_list|,
name|is
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|loadResources (Properties properties, ArrayList<Resource> resources, boolean quiet)
specifier|private
name|void
name|loadResources
parameter_list|(
name|Properties
name|properties
parameter_list|,
name|ArrayList
argument_list|<
name|Resource
argument_list|>
name|resources
parameter_list|,
name|boolean
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|loadDefaults
condition|)
block|{
for|for
control|(
name|String
name|resource
range|:
name|defaultResources
control|)
block|{
name|loadResource
argument_list|(
name|properties
argument_list|,
operator|new
name|Resource
argument_list|(
name|resource
argument_list|,
literal|false
argument_list|)
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|resources
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Resource
name|ret
init|=
name|loadResource
argument_list|(
name|properties
argument_list|,
name|resources
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|quiet
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|null
condition|)
block|{
name|resources
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|addTags
argument_list|(
name|properties
argument_list|)
expr_stmt|;
block|}
DECL|method|loadResource (Properties properties, Resource wrapper, boolean quiet)
specifier|private
name|Resource
name|loadResource
parameter_list|(
name|Properties
name|properties
parameter_list|,
name|Resource
name|wrapper
parameter_list|,
name|boolean
name|quiet
parameter_list|)
block|{
name|String
name|name
init|=
name|UNKNOWN_RESOURCE
decl_stmt|;
try|try
block|{
name|Object
name|resource
init|=
name|wrapper
operator|.
name|getResource
argument_list|()
decl_stmt|;
name|name
operator|=
name|wrapper
operator|.
name|getName
argument_list|()
expr_stmt|;
name|XMLStreamReader2
name|reader
init|=
literal|null
decl_stmt|;
name|boolean
name|returnCachedProperties
init|=
literal|false
decl_stmt|;
name|boolean
name|isRestricted
init|=
name|wrapper
operator|.
name|isParserRestricted
argument_list|()
decl_stmt|;
if|if
condition|(
name|resource
operator|instanceof
name|URL
condition|)
block|{
comment|// an URL resource
name|reader
operator|=
operator|(
name|XMLStreamReader2
operator|)
name|parse
argument_list|(
operator|(
name|URL
operator|)
name|resource
argument_list|,
name|isRestricted
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resource
operator|instanceof
name|String
condition|)
block|{
comment|// a CLASSPATH resource
name|URL
name|url
init|=
name|getResource
argument_list|(
operator|(
name|String
operator|)
name|resource
argument_list|)
decl_stmt|;
name|reader
operator|=
operator|(
name|XMLStreamReader2
operator|)
name|parse
argument_list|(
name|url
argument_list|,
name|isRestricted
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resource
operator|instanceof
name|Path
condition|)
block|{
comment|// a file resource
comment|// Can't use FileSystem API or we get an infinite loop
comment|// since FileSystem uses Configuration API.  Use java.io.File instead.
name|File
name|file
init|=
operator|new
name|File
argument_list|(
operator|(
operator|(
name|Path
operator|)
name|resource
operator|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"parsing File "
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
name|reader
operator|=
operator|(
name|XMLStreamReader2
operator|)
name|parse
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|,
operator|(
operator|(
name|Path
operator|)
name|resource
operator|)
operator|.
name|toString
argument_list|()
argument_list|,
name|isRestricted
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|resource
operator|instanceof
name|InputStream
condition|)
block|{
name|reader
operator|=
operator|(
name|XMLStreamReader2
operator|)
name|parse
argument_list|(
operator|(
name|InputStream
operator|)
name|resource
argument_list|,
literal|null
argument_list|,
name|isRestricted
argument_list|)
expr_stmt|;
name|returnCachedProperties
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resource
operator|instanceof
name|Properties
condition|)
block|{
name|overlay
argument_list|(
name|properties
argument_list|,
operator|(
name|Properties
operator|)
name|resource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
block|{
return|return
literal|null
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|resource
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
name|Properties
name|toAddTo
init|=
name|properties
decl_stmt|;
if|if
condition|(
name|returnCachedProperties
condition|)
block|{
name|toAddTo
operator|=
operator|new
name|Properties
argument_list|()
expr_stmt|;
block|}
name|DeprecationContext
name|deprecations
init|=
name|deprecationContext
operator|.
name|get
argument_list|()
decl_stmt|;
name|StringBuilder
name|token
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|confName
init|=
literal|null
decl_stmt|;
name|String
name|confValue
init|=
literal|null
decl_stmt|;
name|String
name|confInclude
init|=
literal|null
decl_stmt|;
name|String
name|confTag
init|=
literal|null
decl_stmt|;
name|boolean
name|confFinal
init|=
literal|false
decl_stmt|;
name|boolean
name|fallbackAllowed
init|=
literal|false
decl_stmt|;
name|boolean
name|fallbackEntered
init|=
literal|false
decl_stmt|;
name|boolean
name|parseToken
init|=
literal|false
decl_stmt|;
name|LinkedList
argument_list|<
name|String
argument_list|>
name|confSource
init|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|reader
operator|.
name|hasNext
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|reader
operator|.
name|next
argument_list|()
condition|)
block|{
case|case
name|XMLStreamConstants
operator|.
name|START_ELEMENT
case|:
switch|switch
condition|(
name|reader
operator|.
name|getLocalName
argument_list|()
condition|)
block|{
case|case
literal|"property"
case|:
name|confName
operator|=
literal|null
expr_stmt|;
name|confValue
operator|=
literal|null
expr_stmt|;
name|confFinal
operator|=
literal|false
expr_stmt|;
name|confTag
operator|=
literal|null
expr_stmt|;
name|confSource
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// First test for short format configuration
name|int
name|attrCount
init|=
name|reader
operator|.
name|getAttributeCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|propertyAttr
init|=
name|reader
operator|.
name|getAttributeLocalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"name"
operator|.
name|equals
argument_list|(
name|propertyAttr
argument_list|)
condition|)
block|{
name|confName
operator|=
name|StringInterner
operator|.
name|weakIntern
argument_list|(
name|reader
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"value"
operator|.
name|equals
argument_list|(
name|propertyAttr
argument_list|)
condition|)
block|{
name|confValue
operator|=
name|StringInterner
operator|.
name|weakIntern
argument_list|(
name|reader
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"final"
operator|.
name|equals
argument_list|(
name|propertyAttr
argument_list|)
condition|)
block|{
name|confFinal
operator|=
literal|"true"
operator|.
name|equals
argument_list|(
name|reader
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"source"
operator|.
name|equals
argument_list|(
name|propertyAttr
argument_list|)
condition|)
block|{
name|confSource
operator|.
name|add
argument_list|(
name|StringInterner
operator|.
name|weakIntern
argument_list|(
name|reader
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"tag"
operator|.
name|equals
argument_list|(
name|propertyAttr
argument_list|)
condition|)
block|{
name|confTag
operator|=
name|StringInterner
operator|.
name|weakIntern
argument_list|(
name|reader
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|"name"
case|:
case|case
literal|"value"
case|:
case|case
literal|"final"
case|:
case|case
literal|"source"
case|:
case|case
literal|"tag"
case|:
name|parseToken
operator|=
literal|true
expr_stmt|;
name|token
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"include"
case|:
comment|// Determine href for xi:include
name|confInclude
operator|=
literal|null
expr_stmt|;
name|attrCount
operator|=
name|reader
operator|.
name|getAttributeCount
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attrCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|attrName
init|=
name|reader
operator|.
name|getAttributeLocalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"href"
operator|.
name|equals
argument_list|(
name|attrName
argument_list|)
condition|)
block|{
name|confInclude
operator|=
name|reader
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|confInclude
operator|==
literal|null
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|isRestricted
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error parsing resource "
operator|+
name|wrapper
operator|+
literal|": XInclude is not supported for restricted resources"
argument_list|)
throw|;
block|}
comment|// Determine if the included resource is a classpath resource
comment|// otherwise fallback to a file resource
comment|// xi:include are treated as inline and retain current source
name|URL
name|include
init|=
name|getResource
argument_list|(
name|confInclude
argument_list|)
decl_stmt|;
if|if
condition|(
name|include
operator|!=
literal|null
condition|)
block|{
name|Resource
name|classpathResource
init|=
operator|new
name|Resource
argument_list|(
name|include
argument_list|,
name|name
argument_list|,
name|wrapper
operator|.
name|isParserRestricted
argument_list|()
argument_list|)
decl_stmt|;
name|loadResource
argument_list|(
name|properties
argument_list|,
name|classpathResource
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|URL
name|url
decl_stmt|;
try|try
block|{
name|url
operator|=
operator|new
name|URL
argument_list|(
name|confInclude
argument_list|)
expr_stmt|;
name|url
operator|.
name|openConnection
argument_list|()
operator|.
name|connect
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|File
name|href
init|=
operator|new
name|File
argument_list|(
name|confInclude
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|href
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
comment|// Included resources are relative to the current resource
name|File
name|baseFile
init|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
name|href
operator|=
operator|new
name|File
argument_list|(
name|baseFile
argument_list|,
name|href
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|href
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// Resource errors are non-fatal iff there is 1 xi:fallback
name|fallbackAllowed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|url
operator|=
name|href
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
expr_stmt|;
block|}
name|Resource
name|uriResource
init|=
operator|new
name|Resource
argument_list|(
name|url
argument_list|,
name|name
argument_list|,
name|wrapper
operator|.
name|isParserRestricted
argument_list|()
argument_list|)
decl_stmt|;
name|loadResource
argument_list|(
name|properties
argument_list|,
name|uriResource
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|"fallback"
case|:
name|fallbackEntered
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|"configuration"
case|:
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|XMLStreamConstants
operator|.
name|CHARACTERS
case|:
if|if
condition|(
name|parseToken
condition|)
block|{
name|char
index|[]
name|text
init|=
name|reader
operator|.
name|getTextCharacters
argument_list|()
decl_stmt|;
name|token
operator|.
name|append
argument_list|(
name|text
argument_list|,
name|reader
operator|.
name|getTextStart
argument_list|()
argument_list|,
name|reader
operator|.
name|getTextLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XMLStreamConstants
operator|.
name|END_ELEMENT
case|:
switch|switch
condition|(
name|reader
operator|.
name|getLocalName
argument_list|()
condition|)
block|{
case|case
literal|"name"
case|:
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|confName
operator|=
name|StringInterner
operator|.
name|weakIntern
argument_list|(
name|token
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|"value"
case|:
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|confValue
operator|=
name|StringInterner
operator|.
name|weakIntern
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|"final"
case|:
name|confFinal
operator|=
literal|"true"
operator|.
name|equals
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"source"
case|:
name|confSource
operator|.
name|add
argument_list|(
name|StringInterner
operator|.
name|weakIntern
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|"tag"
case|:
if|if
condition|(
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|confTag
operator|=
name|StringInterner
operator|.
name|weakIntern
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|"include"
case|:
if|if
condition|(
name|fallbackAllowed
operator|&&
operator|!
name|fallbackEntered
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Fetch fail on include for '"
operator|+
name|confInclude
operator|+
literal|"' with no fallback while loading '"
operator|+
name|name
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|fallbackAllowed
operator|=
literal|false
expr_stmt|;
name|fallbackEntered
operator|=
literal|false
expr_stmt|;
break|break;
case|case
literal|"property"
case|:
if|if
condition|(
name|confName
operator|==
literal|null
operator|||
operator|(
operator|!
name|fallbackAllowed
operator|&&
name|fallbackEntered
operator|)
condition|)
block|{
break|break;
block|}
name|confSource
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// Read tags and put them in propertyTagsMap
if|if
condition|(
name|confTag
operator|!=
literal|null
condition|)
block|{
name|readTagFromConfig
argument_list|(
name|confTag
argument_list|,
name|confName
argument_list|,
name|confValue
argument_list|,
name|confSource
argument_list|)
expr_stmt|;
block|}
name|DeprecatedKeyInfo
name|keyInfo
init|=
name|deprecations
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|get
argument_list|(
name|confName
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyInfo
operator|!=
literal|null
condition|)
block|{
name|keyInfo
operator|.
name|clearAccessed
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keyInfo
operator|.
name|newKeys
control|)
block|{
comment|// update new keys with deprecated key's value
name|loadProperty
argument_list|(
name|toAddTo
argument_list|,
name|name
argument_list|,
name|key
argument_list|,
name|confValue
argument_list|,
name|confFinal
argument_list|,
name|confSource
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|confSource
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|loadProperty
argument_list|(
name|toAddTo
argument_list|,
name|name
argument_list|,
name|confName
argument_list|,
name|confValue
argument_list|,
name|confFinal
argument_list|,
name|confSource
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|confSource
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
default|default:
break|break;
block|}
block|}
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|returnCachedProperties
condition|)
block|{
name|overlay
argument_list|(
name|properties
argument_list|,
name|toAddTo
argument_list|)
expr_stmt|;
return|return
operator|new
name|Resource
argument_list|(
name|toAddTo
argument_list|,
name|name
argument_list|,
name|wrapper
operator|.
name|isParserRestricted
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"error parsing conf "
operator|+
name|name
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|XMLStreamException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"error parsing conf "
operator|+
name|name
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Add tags defined in HADOOP_TAGS_SYSTEM, HADOOP_TAGS_CUSTOM.    * @param prop    */
DECL|method|addTags (Properties prop)
specifier|public
name|void
name|addTags
parameter_list|(
name|Properties
name|prop
parameter_list|)
block|{
comment|// Get all system tags
try|try
block|{
if|if
condition|(
name|prop
operator|.
name|containsKey
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_TAGS_SYSTEM
argument_list|)
condition|)
block|{
name|String
name|systemTags
init|=
name|prop
operator|.
name|getProperty
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_TAGS_SYSTEM
argument_list|)
decl_stmt|;
name|TAGS
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|systemTags
operator|.
name|split
argument_list|(
literal|","
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Get all custom tags
if|if
condition|(
name|prop
operator|.
name|containsKey
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_TAGS_CUSTOM
argument_list|)
condition|)
block|{
name|String
name|customTags
init|=
name|prop
operator|.
name|getProperty
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_TAGS_CUSTOM
argument_list|)
decl_stmt|;
name|TAGS
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|customTags
operator|.
name|split
argument_list|(
literal|","
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prop
operator|.
name|containsKey
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SYSTEM_TAGS
argument_list|)
condition|)
block|{
name|String
name|systemTags
init|=
name|prop
operator|.
name|getProperty
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SYSTEM_TAGS
argument_list|)
decl_stmt|;
name|TAGS
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|systemTags
operator|.
name|split
argument_list|(
literal|","
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Get all custom tags
if|if
condition|(
name|prop
operator|.
name|containsKey
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_CUSTOM_TAGS
argument_list|)
condition|)
block|{
name|String
name|customTags
init|=
name|prop
operator|.
name|getProperty
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_CUSTOM_TAGS
argument_list|)
decl_stmt|;
name|TAGS
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|customTags
operator|.
name|split
argument_list|(
literal|","
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Error adding tags in configuration"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Read the values passed as tags and store them in a    * map for later retrieval.    * @param attributeValue    * @param confName    * @param confValue    * @param confSource    */
DECL|method|readTagFromConfig (String attributeValue, String confName, String confValue, List<String> confSource)
specifier|private
name|void
name|readTagFromConfig
parameter_list|(
name|String
name|attributeValue
parameter_list|,
name|String
name|confName
parameter_list|,
name|String
name|confValue
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|confSource
parameter_list|)
block|{
for|for
control|(
name|String
name|tagStr
range|:
name|attributeValue
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
try|try
block|{
name|tagStr
operator|=
name|tagStr
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// Handle property with no/null value
if|if
condition|(
name|confValue
operator|==
literal|null
condition|)
block|{
name|confValue
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|propertyTagsMap
operator|.
name|containsKey
argument_list|(
name|tagStr
argument_list|)
condition|)
block|{
name|propertyTagsMap
operator|.
name|get
argument_list|(
name|tagStr
argument_list|)
operator|.
name|setProperty
argument_list|(
name|confName
argument_list|,
name|confValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
name|confName
argument_list|,
name|confValue
argument_list|)
expr_stmt|;
name|propertyTagsMap
operator|.
name|put
argument_list|(
name|tagStr
argument_list|,
name|props
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|// Log the exception at trace level.
name|LOG
operator|.
name|trace
argument_list|(
literal|"Tag '{}' for property:{} Source:{}"
argument_list|,
name|tagStr
argument_list|,
name|confName
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|confSource
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|overlay (Properties to, Properties from)
specifier|private
name|void
name|overlay
parameter_list|(
name|Properties
name|to
parameter_list|,
name|Properties
name|from
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|from
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|to
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|loadProperty (Properties properties, String name, String attr, String value, boolean finalParameter, String[] source)
specifier|private
name|void
name|loadProperty
parameter_list|(
name|Properties
name|properties
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|attr
parameter_list|,
name|String
name|value
parameter_list|,
name|boolean
name|finalParameter
parameter_list|,
name|String
index|[]
name|source
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
operator|||
name|allowNullValueProperties
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|value
operator|=
name|DEFAULT_STRING_CHECK
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|finalParameters
operator|.
name|contains
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|properties
operator|.
name|setProperty
argument_list|(
name|attr
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
name|putIntoUpdatingResource
argument_list|(
name|attr
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// This is a final parameter so check for overrides.
name|checkForOverride
argument_list|(
name|this
operator|.
name|properties
argument_list|,
name|name
argument_list|,
name|attr
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|properties
operator|!=
name|properties
condition|)
block|{
name|checkForOverride
argument_list|(
name|properties
argument_list|,
name|name
argument_list|,
name|attr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|finalParameter
operator|&&
name|attr
operator|!=
literal|null
condition|)
block|{
name|finalParameters
operator|.
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Print a warning if a property with a given name already exists with a    * different value    */
DECL|method|checkForOverride (Properties properties, String name, String attr, String value)
specifier|private
name|void
name|checkForOverride
parameter_list|(
name|Properties
name|properties
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|attr
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|String
name|propertyValue
init|=
name|properties
operator|.
name|getProperty
argument_list|(
name|attr
argument_list|)
decl_stmt|;
if|if
condition|(
name|propertyValue
operator|!=
literal|null
operator|&&
operator|!
name|propertyValue
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|name
operator|+
literal|":an attempt to override final parameter: "
operator|+
name|attr
operator|+
literal|";  Ignoring."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Write out the non-default properties in this configuration to the given    * {@link OutputStream} using UTF-8 encoding.    *     * @param out the output stream to write to.    */
DECL|method|writeXml (OutputStream out)
specifier|public
name|void
name|writeXml
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|writeXml
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|writeXml (Writer out)
specifier|public
name|void
name|writeXml
parameter_list|(
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|writeXml
argument_list|(
literal|null
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write out the non-default properties in this configuration to the    * given {@link Writer}.    *    *<li>    * When property name is not empty and the property exists in the    * configuration, this method writes the property and its attributes    * to the {@link Writer}.    *</li>    *<p>    *    *<li>    * When property name is null or empty, this method writes all the    * configuration properties and their attributes to the {@link Writer}.    *</li>    *<p>    *    *<li>    * When property name is not empty but the property doesn't exist in    * the configuration, this method throws an {@link IllegalArgumentException}.    *</li>    *<p>    * @param out the writer to write to.    */
DECL|method|writeXml (String propertyName, Writer out)
specifier|public
name|void
name|writeXml
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalArgumentException
block|{
name|Document
name|doc
init|=
name|asXmlDocument
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
try|try
block|{
name|DOMSource
name|source
init|=
operator|new
name|DOMSource
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|StreamResult
name|result
init|=
operator|new
name|StreamResult
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|TransformerFactory
name|transFactory
init|=
name|TransformerFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|Transformer
name|transformer
init|=
name|transFactory
operator|.
name|newTransformer
argument_list|()
decl_stmt|;
comment|// Important to not hold Configuration log while writing result, since
comment|// 'out' may be an HDFS stream which needs to lock this configuration
comment|// from another thread.
name|transformer
operator|.
name|transform
argument_list|(
name|source
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransformerException
name|te
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|te
argument_list|)
throw|;
block|}
block|}
comment|/**    * Return the XML DOM corresponding to this Configuration.    */
DECL|method|asXmlDocument (String propertyName)
specifier|private
specifier|synchronized
name|Document
name|asXmlDocument
parameter_list|(
name|String
name|propertyName
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalArgumentException
block|{
name|Document
name|doc
decl_stmt|;
try|try
block|{
name|doc
operator|=
name|DocumentBuilderFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newDocumentBuilder
argument_list|()
operator|.
name|newDocument
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParserConfigurationException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|pe
argument_list|)
throw|;
block|}
name|Element
name|conf
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"configuration"
argument_list|)
decl_stmt|;
name|doc
operator|.
name|appendChild
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|conf
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|handleDeprecation
argument_list|()
expr_stmt|;
comment|//ensure properties is set and deprecation is handled
if|if
condition|(
operator|!
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|propertyName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|properties
operator|.
name|containsKey
argument_list|(
name|propertyName
argument_list|)
condition|)
block|{
comment|// given property not found, illegal argument
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property "
operator|+
name|propertyName
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// given property is found, write single property
name|appendXMLProperty
argument_list|(
name|doc
argument_list|,
name|conf
argument_list|,
name|propertyName
argument_list|)
expr_stmt|;
name|conf
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// append all elements
for|for
control|(
name|Enumeration
argument_list|<
name|Object
argument_list|>
name|e
init|=
name|properties
operator|.
name|keys
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|appendXMLProperty
argument_list|(
name|doc
argument_list|,
name|conf
argument_list|,
operator|(
name|String
operator|)
name|e
operator|.
name|nextElement
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|doc
return|;
block|}
comment|/**    *  Append a property with its attributes to a given {#link Document}    *  if the property is found in configuration.    *    * @param doc    * @param conf    * @param propertyName    */
DECL|method|appendXMLProperty (Document doc, Element conf, String propertyName)
specifier|private
specifier|synchronized
name|void
name|appendXMLProperty
parameter_list|(
name|Document
name|doc
parameter_list|,
name|Element
name|conf
parameter_list|,
name|String
name|propertyName
parameter_list|)
block|{
comment|// skip writing if given property name is empty or null
if|if
condition|(
operator|!
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|propertyName
argument_list|)
condition|)
block|{
name|String
name|value
init|=
name|properties
operator|.
name|getProperty
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|Element
name|propNode
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"property"
argument_list|)
decl_stmt|;
name|conf
operator|.
name|appendChild
argument_list|(
name|propNode
argument_list|)
expr_stmt|;
name|Element
name|nameNode
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|nameNode
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
name|propertyName
argument_list|)
argument_list|)
expr_stmt|;
name|propNode
operator|.
name|appendChild
argument_list|(
name|nameNode
argument_list|)
expr_stmt|;
name|Element
name|valueNode
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"value"
argument_list|)
decl_stmt|;
name|valueNode
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
name|properties
operator|.
name|getProperty
argument_list|(
name|propertyName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|propNode
operator|.
name|appendChild
argument_list|(
name|valueNode
argument_list|)
expr_stmt|;
name|Element
name|finalNode
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"final"
argument_list|)
decl_stmt|;
name|finalNode
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|finalParameters
operator|.
name|contains
argument_list|(
name|propertyName
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|propNode
operator|.
name|appendChild
argument_list|(
name|finalNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|updatingResource
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|sources
init|=
name|updatingResource
operator|.
name|get
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sources
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|sources
control|)
block|{
name|Element
name|sourceNode
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"source"
argument_list|)
decl_stmt|;
name|sourceNode
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|propNode
operator|.
name|appendChild
argument_list|(
name|sourceNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    *  Writes properties and their attributes (final and resource)    *  to the given {@link Writer}.    *    *<li>    *  When propertyName is not empty, and the property exists    *  in the configuration, the format of the output would be,    *<pre>    *  {    *    "property": {    *      "key" : "key1",    *      "value" : "value1",    *      "isFinal" : "key1.isFinal",    *      "resource" : "key1.resource"    *    }    *  }    *</pre>    *</li>    *    *<li>    *  When propertyName is null or empty, it behaves same as    *  {@link #dumpConfiguration(Configuration, Writer)}, the    *  output would be,    *<pre>    *  { "properties" :    *      [ { key : "key1",    *          value : "value1",    *          isFinal : "key1.isFinal",    *          resource : "key1.resource" },    *        { key : "key2",    *          value : "value2",    *          isFinal : "ke2.isFinal",    *          resource : "key2.resource" }    *       ]    *   }    *</pre>    *</li>    *    *<li>    *  When propertyName is not empty, and the property is not    *  found in the configuration, this method will throw an    *  {@link IllegalArgumentException}.    *</li>    *<p>    * @param config the configuration    * @param propertyName property name    * @param out the Writer to write to    * @throws IOException    * @throws IllegalArgumentException when property name is not    *   empty and the property is not found in configuration    **/
DECL|method|dumpConfiguration (Configuration config, String propertyName, Writer out)
specifier|public
specifier|static
name|void
name|dumpConfiguration
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|String
name|propertyName
parameter_list|,
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|propertyName
argument_list|)
condition|)
block|{
name|dumpConfiguration
argument_list|(
name|config
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|config
operator|.
name|get
argument_list|(
name|propertyName
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property "
operator|+
name|propertyName
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
else|else
block|{
name|JsonFactory
name|dumpFactory
init|=
operator|new
name|JsonFactory
argument_list|()
decl_stmt|;
name|JsonGenerator
name|dumpGenerator
init|=
name|dumpFactory
operator|.
name|createGenerator
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|dumpGenerator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeFieldName
argument_list|(
literal|"property"
argument_list|)
expr_stmt|;
name|appendJSONProperty
argument_list|(
name|dumpGenerator
argument_list|,
name|config
argument_list|,
name|propertyName
argument_list|,
operator|new
name|ConfigRedactor
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    *  Writes out all properties and their attributes (final and resource) to    *  the given {@link Writer}, the format of the output would be,    *    *<pre>    *  { "properties" :    *      [ { key : "key1",    *          value : "value1",    *          isFinal : "key1.isFinal",    *          resource : "key1.resource" },    *        { key : "key2",    *          value : "value2",    *          isFinal : "ke2.isFinal",    *          resource : "key2.resource" }    *       ]    *   }    *</pre>    *    *  It does not output the properties of the configuration object which    *  is loaded from an input stream.    *<p>    *    * @param config the configuration    * @param out the Writer to write to    * @throws IOException    */
DECL|method|dumpConfiguration (Configuration config, Writer out)
specifier|public
specifier|static
name|void
name|dumpConfiguration
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|JsonFactory
name|dumpFactory
init|=
operator|new
name|JsonFactory
argument_list|()
decl_stmt|;
name|JsonGenerator
name|dumpGenerator
init|=
name|dumpFactory
operator|.
name|createGenerator
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|dumpGenerator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeFieldName
argument_list|(
literal|"properties"
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStartArray
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|flush
argument_list|()
expr_stmt|;
name|ConfigRedactor
name|redactor
init|=
operator|new
name|ConfigRedactor
argument_list|(
name|config
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|config
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|config
operator|.
name|getProps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|appendJSONProperty
argument_list|(
name|dumpGenerator
argument_list|,
name|config
argument_list|,
name|item
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|redactor
argument_list|)
expr_stmt|;
block|}
block|}
name|dumpGenerator
operator|.
name|writeEndArray
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Write property and its attributes as json format to given    * {@link JsonGenerator}.    *    * @param jsonGen json writer    * @param config configuration    * @param name property name    * @throws IOException    */
DECL|method|appendJSONProperty (JsonGenerator jsonGen, Configuration config, String name, ConfigRedactor redactor)
specifier|private
specifier|static
name|void
name|appendJSONProperty
parameter_list|(
name|JsonGenerator
name|jsonGen
parameter_list|,
name|Configuration
name|config
parameter_list|,
name|String
name|name
parameter_list|,
name|ConfigRedactor
name|redactor
parameter_list|)
throws|throws
name|IOException
block|{
comment|// skip writing if given property name is empty or null
if|if
condition|(
operator|!
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|name
argument_list|)
operator|&&
name|jsonGen
operator|!=
literal|null
condition|)
block|{
name|jsonGen
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|jsonGen
operator|.
name|writeStringField
argument_list|(
literal|"key"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|jsonGen
operator|.
name|writeStringField
argument_list|(
literal|"value"
argument_list|,
name|redactor
operator|.
name|redact
argument_list|(
name|name
argument_list|,
name|config
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|jsonGen
operator|.
name|writeBooleanField
argument_list|(
literal|"isFinal"
argument_list|,
name|config
operator|.
name|finalParameters
operator|.
name|contains
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|String
index|[]
name|resources
init|=
name|config
operator|.
name|updatingResource
operator|!=
literal|null
condition|?
name|config
operator|.
name|updatingResource
operator|.
name|get
argument_list|(
name|name
argument_list|)
else|:
literal|null
decl_stmt|;
name|String
name|resource
init|=
name|UNKNOWN_RESOURCE
decl_stmt|;
if|if
condition|(
name|resources
operator|!=
literal|null
operator|&&
name|resources
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|resource
operator|=
name|resources
index|[
literal|0
index|]
expr_stmt|;
block|}
name|jsonGen
operator|.
name|writeStringField
argument_list|(
literal|"resource"
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|jsonGen
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the {@link ClassLoader} for this job.    *    * @return the correct class loader.    */
DECL|method|getClassLoader ()
specifier|public
name|ClassLoader
name|getClassLoader
parameter_list|()
block|{
return|return
name|classLoader
return|;
block|}
comment|/**    * Set the class loader that will be used to load the various objects.    *     * @param classLoader the new class loader.    */
DECL|method|setClassLoader (ClassLoader classLoader)
specifier|public
name|void
name|setClassLoader
parameter_list|(
name|ClassLoader
name|classLoader
parameter_list|)
block|{
name|this
operator|.
name|classLoader
operator|=
name|classLoader
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Configuration: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadDefaults
condition|)
block|{
name|toString
argument_list|(
name|defaultResources
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|resources
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|toString
argument_list|(
name|resources
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|toString (List<T> resources, StringBuilder sb)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|toString
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|resources
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
block|{
name|ListIterator
argument_list|<
name|T
argument_list|>
name|i
init|=
name|resources
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|nextIndex
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Set the quietness-mode.     *     * In the quiet-mode, error and informational messages might not be logged.    *     * @param quietmode<code>true</code> to set quiet-mode on,<code>false</code>    *              to turn it off.    */
DECL|method|setQuietMode (boolean quietmode)
specifier|public
specifier|synchronized
name|void
name|setQuietMode
parameter_list|(
name|boolean
name|quietmode
parameter_list|)
block|{
name|this
operator|.
name|quietmode
operator|=
name|quietmode
expr_stmt|;
block|}
DECL|method|getQuietMode ()
specifier|synchronized
name|boolean
name|getQuietMode
parameter_list|()
block|{
return|return
name|this
operator|.
name|quietmode
return|;
block|}
comment|/** For debugging.  List non-default properties to the terminal and exit. */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
operator|new
name|Configuration
argument_list|()
operator|.
name|writeXml
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|clear
argument_list|()
expr_stmt|;
name|int
name|size
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|String
name|key
init|=
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|set
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|String
name|sources
index|[]
init|=
name|WritableUtils
operator|.
name|readCompressedStringArray
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|sources
operator|!=
literal|null
condition|)
block|{
name|putIntoUpdatingResource
argument_list|(
name|key
argument_list|,
name|sources
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//@Override
annotation|@
name|Override
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|props
init|=
name|getProps
argument_list|()
decl_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|props
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|props
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
operator|(
name|String
operator|)
name|item
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeCompressedStringArray
argument_list|(
name|out
argument_list|,
name|updatingResource
operator|!=
literal|null
condition|?
name|updatingResource
operator|.
name|get
argument_list|(
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * get keys matching the the regex     * @param regex    * @return Map<String,String> with matching keys    */
DECL|method|getValByRegex (String regex)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getValByRegex
parameter_list|(
name|String
name|regex
parameter_list|)
block|{
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Matcher
name|m
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|getProps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|.
name|getKey
argument_list|()
operator|instanceof
name|String
operator|&&
name|item
operator|.
name|getValue
argument_list|()
operator|instanceof
name|String
condition|)
block|{
name|m
operator|=
name|p
operator|.
name|matcher
argument_list|(
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
comment|// match
name|result
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|,
name|substituteVars
argument_list|(
name|getProps
argument_list|()
operator|.
name|getProperty
argument_list|(
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * A unique class which is used as a sentinel value in the caching    * for getClassByName. {@link Configuration#getClassByNameOrNull(String)}    */
DECL|class|NegativeCacheSentinel
specifier|private
specifier|static
specifier|abstract
class|class
name|NegativeCacheSentinel
block|{}
DECL|method|dumpDeprecatedKeys ()
specifier|public
specifier|static
name|void
name|dumpDeprecatedKeys
parameter_list|()
block|{
name|DeprecationContext
name|deprecations
init|=
name|deprecationContext
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|DeprecatedKeyInfo
argument_list|>
name|entry
range|:
name|deprecations
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|StringBuilder
name|newKeys
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|newKey
range|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|newKeys
control|)
block|{
name|newKeys
operator|.
name|append
argument_list|(
name|newKey
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"\t"
operator|+
name|newKeys
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns whether or not a deprecated name has been warned. If the name is not    * deprecated then always return false    */
DECL|method|hasWarnedDeprecation (String name)
specifier|public
specifier|static
name|boolean
name|hasWarnedDeprecation
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|DeprecationContext
name|deprecations
init|=
name|deprecationContext
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|deprecations
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|deprecations
operator|.
name|getDeprecatedKeyMap
argument_list|()
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|accessed
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Get all properties belonging to tag.    * @param tag tag    * @return Properties with matching tag    */
DECL|method|getAllPropertiesByTag (final String tag)
specifier|public
name|Properties
name|getAllPropertiesByTag
parameter_list|(
specifier|final
name|String
name|tag
parameter_list|)
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
if|if
condition|(
name|propertyTagsMap
operator|.
name|containsKey
argument_list|(
name|tag
argument_list|)
condition|)
block|{
name|props
operator|.
name|putAll
argument_list|(
name|propertyTagsMap
operator|.
name|get
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|props
return|;
block|}
comment|/**    * Get all properties belonging to list of input tags. Calls    * getAllPropertiesByTag internally.    * @param tagList list of input tags    * @return Properties with matching tags    */
DECL|method|getAllPropertiesByTags (final List<String> tagList)
specifier|public
name|Properties
name|getAllPropertiesByTags
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|tagList
parameter_list|)
block|{
name|Properties
name|prop
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|tag
range|:
name|tagList
control|)
block|{
name|prop
operator|.
name|putAll
argument_list|(
name|this
operator|.
name|getAllPropertiesByTag
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|prop
return|;
block|}
comment|/**    * Get Property tag Enum corresponding to given source.    *    * @param tagStr String representation of Enum    * @return true if tagStr is a valid tag    */
DECL|method|isPropertyTag (String tagStr)
specifier|public
name|boolean
name|isPropertyTag
parameter_list|(
name|String
name|tagStr
parameter_list|)
block|{
return|return
name|this
operator|.
name|TAGS
operator|.
name|contains
argument_list|(
name|tagStr
argument_list|)
return|;
block|}
DECL|method|putIntoUpdatingResource (String key, String[] value)
specifier|private
name|void
name|putIntoUpdatingResource
parameter_list|(
name|String
name|key
parameter_list|,
name|String
index|[]
name|value
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|localUR
init|=
name|updatingResource
decl_stmt|;
if|if
condition|(
name|localUR
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|localUR
operator|=
name|updatingResource
expr_stmt|;
if|if
condition|(
name|localUR
operator|==
literal|null
condition|)
block|{
name|updatingResource
operator|=
name|localUR
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|localUR
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

