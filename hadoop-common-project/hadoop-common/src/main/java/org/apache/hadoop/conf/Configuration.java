begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.conf
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilder
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilderFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|Transformer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|TransformerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|dom
operator|.
name|DOMSource
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|transform
operator|.
name|stream
operator|.
name|StreamResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Comment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|DOMException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/**   * Provides access to configuration parameters.  *  *<h4 id="Resources">Resources</h4>  *  *<p>Configurations are specified by resources. A resource contains a set of  * name/value pairs as XML data. Each resource is named by either a   *<code>String</code> or by a {@link Path}. If named by a<code>String</code>,   * then the classpath is examined for a file with that name.  If named by a   *<code>Path</code>, then the local filesystem is examined directly, without   * referring to the classpath.  *  *<p>Unless explicitly turned off, Hadoop by default specifies two   * resources, loaded in-order from the classpath:<ol>  *<li><tt><a href="{@docRoot}/../core-default.html">core-default.xml</a>  *</tt>: Read-only defaults for hadoop.</li>  *<li><tt>core-site.xml</tt>: Site-specific configuration for a given hadoop  * installation.</li>  *</ol>  * Applications may add additional resources, which are loaded  * subsequent to these resources in the order they are added.  *   *<h4 id="FinalParams">Final Parameters</h4>  *  *<p>Configuration parameters may be declared<i>final</i>.   * Once a resource declares a value final, no subsequently-loaded   * resource can alter that value.    * For example, one might define a final parameter with:  *<tt><pre>  *&lt;property&gt;  *&lt;name&gt;dfs.client.buffer.dir&lt;/name&gt;  *&lt;value&gt;/tmp/hadoop/dfs/client&lt;/value&gt;  *<b>&lt;final&gt;true&lt;/final&gt;</b>  *&lt;/property&gt;</pre></tt>  *  * Administrators typically define parameters as final in   *<tt>core-site.xml</tt> for values that user applications may not alter.  *  *<h4 id="VariableExpansion">Variable Expansion</h4>  *  *<p>Value strings are first processed for<i>variable expansion</i>. The  * available properties are:<ol>  *<li>Other properties defined in this Configuration; and, if a name is  * undefined here,</li>  *<li>Properties in {@link System#getProperties()}.</li>  *</ol>  *  *<p>For example, if a configuration resource contains the following property  * definitions:   *<tt><pre>  *&lt;property&gt;  *&lt;name&gt;basedir&lt;/name&gt;  *&lt;value&gt;/user/${<i>user.name</i>}&lt;/value&gt;  *&lt;/property&gt;  *    *&lt;property&gt;  *&lt;name&gt;tempdir&lt;/name&gt;  *&lt;value&gt;${<i>basedir</i>}/tmp&lt;/value&gt;  *&lt;/property&gt;</pre></tt>  *  * When<tt>conf.get("tempdir")</tt> is called, then<tt>${<i>basedir</i>}</tt>  * will be resolved to another property in this Configuration, while  *<tt>${<i>user.name</i>}</tt> would then ordinarily be resolved to the value  * of the System property with that name.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|Configuration
specifier|public
class|class
name|Configuration
implements|implements
name|Iterable
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
implements|,
name|Writable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|quietmode
specifier|private
name|boolean
name|quietmode
init|=
literal|true
decl_stmt|;
comment|/**    * List of configuration resources.    */
DECL|field|resources
specifier|private
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|resources
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * The value reported as the setting resource when a key is set    * by code rather than a file resource.    */
DECL|field|UNKNOWN_RESOURCE
specifier|static
specifier|final
name|String
name|UNKNOWN_RESOURCE
init|=
literal|"Unknown"
decl_stmt|;
comment|/**    * List of configuration parameters marked<b>final</b>.     */
DECL|field|finalParameters
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|finalParameters
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|loadDefaults
specifier|private
name|boolean
name|loadDefaults
init|=
literal|true
decl_stmt|;
comment|/**    * Configuration objects    */
DECL|field|REGISTRY
specifier|private
specifier|static
specifier|final
name|WeakHashMap
argument_list|<
name|Configuration
argument_list|,
name|Object
argument_list|>
name|REGISTRY
init|=
operator|new
name|WeakHashMap
argument_list|<
name|Configuration
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * List of default Resources. Resources are loaded in the order of the list     * entries    */
DECL|field|defaultResources
specifier|private
specifier|static
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|String
argument_list|>
name|defaultResources
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|ClassLoader
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
DECL|field|CACHE_CLASSES
name|CACHE_CLASSES
init|=
operator|new
name|WeakHashMap
argument_list|<
name|ClassLoader
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Stores the mapping of key to the resource which modifies or loads     * the key most recently    */
DECL|field|updatingResource
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|updatingResource
decl_stmt|;
comment|/**    * Class to keep the information about the keys which replace the deprecated    * ones.    *     * This class stores the new keys which replace the deprecated keys and also    * gives a provision to have a custom message for each of the deprecated key    * that is being replaced. It also provides method to get the appropriate    * warning message which can be logged whenever the deprecated key is used.    */
DECL|class|DeprecatedKeyInfo
specifier|private
specifier|static
class|class
name|DeprecatedKeyInfo
block|{
DECL|field|newKeys
specifier|private
name|String
index|[]
name|newKeys
decl_stmt|;
DECL|field|customMessage
specifier|private
name|String
name|customMessage
decl_stmt|;
DECL|field|accessed
specifier|private
name|boolean
name|accessed
decl_stmt|;
DECL|method|DeprecatedKeyInfo (String[] newKeys, String customMessage)
name|DeprecatedKeyInfo
parameter_list|(
name|String
index|[]
name|newKeys
parameter_list|,
name|String
name|customMessage
parameter_list|)
block|{
name|this
operator|.
name|newKeys
operator|=
name|newKeys
expr_stmt|;
name|this
operator|.
name|customMessage
operator|=
name|customMessage
expr_stmt|;
name|accessed
operator|=
literal|false
expr_stmt|;
block|}
comment|/**      * Method to provide the warning message. It gives the custom message if      * non-null, and default message otherwise.      * @param key the associated deprecated key.      * @return message that is to be logged when a deprecated key is used.      */
DECL|method|getWarningMessage (String key)
specifier|private
specifier|final
name|String
name|getWarningMessage
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|String
name|warningMessage
decl_stmt|;
if|if
condition|(
name|customMessage
operator|==
literal|null
condition|)
block|{
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|String
name|deprecatedKeySuffix
init|=
literal|" is deprecated. Instead, use "
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
name|deprecatedKeySuffix
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|message
operator|.
name|append
argument_list|(
name|newKeys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|newKeys
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|warningMessage
operator|=
name|message
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|warningMessage
operator|=
name|customMessage
expr_stmt|;
block|}
name|accessed
operator|=
literal|true
expr_stmt|;
return|return
name|warningMessage
return|;
block|}
block|}
comment|/**    * Stores the deprecated keys, the new keys which replace the deprecated keys    * and custom message(if any provided).    */
DECL|field|deprecatedKeyMap
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|DeprecatedKeyInfo
argument_list|>
name|deprecatedKeyMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|DeprecatedKeyInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Stores a mapping from superseding keys to the keys which they deprecate.    */
DECL|field|reverseDeprecatedKeyMap
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|reverseDeprecatedKeyMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Adds the deprecated key to the deprecation map.    * It does not override any existing entries in the deprecation map.    * This is to be used only by the developers in order to add deprecation of    * keys, and attempts to call this method after loading resources once,    * would lead to<tt>UnsupportedOperationException</tt>    * @param key    * @param newKeys    * @param customMessage    */
DECL|method|addDeprecation (String key, String[] newKeys, String customMessage)
specifier|public
specifier|synchronized
specifier|static
name|void
name|addDeprecation
parameter_list|(
name|String
name|key
parameter_list|,
name|String
index|[]
name|newKeys
parameter_list|,
name|String
name|customMessage
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|key
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|newKeys
operator|==
literal|null
operator|||
name|newKeys
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
operator|!
name|isDeprecated
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|DeprecatedKeyInfo
name|newKeyInfo
decl_stmt|;
name|newKeyInfo
operator|=
operator|new
name|DeprecatedKeyInfo
argument_list|(
name|newKeys
argument_list|,
name|customMessage
argument_list|)
expr_stmt|;
name|deprecatedKeyMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|newKeyInfo
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|newKey
range|:
name|newKeys
control|)
block|{
name|reverseDeprecatedKeyMap
operator|.
name|put
argument_list|(
name|newKey
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Adds the deprecated key to the deprecation map when no custom message    * is provided.    * It does not override any existing entries in the deprecation map.    * This is to be used only by the developers in order to add deprecation of    * keys, and attempts to call this method after loading resources once,    * would lead to<tt>UnsupportedOperationException</tt>    *     * @param key Key that is to be deprecated    * @param newKeys list of keys that take up the values of deprecated key    */
DECL|method|addDeprecation (String key, String[] newKeys)
specifier|public
specifier|synchronized
specifier|static
name|void
name|addDeprecation
parameter_list|(
name|String
name|key
parameter_list|,
name|String
index|[]
name|newKeys
parameter_list|)
block|{
name|addDeprecation
argument_list|(
name|key
argument_list|,
name|newKeys
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * checks whether the given<code>key</code> is deprecated.    *     * @param key the parameter which is to be checked for deprecation    * @return<code>true</code> if the key is deprecated and     *<code>false</code> otherwise.    */
DECL|method|isDeprecated (String key)
specifier|private
specifier|static
name|boolean
name|isDeprecated
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|deprecatedKeyMap
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * Checks for the presence of the property<code>name</code> in the    * deprecation map. Returns the first of the list of new keys if present    * in the deprecation map or the<code>name</code> itself. If the property    * is not presently set but the property map contains an entry for the    * deprecated key, the value of the deprecated key is set as the value for    * the provided property name.    *    * @param name the property name    * @return the first property in the list of properties mapping    *         the<code>name</code> or the<code>name</code> itself.    */
DECL|method|handleDeprecation (String name)
specifier|private
name|String
name|handleDeprecation
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|isDeprecated
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|DeprecatedKeyInfo
name|keyInfo
init|=
name|deprecatedKeyMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keyInfo
operator|.
name|accessed
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|keyInfo
operator|.
name|getWarningMessage
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|newKey
range|:
name|keyInfo
operator|.
name|newKeys
control|)
block|{
if|if
condition|(
name|newKey
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|newKey
expr_stmt|;
break|break;
block|}
block|}
block|}
name|String
name|deprecatedKey
init|=
name|reverseDeprecatedKeyMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|deprecatedKey
operator|!=
literal|null
operator|&&
operator|!
name|getOverlay
argument_list|()
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
operator|&&
name|getOverlay
argument_list|()
operator|.
name|containsKey
argument_list|(
name|deprecatedKey
argument_list|)
condition|)
block|{
name|getProps
argument_list|()
operator|.
name|setProperty
argument_list|(
name|name
argument_list|,
name|getOverlay
argument_list|()
operator|.
name|getProperty
argument_list|(
name|deprecatedKey
argument_list|)
argument_list|)
expr_stmt|;
name|getOverlay
argument_list|()
operator|.
name|setProperty
argument_list|(
name|name
argument_list|,
name|getOverlay
argument_list|()
operator|.
name|getProperty
argument_list|(
name|deprecatedKey
argument_list|)
argument_list|)
expr_stmt|;
name|DeprecatedKeyInfo
name|keyInfo
init|=
name|deprecatedKeyMap
operator|.
name|get
argument_list|(
name|deprecatedKey
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keyInfo
operator|.
name|accessed
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|keyInfo
operator|.
name|getWarningMessage
argument_list|(
name|deprecatedKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|name
return|;
block|}
static|static
block|{
comment|//print deprecation warning if hadoop-site.xml is found in classpath
name|ClassLoader
name|cL
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
decl_stmt|;
if|if
condition|(
name|cL
operator|==
literal|null
condition|)
block|{
name|cL
operator|=
name|Configuration
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cL
operator|.
name|getResource
argument_list|(
literal|"hadoop-site.xml"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DEPRECATED: hadoop-site.xml found in the classpath. "
operator|+
literal|"Usage of hadoop-site.xml is deprecated. Instead use core-site.xml, "
operator|+
literal|"mapred-site.xml and hdfs-site.xml to override properties of "
operator|+
literal|"core-default.xml, mapred-default.xml and hdfs-default.xml "
operator|+
literal|"respectively"
argument_list|)
expr_stmt|;
block|}
name|addDefaultResource
argument_list|(
literal|"core-default.xml"
argument_list|)
expr_stmt|;
name|addDefaultResource
argument_list|(
literal|"core-site.xml"
argument_list|)
expr_stmt|;
comment|//Add code for managing deprecated key mapping
comment|//for example
comment|//addDeprecation("oldKey1",new String[]{"newkey1","newkey2"});
comment|//adds deprecation for oldKey1 to two new keys(newkey1, newkey2).
comment|//so get or set of oldKey1 will correctly populate/access values of
comment|//newkey1 and newkey2
name|addDeprecatedKeys
argument_list|()
expr_stmt|;
block|}
DECL|field|properties
specifier|private
name|Properties
name|properties
decl_stmt|;
DECL|field|overlay
specifier|private
name|Properties
name|overlay
decl_stmt|;
DECL|field|classLoader
specifier|private
name|ClassLoader
name|classLoader
decl_stmt|;
block|{
name|classLoader
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
expr_stmt|;
if|if
condition|(
name|classLoader
operator|==
literal|null
condition|)
block|{
name|classLoader
operator|=
name|Configuration
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** A new configuration. */
DECL|method|Configuration ()
specifier|public
name|Configuration
parameter_list|()
block|{
name|this
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** A new configuration where the behavior of reading from the default     * resources can be turned off.    *     * If the parameter {@code loadDefaults} is false, the new instance    * will not load resources from the default files.     * @param loadDefaults specifies whether to load from the default files    */
DECL|method|Configuration (boolean loadDefaults)
specifier|public
name|Configuration
parameter_list|(
name|boolean
name|loadDefaults
parameter_list|)
block|{
name|this
operator|.
name|loadDefaults
operator|=
name|loadDefaults
expr_stmt|;
name|updatingResource
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|Configuration
operator|.
name|class
init|)
block|{
name|REGISTRY
operator|.
name|put
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * A new configuration with the same settings cloned from another.    *     * @param other the configuration from which to clone settings.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|Configuration (Configuration other)
specifier|public
name|Configuration
parameter_list|(
name|Configuration
name|other
parameter_list|)
block|{
name|this
operator|.
name|resources
operator|=
operator|(
name|ArrayList
operator|)
name|other
operator|.
name|resources
operator|.
name|clone
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|other
init|)
block|{
if|if
condition|(
name|other
operator|.
name|properties
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|properties
operator|=
operator|(
name|Properties
operator|)
name|other
operator|.
name|properties
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|other
operator|.
name|overlay
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|overlay
operator|=
operator|(
name|Properties
operator|)
name|other
operator|.
name|overlay
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|updatingResource
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|other
operator|.
name|updatingResource
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|finalParameters
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|other
operator|.
name|finalParameters
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|Configuration
operator|.
name|class
init|)
block|{
name|REGISTRY
operator|.
name|put
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|classLoader
operator|=
name|other
operator|.
name|classLoader
expr_stmt|;
name|this
operator|.
name|loadDefaults
operator|=
name|other
operator|.
name|loadDefaults
expr_stmt|;
name|setQuietMode
argument_list|(
name|other
operator|.
name|getQuietMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a default resource. Resources are loaded in the order of the resources     * added.    * @param name file name. File should be present in the classpath.    */
DECL|method|addDefaultResource (String name)
specifier|public
specifier|static
specifier|synchronized
name|void
name|addDefaultResource
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|defaultResources
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|defaultResources
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|Configuration
name|conf
range|:
name|REGISTRY
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|conf
operator|.
name|loadDefaults
condition|)
block|{
name|conf
operator|.
name|reloadConfiguration
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Add a configuration resource.     *     * The properties of this resource will override properties of previously     * added resources, unless they were marked<a href="#Final">final</a>.     *     * @param name resource to be added, the classpath is examined for a file     *             with that name.    */
DECL|method|addResource (String name)
specifier|public
name|void
name|addResource
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|addResourceObject
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a configuration resource.     *     * The properties of this resource will override properties of previously     * added resources, unless they were marked<a href="#Final">final</a>.     *     * @param url url of the resource to be added, the local filesystem is     *            examined directly to find the resource, without referring to     *            the classpath.    */
DECL|method|addResource (URL url)
specifier|public
name|void
name|addResource
parameter_list|(
name|URL
name|url
parameter_list|)
block|{
name|addResourceObject
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a configuration resource.     *     * The properties of this resource will override properties of previously     * added resources, unless they were marked<a href="#Final">final</a>.     *     * @param file file-path of resource to be added, the local filesystem is    *             examined directly to find the resource, without referring to     *             the classpath.    */
DECL|method|addResource (Path file)
specifier|public
name|void
name|addResource
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
name|addResourceObject
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a configuration resource.     *     * The properties of this resource will override properties of previously     * added resources, unless they were marked<a href="#Final">final</a>.     *     * @param in InputStream to deserialize the object from.     */
DECL|method|addResource (InputStream in)
specifier|public
name|void
name|addResource
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
name|addResourceObject
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reload configuration from previously added resources.    *    * This method will clear all the configuration read from the added     * resources, and final parameters. This will make the resources to     * be read again before accessing the values. Values that are added    * via set methods will overlay values read from the resources.    */
DECL|method|reloadConfiguration ()
specifier|public
specifier|synchronized
name|void
name|reloadConfiguration
parameter_list|()
block|{
name|properties
operator|=
literal|null
expr_stmt|;
comment|// trigger reload
name|finalParameters
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// clear site-limits
block|}
DECL|method|addResourceObject (Object resource)
specifier|private
specifier|synchronized
name|void
name|addResourceObject
parameter_list|(
name|Object
name|resource
parameter_list|)
block|{
name|resources
operator|.
name|add
argument_list|(
name|resource
argument_list|)
expr_stmt|;
comment|// add to resources
name|reloadConfiguration
argument_list|()
expr_stmt|;
block|}
DECL|field|varPat
specifier|private
specifier|static
name|Pattern
name|varPat
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\$\\{[^\\}\\$\u0020]+\\}"
argument_list|)
decl_stmt|;
DECL|field|MAX_SUBST
specifier|private
specifier|static
name|int
name|MAX_SUBST
init|=
literal|20
decl_stmt|;
DECL|method|substituteVars (String expr)
specifier|private
name|String
name|substituteVars
parameter_list|(
name|String
name|expr
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Matcher
name|match
init|=
name|varPat
operator|.
name|matcher
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|String
name|eval
init|=
name|expr
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|MAX_SUBST
condition|;
name|s
operator|++
control|)
block|{
name|match
operator|.
name|reset
argument_list|(
name|eval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
operator|.
name|find
argument_list|()
condition|)
block|{
return|return
name|eval
return|;
block|}
name|String
name|var
init|=
name|match
operator|.
name|group
argument_list|()
decl_stmt|;
name|var
operator|=
name|var
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|var
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// remove ${ .. }
name|String
name|val
init|=
literal|null
decl_stmt|;
try|try
block|{
name|val
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected SecurityException in Configuration"
argument_list|,
name|se
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
name|getRaw
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
return|return
name|eval
return|;
comment|// return literal ${var}: var is unbound
block|}
comment|// substitute
name|eval
operator|=
name|eval
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|match
operator|.
name|start
argument_list|()
argument_list|)
operator|+
name|val
operator|+
name|eval
operator|.
name|substring
argument_list|(
name|match
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Variable substitution depth too large: "
operator|+
name|MAX_SUBST
operator|+
literal|" "
operator|+
name|expr
argument_list|)
throw|;
block|}
comment|/**    * Get the value of the<code>name</code> property,<code>null</code> if    * no such property exists. If the key is deprecated, it returns the value of    * the first key which replaces the deprecated key and is not null    *     * Values are processed for<a href="#VariableExpansion">variable expansion</a>     * before being returned.     *     * @param name the property name.    * @return the value of the<code>name</code> or its replacing property,     *         or null if no such property exists.    */
DECL|method|get (String name)
specifier|public
name|String
name|get
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|name
operator|=
name|handleDeprecation
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|substituteVars
argument_list|(
name|getProps
argument_list|()
operator|.
name|getProperty
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the value of the<code>name</code> property as a trimmed<code>String</code>,     *<code>null</code> if no such property exists.     * If the key is deprecated, it returns the value of    * the first key which replaces the deprecated key and is not null    *     * Values are processed for<a href="#VariableExpansion">variable expansion</a>     * before being returned.     *     * @param name the property name.    * @return the value of the<code>name</code> or its replacing property,     *         or null if no such property exists.    */
DECL|method|getTrimmed (String name)
specifier|public
name|String
name|getTrimmed
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|value
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|value
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|value
operator|.
name|trim
argument_list|()
return|;
block|}
block|}
comment|/**    * Get the value of the<code>name</code> property, without doing    *<a href="#VariableExpansion">variable expansion</a>.If the key is     * deprecated, it returns the value of the first key which replaces     * the deprecated key and is not null.    *     * @param name the property name.    * @return the value of the<code>name</code> property or     *         its replacing property and null if no such property exists.    */
DECL|method|getRaw (String name)
specifier|public
name|String
name|getRaw
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|name
operator|=
name|handleDeprecation
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|getProps
argument_list|()
operator|.
name|getProperty
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**     * Set the<code>value</code> of the<code>name</code> property. If     *<code>name</code> is deprecated, it sets the<code>value</code> to the keys    * that replace the deprecated key.    *     * @param name property name.    * @param value property value.    */
DECL|method|set (String name, String value)
specifier|public
name|void
name|set
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|deprecatedKeyMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|getProps
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isDeprecated
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|getOverlay
argument_list|()
operator|.
name|setProperty
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|getProps
argument_list|()
operator|.
name|setProperty
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|updatingResource
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|UNKNOWN_RESOURCE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DeprecatedKeyInfo
name|keyInfo
init|=
name|deprecatedKeyMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|keyInfo
operator|.
name|getWarningMessage
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|newKey
range|:
name|keyInfo
operator|.
name|newKeys
control|)
block|{
name|getOverlay
argument_list|()
operator|.
name|setProperty
argument_list|(
name|newKey
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|getProps
argument_list|()
operator|.
name|setProperty
argument_list|(
name|newKey
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Unset a previously set property.    */
DECL|method|unset (String name)
specifier|public
specifier|synchronized
name|void
name|unset
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|name
operator|=
name|handleDeprecation
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|getOverlay
argument_list|()
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|getProps
argument_list|()
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets a property if it is currently unset.    * @param name the property name    * @param value the new value    */
DECL|method|setIfUnset (String name, String value)
specifier|public
specifier|synchronized
name|void
name|setIfUnset
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|get
argument_list|(
name|name
argument_list|)
operator|==
literal|null
condition|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getOverlay ()
specifier|private
specifier|synchronized
name|Properties
name|getOverlay
parameter_list|()
block|{
if|if
condition|(
name|overlay
operator|==
literal|null
condition|)
block|{
name|overlay
operator|=
operator|new
name|Properties
argument_list|()
expr_stmt|;
block|}
return|return
name|overlay
return|;
block|}
comment|/**     * Get the value of the<code>name</code>. If the key is deprecated,    * it returns the value of the first key which replaces the deprecated key    * and is not null.    * If no such property exists,    * then<code>defaultValue</code> is returned.    *     * @param name property name.    * @param defaultValue default value.    * @return property value, or<code>defaultValue</code> if the property     *         doesn't exist.                        */
DECL|method|get (String name, String defaultValue)
specifier|public
name|String
name|get
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|name
operator|=
name|handleDeprecation
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|substituteVars
argument_list|(
name|getProps
argument_list|()
operator|.
name|getProperty
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|)
argument_list|)
return|;
block|}
comment|/**     * Get the value of the<code>name</code> property as an<code>int</code>.    *       * If no such property exists, the provided default value is returned,    * or if the specified value is not a valid<code>int</code>,    * then an error is thrown.    *     * @param name property name.    * @param defaultValue default value.    * @throws NumberFormatException when the value is invalid    * @return property value as an<code>int</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getInt (String name, int defaultValue)
specifier|public
name|int
name|getInt
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
name|String
name|hexString
init|=
name|getHexDigits
argument_list|(
name|valueString
argument_list|)
decl_stmt|;
if|if
condition|(
name|hexString
operator|!=
literal|null
condition|)
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|hexString
argument_list|,
literal|16
argument_list|)
return|;
block|}
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**     * Set the value of the<code>name</code> property to an<code>int</code>.    *     * @param name property name.    * @param value<code>int</code> value of the property.    */
DECL|method|setInt (String name, int value)
specifier|public
name|void
name|setInt
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>long</code>.      * If no such property exists, the provided default value is returned,    * or if the specified value is not a valid<code>long</code>,    * then an error is thrown.    *     * @param name property name.    * @param defaultValue default value.    * @throws NumberFormatException when the value is invalid    * @return property value as a<code>long</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getLong (String name, long defaultValue)
specifier|public
name|long
name|getLong
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
name|String
name|hexString
init|=
name|getHexDigits
argument_list|(
name|valueString
argument_list|)
decl_stmt|;
if|if
condition|(
name|hexString
operator|!=
literal|null
condition|)
block|{
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|hexString
argument_list|,
literal|16
argument_list|)
return|;
block|}
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|valueString
argument_list|)
return|;
block|}
DECL|method|getHexDigits (String value)
specifier|private
name|String
name|getHexDigits
parameter_list|(
name|String
name|value
parameter_list|)
block|{
name|boolean
name|negative
init|=
literal|false
decl_stmt|;
name|String
name|str
init|=
name|value
decl_stmt|;
name|String
name|hexString
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
condition|)
block|{
name|negative
operator|=
literal|true
expr_stmt|;
name|str
operator|=
name|value
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
literal|"0x"
argument_list|)
operator|||
name|str
operator|.
name|startsWith
argument_list|(
literal|"0X"
argument_list|)
condition|)
block|{
name|hexString
operator|=
name|str
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative
condition|)
block|{
name|hexString
operator|=
literal|"-"
operator|+
name|hexString
expr_stmt|;
block|}
return|return
name|hexString
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**     * Set the value of the<code>name</code> property to a<code>long</code>.    *     * @param name property name.    * @param value<code>long</code> value of the property.    */
DECL|method|setLong (String name, long value)
specifier|public
name|void
name|setLong
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>float</code>.      * If no such property exists, the provided default value is returned,    * or if the specified value is not a valid<code>float</code>,    * then an error is thrown.    *    * @param name property name.    * @param defaultValue default value.    * @throws NumberFormatException when the value is invalid    * @return property value as a<code>float</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getFloat (String name, float defaultValue)
specifier|public
name|float
name|getFloat
parameter_list|(
name|String
name|name
parameter_list|,
name|float
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
return|return
name|Float
operator|.
name|parseFloat
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**    * Set the value of the<code>name</code> property to a<code>float</code>.    *     * @param name property name.    * @param value property value.    */
DECL|method|setFloat (String name, float value)
specifier|public
name|void
name|setFloat
parameter_list|(
name|String
name|name
parameter_list|,
name|float
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|Float
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>boolean</code>.      * If no such property is specified, or if the specified value is not a valid    *<code>boolean</code>, then<code>defaultValue</code> is returned.    *     * @param name property name.    * @param defaultValue default value.    * @return property value as a<code>boolean</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getBoolean (String name, boolean defaultValue)
specifier|public
name|boolean
name|getBoolean
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"true"
operator|.
name|equals
argument_list|(
name|valueString
argument_list|)
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
literal|"false"
operator|.
name|equals
argument_list|(
name|valueString
argument_list|)
condition|)
return|return
literal|false
return|;
else|else
return|return
name|defaultValue
return|;
block|}
comment|/**     * Set the value of the<code>name</code> property to a<code>boolean</code>.    *     * @param name property name.    * @param value<code>boolean</code> value of the property.    */
DECL|method|setBoolean (String name, boolean value)
specifier|public
name|void
name|setBoolean
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the given property, if it is currently unset.    * @param name property name    * @param value new value    */
DECL|method|setBooleanIfUnset (String name, boolean value)
specifier|public
name|void
name|setBooleanIfUnset
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|value
parameter_list|)
block|{
name|setIfUnset
argument_list|(
name|name
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the value of the<code>name</code> property to the given type. This    * is equivalent to<code>set(&lt;name&gt;, value.toString())</code>.    * @param name property name    * @param value new value    */
DECL|method|setEnum (String name, T value)
specifier|public
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|void
name|setEnum
parameter_list|(
name|String
name|name
parameter_list|,
name|T
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return value matching this enumerated type.    * @param name Property name    * @param defaultValue Value returned if no mapping exists    * @throws IllegalArgumentException If mapping is illegal for the type    * provided    */
DECL|method|getEnum (String name, T defaultValue)
specifier|public
parameter_list|<
name|T
extends|extends
name|Enum
argument_list|<
name|T
argument_list|>
parameter_list|>
name|T
name|getEnum
parameter_list|(
name|String
name|name
parameter_list|,
name|T
name|defaultValue
parameter_list|)
block|{
specifier|final
name|String
name|val
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
literal|null
operator|==
name|val
condition|?
name|defaultValue
else|:
name|Enum
operator|.
name|valueOf
argument_list|(
name|defaultValue
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/**    * Get the value of the<code>name</code> property as a<code>Pattern</code>.    * If no such property is specified, or if the specified value is not a valid    *<code>Pattern</code>, then<code>DefaultValue</code> is returned.    *    * @param name property name    * @param defaultValue default value    * @return property value as a compiled Pattern, or defaultValue    */
DECL|method|getPattern (String name, Pattern defaultValue)
specifier|public
name|Pattern
name|getPattern
parameter_list|(
name|String
name|name
parameter_list|,
name|Pattern
name|defaultValue
parameter_list|)
block|{
name|String
name|valString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|valString
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|valString
argument_list|)
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
try|try
block|{
return|return
name|Pattern
operator|.
name|compile
argument_list|(
name|valString
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|pse
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Regular expression '"
operator|+
name|valString
operator|+
literal|"' for property '"
operator|+
name|name
operator|+
literal|"' not valid. Using default"
argument_list|,
name|pse
argument_list|)
expr_stmt|;
return|return
name|defaultValue
return|;
block|}
block|}
comment|/**    * Set the given property to<code>Pattern</code>.    * If the pattern is passed as null, sets the empty pattern which results in    * further calls to getPattern(...) returning the default value.    *    * @param name property name    * @param pattern new value    */
DECL|method|setPattern (String name, Pattern pattern)
specifier|public
name|void
name|setPattern
parameter_list|(
name|String
name|name
parameter_list|,
name|Pattern
name|pattern
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|pattern
condition|)
block|{
name|set
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set
argument_list|(
name|name
argument_list|,
name|pattern
operator|.
name|pattern
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A class that represents a set of positive integer ranges. It parses     * strings of the form: "2-3,5,7-" where ranges are separated by comma and     * the lower/upper bounds are separated by dash. Either the lower or upper     * bound may be omitted meaning all values up to or over. So the string     * above means 2, 3, 5, and 7, 8, 9, ...    */
DECL|class|IntegerRanges
specifier|public
specifier|static
class|class
name|IntegerRanges
block|{
DECL|class|Range
specifier|private
specifier|static
class|class
name|Range
block|{
DECL|field|start
name|int
name|start
decl_stmt|;
DECL|field|end
name|int
name|end
decl_stmt|;
block|}
DECL|field|ranges
name|List
argument_list|<
name|Range
argument_list|>
name|ranges
init|=
operator|new
name|ArrayList
argument_list|<
name|Range
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|IntegerRanges ()
specifier|public
name|IntegerRanges
parameter_list|()
block|{     }
DECL|method|IntegerRanges (String newValue)
specifier|public
name|IntegerRanges
parameter_list|(
name|String
name|newValue
parameter_list|)
block|{
name|StringTokenizer
name|itr
init|=
operator|new
name|StringTokenizer
argument_list|(
name|newValue
argument_list|,
literal|","
argument_list|)
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|rng
init|=
name|itr
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
index|[]
name|parts
init|=
name|rng
operator|.
name|split
argument_list|(
literal|"-"
argument_list|,
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
argument_list|<
literal|1
operator|||
name|parts
operator|.
name|length
argument_list|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"integer range badly formed: "
operator|+
name|rng
argument_list|)
throw|;
block|}
name|Range
name|r
init|=
operator|new
name|Range
argument_list|()
decl_stmt|;
name|r
operator|.
name|start
operator|=
name|convertToInt
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|r
operator|.
name|end
operator|=
name|convertToInt
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|.
name|end
operator|=
name|r
operator|.
name|start
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|start
operator|>
name|r
operator|.
name|end
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"IntegerRange from "
operator|+
name|r
operator|.
name|start
operator|+
literal|" to "
operator|+
name|r
operator|.
name|end
operator|+
literal|" is invalid"
argument_list|)
throw|;
block|}
name|ranges
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Convert a string to an int treating empty strings as the default value.      * @param value the string value      * @param defaultValue the value for if the string is empty      * @return the desired integer      */
DECL|method|convertToInt (String value, int defaultValue)
specifier|private
specifier|static
name|int
name|convertToInt
parameter_list|(
name|String
name|value
parameter_list|,
name|int
name|defaultValue
parameter_list|)
block|{
name|String
name|trim
init|=
name|value
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|trim
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|trim
argument_list|)
return|;
block|}
comment|/**      * Is the given value in the set of ranges      * @param value the value to check      * @return is the value in the ranges?      */
DECL|method|isIncluded (int value)
specifier|public
name|boolean
name|isIncluded
parameter_list|(
name|int
name|value
parameter_list|)
block|{
for|for
control|(
name|Range
name|r
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|r
operator|.
name|start
operator|<=
name|value
operator|&&
name|value
operator|<=
name|r
operator|.
name|end
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Range
name|r
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
name|r
operator|.
name|start
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|r
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Parse the given attribute as a set of integer ranges    * @param name the attribute name    * @param defaultValue the default value if it is not set    * @return a new set of ranges from the configured value    */
DECL|method|getRange (String name, String defaultValue)
specifier|public
name|IntegerRanges
name|getRange
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
return|return
operator|new
name|IntegerRanges
argument_list|(
name|get
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|)
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * a collection of<code>String</code>s.      * If no such property is specified then empty collection is returned.    *<p>    * This is an optimized version of {@link #getStrings(String)}    *     * @param name property name.    * @return property value as a collection of<code>String</code>s.     */
DECL|method|getStringCollection (String name)
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getStringCollection
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|StringUtils
operator|.
name|getStringCollection
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * an array of<code>String</code>s.      * If no such property is specified then<code>null</code> is returned.    *     * @param name property name.    * @return property value as an array of<code>String</code>s,     *         or<code>null</code>.     */
DECL|method|getStrings (String name)
specifier|public
name|String
index|[]
name|getStrings
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|StringUtils
operator|.
name|getStrings
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * an array of<code>String</code>s.      * If no such property is specified then default value is returned.    *     * @param name property name.    * @param defaultValue The default value    * @return property value as an array of<code>String</code>s,     *         or default value.     */
DECL|method|getStrings (String name, String... defaultValue)
specifier|public
name|String
index|[]
name|getStrings
parameter_list|(
name|String
name|name
parameter_list|,
name|String
modifier|...
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
else|else
block|{
return|return
name|StringUtils
operator|.
name|getStrings
argument_list|(
name|valueString
argument_list|)
return|;
block|}
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * a collection of<code>String</code>s, trimmed of the leading and trailing whitespace.      * If no such property is specified then empty<code>Collection</code> is returned.    *    * @param name property name.    * @return property value as a collection of<code>String</code>s, or empty<code>Collection</code>     */
DECL|method|getTrimmedStringCollection (String name)
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getTrimmedStringCollection
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|valueString
condition|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|empty
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
return|return
name|empty
return|;
block|}
return|return
name|StringUtils
operator|.
name|getTrimmedStringCollection
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * an array of<code>String</code>s, trimmed of the leading and trailing whitespace.    * If no such property is specified then an empty array is returned.    *     * @param name property name.    * @return property value as an array of trimmed<code>String</code>s,     *         or empty array.     */
DECL|method|getTrimmedStrings (String name)
specifier|public
name|String
index|[]
name|getTrimmedStrings
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|valueString
argument_list|)
return|;
block|}
comment|/**     * Get the comma delimited values of the<code>name</code> property as     * an array of<code>String</code>s, trimmed of the leading and trailing whitespace.    * If no such property is specified then default value is returned.    *     * @param name property name.    * @param defaultValue The default value    * @return property value as an array of trimmed<code>String</code>s,     *         or default value.     */
DECL|method|getTrimmedStrings (String name, String... defaultValue)
specifier|public
name|String
index|[]
name|getTrimmedStrings
parameter_list|(
name|String
name|name
parameter_list|,
name|String
modifier|...
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|valueString
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
else|else
block|{
return|return
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|valueString
argument_list|)
return|;
block|}
block|}
comment|/**     * Set the array of string values for the<code>name</code> property as     * as comma delimited values.      *     * @param name property name.    * @param values The values    */
DECL|method|setStrings (String name, String... values)
specifier|public
name|void
name|setStrings
parameter_list|(
name|String
name|name
parameter_list|,
name|String
modifier|...
name|values
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|StringUtils
operator|.
name|arrayToString
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Load a class by name.    *     * @param name the class name.    * @return the class object.    * @throws ClassNotFoundException if the class is not found.    */
DECL|method|getClassByName (String name)
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getClassByName
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|map
decl_stmt|;
synchronized|synchronized
init|(
name|CACHE_CLASSES
init|)
block|{
name|map
operator|=
name|CACHE_CLASSES
operator|.
name|get
argument_list|(
name|classLoader
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
name|map
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|WeakHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|CACHE_CLASSES
operator|.
name|put
argument_list|(
name|classLoader
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|map
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
block|{
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|classLoader
argument_list|)
expr_stmt|;
if|if
condition|(
name|clazz
operator|!=
literal|null
condition|)
block|{
comment|// two putters can race here, but they'll put the same class
name|map
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clazz
return|;
block|}
comment|/**     * Get the value of the<code>name</code> property    * as an array of<code>Class</code>.    * The value of the property specifies a list of comma separated class names.      * If no such property is specified, then<code>defaultValue</code> is     * returned.    *     * @param name the property name.    * @param defaultValue default value.    * @return property value as a<code>Class[]</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getClasses (String name, Class<?> ... defaultValue)
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|getClasses
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getRaw
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|valueString
condition|)
block|{
return|return
name|defaultValue
return|;
block|}
name|String
index|[]
name|classnames
init|=
name|getTrimmedStrings
argument_list|(
name|name
argument_list|)
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|classes
init|=
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[
name|classnames
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|classnames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|classes
index|[
name|i
index|]
operator|=
name|getClassByName
argument_list|(
name|classnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|classes
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>Class</code>.      * If no such property is specified, then<code>defaultValue</code> is     * returned.    *     * @param name the class name.    * @param defaultValue default value.    * @return property value as a<code>Class</code>,     *         or<code>defaultValue</code>.     */
DECL|method|getClass (String name, Class<?> defaultValue)
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|getClass
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|defaultValue
parameter_list|)
block|{
name|String
name|valueString
init|=
name|getTrimmed
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueString
operator|==
literal|null
condition|)
return|return
name|defaultValue
return|;
try|try
block|{
return|return
name|getClassByName
argument_list|(
name|valueString
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**     * Get the value of the<code>name</code> property as a<code>Class</code>    * implementing the interface specified by<code>xface</code>.    *       * If no such property is specified, then<code>defaultValue</code> is     * returned.    *     * An exception is thrown if the returned class does not implement the named    * interface.     *     * @param name the class name.    * @param defaultValue default value.    * @param xface the interface implemented by the named class.    * @return property value as a<code>Class</code>,     *         or<code>defaultValue</code>.    */
DECL|method|getClass (String name, Class<? extends U> defaultValue, Class<U> xface)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|Class
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|getClass
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|defaultValue
parameter_list|,
name|Class
argument_list|<
name|U
argument_list|>
name|xface
parameter_list|)
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|theClass
init|=
name|getClass
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|theClass
operator|!=
literal|null
operator|&&
operator|!
name|xface
operator|.
name|isAssignableFrom
argument_list|(
name|theClass
argument_list|)
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|theClass
operator|+
literal|" not "
operator|+
name|xface
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
elseif|else
if|if
condition|(
name|theClass
operator|!=
literal|null
condition|)
return|return
name|theClass
operator|.
name|asSubclass
argument_list|(
name|xface
argument_list|)
return|;
else|else
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the value of the<code>name</code> property as a<code>List</code>    * of objects implementing the interface specified by<code>xface</code>.    *     * An exception is thrown if any of the classes does not exist, or if it does    * not implement the named interface.    *     * @param name the property name.    * @param xface the interface implemented by the classes named by    *<code>name</code>.    * @return a<code>List</code> of objects implementing<code>xface</code>.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getInstances (String name, Class<U> xface)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|List
argument_list|<
name|U
argument_list|>
name|getInstances
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|U
argument_list|>
name|xface
parameter_list|)
block|{
name|List
argument_list|<
name|U
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|classes
init|=
name|getClasses
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|cl
range|:
name|classes
control|)
block|{
if|if
condition|(
operator|!
name|xface
operator|.
name|isAssignableFrom
argument_list|(
name|cl
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|cl
operator|+
literal|" does not implement "
operator|+
name|xface
argument_list|)
throw|;
block|}
name|ret
operator|.
name|add
argument_list|(
operator|(
name|U
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|cl
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**     * Set the value of the<code>name</code> property to the name of a     *<code>theClass</code> implementing the given interface<code>xface</code>.    *     * An exception is thrown if<code>theClass</code> does not implement the     * interface<code>xface</code>.     *     * @param name property name.    * @param theClass property value.    * @param xface the interface implemented by the named class.    */
DECL|method|setClass (String name, Class<?> theClass, Class<?> xface)
specifier|public
name|void
name|setClass
parameter_list|(
name|String
name|name
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|theClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|xface
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xface
operator|.
name|isAssignableFrom
argument_list|(
name|theClass
argument_list|)
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|theClass
operator|+
literal|" not "
operator|+
name|xface
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
name|set
argument_list|(
name|name
argument_list|,
name|theClass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**     * Get a local file under a directory named by<i>dirsProp</i> with    * the given<i>path</i>.  If<i>dirsProp</i> contains multiple directories,    * then one is chosen based on<i>path</i>'s hash code.  If the selected    * directory does not exist, an attempt is made to create it.    *     * @param dirsProp directory in which to locate the file.    * @param path file-path.    * @return local file under the directory with the given path.    */
DECL|method|getLocalPath (String dirsProp, String path)
specifier|public
name|Path
name|getLocalPath
parameter_list|(
name|String
name|dirsProp
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|dirs
init|=
name|getTrimmedStrings
argument_list|(
name|dirsProp
argument_list|)
decl_stmt|;
name|int
name|hashCode
init|=
name|path
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|this
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// try each local dir
name|int
name|index
init|=
operator|(
name|hashCode
operator|+
name|i
operator|&
name|Integer
operator|.
name|MAX_VALUE
operator|)
operator|%
name|dirs
operator|.
name|length
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|dirs
index|[
name|index
index|]
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|Path
name|dir
init|=
name|file
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
operator|||
name|fs
operator|.
name|exists
argument_list|(
name|dir
argument_list|)
condition|)
block|{
return|return
name|file
return|;
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not make "
operator|+
name|path
operator|+
literal|" in local directories from "
operator|+
name|dirsProp
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
name|hashCode
operator|+
name|i
operator|&
name|Integer
operator|.
name|MAX_VALUE
operator|)
operator|%
name|dirs
operator|.
name|length
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|dirsProp
operator|+
literal|"["
operator|+
name|index
operator|+
literal|"]="
operator|+
name|dirs
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No valid local directories in property: "
operator|+
name|dirsProp
argument_list|)
throw|;
block|}
comment|/**     * Get a local file name under a directory named in<i>dirsProp</i> with    * the given<i>path</i>.  If<i>dirsProp</i> contains multiple directories,    * then one is chosen based on<i>path</i>'s hash code.  If the selected    * directory does not exist, an attempt is made to create it.    *     * @param dirsProp directory in which to locate the file.    * @param path file-path.    * @return local file under the directory with the given path.    */
DECL|method|getFile (String dirsProp, String path)
specifier|public
name|File
name|getFile
parameter_list|(
name|String
name|dirsProp
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|dirs
init|=
name|getTrimmedStrings
argument_list|(
name|dirsProp
argument_list|)
decl_stmt|;
name|int
name|hashCode
init|=
name|path
operator|.
name|hashCode
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// try each local dir
name|int
name|index
init|=
operator|(
name|hashCode
operator|+
name|i
operator|&
name|Integer
operator|.
name|MAX_VALUE
operator|)
operator|%
name|dirs
operator|.
name|length
decl_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dirs
index|[
name|index
index|]
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|File
name|dir
init|=
name|file
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|exists
argument_list|()
operator|||
name|dir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
return|return
name|file
return|;
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No valid local directories in property: "
operator|+
name|dirsProp
argument_list|)
throw|;
block|}
comment|/**     * Get the {@link URL} for the named resource.    *     * @param name resource name.    * @return the url for the named resource.    */
DECL|method|getResource (String name)
specifier|public
name|URL
name|getResource
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|classLoader
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**     * Get an input stream attached to the configuration resource with the    * given<code>name</code>.    *     * @param name configuration resource name.    * @return an input stream attached to the resource.    */
DECL|method|getConfResourceAsInputStream (String name)
specifier|public
name|InputStream
name|getConfResourceAsInputStream
parameter_list|(
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|URL
name|url
init|=
name|getResource
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"found resource "
operator|+
name|name
operator|+
literal|" at "
operator|+
name|url
argument_list|)
expr_stmt|;
block|}
return|return
name|url
operator|.
name|openStream
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**     * Get a {@link Reader} attached to the configuration resource with the    * given<code>name</code>.    *     * @param name configuration resource name.    * @return a reader attached to the resource.    */
DECL|method|getConfResourceAsReader (String name)
specifier|public
name|Reader
name|getConfResourceAsReader
parameter_list|(
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|URL
name|url
init|=
name|getResource
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"found resource "
operator|+
name|name
operator|+
literal|" at "
operator|+
name|url
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|InputStreamReader
argument_list|(
name|url
operator|.
name|openStream
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|method|getProps ()
specifier|protected
specifier|synchronized
name|Properties
name|getProps
parameter_list|()
block|{
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
name|properties
operator|=
operator|new
name|Properties
argument_list|()
expr_stmt|;
name|loadResources
argument_list|(
name|properties
argument_list|,
name|resources
argument_list|,
name|quietmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlay
operator|!=
literal|null
condition|)
block|{
name|properties
operator|.
name|putAll
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|overlay
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|updatingResource
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|,
name|UNKNOWN_RESOURCE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|properties
return|;
block|}
comment|/**    * Return the number of keys in the configuration.    *    * @return number of keys in the configuration.    */
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|getProps
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Clears all keys from the configuration.    */
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|getProps
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|getOverlay
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get an {@link Iterator} to go through the list of<code>String</code>     * key-value pairs in the configuration.    *     * @return an iterator over the entries.    */
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
comment|// Get a copy of just the string to string pairs. After the old object
comment|// methods that allow non-strings to be put into configurations are removed,
comment|// we could replace properties with a Map<String,String> and get rid of this
comment|// code.
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|getProps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|.
name|getKey
argument_list|()
operator|instanceof
name|String
operator|&&
name|item
operator|.
name|getValue
argument_list|()
operator|instanceof
name|String
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|item
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|loadResources (Properties properties, ArrayList resources, boolean quiet)
specifier|private
name|void
name|loadResources
parameter_list|(
name|Properties
name|properties
parameter_list|,
name|ArrayList
name|resources
parameter_list|,
name|boolean
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|loadDefaults
condition|)
block|{
for|for
control|(
name|String
name|resource
range|:
name|defaultResources
control|)
block|{
name|loadResource
argument_list|(
name|properties
argument_list|,
name|resource
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
comment|//support the hadoop-site.xml as a deprecated case
if|if
condition|(
name|getResource
argument_list|(
literal|"hadoop-site.xml"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|loadResource
argument_list|(
name|properties
argument_list|,
literal|"hadoop-site.xml"
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Object
name|resource
range|:
name|resources
control|)
block|{
name|loadResource
argument_list|(
name|properties
argument_list|,
name|resource
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|loadResource (Properties properties, Object name, boolean quiet)
specifier|private
name|void
name|loadResource
parameter_list|(
name|Properties
name|properties
parameter_list|,
name|Object
name|name
parameter_list|,
name|boolean
name|quiet
parameter_list|)
block|{
try|try
block|{
name|DocumentBuilderFactory
name|docBuilderFactory
init|=
name|DocumentBuilderFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
comment|//ignore all comments inside the xml file
name|docBuilderFactory
operator|.
name|setIgnoringComments
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//allow includes in the xml file
name|docBuilderFactory
operator|.
name|setNamespaceAware
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|docBuilderFactory
operator|.
name|setXIncludeAware
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to set setXIncludeAware(true) for parser "
operator|+
name|docBuilderFactory
operator|+
literal|":"
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|DocumentBuilder
name|builder
init|=
name|docBuilderFactory
operator|.
name|newDocumentBuilder
argument_list|()
decl_stmt|;
name|Document
name|doc
init|=
literal|null
decl_stmt|;
name|Element
name|root
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|name
operator|instanceof
name|URL
condition|)
block|{
comment|// an URL resource
name|URL
name|url
init|=
operator|(
name|URL
operator|)
name|name
decl_stmt|;
if|if
condition|(
name|url
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"parsing "
operator|+
name|url
argument_list|)
expr_stmt|;
block|}
name|doc
operator|=
name|builder
operator|.
name|parse
argument_list|(
name|url
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|instanceof
name|String
condition|)
block|{
comment|// a CLASSPATH resource
name|URL
name|url
init|=
name|getResource
argument_list|(
operator|(
name|String
operator|)
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"parsing "
operator|+
name|url
argument_list|)
expr_stmt|;
block|}
name|doc
operator|=
name|builder
operator|.
name|parse
argument_list|(
name|url
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|instanceof
name|Path
condition|)
block|{
comment|// a file resource
comment|// Can't use FileSystem API or we get an infinite loop
comment|// since FileSystem uses Configuration API.  Use java.io.File instead.
name|File
name|file
init|=
operator|new
name|File
argument_list|(
operator|(
operator|(
name|Path
operator|)
name|name
operator|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"parsing "
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
name|InputStream
name|in
init|=
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|doc
operator|=
name|builder
operator|.
name|parse
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|instanceof
name|InputStream
condition|)
block|{
try|try
block|{
name|doc
operator|=
name|builder
operator|.
name|parse
argument_list|(
operator|(
name|InputStream
operator|)
name|name
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
operator|(
operator|(
name|InputStream
operator|)
name|name
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
operator|instanceof
name|Element
condition|)
block|{
name|root
operator|=
operator|(
name|Element
operator|)
name|name
expr_stmt|;
block|}
if|if
condition|(
name|doc
operator|==
literal|null
operator|&&
name|root
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
return|return;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|name
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
name|root
operator|=
name|doc
operator|.
name|getDocumentElement
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
literal|"configuration"
operator|.
name|equals
argument_list|(
name|root
operator|.
name|getTagName
argument_list|()
argument_list|)
condition|)
name|LOG
operator|.
name|fatal
argument_list|(
literal|"bad conf file: top-level element not<configuration>"
argument_list|)
expr_stmt|;
name|NodeList
name|props
init|=
name|root
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|props
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|propNode
init|=
name|props
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|propNode
operator|instanceof
name|Element
operator|)
condition|)
continue|continue;
name|Element
name|prop
init|=
operator|(
name|Element
operator|)
name|propNode
decl_stmt|;
if|if
condition|(
literal|"configuration"
operator|.
name|equals
argument_list|(
name|prop
operator|.
name|getTagName
argument_list|()
argument_list|)
condition|)
block|{
name|loadResource
argument_list|(
name|properties
argument_list|,
name|prop
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
literal|"property"
operator|.
name|equals
argument_list|(
name|prop
operator|.
name|getTagName
argument_list|()
argument_list|)
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"bad conf file: element not<property>"
argument_list|)
expr_stmt|;
name|NodeList
name|fields
init|=
name|prop
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
name|String
name|attr
init|=
literal|null
decl_stmt|;
name|String
name|value
init|=
literal|null
decl_stmt|;
name|boolean
name|finalParameter
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fields
operator|.
name|getLength
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|Node
name|fieldNode
init|=
name|fields
operator|.
name|item
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fieldNode
operator|instanceof
name|Element
operator|)
condition|)
continue|continue;
name|Element
name|field
init|=
operator|(
name|Element
operator|)
name|fieldNode
decl_stmt|;
if|if
condition|(
literal|"name"
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getTagName
argument_list|()
argument_list|)
operator|&&
name|field
operator|.
name|hasChildNodes
argument_list|()
condition|)
name|attr
operator|=
operator|(
operator|(
name|Text
operator|)
name|field
operator|.
name|getFirstChild
argument_list|()
operator|)
operator|.
name|getData
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
literal|"value"
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getTagName
argument_list|()
argument_list|)
operator|&&
name|field
operator|.
name|hasChildNodes
argument_list|()
condition|)
name|value
operator|=
operator|(
operator|(
name|Text
operator|)
name|field
operator|.
name|getFirstChild
argument_list|()
operator|)
operator|.
name|getData
argument_list|()
expr_stmt|;
if|if
condition|(
literal|"final"
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getTagName
argument_list|()
argument_list|)
operator|&&
name|field
operator|.
name|hasChildNodes
argument_list|()
condition|)
name|finalParameter
operator|=
literal|"true"
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Text
operator|)
name|field
operator|.
name|getFirstChild
argument_list|()
operator|)
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Ignore this parameter if it has already been marked as 'final'
if|if
condition|(
name|attr
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|deprecatedKeyMap
operator|.
name|containsKey
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|DeprecatedKeyInfo
name|keyInfo
init|=
name|deprecatedKeyMap
operator|.
name|get
argument_list|(
name|attr
argument_list|)
decl_stmt|;
name|keyInfo
operator|.
name|accessed
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keyInfo
operator|.
name|newKeys
control|)
block|{
comment|// update new keys with deprecated key's value
name|loadProperty
argument_list|(
name|properties
argument_list|,
name|name
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|finalParameter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|loadProperty
argument_list|(
name|properties
argument_list|,
name|name
argument_list|,
name|attr
argument_list|,
name|value
argument_list|,
name|finalParameter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"error parsing conf file: "
operator|+
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|DOMException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"error parsing conf file: "
operator|+
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"error parsing conf file: "
operator|+
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ParserConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"error parsing conf file: "
operator|+
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|loadProperty (Properties properties, Object name, String attr, String value, boolean finalParameter)
specifier|private
name|void
name|loadProperty
parameter_list|(
name|Properties
name|properties
parameter_list|,
name|Object
name|name
parameter_list|,
name|String
name|attr
parameter_list|,
name|String
name|value
parameter_list|,
name|boolean
name|finalParameter
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|finalParameters
operator|.
name|contains
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|properties
operator|.
name|setProperty
argument_list|(
name|attr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|updatingResource
operator|.
name|put
argument_list|(
name|attr
argument_list|,
name|name
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|value
operator|.
name|equals
argument_list|(
name|properties
operator|.
name|getProperty
argument_list|(
name|attr
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|name
operator|+
literal|":an attempt to override final parameter: "
operator|+
name|attr
operator|+
literal|";  Ignoring."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|finalParameter
condition|)
block|{
name|finalParameters
operator|.
name|add
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Write out the non-default properties in this configuration to the given    * {@link OutputStream}.    *     * @param out the output stream to write to.    */
DECL|method|writeXml (OutputStream out)
specifier|public
name|void
name|writeXml
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|writeXml
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Write out the non-default properties in this configuration to the given    * {@link Writer}.    *     * @param out the writer to write to.    */
DECL|method|writeXml (Writer out)
specifier|public
name|void
name|writeXml
parameter_list|(
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|Document
name|doc
init|=
name|asXmlDocument
argument_list|()
decl_stmt|;
try|try
block|{
name|DOMSource
name|source
init|=
operator|new
name|DOMSource
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|StreamResult
name|result
init|=
operator|new
name|StreamResult
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|TransformerFactory
name|transFactory
init|=
name|TransformerFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|Transformer
name|transformer
init|=
name|transFactory
operator|.
name|newTransformer
argument_list|()
decl_stmt|;
comment|// Important to not hold Configuration log while writing result, since
comment|// 'out' may be an HDFS stream which needs to lock this configuration
comment|// from another thread.
name|transformer
operator|.
name|transform
argument_list|(
name|source
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TransformerException
name|te
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|te
argument_list|)
throw|;
block|}
block|}
comment|/**    * Return the XML DOM corresponding to this Configuration.    */
DECL|method|asXmlDocument ()
specifier|private
specifier|synchronized
name|Document
name|asXmlDocument
parameter_list|()
throws|throws
name|IOException
block|{
name|Document
name|doc
decl_stmt|;
try|try
block|{
name|doc
operator|=
name|DocumentBuilderFactory
operator|.
name|newInstance
argument_list|()
operator|.
name|newDocumentBuilder
argument_list|()
operator|.
name|newDocument
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParserConfigurationException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|pe
argument_list|)
throw|;
block|}
name|Element
name|conf
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"configuration"
argument_list|)
decl_stmt|;
name|doc
operator|.
name|appendChild
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|conf
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|getProps
argument_list|()
expr_stmt|;
comment|// ensure properties is set
for|for
control|(
name|Enumeration
name|e
init|=
name|properties
operator|.
name|keys
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|String
name|name
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Object
name|object
init|=
name|properties
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|object
operator|instanceof
name|String
condition|)
block|{
name|value
operator|=
operator|(
name|String
operator|)
name|object
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
name|Element
name|propNode
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"property"
argument_list|)
decl_stmt|;
name|conf
operator|.
name|appendChild
argument_list|(
name|propNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|updatingResource
operator|!=
literal|null
condition|)
block|{
name|Comment
name|commentNode
init|=
name|doc
operator|.
name|createComment
argument_list|(
literal|"Loaded from "
operator|+
name|updatingResource
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|propNode
operator|.
name|appendChild
argument_list|(
name|commentNode
argument_list|)
expr_stmt|;
block|}
name|Element
name|nameNode
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|nameNode
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|propNode
operator|.
name|appendChild
argument_list|(
name|nameNode
argument_list|)
expr_stmt|;
name|Element
name|valueNode
init|=
name|doc
operator|.
name|createElement
argument_list|(
literal|"value"
argument_list|)
decl_stmt|;
name|valueNode
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|propNode
operator|.
name|appendChild
argument_list|(
name|valueNode
argument_list|)
expr_stmt|;
name|conf
operator|.
name|appendChild
argument_list|(
name|doc
operator|.
name|createTextNode
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
comment|/**    *  Writes out all the parameters and their properties (final and resource) to    *  the given {@link Writer}    *  The format of the output would be     *  { "properties" : [ {key1,value1,key1.isFinal,key1.resource}, {key2,value2,    *  key2.isFinal,key2.resource}... ] }     *  It does not output the parameters of the configuration object which is     *  loaded from an input stream.    * @param out the Writer to write to    * @throws IOException    */
DECL|method|dumpConfiguration (Configuration config, Writer out)
specifier|public
specifier|static
name|void
name|dumpConfiguration
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|Writer
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|JsonFactory
name|dumpFactory
init|=
operator|new
name|JsonFactory
argument_list|()
decl_stmt|;
name|JsonGenerator
name|dumpGenerator
init|=
name|dumpFactory
operator|.
name|createJsonGenerator
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|dumpGenerator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeFieldName
argument_list|(
literal|"properties"
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStartArray
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|flush
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|config
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|config
operator|.
name|getProps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|dumpGenerator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStringField
argument_list|(
literal|"key"
argument_list|,
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStringField
argument_list|(
literal|"value"
argument_list|,
name|config
operator|.
name|get
argument_list|(
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeBooleanField
argument_list|(
literal|"isFinal"
argument_list|,
name|config
operator|.
name|finalParameters
operator|.
name|contains
argument_list|(
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStringField
argument_list|(
literal|"resource"
argument_list|,
name|config
operator|.
name|updatingResource
operator|.
name|get
argument_list|(
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
block|}
name|dumpGenerator
operator|.
name|writeEndArray
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get the {@link ClassLoader} for this job.    *     * @return the correct class loader.    */
DECL|method|getClassLoader ()
specifier|public
name|ClassLoader
name|getClassLoader
parameter_list|()
block|{
return|return
name|classLoader
return|;
block|}
comment|/**    * Set the class loader that will be used to load the various objects.    *     * @param classLoader the new class loader.    */
DECL|method|setClassLoader (ClassLoader classLoader)
specifier|public
name|void
name|setClassLoader
parameter_list|(
name|ClassLoader
name|classLoader
parameter_list|)
block|{
name|this
operator|.
name|classLoader
operator|=
name|classLoader
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Configuration: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadDefaults
condition|)
block|{
name|toString
argument_list|(
name|defaultResources
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|resources
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|toString
argument_list|(
name|resources
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|toString (List<T> resources, StringBuilder sb)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|toString
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|resources
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
block|{
name|ListIterator
argument_list|<
name|T
argument_list|>
name|i
init|=
name|resources
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|nextIndex
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Set the quietness-mode.     *     * In the quiet-mode, error and informational messages might not be logged.    *     * @param quietmode<code>true</code> to set quiet-mode on,<code>false</code>    *              to turn it off.    */
DECL|method|setQuietMode (boolean quietmode)
specifier|public
specifier|synchronized
name|void
name|setQuietMode
parameter_list|(
name|boolean
name|quietmode
parameter_list|)
block|{
name|this
operator|.
name|quietmode
operator|=
name|quietmode
expr_stmt|;
block|}
DECL|method|getQuietMode ()
specifier|synchronized
name|boolean
name|getQuietMode
parameter_list|()
block|{
return|return
name|this
operator|.
name|quietmode
return|;
block|}
comment|/** For debugging.  List non-default properties to the terminal and exit. */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
operator|new
name|Configuration
argument_list|()
operator|.
name|writeXml
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|clear
argument_list|()
expr_stmt|;
name|int
name|size
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|set
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//@Override
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|props
init|=
name|getProps
argument_list|()
decl_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|props
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|props
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
operator|(
name|String
operator|)
name|item
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * get keys matching the the regex     * @param regex    * @return Map<String,String> with matching keys    */
DECL|method|getValByRegex (String regex)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getValByRegex
parameter_list|(
name|String
name|regex
parameter_list|)
block|{
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Matcher
name|m
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|item
range|:
name|getProps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|.
name|getKey
argument_list|()
operator|instanceof
name|String
operator|&&
name|item
operator|.
name|getValue
argument_list|()
operator|instanceof
name|String
condition|)
block|{
name|m
operator|=
name|p
operator|.
name|matcher
argument_list|(
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
comment|// match
name|result
operator|.
name|put
argument_list|(
operator|(
name|String
operator|)
name|item
operator|.
name|getKey
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|item
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|//Load deprecated keys in common
DECL|method|addDeprecatedKeys ()
specifier|private
specifier|static
name|void
name|addDeprecatedKeys
parameter_list|()
block|{
name|Configuration
operator|.
name|addDeprecation
argument_list|(
literal|"topology.script.file.name"
argument_list|,
operator|new
name|String
index|[]
block|{
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY
block|}
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDeprecation
argument_list|(
literal|"topology.script.number.args"
argument_list|,
operator|new
name|String
index|[]
block|{
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY
block|}
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDeprecation
argument_list|(
literal|"hadoop.configured.node.mapping"
argument_list|,
operator|new
name|String
index|[]
block|{
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_CONFIGURED_NODE_MAPPING_KEY
block|}
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDeprecation
argument_list|(
literal|"topology.node.switch.mapping.impl"
argument_list|,
operator|new
name|String
index|[]
block|{
name|CommonConfigurationKeys
operator|.
name|NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY
block|}
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDeprecation
argument_list|(
literal|"dfs.df.interval"
argument_list|,
operator|new
name|String
index|[]
block|{
name|CommonConfigurationKeys
operator|.
name|FS_DF_INTERVAL_KEY
block|}
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDeprecation
argument_list|(
literal|"dfs.client.buffer.dir"
argument_list|,
operator|new
name|String
index|[]
block|{
name|CommonConfigurationKeys
operator|.
name|FS_CLIENT_BUFFER_DIR_KEY
block|}
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDeprecation
argument_list|(
literal|"hadoop.native.lib"
argument_list|,
operator|new
name|String
index|[]
block|{
name|CommonConfigurationKeys
operator|.
name|IO_NATIVE_LIB_AVAILABLE_KEY
block|}
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDeprecation
argument_list|(
literal|"fs.default.name"
argument_list|,
operator|new
name|String
index|[]
block|{
name|CommonConfigurationKeys
operator|.
name|FS_DEFAULT_NAME_KEY
block|}
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

