begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|ChmodParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|shell
operator|.
name|CommandFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|shell
operator|.
name|CommandFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|shell
operator|.
name|FsCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|shell
operator|.
name|PathData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_comment
comment|/**  * This class is the home for file permissions related commands.  * Moved to this separate class since FsShell is getting too large.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|FsShellPermissions
specifier|public
class|class
name|FsShellPermissions
extends|extends
name|FsCommand
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|FsShell
operator|.
name|LOG
decl_stmt|;
comment|/**    * Register the permission related commands with the factory    * @param factory the command factory    */
DECL|method|registerCommands (CommandFactory factory)
specifier|public
specifier|static
name|void
name|registerCommands
parameter_list|(
name|CommandFactory
name|factory
parameter_list|)
block|{
name|factory
operator|.
name|addClass
argument_list|(
name|Chmod
operator|.
name|class
argument_list|,
literal|"-chmod"
argument_list|)
expr_stmt|;
name|factory
operator|.
name|addClass
argument_list|(
name|Chown
operator|.
name|class
argument_list|,
literal|"-chown"
argument_list|)
expr_stmt|;
name|factory
operator|.
name|addClass
argument_list|(
name|Chgrp
operator|.
name|class
argument_list|,
literal|"-chgrp"
argument_list|)
expr_stmt|;
block|}
comment|/**    * The pattern is almost as flexible as mode allowed by chmod shell command.    * The main restriction is that we recognize only rwxXt. To reduce errors we    * also enforce octal mode specifications of either 3 digits without a sticky    * bit setting or four digits with a sticky bit setting.    */
DECL|class|Chmod
specifier|public
specifier|static
class|class
name|Chmod
extends|extends
name|FsShellPermissions
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"chmod"
decl_stmt|;
DECL|field|USAGE
specifier|public
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"[-R]<MODE[,MODE]... | OCTALMODE> PATH..."
decl_stmt|;
DECL|field|DESCRIPTION
specifier|public
specifier|static
specifier|final
name|String
name|DESCRIPTION
init|=
literal|"Changes permissions of a file. "
operator|+
literal|"This works similar to the shell's chmod command with a few exceptions.\n"
operator|+
literal|"-R: modifies the files recursively. This is the only option"
operator|+
literal|" currently supported.\n"
operator|+
literal|"<MODE>: Mode is the same as mode used for the shell's command. "
operator|+
literal|"The only letters recognized are 'rwxXt', e.g. +t,a+r,g-w,+rwx,o=r.\n"
operator|+
literal|"<OCTALMODE>: Mode specifed in 3 or 4 digits. If 4 digits, the first "
operator|+
literal|"may be 1 or 0 to turn the sticky bit on or off, respectively.  Unlike "
operator|+
literal|"the shell command, it is not possible to specify only part of the "
operator|+
literal|"mode, e.g. 754 is same as u=rwx,g=rx,o=r.\n\n"
operator|+
literal|"If none of 'augo' is specified, 'a' is assumed and unlike the "
operator|+
literal|"shell command, no umask is applied."
decl_stmt|;
DECL|field|pp
specifier|protected
name|ChmodParser
name|pp
decl_stmt|;
annotation|@
name|Override
DECL|method|processOptions (LinkedList<String> args)
specifier|protected
name|void
name|processOptions
parameter_list|(
name|LinkedList
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|CommandFormat
name|cf
init|=
operator|new
name|CommandFormat
argument_list|(
literal|2
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|"R"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|cf
operator|.
name|parse
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|setRecursive
argument_list|(
name|cf
operator|.
name|getOpt
argument_list|(
literal|"R"
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|modeStr
init|=
name|args
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
try|try
block|{
name|pp
operator|=
operator|new
name|ChmodParser
argument_list|(
name|modeStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iea
parameter_list|)
block|{
comment|// TODO: remove "chmod : " so it's not doubled up in output, but it's
comment|// here for backwards compatibility...
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"chmod : mode '"
operator|+
name|modeStr
operator|+
literal|"' does not match the expected pattern."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|processPath (PathData item)
specifier|protected
name|void
name|processPath
parameter_list|(
name|PathData
name|item
parameter_list|)
throws|throws
name|IOException
block|{
name|short
name|newperms
init|=
name|pp
operator|.
name|applyNewPermission
argument_list|(
name|item
operator|.
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|.
name|stat
operator|.
name|getPermission
argument_list|()
operator|.
name|toShort
argument_list|()
operator|!=
name|newperms
condition|)
block|{
try|try
block|{
name|item
operator|.
name|fs
operator|.
name|setPermission
argument_list|(
name|item
operator|.
name|path
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|newperms
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error changing permissions of "
operator|+
name|item
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"changing permissions of '"
operator|+
name|item
operator|+
literal|"': "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|// used by chown/chgrp
DECL|field|allowedChars
specifier|static
specifier|private
name|String
name|allowedChars
init|=
name|Shell
operator|.
name|WINDOWS
condition|?
literal|"[-_./@a-zA-Z0-9 ]"
else|:
literal|"[-_./@a-zA-Z0-9]"
decl_stmt|;
comment|/**    * Used to change owner and/or group of files     */
DECL|class|Chown
specifier|public
specifier|static
class|class
name|Chown
extends|extends
name|FsShellPermissions
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"chown"
decl_stmt|;
DECL|field|USAGE
specifier|public
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"[-R] [OWNER][:[GROUP]] PATH..."
decl_stmt|;
DECL|field|DESCRIPTION
specifier|public
specifier|static
specifier|final
name|String
name|DESCRIPTION
init|=
literal|"Changes owner and group of a file. "
operator|+
literal|"This is similar to the shell's chown command with a few exceptions.\n"
operator|+
literal|"-R: modifies the files recursively. This is the only option "
operator|+
literal|"currently supported.\n\n"
operator|+
literal|"If only the owner or group is specified, then only the owner or "
operator|+
literal|"group is modified. "
operator|+
literal|"The owner and group names may only consist of digits, alphabet, "
operator|+
literal|"and any of "
operator|+
name|allowedChars
operator|+
literal|". The names are case sensitive.\n\n"
operator|+
literal|"WARNING: Avoid using '.' to separate user name and group though "
operator|+
literal|"Linux allows it. If user names have dots in them and you are "
operator|+
literal|"using local file system, you might see surprising results since "
operator|+
literal|"the shell command 'chown' is used for local files."
decl_stmt|;
comment|///allows only "allowedChars" above in names for owner and group
DECL|field|chownPattern
specifier|static
specifier|private
specifier|final
name|Pattern
name|chownPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^\\s*("
operator|+
name|allowedChars
operator|+
literal|"+)?([:]("
operator|+
name|allowedChars
operator|+
literal|"*))?\\s*$"
argument_list|)
decl_stmt|;
DECL|field|owner
specifier|protected
name|String
name|owner
init|=
literal|null
decl_stmt|;
DECL|field|group
specifier|protected
name|String
name|group
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
DECL|method|processOptions (LinkedList<String> args)
specifier|protected
name|void
name|processOptions
parameter_list|(
name|LinkedList
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|CommandFormat
name|cf
init|=
operator|new
name|CommandFormat
argument_list|(
literal|2
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|"R"
argument_list|)
decl_stmt|;
name|cf
operator|.
name|parse
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|setRecursive
argument_list|(
name|cf
operator|.
name|getOpt
argument_list|(
literal|"R"
argument_list|)
argument_list|)
expr_stmt|;
name|parseOwnerGroup
argument_list|(
name|args
operator|.
name|removeFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parse the first argument into an owner and group      * @param ownerStr string describing new ownership      */
DECL|method|parseOwnerGroup (String ownerStr)
specifier|protected
name|void
name|parseOwnerGroup
parameter_list|(
name|String
name|ownerStr
parameter_list|)
block|{
name|Matcher
name|matcher
init|=
name|chownPattern
operator|.
name|matcher
argument_list|(
name|ownerStr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'"
operator|+
name|ownerStr
operator|+
literal|"' does not match expected pattern for [owner][:group]."
argument_list|)
throw|;
block|}
name|owner
operator|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|group
operator|=
name|matcher
operator|.
name|group
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|!=
literal|null
operator|&&
name|group
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|group
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|owner
operator|==
literal|null
operator|&&
name|group
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'"
operator|+
name|ownerStr
operator|+
literal|"' does not specify owner or group."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|processPath (PathData item)
specifier|protected
name|void
name|processPath
parameter_list|(
name|PathData
name|item
parameter_list|)
throws|throws
name|IOException
block|{
comment|//Should we do case insensitive match?
name|String
name|newOwner
init|=
operator|(
name|owner
operator|==
literal|null
operator|||
name|owner
operator|.
name|equals
argument_list|(
name|item
operator|.
name|stat
operator|.
name|getOwner
argument_list|()
argument_list|)
operator|)
condition|?
literal|null
else|:
name|owner
decl_stmt|;
name|String
name|newGroup
init|=
operator|(
name|group
operator|==
literal|null
operator|||
name|group
operator|.
name|equals
argument_list|(
name|item
operator|.
name|stat
operator|.
name|getGroup
argument_list|()
argument_list|)
operator|)
condition|?
literal|null
else|:
name|group
decl_stmt|;
if|if
condition|(
name|newOwner
operator|!=
literal|null
operator|||
name|newGroup
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|item
operator|.
name|fs
operator|.
name|setOwner
argument_list|(
name|item
operator|.
name|path
argument_list|,
name|newOwner
argument_list|,
name|newGroup
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error changing ownership of "
operator|+
name|item
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"changing ownership of '"
operator|+
name|item
operator|+
literal|"': "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Used to change group of files     */
DECL|class|Chgrp
specifier|public
specifier|static
class|class
name|Chgrp
extends|extends
name|Chown
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"chgrp"
decl_stmt|;
DECL|field|USAGE
specifier|public
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"[-R] GROUP PATH..."
decl_stmt|;
DECL|field|DESCRIPTION
specifier|public
specifier|static
specifier|final
name|String
name|DESCRIPTION
init|=
literal|"This is equivalent to -chown ... :GROUP ..."
decl_stmt|;
DECL|field|chgrpPattern
specifier|static
specifier|private
specifier|final
name|Pattern
name|chgrpPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^\\s*("
operator|+
name|allowedChars
operator|+
literal|"+)\\s*$"
argument_list|)
decl_stmt|;
annotation|@
name|Override
DECL|method|parseOwnerGroup (String groupStr)
specifier|protected
name|void
name|parseOwnerGroup
parameter_list|(
name|String
name|groupStr
parameter_list|)
block|{
name|Matcher
name|matcher
init|=
name|chgrpPattern
operator|.
name|matcher
argument_list|(
name|groupStr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"'"
operator|+
name|groupStr
operator|+
literal|"' does not match expected pattern for group"
argument_list|)
throw|;
block|}
name|owner
operator|=
literal|null
expr_stmt|;
name|group
operator|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

