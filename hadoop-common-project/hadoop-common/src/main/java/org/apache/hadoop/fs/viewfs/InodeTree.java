begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.viewfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|viewfs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnsupportedFileSystemException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * InodeTree implements a mount-table as a tree of inodes.  * It is used to implement ViewFs and ViewFileSystem.  * In order to use it the caller must subclass it and implement  * the abstract methods {@link #getTargetFileSystem(INodeDir)}, etc.  *  * The mountable is initialized from the config variables as   * specified in {@link ViewFs}  *  * @param<T> is AbstractFileSystem or FileSystem  *  * The two main methods are  * {@link #InodeTree(Configuration, String)} // constructor  * {@link #resolve(String, boolean)}   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|InodeTree
specifier|abstract
class|class
name|InodeTree
parameter_list|<
name|T
parameter_list|>
block|{
DECL|enum|ResultKind
enum|enum
name|ResultKind
block|{
DECL|enumConstant|INTERNAL_DIR
name|INTERNAL_DIR
block|,
DECL|enumConstant|EXTERNAL_DIR
name|EXTERNAL_DIR
block|}
DECL|field|SlashPath
specifier|static
specifier|final
name|Path
name|SlashPath
init|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
DECL|field|root
specifier|private
specifier|final
name|INodeDir
argument_list|<
name|T
argument_list|>
name|root
decl_stmt|;
comment|// the root of the mount table
DECL|field|homedirPrefix
specifier|private
specifier|final
name|String
name|homedirPrefix
decl_stmt|;
comment|// the homedir for this mount table
DECL|field|mountPoints
specifier|private
name|List
argument_list|<
name|MountPoint
argument_list|<
name|T
argument_list|>
argument_list|>
name|mountPoints
init|=
operator|new
name|ArrayList
argument_list|<
name|MountPoint
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|class|MountPoint
specifier|static
class|class
name|MountPoint
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|src
name|String
name|src
decl_stmt|;
DECL|field|target
name|INodeLink
argument_list|<
name|T
argument_list|>
name|target
decl_stmt|;
DECL|method|MountPoint (String srcPath, INodeLink<T> mountLink)
name|MountPoint
parameter_list|(
name|String
name|srcPath
parameter_list|,
name|INodeLink
argument_list|<
name|T
argument_list|>
name|mountLink
parameter_list|)
block|{
name|src
operator|=
name|srcPath
expr_stmt|;
name|target
operator|=
name|mountLink
expr_stmt|;
block|}
block|}
comment|/**    * Breaks file path into component names.    * @param path    * @return array of names component names    */
DECL|method|breakIntoPathComponents (final String path)
specifier|static
name|String
index|[]
name|breakIntoPathComponents
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
block|{
return|return
name|path
operator|==
literal|null
condition|?
literal|null
else|:
name|path
operator|.
name|split
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
return|;
block|}
comment|/**    * Internal class for inode tree    * @param<T>    */
DECL|class|INode
specifier|abstract
specifier|static
class|class
name|INode
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|fullPath
specifier|final
name|String
name|fullPath
decl_stmt|;
comment|// the full path to the root
DECL|method|INode (String pathToNode, UserGroupInformation aUgi)
specifier|public
name|INode
parameter_list|(
name|String
name|pathToNode
parameter_list|,
name|UserGroupInformation
name|aUgi
parameter_list|)
block|{
name|fullPath
operator|=
name|pathToNode
expr_stmt|;
block|}
block|}
comment|/**    * Internal class to represent an internal dir of the mount table    * @param<T>    */
DECL|class|INodeDir
specifier|static
class|class
name|INodeDir
parameter_list|<
name|T
parameter_list|>
extends|extends
name|INode
argument_list|<
name|T
argument_list|>
block|{
DECL|field|children
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|INode
argument_list|<
name|T
argument_list|>
argument_list|>
name|children
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|INode
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|InodeDirFs
name|T
name|InodeDirFs
init|=
literal|null
decl_stmt|;
comment|// file system of this internal directory of mountT
DECL|field|isRoot
name|boolean
name|isRoot
init|=
literal|false
decl_stmt|;
DECL|method|INodeDir (final String pathToNode, final UserGroupInformation aUgi)
name|INodeDir
parameter_list|(
specifier|final
name|String
name|pathToNode
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|)
block|{
name|super
argument_list|(
name|pathToNode
argument_list|,
name|aUgi
argument_list|)
expr_stmt|;
block|}
DECL|method|resolveInternal (final String pathComponent)
name|INode
argument_list|<
name|T
argument_list|>
name|resolveInternal
parameter_list|(
specifier|final
name|String
name|pathComponent
parameter_list|)
block|{
return|return
name|children
operator|.
name|get
argument_list|(
name|pathComponent
argument_list|)
return|;
block|}
DECL|method|addDir (final String pathComponent, final UserGroupInformation aUgi)
name|INodeDir
argument_list|<
name|T
argument_list|>
name|addDir
parameter_list|(
specifier|final
name|String
name|pathComponent
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|)
throws|throws
name|FileAlreadyExistsException
block|{
if|if
condition|(
name|children
operator|.
name|containsKey
argument_list|(
name|pathComponent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|()
throw|;
block|}
specifier|final
name|INodeDir
argument_list|<
name|T
argument_list|>
name|newDir
init|=
operator|new
name|INodeDir
argument_list|<
name|T
argument_list|>
argument_list|(
name|fullPath
operator|+
operator|(
name|isRoot
condition|?
literal|""
else|:
literal|"/"
operator|)
operator|+
name|pathComponent
argument_list|,
name|aUgi
argument_list|)
decl_stmt|;
name|children
operator|.
name|put
argument_list|(
name|pathComponent
argument_list|,
name|newDir
argument_list|)
expr_stmt|;
return|return
name|newDir
return|;
block|}
DECL|method|addLink (final String pathComponent, final INodeLink<T> link)
name|void
name|addLink
parameter_list|(
specifier|final
name|String
name|pathComponent
parameter_list|,
specifier|final
name|INodeLink
argument_list|<
name|T
argument_list|>
name|link
parameter_list|)
throws|throws
name|FileAlreadyExistsException
block|{
if|if
condition|(
name|children
operator|.
name|containsKey
argument_list|(
name|pathComponent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|()
throw|;
block|}
name|children
operator|.
name|put
argument_list|(
name|pathComponent
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * An internal class to represent a mount link.    * A mount link can be single dir link or a merge dir link.     * A merge dir link is  a merge (junction) of links to dirs:    * example : merge of 2 dirs    *     /users -> hdfs:nn1//users    *     /users -> hdfs:nn2//users    *    * For a merge, each target is checked to be dir when created but if target    * is changed later it is then ignored (a dir with null entries)    */
DECL|class|INodeLink
specifier|static
class|class
name|INodeLink
parameter_list|<
name|T
parameter_list|>
extends|extends
name|INode
argument_list|<
name|T
argument_list|>
block|{
DECL|field|isMergeLink
specifier|final
name|boolean
name|isMergeLink
decl_stmt|;
comment|// true if MergeLink
DECL|field|targetDirLinkList
specifier|final
name|URI
index|[]
name|targetDirLinkList
decl_stmt|;
DECL|field|targetFileSystem
specifier|final
name|T
name|targetFileSystem
decl_stmt|;
comment|// file system object created from the link.
comment|/**      * Construct a mergeLink.      */
DECL|method|INodeLink (final String pathToNode, final UserGroupInformation aUgi, final T targetMergeFs, final URI[] aTargetDirLinkList)
name|INodeLink
parameter_list|(
specifier|final
name|String
name|pathToNode
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|,
specifier|final
name|T
name|targetMergeFs
parameter_list|,
specifier|final
name|URI
index|[]
name|aTargetDirLinkList
parameter_list|)
block|{
name|super
argument_list|(
name|pathToNode
argument_list|,
name|aUgi
argument_list|)
expr_stmt|;
name|targetFileSystem
operator|=
name|targetMergeFs
expr_stmt|;
name|targetDirLinkList
operator|=
name|aTargetDirLinkList
expr_stmt|;
name|isMergeLink
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Construct a simple link (i.e. not a mergeLink).      */
DECL|method|INodeLink (final String pathToNode, final UserGroupInformation aUgi, final T targetFs, final URI aTargetDirLink)
name|INodeLink
parameter_list|(
specifier|final
name|String
name|pathToNode
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|,
specifier|final
name|T
name|targetFs
parameter_list|,
specifier|final
name|URI
name|aTargetDirLink
parameter_list|)
block|{
name|super
argument_list|(
name|pathToNode
argument_list|,
name|aUgi
argument_list|)
expr_stmt|;
name|targetFileSystem
operator|=
name|targetFs
expr_stmt|;
name|targetDirLinkList
operator|=
operator|new
name|URI
index|[
literal|1
index|]
expr_stmt|;
name|targetDirLinkList
index|[
literal|0
index|]
operator|=
name|aTargetDirLink
expr_stmt|;
name|isMergeLink
operator|=
literal|false
expr_stmt|;
block|}
comment|/**      * Get the target of the link. If a merge link then it returned      * as "," separated URI list.      */
DECL|method|getTargetLink ()
name|Path
name|getTargetLink
parameter_list|()
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
name|targetDirLinkList
index|[
literal|0
index|]
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|// If merge link, use "," as separator between the merged URIs
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|targetDirLinkList
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
name|targetDirLinkList
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Path
argument_list|(
name|result
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|createLink (final String src, final String target, final boolean isLinkMerge, final UserGroupInformation aUgi)
specifier|private
name|void
name|createLink
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|String
name|target
parameter_list|,
specifier|final
name|boolean
name|isLinkMerge
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|)
throws|throws
name|URISyntaxException
throws|,
name|IOException
throws|,
name|FileAlreadyExistsException
throws|,
name|UnsupportedFileSystemException
block|{
comment|// Validate that src is valid absolute path
specifier|final
name|Path
name|srcPath
init|=
operator|new
name|Path
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|srcPath
operator|.
name|isAbsoluteAndSchemeAuthorityNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ViewFs: Non absolute mount name in config:"
operator|+
name|src
argument_list|)
throw|;
block|}
specifier|final
name|String
index|[]
name|srcPaths
init|=
name|breakIntoPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|INodeDir
argument_list|<
name|T
argument_list|>
name|curInode
init|=
name|root
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|// Ignore first initial slash, process all except last component
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|srcPaths
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|iPath
init|=
name|srcPaths
index|[
name|i
index|]
decl_stmt|;
name|INode
argument_list|<
name|T
argument_list|>
name|nextInode
init|=
name|curInode
operator|.
name|resolveInternal
argument_list|(
name|iPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextInode
operator|==
literal|null
condition|)
block|{
name|INodeDir
argument_list|<
name|T
argument_list|>
name|newDir
init|=
name|curInode
operator|.
name|addDir
argument_list|(
name|iPath
argument_list|,
name|aUgi
argument_list|)
decl_stmt|;
name|newDir
operator|.
name|InodeDirFs
operator|=
name|getTargetFileSystem
argument_list|(
name|newDir
argument_list|)
expr_stmt|;
name|nextInode
operator|=
name|newDir
expr_stmt|;
block|}
if|if
condition|(
name|nextInode
operator|instanceof
name|INodeLink
condition|)
block|{
comment|// Error - expected a dir but got a link
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Path "
operator|+
name|nextInode
operator|.
name|fullPath
operator|+
literal|" already exists as link"
argument_list|)
throw|;
block|}
else|else
block|{
assert|assert
operator|(
name|nextInode
operator|instanceof
name|INodeDir
operator|)
assert|;
name|curInode
operator|=
operator|(
name|INodeDir
argument_list|<
name|T
argument_list|>
operator|)
name|nextInode
expr_stmt|;
block|}
block|}
comment|// Now process the last component
comment|// Add the link in 2 cases: does not exist or a link exists
name|String
name|iPath
init|=
name|srcPaths
index|[
name|i
index|]
decl_stmt|;
comment|// last component
if|if
condition|(
name|curInode
operator|.
name|resolveInternal
argument_list|(
name|iPath
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|//  directory/link already exists
name|StringBuilder
name|strB
init|=
operator|new
name|StringBuilder
argument_list|(
name|srcPaths
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|i
condition|;
operator|++
name|j
control|)
block|{
name|strB
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|srcPaths
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Path "
operator|+
name|strB
operator|+
literal|" already exists as dir; cannot create link here"
argument_list|)
throw|;
block|}
specifier|final
name|INodeLink
argument_list|<
name|T
argument_list|>
name|newLink
decl_stmt|;
specifier|final
name|String
name|fullPath
init|=
name|curInode
operator|.
name|fullPath
operator|+
operator|(
name|curInode
operator|==
name|root
condition|?
literal|""
else|:
literal|"/"
operator|)
operator|+
name|iPath
decl_stmt|;
if|if
condition|(
name|isLinkMerge
condition|)
block|{
comment|// Target is list of URIs
name|String
index|[]
name|targetsList
init|=
name|StringUtils
operator|.
name|getStrings
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|URI
index|[]
name|targetsListURI
init|=
operator|new
name|URI
index|[
name|targetsList
operator|.
name|length
index|]
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|itarget
range|:
name|targetsList
control|)
block|{
name|targetsListURI
index|[
name|k
operator|++
index|]
operator|=
operator|new
name|URI
argument_list|(
name|itarget
argument_list|)
expr_stmt|;
block|}
name|newLink
operator|=
operator|new
name|INodeLink
argument_list|<
name|T
argument_list|>
argument_list|(
name|fullPath
argument_list|,
name|aUgi
argument_list|,
name|getTargetFileSystem
argument_list|(
name|targetsListURI
argument_list|)
argument_list|,
name|targetsListURI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newLink
operator|=
operator|new
name|INodeLink
argument_list|<
name|T
argument_list|>
argument_list|(
name|fullPath
argument_list|,
name|aUgi
argument_list|,
name|getTargetFileSystem
argument_list|(
operator|new
name|URI
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
operator|new
name|URI
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|curInode
operator|.
name|addLink
argument_list|(
name|iPath
argument_list|,
name|newLink
argument_list|)
expr_stmt|;
name|mountPoints
operator|.
name|add
argument_list|(
operator|new
name|MountPoint
argument_list|<
name|T
argument_list|>
argument_list|(
name|src
argument_list|,
name|newLink
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * The user of this class must subclass and implement the following    * 3 abstract methods.    * @throws IOException    */
DECL|method|getTargetFileSystem (final URI uri)
specifier|protected
specifier|abstract
name|T
name|getTargetFileSystem
parameter_list|(
specifier|final
name|URI
name|uri
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
throws|,
name|URISyntaxException
throws|,
name|IOException
function_decl|;
DECL|method|getTargetFileSystem (final INodeDir<T> dir)
specifier|protected
specifier|abstract
name|T
name|getTargetFileSystem
parameter_list|(
specifier|final
name|INodeDir
argument_list|<
name|T
argument_list|>
name|dir
parameter_list|)
throws|throws
name|URISyntaxException
function_decl|;
DECL|method|getTargetFileSystem (final URI[] mergeFsURIList)
specifier|protected
specifier|abstract
name|T
name|getTargetFileSystem
parameter_list|(
specifier|final
name|URI
index|[]
name|mergeFsURIList
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
throws|,
name|URISyntaxException
function_decl|;
comment|/**    * Create Inode Tree from the specified mount-table specified in Config    * @param config - the mount table keys are prefixed with     *       FsConstants.CONFIG_VIEWFS_PREFIX    * @param viewName - the name of the mount table - if null use defaultMT name    * @throws UnsupportedFileSystemException    * @throws URISyntaxException    * @throws FileAlreadyExistsException    * @throws IOException    */
DECL|method|InodeTree (final Configuration config, final String viewName)
specifier|protected
name|InodeTree
parameter_list|(
specifier|final
name|Configuration
name|config
parameter_list|,
specifier|final
name|String
name|viewName
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
throws|,
name|URISyntaxException
throws|,
name|FileAlreadyExistsException
throws|,
name|IOException
block|{
name|String
name|vName
init|=
name|viewName
decl_stmt|;
if|if
condition|(
name|vName
operator|==
literal|null
condition|)
block|{
name|vName
operator|=
name|Constants
operator|.
name|CONFIG_VIEWFS_DEFAULT_MOUNT_TABLE
expr_stmt|;
block|}
name|homedirPrefix
operator|=
name|ConfigUtil
operator|.
name|getHomeDirValue
argument_list|(
name|config
argument_list|,
name|vName
argument_list|)
expr_stmt|;
name|root
operator|=
operator|new
name|INodeDir
argument_list|<
name|T
argument_list|>
argument_list|(
literal|"/"
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|.
name|InodeDirFs
operator|=
name|getTargetFileSystem
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|.
name|isRoot
operator|=
literal|true
expr_stmt|;
specifier|final
name|String
name|mtPrefix
init|=
name|Constants
operator|.
name|CONFIG_VIEWFS_PREFIX
operator|+
literal|"."
operator|+
name|vName
operator|+
literal|"."
decl_stmt|;
specifier|final
name|String
name|linkPrefix
init|=
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK
operator|+
literal|"."
decl_stmt|;
specifier|final
name|String
name|linkMergePrefix
init|=
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK_MERGE
operator|+
literal|"."
decl_stmt|;
name|boolean
name|gotMountTableEntry
init|=
literal|false
decl_stmt|;
specifier|final
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|si
range|:
name|config
control|)
block|{
specifier|final
name|String
name|key
init|=
name|si
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
name|mtPrefix
argument_list|)
condition|)
block|{
name|gotMountTableEntry
operator|=
literal|true
expr_stmt|;
name|boolean
name|isMergeLink
init|=
literal|false
decl_stmt|;
name|String
name|src
init|=
name|key
operator|.
name|substring
argument_list|(
name|mtPrefix
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|linkPrefix
argument_list|)
condition|)
block|{
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
name|linkPrefix
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|linkMergePrefix
argument_list|)
condition|)
block|{
comment|// A merge link
name|isMergeLink
operator|=
literal|true
expr_stmt|;
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
name|linkMergePrefix
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|Constants
operator|.
name|CONFIG_VIEWFS_HOMEDIR
argument_list|)
condition|)
block|{
comment|// ignore - we set home dir from config
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ViewFs: Cannot initialize: Invalid entry in "
operator|+
literal|"Mount table in config: "
operator|+
name|src
argument_list|)
throw|;
block|}
specifier|final
name|String
name|target
init|=
name|si
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// link or merge link
name|createLink
argument_list|(
name|src
argument_list|,
name|target
argument_list|,
name|isMergeLink
argument_list|,
name|ugi
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|gotMountTableEntry
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ViewFs: Cannot initialize: Empty Mount table in config for "
operator|+
literal|"viewfs://"
operator|+
name|vName
operator|+
literal|"/"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Resolve returns ResolveResult.    * The caller can continue the resolution of the remainingPath    * in the targetFileSystem.    *    * If the input pathname leads to link to another file system then    * the targetFileSystem is the one denoted by the link (except it is    * file system chrooted to link target.    * If the input pathname leads to an internal mount-table entry then    * the target file system is one that represents the internal inode.    */
DECL|class|ResolveResult
specifier|static
class|class
name|ResolveResult
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|kind
specifier|final
name|ResultKind
name|kind
decl_stmt|;
DECL|field|targetFileSystem
specifier|final
name|T
name|targetFileSystem
decl_stmt|;
DECL|field|resolvedPath
specifier|final
name|String
name|resolvedPath
decl_stmt|;
DECL|field|remainingPath
specifier|final
name|Path
name|remainingPath
decl_stmt|;
comment|// to resolve in the target FileSystem
DECL|method|ResolveResult (final ResultKind k, final T targetFs, final String resolveP, final Path remainingP)
name|ResolveResult
parameter_list|(
specifier|final
name|ResultKind
name|k
parameter_list|,
specifier|final
name|T
name|targetFs
parameter_list|,
specifier|final
name|String
name|resolveP
parameter_list|,
specifier|final
name|Path
name|remainingP
parameter_list|)
block|{
name|kind
operator|=
name|k
expr_stmt|;
name|targetFileSystem
operator|=
name|targetFs
expr_stmt|;
name|resolvedPath
operator|=
name|resolveP
expr_stmt|;
name|remainingPath
operator|=
name|remainingP
expr_stmt|;
block|}
comment|// Internal dir path resolution completed within the mount table
DECL|method|isInternalDir ()
name|boolean
name|isInternalDir
parameter_list|()
block|{
return|return
operator|(
name|kind
operator|==
name|ResultKind
operator|.
name|INTERNAL_DIR
operator|)
return|;
block|}
block|}
comment|/**    * Resolve the pathname p relative to root InodeDir    * @param p - inout path    * @param resolveLastComponent    * @return ResolveResult which allows further resolution of the remaining path    * @throws FileNotFoundException    */
DECL|method|resolve (final String p, final boolean resolveLastComponent)
name|ResolveResult
argument_list|<
name|T
argument_list|>
name|resolve
parameter_list|(
specifier|final
name|String
name|p
parameter_list|,
specifier|final
name|boolean
name|resolveLastComponent
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|String
index|[]
name|path
init|=
name|breakIntoPathComponents
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|length
operator|<=
literal|1
condition|)
block|{
comment|// special case for when path is "/"
name|ResolveResult
argument_list|<
name|T
argument_list|>
name|res
init|=
operator|new
name|ResolveResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|ResultKind
operator|.
name|INTERNAL_DIR
argument_list|,
name|root
operator|.
name|InodeDirFs
argument_list|,
name|root
operator|.
name|fullPath
argument_list|,
name|SlashPath
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
name|INodeDir
argument_list|<
name|T
argument_list|>
name|curInode
init|=
name|root
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|// ignore first slash
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|path
operator|.
name|length
operator|-
operator|(
name|resolveLastComponent
condition|?
literal|0
else|:
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|INode
argument_list|<
name|T
argument_list|>
name|nextInode
init|=
name|curInode
operator|.
name|resolveInternal
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextInode
operator|==
literal|null
condition|)
block|{
name|StringBuilder
name|failedAt
init|=
operator|new
name|StringBuilder
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|i
condition|;
operator|++
name|j
control|)
block|{
name|failedAt
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|path
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|(
operator|new
name|FileNotFoundException
argument_list|(
name|failedAt
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
throw|;
block|}
if|if
condition|(
name|nextInode
operator|instanceof
name|INodeLink
condition|)
block|{
specifier|final
name|INodeLink
argument_list|<
name|T
argument_list|>
name|link
init|=
operator|(
name|INodeLink
argument_list|<
name|T
argument_list|>
operator|)
name|nextInode
decl_stmt|;
specifier|final
name|Path
name|remainingPath
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|path
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|remainingPath
operator|=
name|SlashPath
expr_stmt|;
block|}
else|else
block|{
name|StringBuilder
name|remainingPathStr
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"/"
operator|+
name|path
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|2
init|;
name|j
operator|<
name|path
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|remainingPathStr
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|path
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|remainingPath
operator|=
operator|new
name|Path
argument_list|(
name|remainingPathStr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ResolveResult
argument_list|<
name|T
argument_list|>
name|res
init|=
operator|new
name|ResolveResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|ResultKind
operator|.
name|EXTERNAL_DIR
argument_list|,
name|link
operator|.
name|targetFileSystem
argument_list|,
name|nextInode
operator|.
name|fullPath
argument_list|,
name|remainingPath
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
elseif|else
if|if
condition|(
name|nextInode
operator|instanceof
name|INodeDir
condition|)
block|{
name|curInode
operator|=
operator|(
name|INodeDir
argument_list|<
name|T
argument_list|>
operator|)
name|nextInode
expr_stmt|;
block|}
block|}
comment|// We have resolved to an internal dir in mount table.
name|Path
name|remainingPath
decl_stmt|;
if|if
condition|(
name|resolveLastComponent
condition|)
block|{
name|remainingPath
operator|=
name|SlashPath
expr_stmt|;
block|}
else|else
block|{
comment|// note we have taken care of when path is "/" above
comment|// for internal dirs rem-path does not start with / since the lookup
comment|// that follows will do a children.get(remaningPath) and will have to
comment|// strip-out the initial /
name|StringBuilder
name|remainingPathStr
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"/"
operator|+
name|path
index|[
name|i
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|path
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|remainingPathStr
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|path
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|remainingPath
operator|=
operator|new
name|Path
argument_list|(
name|remainingPathStr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ResolveResult
argument_list|<
name|T
argument_list|>
name|res
init|=
operator|new
name|ResolveResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|ResultKind
operator|.
name|INTERNAL_DIR
argument_list|,
name|curInode
operator|.
name|InodeDirFs
argument_list|,
name|curInode
operator|.
name|fullPath
argument_list|,
name|remainingPath
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
DECL|method|getMountPoints ()
name|List
argument_list|<
name|MountPoint
argument_list|<
name|T
argument_list|>
argument_list|>
name|getMountPoints
parameter_list|()
block|{
return|return
name|mountPoints
return|;
block|}
comment|/**    *    * @return home dir value from mount table; null if no config value    * was found.    */
DECL|method|getHomeDirPrefixValue ()
name|String
name|getHomeDirPrefixValue
parameter_list|()
block|{
return|return
name|homedirPrefix
return|;
block|}
block|}
end_class

end_unit

