begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.viewfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|viewfs
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnsupportedFileSystemException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * InodeTree implements a mount-table as a tree of inodes.  * It is used to implement ViewFs and ViewFileSystem.  * In order to use it the caller must subclass it and implement  * the abstract methods {@link #getTargetFileSystem(INodeDir)}, etc.  *  * The mountable is initialized from the config variables as   * specified in {@link ViewFs}  *  * @param<T> is AbstractFileSystem or FileSystem  *  * The two main methods are  * {@link #InodeTree(Configuration, String)} // constructor  * {@link #resolve(String, boolean)}   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|InodeTree
specifier|abstract
class|class
name|InodeTree
parameter_list|<
name|T
parameter_list|>
block|{
DECL|enum|ResultKind
enum|enum
name|ResultKind
block|{
DECL|enumConstant|INTERNAL_DIR
name|INTERNAL_DIR
block|,
DECL|enumConstant|EXTERNAL_DIR
name|EXTERNAL_DIR
block|}
DECL|field|SlashPath
specifier|static
specifier|final
name|Path
name|SlashPath
init|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
comment|// the root of the mount table
DECL|field|root
specifier|private
specifier|final
name|INode
argument_list|<
name|T
argument_list|>
name|root
decl_stmt|;
comment|// the fallback filesystem
DECL|field|rootFallbackLink
specifier|private
specifier|final
name|INodeLink
argument_list|<
name|T
argument_list|>
name|rootFallbackLink
decl_stmt|;
comment|// the homedir for this mount table
DECL|field|homedirPrefix
specifier|private
specifier|final
name|String
name|homedirPrefix
decl_stmt|;
DECL|field|mountPoints
specifier|private
name|List
argument_list|<
name|MountPoint
argument_list|<
name|T
argument_list|>
argument_list|>
name|mountPoints
init|=
operator|new
name|ArrayList
argument_list|<
name|MountPoint
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|class|MountPoint
specifier|static
class|class
name|MountPoint
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|src
name|String
name|src
decl_stmt|;
DECL|field|target
name|INodeLink
argument_list|<
name|T
argument_list|>
name|target
decl_stmt|;
DECL|method|MountPoint (String srcPath, INodeLink<T> mountLink)
name|MountPoint
parameter_list|(
name|String
name|srcPath
parameter_list|,
name|INodeLink
argument_list|<
name|T
argument_list|>
name|mountLink
parameter_list|)
block|{
name|src
operator|=
name|srcPath
expr_stmt|;
name|target
operator|=
name|mountLink
expr_stmt|;
block|}
block|}
comment|/**    * Breaks file path into component names.    * @param path    * @return array of names component names    */
DECL|method|breakIntoPathComponents (final String path)
specifier|static
name|String
index|[]
name|breakIntoPathComponents
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
block|{
return|return
name|path
operator|==
literal|null
condition|?
literal|null
else|:
name|path
operator|.
name|split
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
return|;
block|}
comment|/**    * Internal class for INode tree.    * @param<T>    */
DECL|class|INode
specifier|abstract
specifier|static
class|class
name|INode
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|fullPath
specifier|final
name|String
name|fullPath
decl_stmt|;
comment|// the full path to the root
DECL|method|INode (String pathToNode, UserGroupInformation aUgi)
specifier|public
name|INode
parameter_list|(
name|String
name|pathToNode
parameter_list|,
name|UserGroupInformation
name|aUgi
parameter_list|)
block|{
name|fullPath
operator|=
name|pathToNode
expr_stmt|;
block|}
comment|// INode forming the internal mount table directory tree
comment|// for ViewFileSystem. This internal directory tree is
comment|// constructed based on the mount table config entries
comment|// and is read only.
DECL|method|isInternalDir ()
specifier|abstract
name|boolean
name|isInternalDir
parameter_list|()
function_decl|;
comment|// INode linking to another filesystem. Represented
comment|// via mount table link config entries.
DECL|method|isLink ()
name|boolean
name|isLink
parameter_list|()
block|{
return|return
operator|!
name|isInternalDir
argument_list|()
return|;
block|}
block|}
comment|/**    * Internal class to represent an internal dir of the mount table.    * @param<T>    */
DECL|class|INodeDir
specifier|static
class|class
name|INodeDir
parameter_list|<
name|T
parameter_list|>
extends|extends
name|INode
argument_list|<
name|T
argument_list|>
block|{
DECL|field|children
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|INode
argument_list|<
name|T
argument_list|>
argument_list|>
name|children
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|internalDirFs
specifier|private
name|T
name|internalDirFs
init|=
literal|null
decl_stmt|;
comment|//filesystem of this internal directory
DECL|field|isRoot
specifier|private
name|boolean
name|isRoot
init|=
literal|false
decl_stmt|;
DECL|method|INodeDir (final String pathToNode, final UserGroupInformation aUgi)
name|INodeDir
parameter_list|(
specifier|final
name|String
name|pathToNode
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|)
block|{
name|super
argument_list|(
name|pathToNode
argument_list|,
name|aUgi
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isInternalDir ()
name|boolean
name|isInternalDir
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|method|getInternalDirFs ()
name|T
name|getInternalDirFs
parameter_list|()
block|{
return|return
name|internalDirFs
return|;
block|}
DECL|method|setInternalDirFs (T internalDirFs)
name|void
name|setInternalDirFs
parameter_list|(
name|T
name|internalDirFs
parameter_list|)
block|{
name|this
operator|.
name|internalDirFs
operator|=
name|internalDirFs
expr_stmt|;
block|}
DECL|method|setRoot (boolean root)
name|void
name|setRoot
parameter_list|(
name|boolean
name|root
parameter_list|)
block|{
name|isRoot
operator|=
name|root
expr_stmt|;
block|}
DECL|method|isRoot ()
name|boolean
name|isRoot
parameter_list|()
block|{
return|return
name|isRoot
return|;
block|}
DECL|method|getChildren ()
name|Map
argument_list|<
name|String
argument_list|,
name|INode
argument_list|<
name|T
argument_list|>
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|children
argument_list|)
return|;
block|}
DECL|method|resolveInternal (final String pathComponent)
name|INode
argument_list|<
name|T
argument_list|>
name|resolveInternal
parameter_list|(
specifier|final
name|String
name|pathComponent
parameter_list|)
block|{
return|return
name|children
operator|.
name|get
argument_list|(
name|pathComponent
argument_list|)
return|;
block|}
DECL|method|addDir (final String pathComponent, final UserGroupInformation aUgi)
name|INodeDir
argument_list|<
name|T
argument_list|>
name|addDir
parameter_list|(
specifier|final
name|String
name|pathComponent
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|)
throws|throws
name|FileAlreadyExistsException
block|{
if|if
condition|(
name|children
operator|.
name|containsKey
argument_list|(
name|pathComponent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|()
throw|;
block|}
specifier|final
name|INodeDir
argument_list|<
name|T
argument_list|>
name|newDir
init|=
operator|new
name|INodeDir
argument_list|<
name|T
argument_list|>
argument_list|(
name|fullPath
operator|+
operator|(
name|isRoot
argument_list|()
condition|?
literal|""
else|:
literal|"/"
operator|)
operator|+
name|pathComponent
argument_list|,
name|aUgi
argument_list|)
decl_stmt|;
name|children
operator|.
name|put
argument_list|(
name|pathComponent
argument_list|,
name|newDir
argument_list|)
expr_stmt|;
return|return
name|newDir
return|;
block|}
DECL|method|addLink (final String pathComponent, final INodeLink<T> link)
name|void
name|addLink
parameter_list|(
specifier|final
name|String
name|pathComponent
parameter_list|,
specifier|final
name|INodeLink
argument_list|<
name|T
argument_list|>
name|link
parameter_list|)
throws|throws
name|FileAlreadyExistsException
block|{
if|if
condition|(
name|children
operator|.
name|containsKey
argument_list|(
name|pathComponent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|()
throw|;
block|}
name|children
operator|.
name|put
argument_list|(
name|pathComponent
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Mount table link type.    */
DECL|enum|LinkType
enum|enum
name|LinkType
block|{
comment|/**      * Link entry pointing to a single filesystem uri.      * Config prefix: fs.viewfs.mounttable.<mnt_tbl_name>.link.<link_name>      * Refer: {@link Constants#CONFIG_VIEWFS_LINK}      */
DECL|enumConstant|SINGLE
name|SINGLE
block|,
comment|/**      * Fallback filesystem for the paths not mounted by      * any single link entries.      * Config prefix: fs.viewfs.mounttable.<mnt_tbl_name>.linkFallback      * Refer: {@link Constants#CONFIG_VIEWFS_LINK_FALLBACK}      */
DECL|enumConstant|SINGLE_FALLBACK
name|SINGLE_FALLBACK
block|,
comment|/**      * Link entry pointing to an union of two or more filesystem uris.      * Config prefix: fs.viewfs.mounttable.<mnt_tbl_name>.linkMerge.<link_name>      * Refer: {@link Constants#CONFIG_VIEWFS_LINK_MERGE}      */
DECL|enumConstant|MERGE
name|MERGE
block|,
comment|/**      * Link entry for merging mount table's root with the      * root of another filesystem.      * Config prefix: fs.viewfs.mounttable.<mnt_tbl_name>.linkMergeSlash      * Refer: {@link Constants#CONFIG_VIEWFS_LINK_MERGE_SLASH}      */
DECL|enumConstant|MERGE_SLASH
name|MERGE_SLASH
block|,
comment|/**      * Link entry to write to multiple filesystems and read      * from the closest filesystem.      * Config prefix: fs.viewfs.mounttable.<mnt_tbl_name>.linkNfly      * Refer: {@link Constants#CONFIG_VIEWFS_LINK_NFLY}      */
DECL|enumConstant|NFLY
name|NFLY
block|;   }
comment|/**    * An internal class to represent a mount link.    * A mount link can be single dir link or a merge dir link.     * A merge dir link is  a merge (junction) of links to dirs:    * example : merge of 2 dirs    *     /users -> hdfs:nn1//users    *     /users -> hdfs:nn2//users    *    * For a merge, each target is checked to be dir when created but if target    * is changed later it is then ignored (a dir with null entries)    */
DECL|class|INodeLink
specifier|static
class|class
name|INodeLink
parameter_list|<
name|T
parameter_list|>
extends|extends
name|INode
argument_list|<
name|T
argument_list|>
block|{
DECL|field|targetDirLinkList
specifier|final
name|URI
index|[]
name|targetDirLinkList
decl_stmt|;
DECL|field|targetFileSystem
specifier|final
name|T
name|targetFileSystem
decl_stmt|;
comment|// file system object created from the link.
comment|/**      * Construct a mergeLink or nfly.      */
DECL|method|INodeLink (final String pathToNode, final UserGroupInformation aUgi, final T targetMergeFs, final URI[] aTargetDirLinkList)
name|INodeLink
parameter_list|(
specifier|final
name|String
name|pathToNode
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|,
specifier|final
name|T
name|targetMergeFs
parameter_list|,
specifier|final
name|URI
index|[]
name|aTargetDirLinkList
parameter_list|)
block|{
name|super
argument_list|(
name|pathToNode
argument_list|,
name|aUgi
argument_list|)
expr_stmt|;
name|targetFileSystem
operator|=
name|targetMergeFs
expr_stmt|;
name|targetDirLinkList
operator|=
name|aTargetDirLinkList
expr_stmt|;
block|}
comment|/**      * Construct a simple link (i.e. not a mergeLink).      */
DECL|method|INodeLink (final String pathToNode, final UserGroupInformation aUgi, final T targetFs, final URI aTargetDirLink)
name|INodeLink
parameter_list|(
specifier|final
name|String
name|pathToNode
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|,
specifier|final
name|T
name|targetFs
parameter_list|,
specifier|final
name|URI
name|aTargetDirLink
parameter_list|)
block|{
name|super
argument_list|(
name|pathToNode
argument_list|,
name|aUgi
argument_list|)
expr_stmt|;
name|targetFileSystem
operator|=
name|targetFs
expr_stmt|;
name|targetDirLinkList
operator|=
operator|new
name|URI
index|[
literal|1
index|]
expr_stmt|;
name|targetDirLinkList
index|[
literal|0
index|]
operator|=
name|aTargetDirLink
expr_stmt|;
block|}
comment|/**      * Get the target of the link. If a merge link then it returned      * as "," separated URI list.      */
DECL|method|getTargetLink ()
name|Path
name|getTargetLink
parameter_list|()
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
name|targetDirLinkList
index|[
literal|0
index|]
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|// If merge link, use "," as separator between the merged URIs
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|targetDirLinkList
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
name|targetDirLinkList
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Path
argument_list|(
name|result
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isInternalDir ()
name|boolean
name|isInternalDir
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|getTargetFileSystem ()
specifier|public
name|T
name|getTargetFileSystem
parameter_list|()
block|{
return|return
name|targetFileSystem
return|;
block|}
block|}
DECL|method|createLink (final String src, final String target, final LinkType linkType, final String settings, final UserGroupInformation aUgi, final Configuration config)
specifier|private
name|void
name|createLink
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|String
name|target
parameter_list|,
specifier|final
name|LinkType
name|linkType
parameter_list|,
specifier|final
name|String
name|settings
parameter_list|,
specifier|final
name|UserGroupInformation
name|aUgi
parameter_list|,
specifier|final
name|Configuration
name|config
parameter_list|)
throws|throws
name|URISyntaxException
throws|,
name|IOException
throws|,
name|FileAlreadyExistsException
throws|,
name|UnsupportedFileSystemException
block|{
comment|// Validate that src is valid absolute path
specifier|final
name|Path
name|srcPath
init|=
operator|new
name|Path
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|srcPath
operator|.
name|isAbsoluteAndSchemeAuthorityNull
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ViewFs: Non absolute mount name in config:"
operator|+
name|src
argument_list|)
throw|;
block|}
specifier|final
name|String
index|[]
name|srcPaths
init|=
name|breakIntoPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|// Make sure root is of INodeDir type before
comment|// adding any regular links to it.
name|Preconditions
operator|.
name|checkState
argument_list|(
name|root
operator|.
name|isInternalDir
argument_list|()
argument_list|)
expr_stmt|;
name|INodeDir
argument_list|<
name|T
argument_list|>
name|curInode
init|=
name|getRootDir
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|// Ignore first initial slash, process all except last component
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|srcPaths
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|iPath
init|=
name|srcPaths
index|[
name|i
index|]
decl_stmt|;
name|INode
argument_list|<
name|T
argument_list|>
name|nextInode
init|=
name|curInode
operator|.
name|resolveInternal
argument_list|(
name|iPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextInode
operator|==
literal|null
condition|)
block|{
name|INodeDir
argument_list|<
name|T
argument_list|>
name|newDir
init|=
name|curInode
operator|.
name|addDir
argument_list|(
name|iPath
argument_list|,
name|aUgi
argument_list|)
decl_stmt|;
name|newDir
operator|.
name|setInternalDirFs
argument_list|(
name|getTargetFileSystem
argument_list|(
name|newDir
argument_list|)
argument_list|)
expr_stmt|;
name|nextInode
operator|=
name|newDir
expr_stmt|;
block|}
if|if
condition|(
name|nextInode
operator|.
name|isLink
argument_list|()
condition|)
block|{
comment|// Error - expected a dir but got a link
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Path "
operator|+
name|nextInode
operator|.
name|fullPath
operator|+
literal|" already exists as link"
argument_list|)
throw|;
block|}
else|else
block|{
assert|assert
operator|(
name|nextInode
operator|.
name|isInternalDir
argument_list|()
operator|)
assert|;
name|curInode
operator|=
operator|(
name|INodeDir
argument_list|<
name|T
argument_list|>
operator|)
name|nextInode
expr_stmt|;
block|}
block|}
comment|// Now process the last component
comment|// Add the link in 2 cases: does not exist or a link exists
name|String
name|iPath
init|=
name|srcPaths
index|[
name|i
index|]
decl_stmt|;
comment|// last component
if|if
condition|(
name|curInode
operator|.
name|resolveInternal
argument_list|(
name|iPath
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|//  directory/link already exists
name|StringBuilder
name|strB
init|=
operator|new
name|StringBuilder
argument_list|(
name|srcPaths
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|i
condition|;
operator|++
name|j
control|)
block|{
name|strB
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|srcPaths
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Path "
operator|+
name|strB
operator|+
literal|" already exists as dir; cannot create link here"
argument_list|)
throw|;
block|}
specifier|final
name|INodeLink
argument_list|<
name|T
argument_list|>
name|newLink
decl_stmt|;
specifier|final
name|String
name|fullPath
init|=
name|curInode
operator|.
name|fullPath
operator|+
operator|(
name|curInode
operator|==
name|root
condition|?
literal|""
else|:
literal|"/"
operator|)
operator|+
name|iPath
decl_stmt|;
switch|switch
condition|(
name|linkType
condition|)
block|{
case|case
name|SINGLE
case|:
name|newLink
operator|=
operator|new
name|INodeLink
argument_list|<
name|T
argument_list|>
argument_list|(
name|fullPath
argument_list|,
name|aUgi
argument_list|,
name|getTargetFileSystem
argument_list|(
operator|new
name|URI
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
operator|new
name|URI
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SINGLE_FALLBACK
case|:
case|case
name|MERGE_SLASH
case|:
comment|// Link fallback and link merge slash configuration
comment|// are handled specially at InodeTree.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected linkType: "
operator|+
name|linkType
argument_list|)
throw|;
case|case
name|MERGE
case|:
case|case
name|NFLY
case|:
specifier|final
name|URI
index|[]
name|targetUris
init|=
name|StringUtils
operator|.
name|stringToURI
argument_list|(
name|StringUtils
operator|.
name|getStrings
argument_list|(
name|target
argument_list|)
argument_list|)
decl_stmt|;
name|newLink
operator|=
operator|new
name|INodeLink
argument_list|<
name|T
argument_list|>
argument_list|(
name|fullPath
argument_list|,
name|aUgi
argument_list|,
name|getTargetFileSystem
argument_list|(
name|settings
argument_list|,
name|targetUris
argument_list|)
argument_list|,
name|targetUris
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|linkType
operator|+
literal|": Infeasible linkType"
argument_list|)
throw|;
block|}
name|curInode
operator|.
name|addLink
argument_list|(
name|iPath
argument_list|,
name|newLink
argument_list|)
expr_stmt|;
name|mountPoints
operator|.
name|add
argument_list|(
operator|new
name|MountPoint
argument_list|<
name|T
argument_list|>
argument_list|(
name|src
argument_list|,
name|newLink
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * The user of this class must subclass and implement the following    * 3 abstract methods.    * @throws IOException    */
DECL|method|getTargetFileSystem (URI uri)
specifier|protected
specifier|abstract
name|T
name|getTargetFileSystem
parameter_list|(
name|URI
name|uri
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
throws|,
name|URISyntaxException
throws|,
name|IOException
function_decl|;
DECL|method|getTargetFileSystem (INodeDir<T> dir)
specifier|protected
specifier|abstract
name|T
name|getTargetFileSystem
parameter_list|(
name|INodeDir
argument_list|<
name|T
argument_list|>
name|dir
parameter_list|)
throws|throws
name|URISyntaxException
function_decl|;
DECL|method|getTargetFileSystem (String settings, URI[] mergeFsURIs)
specifier|protected
specifier|abstract
name|T
name|getTargetFileSystem
parameter_list|(
name|String
name|settings
parameter_list|,
name|URI
index|[]
name|mergeFsURIs
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
throws|,
name|URISyntaxException
throws|,
name|IOException
function_decl|;
DECL|method|getRootDir ()
specifier|private
name|INodeDir
argument_list|<
name|T
argument_list|>
name|getRootDir
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|root
operator|.
name|isInternalDir
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|INodeDir
argument_list|<
name|T
argument_list|>
operator|)
name|root
return|;
block|}
DECL|method|getRootLink ()
specifier|private
name|INodeLink
argument_list|<
name|T
argument_list|>
name|getRootLink
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|root
operator|.
name|isLink
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|INodeLink
argument_list|<
name|T
argument_list|>
operator|)
name|root
return|;
block|}
DECL|method|hasFallbackLink ()
specifier|private
name|boolean
name|hasFallbackLink
parameter_list|()
block|{
return|return
name|rootFallbackLink
operator|!=
literal|null
return|;
block|}
DECL|method|getRootFallbackLink ()
specifier|private
name|INodeLink
argument_list|<
name|T
argument_list|>
name|getRootFallbackLink
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|root
operator|.
name|isInternalDir
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rootFallbackLink
return|;
block|}
comment|/**    * An internal class representing the ViewFileSystem mount table    * link entries and their attributes.    * @see LinkType    */
DECL|class|LinkEntry
specifier|private
specifier|static
class|class
name|LinkEntry
block|{
DECL|field|src
specifier|private
specifier|final
name|String
name|src
decl_stmt|;
DECL|field|target
specifier|private
specifier|final
name|String
name|target
decl_stmt|;
DECL|field|linkType
specifier|private
specifier|final
name|LinkType
name|linkType
decl_stmt|;
DECL|field|settings
specifier|private
specifier|final
name|String
name|settings
decl_stmt|;
DECL|field|ugi
specifier|private
specifier|final
name|UserGroupInformation
name|ugi
decl_stmt|;
DECL|field|config
specifier|private
specifier|final
name|Configuration
name|config
decl_stmt|;
DECL|method|LinkEntry (String src, String target, LinkType linkType, String settings, UserGroupInformation ugi, Configuration config)
name|LinkEntry
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|target
parameter_list|,
name|LinkType
name|linkType
parameter_list|,
name|String
name|settings
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|,
name|Configuration
name|config
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|linkType
operator|=
name|linkType
expr_stmt|;
name|this
operator|.
name|settings
operator|=
name|settings
expr_stmt|;
name|this
operator|.
name|ugi
operator|=
name|ugi
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
block|}
DECL|method|getSrc ()
name|String
name|getSrc
parameter_list|()
block|{
return|return
name|src
return|;
block|}
DECL|method|getTarget ()
name|String
name|getTarget
parameter_list|()
block|{
return|return
name|target
return|;
block|}
DECL|method|getLinkType ()
name|LinkType
name|getLinkType
parameter_list|()
block|{
return|return
name|linkType
return|;
block|}
DECL|method|isLinkType (LinkType type)
name|boolean
name|isLinkType
parameter_list|(
name|LinkType
name|type
parameter_list|)
block|{
return|return
name|this
operator|.
name|linkType
operator|==
name|type
return|;
block|}
DECL|method|getSettings ()
name|String
name|getSettings
parameter_list|()
block|{
return|return
name|settings
return|;
block|}
DECL|method|getUgi ()
name|UserGroupInformation
name|getUgi
parameter_list|()
block|{
return|return
name|ugi
return|;
block|}
DECL|method|getConfig ()
name|Configuration
name|getConfig
parameter_list|()
block|{
return|return
name|config
return|;
block|}
block|}
comment|/**    * Create Inode Tree from the specified mount-table specified in Config    * @param config - the mount table keys are prefixed with     *       FsConstants.CONFIG_VIEWFS_PREFIX    * @param viewName - the name of the mount table - if null use defaultMT name    * @throws UnsupportedFileSystemException    * @throws URISyntaxException    * @throws FileAlreadyExistsException    * @throws IOException    */
DECL|method|InodeTree (final Configuration config, final String viewName)
specifier|protected
name|InodeTree
parameter_list|(
specifier|final
name|Configuration
name|config
parameter_list|,
specifier|final
name|String
name|viewName
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
throws|,
name|URISyntaxException
throws|,
name|FileAlreadyExistsException
throws|,
name|IOException
block|{
name|String
name|mountTableName
init|=
name|viewName
decl_stmt|;
if|if
condition|(
name|mountTableName
operator|==
literal|null
condition|)
block|{
name|mountTableName
operator|=
name|Constants
operator|.
name|CONFIG_VIEWFS_DEFAULT_MOUNT_TABLE
expr_stmt|;
block|}
name|homedirPrefix
operator|=
name|ConfigUtil
operator|.
name|getHomeDirValue
argument_list|(
name|config
argument_list|,
name|mountTableName
argument_list|)
expr_stmt|;
name|boolean
name|isMergeSlashConfigured
init|=
literal|false
decl_stmt|;
name|String
name|mergeSlashTarget
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|LinkEntry
argument_list|>
name|linkEntries
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|String
name|mountTablePrefix
init|=
name|Constants
operator|.
name|CONFIG_VIEWFS_PREFIX
operator|+
literal|"."
operator|+
name|mountTableName
operator|+
literal|"."
decl_stmt|;
specifier|final
name|String
name|linkPrefix
init|=
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK
operator|+
literal|"."
decl_stmt|;
specifier|final
name|String
name|linkFallbackPrefix
init|=
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK_FALLBACK
decl_stmt|;
specifier|final
name|String
name|linkMergePrefix
init|=
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK_MERGE
operator|+
literal|"."
decl_stmt|;
specifier|final
name|String
name|linkMergeSlashPrefix
init|=
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK_MERGE_SLASH
decl_stmt|;
name|boolean
name|gotMountTableEntry
init|=
literal|false
decl_stmt|;
specifier|final
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|si
range|:
name|config
control|)
block|{
specifier|final
name|String
name|key
init|=
name|si
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
name|mountTablePrefix
argument_list|)
condition|)
block|{
name|gotMountTableEntry
operator|=
literal|true
expr_stmt|;
name|LinkType
name|linkType
decl_stmt|;
name|String
name|src
init|=
name|key
operator|.
name|substring
argument_list|(
name|mountTablePrefix
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|settings
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|linkPrefix
argument_list|)
condition|)
block|{
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
name|linkPrefix
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|.
name|equals
argument_list|(
name|SlashPath
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedFileSystemException
argument_list|(
literal|"Unexpected mount table "
operator|+
literal|"link entry '"
operator|+
name|key
operator|+
literal|"'. Use "
operator|+
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK_MERGE_SLASH
operator|+
literal|" instead!"
argument_list|)
throw|;
block|}
name|linkType
operator|=
name|LinkType
operator|.
name|SINGLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|linkFallbackPrefix
argument_list|)
condition|)
block|{
if|if
condition|(
name|src
operator|.
name|length
argument_list|()
operator|!=
name|linkFallbackPrefix
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ViewFs: Mount points initialization error."
operator|+
literal|" Invalid "
operator|+
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK_FALLBACK
operator|+
literal|" entry in config: "
operator|+
name|src
argument_list|)
throw|;
block|}
name|linkType
operator|=
name|LinkType
operator|.
name|SINGLE_FALLBACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|linkMergePrefix
argument_list|)
condition|)
block|{
comment|// A merge link
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
name|linkMergePrefix
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|linkType
operator|=
name|LinkType
operator|.
name|MERGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|linkMergeSlashPrefix
argument_list|)
condition|)
block|{
comment|// This is a LinkMergeSlash entry. This entry should
comment|// not have any additional source path.
if|if
condition|(
name|src
operator|.
name|length
argument_list|()
operator|!=
name|linkMergeSlashPrefix
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ViewFs: Mount points initialization error."
operator|+
literal|" Invalid "
operator|+
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK_MERGE_SLASH
operator|+
literal|" entry in config: "
operator|+
name|src
argument_list|)
throw|;
block|}
name|linkType
operator|=
name|LinkType
operator|.
name|MERGE_SLASH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK_NFLY
argument_list|)
condition|)
block|{
comment|// prefix.settings.src
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
name|Constants
operator|.
name|CONFIG_VIEWFS_LINK_NFLY
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// settings.src
name|settings
operator|=
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
comment|// settings
comment|// settings.src
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
name|settings
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// src
name|linkType
operator|=
name|LinkType
operator|.
name|NFLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|.
name|startsWith
argument_list|(
name|Constants
operator|.
name|CONFIG_VIEWFS_HOMEDIR
argument_list|)
condition|)
block|{
comment|// ignore - we set home dir from config
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ViewFs: Cannot initialize: Invalid entry in "
operator|+
literal|"Mount table in config: "
operator|+
name|src
argument_list|)
throw|;
block|}
specifier|final
name|String
name|target
init|=
name|si
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|linkType
operator|!=
name|LinkType
operator|.
name|MERGE_SLASH
condition|)
block|{
if|if
condition|(
name|isMergeSlashConfigured
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mount table "
operator|+
name|mountTableName
operator|+
literal|" has already been configured with a merge slash link. "
operator|+
literal|"A regular link should not be added."
argument_list|)
throw|;
block|}
name|linkEntries
operator|.
name|add
argument_list|(
operator|new
name|LinkEntry
argument_list|(
name|src
argument_list|,
name|target
argument_list|,
name|linkType
argument_list|,
name|settings
argument_list|,
name|ugi
argument_list|,
name|config
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|linkEntries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mount table "
operator|+
name|mountTableName
operator|+
literal|" has already been configured with regular links. "
operator|+
literal|"A merge slash link should not be configured."
argument_list|)
throw|;
block|}
if|if
condition|(
name|isMergeSlashConfigured
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mount table "
operator|+
name|mountTableName
operator|+
literal|" has already been configured with a merge slash link. "
operator|+
literal|"Multiple merge slash links for the same mount table is "
operator|+
literal|"not allowed."
argument_list|)
throw|;
block|}
name|isMergeSlashConfigured
operator|=
literal|true
expr_stmt|;
name|mergeSlashTarget
operator|=
name|target
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|isMergeSlashConfigured
condition|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|mergeSlashTarget
argument_list|)
expr_stmt|;
name|root
operator|=
operator|new
name|INodeLink
argument_list|<
name|T
argument_list|>
argument_list|(
name|mountTableName
argument_list|,
name|ugi
argument_list|,
name|getTargetFileSystem
argument_list|(
operator|new
name|URI
argument_list|(
name|mergeSlashTarget
argument_list|)
argument_list|)
argument_list|,
operator|new
name|URI
argument_list|(
name|mergeSlashTarget
argument_list|)
argument_list|)
expr_stmt|;
name|mountPoints
operator|.
name|add
argument_list|(
operator|new
name|MountPoint
argument_list|<
name|T
argument_list|>
argument_list|(
literal|"/"
argument_list|,
operator|(
name|INodeLink
argument_list|<
name|T
argument_list|>
operator|)
name|root
argument_list|)
argument_list|)
expr_stmt|;
name|rootFallbackLink
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|root
operator|=
operator|new
name|INodeDir
argument_list|<
name|T
argument_list|>
argument_list|(
literal|"/"
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
expr_stmt|;
name|getRootDir
argument_list|()
operator|.
name|setInternalDirFs
argument_list|(
name|getTargetFileSystem
argument_list|(
name|getRootDir
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|getRootDir
argument_list|()
operator|.
name|setRoot
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|INodeLink
argument_list|<
name|T
argument_list|>
name|fallbackLink
init|=
literal|null
decl_stmt|;
for|for
control|(
name|LinkEntry
name|le
range|:
name|linkEntries
control|)
block|{
if|if
condition|(
name|le
operator|.
name|isLinkType
argument_list|(
name|LinkType
operator|.
name|SINGLE_FALLBACK
argument_list|)
condition|)
block|{
if|if
condition|(
name|fallbackLink
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mount table "
operator|+
name|mountTableName
operator|+
literal|" has already been configured with a link fallback. "
operator|+
literal|"Multiple fallback links for the same mount table is "
operator|+
literal|"not allowed."
argument_list|)
throw|;
block|}
name|fallbackLink
operator|=
operator|new
name|INodeLink
argument_list|<
name|T
argument_list|>
argument_list|(
name|mountTableName
argument_list|,
name|ugi
argument_list|,
name|getTargetFileSystem
argument_list|(
operator|new
name|URI
argument_list|(
name|le
operator|.
name|getTarget
argument_list|()
argument_list|)
argument_list|)
argument_list|,
operator|new
name|URI
argument_list|(
name|le
operator|.
name|getTarget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|createLink
argument_list|(
name|le
operator|.
name|getSrc
argument_list|()
argument_list|,
name|le
operator|.
name|getTarget
argument_list|()
argument_list|,
name|le
operator|.
name|getLinkType
argument_list|()
argument_list|,
name|le
operator|.
name|getSettings
argument_list|()
argument_list|,
name|le
operator|.
name|getUgi
argument_list|()
argument_list|,
name|le
operator|.
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|rootFallbackLink
operator|=
name|fallbackLink
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gotMountTableEntry
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ViewFs: Cannot initialize: Empty Mount table in config for "
operator|+
literal|"viewfs://"
operator|+
name|mountTableName
operator|+
literal|"/"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Resolve returns ResolveResult.    * The caller can continue the resolution of the remainingPath    * in the targetFileSystem.    *    * If the input pathname leads to link to another file system then    * the targetFileSystem is the one denoted by the link (except it is    * file system chrooted to link target.    * If the input pathname leads to an internal mount-table entry then    * the target file system is one that represents the internal inode.    */
DECL|class|ResolveResult
specifier|static
class|class
name|ResolveResult
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|kind
specifier|final
name|ResultKind
name|kind
decl_stmt|;
DECL|field|targetFileSystem
specifier|final
name|T
name|targetFileSystem
decl_stmt|;
DECL|field|resolvedPath
specifier|final
name|String
name|resolvedPath
decl_stmt|;
DECL|field|remainingPath
specifier|final
name|Path
name|remainingPath
decl_stmt|;
comment|// to resolve in the target FileSystem
DECL|method|ResolveResult (final ResultKind k, final T targetFs, final String resolveP, final Path remainingP)
name|ResolveResult
parameter_list|(
specifier|final
name|ResultKind
name|k
parameter_list|,
specifier|final
name|T
name|targetFs
parameter_list|,
specifier|final
name|String
name|resolveP
parameter_list|,
specifier|final
name|Path
name|remainingP
parameter_list|)
block|{
name|kind
operator|=
name|k
expr_stmt|;
name|targetFileSystem
operator|=
name|targetFs
expr_stmt|;
name|resolvedPath
operator|=
name|resolveP
expr_stmt|;
name|remainingPath
operator|=
name|remainingP
expr_stmt|;
block|}
comment|// Internal dir path resolution completed within the mount table
DECL|method|isInternalDir ()
name|boolean
name|isInternalDir
parameter_list|()
block|{
return|return
operator|(
name|kind
operator|==
name|ResultKind
operator|.
name|INTERNAL_DIR
operator|)
return|;
block|}
block|}
comment|/**    * Resolve the pathname p relative to root InodeDir    * @param p - input path    * @param resolveLastComponent    * @return ResolveResult which allows further resolution of the remaining path    * @throws FileNotFoundException    */
DECL|method|resolve (final String p, final boolean resolveLastComponent)
name|ResolveResult
argument_list|<
name|T
argument_list|>
name|resolve
parameter_list|(
specifier|final
name|String
name|p
parameter_list|,
specifier|final
name|boolean
name|resolveLastComponent
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|String
index|[]
name|path
init|=
name|breakIntoPathComponents
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|length
operator|<=
literal|1
condition|)
block|{
comment|// special case for when path is "/"
name|T
name|targetFs
init|=
name|root
operator|.
name|isInternalDir
argument_list|()
condition|?
name|getRootDir
argument_list|()
operator|.
name|getInternalDirFs
argument_list|()
else|:
name|getRootLink
argument_list|()
operator|.
name|getTargetFileSystem
argument_list|()
decl_stmt|;
name|ResolveResult
argument_list|<
name|T
argument_list|>
name|res
init|=
operator|new
name|ResolveResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|ResultKind
operator|.
name|INTERNAL_DIR
argument_list|,
name|targetFs
argument_list|,
name|root
operator|.
name|fullPath
argument_list|,
name|SlashPath
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
comment|/**      * linkMergeSlash has been configured. The root of this mount table has      * been linked to the root directory of a file system.      * The first non-slash path component should be name of the mount table.      */
if|if
condition|(
name|root
operator|.
name|isLink
argument_list|()
condition|)
block|{
name|Path
name|remainingPath
decl_stmt|;
name|StringBuilder
name|remainingPathStr
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// ignore first slash
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|path
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|remainingPathStr
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|remainingPath
operator|=
operator|new
name|Path
argument_list|(
name|remainingPathStr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|ResolveResult
argument_list|<
name|T
argument_list|>
name|res
init|=
operator|new
name|ResolveResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|ResultKind
operator|.
name|EXTERNAL_DIR
argument_list|,
name|getRootLink
argument_list|()
operator|.
name|getTargetFileSystem
argument_list|()
argument_list|,
name|root
operator|.
name|fullPath
argument_list|,
name|remainingPath
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
name|root
operator|.
name|isInternalDir
argument_list|()
argument_list|)
expr_stmt|;
name|INodeDir
argument_list|<
name|T
argument_list|>
name|curInode
init|=
name|getRootDir
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|// ignore first slash
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|path
operator|.
name|length
operator|-
operator|(
name|resolveLastComponent
condition|?
literal|0
else|:
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|INode
argument_list|<
name|T
argument_list|>
name|nextInode
init|=
name|curInode
operator|.
name|resolveInternal
argument_list|(
name|path
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextInode
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|hasFallbackLink
argument_list|()
condition|)
block|{
return|return
operator|new
name|ResolveResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|ResultKind
operator|.
name|EXTERNAL_DIR
argument_list|,
name|getRootFallbackLink
argument_list|()
operator|.
name|getTargetFileSystem
argument_list|()
argument_list|,
name|root
operator|.
name|fullPath
argument_list|,
operator|new
name|Path
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|StringBuilder
name|failedAt
init|=
operator|new
name|StringBuilder
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|i
condition|;
operator|++
name|j
control|)
block|{
name|failedAt
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|path
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|(
operator|new
name|FileNotFoundException
argument_list|(
literal|"File/Directory does not exist: "
operator|+
name|failedAt
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
throw|;
block|}
block|}
if|if
condition|(
name|nextInode
operator|.
name|isLink
argument_list|()
condition|)
block|{
specifier|final
name|INodeLink
argument_list|<
name|T
argument_list|>
name|link
init|=
operator|(
name|INodeLink
argument_list|<
name|T
argument_list|>
operator|)
name|nextInode
decl_stmt|;
specifier|final
name|Path
name|remainingPath
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|path
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|remainingPath
operator|=
name|SlashPath
expr_stmt|;
block|}
else|else
block|{
name|StringBuilder
name|remainingPathStr
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"/"
operator|+
name|path
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|2
init|;
name|j
operator|<
name|path
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|remainingPathStr
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|path
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|remainingPath
operator|=
operator|new
name|Path
argument_list|(
name|remainingPathStr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ResolveResult
argument_list|<
name|T
argument_list|>
name|res
init|=
operator|new
name|ResolveResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|ResultKind
operator|.
name|EXTERNAL_DIR
argument_list|,
name|link
operator|.
name|getTargetFileSystem
argument_list|()
argument_list|,
name|nextInode
operator|.
name|fullPath
argument_list|,
name|remainingPath
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
elseif|else
if|if
condition|(
name|nextInode
operator|.
name|isInternalDir
argument_list|()
condition|)
block|{
name|curInode
operator|=
operator|(
name|INodeDir
argument_list|<
name|T
argument_list|>
operator|)
name|nextInode
expr_stmt|;
block|}
block|}
comment|// We have resolved to an internal dir in mount table.
name|Path
name|remainingPath
decl_stmt|;
if|if
condition|(
name|resolveLastComponent
condition|)
block|{
name|remainingPath
operator|=
name|SlashPath
expr_stmt|;
block|}
else|else
block|{
comment|// note we have taken care of when path is "/" above
comment|// for internal dirs rem-path does not start with / since the lookup
comment|// that follows will do a children.get(remaningPath) and will have to
comment|// strip-out the initial /
name|StringBuilder
name|remainingPathStr
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"/"
operator|+
name|path
index|[
name|i
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|path
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
name|remainingPathStr
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
operator|.
name|append
argument_list|(
name|path
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|remainingPath
operator|=
operator|new
name|Path
argument_list|(
name|remainingPathStr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ResolveResult
argument_list|<
name|T
argument_list|>
name|res
init|=
operator|new
name|ResolveResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|ResultKind
operator|.
name|INTERNAL_DIR
argument_list|,
name|curInode
operator|.
name|getInternalDirFs
argument_list|()
argument_list|,
name|curInode
operator|.
name|fullPath
argument_list|,
name|remainingPath
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
DECL|method|getMountPoints ()
name|List
argument_list|<
name|MountPoint
argument_list|<
name|T
argument_list|>
argument_list|>
name|getMountPoints
parameter_list|()
block|{
return|return
name|mountPoints
return|;
block|}
comment|/**    *    * @return home dir value from mount table; null if no config value    * was found.    */
DECL|method|getHomeDirPrefixValue ()
name|String
name|getHomeDirPrefixValue
parameter_list|()
block|{
return|return
name|homedirPrefix
return|;
block|}
block|}
end_class

end_unit

