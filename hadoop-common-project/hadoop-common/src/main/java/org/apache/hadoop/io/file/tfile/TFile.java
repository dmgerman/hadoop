begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io.file.tfile
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|file
operator|.
name|tfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BoundedByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataInputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataOutputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|RawComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|file
operator|.
name|tfile
operator|.
name|BCFile
operator|.
name|Reader
operator|.
name|BlockReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|file
operator|.
name|tfile
operator|.
name|BCFile
operator|.
name|Writer
operator|.
name|BlockAppender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|file
operator|.
name|tfile
operator|.
name|Chunk
operator|.
name|ChunkDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|file
operator|.
name|tfile
operator|.
name|Chunk
operator|.
name|ChunkEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|file
operator|.
name|tfile
operator|.
name|CompareUtils
operator|.
name|BytesComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|file
operator|.
name|tfile
operator|.
name|CompareUtils
operator|.
name|MemcmpRawComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|file
operator|.
name|tfile
operator|.
name|Utils
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|JavaSerializationComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A TFile is a container of key-value pairs. Both keys and values are type-less  * bytes. Keys are restricted to 64KB, value length is not restricted  * (practically limited to the available disk storage). TFile further provides  * the following features:  *<ul>  *<li>Block Compression.  *<li>Named meta data blocks.  *<li>Sorted or unsorted keys.  *<li>Seek by key or by file offset.  *</ul>  * The memory footprint of a TFile includes the following:  *<ul>  *<li>Some constant overhead of reading or writing a compressed block.  *<ul>  *<li>Each compressed block requires one compression/decompression codec for  * I/O.  *<li>Temporary space to buffer the key.  *<li>Temporary space to buffer the value (for TFile.Writer only). Values are  * chunk encoded, so that we buffer at most one chunk of user data. By default,  * the chunk buffer is 1MB. Reading chunked value does not require additional  * memory.  *</ul>  *<li>TFile index, which is proportional to the total number of Data Blocks.  * The total amount of memory needed to hold the index can be estimated as  * (56+AvgKeySize)*NumBlocks.  *<li>MetaBlock index, which is proportional to the total number of Meta  * Blocks.The total amount of memory needed to hold the index for Meta Blocks  * can be estimated as (40+AvgMetaBlockName)*NumMetaBlock.  *</ul>  *<p>  * The behavior of TFile can be customized by the following variables through  * Configuration:  *<ul>  *<li><b>tfile.io.chunk.size</b>: Value chunk size. Integer (in bytes). Default  * to 1MB. Values of the length less than the chunk size is guaranteed to have  * known value length in read time (See  * {@link TFile.Reader.Scanner.Entry#isValueLengthKnown()}).  *<li><b>tfile.fs.output.buffer.size</b>: Buffer size used for  * FSDataOutputStream. Integer (in bytes). Default to 256KB.  *<li><b>tfile.fs.input.buffer.size</b>: Buffer size used for  * FSDataInputStream. Integer (in bytes). Default to 256KB.  *</ul>  *<p>  * Suggestions on performance optimization.  *<ul>  *<li>Minimum block size. We recommend a setting of minimum block size between  * 256KB to 1MB for general usage. Larger block size is preferred if files are  * primarily for sequential access. However, it would lead to inefficient random  * access (because there are more data to decompress). Smaller blocks are good  * for random access, but require more memory to hold the block index, and may  * be slower to create (because we must flush the compressor stream at the  * conclusion of each data block, which leads to an FS I/O flush). Further, due  * to the internal caching in Compression codec, the smallest possible block  * size would be around 20KB-30KB.  *<li>The current implementation does not offer true multi-threading for  * reading. The implementation uses FSDataInputStream seek()+read(), which is  * shown to be much faster than positioned-read call in single thread mode.  * However, it also means that if multiple threads attempt to access the same  * TFile (using multiple scanners) simultaneously, the actual I/O is carried out  * sequentially even if they access different DFS blocks.  *<li>Compression codec. Use "none" if the data is not very compressable (by  * compressable, I mean a compression ratio at least 2:1). Generally, use "lzo"  * as the starting point for experimenting. "gz" overs slightly better  * compression ratio over "lzo" but requires 4x CPU to compress and 2x CPU to  * decompress, comparing to "lzo".  *<li>File system buffering, if the underlying FSDataInputStream and  * FSDataOutputStream is already adequately buffered; or if applications  * reads/writes keys and values in large buffers, we can reduce the sizes of  * input/output buffering in TFile layer by setting the configuration parameters  * "tfile.fs.input.buffer.size" and "tfile.fs.output.buffer.size".  *</ul>  *   * Some design rationale behind TFile can be found at<a  * href=https://issues.apache.org/jira/browse/HADOOP-3315>Hadoop-3315</a>.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|TFile
specifier|public
class|class
name|TFile
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TFile
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CHUNK_BUF_SIZE_ATTR
specifier|private
specifier|static
specifier|final
name|String
name|CHUNK_BUF_SIZE_ATTR
init|=
literal|"tfile.io.chunk.size"
decl_stmt|;
DECL|field|FS_INPUT_BUF_SIZE_ATTR
specifier|private
specifier|static
specifier|final
name|String
name|FS_INPUT_BUF_SIZE_ATTR
init|=
literal|"tfile.fs.input.buffer.size"
decl_stmt|;
DECL|field|FS_OUTPUT_BUF_SIZE_ATTR
specifier|private
specifier|static
specifier|final
name|String
name|FS_OUTPUT_BUF_SIZE_ATTR
init|=
literal|"tfile.fs.output.buffer.size"
decl_stmt|;
DECL|method|getChunkBufferSize (Configuration conf)
specifier|static
name|int
name|getChunkBufferSize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|ret
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|CHUNK_BUF_SIZE_ATTR
argument_list|,
literal|1024
operator|*
literal|1024
argument_list|)
decl_stmt|;
return|return
operator|(
name|ret
operator|>
literal|0
operator|)
condition|?
name|ret
else|:
literal|1024
operator|*
literal|1024
return|;
block|}
DECL|method|getFSInputBufferSize (Configuration conf)
specifier|static
name|int
name|getFSInputBufferSize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|FS_INPUT_BUF_SIZE_ATTR
argument_list|,
literal|256
operator|*
literal|1024
argument_list|)
return|;
block|}
DECL|method|getFSOutputBufferSize (Configuration conf)
specifier|static
name|int
name|getFSOutputBufferSize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|FS_OUTPUT_BUF_SIZE_ATTR
argument_list|,
literal|256
operator|*
literal|1024
argument_list|)
return|;
block|}
DECL|field|MAX_KEY_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|MAX_KEY_SIZE
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
comment|// 64KB
DECL|field|API_VERSION
specifier|static
specifier|final
name|Version
name|API_VERSION
init|=
operator|new
name|Version
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
decl_stmt|;
comment|/** compression: gzip */
DECL|field|COMPRESSION_GZ
specifier|public
specifier|static
specifier|final
name|String
name|COMPRESSION_GZ
init|=
literal|"gz"
decl_stmt|;
comment|/** compression: lzo */
DECL|field|COMPRESSION_LZO
specifier|public
specifier|static
specifier|final
name|String
name|COMPRESSION_LZO
init|=
literal|"lzo"
decl_stmt|;
comment|/** compression: none */
DECL|field|COMPRESSION_NONE
specifier|public
specifier|static
specifier|final
name|String
name|COMPRESSION_NONE
init|=
literal|"none"
decl_stmt|;
comment|/** comparator: memcmp */
DECL|field|COMPARATOR_MEMCMP
specifier|public
specifier|static
specifier|final
name|String
name|COMPARATOR_MEMCMP
init|=
literal|"memcmp"
decl_stmt|;
comment|/** comparator prefix: java class */
DECL|field|COMPARATOR_JCLASS
specifier|public
specifier|static
specifier|final
name|String
name|COMPARATOR_JCLASS
init|=
literal|"jclass:"
decl_stmt|;
comment|/**    * Make a raw comparator from a string name.    *     * @param name    *          Comparator name    * @return A RawComparable comparator.    */
DECL|method|makeComparator (String name)
specifier|static
specifier|public
name|Comparator
argument_list|<
name|RawComparable
argument_list|>
name|makeComparator
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|TFileMeta
operator|.
name|makeComparator
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|// Prevent the instantiation of TFiles
DECL|method|TFile ()
specifier|private
name|TFile
parameter_list|()
block|{
comment|// nothing
block|}
comment|/**    * Get names of supported compression algorithms. The names are acceptable by    * TFile.Writer.    *     * @return Array of strings, each represents a supported compression    *         algorithm. Currently, the following compression algorithms are    *         supported.    *<ul>    *<li>"none" - No compression.    *<li>"lzo" - LZO compression.    *<li>"gz" - GZIP compression.    *</ul>    */
DECL|method|getSupportedCompressionAlgorithms ()
specifier|public
specifier|static
name|String
index|[]
name|getSupportedCompressionAlgorithms
parameter_list|()
block|{
return|return
name|Compression
operator|.
name|getSupportedAlgorithms
argument_list|()
return|;
block|}
comment|/**    * TFile Writer.    */
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|Writer
specifier|public
specifier|static
class|class
name|Writer
implements|implements
name|Closeable
block|{
comment|// minimum compressed size for a block.
DECL|field|sizeMinBlock
specifier|private
specifier|final
name|int
name|sizeMinBlock
decl_stmt|;
comment|// Meta blocks.
DECL|field|tfileIndex
specifier|final
name|TFileIndex
name|tfileIndex
decl_stmt|;
DECL|field|tfileMeta
specifier|final
name|TFileMeta
name|tfileMeta
decl_stmt|;
comment|// reference to the underlying BCFile.
DECL|field|writerBCF
specifier|private
name|BCFile
operator|.
name|Writer
name|writerBCF
decl_stmt|;
comment|// current data block appender.
DECL|field|blkAppender
name|BlockAppender
name|blkAppender
decl_stmt|;
DECL|field|blkRecordCount
name|long
name|blkRecordCount
decl_stmt|;
comment|// buffers for caching the key.
DECL|field|currentKeyBufferOS
name|BoundedByteArrayOutputStream
name|currentKeyBufferOS
decl_stmt|;
DECL|field|lastKeyBufferOS
name|BoundedByteArrayOutputStream
name|lastKeyBufferOS
decl_stmt|;
comment|// buffer used by chunk codec
DECL|field|valueBuffer
specifier|private
name|byte
index|[]
name|valueBuffer
decl_stmt|;
comment|/**      * Writer states. The state always transits in circles: READY -> IN_KEY ->      * END_KEY -> IN_VALUE -> READY.      */
DECL|enum|State
specifier|private
enum|enum
name|State
block|{
DECL|enumConstant|READY
name|READY
block|,
comment|// Ready to start a new key-value pair insertion.
DECL|enumConstant|IN_KEY
name|IN_KEY
block|,
comment|// In the middle of key insertion.
DECL|enumConstant|END_KEY
name|END_KEY
block|,
comment|// Key insertion complete, ready to insert value.
DECL|enumConstant|IN_VALUE
name|IN_VALUE
block|,
comment|// In value insertion.
comment|// ERROR, // Error encountered, cannot continue.
DECL|enumConstant|CLOSED
name|CLOSED
block|,
comment|// TFile already closed.
block|}
empty_stmt|;
comment|// current state of Writer.
DECL|field|state
name|State
name|state
init|=
name|State
operator|.
name|READY
decl_stmt|;
DECL|field|conf
name|Configuration
name|conf
decl_stmt|;
DECL|field|errorCount
name|long
name|errorCount
init|=
literal|0
decl_stmt|;
comment|/**      * Constructor      *       * @param fsdos      *          output stream for writing. Must be at position 0.      * @param minBlockSize      *          Minimum compressed block size in bytes. A compression block will      *          not be closed until it reaches this size except for the last      *          block.      * @param compressName      *          Name of the compression algorithm. Must be one of the strings      *          returned by {@link TFile#getSupportedCompressionAlgorithms()}.      * @param comparator      *          Leave comparator as null or empty string if TFile is not sorted.      *          Otherwise, provide the string name for the comparison algorithm      *          for keys. Two kinds of comparators are supported.      *<ul>      *<li>Algorithmic comparator: binary comparators that is language      *          independent. Currently, only "memcmp" is supported.      *<li>Language-specific comparator: binary comparators that can      *          only be constructed in specific language. For Java, the syntax      *          is "jclass:", followed by the class name of the RawComparator.      *          Currently, we only support RawComparators that can be      *          constructed through the default constructor (with no      *          parameters). Parameterized RawComparators such as      *          {@link WritableComparator} or      *          {@link JavaSerializationComparator} may not be directly used.      *          One should write a wrapper class that inherits from such classes      *          and use its default constructor to perform proper      *          initialization.      *</ul>      * @param conf      *          The configuration object.      * @throws IOException      */
DECL|method|Writer (FSDataOutputStream fsdos, int minBlockSize, String compressName, String comparator, Configuration conf)
specifier|public
name|Writer
parameter_list|(
name|FSDataOutputStream
name|fsdos
parameter_list|,
name|int
name|minBlockSize
parameter_list|,
name|String
name|compressName
parameter_list|,
name|String
name|comparator
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|sizeMinBlock
operator|=
name|minBlockSize
expr_stmt|;
name|tfileMeta
operator|=
operator|new
name|TFileMeta
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|tfileIndex
operator|=
operator|new
name|TFileIndex
argument_list|(
name|tfileMeta
operator|.
name|getComparator
argument_list|()
argument_list|)
expr_stmt|;
name|writerBCF
operator|=
operator|new
name|BCFile
operator|.
name|Writer
argument_list|(
name|fsdos
argument_list|,
name|compressName
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|currentKeyBufferOS
operator|=
operator|new
name|BoundedByteArrayOutputStream
argument_list|(
name|MAX_KEY_SIZE
argument_list|)
expr_stmt|;
name|lastKeyBufferOS
operator|=
operator|new
name|BoundedByteArrayOutputStream
argument_list|(
name|MAX_KEY_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|/**      * Close the Writer. Resources will be released regardless of the exceptions      * being thrown. Future close calls will have no effect.      *       * The underlying FSDataOutputStream is not closed.      */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|state
operator|==
name|State
operator|.
name|CLOSED
operator|)
condition|)
block|{
return|return;
block|}
try|try
block|{
comment|// First try the normal finish.
comment|// Terminate upon the first Exception.
if|if
condition|(
name|errorCount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|READY
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot close TFile in the middle of key-value insertion."
argument_list|)
throw|;
block|}
name|finishDataBlock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// first, write out data:TFile.meta
name|BlockAppender
name|outMeta
init|=
name|writerBCF
operator|.
name|prepareMetaBlock
argument_list|(
name|TFileMeta
operator|.
name|BLOCK_NAME
argument_list|,
name|COMPRESSION_NONE
argument_list|)
decl_stmt|;
try|try
block|{
name|tfileMeta
operator|.
name|write
argument_list|(
name|outMeta
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|outMeta
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// second, write out data:TFile.index
name|BlockAppender
name|outIndex
init|=
name|writerBCF
operator|.
name|prepareMetaBlock
argument_list|(
name|TFileIndex
operator|.
name|BLOCK_NAME
argument_list|)
decl_stmt|;
try|try
block|{
name|tfileIndex
operator|.
name|write
argument_list|(
name|outIndex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|outIndex
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|writerBCF
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|blkAppender
argument_list|,
name|writerBCF
argument_list|)
expr_stmt|;
name|blkAppender
operator|=
literal|null
expr_stmt|;
name|writerBCF
operator|=
literal|null
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|CLOSED
expr_stmt|;
block|}
block|}
comment|/**      * Adding a new key-value pair to the TFile. This is synonymous to      * append(key, 0, key.length, value, 0, value.length)      *       * @param key      *          Buffer for key.      * @param value      *          Buffer for value.      * @throws IOException      */
DECL|method|append (byte[] key, byte[] value)
specifier|public
name|void
name|append
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|append
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adding a new key-value pair to TFile.      *       * @param key      *          buffer for key.      * @param koff      *          offset in key buffer.      * @param klen      *          length of key.      * @param value      *          buffer for value.      * @param voff      *          offset in value buffer.      * @param vlen      *          length of value.      * @throws IOException      *           Upon IO errors.      *<p>      *           If an exception is thrown, the TFile will be in an inconsistent      *           state. The only legitimate call after that would be close      */
DECL|method|append (byte[] key, int koff, int klen, byte[] value, int voff, int vlen)
specifier|public
name|void
name|append
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|koff
parameter_list|,
name|int
name|klen
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|int
name|voff
parameter_list|,
name|int
name|vlen
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|koff
operator||
name|klen
operator||
operator|(
name|koff
operator|+
name|klen
operator|)
operator||
operator|(
name|key
operator|.
name|length
operator|-
operator|(
name|koff
operator|+
name|klen
operator|)
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Bad key buffer offset-length combination."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|voff
operator||
name|vlen
operator||
operator|(
name|voff
operator|+
name|vlen
operator|)
operator||
operator|(
name|value
operator|.
name|length
operator|-
operator|(
name|voff
operator|+
name|vlen
operator|)
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Bad value buffer offset-length combination."
argument_list|)
throw|;
block|}
try|try
block|{
name|DataOutputStream
name|dosKey
init|=
name|prepareAppendKey
argument_list|(
name|klen
argument_list|)
decl_stmt|;
try|try
block|{
operator|++
name|errorCount
expr_stmt|;
name|dosKey
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|koff
argument_list|,
name|klen
argument_list|)
expr_stmt|;
operator|--
name|errorCount
expr_stmt|;
block|}
finally|finally
block|{
name|dosKey
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|DataOutputStream
name|dosValue
init|=
name|prepareAppendValue
argument_list|(
name|vlen
argument_list|)
decl_stmt|;
try|try
block|{
operator|++
name|errorCount
expr_stmt|;
name|dosValue
operator|.
name|write
argument_list|(
name|value
argument_list|,
name|voff
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
operator|--
name|errorCount
expr_stmt|;
block|}
finally|finally
block|{
name|dosValue
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|state
operator|=
name|State
operator|.
name|READY
expr_stmt|;
block|}
block|}
comment|/**      * Helper class to register key after close call on key append stream.      */
DECL|class|KeyRegister
specifier|private
class|class
name|KeyRegister
extends|extends
name|DataOutputStream
block|{
DECL|field|expectedLength
specifier|private
specifier|final
name|int
name|expectedLength
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
DECL|method|KeyRegister (int len)
specifier|public
name|KeyRegister
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|super
argument_list|(
name|currentKeyBufferOS
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
block|{
name|currentKeyBufferOS
operator|.
name|reset
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentKeyBufferOS
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
name|expectedLength
operator|=
name|len
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
operator|==
literal|true
condition|)
block|{
return|return;
block|}
try|try
block|{
operator|++
name|errorCount
expr_stmt|;
name|byte
index|[]
name|key
init|=
name|currentKeyBufferOS
operator|.
name|getBuffer
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|currentKeyBufferOS
operator|.
name|size
argument_list|()
decl_stmt|;
comment|/**            * verify length.            */
if|if
condition|(
name|expectedLength
operator|>=
literal|0
operator|&&
name|expectedLength
operator|!=
name|len
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incorrect key length: expected="
operator|+
name|expectedLength
operator|+
literal|" actual="
operator|+
name|len
argument_list|)
throw|;
block|}
name|Utils
operator|.
name|writeVInt
argument_list|(
name|blkAppender
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|blkAppender
operator|.
name|write
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfileIndex
operator|.
name|getFirstKey
argument_list|()
operator|==
literal|null
condition|)
block|{
name|tfileIndex
operator|.
name|setFirstKey
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tfileMeta
operator|.
name|isSorted
argument_list|()
operator|&&
name|tfileMeta
operator|.
name|getRecordCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|lastKey
init|=
name|lastKeyBufferOS
operator|.
name|getBuffer
argument_list|()
decl_stmt|;
name|int
name|lastLen
init|=
name|lastKeyBufferOS
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|tfileMeta
operator|.
name|getComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|lastKey
argument_list|,
literal|0
argument_list|,
name|lastLen
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Keys are not added in sorted order"
argument_list|)
throw|;
block|}
block|}
name|BoundedByteArrayOutputStream
name|tmp
init|=
name|currentKeyBufferOS
decl_stmt|;
name|currentKeyBufferOS
operator|=
name|lastKeyBufferOS
expr_stmt|;
name|lastKeyBufferOS
operator|=
name|tmp
expr_stmt|;
operator|--
name|errorCount
expr_stmt|;
block|}
finally|finally
block|{
name|closed
operator|=
literal|true
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|END_KEY
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Helper class to register value after close call on value append stream.      */
DECL|class|ValueRegister
specifier|private
class|class
name|ValueRegister
extends|extends
name|DataOutputStream
block|{
DECL|field|closed
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
DECL|method|ValueRegister (OutputStream os)
specifier|public
name|ValueRegister
parameter_list|(
name|OutputStream
name|os
parameter_list|)
block|{
name|super
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
comment|// Avoiding flushing call to down stream.
annotation|@
name|Override
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
block|{
comment|// do nothing
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
operator|==
literal|true
condition|)
block|{
return|return;
block|}
try|try
block|{
operator|++
name|errorCount
expr_stmt|;
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
name|blkRecordCount
operator|++
expr_stmt|;
comment|// bump up the total record count in the whole file
name|tfileMeta
operator|.
name|incRecordCount
argument_list|()
expr_stmt|;
name|finishDataBlock
argument_list|(
literal|false
argument_list|)
expr_stmt|;
operator|--
name|errorCount
expr_stmt|;
block|}
finally|finally
block|{
name|closed
operator|=
literal|true
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|READY
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Obtain an output stream for writing a key into TFile. This may only be      * called when there is no active Key appending stream or value appending      * stream.      *       * @param length      *          The expected length of the key. If length of the key is not      *          known, set length = -1. Otherwise, the application must write      *          exactly as many bytes as specified here before calling close on      *          the returned output stream.      * @return The key appending output stream.      * @throws IOException      *       */
DECL|method|prepareAppendKey (int length)
specifier|public
name|DataOutputStream
name|prepareAppendKey
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|READY
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Incorrect state to start a new key: "
operator|+
name|state
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
name|initDataBlock
argument_list|()
expr_stmt|;
name|DataOutputStream
name|ret
init|=
operator|new
name|KeyRegister
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|state
operator|=
name|State
operator|.
name|IN_KEY
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**      * Obtain an output stream for writing a value into TFile. This may only be      * called right after a key appending operation (the key append stream must      * be closed).      *       * @param length      *          The expected length of the value. If length of the value is not      *          known, set length = -1. Otherwise, the application must write      *          exactly as many bytes as specified here before calling close on      *          the returned output stream. Advertising the value size up-front      *          guarantees that the value is encoded in one chunk, and avoids      *          intermediate chunk buffering.      * @throws IOException      *       */
DECL|method|prepareAppendValue (int length)
specifier|public
name|DataOutputStream
name|prepareAppendValue
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|END_KEY
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Incorrect state to start a new value: "
operator|+
name|state
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
name|DataOutputStream
name|ret
decl_stmt|;
comment|// unknown length
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|valueBuffer
operator|==
literal|null
condition|)
block|{
name|valueBuffer
operator|=
operator|new
name|byte
index|[
name|getChunkBufferSize
argument_list|(
name|conf
argument_list|)
index|]
expr_stmt|;
block|}
name|ret
operator|=
operator|new
name|ValueRegister
argument_list|(
operator|new
name|ChunkEncoder
argument_list|(
name|blkAppender
argument_list|,
name|valueBuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|new
name|ValueRegister
argument_list|(
operator|new
name|Chunk
operator|.
name|SingleChunkEncoder
argument_list|(
name|blkAppender
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|State
operator|.
name|IN_VALUE
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**      * Obtain an output stream for creating a meta block. This function may not      * be called when there is a key append stream or value append stream      * active. No more key-value insertion is allowed after a meta data block      * has been added to TFile.      *       * @param name      *          Name of the meta block.      * @param compressName      *          Name of the compression algorithm to be used. Must be one of the      *          strings returned by      *          {@link TFile#getSupportedCompressionAlgorithms()}.      * @return A DataOutputStream that can be used to write Meta Block data.      *         Closing the stream would signal the ending of the block.      * @throws IOException      * @throws MetaBlockAlreadyExists      *           the Meta Block with the same name already exists.      */
DECL|method|prepareMetaBlock (String name, String compressName)
specifier|public
name|DataOutputStream
name|prepareMetaBlock
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|compressName
parameter_list|)
throws|throws
name|IOException
throws|,
name|MetaBlockAlreadyExists
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|READY
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Incorrect state to start a Meta Block: "
operator|+
name|state
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
name|finishDataBlock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|DataOutputStream
name|outputStream
init|=
name|writerBCF
operator|.
name|prepareMetaBlock
argument_list|(
name|name
argument_list|,
name|compressName
argument_list|)
decl_stmt|;
return|return
name|outputStream
return|;
block|}
comment|/**      * Obtain an output stream for creating a meta block. This function may not      * be called when there is a key append stream or value append stream      * active. No more key-value insertion is allowed after a meta data block      * has been added to TFile. Data will be compressed using the default      * compressor as defined in Writer's constructor.      *       * @param name      *          Name of the meta block.      * @return A DataOutputStream that can be used to write Meta Block data.      *         Closing the stream would signal the ending of the block.      * @throws IOException      * @throws MetaBlockAlreadyExists      *           the Meta Block with the same name already exists.      */
DECL|method|prepareMetaBlock (String name)
specifier|public
name|DataOutputStream
name|prepareMetaBlock
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
throws|,
name|MetaBlockAlreadyExists
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|READY
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Incorrect state to start a Meta Block: "
operator|+
name|state
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
name|finishDataBlock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|writerBCF
operator|.
name|prepareMetaBlock
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * Check if we need to start a new data block.      *       * @throws IOException      */
DECL|method|initDataBlock ()
specifier|private
name|void
name|initDataBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// for each new block, get a new appender
if|if
condition|(
name|blkAppender
operator|==
literal|null
condition|)
block|{
name|blkAppender
operator|=
name|writerBCF
operator|.
name|prepareDataBlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Close the current data block if necessary.      *       * @param bForceFinish      *          Force the closure regardless of the block size.      * @throws IOException      */
DECL|method|finishDataBlock (boolean bForceFinish)
name|void
name|finishDataBlock
parameter_list|(
name|boolean
name|bForceFinish
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blkAppender
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// exceeded the size limit, do the compression and finish the block
if|if
condition|(
name|bForceFinish
operator|||
name|blkAppender
operator|.
name|getCompressedSize
argument_list|()
operator|>=
name|sizeMinBlock
condition|)
block|{
comment|// keep tracks of the last key of each data block, no padding
comment|// for now
name|TFileIndexEntry
name|keyLast
init|=
operator|new
name|TFileIndexEntry
argument_list|(
name|lastKeyBufferOS
operator|.
name|getBuffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|lastKeyBufferOS
operator|.
name|size
argument_list|()
argument_list|,
name|blkRecordCount
argument_list|)
decl_stmt|;
name|tfileIndex
operator|.
name|addEntry
argument_list|(
name|keyLast
argument_list|)
expr_stmt|;
comment|// close the appender
name|blkAppender
operator|.
name|close
argument_list|()
expr_stmt|;
name|blkAppender
operator|=
literal|null
expr_stmt|;
name|blkRecordCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/**    * TFile Reader. Users may only read TFiles by creating TFile.Reader.Scanner.    * objects. A scanner may scan the whole TFile ({@link Reader#createScanner()}    * ) , a portion of TFile based on byte offsets (    * {@link Reader#createScannerByByteRange(long, long)}), or a portion of TFile with keys    * fall in a certain key range (for sorted TFile only,    * {@link Reader#createScannerByKey(byte[], byte[])} or    * {@link Reader#createScannerByKey(RawComparable, RawComparable)}).    */
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|Reader
specifier|public
specifier|static
class|class
name|Reader
implements|implements
name|Closeable
block|{
comment|// The underlying BCFile reader.
DECL|field|readerBCF
specifier|final
name|BCFile
operator|.
name|Reader
name|readerBCF
decl_stmt|;
comment|// TFile index, it is loaded lazily.
DECL|field|tfileIndex
name|TFileIndex
name|tfileIndex
init|=
literal|null
decl_stmt|;
DECL|field|tfileMeta
specifier|final
name|TFileMeta
name|tfileMeta
decl_stmt|;
DECL|field|comparator
specifier|final
name|BytesComparator
name|comparator
decl_stmt|;
comment|// global begin and end locations.
DECL|field|begin
specifier|private
specifier|final
name|Location
name|begin
decl_stmt|;
DECL|field|end
specifier|private
specifier|final
name|Location
name|end
decl_stmt|;
comment|/**      * Location representing a virtual position in the TFile.      */
DECL|class|Location
specifier|static
specifier|final
class|class
name|Location
implements|implements
name|Comparable
argument_list|<
name|Location
argument_list|>
implements|,
name|Cloneable
block|{
DECL|field|blockIndex
specifier|private
name|int
name|blockIndex
decl_stmt|;
comment|// distance/offset from the beginning of the block
DECL|field|recordIndex
specifier|private
name|long
name|recordIndex
decl_stmt|;
DECL|method|Location (int blockIndex, long recordIndex)
name|Location
parameter_list|(
name|int
name|blockIndex
parameter_list|,
name|long
name|recordIndex
parameter_list|)
block|{
name|set
argument_list|(
name|blockIndex
argument_list|,
name|recordIndex
argument_list|)
expr_stmt|;
block|}
DECL|method|incRecordIndex ()
name|void
name|incRecordIndex
parameter_list|()
block|{
operator|++
name|recordIndex
expr_stmt|;
block|}
DECL|method|Location (Location other)
name|Location
parameter_list|(
name|Location
name|other
parameter_list|)
block|{
name|set
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
DECL|method|getBlockIndex ()
name|int
name|getBlockIndex
parameter_list|()
block|{
return|return
name|blockIndex
return|;
block|}
DECL|method|getRecordIndex ()
name|long
name|getRecordIndex
parameter_list|()
block|{
return|return
name|recordIndex
return|;
block|}
DECL|method|set (int blockIndex, long recordIndex)
name|void
name|set
parameter_list|(
name|int
name|blockIndex
parameter_list|,
name|long
name|recordIndex
parameter_list|)
block|{
if|if
condition|(
operator|(
name|blockIndex
operator||
name|recordIndex
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal parameter for BlockLocation."
argument_list|)
throw|;
block|}
name|this
operator|.
name|blockIndex
operator|=
name|blockIndex
expr_stmt|;
name|this
operator|.
name|recordIndex
operator|=
name|recordIndex
expr_stmt|;
block|}
DECL|method|set (Location other)
name|void
name|set
parameter_list|(
name|Location
name|other
parameter_list|)
block|{
name|set
argument_list|(
name|other
operator|.
name|blockIndex
argument_list|,
name|other
operator|.
name|recordIndex
argument_list|)
expr_stmt|;
block|}
comment|/**        * @see java.lang.Comparable#compareTo(java.lang.Object)        */
annotation|@
name|Override
DECL|method|compareTo (Location other)
specifier|public
name|int
name|compareTo
parameter_list|(
name|Location
name|other
parameter_list|)
block|{
return|return
name|compareTo
argument_list|(
name|other
operator|.
name|blockIndex
argument_list|,
name|other
operator|.
name|recordIndex
argument_list|)
return|;
block|}
DECL|method|compareTo (int bid, long rid)
name|int
name|compareTo
parameter_list|(
name|int
name|bid
parameter_list|,
name|long
name|rid
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|blockIndex
operator|==
name|bid
condition|)
block|{
name|long
name|ret
init|=
name|this
operator|.
name|recordIndex
operator|-
name|rid
decl_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
name|this
operator|.
name|blockIndex
operator|-
name|bid
return|;
block|}
comment|/**        * @see java.lang.Object#clone()        */
annotation|@
name|Override
DECL|method|clone ()
specifier|protected
name|Location
name|clone
parameter_list|()
block|{
return|return
operator|new
name|Location
argument_list|(
name|blockIndex
argument_list|,
name|recordIndex
argument_list|)
return|;
block|}
comment|/**        * @see java.lang.Object#hashCode()        */
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
name|prime
operator|+
name|blockIndex
decl_stmt|;
name|result
operator|=
call|(
name|int
call|)
argument_list|(
name|prime
operator|*
name|result
operator|+
name|recordIndex
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**        * @see java.lang.Object#equals(java.lang.Object)        */
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|Location
name|other
init|=
operator|(
name|Location
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|blockIndex
operator|!=
name|other
operator|.
name|blockIndex
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|recordIndex
operator|!=
name|other
operator|.
name|recordIndex
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Constructor      *       * @param fsdis      *          FS input stream of the TFile.      * @param fileLength      *          The length of TFile. This is required because we have no easy      *          way of knowing the actual size of the input file through the      *          File input stream.      * @param conf      * @throws IOException      */
DECL|method|Reader (FSDataInputStream fsdis, long fileLength, Configuration conf)
specifier|public
name|Reader
parameter_list|(
name|FSDataInputStream
name|fsdis
parameter_list|,
name|long
name|fileLength
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|readerBCF
operator|=
operator|new
name|BCFile
operator|.
name|Reader
argument_list|(
name|fsdis
argument_list|,
name|fileLength
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// first, read TFile meta
name|BlockReader
name|brMeta
init|=
name|readerBCF
operator|.
name|getMetaBlock
argument_list|(
name|TFileMeta
operator|.
name|BLOCK_NAME
argument_list|)
decl_stmt|;
try|try
block|{
name|tfileMeta
operator|=
operator|new
name|TFileMeta
argument_list|(
name|brMeta
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|brMeta
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|comparator
operator|=
name|tfileMeta
operator|.
name|getComparator
argument_list|()
expr_stmt|;
comment|// Set begin and end locations.
name|begin
operator|=
operator|new
name|Location
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
operator|=
operator|new
name|Location
argument_list|(
name|readerBCF
operator|.
name|getBlockCount
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Close the reader. The state of the Reader object is undefined after      * close. Calling close() for multiple times has no effect.      */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|readerBCF
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Get the begin location of the TFile.      *       * @return If TFile is not empty, the location of the first key-value pair.      *         Otherwise, it returns end().      */
DECL|method|begin ()
name|Location
name|begin
parameter_list|()
block|{
return|return
name|begin
return|;
block|}
comment|/**      * Get the end location of the TFile.      *       * @return The location right after the last key-value pair in TFile.      */
DECL|method|end ()
name|Location
name|end
parameter_list|()
block|{
return|return
name|end
return|;
block|}
comment|/**      * Get the string representation of the comparator.      *       * @return If the TFile is not sorted by keys, an empty string will be      *         returned. Otherwise, the actual comparator string that is      *         provided during the TFile creation time will be returned.      */
DECL|method|getComparatorName ()
specifier|public
name|String
name|getComparatorName
parameter_list|()
block|{
return|return
name|tfileMeta
operator|.
name|getComparatorString
argument_list|()
return|;
block|}
comment|/**      * Is the TFile sorted?      *       * @return true if TFile is sorted.      */
DECL|method|isSorted ()
specifier|public
name|boolean
name|isSorted
parameter_list|()
block|{
return|return
name|tfileMeta
operator|.
name|isSorted
argument_list|()
return|;
block|}
comment|/**      * Get the number of key-value pair entries in TFile.      *       * @return the number of key-value pairs in TFile      */
DECL|method|getEntryCount ()
specifier|public
name|long
name|getEntryCount
parameter_list|()
block|{
return|return
name|tfileMeta
operator|.
name|getRecordCount
argument_list|()
return|;
block|}
comment|/**      * Lazily loading the TFile index.      *       * @throws IOException      */
DECL|method|checkTFileDataIndex ()
specifier|synchronized
name|void
name|checkTFileDataIndex
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|tfileIndex
operator|==
literal|null
condition|)
block|{
name|BlockReader
name|brIndex
init|=
name|readerBCF
operator|.
name|getMetaBlock
argument_list|(
name|TFileIndex
operator|.
name|BLOCK_NAME
argument_list|)
decl_stmt|;
try|try
block|{
name|tfileIndex
operator|=
operator|new
name|TFileIndex
argument_list|(
name|readerBCF
operator|.
name|getBlockCount
argument_list|()
argument_list|,
name|brIndex
argument_list|,
name|tfileMeta
operator|.
name|getComparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|brIndex
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Get the first key in the TFile.      *       * @return The first key in the TFile.      * @throws IOException      */
DECL|method|getFirstKey ()
specifier|public
name|RawComparable
name|getFirstKey
parameter_list|()
throws|throws
name|IOException
block|{
name|checkTFileDataIndex
argument_list|()
expr_stmt|;
return|return
name|tfileIndex
operator|.
name|getFirstKey
argument_list|()
return|;
block|}
comment|/**      * Get the last key in the TFile.      *       * @return The last key in the TFile.      * @throws IOException      */
DECL|method|getLastKey ()
specifier|public
name|RawComparable
name|getLastKey
parameter_list|()
throws|throws
name|IOException
block|{
name|checkTFileDataIndex
argument_list|()
expr_stmt|;
return|return
name|tfileIndex
operator|.
name|getLastKey
argument_list|()
return|;
block|}
comment|/**      * Get a Comparator object to compare Entries. It is useful when you want      * stores the entries in a collection (such as PriorityQueue) and perform      * sorting or comparison among entries based on the keys without copying out      * the key.      *       * @return An Entry Comparator..      */
DECL|method|getEntryComparator ()
specifier|public
name|Comparator
argument_list|<
name|Scanner
operator|.
name|Entry
argument_list|>
name|getEntryComparator
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSorted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Entries are not comparable for unsorted TFiles"
argument_list|)
throw|;
block|}
return|return
operator|new
name|Comparator
argument_list|<
name|Scanner
operator|.
name|Entry
argument_list|>
argument_list|()
block|{
comment|/**          * Provide a customized comparator for Entries. This is useful if we          * have a collection of Entry objects. However, if the Entry objects          * come from different TFiles, users must ensure that those TFiles share          * the same RawComparator.          */
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Scanner
operator|.
name|Entry
name|o1
parameter_list|,
name|Scanner
operator|.
name|Entry
name|o2
parameter_list|)
block|{
return|return
name|comparator
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|getKeyBuffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|o1
operator|.
name|getKeyLength
argument_list|()
argument_list|,
name|o2
operator|.
name|getKeyBuffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|o2
operator|.
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**      * Get an instance of the RawComparator that is constructed based on the      * string comparator representation.      *       * @return a Comparator that can compare RawComparable's.      */
DECL|method|getComparator ()
specifier|public
name|Comparator
argument_list|<
name|RawComparable
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|comparator
return|;
block|}
comment|/**      * Stream access to a meta block.``      *       * @param name      *          The name of the meta block.      * @return The input stream.      * @throws IOException      *           on I/O error.      * @throws MetaBlockDoesNotExist      *           If the meta block with the name does not exist.      */
DECL|method|getMetaBlock (String name)
specifier|public
name|DataInputStream
name|getMetaBlock
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
throws|,
name|MetaBlockDoesNotExist
block|{
return|return
name|readerBCF
operator|.
name|getMetaBlock
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * if greater is true then returns the beginning location of the block      * containing the key strictly greater than input key. if greater is false      * then returns the beginning location of the block greater than equal to      * the input key      *       * @param key      *          the input key      * @param greater      *          boolean flag      * @return      * @throws IOException      */
DECL|method|getBlockContainsKey (RawComparable key, boolean greater)
name|Location
name|getBlockContainsKey
parameter_list|(
name|RawComparable
name|key
parameter_list|,
name|boolean
name|greater
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSorted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Seeking in unsorted TFile"
argument_list|)
throw|;
block|}
name|checkTFileDataIndex
argument_list|()
expr_stmt|;
name|int
name|blkIndex
init|=
operator|(
name|greater
operator|)
condition|?
name|tfileIndex
operator|.
name|upperBound
argument_list|(
name|key
argument_list|)
else|:
name|tfileIndex
operator|.
name|lowerBound
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|blkIndex
operator|<
literal|0
condition|)
return|return
name|end
return|;
return|return
operator|new
name|Location
argument_list|(
name|blkIndex
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|method|getLocationByRecordNum (long recNum)
name|Location
name|getLocationByRecordNum
parameter_list|(
name|long
name|recNum
parameter_list|)
throws|throws
name|IOException
block|{
name|checkTFileDataIndex
argument_list|()
expr_stmt|;
return|return
name|tfileIndex
operator|.
name|getLocationByRecordNum
argument_list|(
name|recNum
argument_list|)
return|;
block|}
DECL|method|getRecordNumByLocation (Location location)
name|long
name|getRecordNumByLocation
parameter_list|(
name|Location
name|location
parameter_list|)
throws|throws
name|IOException
block|{
name|checkTFileDataIndex
argument_list|()
expr_stmt|;
return|return
name|tfileIndex
operator|.
name|getRecordNumByLocation
argument_list|(
name|location
argument_list|)
return|;
block|}
DECL|method|compareKeys (byte[] a, int o1, int l1, byte[] b, int o2, int l2)
name|int
name|compareKeys
parameter_list|(
name|byte
index|[]
name|a
parameter_list|,
name|int
name|o1
parameter_list|,
name|int
name|l1
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|o2
parameter_list|,
name|int
name|l2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isSorted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot compare keys for unsorted TFiles."
argument_list|)
throw|;
block|}
return|return
name|comparator
operator|.
name|compare
argument_list|(
name|a
argument_list|,
name|o1
argument_list|,
name|l1
argument_list|,
name|b
argument_list|,
name|o2
argument_list|,
name|l2
argument_list|)
return|;
block|}
DECL|method|compareKeys (RawComparable a, RawComparable b)
name|int
name|compareKeys
parameter_list|(
name|RawComparable
name|a
parameter_list|,
name|RawComparable
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isSorted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot compare keys for unsorted TFiles."
argument_list|)
throw|;
block|}
return|return
name|comparator
operator|.
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
comment|/**      * Get the location pointing to the beginning of the first key-value pair in      * a compressed block whose byte offset in the TFile is greater than or      * equal to the specified offset.      *       * @param offset      *          the user supplied offset.      * @return the location to the corresponding entry; or end() if no such      *         entry exists.      */
DECL|method|getLocationNear (long offset)
name|Location
name|getLocationNear
parameter_list|(
name|long
name|offset
parameter_list|)
block|{
name|int
name|blockIndex
init|=
name|readerBCF
operator|.
name|getBlockIndexNear
argument_list|(
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockIndex
operator|==
operator|-
literal|1
condition|)
return|return
name|end
return|;
return|return
operator|new
name|Location
argument_list|(
name|blockIndex
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      * Get the RecordNum for the first key-value pair in a compressed block      * whose byte offset in the TFile is greater than or equal to the specified      * offset.      *       * @param offset      *          the user supplied offset.      * @return the RecordNum to the corresponding entry. If no such entry      *         exists, it returns the total entry count.      * @throws IOException      */
DECL|method|getRecordNumNear (long offset)
specifier|public
name|long
name|getRecordNumNear
parameter_list|(
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getRecordNumByLocation
argument_list|(
name|getLocationNear
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Get a sample key that is within a block whose starting offset is greater      * than or equal to the specified offset.      *       * @param offset      *          The file offset.      * @return the key that fits the requirement; or null if no such key exists      *         (which could happen if the offset is close to the end of the      *         TFile).      * @throws IOException      */
DECL|method|getKeyNear (long offset)
specifier|public
name|RawComparable
name|getKeyNear
parameter_list|(
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|blockIndex
init|=
name|readerBCF
operator|.
name|getBlockIndexNear
argument_list|(
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockIndex
operator|==
operator|-
literal|1
condition|)
return|return
literal|null
return|;
name|checkTFileDataIndex
argument_list|()
expr_stmt|;
return|return
operator|new
name|ByteArray
argument_list|(
name|tfileIndex
operator|.
name|getEntry
argument_list|(
name|blockIndex
argument_list|)
operator|.
name|key
argument_list|)
return|;
block|}
comment|/**      * Get a scanner than can scan the whole TFile.      *       * @return The scanner object. A valid Scanner is always returned even if      *         the TFile is empty.      * @throws IOException      */
DECL|method|createScanner ()
specifier|public
name|Scanner
name|createScanner
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|Scanner
argument_list|(
name|this
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
return|;
block|}
comment|/**      * Get a scanner that covers a portion of TFile based on byte offsets.      *       * @param offset      *          The beginning byte offset in the TFile.      * @param length      *          The length of the region.      * @return The actual coverage of the returned scanner tries to match the      *         specified byte-region but always round up to the compression      *         block boundaries. It is possible that the returned scanner      *         contains zero key-value pairs even if length is positive.      * @throws IOException      */
DECL|method|createScannerByByteRange (long offset, long length)
specifier|public
name|Scanner
name|createScannerByByteRange
parameter_list|(
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Scanner
argument_list|(
name|this
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|length
argument_list|)
return|;
block|}
comment|/**      * Get a scanner that covers a portion of TFile based on keys.      *       * @param beginKey      *          Begin key of the scan (inclusive). If null, scan from the first      *          key-value entry of the TFile.      * @param endKey      *          End key of the scan (exclusive). If null, scan up to the last      *          key-value entry of the TFile.      * @return The actual coverage of the returned scanner will cover all keys      *         greater than or equal to the beginKey and less than the endKey.      * @throws IOException      *       * @deprecated Use {@link #createScannerByKey(byte[], byte[])} instead.      */
annotation|@
name|Deprecated
DECL|method|createScanner (byte[] beginKey, byte[] endKey)
specifier|public
name|Scanner
name|createScanner
parameter_list|(
name|byte
index|[]
name|beginKey
parameter_list|,
name|byte
index|[]
name|endKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createScannerByKey
argument_list|(
name|beginKey
argument_list|,
name|endKey
argument_list|)
return|;
block|}
comment|/**      * Get a scanner that covers a portion of TFile based on keys.      *       * @param beginKey      *          Begin key of the scan (inclusive). If null, scan from the first      *          key-value entry of the TFile.      * @param endKey      *          End key of the scan (exclusive). If null, scan up to the last      *          key-value entry of the TFile.      * @return The actual coverage of the returned scanner will cover all keys      *         greater than or equal to the beginKey and less than the endKey.      * @throws IOException      */
DECL|method|createScannerByKey (byte[] beginKey, byte[] endKey)
specifier|public
name|Scanner
name|createScannerByKey
parameter_list|(
name|byte
index|[]
name|beginKey
parameter_list|,
name|byte
index|[]
name|endKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createScannerByKey
argument_list|(
operator|(
name|beginKey
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
operator|new
name|ByteArray
argument_list|(
name|beginKey
argument_list|,
literal|0
argument_list|,
name|beginKey
operator|.
name|length
argument_list|)
argument_list|,
operator|(
name|endKey
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
operator|new
name|ByteArray
argument_list|(
name|endKey
argument_list|,
literal|0
argument_list|,
name|endKey
operator|.
name|length
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Get a scanner that covers a specific key range.      *       * @param beginKey      *          Begin key of the scan (inclusive). If null, scan from the first      *          key-value entry of the TFile.      * @param endKey      *          End key of the scan (exclusive). If null, scan up to the last      *          key-value entry of the TFile.      * @return The actual coverage of the returned scanner will cover all keys      *         greater than or equal to the beginKey and less than the endKey.      * @throws IOException      *       * @deprecated Use {@link #createScannerByKey(RawComparable, RawComparable)}      *             instead.      */
annotation|@
name|Deprecated
DECL|method|createScanner (RawComparable beginKey, RawComparable endKey)
specifier|public
name|Scanner
name|createScanner
parameter_list|(
name|RawComparable
name|beginKey
parameter_list|,
name|RawComparable
name|endKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createScannerByKey
argument_list|(
name|beginKey
argument_list|,
name|endKey
argument_list|)
return|;
block|}
comment|/**      * Get a scanner that covers a specific key range.      *       * @param beginKey      *          Begin key of the scan (inclusive). If null, scan from the first      *          key-value entry of the TFile.      * @param endKey      *          End key of the scan (exclusive). If null, scan up to the last      *          key-value entry of the TFile.      * @return The actual coverage of the returned scanner will cover all keys      *         greater than or equal to the beginKey and less than the endKey.      * @throws IOException      */
DECL|method|createScannerByKey (RawComparable beginKey, RawComparable endKey)
specifier|public
name|Scanner
name|createScannerByKey
parameter_list|(
name|RawComparable
name|beginKey
parameter_list|,
name|RawComparable
name|endKey
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|beginKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|endKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|compareKeys
argument_list|(
name|beginKey
argument_list|,
name|endKey
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
return|return
operator|new
name|Scanner
argument_list|(
name|this
argument_list|,
name|beginKey
argument_list|,
name|beginKey
argument_list|)
return|;
block|}
return|return
operator|new
name|Scanner
argument_list|(
name|this
argument_list|,
name|beginKey
argument_list|,
name|endKey
argument_list|)
return|;
block|}
comment|/**      * Create a scanner that covers a range of records.      *       * @param beginRecNum      *          The RecordNum for the first record (inclusive).      * @param endRecNum      *          The RecordNum for the last record (exclusive). To scan the whole      *          file, either specify endRecNum==-1 or endRecNum==getEntryCount().      * @return The TFile scanner that covers the specified range of records.      * @throws IOException      */
DECL|method|createScannerByRecordNum (long beginRecNum, long endRecNum)
specifier|public
name|Scanner
name|createScannerByRecordNum
parameter_list|(
name|long
name|beginRecNum
parameter_list|,
name|long
name|endRecNum
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|beginRecNum
operator|<
literal|0
condition|)
name|beginRecNum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|endRecNum
argument_list|<
literal|0
operator|||
name|endRecNum
argument_list|>
name|getEntryCount
argument_list|()
condition|)
block|{
name|endRecNum
operator|=
name|getEntryCount
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|Scanner
argument_list|(
name|this
argument_list|,
name|getLocationByRecordNum
argument_list|(
name|beginRecNum
argument_list|)
argument_list|,
name|getLocationByRecordNum
argument_list|(
name|endRecNum
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * The TFile Scanner. The Scanner has an implicit cursor, which, upon      * creation, points to the first key-value pair in the scan range. If the      * scan range is empty, the cursor will point to the end of the scan range.      *<p>      * Use {@link Scanner#atEnd()} to test whether the cursor is at the end      * location of the scanner.      *<p>      * Use {@link Scanner#advance()} to move the cursor to the next key-value      * pair (or end if none exists). Use seekTo methods (      * {@link Scanner#seekTo(byte[])} or      * {@link Scanner#seekTo(byte[], int, int)}) to seek to any arbitrary      * location in the covered range (including backward seeking). Use      * {@link Scanner#rewind()} to seek back to the beginning of the scanner.      * Use {@link Scanner#seekToEnd()} to seek to the end of the scanner.      *<p>      * Actual keys and values may be obtained through {@link Scanner.Entry}      * object, which is obtained through {@link Scanner#entry()}.      */
DECL|class|Scanner
specifier|public
specifier|static
class|class
name|Scanner
implements|implements
name|Closeable
block|{
comment|// The underlying TFile reader.
DECL|field|reader
specifier|final
name|Reader
name|reader
decl_stmt|;
comment|// current block (null if reaching end)
DECL|field|blkReader
specifier|private
name|BlockReader
name|blkReader
decl_stmt|;
DECL|field|beginLocation
name|Location
name|beginLocation
decl_stmt|;
DECL|field|endLocation
name|Location
name|endLocation
decl_stmt|;
DECL|field|currentLocation
name|Location
name|currentLocation
decl_stmt|;
comment|// flag to ensure value is only examined once.
DECL|field|valueChecked
name|boolean
name|valueChecked
init|=
literal|false
decl_stmt|;
comment|// reusable buffer for keys.
DECL|field|keyBuffer
specifier|final
name|byte
index|[]
name|keyBuffer
decl_stmt|;
comment|// length of key, -1 means key is invalid.
DECL|field|klen
name|int
name|klen
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|MAX_VAL_TRANSFER_BUF_SIZE
specifier|static
specifier|final
name|int
name|MAX_VAL_TRANSFER_BUF_SIZE
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
DECL|field|valTransferBuffer
name|BytesWritable
name|valTransferBuffer
decl_stmt|;
DECL|field|keyDataInputStream
name|DataInputBuffer
name|keyDataInputStream
decl_stmt|;
DECL|field|valueBufferInputStream
name|ChunkDecoder
name|valueBufferInputStream
decl_stmt|;
DECL|field|valueDataInputStream
name|DataInputStream
name|valueDataInputStream
decl_stmt|;
comment|// vlen == -1 if unknown.
DECL|field|vlen
name|int
name|vlen
decl_stmt|;
comment|/**        * Constructor        *         * @param reader        *          The TFile reader object.        * @param offBegin        *          Begin byte-offset of the scan.        * @param offEnd        *          End byte-offset of the scan.        * @throws IOException        *         *           The offsets will be rounded to the beginning of a compressed        *           block whose offset is greater than or equal to the specified        *           offset.        */
DECL|method|Scanner (Reader reader, long offBegin, long offEnd)
specifier|protected
name|Scanner
parameter_list|(
name|Reader
name|reader
parameter_list|,
name|long
name|offBegin
parameter_list|,
name|long
name|offEnd
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|reader
argument_list|,
name|reader
operator|.
name|getLocationNear
argument_list|(
name|offBegin
argument_list|)
argument_list|,
name|reader
operator|.
name|getLocationNear
argument_list|(
name|offEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**        * Constructor        *         * @param reader        *          The TFile reader object.        * @param begin        *          Begin location of the scan.        * @param end        *          End location of the scan.        * @throws IOException        */
DECL|method|Scanner (Reader reader, Location begin, Location end)
name|Scanner
parameter_list|(
name|Reader
name|reader
parameter_list|,
name|Location
name|begin
parameter_list|,
name|Location
name|end
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
comment|// ensure the TFile index is loaded throughout the life of scanner.
name|reader
operator|.
name|checkTFileDataIndex
argument_list|()
expr_stmt|;
name|beginLocation
operator|=
name|begin
expr_stmt|;
name|endLocation
operator|=
name|end
expr_stmt|;
name|valTransferBuffer
operator|=
operator|new
name|BytesWritable
argument_list|()
expr_stmt|;
comment|// TODO: remember the longest key in a TFile, and use it to replace
comment|// MAX_KEY_SIZE.
name|keyBuffer
operator|=
operator|new
name|byte
index|[
name|MAX_KEY_SIZE
index|]
expr_stmt|;
name|keyDataInputStream
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
name|valueBufferInputStream
operator|=
operator|new
name|ChunkDecoder
argument_list|()
expr_stmt|;
name|valueDataInputStream
operator|=
operator|new
name|DataInputStream
argument_list|(
name|valueBufferInputStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|beginLocation
operator|.
name|compareTo
argument_list|(
name|endLocation
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|currentLocation
operator|=
operator|new
name|Location
argument_list|(
name|endLocation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentLocation
operator|=
operator|new
name|Location
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initBlock
argument_list|(
name|beginLocation
operator|.
name|getBlockIndex
argument_list|()
argument_list|)
expr_stmt|;
name|inBlockAdvance
argument_list|(
name|beginLocation
operator|.
name|getRecordIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**        * Constructor        *         * @param reader        *          The TFile reader object.        * @param beginKey        *          Begin key of the scan. If null, scan from the first        *&lt;K, V&gt; entry of the TFile.        * @param endKey        *          End key of the scan. If null, scan up to the last&lt;K, V&gt;        *          entry of the TFile.        * @throws IOException        */
DECL|method|Scanner (Reader reader, RawComparable beginKey, RawComparable endKey)
specifier|protected
name|Scanner
parameter_list|(
name|Reader
name|reader
parameter_list|,
name|RawComparable
name|beginKey
parameter_list|,
name|RawComparable
name|endKey
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|reader
argument_list|,
operator|(
name|beginKey
operator|==
literal|null
operator|)
condition|?
name|reader
operator|.
name|begin
argument_list|()
else|:
name|reader
operator|.
name|getBlockContainsKey
argument_list|(
name|beginKey
argument_list|,
literal|false
argument_list|)
argument_list|,
name|reader
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|beginKey
operator|!=
literal|null
condition|)
block|{
name|inBlockAdvance
argument_list|(
name|beginKey
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|beginLocation
operator|.
name|set
argument_list|(
name|currentLocation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endKey
operator|!=
literal|null
condition|)
block|{
name|seekTo
argument_list|(
name|endKey
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|endLocation
operator|.
name|set
argument_list|(
name|currentLocation
argument_list|)
expr_stmt|;
name|seekTo
argument_list|(
name|beginLocation
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**        * Move the cursor to the first entry whose key is greater than or equal        * to the input key. Synonymous to seekTo(key, 0, key.length). The entry        * returned by the previous entry() call will be invalid.        *         * @param key        *          The input key        * @return true if we find an equal key.        * @throws IOException        */
DECL|method|seekTo (byte[] key)
specifier|public
name|boolean
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**        * Move the cursor to the first entry whose key is greater than or equal        * to the input key. The entry returned by the previous entry() call will        * be invalid.        *         * @param key        *          The input key        * @param keyOffset        *          offset in the key buffer.        * @param keyLen        *          key buffer length.        * @return true if we find an equal key; false otherwise.        * @throws IOException        */
DECL|method|seekTo (byte[] key, int keyOffset, int keyLen)
specifier|public
name|boolean
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|keyOffset
parameter_list|,
name|int
name|keyLen
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekTo
argument_list|(
operator|new
name|ByteArray
argument_list|(
name|key
argument_list|,
name|keyOffset
argument_list|,
name|keyLen
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|seekTo (RawComparable key, boolean beyond)
specifier|private
name|boolean
name|seekTo
parameter_list|(
name|RawComparable
name|key
parameter_list|,
name|boolean
name|beyond
parameter_list|)
throws|throws
name|IOException
block|{
name|Location
name|l
init|=
name|reader
operator|.
name|getBlockContainsKey
argument_list|(
name|key
argument_list|,
name|beyond
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|.
name|compareTo
argument_list|(
name|beginLocation
argument_list|)
operator|<
literal|0
condition|)
block|{
name|l
operator|=
name|beginLocation
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|.
name|compareTo
argument_list|(
name|endLocation
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|seekTo
argument_list|(
name|endLocation
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// check if what we are seeking is in the later part of the current
comment|// block.
if|if
condition|(
name|atEnd
argument_list|()
operator|||
operator|(
name|l
operator|.
name|getBlockIndex
argument_list|()
operator|!=
name|currentLocation
operator|.
name|getBlockIndex
argument_list|()
operator|)
operator|||
operator|(
name|compareCursorKeyTo
argument_list|(
name|key
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
comment|// sorry, we must seek to a different location first.
name|seekTo
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|inBlockAdvance
argument_list|(
name|key
argument_list|,
name|beyond
argument_list|)
return|;
block|}
comment|/**        * Move the cursor to the new location. The entry returned by the previous        * entry() call will be invalid.        *         * @param l        *          new cursor location. It must fall between the begin and end        *          location of the scanner.        * @throws IOException        */
DECL|method|seekTo (Location l)
specifier|private
name|void
name|seekTo
parameter_list|(
name|Location
name|l
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|l
operator|.
name|compareTo
argument_list|(
name|beginLocation
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Attempt to seek before the begin location."
argument_list|)
throw|;
block|}
if|if
condition|(
name|l
operator|.
name|compareTo
argument_list|(
name|endLocation
argument_list|)
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Attempt to seek after the end location."
argument_list|)
throw|;
block|}
if|if
condition|(
name|l
operator|.
name|compareTo
argument_list|(
name|endLocation
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parkCursorAtEnd
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|l
operator|.
name|getBlockIndex
argument_list|()
operator|!=
name|currentLocation
operator|.
name|getBlockIndex
argument_list|()
condition|)
block|{
comment|// going to a totally different block
name|initBlock
argument_list|(
name|l
operator|.
name|getBlockIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|valueChecked
condition|)
block|{
comment|// may temporarily go beyond the last record in the block (in which
comment|// case the next if loop will always be true).
name|inBlockAdvance
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|.
name|getRecordIndex
argument_list|()
operator|<
name|currentLocation
operator|.
name|getRecordIndex
argument_list|()
condition|)
block|{
name|initBlock
argument_list|(
name|l
operator|.
name|getBlockIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|inBlockAdvance
argument_list|(
name|l
operator|.
name|getRecordIndex
argument_list|()
operator|-
name|currentLocation
operator|.
name|getRecordIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/**        * Rewind to the first entry in the scanner. The entry returned by the        * previous entry() call will be invalid.        *         * @throws IOException        */
DECL|method|rewind ()
specifier|public
name|void
name|rewind
parameter_list|()
throws|throws
name|IOException
block|{
name|seekTo
argument_list|(
name|beginLocation
argument_list|)
expr_stmt|;
block|}
comment|/**        * Seek to the end of the scanner. The entry returned by the previous        * entry() call will be invalid.        *         * @throws IOException        */
DECL|method|seekToEnd ()
specifier|public
name|void
name|seekToEnd
parameter_list|()
throws|throws
name|IOException
block|{
name|parkCursorAtEnd
argument_list|()
expr_stmt|;
block|}
comment|/**        * Move the cursor to the first entry whose key is greater than or equal        * to the input key. Synonymous to lowerBound(key, 0, key.length). The        * entry returned by the previous entry() call will be invalid.        *         * @param key        *          The input key        * @throws IOException        */
DECL|method|lowerBound (byte[] key)
specifier|public
name|void
name|lowerBound
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|lowerBound
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**        * Move the cursor to the first entry whose key is greater than or equal        * to the input key. The entry returned by the previous entry() call will        * be invalid.        *         * @param key        *          The input key        * @param keyOffset        *          offset in the key buffer.        * @param keyLen        *          key buffer length.        * @throws IOException        */
DECL|method|lowerBound (byte[] key, int keyOffset, int keyLen)
specifier|public
name|void
name|lowerBound
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|keyOffset
parameter_list|,
name|int
name|keyLen
parameter_list|)
throws|throws
name|IOException
block|{
name|seekTo
argument_list|(
operator|new
name|ByteArray
argument_list|(
name|key
argument_list|,
name|keyOffset
argument_list|,
name|keyLen
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**        * Move the cursor to the first entry whose key is strictly greater than        * the input key. Synonymous to upperBound(key, 0, key.length). The entry        * returned by the previous entry() call will be invalid.        *         * @param key        *          The input key        * @throws IOException        */
DECL|method|upperBound (byte[] key)
specifier|public
name|void
name|upperBound
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|upperBound
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**        * Move the cursor to the first entry whose key is strictly greater than        * the input key. The entry returned by the previous entry() call will be        * invalid.        *         * @param key        *          The input key        * @param keyOffset        *          offset in the key buffer.        * @param keyLen        *          key buffer length.        * @throws IOException        */
DECL|method|upperBound (byte[] key, int keyOffset, int keyLen)
specifier|public
name|void
name|upperBound
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|keyOffset
parameter_list|,
name|int
name|keyLen
parameter_list|)
throws|throws
name|IOException
block|{
name|seekTo
argument_list|(
operator|new
name|ByteArray
argument_list|(
name|key
argument_list|,
name|keyOffset
argument_list|,
name|keyLen
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**        * Move the cursor to the next key-value pair. The entry returned by the        * previous entry() call will be invalid.        *         * @return true if the cursor successfully moves. False when cursor is        *         already at the end location and cannot be advanced.        * @throws IOException        */
DECL|method|advance ()
specifier|public
name|boolean
name|advance
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|curBid
init|=
name|currentLocation
operator|.
name|getBlockIndex
argument_list|()
decl_stmt|;
name|long
name|curRid
init|=
name|currentLocation
operator|.
name|getRecordIndex
argument_list|()
decl_stmt|;
name|long
name|entriesInBlock
init|=
name|reader
operator|.
name|getBlockEntryCount
argument_list|(
name|curBid
argument_list|)
decl_stmt|;
if|if
condition|(
name|curRid
operator|+
literal|1
operator|>=
name|entriesInBlock
condition|)
block|{
if|if
condition|(
name|endLocation
operator|.
name|compareTo
argument_list|(
name|curBid
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|// last entry in TFile.
name|parkCursorAtEnd
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// last entry in Block.
name|initBlock
argument_list|(
name|curBid
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inBlockAdvance
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**        * Load a compressed block for reading. Expecting blockIndex is valid.        *         * @throws IOException        */
DECL|method|initBlock (int blockIndex)
specifier|private
name|void
name|initBlock
parameter_list|(
name|int
name|blockIndex
parameter_list|)
throws|throws
name|IOException
block|{
name|klen
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|blkReader
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|blkReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|blkReader
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|blkReader
operator|=
name|reader
operator|.
name|getBlockReader
argument_list|(
name|blockIndex
argument_list|)
expr_stmt|;
name|currentLocation
operator|.
name|set
argument_list|(
name|blockIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|parkCursorAtEnd ()
specifier|private
name|void
name|parkCursorAtEnd
parameter_list|()
throws|throws
name|IOException
block|{
name|klen
operator|=
operator|-
literal|1
expr_stmt|;
name|currentLocation
operator|.
name|set
argument_list|(
name|endLocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkReader
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|blkReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|blkReader
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/**        * Close the scanner. Release all resources. The behavior of using the        * scanner after calling close is not defined. The entry returned by the        * previous entry() call will be invalid.        */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|parkCursorAtEnd
argument_list|()
expr_stmt|;
block|}
comment|/**        * Is cursor at the end location?        *         * @return true if the cursor is at the end location.        */
DECL|method|atEnd ()
specifier|public
name|boolean
name|atEnd
parameter_list|()
block|{
return|return
operator|(
name|currentLocation
operator|.
name|compareTo
argument_list|(
name|endLocation
argument_list|)
operator|>=
literal|0
operator|)
return|;
block|}
comment|/**        * check whether we have already successfully obtained the key. It also        * initializes the valueInputStream.        */
DECL|method|checkKey ()
name|void
name|checkKey
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|klen
operator|>=
literal|0
condition|)
return|return;
if|if
condition|(
name|atEnd
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"No key-value to read"
argument_list|)
throw|;
block|}
name|klen
operator|=
operator|-
literal|1
expr_stmt|;
name|vlen
operator|=
operator|-
literal|1
expr_stmt|;
name|valueChecked
operator|=
literal|false
expr_stmt|;
name|klen
operator|=
name|Utils
operator|.
name|readVInt
argument_list|(
name|blkReader
argument_list|)
expr_stmt|;
name|blkReader
operator|.
name|readFully
argument_list|(
name|keyBuffer
argument_list|,
literal|0
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|valueBufferInputStream
operator|.
name|reset
argument_list|(
name|blkReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|valueBufferInputStream
operator|.
name|isLastChunk
argument_list|()
condition|)
block|{
name|vlen
operator|=
name|valueBufferInputStream
operator|.
name|getRemain
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**        * Get an entry to access the key and value.        *         * @return The Entry object to access the key and value.        * @throws IOException        */
DECL|method|entry ()
specifier|public
name|Entry
name|entry
parameter_list|()
throws|throws
name|IOException
block|{
name|checkKey
argument_list|()
expr_stmt|;
return|return
operator|new
name|Entry
argument_list|()
return|;
block|}
comment|/**        * Get the RecordNum corresponding to the entry pointed by the cursor.        * @return The RecordNum corresponding to the entry pointed by the cursor.        * @throws IOException        */
DECL|method|getRecordNum ()
specifier|public
name|long
name|getRecordNum
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|getRecordNumByLocation
argument_list|(
name|currentLocation
argument_list|)
return|;
block|}
comment|/**        * Internal API. Comparing the key at cursor to user-specified key.        *         * @param other        *          user-specified key.        * @return negative if key at cursor is smaller than user key; 0 if equal;        *         and positive if key at cursor greater than user key.        * @throws IOException        */
DECL|method|compareCursorKeyTo (RawComparable other)
name|int
name|compareCursorKeyTo
parameter_list|(
name|RawComparable
name|other
parameter_list|)
throws|throws
name|IOException
block|{
name|checkKey
argument_list|()
expr_stmt|;
return|return
name|reader
operator|.
name|compareKeys
argument_list|(
name|keyBuffer
argument_list|,
literal|0
argument_list|,
name|klen
argument_list|,
name|other
operator|.
name|buffer
argument_list|()
argument_list|,
name|other
operator|.
name|offset
argument_list|()
argument_list|,
name|other
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**        * Entry to a&lt;Key, Value&gt; pair.        */
DECL|class|Entry
specifier|public
class|class
name|Entry
implements|implements
name|Comparable
argument_list|<
name|RawComparable
argument_list|>
block|{
comment|/**          * Get the length of the key.          *           * @return the length of the key.          */
DECL|method|getKeyLength ()
specifier|public
name|int
name|getKeyLength
parameter_list|()
block|{
return|return
name|klen
return|;
block|}
DECL|method|getKeyBuffer ()
name|byte
index|[]
name|getKeyBuffer
parameter_list|()
block|{
return|return
name|keyBuffer
return|;
block|}
comment|/**          * Copy the key and value in one shot into BytesWritables. This is          * equivalent to getKey(key); getValue(value);          *           * @param key          *          BytesWritable to hold key.          * @param value          *          BytesWritable to hold value          * @throws IOException          */
DECL|method|get (BytesWritable key, BytesWritable value)
specifier|public
name|void
name|get
parameter_list|(
name|BytesWritable
name|key
parameter_list|,
name|BytesWritable
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|getKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|getValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**          * Copy the key into BytesWritable. The input BytesWritable will be          * automatically resized to the actual key size.          *           * @param key          *          BytesWritable to hold the key.          * @throws IOException          */
DECL|method|getKey (BytesWritable key)
specifier|public
name|int
name|getKey
parameter_list|(
name|BytesWritable
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|key
operator|.
name|setSize
argument_list|(
name|getKeyLength
argument_list|()
argument_list|)
expr_stmt|;
name|getKey
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|key
operator|.
name|getLength
argument_list|()
return|;
block|}
comment|/**          * Copy the value into BytesWritable. The input BytesWritable will be          * automatically resized to the actual value size. The implementation          * directly uses the buffer inside BytesWritable for storing the value.          * The call does not require the value length to be known.          *           * @param value          * @throws IOException          */
DECL|method|getValue (BytesWritable value)
specifier|public
name|long
name|getValue
parameter_list|(
name|BytesWritable
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|DataInputStream
name|dis
init|=
name|getValueStream
argument_list|()
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
try|try
block|{
name|int
name|remain
decl_stmt|;
while|while
condition|(
operator|(
name|remain
operator|=
name|valueBufferInputStream
operator|.
name|getRemain
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|value
operator|.
name|setSize
argument_list|(
name|size
operator|+
name|remain
argument_list|)
expr_stmt|;
name|dis
operator|.
name|readFully
argument_list|(
name|value
operator|.
name|getBytes
argument_list|()
argument_list|,
name|size
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|size
operator|+=
name|remain
expr_stmt|;
block|}
return|return
name|value
operator|.
name|getLength
argument_list|()
return|;
block|}
finally|finally
block|{
name|dis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Writing the key to the output stream. This method avoids copying key          * buffer from Scanner into user buffer, then writing to the output          * stream.          *           * @param out          *          The output stream          * @return the length of the key.          * @throws IOException          */
DECL|method|writeKey (OutputStream out)
specifier|public
name|int
name|writeKey
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|keyBuffer
argument_list|,
literal|0
argument_list|,
name|klen
argument_list|)
expr_stmt|;
return|return
name|klen
return|;
block|}
comment|/**          * Writing the value to the output stream. This method avoids copying          * value data from Scanner into user buffer, then writing to the output          * stream. It does not require the value length to be known.          *           * @param out          *          The output stream          * @return the length of the value          * @throws IOException          */
DECL|method|writeValue (OutputStream out)
specifier|public
name|long
name|writeValue
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|DataInputStream
name|dis
init|=
name|getValueStream
argument_list|()
decl_stmt|;
name|long
name|size
init|=
literal|0
decl_stmt|;
try|try
block|{
name|int
name|chunkSize
decl_stmt|;
while|while
condition|(
operator|(
name|chunkSize
operator|=
name|valueBufferInputStream
operator|.
name|getRemain
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|chunkSize
operator|=
name|Math
operator|.
name|min
argument_list|(
name|chunkSize
argument_list|,
name|MAX_VAL_TRANSFER_BUF_SIZE
argument_list|)
expr_stmt|;
name|valTransferBuffer
operator|.
name|setSize
argument_list|(
name|chunkSize
argument_list|)
expr_stmt|;
name|dis
operator|.
name|readFully
argument_list|(
name|valTransferBuffer
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|valTransferBuffer
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|size
operator|+=
name|chunkSize
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
finally|finally
block|{
name|dis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Copy the key into user supplied buffer.          *           * @param buf          *          The buffer supplied by user. The length of the buffer must          *          not be shorter than the key length.          * @return The length of the key.          *           * @throws IOException          */
DECL|method|getKey (byte[] buf)
specifier|public
name|int
name|getKey
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getKey
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**          * Copy the key into user supplied buffer.          *           * @param buf          *          The buffer supplied by user.          * @param offset          *          The starting offset of the user buffer where we should copy          *          the key into. Requiring the key-length + offset no greater          *          than the buffer length.          * @return The length of the key.          * @throws IOException          */
DECL|method|getKey (byte[] buf, int offset)
specifier|public
name|int
name|getKey
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|offset
operator||
operator|(
name|buf
operator|.
name|length
operator|-
name|offset
operator|-
name|klen
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Buffer not enough to store the key"
argument_list|)
throw|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|keyBuffer
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|klen
argument_list|)
expr_stmt|;
return|return
name|klen
return|;
block|}
comment|/**          * Streaming access to the key. Useful for desrializing the key into          * user objects.          *           * @return The input stream.          */
DECL|method|getKeyStream ()
specifier|public
name|DataInputStream
name|getKeyStream
parameter_list|()
block|{
name|keyDataInputStream
operator|.
name|reset
argument_list|(
name|keyBuffer
argument_list|,
name|klen
argument_list|)
expr_stmt|;
return|return
name|keyDataInputStream
return|;
block|}
comment|/**          * Get the length of the value. isValueLengthKnown() must be tested          * true.          *           * @return the length of the value.          */
DECL|method|getValueLength ()
specifier|public
name|int
name|getValueLength
parameter_list|()
block|{
if|if
condition|(
name|vlen
operator|>=
literal|0
condition|)
block|{
return|return
name|vlen
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Value length unknown."
argument_list|)
throw|;
block|}
comment|/**          * Copy value into user-supplied buffer. User supplied buffer must be          * large enough to hold the whole value. The value part of the key-value          * pair pointed by the current cursor is not cached and can only be          * examined once. Calling any of the following functions more than once          * without moving the cursor will result in exception:          * {@link #getValue(byte[])}, {@link #getValue(byte[], int)},          * {@link #getValueStream}.          *           * @return the length of the value. Does not require          *         isValueLengthKnown() to be true.          * @throws IOException          *           */
DECL|method|getValue (byte[] buf)
specifier|public
name|int
name|getValue
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getValue
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**          * Copy value into user-supplied buffer. User supplied buffer must be          * large enough to hold the whole value (starting from the offset). The          * value part of the key-value pair pointed by the current cursor is not          * cached and can only be examined once. Calling any of the following          * functions more than once without moving the cursor will result in          * exception: {@link #getValue(byte[])}, {@link #getValue(byte[], int)},          * {@link #getValueStream}.          *           * @return the length of the value. Does not require          *         isValueLengthKnown() to be true.          * @throws IOException          */
DECL|method|getValue (byte[] buf, int offset)
specifier|public
name|int
name|getValue
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|DataInputStream
name|dis
init|=
name|getValueStream
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isValueLengthKnown
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator||
operator|(
name|buf
operator|.
name|length
operator|-
name|offset
operator|-
name|vlen
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Buffer too small to hold value"
argument_list|)
throw|;
block|}
name|dis
operator|.
name|readFully
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
return|return
name|vlen
return|;
block|}
name|int
name|nextOffset
init|=
name|offset
decl_stmt|;
while|while
condition|(
name|nextOffset
operator|<
name|buf
operator|.
name|length
condition|)
block|{
name|int
name|n
init|=
name|dis
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|nextOffset
argument_list|,
name|buf
operator|.
name|length
operator|-
name|nextOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|nextOffset
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|dis
operator|.
name|read
argument_list|()
operator|>=
literal|0
condition|)
block|{
comment|// attempt to read one more byte to determine whether we reached
comment|// the
comment|// end or not.
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Buffer too small to hold value"
argument_list|)
throw|;
block|}
return|return
name|nextOffset
operator|-
name|offset
return|;
block|}
finally|finally
block|{
name|dis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Stream access to value. The value part of the key-value pair pointed          * by the current cursor is not cached and can only be examined once.          * Calling any of the following functions more than once without moving          * the cursor will result in exception: {@link #getValue(byte[])},          * {@link #getValue(byte[], int)}, {@link #getValueStream}.          *           * @return The input stream for reading the value.          * @throws IOException          */
DECL|method|getValueStream ()
specifier|public
name|DataInputStream
name|getValueStream
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|valueChecked
operator|==
literal|true
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Attempt to examine value multiple times."
argument_list|)
throw|;
block|}
name|valueChecked
operator|=
literal|true
expr_stmt|;
return|return
name|valueDataInputStream
return|;
block|}
comment|/**          * Check whether it is safe to call getValueLength().          *           * @return true if value length is known before hand. Values less than          *         the chunk size will always have their lengths known before          *         hand. Values that are written out as a whole (with advertised          *         length up-front) will always have their lengths known in          *         read.          */
DECL|method|isValueLengthKnown ()
specifier|public
name|boolean
name|isValueLengthKnown
parameter_list|()
block|{
return|return
operator|(
name|vlen
operator|>=
literal|0
operator|)
return|;
block|}
comment|/**          * Compare the entry key to another key. Synonymous to compareTo(key, 0,          * key.length).          *           * @param buf          *          The key buffer.          * @return comparison result between the entry key with the input key.          */
DECL|method|compareTo (byte[] buf)
specifier|public
name|int
name|compareTo
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
block|{
return|return
name|compareTo
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**          * Compare the entry key to another key. Synonymous to compareTo(new          * ByteArray(buf, offset, length)          *           * @param buf          *          The key buffer          * @param offset          *          offset into the key buffer.          * @param length          *          the length of the key.          * @return comparison result between the entry key with the input key.          */
DECL|method|compareTo (byte[] buf, int offset, int length)
specifier|public
name|int
name|compareTo
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|compareTo
argument_list|(
operator|new
name|ByteArray
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Compare an entry with a RawComparable object. This is useful when          * Entries are stored in a collection, and we want to compare a user          * supplied key.          */
annotation|@
name|Override
DECL|method|compareTo (RawComparable key)
specifier|public
name|int
name|compareTo
parameter_list|(
name|RawComparable
name|key
parameter_list|)
block|{
return|return
name|reader
operator|.
name|compareKeys
argument_list|(
name|keyBuffer
argument_list|,
literal|0
argument_list|,
name|getKeyLength
argument_list|()
argument_list|,
name|key
operator|.
name|buffer
argument_list|()
argument_list|,
name|key
operator|.
name|offset
argument_list|()
argument_list|,
name|key
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**          * Compare whether this and other points to the same key value.          */
annotation|@
name|Override
DECL|method|equals (Object other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|other
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|Entry
operator|)
condition|)
return|return
literal|false
return|;
return|return
operator|(
operator|(
name|Entry
operator|)
name|other
operator|)
operator|.
name|compareTo
argument_list|(
name|keyBuffer
argument_list|,
literal|0
argument_list|,
name|getKeyLength
argument_list|()
argument_list|)
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|WritableComparator
operator|.
name|hashBytes
argument_list|(
name|keyBuffer
argument_list|,
literal|0
argument_list|,
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**        * Advance cursor by n positions within the block.        *         * @param n        *          Number of key-value pairs to skip in block.        * @throws IOException        */
DECL|method|inBlockAdvance (long n)
specifier|private
name|void
name|inBlockAdvance
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|checkKey
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|valueBufferInputStream
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|valueBufferInputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|klen
operator|=
operator|-
literal|1
expr_stmt|;
name|currentLocation
operator|.
name|incRecordIndex
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**        * Advance cursor in block until we find a key that is greater than or        * equal to the input key.        *         * @param key        *          Key to compare.        * @param greater        *          advance until we find a key greater than the input key.        * @return true if we find a equal key.        * @throws IOException        */
DECL|method|inBlockAdvance (RawComparable key, boolean greater)
specifier|private
name|boolean
name|inBlockAdvance
parameter_list|(
name|RawComparable
name|key
parameter_list|,
name|boolean
name|greater
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|curBid
init|=
name|currentLocation
operator|.
name|getBlockIndex
argument_list|()
decl_stmt|;
name|long
name|entryInBlock
init|=
name|reader
operator|.
name|getBlockEntryCount
argument_list|(
name|curBid
argument_list|)
decl_stmt|;
if|if
condition|(
name|curBid
operator|==
name|endLocation
operator|.
name|getBlockIndex
argument_list|()
condition|)
block|{
name|entryInBlock
operator|=
name|endLocation
operator|.
name|getRecordIndex
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|currentLocation
operator|.
name|getRecordIndex
argument_list|()
operator|<
name|entryInBlock
condition|)
block|{
name|int
name|cmp
init|=
name|compareCursorKeyTo
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|cmp
operator|==
literal|0
operator|&&
operator|!
name|greater
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|valueBufferInputStream
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|valueBufferInputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|klen
operator|=
operator|-
literal|1
expr_stmt|;
name|currentLocation
operator|.
name|incRecordIndex
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot find matching key in block."
argument_list|)
throw|;
block|}
block|}
DECL|method|getBlockEntryCount (int curBid)
name|long
name|getBlockEntryCount
parameter_list|(
name|int
name|curBid
parameter_list|)
block|{
return|return
name|tfileIndex
operator|.
name|getEntry
argument_list|(
name|curBid
argument_list|)
operator|.
name|entries
argument_list|()
return|;
block|}
DECL|method|getBlockReader (int blockIndex)
name|BlockReader
name|getBlockReader
parameter_list|(
name|int
name|blockIndex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readerBCF
operator|.
name|getDataBlock
argument_list|(
name|blockIndex
argument_list|)
return|;
block|}
block|}
comment|/**    * Data structure representing "TFile.meta" meta block.    */
DECL|class|TFileMeta
specifier|static
specifier|final
class|class
name|TFileMeta
block|{
DECL|field|BLOCK_NAME
specifier|final
specifier|static
name|String
name|BLOCK_NAME
init|=
literal|"TFile.meta"
decl_stmt|;
DECL|field|version
specifier|final
name|Version
name|version
decl_stmt|;
DECL|field|recordCount
specifier|private
name|long
name|recordCount
decl_stmt|;
DECL|field|strComparator
specifier|private
specifier|final
name|String
name|strComparator
decl_stmt|;
DECL|field|comparator
specifier|private
specifier|final
name|BytesComparator
name|comparator
decl_stmt|;
comment|// ctor for writes
DECL|method|TFileMeta (String comparator)
specifier|public
name|TFileMeta
parameter_list|(
name|String
name|comparator
parameter_list|)
block|{
comment|// set fileVersion to API version when we create it.
name|version
operator|=
name|TFile
operator|.
name|API_VERSION
expr_stmt|;
name|recordCount
operator|=
literal|0
expr_stmt|;
name|strComparator
operator|=
operator|(
name|comparator
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
name|comparator
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|makeComparator
argument_list|(
name|strComparator
argument_list|)
expr_stmt|;
block|}
comment|// ctor for reads
DECL|method|TFileMeta (DataInput in)
specifier|public
name|TFileMeta
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|version
operator|=
operator|new
name|Version
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|version
operator|.
name|compatibleWith
argument_list|(
name|TFile
operator|.
name|API_VERSION
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Incompatible TFile fileVersion."
argument_list|)
throw|;
block|}
name|recordCount
operator|=
name|Utils
operator|.
name|readVLong
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|strComparator
operator|=
name|Utils
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|comparator
operator|=
name|makeComparator
argument_list|(
name|strComparator
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|makeComparator (String comparator)
specifier|static
name|BytesComparator
name|makeComparator
parameter_list|(
name|String
name|comparator
parameter_list|)
block|{
if|if
condition|(
name|comparator
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// unsorted keys
return|return
literal|null
return|;
block|}
if|if
condition|(
name|comparator
operator|.
name|equals
argument_list|(
name|COMPARATOR_MEMCMP
argument_list|)
condition|)
block|{
comment|// default comparator
return|return
operator|new
name|BytesComparator
argument_list|(
operator|new
name|MemcmpRawComparator
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|comparator
operator|.
name|startsWith
argument_list|(
name|COMPARATOR_JCLASS
argument_list|)
condition|)
block|{
name|String
name|compClassName
init|=
name|comparator
operator|.
name|substring
argument_list|(
name|COMPARATOR_JCLASS
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
try|try
block|{
name|Class
name|compClass
init|=
name|Class
operator|.
name|forName
argument_list|(
name|compClassName
argument_list|)
decl_stmt|;
comment|// use its default ctor to create an instance
return|return
operator|new
name|BytesComparator
argument_list|(
operator|(
name|RawComparator
argument_list|<
name|Object
argument_list|>
operator|)
name|compClass
operator|.
name|newInstance
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Failed to instantiate comparator: "
operator|+
name|comparator
operator|+
literal|"("
operator|+
name|e
operator|.
name|toString
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unsupported comparator: "
operator|+
name|comparator
argument_list|)
throw|;
block|}
block|}
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|TFile
operator|.
name|API_VERSION
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|Utils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|recordCount
argument_list|)
expr_stmt|;
name|Utils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|strComparator
argument_list|)
expr_stmt|;
block|}
DECL|method|getRecordCount ()
specifier|public
name|long
name|getRecordCount
parameter_list|()
block|{
return|return
name|recordCount
return|;
block|}
DECL|method|incRecordCount ()
specifier|public
name|void
name|incRecordCount
parameter_list|()
block|{
operator|++
name|recordCount
expr_stmt|;
block|}
DECL|method|isSorted ()
specifier|public
name|boolean
name|isSorted
parameter_list|()
block|{
return|return
operator|!
name|strComparator
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|getComparatorString ()
specifier|public
name|String
name|getComparatorString
parameter_list|()
block|{
return|return
name|strComparator
return|;
block|}
DECL|method|getComparator ()
specifier|public
name|BytesComparator
name|getComparator
parameter_list|()
block|{
return|return
name|comparator
return|;
block|}
DECL|method|getVersion ()
specifier|public
name|Version
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
block|}
comment|// END: class MetaTFileMeta
comment|/**    * Data structure representing "TFile.index" meta block.    */
DECL|class|TFileIndex
specifier|static
class|class
name|TFileIndex
block|{
DECL|field|BLOCK_NAME
specifier|final
specifier|static
name|String
name|BLOCK_NAME
init|=
literal|"TFile.index"
decl_stmt|;
DECL|field|firstKey
specifier|private
name|ByteArray
name|firstKey
decl_stmt|;
DECL|field|index
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|TFileIndexEntry
argument_list|>
name|index
decl_stmt|;
DECL|field|recordNumIndex
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|Long
argument_list|>
name|recordNumIndex
decl_stmt|;
DECL|field|comparator
specifier|private
specifier|final
name|BytesComparator
name|comparator
decl_stmt|;
DECL|field|sum
specifier|private
name|long
name|sum
init|=
literal|0
decl_stmt|;
comment|/**      * For reading from file.      *       * @throws IOException      */
DECL|method|TFileIndex (int entryCount, DataInput in, BytesComparator comparator)
specifier|public
name|TFileIndex
parameter_list|(
name|int
name|entryCount
parameter_list|,
name|DataInput
name|in
parameter_list|,
name|BytesComparator
name|comparator
parameter_list|)
throws|throws
name|IOException
block|{
name|index
operator|=
operator|new
name|ArrayList
argument_list|<
name|TFileIndexEntry
argument_list|>
argument_list|(
name|entryCount
argument_list|)
expr_stmt|;
name|recordNumIndex
operator|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|(
name|entryCount
argument_list|)
expr_stmt|;
name|int
name|size
init|=
name|Utils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
comment|// size for the first key entry.
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|DataInputStream
name|firstKeyInputStream
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|firstKeyLength
init|=
name|Utils
operator|.
name|readVInt
argument_list|(
name|firstKeyInputStream
argument_list|)
decl_stmt|;
name|firstKey
operator|=
operator|new
name|ByteArray
argument_list|(
operator|new
name|byte
index|[
name|firstKeyLength
index|]
argument_list|)
expr_stmt|;
name|firstKeyInputStream
operator|.
name|readFully
argument_list|(
name|firstKey
operator|.
name|buffer
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entryCount
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|Utils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|length
operator|<
name|size
condition|)
block|{
name|buffer
operator|=
operator|new
name|byte
index|[
name|size
index|]
expr_stmt|;
block|}
name|in
operator|.
name|readFully
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|TFileIndexEntry
name|idx
init|=
operator|new
name|TFileIndexEntry
argument_list|(
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|index
operator|.
name|add
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|idx
operator|.
name|entries
argument_list|()
expr_stmt|;
name|recordNumIndex
operator|.
name|add
argument_list|(
name|sum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|entryCount
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Internal error"
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
block|}
comment|/**      * @param key      *          input key.      * @return the ID of the first block that contains key>= input key. Or -1      *         if no such block exists.      */
DECL|method|lowerBound (RawComparable key)
specifier|public
name|int
name|lowerBound
parameter_list|(
name|RawComparable
name|key
parameter_list|)
block|{
if|if
condition|(
name|comparator
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot search in unsorted TFile"
argument_list|)
throw|;
block|}
if|if
condition|(
name|firstKey
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// not found
block|}
name|int
name|ret
init|=
name|Utils
operator|.
name|lowerBound
argument_list|(
name|index
argument_list|,
name|key
argument_list|,
name|comparator
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|index
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * @param key      *          input key.      * @return the ID of the first block that contains key> input key. Or -1      *         if no such block exists.      */
DECL|method|upperBound (RawComparable key)
specifier|public
name|int
name|upperBound
parameter_list|(
name|RawComparable
name|key
parameter_list|)
block|{
if|if
condition|(
name|comparator
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot search in unsorted TFile"
argument_list|)
throw|;
block|}
if|if
condition|(
name|firstKey
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// not found
block|}
name|int
name|ret
init|=
name|Utils
operator|.
name|upperBound
argument_list|(
name|index
argument_list|,
name|key
argument_list|,
name|comparator
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|index
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * For writing to file.      */
DECL|method|TFileIndex (BytesComparator comparator)
specifier|public
name|TFileIndex
parameter_list|(
name|BytesComparator
name|comparator
parameter_list|)
block|{
name|index
operator|=
operator|new
name|ArrayList
argument_list|<
name|TFileIndexEntry
argument_list|>
argument_list|()
expr_stmt|;
name|recordNumIndex
operator|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
block|}
DECL|method|getFirstKey ()
specifier|public
name|RawComparable
name|getFirstKey
parameter_list|()
block|{
return|return
name|firstKey
return|;
block|}
DECL|method|getLocationByRecordNum (long recNum)
specifier|public
name|Reader
operator|.
name|Location
name|getLocationByRecordNum
parameter_list|(
name|long
name|recNum
parameter_list|)
block|{
name|int
name|idx
init|=
name|Utils
operator|.
name|upperBound
argument_list|(
name|recordNumIndex
argument_list|,
name|recNum
argument_list|)
decl_stmt|;
name|long
name|lastRecNum
init|=
operator|(
name|idx
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|recordNumIndex
operator|.
name|get
argument_list|(
name|idx
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
operator|new
name|Reader
operator|.
name|Location
argument_list|(
name|idx
argument_list|,
name|recNum
operator|-
name|lastRecNum
argument_list|)
return|;
block|}
DECL|method|getRecordNumByLocation (Reader.Location location)
specifier|public
name|long
name|getRecordNumByLocation
parameter_list|(
name|Reader
operator|.
name|Location
name|location
parameter_list|)
block|{
name|int
name|blkIndex
init|=
name|location
operator|.
name|getBlockIndex
argument_list|()
decl_stmt|;
name|long
name|lastRecNum
init|=
operator|(
name|blkIndex
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|recordNumIndex
operator|.
name|get
argument_list|(
name|blkIndex
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|lastRecNum
operator|+
name|location
operator|.
name|getRecordIndex
argument_list|()
return|;
block|}
DECL|method|setFirstKey (byte[] key, int offset, int length)
specifier|public
name|void
name|setFirstKey
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|firstKey
operator|=
operator|new
name|ByteArray
argument_list|(
operator|new
name|byte
index|[
name|length
index|]
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|firstKey
operator|.
name|buffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|getLastKey ()
specifier|public
name|RawComparable
name|getLastKey
parameter_list|()
block|{
if|if
condition|(
name|index
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ByteArray
argument_list|(
name|index
operator|.
name|get
argument_list|(
name|index
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|buffer
argument_list|()
argument_list|)
return|;
block|}
DECL|method|addEntry (TFileIndexEntry keyEntry)
specifier|public
name|void
name|addEntry
parameter_list|(
name|TFileIndexEntry
name|keyEntry
parameter_list|)
block|{
name|index
operator|.
name|add
argument_list|(
name|keyEntry
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|keyEntry
operator|.
name|entries
argument_list|()
expr_stmt|;
name|recordNumIndex
operator|.
name|add
argument_list|(
name|sum
argument_list|)
expr_stmt|;
block|}
DECL|method|getEntry (int bid)
specifier|public
name|TFileIndexEntry
name|getEntry
parameter_list|(
name|int
name|bid
parameter_list|)
block|{
return|return
name|index
operator|.
name|get
argument_list|(
name|bid
argument_list|)
return|;
block|}
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|firstKey
operator|==
literal|null
condition|)
block|{
name|Utils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|DataOutputBuffer
name|dob
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
name|Utils
operator|.
name|writeVInt
argument_list|(
name|dob
argument_list|,
name|firstKey
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|dob
operator|.
name|write
argument_list|(
name|firstKey
operator|.
name|buffer
argument_list|()
argument_list|)
expr_stmt|;
name|Utils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|dob
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|dob
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dob
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|TFileIndexEntry
name|entry
range|:
name|index
control|)
block|{
name|dob
operator|.
name|reset
argument_list|()
expr_stmt|;
name|entry
operator|.
name|write
argument_list|(
name|dob
argument_list|)
expr_stmt|;
name|Utils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|dob
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|dob
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dob
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * TFile Data Index entry. We should try to make the memory footprint of each    * index entry as small as possible.    */
DECL|class|TFileIndexEntry
specifier|static
specifier|final
class|class
name|TFileIndexEntry
implements|implements
name|RawComparable
block|{
DECL|field|key
specifier|final
name|byte
index|[]
name|key
decl_stmt|;
comment|// count of<key, value> entries in the block.
DECL|field|kvEntries
specifier|final
name|long
name|kvEntries
decl_stmt|;
DECL|method|TFileIndexEntry (DataInput in)
specifier|public
name|TFileIndexEntry
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
init|=
name|Utils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|key
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|kvEntries
operator|=
name|Utils
operator|.
name|readVLong
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|// default entry, without any padding
DECL|method|TFileIndexEntry (byte[] newkey, int offset, int len, long entries)
specifier|public
name|TFileIndexEntry
parameter_list|(
name|byte
index|[]
name|newkey
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|long
name|entries
parameter_list|)
block|{
name|key
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|newkey
argument_list|,
name|offset
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|this
operator|.
name|kvEntries
operator|=
name|entries
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|buffer ()
specifier|public
name|byte
index|[]
name|buffer
parameter_list|()
block|{
return|return
name|key
return|;
block|}
annotation|@
name|Override
DECL|method|offset ()
specifier|public
name|int
name|offset
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|key
operator|.
name|length
return|;
block|}
DECL|method|entries ()
name|long
name|entries
parameter_list|()
block|{
return|return
name|kvEntries
return|;
block|}
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|Utils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|key
operator|.
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
expr_stmt|;
name|Utils
operator|.
name|writeVLong
argument_list|(
name|out
argument_list|,
name|kvEntries
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Dumping the TFile information.    *     * @param args    *          A list of TFile paths.    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"TFile Dumper (TFile %s, BCFile %s)%n"
argument_list|,
name|TFile
operator|.
name|API_VERSION
operator|.
name|toString
argument_list|()
argument_list|,
name|BCFile
operator|.
name|API_VERSION
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage: java ... org.apache.hadoop.io.file.tfile.TFile tfile-path [tfile-path ...]"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|args
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"==="
operator|+
name|file
operator|+
literal|"==="
argument_list|)
expr_stmt|;
try|try
block|{
name|TFileDumper
operator|.
name|dumpInfo
argument_list|(
name|file
argument_list|,
name|System
operator|.
name|out
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

