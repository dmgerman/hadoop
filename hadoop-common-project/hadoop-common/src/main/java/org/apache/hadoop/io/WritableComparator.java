begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_comment
comment|/** A Comparator for {@link WritableComparable}s.  *  *<p>This base implemenation uses the natural ordering.  To define alternate  * orderings, override {@link #compare(WritableComparable,WritableComparable)}.  *  *<p>One may optimize compare-intensive operations by overriding  * {@link #compare(byte[],int,int,byte[],int,int)}.  Static utility methods are  * provided to assist in optimized implementations of this method.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|WritableComparator
specifier|public
class|class
name|WritableComparator
implements|implements
name|RawComparator
block|{
DECL|field|comparators
specifier|private
specifier|static
name|HashMap
argument_list|<
name|Class
argument_list|,
name|WritableComparator
argument_list|>
name|comparators
init|=
operator|new
name|HashMap
argument_list|<
name|Class
argument_list|,
name|WritableComparator
argument_list|>
argument_list|()
decl_stmt|;
comment|// registry
comment|/** Get a comparator for a {@link WritableComparable} implementation. */
specifier|public
specifier|static
specifier|synchronized
DECL|method|get (Class<? extends WritableComparable> c)
name|WritableComparator
name|get
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|WritableComparable
argument_list|>
name|c
parameter_list|)
block|{
name|WritableComparator
name|comparator
init|=
name|comparators
operator|.
name|get
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|comparator
operator|==
literal|null
condition|)
block|{
comment|// force the static initializers to run
name|forceInit
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// look to see if it is defined now
name|comparator
operator|=
name|comparators
operator|.
name|get
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// if not, use the generic one
if|if
condition|(
name|comparator
operator|==
literal|null
condition|)
block|{
name|comparator
operator|=
operator|new
name|WritableComparator
argument_list|(
name|c
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|comparator
return|;
block|}
comment|/**    * Force initialization of the static members.    * As of Java 5, referencing a class doesn't force it to initialize. Since    * this class requires that the classes be initialized to declare their    * comparators, we force that initialization to happen.    * @param cls the class to initialize    */
DECL|method|forceInit (Class<?> cls)
specifier|private
specifier|static
name|void
name|forceInit
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cls
parameter_list|)
block|{
try|try
block|{
name|Class
operator|.
name|forName
argument_list|(
name|cls
operator|.
name|getName
argument_list|()
argument_list|,
literal|true
argument_list|,
name|cls
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't initialize class "
operator|+
name|cls
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Register an optimized comparator for a {@link WritableComparable}    * implementation. Comparators registered with this method must be    * thread-safe. */
DECL|method|define (Class c, WritableComparator comparator)
specifier|public
specifier|static
specifier|synchronized
name|void
name|define
parameter_list|(
name|Class
name|c
parameter_list|,
name|WritableComparator
name|comparator
parameter_list|)
block|{
name|comparators
operator|.
name|put
argument_list|(
name|c
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
DECL|field|keyClass
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|WritableComparable
argument_list|>
name|keyClass
decl_stmt|;
DECL|field|key1
specifier|private
specifier|final
name|WritableComparable
name|key1
decl_stmt|;
DECL|field|key2
specifier|private
specifier|final
name|WritableComparable
name|key2
decl_stmt|;
DECL|field|buffer
specifier|private
specifier|final
name|DataInputBuffer
name|buffer
decl_stmt|;
comment|/** Construct for a {@link WritableComparable} implementation. */
DECL|method|WritableComparator (Class<? extends WritableComparable> keyClass)
specifier|protected
name|WritableComparator
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|WritableComparable
argument_list|>
name|keyClass
parameter_list|)
block|{
name|this
argument_list|(
name|keyClass
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|WritableComparator (Class<? extends WritableComparable> keyClass, boolean createInstances)
specifier|protected
name|WritableComparator
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|WritableComparable
argument_list|>
name|keyClass
parameter_list|,
name|boolean
name|createInstances
parameter_list|)
block|{
name|this
operator|.
name|keyClass
operator|=
name|keyClass
expr_stmt|;
if|if
condition|(
name|createInstances
condition|)
block|{
name|key1
operator|=
name|newKey
argument_list|()
expr_stmt|;
name|key2
operator|=
name|newKey
argument_list|()
expr_stmt|;
name|buffer
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|key1
operator|=
name|key2
operator|=
literal|null
expr_stmt|;
name|buffer
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/** Returns the WritableComparable implementation class. */
DECL|method|getKeyClass ()
specifier|public
name|Class
argument_list|<
name|?
extends|extends
name|WritableComparable
argument_list|>
name|getKeyClass
parameter_list|()
block|{
return|return
name|keyClass
return|;
block|}
comment|/** Construct a new {@link WritableComparable} instance. */
DECL|method|newKey ()
specifier|public
name|WritableComparable
name|newKey
parameter_list|()
block|{
return|return
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|keyClass
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Optimization hook.  Override this to make SequenceFile.Sorter's scream.    *    *<p>The default implementation reads the data into two {@link    * WritableComparable}s (using {@link    * Writable#readFields(DataInput)}, then calls {@link    * #compare(WritableComparable,WritableComparable)}.    */
DECL|method|compare (byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
specifier|public
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|b1
parameter_list|,
name|int
name|s1
parameter_list|,
name|int
name|l1
parameter_list|,
name|byte
index|[]
name|b2
parameter_list|,
name|int
name|s2
parameter_list|,
name|int
name|l2
parameter_list|)
block|{
try|try
block|{
name|buffer
operator|.
name|reset
argument_list|(
name|b1
argument_list|,
name|s1
argument_list|,
name|l1
argument_list|)
expr_stmt|;
comment|// parse key1
name|key1
operator|.
name|readFields
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|reset
argument_list|(
name|b2
argument_list|,
name|s2
argument_list|,
name|l2
argument_list|)
expr_stmt|;
comment|// parse key2
name|key2
operator|.
name|readFields
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|compare
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|)
return|;
comment|// compare them
block|}
comment|/** Compare two WritableComparables.    *    *<p> The default implementation uses the natural ordering, calling {@link    * Comparable#compareTo(Object)}. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|compare (WritableComparable a, WritableComparable b)
specifier|public
name|int
name|compare
parameter_list|(
name|WritableComparable
name|a
parameter_list|,
name|WritableComparable
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
return|;
block|}
DECL|method|compare (Object a, Object b)
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|compare
argument_list|(
operator|(
name|WritableComparable
operator|)
name|a
argument_list|,
operator|(
name|WritableComparable
operator|)
name|b
argument_list|)
return|;
block|}
comment|/** Lexicographic order of binary data. */
DECL|method|compareBytes (byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
specifier|public
specifier|static
name|int
name|compareBytes
parameter_list|(
name|byte
index|[]
name|b1
parameter_list|,
name|int
name|s1
parameter_list|,
name|int
name|l1
parameter_list|,
name|byte
index|[]
name|b2
parameter_list|,
name|int
name|s2
parameter_list|,
name|int
name|l2
parameter_list|)
block|{
return|return
name|FastByteComparisons
operator|.
name|compareTo
argument_list|(
name|b1
argument_list|,
name|s1
argument_list|,
name|l1
argument_list|,
name|b2
argument_list|,
name|s2
argument_list|,
name|l2
argument_list|)
return|;
block|}
comment|/** Compute hash for binary data. */
DECL|method|hashBytes (byte[] bytes, int offset, int length)
specifier|public
specifier|static
name|int
name|hashBytes
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|hash
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|offset
operator|+
name|length
condition|;
name|i
operator|++
control|)
name|hash
operator|=
operator|(
literal|31
operator|*
name|hash
operator|)
operator|+
operator|(
name|int
operator|)
name|bytes
index|[
name|i
index|]
expr_stmt|;
return|return
name|hash
return|;
block|}
comment|/** Compute hash for binary data. */
DECL|method|hashBytes (byte[] bytes, int length)
specifier|public
specifier|static
name|int
name|hashBytes
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|hashBytes
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/** Parse an unsigned short from a byte array. */
DECL|method|readUnsignedShort (byte[] bytes, int start)
specifier|public
specifier|static
name|int
name|readUnsignedShort
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|bytes
index|[
name|start
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|bytes
index|[
name|start
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|)
return|;
block|}
comment|/** Parse an integer from a byte array. */
DECL|method|readInt (byte[] bytes, int start)
specifier|public
specifier|static
name|int
name|readInt
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|bytes
index|[
name|start
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|bytes
index|[
name|start
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|bytes
index|[
name|start
operator|+
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|bytes
index|[
name|start
operator|+
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|)
return|;
block|}
comment|/** Parse a float from a byte array. */
DECL|method|readFloat (byte[] bytes, int start)
specifier|public
specifier|static
name|float
name|readFloat
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
block|{
return|return
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|readInt
argument_list|(
name|bytes
argument_list|,
name|start
argument_list|)
argument_list|)
return|;
block|}
comment|/** Parse a long from a byte array. */
DECL|method|readLong (byte[] bytes, int start)
specifier|public
specifier|static
name|long
name|readLong
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
block|{
return|return
operator|(
call|(
name|long
call|)
argument_list|(
name|readInt
argument_list|(
name|bytes
argument_list|,
name|start
argument_list|)
argument_list|)
operator|<<
literal|32
operator|)
operator|+
operator|(
name|readInt
argument_list|(
name|bytes
argument_list|,
name|start
operator|+
literal|4
argument_list|)
operator|&
literal|0xFFFFFFFFL
operator|)
return|;
block|}
comment|/** Parse a double from a byte array. */
DECL|method|readDouble (byte[] bytes, int start)
specifier|public
specifier|static
name|double
name|readDouble
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|readLong
argument_list|(
name|bytes
argument_list|,
name|start
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Reads a zero-compressed encoded long from a byte array and returns it.    * @param bytes byte array with decode long    * @param start starting index    * @throws java.io.IOException     * @return deserialized long    */
DECL|method|readVLong (byte[] bytes, int start)
specifier|public
specifier|static
name|long
name|readVLong
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
init|=
name|bytes
index|[
name|start
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|>=
operator|-
literal|112
condition|)
block|{
return|return
name|len
return|;
block|}
name|boolean
name|isNegative
init|=
operator|(
name|len
operator|<
operator|-
literal|120
operator|)
decl_stmt|;
name|len
operator|=
name|isNegative
condition|?
operator|-
operator|(
name|len
operator|+
literal|120
operator|)
else|:
operator|-
operator|(
name|len
operator|+
literal|112
operator|)
expr_stmt|;
if|if
condition|(
name|start
operator|+
literal|1
operator|+
name|len
operator|>
name|bytes
operator|.
name|length
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not enough number of bytes for a zero-compressed integer"
argument_list|)
throw|;
name|long
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|len
condition|;
name|idx
operator|++
control|)
block|{
name|i
operator|=
name|i
operator|<<
literal|8
expr_stmt|;
name|i
operator|=
name|i
operator||
operator|(
name|bytes
index|[
name|start
operator|+
literal|1
operator|+
name|idx
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|isNegative
condition|?
operator|(
name|i
operator|^
operator|-
literal|1L
operator|)
else|:
name|i
operator|)
return|;
block|}
comment|/**    * Reads a zero-compressed encoded integer from a byte array and returns it.    * @param bytes byte array with the encoded integer    * @param start start index    * @throws java.io.IOException     * @return deserialized integer    */
DECL|method|readVInt (byte[] bytes, int start)
specifier|public
specifier|static
name|int
name|readVInt
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|start
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
name|int
operator|)
name|readVLong
argument_list|(
name|bytes
argument_list|,
name|start
argument_list|)
return|;
block|}
block|}
end_class

end_unit

