begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_comment
comment|/****************************************************************  * Abstract Checksumed FileSystem.  * It provide a basic implementation of a Checksumed FileSystem,  * which creates a checksum file for each raw file.  * It generates& verifies checksums at the client side.  *  *****************************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|ChecksumFileSystem
specifier|public
specifier|abstract
class|class
name|ChecksumFileSystem
extends|extends
name|FilterFileSystem
block|{
DECL|field|CHECKSUM_VERSION
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|CHECKSUM_VERSION
init|=
operator|new
name|byte
index|[]
block|{
literal|'c'
block|,
literal|'r'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
DECL|field|bytesPerChecksum
specifier|private
name|int
name|bytesPerChecksum
init|=
literal|512
decl_stmt|;
DECL|field|verifyChecksum
specifier|private
name|boolean
name|verifyChecksum
init|=
literal|true
decl_stmt|;
DECL|field|writeChecksum
specifier|private
name|boolean
name|writeChecksum
init|=
literal|true
decl_stmt|;
DECL|method|getApproxChkSumLength (long size)
specifier|public
specifier|static
name|double
name|getApproxChkSumLength
parameter_list|(
name|long
name|size
parameter_list|)
block|{
return|return
name|ChecksumFSOutputSummer
operator|.
name|CHKSUM_AS_FRACTION
operator|*
name|size
return|;
block|}
DECL|method|ChecksumFileSystem (FileSystem fs)
specifier|public
name|ChecksumFileSystem
parameter_list|(
name|FileSystem
name|fs
parameter_list|)
block|{
name|super
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setConf (Configuration conf)
specifier|public
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
name|bytesPerChecksum
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|LocalFileSystemConfigKeys
operator|.
name|LOCAL_FS_BYTES_PER_CHECKSUM_KEY
argument_list|,
name|LocalFileSystemConfigKeys
operator|.
name|LOCAL_FS_BYTES_PER_CHECKSUM_DEFAULT
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|bytesPerChecksum
operator|>
literal|0
argument_list|,
literal|"bytes per checksum should be positive but was %s"
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set whether to verify checksum.    */
annotation|@
name|Override
DECL|method|setVerifyChecksum (boolean verifyChecksum)
specifier|public
name|void
name|setVerifyChecksum
parameter_list|(
name|boolean
name|verifyChecksum
parameter_list|)
block|{
name|this
operator|.
name|verifyChecksum
operator|=
name|verifyChecksum
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setWriteChecksum (boolean writeChecksum)
specifier|public
name|void
name|setWriteChecksum
parameter_list|(
name|boolean
name|writeChecksum
parameter_list|)
block|{
name|this
operator|.
name|writeChecksum
operator|=
name|writeChecksum
expr_stmt|;
block|}
comment|/** get the raw file system */
annotation|@
name|Override
DECL|method|getRawFileSystem ()
specifier|public
name|FileSystem
name|getRawFileSystem
parameter_list|()
block|{
return|return
name|fs
return|;
block|}
comment|/** Return the name of the checksum file associated with a file.*/
DECL|method|getChecksumFile (Path file)
specifier|public
name|Path
name|getChecksumFile
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|file
operator|.
name|getParent
argument_list|()
argument_list|,
literal|"."
operator|+
name|file
operator|.
name|getName
argument_list|()
operator|+
literal|".crc"
argument_list|)
return|;
block|}
comment|/** Return true iff file is a checksum file name.*/
DECL|method|isChecksumFile (Path file)
specifier|public
specifier|static
name|boolean
name|isChecksumFile
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
name|String
name|name
init|=
name|file
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
name|name
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
literal|".crc"
argument_list|)
return|;
block|}
comment|/** Return the length of the checksum file given the size of the     * actual file.    **/
DECL|method|getChecksumFileLength (Path file, long fileSize)
specifier|public
name|long
name|getChecksumFileLength
parameter_list|(
name|Path
name|file
parameter_list|,
name|long
name|fileSize
parameter_list|)
block|{
return|return
name|getChecksumLength
argument_list|(
name|fileSize
argument_list|,
name|getBytesPerSum
argument_list|()
argument_list|)
return|;
block|}
comment|/** Return the bytes Per Checksum */
DECL|method|getBytesPerSum ()
specifier|public
name|int
name|getBytesPerSum
parameter_list|()
block|{
return|return
name|bytesPerChecksum
return|;
block|}
DECL|method|getSumBufferSize (int bytesPerSum, int bufferSize)
specifier|private
name|int
name|getSumBufferSize
parameter_list|(
name|int
name|bytesPerSum
parameter_list|,
name|int
name|bufferSize
parameter_list|)
block|{
name|int
name|defaultBufferSize
init|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|LocalFileSystemConfigKeys
operator|.
name|LOCAL_FS_STREAM_BUFFER_SIZE_KEY
argument_list|,
name|LocalFileSystemConfigKeys
operator|.
name|LOCAL_FS_STREAM_BUFFER_SIZE_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|proportionalBufferSize
init|=
name|bufferSize
operator|/
name|bytesPerSum
decl_stmt|;
return|return
name|Math
operator|.
name|max
argument_list|(
name|bytesPerSum
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|proportionalBufferSize
argument_list|,
name|defaultBufferSize
argument_list|)
argument_list|)
return|;
block|}
comment|/*******************************************************    * For open()'s FSInputStream    * It verifies that data matches checksums.    *******************************************************/
DECL|class|ChecksumFSInputChecker
specifier|private
specifier|static
class|class
name|ChecksumFSInputChecker
extends|extends
name|FSInputChecker
block|{
DECL|field|fs
specifier|private
name|ChecksumFileSystem
name|fs
decl_stmt|;
DECL|field|datas
specifier|private
name|FSDataInputStream
name|datas
decl_stmt|;
DECL|field|sums
specifier|private
name|FSDataInputStream
name|sums
decl_stmt|;
DECL|field|HEADER_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|HEADER_LENGTH
init|=
literal|8
decl_stmt|;
DECL|field|bytesPerSum
specifier|private
name|int
name|bytesPerSum
init|=
literal|1
decl_stmt|;
DECL|method|ChecksumFSInputChecker (ChecksumFileSystem fs, Path file)
specifier|public
name|ChecksumFSInputChecker
parameter_list|(
name|ChecksumFileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|LocalFileSystemConfigKeys
operator|.
name|LOCAL_FS_STREAM_BUFFER_SIZE_KEY
argument_list|,
name|LocalFileSystemConfigKeys
operator|.
name|LOCAL_FS_STREAM_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|ChecksumFSInputChecker (ChecksumFileSystem fs, Path file, int bufferSize)
specifier|public
name|ChecksumFSInputChecker
parameter_list|(
name|ChecksumFileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|file
argument_list|,
name|fs
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
operator|.
name|getReplication
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|datas
operator|=
name|fs
operator|.
name|getRawFileSystem
argument_list|()
operator|.
name|open
argument_list|(
name|file
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|Path
name|sumFile
init|=
name|fs
operator|.
name|getChecksumFile
argument_list|(
name|file
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|sumBufferSize
init|=
name|fs
operator|.
name|getSumBufferSize
argument_list|(
name|fs
operator|.
name|getBytesPerSum
argument_list|()
argument_list|,
name|bufferSize
argument_list|)
decl_stmt|;
name|sums
operator|=
name|fs
operator|.
name|getRawFileSystem
argument_list|()
operator|.
name|open
argument_list|(
name|sumFile
argument_list|,
name|sumBufferSize
argument_list|)
expr_stmt|;
name|byte
index|[]
name|version
init|=
operator|new
name|byte
index|[
name|CHECKSUM_VERSION
operator|.
name|length
index|]
decl_stmt|;
name|sums
operator|.
name|readFully
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|version
argument_list|,
name|CHECKSUM_VERSION
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not a checksum file: "
operator|+
name|sumFile
argument_list|)
throw|;
name|this
operator|.
name|bytesPerSum
operator|=
name|sums
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|set
argument_list|(
name|fs
operator|.
name|verifyChecksum
argument_list|,
name|DataChecksum
operator|.
name|newCrc32
argument_list|()
argument_list|,
name|bytesPerSum
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// mincing the message is terrible, but java throws permission
comment|// exceptions as FNF because that's all the method signatures allow!
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|FileNotFoundException
operator|)
operator|||
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|" (Permission denied)"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem opening checksum file: "
operator|+
name|file
operator|+
literal|".  Ignoring exception: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|set
argument_list|(
name|fs
operator|.
name|verifyChecksum
argument_list|,
literal|null
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getChecksumFilePos ( long dataPos )
specifier|private
name|long
name|getChecksumFilePos
parameter_list|(
name|long
name|dataPos
parameter_list|)
block|{
return|return
name|HEADER_LENGTH
operator|+
literal|4
operator|*
operator|(
name|dataPos
operator|/
name|bytesPerSum
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|getChunkPosition ( long dataPos )
specifier|protected
name|long
name|getChunkPosition
parameter_list|(
name|long
name|dataPos
parameter_list|)
block|{
return|return
name|dataPos
operator|/
name|bytesPerSum
operator|*
name|bytesPerSum
return|;
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|datas
operator|.
name|available
argument_list|()
operator|+
name|super
operator|.
name|available
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|read (long position, byte[] b, int off, int len)
specifier|public
name|int
name|read
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
comment|// parameter check
name|validatePositionedReadArgs
argument_list|(
name|position
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|nread
decl_stmt|;
try|try
init|(
name|ChecksumFSInputChecker
name|checker
init|=
operator|new
name|ChecksumFSInputChecker
argument_list|(
name|fs
argument_list|,
name|file
argument_list|)
init|)
block|{
name|checker
operator|.
name|seek
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|nread
operator|=
name|checker
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|nread
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|datas
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|sums
operator|!=
literal|null
condition|)
block|{
name|sums
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|set
argument_list|(
name|fs
operator|.
name|verifyChecksum
argument_list|,
literal|null
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|seekToNewSource (long targetPos)
specifier|public
name|boolean
name|seekToNewSource
parameter_list|(
name|long
name|targetPos
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|sumsPos
init|=
name|getChecksumFilePos
argument_list|(
name|targetPos
argument_list|)
decl_stmt|;
name|fs
operator|.
name|reportChecksumFailure
argument_list|(
name|file
argument_list|,
name|datas
argument_list|,
name|targetPos
argument_list|,
name|sums
argument_list|,
name|sumsPos
argument_list|)
expr_stmt|;
name|boolean
name|newDataSource
init|=
name|datas
operator|.
name|seekToNewSource
argument_list|(
name|targetPos
argument_list|)
decl_stmt|;
return|return
name|sums
operator|.
name|seekToNewSource
argument_list|(
name|sumsPos
argument_list|)
operator|||
name|newDataSource
return|;
block|}
annotation|@
name|Override
DECL|method|readChunk (long pos, byte[] buf, int offset, int len, byte[] checksum)
specifier|protected
name|int
name|readChunk
parameter_list|(
name|long
name|pos
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|byte
index|[]
name|checksum
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|eof
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|needChecksum
argument_list|()
condition|)
block|{
assert|assert
name|checksum
operator|!=
literal|null
assert|;
comment|// we have a checksum buffer
assert|assert
name|checksum
operator|.
name|length
operator|%
name|CHECKSUM_SIZE
operator|==
literal|0
assert|;
comment|// it is sane length
assert|assert
name|len
operator|>=
name|bytesPerSum
assert|;
comment|// we must read at least one chunk
specifier|final
name|int
name|checksumsToRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|len
operator|/
name|bytesPerSum
argument_list|,
comment|// number of checksums based on len to read
name|checksum
operator|.
name|length
operator|/
name|CHECKSUM_SIZE
argument_list|)
decl_stmt|;
comment|// size of checksum buffer
name|long
name|checksumPos
init|=
name|getChecksumFilePos
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|checksumPos
operator|!=
name|sums
operator|.
name|getPos
argument_list|()
condition|)
block|{
name|sums
operator|.
name|seek
argument_list|(
name|checksumPos
argument_list|)
expr_stmt|;
block|}
name|int
name|sumLenRead
init|=
name|sums
operator|.
name|read
argument_list|(
name|checksum
argument_list|,
literal|0
argument_list|,
name|CHECKSUM_SIZE
operator|*
name|checksumsToRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|sumLenRead
operator|>=
literal|0
operator|&&
name|sumLenRead
operator|%
name|CHECKSUM_SIZE
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ChecksumException
argument_list|(
literal|"Checksum file not a length multiple of checksum size "
operator|+
literal|"in "
operator|+
name|file
operator|+
literal|" at "
operator|+
name|pos
operator|+
literal|" checksumpos: "
operator|+
name|checksumPos
operator|+
literal|" sumLenread: "
operator|+
name|sumLenRead
argument_list|,
name|pos
argument_list|)
throw|;
block|}
if|if
condition|(
name|sumLenRead
operator|<=
literal|0
condition|)
block|{
comment|// we're at the end of the file
name|eof
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// Adjust amount of data to read based on how many checksum chunks we read
name|len
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|bytesPerSum
operator|*
operator|(
name|sumLenRead
operator|/
name|CHECKSUM_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pos
operator|!=
name|datas
operator|.
name|getPos
argument_list|()
condition|)
block|{
name|datas
operator|.
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|int
name|nread
init|=
name|readFully
argument_list|(
name|datas
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|eof
operator|&&
name|nread
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|ChecksumException
argument_list|(
literal|"Checksum error: "
operator|+
name|file
operator|+
literal|" at "
operator|+
name|pos
argument_list|,
name|pos
argument_list|)
throw|;
block|}
return|return
name|nread
return|;
block|}
block|}
DECL|class|FSDataBoundedInputStream
specifier|private
specifier|static
class|class
name|FSDataBoundedInputStream
extends|extends
name|FSDataInputStream
block|{
DECL|field|fs
specifier|private
name|FileSystem
name|fs
decl_stmt|;
DECL|field|file
specifier|private
name|Path
name|file
decl_stmt|;
DECL|field|fileLen
specifier|private
name|long
name|fileLen
init|=
operator|-
literal|1L
decl_stmt|;
DECL|method|FSDataBoundedInputStream (FileSystem fs, Path file, InputStream in)
name|FSDataBoundedInputStream
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|InputStream
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|markSupported ()
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/* Return the file length */
DECL|method|getFileLength ()
specifier|private
name|long
name|getFileLength
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|fileLen
operator|==
operator|-
literal|1L
condition|)
block|{
name|fileLen
operator|=
name|fs
operator|.
name|getContentSummary
argument_list|(
name|file
argument_list|)
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
return|return
name|fileLen
return|;
block|}
comment|/**      * Skips over and discards<code>n</code> bytes of data from the      * input stream.      *      *The<code>skip</code> method skips over some smaller number of bytes      * when reaching end of file before<code>n</code> bytes have been skipped.      * The actual number of bytes skipped is returned.  If<code>n</code> is      * negative, no bytes are skipped.      *      * @param      n   the number of bytes to be skipped.      * @return     the actual number of bytes skipped.      * @exception  IOException  if an I/O error occurs.      *             ChecksumException if the chunk to skip to is corrupted      */
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
specifier|synchronized
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|curPos
init|=
name|getPos
argument_list|()
decl_stmt|;
name|long
name|fileLength
init|=
name|getFileLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|+
name|curPos
operator|>
name|fileLength
condition|)
block|{
name|n
operator|=
name|fileLength
operator|-
name|curPos
expr_stmt|;
block|}
return|return
name|super
operator|.
name|skip
argument_list|(
name|n
argument_list|)
return|;
block|}
comment|/**      * Seek to the given position in the stream.      * The next read() will be from that position.      *       *<p>This method does not allow seek past the end of the file.      * This produces IOException.      *      * @param      pos   the postion to seek to.      * @exception  IOException  if an I/O error occurs or seeks after EOF      *             ChecksumException if the chunk to seek to is corrupted      */
annotation|@
name|Override
DECL|method|seek (long pos)
specifier|public
specifier|synchronized
name|void
name|seek
parameter_list|(
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|>
name|getFileLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Cannot seek after EOF"
argument_list|)
throw|;
block|}
name|super
operator|.
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Opens an FSDataInputStream at the indicated Path.    * @param f the file name to open    * @param bufferSize the size of the buffer to be used.    */
annotation|@
name|Override
DECL|method|open (Path f, int bufferSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
decl_stmt|;
name|InputStream
name|in
decl_stmt|;
if|if
condition|(
name|verifyChecksum
condition|)
block|{
name|fs
operator|=
name|this
expr_stmt|;
name|in
operator|=
operator|new
name|ChecksumFSInputChecker
argument_list|(
name|this
argument_list|,
name|f
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|=
name|getRawFileSystem
argument_list|()
expr_stmt|;
name|in
operator|=
name|fs
operator|.
name|open
argument_list|(
name|f
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FSDataBoundedInputStream
argument_list|(
name|fs
argument_list|,
name|f
argument_list|,
name|in
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|append (Path f, int bufferSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Append is not supported "
operator|+
literal|"by ChecksumFileSystem"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|truncate (Path f, long newLength)
specifier|public
name|boolean
name|truncate
parameter_list|(
name|Path
name|f
parameter_list|,
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Truncate is not supported "
operator|+
literal|"by ChecksumFileSystem"
argument_list|)
throw|;
block|}
comment|/**    * Calculated the length of the checksum file in bytes.    * @param size the length of the data file in bytes    * @param bytesPerSum the number of bytes in a checksum block    * @return the number of bytes in the checksum file    */
DECL|method|getChecksumLength (long size, int bytesPerSum)
specifier|public
specifier|static
name|long
name|getChecksumLength
parameter_list|(
name|long
name|size
parameter_list|,
name|int
name|bytesPerSum
parameter_list|)
block|{
comment|//the checksum length is equal to size passed divided by bytesPerSum +
comment|//bytes written in the beginning of the checksum file.
return|return
operator|(
operator|(
name|size
operator|+
name|bytesPerSum
operator|-
literal|1
operator|)
operator|/
name|bytesPerSum
operator|)
operator|*
literal|4
operator|+
name|CHECKSUM_VERSION
operator|.
name|length
operator|+
literal|4
return|;
block|}
comment|/** This class provides an output stream for a checksummed file.    * It generates checksums for data. */
DECL|class|ChecksumFSOutputSummer
specifier|private
specifier|static
class|class
name|ChecksumFSOutputSummer
extends|extends
name|FSOutputSummer
block|{
DECL|field|datas
specifier|private
name|FSDataOutputStream
name|datas
decl_stmt|;
DECL|field|sums
specifier|private
name|FSDataOutputStream
name|sums
decl_stmt|;
DECL|field|CHKSUM_AS_FRACTION
specifier|private
specifier|static
specifier|final
name|float
name|CHKSUM_AS_FRACTION
init|=
literal|0.01f
decl_stmt|;
DECL|field|isClosed
specifier|private
name|boolean
name|isClosed
init|=
literal|false
decl_stmt|;
DECL|method|ChecksumFSOutputSummer (ChecksumFileSystem fs, Path file, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress, FsPermission permission)
specifier|public
name|ChecksumFSOutputSummer
parameter_list|(
name|ChecksumFileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|DataChecksum
operator|.
name|newDataChecksum
argument_list|(
name|DataChecksum
operator|.
name|Type
operator|.
name|CRC32
argument_list|,
name|fs
operator|.
name|getBytesPerSum
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|bytesPerSum
init|=
name|fs
operator|.
name|getBytesPerSum
argument_list|()
decl_stmt|;
name|this
operator|.
name|datas
operator|=
name|fs
operator|.
name|getRawFileSystem
argument_list|()
operator|.
name|create
argument_list|(
name|file
argument_list|,
name|permission
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
expr_stmt|;
name|int
name|sumBufferSize
init|=
name|fs
operator|.
name|getSumBufferSize
argument_list|(
name|bytesPerSum
argument_list|,
name|bufferSize
argument_list|)
decl_stmt|;
name|this
operator|.
name|sums
operator|=
name|fs
operator|.
name|getRawFileSystem
argument_list|()
operator|.
name|create
argument_list|(
name|fs
operator|.
name|getChecksumFile
argument_list|(
name|file
argument_list|)
argument_list|,
name|permission
argument_list|,
literal|true
argument_list|,
name|sumBufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|sums
operator|.
name|write
argument_list|(
name|CHECKSUM_VERSION
argument_list|,
literal|0
argument_list|,
name|CHECKSUM_VERSION
operator|.
name|length
argument_list|)
expr_stmt|;
name|sums
operator|.
name|writeInt
argument_list|(
name|bytesPerSum
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|flushBuffer
argument_list|()
expr_stmt|;
name|sums
operator|.
name|close
argument_list|()
expr_stmt|;
name|datas
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|isClosed
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeChunk (byte[] b, int offset, int len, byte[] checksum, int ckoff, int cklen)
specifier|protected
name|void
name|writeChunk
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|byte
index|[]
name|checksum
parameter_list|,
name|int
name|ckoff
parameter_list|,
name|int
name|cklen
parameter_list|)
throws|throws
name|IOException
block|{
name|datas
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sums
operator|.
name|write
argument_list|(
name|checksum
argument_list|,
name|ckoff
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|checkClosed ()
specifier|protected
name|void
name|checkClosed
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isClosed
condition|)
block|{
throw|throw
operator|new
name|ClosedChannelException
argument_list|()
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|create (Path f, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
name|overwrite
argument_list|,
literal|true
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
DECL|method|create (Path f, FsPermission permission, boolean overwrite, boolean createParent, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|private
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|parent
init|=
name|f
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|createParent
operator|&&
operator|!
name|exists
argument_list|(
name|parent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Parent directory doesn't exist: "
operator|+
name|parent
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mkdirs
argument_list|(
name|parent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|parent
operator|+
literal|" (exists="
operator|+
name|exists
argument_list|(
name|parent
argument_list|)
operator|+
literal|", cwd="
operator|+
name|getWorkingDirectory
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|FSDataOutputStream
name|out
decl_stmt|;
if|if
condition|(
name|writeChecksum
condition|)
block|{
name|out
operator|=
operator|new
name|FSDataOutputStream
argument_list|(
operator|new
name|ChecksumFSOutputSummer
argument_list|(
name|this
argument_list|,
name|f
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|permission
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|fs
operator|.
name|create
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
expr_stmt|;
comment|// remove the checksum file since we aren't writing one
name|Path
name|checkFile
init|=
name|getChecksumFile
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|checkFile
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|checkFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
annotation|@
name|Override
DECL|method|createNonRecursive (Path f, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
name|overwrite
argument_list|,
literal|false
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
DECL|class|FsOperation
specifier|abstract
class|class
name|FsOperation
block|{
DECL|method|run (Path p)
name|boolean
name|run
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|status
init|=
name|apply
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|Path
name|checkFile
init|=
name|getChecksumFile
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|checkFile
argument_list|)
condition|)
block|{
name|apply
argument_list|(
name|checkFile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
DECL|method|apply (Path p)
specifier|abstract
name|boolean
name|apply
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
annotation|@
name|Override
DECL|method|setPermission (Path src, final FsPermission permission)
specifier|public
name|void
name|setPermission
parameter_list|(
name|Path
name|src
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|FsOperation
argument_list|()
block|{
annotation|@
name|Override
name|boolean
name|apply
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setPermission
argument_list|(
name|p
argument_list|,
name|permission
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setOwner (Path src, final String username, final String groupname)
specifier|public
name|void
name|setOwner
parameter_list|(
name|Path
name|src
parameter_list|,
specifier|final
name|String
name|username
parameter_list|,
specifier|final
name|String
name|groupname
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|FsOperation
argument_list|()
block|{
annotation|@
name|Override
name|boolean
name|apply
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setOwner
argument_list|(
name|p
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setAcl (Path src, final List<AclEntry> aclSpec)
specifier|public
name|void
name|setAcl
parameter_list|(
name|Path
name|src
parameter_list|,
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|FsOperation
argument_list|()
block|{
annotation|@
name|Override
name|boolean
name|apply
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setAcl
argument_list|(
name|p
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|modifyAclEntries (Path src, final List<AclEntry> aclSpec)
specifier|public
name|void
name|modifyAclEntries
parameter_list|(
name|Path
name|src
parameter_list|,
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|FsOperation
argument_list|()
block|{
annotation|@
name|Override
name|boolean
name|apply
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|modifyAclEntries
argument_list|(
name|p
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeAcl (Path src)
specifier|public
name|void
name|removeAcl
parameter_list|(
name|Path
name|src
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|FsOperation
argument_list|()
block|{
annotation|@
name|Override
name|boolean
name|apply
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|removeAcl
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeAclEntries (Path src, final List<AclEntry> aclSpec)
specifier|public
name|void
name|removeAclEntries
parameter_list|(
name|Path
name|src
parameter_list|,
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|FsOperation
argument_list|()
block|{
annotation|@
name|Override
name|boolean
name|apply
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|removeAclEntries
argument_list|(
name|p
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeDefaultAcl (Path src)
specifier|public
name|void
name|removeDefaultAcl
parameter_list|(
name|Path
name|src
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|FsOperation
argument_list|()
block|{
annotation|@
name|Override
name|boolean
name|apply
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|removeDefaultAcl
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set replication for an existing file.    * Implement the abstract<tt>setReplication</tt> of<tt>FileSystem</tt>    * @param src file name    * @param replication new replication    * @throws IOException    * @return true if successful;    *         false if file does not exist or is a directory    */
annotation|@
name|Override
DECL|method|setReplication (Path src, final short replication)
specifier|public
name|boolean
name|setReplication
parameter_list|(
name|Path
name|src
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FsOperation
argument_list|()
block|{
annotation|@
name|Override
name|boolean
name|apply
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|setReplication
argument_list|(
name|p
argument_list|,
name|replication
argument_list|)
return|;
block|}
block|}
operator|.
name|run
argument_list|(
name|src
argument_list|)
return|;
block|}
comment|/**    * Rename files/dirs    */
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|rename (Path src, Path dst)
specifier|public
name|boolean
name|rename
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|.
name|isDirectory
argument_list|(
name|src
argument_list|)
condition|)
block|{
return|return
name|fs
operator|.
name|rename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|fs
operator|.
name|isDirectory
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|dst
operator|=
operator|new
name|Path
argument_list|(
name|dst
argument_list|,
name|src
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|value
init|=
name|fs
operator|.
name|rename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
literal|false
return|;
name|Path
name|srcCheckFile
init|=
name|getChecksumFile
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Path
name|dstCheckFile
init|=
name|getChecksumFile
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|srcCheckFile
argument_list|)
condition|)
block|{
comment|//try to rename checksum
name|value
operator|=
name|fs
operator|.
name|rename
argument_list|(
name|srcCheckFile
argument_list|,
name|dstCheckFile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|dstCheckFile
argument_list|)
condition|)
block|{
comment|// no src checksum, so remove dst checksum
name|value
operator|=
name|fs
operator|.
name|delete
argument_list|(
name|dstCheckFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
block|}
comment|/**    * Implement the delete(Path, boolean) in checksum    * file system.    */
annotation|@
name|Override
DECL|method|delete (Path f, boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|fstatus
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fstatus
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fstatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//this works since the crcs are in the same
comment|//directories and the files. so we just delete
comment|//everything in the underlying filesystem
return|return
name|fs
operator|.
name|delete
argument_list|(
name|f
argument_list|,
name|recursive
argument_list|)
return|;
block|}
else|else
block|{
name|Path
name|checkFile
init|=
name|getChecksumFile
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|checkFile
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|checkFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|fs
operator|.
name|delete
argument_list|(
name|f
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
DECL|field|DEFAULT_FILTER
specifier|final
specifier|private
specifier|static
name|PathFilter
name|DEFAULT_FILTER
init|=
operator|new
name|PathFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
return|return
operator|!
name|isChecksumFile
argument_list|(
name|file
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * List the statuses of the files/directories in the given path if the path is    * a directory.    *     * @param f    *          given path    * @return the statuses of the files/directories in the given path    * @throws IOException    */
annotation|@
name|Override
DECL|method|listStatus (Path f)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|listStatus
argument_list|(
name|f
argument_list|,
name|DEFAULT_FILTER
argument_list|)
return|;
block|}
comment|/**    * List the statuses of the files/directories in the given path if the path is    * a directory.    *     * @param f    *          given path    * @return the statuses of the files/directories in the given patch    * @throws IOException    */
annotation|@
name|Override
DECL|method|listLocatedStatus (Path f)
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listLocatedStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|listLocatedStatus
argument_list|(
name|f
argument_list|,
name|DEFAULT_FILTER
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|mkdirs (Path f)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|mkdirs
argument_list|(
name|f
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|copyFromLocalFile (boolean delSrc, Path src, Path dst)
specifier|public
name|void
name|copyFromLocalFile
parameter_list|(
name|boolean
name|delSrc
parameter_list|,
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|FileUtil
operator|.
name|copy
argument_list|(
name|getLocal
argument_list|(
name|conf
argument_list|)
argument_list|,
name|src
argument_list|,
name|this
argument_list|,
name|dst
argument_list|,
name|delSrc
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * The src file is under FS, and the dst is on the local disk.    * Copy it from FS control to the local dst name.    */
annotation|@
name|Override
DECL|method|copyToLocalFile (boolean delSrc, Path src, Path dst)
specifier|public
name|void
name|copyToLocalFile
parameter_list|(
name|boolean
name|delSrc
parameter_list|,
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|FileUtil
operator|.
name|copy
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|getLocal
argument_list|(
name|conf
argument_list|)
argument_list|,
name|dst
argument_list|,
name|delSrc
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * The src file is under FS, and the dst is on the local disk.    * Copy it from FS control to the local dst name.    * If src and dst are directories, the copyCrc parameter    * determines whether to copy CRC files.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|copyToLocalFile (Path src, Path dst, boolean copyCrc)
specifier|public
name|void
name|copyToLocalFile
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|,
name|boolean
name|copyCrc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|isDirectory
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|// source is a file
name|fs
operator|.
name|copyToLocalFile
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|FileSystem
name|localFs
init|=
name|getLocal
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|getRawFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
name|localFs
operator|.
name|isDirectory
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|dst
operator|=
operator|new
name|Path
argument_list|(
name|dst
argument_list|,
name|src
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
name|getChecksumFile
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|localFs
operator|.
name|exists
argument_list|(
name|dst
argument_list|)
condition|)
block|{
comment|//remove old local checksum file
name|localFs
operator|.
name|delete
argument_list|(
name|dst
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|Path
name|checksumFile
init|=
name|getChecksumFile
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyCrc
operator|&&
name|fs
operator|.
name|exists
argument_list|(
name|checksumFile
argument_list|)
condition|)
block|{
comment|//copy checksum file
name|fs
operator|.
name|copyToLocalFile
argument_list|(
name|checksumFile
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|FileStatus
index|[]
name|srcs
init|=
name|listStatus
argument_list|(
name|src
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|srcFile
range|:
name|srcs
control|)
block|{
name|copyToLocalFile
argument_list|(
name|srcFile
operator|.
name|getPath
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
name|dst
argument_list|,
name|srcFile
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|copyCrc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|startLocalOutput (Path fsOutputFile, Path tmpLocalFile)
specifier|public
name|Path
name|startLocalOutput
parameter_list|(
name|Path
name|fsOutputFile
parameter_list|,
name|Path
name|tmpLocalFile
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|tmpLocalFile
return|;
block|}
annotation|@
name|Override
DECL|method|completeLocalOutput (Path fsOutputFile, Path tmpLocalFile)
specifier|public
name|void
name|completeLocalOutput
parameter_list|(
name|Path
name|fsOutputFile
parameter_list|,
name|Path
name|tmpLocalFile
parameter_list|)
throws|throws
name|IOException
block|{
name|moveFromLocalFile
argument_list|(
name|tmpLocalFile
argument_list|,
name|fsOutputFile
argument_list|)
expr_stmt|;
block|}
comment|/**    * Report a checksum error to the file system.    * @param f the file name containing the error    * @param in the stream open on the file    * @param inPos the position of the beginning of the bad data in the file    * @param sums the stream open on the checksum file    * @param sumsPos the position of the beginning of the bad data in the checksum file    * @return if retry is necessary    */
DECL|method|reportChecksumFailure (Path f, FSDataInputStream in, long inPos, FSDataInputStream sums, long sumsPos)
specifier|public
name|boolean
name|reportChecksumFailure
parameter_list|(
name|Path
name|f
parameter_list|,
name|FSDataInputStream
name|in
parameter_list|,
name|long
name|inPos
parameter_list|,
name|FSDataInputStream
name|sums
parameter_list|,
name|long
name|sumsPos
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

