begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_AUTHENTICATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ServiceLoader
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosPrincipal
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosTicket
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|AuthenticationMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenInfo
import|;
end_import

begin_comment
comment|//this will need to be replaced someday when there is a suitable replacement
end_comment

begin_import
import|import
name|sun
operator|.
name|net
operator|.
name|dns
operator|.
name|ResolverConfiguration
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|net
operator|.
name|util
operator|.
name|IPAddressUtil
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|SecurityUtil
specifier|public
class|class
name|SecurityUtil
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SecurityUtil
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|HOSTNAME_PATTERN
specifier|public
specifier|static
specifier|final
name|String
name|HOSTNAME_PATTERN
init|=
literal|"_HOST"
decl_stmt|;
DECL|field|FAILED_TO_GET_UGI_MSG_HEADER
specifier|public
specifier|static
specifier|final
name|String
name|FAILED_TO_GET_UGI_MSG_HEADER
init|=
literal|"Failed to obtain user group information:"
decl_stmt|;
comment|// controls whether buildTokenService will use an ip or host/ip as given
comment|// by the user
annotation|@
name|VisibleForTesting
DECL|field|useIpForTokenService
specifier|static
name|boolean
name|useIpForTokenService
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|hostResolver
specifier|static
name|HostResolver
name|hostResolver
decl_stmt|;
static|static
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|boolean
name|useIp
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_TOKEN_SERVICE_USE_IP
argument_list|,
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_TOKEN_SERVICE_USE_IP_DEFAULT
argument_list|)
decl_stmt|;
name|setTokenServiceUseIp
argument_list|(
name|useIp
argument_list|)
expr_stmt|;
block|}
comment|/**    * For use only by tests and initialization    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setTokenServiceUseIp (boolean flag)
specifier|public
specifier|static
name|void
name|setTokenServiceUseIp
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|useIpForTokenService
operator|=
name|flag
expr_stmt|;
name|hostResolver
operator|=
operator|!
name|useIpForTokenService
condition|?
operator|new
name|QualifiedHostResolver
argument_list|()
else|:
operator|new
name|StandardHostResolver
argument_list|()
expr_stmt|;
block|}
comment|/**    * TGS must have the server principal of the form "krbtgt/FOO@FOO".    * @param principal    * @return true or false    */
specifier|static
name|boolean
DECL|method|isTGSPrincipal (KerberosPrincipal principal)
name|isTGSPrincipal
parameter_list|(
name|KerberosPrincipal
name|principal
parameter_list|)
block|{
if|if
condition|(
name|principal
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|principal
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"krbtgt/"
operator|+
name|principal
operator|.
name|getRealm
argument_list|()
operator|+
literal|"@"
operator|+
name|principal
operator|.
name|getRealm
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Check whether the server principal is the TGS's principal    * @param ticket the original TGT (the ticket that is obtained when a     * kinit is done)    * @return true or false    */
DECL|method|isOriginalTGT (KerberosTicket ticket)
specifier|protected
specifier|static
name|boolean
name|isOriginalTGT
parameter_list|(
name|KerberosTicket
name|ticket
parameter_list|)
block|{
return|return
name|isTGSPrincipal
argument_list|(
name|ticket
operator|.
name|getServer
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Convert Kerberos principal name pattern to valid Kerberos principal    * names. It replaces hostname pattern with hostname, which should be    * fully-qualified domain name. If hostname is null or "0.0.0.0", it uses    * dynamically looked-up fqdn of the current host instead.    *     * @param principalConfig    *          the Kerberos principal name conf value to convert    * @param hostname    *          the fully-qualified domain name used for substitution    * @return converted Kerberos principal name    * @throws IOException if the client address cannot be determined    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getServerPrincipal (String principalConfig, String hostname)
specifier|public
specifier|static
name|String
name|getServerPrincipal
parameter_list|(
name|String
name|principalConfig
parameter_list|,
name|String
name|hostname
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|components
init|=
name|getComponents
argument_list|(
name|principalConfig
argument_list|)
decl_stmt|;
if|if
condition|(
name|components
operator|==
literal|null
operator|||
name|components
operator|.
name|length
operator|!=
literal|3
operator|||
operator|!
name|components
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
name|HOSTNAME_PATTERN
argument_list|)
condition|)
block|{
return|return
name|principalConfig
return|;
block|}
else|else
block|{
return|return
name|replacePattern
argument_list|(
name|components
argument_list|,
name|hostname
argument_list|)
return|;
block|}
block|}
comment|/**    * Convert Kerberos principal name pattern to valid Kerberos principal names.    * This method is similar to {@link #getServerPrincipal(String, String)},    * except 1) the reverse DNS lookup from addr to hostname is done only when    * necessary, 2) param addr can't be null (no default behavior of using local    * hostname when addr is null).    *     * @param principalConfig    *          Kerberos principal name pattern to convert    * @param addr    *          InetAddress of the host used for substitution    * @return converted Kerberos principal name    * @throws IOException if the client address cannot be determined    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getServerPrincipal (String principalConfig, InetAddress addr)
specifier|public
specifier|static
name|String
name|getServerPrincipal
parameter_list|(
name|String
name|principalConfig
parameter_list|,
name|InetAddress
name|addr
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|components
init|=
name|getComponents
argument_list|(
name|principalConfig
argument_list|)
decl_stmt|;
if|if
condition|(
name|components
operator|==
literal|null
operator|||
name|components
operator|.
name|length
operator|!=
literal|3
operator|||
operator|!
name|components
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
name|HOSTNAME_PATTERN
argument_list|)
condition|)
block|{
return|return
name|principalConfig
return|;
block|}
else|else
block|{
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't replace "
operator|+
name|HOSTNAME_PATTERN
operator|+
literal|" pattern since client address is null"
argument_list|)
throw|;
block|}
return|return
name|replacePattern
argument_list|(
name|components
argument_list|,
name|addr
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|getComponents (String principalConfig)
specifier|private
specifier|static
name|String
index|[]
name|getComponents
parameter_list|(
name|String
name|principalConfig
parameter_list|)
block|{
if|if
condition|(
name|principalConfig
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|principalConfig
operator|.
name|split
argument_list|(
literal|"[/@]"
argument_list|)
return|;
block|}
DECL|method|replacePattern (String[] components, String hostname)
specifier|private
specifier|static
name|String
name|replacePattern
parameter_list|(
name|String
index|[]
name|components
parameter_list|,
name|String
name|hostname
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|fqdn
init|=
name|hostname
decl_stmt|;
if|if
condition|(
name|fqdn
operator|==
literal|null
operator|||
name|fqdn
operator|.
name|isEmpty
argument_list|()
operator|||
name|fqdn
operator|.
name|equals
argument_list|(
literal|"0.0.0.0"
argument_list|)
condition|)
block|{
name|fqdn
operator|=
name|getLocalHostName
argument_list|()
expr_stmt|;
block|}
return|return
name|components
index|[
literal|0
index|]
operator|+
literal|"/"
operator|+
name|fqdn
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
operator|+
literal|"@"
operator|+
name|components
index|[
literal|2
index|]
return|;
block|}
DECL|method|getLocalHostName ()
specifier|static
name|String
name|getLocalHostName
parameter_list|()
throws|throws
name|UnknownHostException
block|{
return|return
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getCanonicalHostName
argument_list|()
return|;
block|}
comment|/**    * Login as a principal specified in config. Substitute $host in    * user's Kerberos principal name with a dynamically looked-up fully-qualified    * domain name of the current host.    *     * @param conf    *          conf to use    * @param keytabFileKey    *          the key to look for keytab file in conf    * @param userNameKey    *          the key to look for user's Kerberos principal name in conf    * @throws IOException if login fails    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|login (final Configuration conf, final String keytabFileKey, final String userNameKey)
specifier|public
specifier|static
name|void
name|login
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|keytabFileKey
parameter_list|,
specifier|final
name|String
name|userNameKey
parameter_list|)
throws|throws
name|IOException
block|{
name|login
argument_list|(
name|conf
argument_list|,
name|keytabFileKey
argument_list|,
name|userNameKey
argument_list|,
name|getLocalHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Login as a principal specified in config. Substitute $host in user's Kerberos principal     * name with hostname. If non-secure mode - return. If no keytab available -    * bail out with an exception    *     * @param conf    *          conf to use    * @param keytabFileKey    *          the key to look for keytab file in conf    * @param userNameKey    *          the key to look for user's Kerberos principal name in conf    * @param hostname    *          hostname to use for substitution    * @throws IOException if the config doesn't specify a keytab    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|login (final Configuration conf, final String keytabFileKey, final String userNameKey, String hostname)
specifier|public
specifier|static
name|void
name|login
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|keytabFileKey
parameter_list|,
specifier|final
name|String
name|userNameKey
parameter_list|,
name|String
name|hostname
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
return|return;
name|String
name|keytabFilename
init|=
name|conf
operator|.
name|get
argument_list|(
name|keytabFileKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|keytabFilename
operator|==
literal|null
operator|||
name|keytabFilename
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Running in secure mode, but config doesn't have a keytab"
argument_list|)
throw|;
block|}
name|String
name|principalConfig
init|=
name|conf
operator|.
name|get
argument_list|(
name|userNameKey
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|principalName
init|=
name|SecurityUtil
operator|.
name|getServerPrincipal
argument_list|(
name|principalConfig
argument_list|,
name|hostname
argument_list|)
decl_stmt|;
name|UserGroupInformation
operator|.
name|loginUserFromKeytab
argument_list|(
name|principalName
argument_list|,
name|keytabFilename
argument_list|)
expr_stmt|;
block|}
comment|/**    * create the service name for a Delegation token    * @param uri of the service    * @param defPort is used if the uri lacks a port    * @return the token service, or null if no authority    * @see #buildTokenService(InetSocketAddress)    */
DECL|method|buildDTServiceName (URI uri, int defPort)
specifier|public
specifier|static
name|String
name|buildDTServiceName
parameter_list|(
name|URI
name|uri
parameter_list|,
name|int
name|defPort
parameter_list|)
block|{
name|String
name|authority
init|=
name|uri
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
if|if
condition|(
name|authority
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|InetSocketAddress
name|addr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|authority
argument_list|,
name|defPort
argument_list|)
decl_stmt|;
return|return
name|buildTokenService
argument_list|(
name|addr
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get the host name from the principal name of format<service>/host@realm.    * @param principalName principal name of format as described above    * @return host name if the the string conforms to the above format, else null    */
DECL|method|getHostFromPrincipal (String principalName)
specifier|public
specifier|static
name|String
name|getHostFromPrincipal
parameter_list|(
name|String
name|principalName
parameter_list|)
block|{
return|return
operator|new
name|HadoopKerberosName
argument_list|(
name|principalName
argument_list|)
operator|.
name|getHostName
argument_list|()
return|;
block|}
DECL|field|securityInfoProviders
specifier|private
specifier|static
name|ServiceLoader
argument_list|<
name|SecurityInfo
argument_list|>
name|securityInfoProviders
init|=
name|ServiceLoader
operator|.
name|load
argument_list|(
name|SecurityInfo
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|testProviders
specifier|private
specifier|static
name|SecurityInfo
index|[]
name|testProviders
init|=
operator|new
name|SecurityInfo
index|[
literal|0
index|]
decl_stmt|;
comment|/**    * Test setup method to register additional providers.    * @param providers a list of high priority providers to use    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|setSecurityInfoProviders (SecurityInfo... providers)
specifier|public
specifier|static
name|void
name|setSecurityInfoProviders
parameter_list|(
name|SecurityInfo
modifier|...
name|providers
parameter_list|)
block|{
name|testProviders
operator|=
name|providers
expr_stmt|;
block|}
comment|/**    * Look up the KerberosInfo for a given protocol. It searches all known    * SecurityInfo providers.    * @param protocol the protocol class to get the information for    * @param conf configuration object    * @return the KerberosInfo or null if it has no KerberosInfo defined    */
specifier|public
specifier|static
name|KerberosInfo
DECL|method|getKerberosInfo (Class<?> protocol, Configuration conf)
name|getKerberosInfo
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|protocol
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
for|for
control|(
name|SecurityInfo
name|provider
range|:
name|testProviders
control|)
block|{
name|KerberosInfo
name|result
init|=
name|provider
operator|.
name|getKerberosInfo
argument_list|(
name|protocol
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
synchronized|synchronized
init|(
name|securityInfoProviders
init|)
block|{
for|for
control|(
name|SecurityInfo
name|provider
range|:
name|securityInfoProviders
control|)
block|{
name|KerberosInfo
name|result
init|=
name|provider
operator|.
name|getKerberosInfo
argument_list|(
name|protocol
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Look up the TokenInfo for a given protocol. It searches all known    * SecurityInfo providers.    * @param protocol The protocol class to get the information for.    * @param conf Configuration object    * @return the TokenInfo or null if it has no KerberosInfo defined    */
DECL|method|getTokenInfo (Class<?> protocol, Configuration conf)
specifier|public
specifier|static
name|TokenInfo
name|getTokenInfo
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|protocol
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
for|for
control|(
name|SecurityInfo
name|provider
range|:
name|testProviders
control|)
block|{
name|TokenInfo
name|result
init|=
name|provider
operator|.
name|getTokenInfo
argument_list|(
name|protocol
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
synchronized|synchronized
init|(
name|securityInfoProviders
init|)
block|{
for|for
control|(
name|SecurityInfo
name|provider
range|:
name|securityInfoProviders
control|)
block|{
name|TokenInfo
name|result
init|=
name|provider
operator|.
name|getTokenInfo
argument_list|(
name|protocol
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Decode the given token's service field into an InetAddress    * @param token from which to obtain the service    * @return InetAddress for the service    */
DECL|method|getTokenServiceAddr (Token<?> token)
specifier|public
specifier|static
name|InetSocketAddress
name|getTokenServiceAddr
parameter_list|(
name|Token
argument_list|<
name|?
argument_list|>
name|token
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|token
operator|.
name|getService
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Set the given token's service to the format expected by the RPC client     * @param token a delegation token    * @param addr the socket for the rpc connection    */
DECL|method|setTokenService (Token<?> token, InetSocketAddress addr)
specifier|public
specifier|static
name|void
name|setTokenService
parameter_list|(
name|Token
argument_list|<
name|?
argument_list|>
name|token
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|)
block|{
name|Text
name|service
init|=
name|buildTokenService
argument_list|(
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|token
operator|.
name|setService
argument_list|(
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Acquired token "
operator|+
name|token
argument_list|)
expr_stmt|;
comment|// Token#toString() prints service
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get token for service "
operator|+
name|service
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Construct the service key for a token    * @param addr InetSocketAddress of remote connection with a token    * @return "ip:port" or "host:port" depending on the value of    *          hadoop.security.token.service.use_ip    */
DECL|method|buildTokenService (InetSocketAddress addr)
specifier|public
specifier|static
name|Text
name|buildTokenService
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|)
block|{
name|String
name|host
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|useIpForTokenService
condition|)
block|{
if|if
condition|(
name|addr
operator|.
name|isUnresolved
argument_list|()
condition|)
block|{
comment|// host has no ip address
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
operator|new
name|UnknownHostException
argument_list|(
name|addr
operator|.
name|getHostName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|host
operator|=
name|addr
operator|.
name|getAddress
argument_list|()
operator|.
name|getHostAddress
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|addr
operator|.
name|getHostName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|Text
argument_list|(
name|host
operator|+
literal|":"
operator|+
name|addr
operator|.
name|getPort
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Construct the service key for a token    * @param uri of remote connection with a token    * @return "ip:port" or "host:port" depending on the value of    *          hadoop.security.token.service.use_ip    */
DECL|method|buildTokenService (URI uri)
specifier|public
specifier|static
name|Text
name|buildTokenService
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
return|return
name|buildTokenService
argument_list|(
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|uri
operator|.
name|getAuthority
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Perform the given action as the daemon's login user. If the login    * user cannot be determined, this will log a FATAL error and exit    * the whole JVM.    */
DECL|method|doAsLoginUserOrFatal (PrivilegedAction<T> action)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|doAsLoginUserOrFatal
parameter_list|(
name|PrivilegedAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|UserGroupInformation
name|ugi
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Exception while getting login user"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ugi
operator|.
name|doAs
argument_list|(
name|action
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|action
operator|.
name|run
argument_list|()
return|;
block|}
block|}
comment|/**    * Perform the given action as the daemon's login user. If an    * InterruptedException is thrown, it is converted to an IOException.    *    * @param action the action to perform    * @return the result of the action    * @throws IOException in the event of error    */
DECL|method|doAsLoginUser (PrivilegedExceptionAction<T> action)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|doAsLoginUser
parameter_list|(
name|PrivilegedExceptionAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doAsUser
argument_list|(
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**    * Perform the given action as the daemon's current user. If an    * InterruptedException is thrown, it is converted to an IOException.    *    * @param action the action to perform    * @return the result of the action    * @throws IOException in the event of error    */
DECL|method|doAsCurrentUser (PrivilegedExceptionAction<T> action)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|doAsCurrentUser
parameter_list|(
name|PrivilegedExceptionAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|doAsUser
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|action
argument_list|)
return|;
block|}
DECL|method|doAsUser (UserGroupInformation ugi, PrivilegedExceptionAction<T> action)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|doAsUser
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|PrivilegedExceptionAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|ugi
operator|.
name|doAs
argument_list|(
name|action
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|/**    * Resolves a host subject to the security requirements determined by    * hadoop.security.token.service.use_ip.    *     * @param hostname host or ip to resolve    * @return a resolved host    * @throws UnknownHostException if the host doesn't exist    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
DECL|method|getByName (String hostname)
name|InetAddress
name|getByName
parameter_list|(
name|String
name|hostname
parameter_list|)
throws|throws
name|UnknownHostException
block|{
return|return
name|hostResolver
operator|.
name|getByName
argument_list|(
name|hostname
argument_list|)
return|;
block|}
DECL|interface|HostResolver
interface|interface
name|HostResolver
block|{
DECL|method|getByName (String host)
name|InetAddress
name|getByName
parameter_list|(
name|String
name|host
parameter_list|)
throws|throws
name|UnknownHostException
function_decl|;
block|}
comment|/**    * Uses standard java host resolution    */
DECL|class|StandardHostResolver
specifier|static
class|class
name|StandardHostResolver
implements|implements
name|HostResolver
block|{
annotation|@
name|Override
DECL|method|getByName (String host)
specifier|public
name|InetAddress
name|getByName
parameter_list|(
name|String
name|host
parameter_list|)
throws|throws
name|UnknownHostException
block|{
return|return
name|InetAddress
operator|.
name|getByName
argument_list|(
name|host
argument_list|)
return|;
block|}
block|}
comment|/**    * This an alternate resolver with important properties that the standard    * java resolver lacks:    * 1) The hostname is fully qualified.  This avoids security issues if not    *    all hosts in the cluster do not share the same search domains.  It    *    also prevents other hosts from performing unnecessary dns searches.    *    In contrast, InetAddress simply returns the host as given.    * 2) The InetAddress is instantiated with an exact host and IP to prevent    *    further unnecessary lookups.  InetAddress may perform an unnecessary    *    reverse lookup for an IP.    * 3) A call to getHostName() will always return the qualified hostname, or    *    more importantly, the IP if instantiated with an IP.  This avoids    *    unnecessary dns timeouts if the host is not resolvable.    * 4) Point 3 also ensures that if the host is re-resolved, ex. during a    *    connection re-attempt, that a reverse lookup to host and forward    *    lookup to IP is not performed since the reverse/forward mappings may    *    not always return the same IP.  If the client initiated a connection    *    with an IP, then that IP is all that should ever be contacted.    *        * NOTE: this resolver is only used if:    *       hadoop.security.token.service.use_ip=false     */
DECL|class|QualifiedHostResolver
specifier|protected
specifier|static
class|class
name|QualifiedHostResolver
implements|implements
name|HostResolver
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|field|searchDomains
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|searchDomains
init|=
name|ResolverConfiguration
operator|.
name|open
argument_list|()
operator|.
name|searchlist
argument_list|()
decl_stmt|;
comment|/**      * Create an InetAddress with a fully qualified hostname of the given      * hostname.  InetAddress does not qualify an incomplete hostname that      * is resolved via the domain search list.      * {@link InetAddress#getCanonicalHostName()} will fully qualify the      * hostname, but it always return the A record whereas the given hostname      * may be a CNAME.      *       * @param host a hostname or ip address      * @return InetAddress with the fully qualified hostname or ip      * @throws UnknownHostException if host does not exist      */
annotation|@
name|Override
DECL|method|getByName (String host)
specifier|public
name|InetAddress
name|getByName
parameter_list|(
name|String
name|host
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|InetAddress
name|addr
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|IPAddressUtil
operator|.
name|isIPv4LiteralAddress
argument_list|(
name|host
argument_list|)
condition|)
block|{
comment|// use ipv4 address as-is
name|byte
index|[]
name|ip
init|=
name|IPAddressUtil
operator|.
name|textToNumericFormatV4
argument_list|(
name|host
argument_list|)
decl_stmt|;
name|addr
operator|=
name|InetAddress
operator|.
name|getByAddress
argument_list|(
name|host
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IPAddressUtil
operator|.
name|isIPv6LiteralAddress
argument_list|(
name|host
argument_list|)
condition|)
block|{
comment|// use ipv6 address as-is
name|byte
index|[]
name|ip
init|=
name|IPAddressUtil
operator|.
name|textToNumericFormatV6
argument_list|(
name|host
argument_list|)
decl_stmt|;
name|addr
operator|=
name|InetAddress
operator|.
name|getByAddress
argument_list|(
name|host
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|host
operator|.
name|endsWith
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
comment|// a rooted host ends with a dot, ex. "host."
comment|// rooted hosts never use the search path, so only try an exact lookup
name|addr
operator|=
name|getByExactName
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|host
operator|.
name|contains
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
comment|// the host contains a dot (domain), ex. "host.domain"
comment|// try an exact host lookup, then fallback to search list
name|addr
operator|=
name|getByExactName
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
name|addr
operator|=
name|getByNameWithSearch
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// it's a simple host with no dots, ex. "host"
comment|// try the search list, then fallback to exact host
name|InetAddress
name|loopback
init|=
name|InetAddress
operator|.
name|getByName
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|host
operator|.
name|equalsIgnoreCase
argument_list|(
name|loopback
operator|.
name|getHostName
argument_list|()
argument_list|)
condition|)
block|{
name|addr
operator|=
name|InetAddress
operator|.
name|getByAddress
argument_list|(
name|host
argument_list|,
name|loopback
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|getByNameWithSearch
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
name|addr
operator|=
name|getByExactName
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// unresolvable!
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
name|host
argument_list|)
throw|;
block|}
return|return
name|addr
return|;
block|}
DECL|method|getByExactName (String host)
name|InetAddress
name|getByExactName
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|InetAddress
name|addr
init|=
literal|null
decl_stmt|;
comment|// InetAddress will use the search list unless the host is rooted
comment|// with a trailing dot.  The trailing dot will disable any use of the
comment|// search path in a lower level resolver.  See RFC 1535.
name|String
name|fqHost
init|=
name|host
decl_stmt|;
if|if
condition|(
operator|!
name|fqHost
operator|.
name|endsWith
argument_list|(
literal|"."
argument_list|)
condition|)
name|fqHost
operator|+=
literal|"."
expr_stmt|;
try|try
block|{
name|addr
operator|=
name|getInetAddressByName
argument_list|(
name|fqHost
argument_list|)
expr_stmt|;
comment|// can't leave the hostname as rooted or other parts of the system
comment|// malfunction, ex. kerberos principals are lacking proper host
comment|// equivalence for rooted/non-rooted hostnames
name|addr
operator|=
name|InetAddress
operator|.
name|getByAddress
argument_list|(
name|host
argument_list|,
name|addr
operator|.
name|getAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
comment|// ignore, caller will throw if necessary
block|}
return|return
name|addr
return|;
block|}
DECL|method|getByNameWithSearch (String host)
name|InetAddress
name|getByNameWithSearch
parameter_list|(
name|String
name|host
parameter_list|)
block|{
name|InetAddress
name|addr
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|host
operator|.
name|endsWith
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
comment|// already qualified?
name|addr
operator|=
name|getByExactName
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|String
name|domain
range|:
name|searchDomains
control|)
block|{
name|String
name|dot
init|=
operator|!
name|domain
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
condition|?
literal|"."
else|:
literal|""
decl_stmt|;
name|addr
operator|=
name|getByExactName
argument_list|(
name|host
operator|+
name|dot
operator|+
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|null
condition|)
break|break;
block|}
block|}
return|return
name|addr
return|;
block|}
comment|// implemented as a separate method to facilitate unit testing
DECL|method|getInetAddressByName (String host)
name|InetAddress
name|getInetAddressByName
parameter_list|(
name|String
name|host
parameter_list|)
throws|throws
name|UnknownHostException
block|{
return|return
name|InetAddress
operator|.
name|getByName
argument_list|(
name|host
argument_list|)
return|;
block|}
DECL|method|setSearchDomains (String .... domains)
name|void
name|setSearchDomains
parameter_list|(
name|String
modifier|...
name|domains
parameter_list|)
block|{
name|searchDomains
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|domains
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getAuthenticationMethod (Configuration conf)
specifier|public
specifier|static
name|AuthenticationMethod
name|getAuthenticationMethod
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|value
init|=
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_SECURITY_AUTHENTICATION
argument_list|,
literal|"simple"
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|Enum
operator|.
name|valueOf
argument_list|(
name|AuthenticationMethod
operator|.
name|class
argument_list|,
name|value
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid attribute value for "
operator|+
name|HADOOP_SECURITY_AUTHENTICATION
operator|+
literal|" of "
operator|+
name|value
argument_list|)
throw|;
block|}
block|}
DECL|method|setAuthenticationMethod ( AuthenticationMethod authenticationMethod, Configuration conf)
specifier|public
specifier|static
name|void
name|setAuthenticationMethod
parameter_list|(
name|AuthenticationMethod
name|authenticationMethod
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|authenticationMethod
operator|==
literal|null
condition|)
block|{
name|authenticationMethod
operator|=
name|AuthenticationMethod
operator|.
name|SIMPLE
expr_stmt|;
block|}
name|conf
operator|.
name|set
argument_list|(
name|HADOOP_SECURITY_AUTHENTICATION
argument_list|,
name|authenticationMethod
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

