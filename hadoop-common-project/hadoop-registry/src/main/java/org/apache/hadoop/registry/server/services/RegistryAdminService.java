begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.registry.server.services
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|server
operator|.
name|services
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|BackgroundCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathIsNotEmptyDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|ServiceStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryPathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|InvalidRecordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|NoPathPermissionsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|NoRecordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|impl
operator|.
name|zk
operator|.
name|RegistryBindingSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|impl
operator|.
name|zk
operator|.
name|RegistryOperationsService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|impl
operator|.
name|zk
operator|.
name|RegistrySecurity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|RegistryPathStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|concurrent
operator|.
name|HadoopExecutors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * Administrator service for the registry. This is the one with  * permissions to create the base directories and those for users.  *  * It also includes support for asynchronous operations, so that  * zookeeper connectivity problems do not hold up the server code  * performing the actions.  *  * Any action queued via {@link #submit(Callable)} will be  * run asynchronously. The {@link #createDirAsync(String, List, boolean)}  * is an example of such an an action  *  * A key async action is the depth-first tree purge, which supports  * pluggable policies for deleting entries. The method  * {@link #purge(String, NodeSelector, PurgePolicy, BackgroundCallback)}  * implements the recursive purge operation âthe class  * {{AsyncPurge}} provides the asynchronous scheduling of this.  */
end_comment

begin_class
DECL|class|RegistryAdminService
specifier|public
class|class
name|RegistryAdminService
extends|extends
name|RegistryOperationsService
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RegistryAdminService
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The ACL permissions for the user's homedir ACL.    */
DECL|field|USER_HOMEDIR_ACL_PERMISSIONS
specifier|public
specifier|static
specifier|final
name|int
name|USER_HOMEDIR_ACL_PERMISSIONS
init|=
name|ZooDefs
operator|.
name|Perms
operator|.
name|READ
operator||
name|ZooDefs
operator|.
name|Perms
operator|.
name|WRITE
operator||
name|ZooDefs
operator|.
name|Perms
operator|.
name|CREATE
operator||
name|ZooDefs
operator|.
name|Perms
operator|.
name|DELETE
decl_stmt|;
comment|/**    * Executor for async operations    */
DECL|field|executor
specifier|protected
specifier|final
name|ExecutorService
name|executor
decl_stmt|;
comment|/**    * Construct an instance of the service    * @param name service name    */
DECL|method|RegistryAdminService (String name)
specifier|public
name|RegistryAdminService
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * construct an instance of the service, using the    * specified binding source to bond to ZK    * @param name service name    * @param bindingSource provider of ZK binding information    */
DECL|method|RegistryAdminService (String name, RegistryBindingSource bindingSource)
specifier|public
name|RegistryAdminService
parameter_list|(
name|String
name|name
parameter_list|,
name|RegistryBindingSource
name|bindingSource
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|bindingSource
argument_list|)
expr_stmt|;
name|executor
operator|=
name|HadoopExecutors
operator|.
name|newCachedThreadPool
argument_list|(
operator|new
name|ThreadFactory
argument_list|()
block|{
specifier|private
name|AtomicInteger
name|counter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
return|return
operator|new
name|Thread
argument_list|(
name|r
argument_list|,
literal|"RegistryAdminService "
operator|+
name|counter
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stop the service: halt the executor.    * @throws Exception exception.    */
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|protected
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
name|stopExecutor
argument_list|()
expr_stmt|;
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
comment|/**    * Stop the executor if it is not null.    * This uses {@link ExecutorService#shutdownNow()}    * and so does not block until they have completed.    */
DECL|method|stopExecutor ()
specifier|protected
specifier|synchronized
name|void
name|stopExecutor
parameter_list|()
block|{
if|if
condition|(
name|executor
operator|!=
literal|null
condition|)
block|{
name|executor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the executor    * @return the executor    */
DECL|method|getExecutor ()
specifier|protected
name|ExecutorService
name|getExecutor
parameter_list|()
block|{
return|return
name|executor
return|;
block|}
comment|/**    * Submit a callable    * @param callable callable    * @param<V> type of the final get    * @return a future to wait on    */
DECL|method|submit (Callable<V> callable)
specifier|public
parameter_list|<
name|V
parameter_list|>
name|Future
argument_list|<
name|V
argument_list|>
name|submit
parameter_list|(
name|Callable
argument_list|<
name|V
argument_list|>
name|callable
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Submitting {}"
argument_list|,
name|callable
argument_list|)
expr_stmt|;
block|}
return|return
name|getExecutor
argument_list|()
operator|.
name|submit
argument_list|(
name|callable
argument_list|)
return|;
block|}
comment|/**    * Asynchronous operation to create a directory    * @param path path    * @param acls ACL list    * @param createParents flag to indicate parent dirs should be created    * as needed    * @return the future which will indicate whether or not the operation    * succeeded âand propagate any exceptions    * @throws IOException    */
DECL|method|createDirAsync (final String path, final List<ACL> acls, final boolean createParents)
specifier|public
name|Future
argument_list|<
name|Boolean
argument_list|>
name|createDirAsync
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
parameter_list|,
specifier|final
name|boolean
name|createParents
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|maybeCreate
argument_list|(
name|path
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|acls
argument_list|,
name|createParents
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Init operation sets up the system ACLs.    * @param conf configuration of the service    * @throws Exception    */
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|RegistrySecurity
name|registrySecurity
init|=
name|getRegistrySecurity
argument_list|()
decl_stmt|;
if|if
condition|(
name|registrySecurity
operator|.
name|isSecureRegistry
argument_list|()
condition|)
block|{
name|ACL
name|sasl
init|=
name|registrySecurity
operator|.
name|createSaslACLFromCurrentUser
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|)
decl_stmt|;
name|registrySecurity
operator|.
name|addSystemACL
argument_list|(
name|sasl
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Registry System ACLs:"
argument_list|,
name|RegistrySecurity
operator|.
name|aclsToString
argument_list|(
name|registrySecurity
operator|.
name|getSystemACLs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Start the service, including creating base directories with permissions    * @throws Exception    */
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|protected
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
comment|// create the root directories
try|try
block|{
name|createRootRegistryPaths
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoPathPermissionsException
name|e
parameter_list|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"Failed to create root paths {%s};"
operator|+
literal|"%ndiagnostics={%s}"
operator|+
literal|"%ncurrent registry is:"
operator|+
literal|"%n{%s}"
argument_list|,
name|e
argument_list|,
name|bindingDiagnosticDetails
argument_list|()
argument_list|,
name|dumpRegistryRobustly
argument_list|(
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|" Failure {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// TODO: this is something temporary to deal with the problem
comment|// that jenkins is failing this test
throw|throw
operator|new
name|NoPathPermissionsException
argument_list|(
name|e
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|message
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create the initial registry paths    * @throws IOException any failure    */
annotation|@
name|VisibleForTesting
DECL|method|createRootRegistryPaths ()
specifier|public
name|void
name|createRootRegistryPaths
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|ACL
argument_list|>
name|systemACLs
init|=
name|getRegistrySecurity
argument_list|()
operator|.
name|getSystemACLs
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"System ACLs {}"
argument_list|,
name|RegistrySecurity
operator|.
name|aclsToString
argument_list|(
name|systemACLs
argument_list|)
argument_list|)
expr_stmt|;
name|maybeCreate
argument_list|(
literal|""
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|systemACLs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|maybeCreate
argument_list|(
name|PATH_USERS
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|systemACLs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|maybeCreate
argument_list|(
name|PATH_SYSTEM_SERVICES
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|systemACLs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the path to a user's home dir    * @param username username    * @return a path for services underneath    */
DECL|method|homeDir (String username)
specifier|protected
name|String
name|homeDir
parameter_list|(
name|String
name|username
parameter_list|)
block|{
return|return
name|RegistryUtils
operator|.
name|homePathForUser
argument_list|(
name|username
argument_list|)
return|;
block|}
comment|/**    * Set up the ACL for the user.    *<b>Important: this must run client-side as it needs    * to know the id:pass tuple for a user</b>    * @param username user name    * @param perms permissions    * @return an ACL list    * @throws IOException ACL creation/parsing problems    */
DECL|method|aclsForUser (String username, int perms)
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|aclsForUser
parameter_list|(
name|String
name|username
parameter_list|,
name|int
name|perms
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|ACL
argument_list|>
name|clientACLs
init|=
name|getClientAcls
argument_list|()
decl_stmt|;
name|RegistrySecurity
name|security
init|=
name|getRegistrySecurity
argument_list|()
decl_stmt|;
if|if
condition|(
name|security
operator|.
name|isSecureRegistry
argument_list|()
condition|)
block|{
name|clientACLs
operator|.
name|add
argument_list|(
name|security
operator|.
name|createACLfromUsername
argument_list|(
name|username
argument_list|,
name|perms
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|clientACLs
return|;
block|}
comment|/**    * Start an async operation to create the home path for a user    * if it does not exist    * @param shortname username, without any @REALM in kerberos    * @return the path created    * @throws IOException any failure while setting up the operation    *    */
DECL|method|initUserRegistryAsync (final String shortname)
specifier|public
name|Future
argument_list|<
name|Boolean
argument_list|>
name|initUserRegistryAsync
parameter_list|(
specifier|final
name|String
name|shortname
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|homeDir
init|=
name|homeDir
argument_list|(
name|shortname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|homeDir
argument_list|)
condition|)
block|{
comment|// create the directory. The user does not
return|return
name|createDirAsync
argument_list|(
name|homeDir
argument_list|,
name|aclsForUser
argument_list|(
name|shortname
argument_list|,
name|USER_HOMEDIR_ACL_PERMISSIONS
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Create the home path for a user if it does not exist.    *    * This uses {@link #initUserRegistryAsync(String)} and then waits for the    * result ... the code path is the same as the async operation; this just    * picks up and relays/converts exceptions    * @param username username    * @return the path created    * @throws IOException any failure    *    */
DECL|method|initUserRegistry (final String username)
specifier|public
name|String
name|initUserRegistry
parameter_list|(
specifier|final
name|String
name|username
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Future
argument_list|<
name|Boolean
argument_list|>
name|future
init|=
name|initUserRegistryAsync
argument_list|(
name|username
argument_list|)
decl_stmt|;
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
call|(
name|InterruptedIOException
call|)
argument_list|(
operator|new
name|InterruptedIOException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
call|(
name|IOException
call|)
argument_list|(
name|cause
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|cause
operator|.
name|toString
argument_list|()
argument_list|,
name|cause
argument_list|)
throw|;
block|}
block|}
return|return
name|homeDir
argument_list|(
name|username
argument_list|)
return|;
block|}
comment|/**    * Method to validate the validity of the kerberos realm.    *<ul>    *<li>Insecure: not needed.</li>    *<li>Secure: must have been determined.</li>    *</ul>    */
DECL|method|verifyRealmValidity ()
specifier|protected
name|void
name|verifyRealmValidity
parameter_list|()
throws|throws
name|ServiceStateException
block|{
if|if
condition|(
name|isSecure
argument_list|()
condition|)
block|{
name|String
name|realm
init|=
name|getRegistrySecurity
argument_list|()
operator|.
name|getKerberosRealm
argument_list|()
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|realm
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ServiceStateException
argument_list|(
literal|"Cannot determine service realm"
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Started Registry operations in realm {}"
argument_list|,
name|realm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Policy to purge entries    */
DECL|enum|PurgePolicy
specifier|public
enum|enum
name|PurgePolicy
block|{
DECL|enumConstant|PurgeAll
name|PurgeAll
block|,
DECL|enumConstant|FailOnChildren
name|FailOnChildren
block|,
DECL|enumConstant|SkipOnChildren
name|SkipOnChildren
block|}
comment|/**    * Recursive operation to purge all matching records under a base path.    *<ol>    *<li>Uses a depth first search</li>    *<li>A match is on ID and persistence policy, or, if policy==-1, any match</li>    *<li>If a record matches then it is deleted without any child searches</li>    *<li>Deletions will be asynchronous if a callback is provided</li>    *</ol>    *    * The code is designed to be robust against parallel deletions taking place;    * in such a case it will stop attempting that part of the tree. This    * avoid the situation of more than 1 purge happening in parallel and    * one of the purge operations deleteing the node tree above the other.    * @param path base path    * @param selector selector for the purge policy    * @param purgePolicy what to do if there is a matching record with children    * @param callback optional curator callback    * @return the number of delete operations perfomed. As deletes may be for    * everything under a path, this may be less than the number of records    * actually deleted    * @throws IOException problems    * @throws PathIsNotEmptyDirectoryException if an entry cannot be deleted    * as it has children and the purge policy is FailOnChildren    */
annotation|@
name|VisibleForTesting
DECL|method|purge (String path, NodeSelector selector, PurgePolicy purgePolicy, BackgroundCallback callback)
specifier|public
name|int
name|purge
parameter_list|(
name|String
name|path
parameter_list|,
name|NodeSelector
name|selector
parameter_list|,
name|PurgePolicy
name|purgePolicy
parameter_list|,
name|BackgroundCallback
name|callback
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|toDelete
init|=
literal|false
decl_stmt|;
comment|// look at self to see if it has a service record
name|Map
argument_list|<
name|String
argument_list|,
name|RegistryPathStatus
argument_list|>
name|childEntries
decl_stmt|;
name|Collection
argument_list|<
name|RegistryPathStatus
argument_list|>
name|entries
decl_stmt|;
try|try
block|{
comment|// list this path's children
name|childEntries
operator|=
name|RegistryUtils
operator|.
name|statChildren
argument_list|(
name|this
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|entries
operator|=
name|childEntries
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
comment|// there's no record here, it may have been deleted already.
comment|// exit
return|return
literal|0
return|;
block|}
try|try
block|{
name|RegistryPathStatus
name|registryPathStatus
init|=
name|stat
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|ServiceRecord
name|serviceRecord
init|=
name|resolve
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|// there is now an entry here.
name|toDelete
operator|=
name|selector
operator|.
name|shouldSelect
argument_list|(
name|path
argument_list|,
name|registryPathStatus
argument_list|,
name|serviceRecord
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|ignored
parameter_list|)
block|{
comment|// ignore
block|}
catch|catch
parameter_list|(
name|InvalidRecordException
name|ignored
parameter_list|)
block|{
comment|// ignore
block|}
catch|catch
parameter_list|(
name|NoRecordException
name|ignored
parameter_list|)
block|{
comment|// ignore
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
comment|// there's no record here, it may have been deleted already.
comment|// exit
return|return
literal|0
return|;
block|}
if|if
condition|(
name|toDelete
operator|&&
operator|!
name|entries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Match on record @ {} with children "
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|// there's children
switch|switch
condition|(
name|purgePolicy
condition|)
block|{
case|case
name|SkipOnChildren
case|:
comment|// don't do the deletion... continue to next record
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping deletion"
argument_list|)
expr_stmt|;
block|}
name|toDelete
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|PurgeAll
case|:
comment|// mark for deletion
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scheduling for deletion with children"
argument_list|)
expr_stmt|;
block|}
name|toDelete
operator|=
literal|true
expr_stmt|;
name|entries
operator|=
operator|new
name|ArrayList
argument_list|<
name|RegistryPathStatus
argument_list|>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FailOnChildren
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failing deletion operation"
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|PathIsNotEmptyDirectoryException
argument_list|(
name|path
argument_list|)
throw|;
block|}
block|}
name|int
name|deleteOps
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|toDelete
condition|)
block|{
try|try
block|{
name|zkDelete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
comment|// sign that the path was deleted during the operation.
comment|// this is a no-op, and all children can be skipped
return|return
name|deleteOps
return|;
block|}
name|deleteOps
operator|++
expr_stmt|;
block|}
comment|// now go through the children
for|for
control|(
name|RegistryPathStatus
name|status
range|:
name|entries
control|)
block|{
name|String
name|childname
init|=
name|status
operator|.
name|path
decl_stmt|;
name|String
name|childpath
init|=
name|RegistryPathUtils
operator|.
name|join
argument_list|(
name|path
argument_list|,
name|childname
argument_list|)
decl_stmt|;
name|deleteOps
operator|+=
name|purge
argument_list|(
name|childpath
argument_list|,
name|selector
argument_list|,
name|purgePolicy
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
return|return
name|deleteOps
return|;
block|}
comment|/**    * Comparator used for purge logic    */
DECL|interface|NodeSelector
specifier|public
interface|interface
name|NodeSelector
block|{
DECL|method|shouldSelect (String path, RegistryPathStatus registryPathStatus, ServiceRecord serviceRecord)
name|boolean
name|shouldSelect
parameter_list|(
name|String
name|path
parameter_list|,
name|RegistryPathStatus
name|registryPathStatus
parameter_list|,
name|ServiceRecord
name|serviceRecord
parameter_list|)
function_decl|;
block|}
comment|/**    * An async registry purge action taking    * a selector which decides what to delete    */
DECL|class|AsyncPurge
specifier|public
class|class
name|AsyncPurge
implements|implements
name|Callable
argument_list|<
name|Integer
argument_list|>
block|{
DECL|field|callback
specifier|private
specifier|final
name|BackgroundCallback
name|callback
decl_stmt|;
DECL|field|selector
specifier|private
specifier|final
name|NodeSelector
name|selector
decl_stmt|;
DECL|field|path
specifier|private
specifier|final
name|String
name|path
decl_stmt|;
DECL|field|purgePolicy
specifier|private
specifier|final
name|PurgePolicy
name|purgePolicy
decl_stmt|;
DECL|method|AsyncPurge (String path, NodeSelector selector, PurgePolicy purgePolicy, BackgroundCallback callback)
specifier|public
name|AsyncPurge
parameter_list|(
name|String
name|path
parameter_list|,
name|NodeSelector
name|selector
parameter_list|,
name|PurgePolicy
name|purgePolicy
parameter_list|,
name|BackgroundCallback
name|callback
parameter_list|)
block|{
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
name|this
operator|.
name|selector
operator|=
name|selector
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|purgePolicy
operator|=
name|purgePolicy
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Executing {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|purge
argument_list|(
name|path
argument_list|,
name|selector
argument_list|,
name|purgePolicy
argument_list|,
name|callback
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"Record purge under %s with selector %s"
argument_list|,
name|path
argument_list|,
name|selector
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

