begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.nfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|nfs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|net
operator|.
name|util
operator|.
name|SubnetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|net
operator|.
name|util
operator|.
name|SubnetUtils
operator|.
name|SubnetInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|nfs
operator|.
name|nfs3
operator|.
name|Nfs3Constant
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LightWeightCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LightWeightGSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LightWeightGSet
operator|.
name|LinkedElement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class provides functionality for loading and checking the mapping   * between client hosts and their access privileges.  */
end_comment

begin_class
DECL|class|NfsExports
specifier|public
class|class
name|NfsExports
block|{
DECL|field|exports
specifier|private
specifier|static
name|NfsExports
name|exports
init|=
literal|null
decl_stmt|;
DECL|method|getInstance (Configuration conf)
specifier|public
specifier|static
specifier|synchronized
name|NfsExports
name|getInstance
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|exports
operator|==
literal|null
condition|)
block|{
name|String
name|matchHosts
init|=
name|conf
operator|.
name|get
argument_list|(
name|CommonConfigurationKeys
operator|.
name|NFS_EXPORTS_ALLOWED_HOSTS_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|NFS_EXPORTS_ALLOWED_HOSTS_KEY_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|cacheSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|Nfs3Constant
operator|.
name|NFS_EXPORTS_CACHE_SIZE_KEY
argument_list|,
name|Nfs3Constant
operator|.
name|NFS_EXPORTS_CACHE_SIZE_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|expirationPeriodNano
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|Nfs3Constant
operator|.
name|NFS_EXPORTS_CACHE_EXPIRYTIME_MILLIS_KEY
argument_list|,
name|Nfs3Constant
operator|.
name|NFS_EXPORTS_CACHE_EXPIRYTIME_MILLIS_DEFAULT
argument_list|)
operator|*
literal|1000
operator|*
literal|1000
decl_stmt|;
try|try
block|{
name|exports
operator|=
operator|new
name|NfsExports
argument_list|(
name|cacheSize
argument_list|,
name|expirationPeriodNano
argument_list|,
name|matchHosts
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid NFS Exports provided: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|exports
return|;
block|}
block|}
return|return
name|exports
return|;
block|}
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NfsExports
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// only support IPv4 now
DECL|field|IP_ADDRESS
specifier|private
specifier|static
specifier|final
name|String
name|IP_ADDRESS
init|=
literal|"(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})"
decl_stmt|;
DECL|field|SLASH_FORMAT_SHORT
specifier|private
specifier|static
specifier|final
name|String
name|SLASH_FORMAT_SHORT
init|=
name|IP_ADDRESS
operator|+
literal|"/(\\d{1,3})"
decl_stmt|;
DECL|field|SLASH_FORMAT_LONG
specifier|private
specifier|static
specifier|final
name|String
name|SLASH_FORMAT_LONG
init|=
name|IP_ADDRESS
operator|+
literal|"/"
operator|+
name|IP_ADDRESS
decl_stmt|;
DECL|field|CIDR_FORMAT_SHORT
specifier|private
specifier|static
specifier|final
name|Pattern
name|CIDR_FORMAT_SHORT
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|SLASH_FORMAT_SHORT
argument_list|)
decl_stmt|;
DECL|field|CIDR_FORMAT_LONG
specifier|private
specifier|static
specifier|final
name|Pattern
name|CIDR_FORMAT_LONG
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|SLASH_FORMAT_LONG
argument_list|)
decl_stmt|;
comment|// Hostnames are composed of series of 'labels' concatenated with dots.
comment|// Labels can be between 1-63 characters long, and can only take
comment|// letters, digits& hyphens. They cannot start and end with hyphens. For
comment|// more details, refer RFC-1123& http://en.wikipedia.org/wiki/Hostname
DECL|field|LABEL_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|LABEL_FORMAT
init|=
literal|"[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?"
decl_stmt|;
DECL|field|HOSTNAME_FORMAT
specifier|private
specifier|static
specifier|final
name|Pattern
name|HOSTNAME_FORMAT
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^("
operator|+
name|LABEL_FORMAT
operator|+
literal|"\\.)*"
operator|+
name|LABEL_FORMAT
operator|+
literal|"$"
argument_list|)
decl_stmt|;
DECL|class|AccessCacheEntry
specifier|static
class|class
name|AccessCacheEntry
implements|implements
name|LightWeightCache
operator|.
name|Entry
block|{
DECL|field|hostAddr
specifier|private
specifier|final
name|String
name|hostAddr
decl_stmt|;
DECL|field|access
specifier|private
name|AccessPrivilege
name|access
decl_stmt|;
DECL|field|expirationTime
specifier|private
specifier|final
name|long
name|expirationTime
decl_stmt|;
DECL|field|next
specifier|private
name|LightWeightGSet
operator|.
name|LinkedElement
name|next
decl_stmt|;
DECL|method|AccessCacheEntry (String hostAddr, AccessPrivilege access, long expirationTime)
name|AccessCacheEntry
parameter_list|(
name|String
name|hostAddr
parameter_list|,
name|AccessPrivilege
name|access
parameter_list|,
name|long
name|expirationTime
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|hostAddr
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|hostAddr
operator|=
name|hostAddr
expr_stmt|;
name|this
operator|.
name|access
operator|=
name|access
expr_stmt|;
name|this
operator|.
name|expirationTime
operator|=
name|expirationTime
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|hostAddr
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|AccessCacheEntry
condition|)
block|{
name|AccessCacheEntry
name|entry
init|=
operator|(
name|AccessCacheEntry
operator|)
name|obj
decl_stmt|;
return|return
name|this
operator|.
name|hostAddr
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|hostAddr
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|setNext (LinkedElement next)
specifier|public
name|void
name|setNext
parameter_list|(
name|LinkedElement
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getNext ()
specifier|public
name|LinkedElement
name|getNext
parameter_list|()
block|{
return|return
name|this
operator|.
name|next
return|;
block|}
annotation|@
name|Override
DECL|method|setExpirationTime (long timeNano)
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|timeNano
parameter_list|)
block|{
comment|// we set expiration time in the constructor, and the expiration time
comment|// does not change
block|}
annotation|@
name|Override
DECL|method|getExpirationTime ()
specifier|public
name|long
name|getExpirationTime
parameter_list|()
block|{
return|return
name|this
operator|.
name|expirationTime
return|;
block|}
block|}
DECL|field|mMatches
specifier|private
specifier|final
name|List
argument_list|<
name|Match
argument_list|>
name|mMatches
decl_stmt|;
DECL|field|accessCache
specifier|private
specifier|final
name|LightWeightCache
argument_list|<
name|AccessCacheEntry
argument_list|,
name|AccessCacheEntry
argument_list|>
name|accessCache
decl_stmt|;
DECL|field|cacheExpirationPeriod
specifier|private
specifier|final
name|long
name|cacheExpirationPeriod
decl_stmt|;
comment|/**    * Constructor.    * @param cacheSize The size of the access privilege cache.    * @param expirationPeriodNano The period     * @param matchingHosts A string specifying one or multiple matchers.     */
DECL|method|NfsExports (int cacheSize, long expirationPeriodNano, String matchHosts)
name|NfsExports
parameter_list|(
name|int
name|cacheSize
parameter_list|,
name|long
name|expirationPeriodNano
parameter_list|,
name|String
name|matchHosts
parameter_list|)
block|{
name|this
operator|.
name|cacheExpirationPeriod
operator|=
name|expirationPeriodNano
expr_stmt|;
name|accessCache
operator|=
operator|new
name|LightWeightCache
argument_list|<
name|AccessCacheEntry
argument_list|,
name|AccessCacheEntry
argument_list|>
argument_list|(
name|cacheSize
argument_list|,
name|cacheSize
argument_list|,
name|expirationPeriodNano
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|String
index|[]
name|matchStrings
init|=
name|matchHosts
operator|.
name|split
argument_list|(
name|CommonConfigurationKeys
operator|.
name|NFS_EXPORTS_ALLOWED_HOSTS_SEPARATOR
argument_list|)
decl_stmt|;
name|mMatches
operator|=
operator|new
name|ArrayList
argument_list|<
name|Match
argument_list|>
argument_list|(
name|matchStrings
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|mStr
range|:
name|matchStrings
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing match string '"
operator|+
name|mStr
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|mStr
operator|=
name|mStr
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|mStr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mMatches
operator|.
name|add
argument_list|(
name|getMatch
argument_list|(
name|mStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Return the configured group list    * @return host group list    */
DECL|method|getHostGroupList ()
specifier|public
name|String
index|[]
name|getHostGroupList
parameter_list|()
block|{
name|int
name|listSize
init|=
name|mMatches
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
index|[]
name|hostGroups
init|=
operator|new
name|String
index|[
name|listSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mMatches
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|hostGroups
index|[
name|i
index|]
operator|=
name|mMatches
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getHostGroup
argument_list|()
expr_stmt|;
block|}
return|return
name|hostGroups
return|;
block|}
DECL|method|getAccessPrivilege (InetAddress addr)
specifier|public
name|AccessPrivilege
name|getAccessPrivilege
parameter_list|(
name|InetAddress
name|addr
parameter_list|)
block|{
return|return
name|getAccessPrivilege
argument_list|(
name|addr
operator|.
name|getHostAddress
argument_list|()
argument_list|,
name|addr
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getAccessPrivilege (String address, String hostname)
name|AccessPrivilege
name|getAccessPrivilege
parameter_list|(
name|String
name|address
parameter_list|,
name|String
name|hostname
parameter_list|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|AccessCacheEntry
name|newEntry
init|=
operator|new
name|AccessCacheEntry
argument_list|(
name|address
argument_list|,
name|AccessPrivilege
operator|.
name|NONE
argument_list|,
name|now
operator|+
name|this
operator|.
name|cacheExpirationPeriod
argument_list|)
decl_stmt|;
comment|// check if there is a cache entry for the given address
name|AccessCacheEntry
name|cachedEntry
init|=
name|accessCache
operator|.
name|get
argument_list|(
name|newEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedEntry
operator|!=
literal|null
operator|&&
name|now
operator|<
name|cachedEntry
operator|.
name|expirationTime
condition|)
block|{
comment|// get a non-expired cache entry, use it
return|return
name|cachedEntry
operator|.
name|access
return|;
block|}
else|else
block|{
for|for
control|(
name|Match
name|match
range|:
name|mMatches
control|)
block|{
if|if
condition|(
name|match
operator|.
name|isIncluded
argument_list|(
name|address
argument_list|,
name|hostname
argument_list|)
condition|)
block|{
if|if
condition|(
name|match
operator|.
name|accessPrivilege
operator|==
name|AccessPrivilege
operator|.
name|READ_ONLY
condition|)
block|{
name|newEntry
operator|.
name|access
operator|=
name|AccessPrivilege
operator|.
name|READ_ONLY
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|match
operator|.
name|accessPrivilege
operator|==
name|AccessPrivilege
operator|.
name|READ_WRITE
condition|)
block|{
name|newEntry
operator|.
name|access
operator|=
name|AccessPrivilege
operator|.
name|READ_WRITE
expr_stmt|;
block|}
block|}
block|}
name|accessCache
operator|.
name|put
argument_list|(
name|newEntry
argument_list|)
expr_stmt|;
return|return
name|newEntry
operator|.
name|access
return|;
block|}
block|}
DECL|class|Match
specifier|private
specifier|static
specifier|abstract
class|class
name|Match
block|{
DECL|field|accessPrivilege
specifier|private
specifier|final
name|AccessPrivilege
name|accessPrivilege
decl_stmt|;
DECL|method|Match (AccessPrivilege accessPrivilege)
specifier|private
name|Match
parameter_list|(
name|AccessPrivilege
name|accessPrivilege
parameter_list|)
block|{
name|this
operator|.
name|accessPrivilege
operator|=
name|accessPrivilege
expr_stmt|;
block|}
DECL|method|isIncluded (String address, String hostname)
specifier|public
specifier|abstract
name|boolean
name|isIncluded
parameter_list|(
name|String
name|address
parameter_list|,
name|String
name|hostname
parameter_list|)
function_decl|;
DECL|method|getHostGroup ()
specifier|public
specifier|abstract
name|String
name|getHostGroup
parameter_list|()
function_decl|;
block|}
comment|/**    * Matcher covering all client hosts (specified by "*")    */
DECL|class|AnonymousMatch
specifier|private
specifier|static
class|class
name|AnonymousMatch
extends|extends
name|Match
block|{
DECL|method|AnonymousMatch (AccessPrivilege accessPrivilege)
specifier|private
name|AnonymousMatch
parameter_list|(
name|AccessPrivilege
name|accessPrivilege
parameter_list|)
block|{
name|super
argument_list|(
name|accessPrivilege
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isIncluded (String address, String hostname)
specifier|public
name|boolean
name|isIncluded
parameter_list|(
name|String
name|address
parameter_list|,
name|String
name|hostname
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getHostGroup ()
specifier|public
name|String
name|getHostGroup
parameter_list|()
block|{
return|return
literal|"*"
return|;
block|}
block|}
comment|/**    * Matcher using CIDR for client host matching    */
DECL|class|CIDRMatch
specifier|private
specifier|static
class|class
name|CIDRMatch
extends|extends
name|Match
block|{
DECL|field|subnetInfo
specifier|private
specifier|final
name|SubnetInfo
name|subnetInfo
decl_stmt|;
DECL|method|CIDRMatch (AccessPrivilege accessPrivilege, SubnetInfo subnetInfo)
specifier|private
name|CIDRMatch
parameter_list|(
name|AccessPrivilege
name|accessPrivilege
parameter_list|,
name|SubnetInfo
name|subnetInfo
parameter_list|)
block|{
name|super
argument_list|(
name|accessPrivilege
argument_list|)
expr_stmt|;
name|this
operator|.
name|subnetInfo
operator|=
name|subnetInfo
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isIncluded (String address, String hostname)
specifier|public
name|boolean
name|isIncluded
parameter_list|(
name|String
name|address
parameter_list|,
name|String
name|hostname
parameter_list|)
block|{
if|if
condition|(
name|subnetInfo
operator|.
name|isInRange
argument_list|(
name|address
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CIDRNMatcher low = "
operator|+
name|subnetInfo
operator|.
name|getLowAddress
argument_list|()
operator|+
literal|", high = "
operator|+
name|subnetInfo
operator|.
name|getHighAddress
argument_list|()
operator|+
literal|", allowing client '"
operator|+
name|address
operator|+
literal|"', '"
operator|+
name|hostname
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CIDRNMatcher low = "
operator|+
name|subnetInfo
operator|.
name|getLowAddress
argument_list|()
operator|+
literal|", high = "
operator|+
name|subnetInfo
operator|.
name|getHighAddress
argument_list|()
operator|+
literal|", denying client '"
operator|+
name|address
operator|+
literal|"', '"
operator|+
name|hostname
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getHostGroup ()
specifier|public
name|String
name|getHostGroup
parameter_list|()
block|{
return|return
name|subnetInfo
operator|.
name|getAddress
argument_list|()
operator|+
literal|"/"
operator|+
name|subnetInfo
operator|.
name|getNetmask
argument_list|()
return|;
block|}
block|}
comment|/**    * Matcher requiring exact string match for client host    */
DECL|class|ExactMatch
specifier|private
specifier|static
class|class
name|ExactMatch
extends|extends
name|Match
block|{
DECL|field|ipOrHost
specifier|private
specifier|final
name|String
name|ipOrHost
decl_stmt|;
DECL|method|ExactMatch (AccessPrivilege accessPrivilege, String ipOrHost)
specifier|private
name|ExactMatch
parameter_list|(
name|AccessPrivilege
name|accessPrivilege
parameter_list|,
name|String
name|ipOrHost
parameter_list|)
block|{
name|super
argument_list|(
name|accessPrivilege
argument_list|)
expr_stmt|;
name|this
operator|.
name|ipOrHost
operator|=
name|ipOrHost
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isIncluded (String address, String hostname)
specifier|public
name|boolean
name|isIncluded
parameter_list|(
name|String
name|address
parameter_list|,
name|String
name|hostname
parameter_list|)
block|{
if|if
condition|(
name|ipOrHost
operator|.
name|equalsIgnoreCase
argument_list|(
name|address
argument_list|)
operator|||
name|ipOrHost
operator|.
name|equalsIgnoreCase
argument_list|(
name|hostname
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ExactMatcher '"
operator|+
name|ipOrHost
operator|+
literal|"', allowing client "
operator|+
literal|"'"
operator|+
name|address
operator|+
literal|"', '"
operator|+
name|hostname
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ExactMatcher '"
operator|+
name|ipOrHost
operator|+
literal|"', denying client "
operator|+
literal|"'"
operator|+
name|address
operator|+
literal|"', '"
operator|+
name|hostname
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getHostGroup ()
specifier|public
name|String
name|getHostGroup
parameter_list|()
block|{
return|return
name|ipOrHost
return|;
block|}
block|}
comment|/**    * Matcher where client hosts are specified by regular expression    */
DECL|class|RegexMatch
specifier|private
specifier|static
class|class
name|RegexMatch
extends|extends
name|Match
block|{
DECL|field|pattern
specifier|private
specifier|final
name|Pattern
name|pattern
decl_stmt|;
DECL|method|RegexMatch (AccessPrivilege accessPrivilege, String wildcard)
specifier|private
name|RegexMatch
parameter_list|(
name|AccessPrivilege
name|accessPrivilege
parameter_list|,
name|String
name|wildcard
parameter_list|)
block|{
name|super
argument_list|(
name|accessPrivilege
argument_list|)
expr_stmt|;
name|this
operator|.
name|pattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|wildcard
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isIncluded (String address, String hostname)
specifier|public
name|boolean
name|isIncluded
parameter_list|(
name|String
name|address
parameter_list|,
name|String
name|hostname
parameter_list|)
block|{
if|if
condition|(
name|pattern
operator|.
name|matcher
argument_list|(
name|address
argument_list|)
operator|.
name|matches
argument_list|()
operator|||
name|pattern
operator|.
name|matcher
argument_list|(
name|hostname
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"RegexMatcher '"
operator|+
name|pattern
operator|.
name|pattern
argument_list|()
operator|+
literal|"', allowing client '"
operator|+
name|address
operator|+
literal|"', '"
operator|+
name|hostname
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"RegexMatcher '"
operator|+
name|pattern
operator|.
name|pattern
argument_list|()
operator|+
literal|"', denying client '"
operator|+
name|address
operator|+
literal|"', '"
operator|+
name|hostname
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getHostGroup ()
specifier|public
name|String
name|getHostGroup
parameter_list|()
block|{
return|return
name|pattern
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Loading a matcher from a string. The default access privilege is read-only.    * The string contains 1 or 2 parts, separated by whitespace characters, where    * the first part specifies the client hosts, and the second part (if     * existent) specifies the access privilege of the client hosts. I.e.,    *     * "client-hosts [access-privilege]"    */
DECL|method|getMatch (String line)
specifier|private
specifier|static
name|Match
name|getMatch
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|String
index|[]
name|parts
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|host
decl_stmt|;
name|AccessPrivilege
name|privilege
init|=
name|AccessPrivilege
operator|.
name|READ_ONLY
decl_stmt|;
switch|switch
condition|(
name|parts
operator|.
name|length
condition|)
block|{
case|case
literal|1
case|:
name|host
operator|=
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|host
operator|=
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
name|String
name|option
init|=
name|parts
index|[
literal|1
index|]
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"rw"
operator|.
name|equalsIgnoreCase
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|privilege
operator|=
name|AccessPrivilege
operator|.
name|READ_WRITE
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrectly formatted line '"
operator|+
name|line
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|host
operator|.
name|equals
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using match all for '"
operator|+
name|host
operator|+
literal|"' and "
operator|+
name|privilege
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|AnonymousMatch
argument_list|(
name|privilege
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|CIDR_FORMAT_SHORT
operator|.
name|matcher
argument_list|(
name|host
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using CIDR match for '"
operator|+
name|host
operator|+
literal|"' and "
operator|+
name|privilege
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|CIDRMatch
argument_list|(
name|privilege
argument_list|,
operator|new
name|SubnetUtils
argument_list|(
name|host
argument_list|)
operator|.
name|getInfo
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|CIDR_FORMAT_LONG
operator|.
name|matcher
argument_list|(
name|host
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using CIDR match for '"
operator|+
name|host
operator|+
literal|"' and "
operator|+
name|privilege
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|pair
init|=
name|host
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
return|return
operator|new
name|CIDRMatch
argument_list|(
name|privilege
argument_list|,
operator|new
name|SubnetUtils
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|)
operator|.
name|getInfo
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|host
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
operator|||
name|host
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
operator|||
name|host
operator|.
name|contains
argument_list|(
literal|"["
argument_list|)
operator|||
name|host
operator|.
name|contains
argument_list|(
literal|"]"
argument_list|)
operator|||
name|host
operator|.
name|contains
argument_list|(
literal|"("
argument_list|)
operator|||
name|host
operator|.
name|contains
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using Regex match for '"
operator|+
name|host
operator|+
literal|"' and "
operator|+
name|privilege
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RegexMatch
argument_list|(
name|privilege
argument_list|,
name|host
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|HOSTNAME_FORMAT
operator|.
name|matcher
argument_list|(
name|host
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using exact match for '"
operator|+
name|host
operator|+
literal|"' and "
operator|+
name|privilege
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ExactMatch
argument_list|(
name|privilege
argument_list|,
name|host
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid hostname provided '"
operator|+
name|host
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

