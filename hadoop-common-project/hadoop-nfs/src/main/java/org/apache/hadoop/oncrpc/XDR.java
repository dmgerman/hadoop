begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.oncrpc
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|oncrpc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jboss
operator|.
name|netty
operator|.
name|buffer
operator|.
name|ChannelBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jboss
operator|.
name|netty
operator|.
name|buffer
operator|.
name|ChannelBuffers
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Utility class for building XDR messages based on RFC 4506.  *<p>  * This class maintains a buffer into which java types are written as  * XDR types for building XDR messages. Similarly this class can  * be used to get java types from an XDR request or response.  *<p>  * Currently only a subset of XDR types defined in RFC 4506 are supported.  */
end_comment

begin_class
DECL|class|XDR
specifier|public
class|class
name|XDR
block|{
DECL|field|HEXES
specifier|private
specifier|final
specifier|static
name|String
name|HEXES
init|=
literal|"0123456789abcdef"
decl_stmt|;
comment|/** Internal buffer for reading or writing to */
DECL|field|bytearr
specifier|private
name|byte
index|[]
name|bytearr
decl_stmt|;
comment|/** Place to read from or write to */
DECL|field|cursor
specifier|private
name|int
name|cursor
decl_stmt|;
DECL|method|XDR ()
specifier|public
name|XDR
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
DECL|method|XDR (byte[] data)
specifier|public
name|XDR
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
block|{
name|bytearr
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|cursor
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * @param bytes bytes to be appended to internal buffer    */
DECL|method|append (byte[] bytesToAdd)
specifier|private
name|void
name|append
parameter_list|(
name|byte
index|[]
name|bytesToAdd
parameter_list|)
block|{
name|bytearr
operator|=
name|append
argument_list|(
name|bytearr
argument_list|,
name|bytesToAdd
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|bytearr
operator|.
name|length
return|;
block|}
comment|/** Skip some bytes by moving the cursor */
DECL|method|skip (int size)
specifier|public
name|void
name|skip
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|cursor
operator|+=
name|size
expr_stmt|;
block|}
comment|/**    * Write Java primitive integer as XDR signed integer.    *     * Definition of XDR signed integer from RFC 4506:    *<pre>    * An XDR signed integer is a 32-bit datum that encodes an integer in    * the range [-2147483648,2147483647].  The integer is represented in    * two's complement notation.  The most and least significant bytes are    * 0 and 3, respectively.  Integers are declared as follows:    *     *       int identifier;    *     *            (MSB)                   (LSB)    *          +-------+-------+-------+-------+    *          |byte 0 |byte 1 |byte 2 |byte 3 |                      INTEGER    *          +-------+-------+-------+-------+    *<------------32 bits------------>    *</pre>    */
DECL|method|writeInt (int data)
specifier|public
name|void
name|writeInt
parameter_list|(
name|int
name|data
parameter_list|)
block|{
name|append
argument_list|(
name|toBytes
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read an XDR signed integer and return as Java primitive integer.    */
DECL|method|readInt ()
specifier|public
name|int
name|readInt
parameter_list|()
block|{
name|byte
name|byte0
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte1
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte2
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte3
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
return|return
operator|(
name|XDR
operator|.
name|toShort
argument_list|(
name|byte0
argument_list|)
operator|<<
literal|24
operator|)
operator|+
operator|(
name|XDR
operator|.
name|toShort
argument_list|(
name|byte1
argument_list|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|XDR
operator|.
name|toShort
argument_list|(
name|byte2
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|XDR
operator|.
name|toShort
argument_list|(
name|byte3
argument_list|)
return|;
block|}
comment|/**    * Write Java primitive boolean as an XDR boolean.    *     * Definition of XDR boolean from RFC 4506:    *<pre>    *    Booleans are important enough and occur frequently enough to warrant    *    their own explicit type in the standard.  Booleans are declared as    *    follows:    *     *          bool identifier;    *     *    This is equivalent to:    *     *          enum { FALSE = 0, TRUE = 1 } identifier;    *</pre>    */
DECL|method|writeBoolean (boolean data)
specifier|public
name|void
name|writeBoolean
parameter_list|(
name|boolean
name|data
parameter_list|)
block|{
name|this
operator|.
name|writeInt
argument_list|(
name|data
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read an XDR boolean and return as Java primitive boolean.    */
DECL|method|readBoolean ()
specifier|public
name|boolean
name|readBoolean
parameter_list|()
block|{
return|return
name|readInt
argument_list|()
operator|==
literal|0
condition|?
literal|false
else|:
literal|true
return|;
block|}
comment|/**    * Write Java primitive long to an XDR signed long.    *     * Definition of XDR signed long from RFC 4506:    *<pre>    *    The standard also defines 64-bit (8-byte) numbers called hyper    *    integers and unsigned hyper integers.  Their representations are the    *    obvious extensions of integer and unsigned integer defined above.    *    They are represented in two's complement notation.The most and    *    least significant bytes are 0 and 7, respectively. Their    *    declarations:    *     *    hyper identifier; unsigned hyper identifier;    *     *         (MSB)                                                   (LSB)    *       +-------+-------+-------+-------+-------+-------+-------+-------+    *       |byte 0 |byte 1 |byte 2 |byte 3 |byte 4 |byte 5 |byte 6 |byte 7 |    *       +-------+-------+-------+-------+-------+-------+-------+-------+    *<----------------------------64 bits---------------------------->    *                                                  HYPER INTEGER    *                                                  UNSIGNED HYPER INTEGER    *</pre>    */
DECL|method|writeLongAsHyper (long data)
specifier|public
name|void
name|writeLongAsHyper
parameter_list|(
name|long
name|data
parameter_list|)
block|{
name|byte
name|byte0
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|data
operator|&
literal|0xff00000000000000l
operator|)
operator|>>
literal|56
argument_list|)
decl_stmt|;
name|byte
name|byte1
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|data
operator|&
literal|0x00ff000000000000l
operator|)
operator|>>
literal|48
argument_list|)
decl_stmt|;
name|byte
name|byte2
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|data
operator|&
literal|0x0000ff0000000000l
operator|)
operator|>>
literal|40
argument_list|)
decl_stmt|;
name|byte
name|byte3
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|data
operator|&
literal|0x000000ff00000000l
operator|)
operator|>>
literal|32
argument_list|)
decl_stmt|;
name|byte
name|byte4
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|data
operator|&
literal|0x00000000ff000000l
operator|)
operator|>>
literal|24
argument_list|)
decl_stmt|;
name|byte
name|byte5
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|data
operator|&
literal|0x0000000000ff0000l
operator|)
operator|>>
literal|16
argument_list|)
decl_stmt|;
name|byte
name|byte6
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|data
operator|&
literal|0x000000000000ff00l
operator|)
operator|>>
literal|8
argument_list|)
decl_stmt|;
name|byte
name|byte7
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|data
operator|&
literal|0x00000000000000ffl
operator|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|append
argument_list|(
operator|new
name|byte
index|[]
block|{
name|byte0
block|,
name|byte1
block|,
name|byte2
block|,
name|byte3
block|,
name|byte4
block|,
name|byte5
block|,
name|byte6
block|,
name|byte7
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read XDR signed hyper and return as java primitive long.    */
DECL|method|readHyper ()
specifier|public
name|long
name|readHyper
parameter_list|()
block|{
name|byte
name|byte0
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte1
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte2
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte3
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte4
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte5
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte6
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
name|byte
name|byte7
init|=
name|bytearr
index|[
name|cursor
operator|++
index|]
decl_stmt|;
return|return
operator|(
operator|(
name|long
operator|)
name|XDR
operator|.
name|toShort
argument_list|(
name|byte0
argument_list|)
operator|<<
literal|56
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|XDR
operator|.
name|toShort
argument_list|(
name|byte1
argument_list|)
operator|<<
literal|48
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|XDR
operator|.
name|toShort
argument_list|(
name|byte2
argument_list|)
operator|<<
literal|40
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|XDR
operator|.
name|toShort
argument_list|(
name|byte3
argument_list|)
operator|<<
literal|32
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|XDR
operator|.
name|toShort
argument_list|(
name|byte4
argument_list|)
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|XDR
operator|.
name|toShort
argument_list|(
name|byte5
argument_list|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|XDR
operator|.
name|toShort
argument_list|(
name|byte6
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|XDR
operator|.
name|toShort
argument_list|(
name|byte7
argument_list|)
return|;
block|}
comment|/**    * Write a Java primitive byte array to XDR fixed-length opaque data.    *     * Defintion of fixed-length opaque data from RFC 4506:    *<pre>    *    At times, fixed-length uninterpreted data needs to be passed among    *    machines.  This data is called "opaque" and is declared as follows:    *     *          opaque identifier[n];    *     *    where the constant n is the (static) number of bytes necessary to    *    contain the opaque data.  If n is not a multiple of four, then the n    *    bytes are followed by enough (0 to 3) residual zero bytes, r, to make    *    the total byte count of the opaque object a multiple of four.    *     *           0        1     ...    *       +--------+--------+...+--------+--------+...+--------+    *       | byte 0 | byte 1 |...|byte n-1|    0   |...|    0   |    *       +--------+--------+...+--------+--------+...+--------+    *       |<-----------n bytes---------->|<------r bytes------>|    *       |<-----------n+r (where (n+r) mod 4 = 0)------------>|    *                                                    FIXED-LENGTH OPAQUE    *</pre>    */
DECL|method|writeFixedOpaque (byte[] data)
specifier|public
name|void
name|writeFixedOpaque
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
block|{
name|writeFixedOpaque
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|writeFixedOpaque (byte[] data, int length)
specifier|public
name|void
name|writeFixedOpaque
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|append
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|data
argument_list|,
name|length
operator|+
name|XDR
operator|.
name|pad
argument_list|(
name|length
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|readFixedOpaque (int size)
specifier|public
name|byte
index|[]
name|readFixedOpaque
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|byte
index|[]
name|ret
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|ret
index|[
name|i
index|]
operator|=
name|bytearr
index|[
name|cursor
index|]
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|XDR
operator|.
name|pad
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cursor
operator|++
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Write a Java primitive byte array as XDR variable-length opque data.    *     * Definition of XDR variable-length opaque data RFC 4506:    *     *<pre>    *    The standard also provides for variable-length (counted) opaque data,    *    defined as a sequence of n (numbered 0 through n-1) arbitrary bytes    *    to be the number n encoded as an unsigned integer (as described    *    below), and followed by the n bytes of the sequence.    *     *    Byte m of the sequence always precedes byte m+1 of the sequence, and    *    byte 0 of the sequence always follows the sequence's length (count).    *    If n is not a multiple of four, then the n bytes are followed by    *    enough (0 to 3) residual zero bytes, r, to make the total byte count    *    a multiple of four.  Variable-length opaque data is declared in the    *    following way:    *     *          opaque identifier<m>;    *       or    *          opaque identifier<>;    *     *    The constant m denotes an upper bound of the number of bytes that the    *    sequence may contain.  If m is not specified, as in the second    *    declaration, it is assumed to be (2**32) - 1, the maximum length.    *     *    The constant m would normally be found in a protocol specification.    *    For example, a filing protocol may state that the maximum data    *    transfer size is 8192 bytes, as follows:    *     *          opaque filedata<8192>;    *     *             0     1     2     3     4     5   ...    *          +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+    *          |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |    *          +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+    *          |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|    *                                  |<----n+r (where (n+r) mod 4 = 0)---->|    *                                                   VARIABLE-LENGTH OPAQUE    *     *    It is an error to encode a length greater than the maximum described    *    in the specification.    *</pre>    */
DECL|method|writeVariableOpaque (byte[] data)
specifier|public
name|void
name|writeVariableOpaque
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
block|{
name|this
operator|.
name|writeInt
argument_list|(
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|writeFixedOpaque
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
DECL|method|readVariableOpaque ()
specifier|public
name|byte
index|[]
name|readVariableOpaque
parameter_list|()
block|{
name|int
name|size
init|=
name|this
operator|.
name|readInt
argument_list|()
decl_stmt|;
return|return
name|size
operator|!=
literal|0
condition|?
name|this
operator|.
name|readFixedOpaque
argument_list|(
name|size
argument_list|)
else|:
operator|new
name|byte
index|[
literal|0
index|]
return|;
block|}
DECL|method|skipVariableOpaque ()
specifier|public
name|void
name|skipVariableOpaque
parameter_list|()
block|{
name|int
name|length
init|=
name|this
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|this
operator|.
name|skip
argument_list|(
name|length
operator|+
name|XDR
operator|.
name|pad
argument_list|(
name|length
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write Java String as XDR string.    *     * Definition of XDR string from RFC 4506:    *     *<pre>    *    The standard defines a string of n (numbered 0 through n-1) ASCII    *    bytes to be the number n encoded as an unsigned integer (as described    *    above), and followed by the n bytes of the string.  Byte m of the    *    string always precedes byte m+1 of the string, and byte 0 of the    *    string always follows the string's length.  If n is not a multiple of    *    four, then the n bytes are followed by enough (0 to 3) residual zero    *    bytes, r, to make the total byte count a multiple of four.  Counted    *    byte strings are declared as follows:    *     *          string object<m>;    *       or    *          string object<>;    *     *    The constant m denotes an upper bound of the number of bytes that a    *    string may contain.  If m is not specified, as in the second    *    declaration, it is assumed to be (2**32) - 1, the maximum length.    *    The constant m would normally be found in a protocol specification.    *    For example, a filing protocol may state that a file name can be no    *    longer than 255 bytes, as follows:    *     *          string filename<255>;    *     *             0     1     2     3     4     5   ...    *          +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+    *          |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |    *          +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+    *          |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|    *                                  |<----n+r (where (n+r) mod 4 = 0)---->|    *                                                                   STRING    *    It is an error to encode a length greater than the maximum described    *    in the specification.    *</pre>    */
DECL|method|writeString (String data)
specifier|public
name|void
name|writeString
parameter_list|(
name|String
name|data
parameter_list|)
block|{
name|this
operator|.
name|writeVariableOpaque
argument_list|(
name|data
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|readString ()
specifier|public
name|String
name|readString
parameter_list|()
block|{
return|return
operator|new
name|String
argument_list|(
name|this
operator|.
name|readVariableOpaque
argument_list|()
argument_list|)
return|;
block|}
DECL|method|dump (PrintStream out)
specifier|public
name|void
name|dump
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytearr
operator|.
name|length
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|out
operator|.
name|println
argument_list|(
name|hex
argument_list|(
name|bytearr
index|[
name|i
index|]
argument_list|)
operator|+
literal|" "
operator|+
name|hex
argument_list|(
name|bytearr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|+
literal|" "
operator|+
name|hex
argument_list|(
name|bytearr
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
operator|+
literal|" "
operator|+
name|hex
argument_list|(
name|bytearr
index|[
name|i
operator|+
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getBytes ()
specifier|public
name|byte
index|[]
name|getBytes
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|bytearr
argument_list|,
name|bytearr
operator|.
name|length
argument_list|)
return|;
block|}
DECL|method|append (byte[] bytes, byte[] bytesToAdd)
specifier|public
specifier|static
name|byte
index|[]
name|append
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|byte
index|[]
name|bytesToAdd
parameter_list|)
block|{
name|byte
index|[]
name|newByteArray
init|=
operator|new
name|byte
index|[
name|bytes
operator|.
name|length
operator|+
name|bytesToAdd
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|newByteArray
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytesToAdd
argument_list|,
literal|0
argument_list|,
name|newByteArray
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|bytesToAdd
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|newByteArray
return|;
block|}
DECL|method|pad (int x, int y)
specifier|private
specifier|static
name|int
name|pad
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
return|return
name|x
operator|%
name|y
operator|==
literal|0
condition|?
literal|0
else|:
name|y
operator|-
operator|(
name|x
operator|%
name|y
operator|)
return|;
block|}
DECL|method|toBytes (int n)
specifier|static
name|byte
index|[]
name|toBytes
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|byte
index|[]
name|ret
init|=
block|{
call|(
name|byte
call|)
argument_list|(
operator|(
name|n
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
argument_list|)
block|,
call|(
name|byte
call|)
argument_list|(
operator|(
name|n
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
argument_list|)
block|,
call|(
name|byte
call|)
argument_list|(
operator|(
name|n
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
argument_list|)
block|,
call|(
name|byte
call|)
argument_list|(
name|n
operator|&
literal|0x000000ff
argument_list|)
block|}
decl_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|toShort (byte b)
specifier|private
specifier|static
name|short
name|toShort
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
return|return
name|b
operator|<
literal|0
condition|?
call|(
name|short
call|)
argument_list|(
name|b
operator|+
literal|256
argument_list|)
else|:
operator|(
name|short
operator|)
name|b
return|;
block|}
DECL|method|hex (byte b)
specifier|private
specifier|static
name|String
name|hex
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
return|return
literal|""
operator|+
name|HEXES
operator|.
name|charAt
argument_list|(
operator|(
name|b
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|)
operator|+
name|HEXES
operator|.
name|charAt
argument_list|(
operator|(
name|b
operator|&
literal|0x0F
operator|)
argument_list|)
return|;
block|}
DECL|method|recordMark (int size, boolean last)
specifier|private
specifier|static
name|byte
index|[]
name|recordMark
parameter_list|(
name|int
name|size
parameter_list|,
name|boolean
name|last
parameter_list|)
block|{
return|return
name|toBytes
argument_list|(
operator|!
name|last
condition|?
name|size
else|:
name|size
operator||
literal|0x80000000
argument_list|)
return|;
block|}
DECL|method|getVariableOpque (byte[] data)
specifier|public
specifier|static
name|byte
index|[]
name|getVariableOpque
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|toBytes
argument_list|(
name|data
operator|.
name|length
argument_list|)
decl_stmt|;
return|return
name|append
argument_list|(
name|bytes
argument_list|,
name|Arrays
operator|.
name|copyOf
argument_list|(
name|data
argument_list|,
name|data
operator|.
name|length
operator|+
name|XDR
operator|.
name|pad
argument_list|(
name|data
operator|.
name|length
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|fragmentSize (byte[] mark)
specifier|public
specifier|static
name|int
name|fragmentSize
parameter_list|(
name|byte
index|[]
name|mark
parameter_list|)
block|{
name|int
name|n
init|=
operator|(
name|XDR
operator|.
name|toShort
argument_list|(
name|mark
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|24
operator|)
operator|+
operator|(
name|XDR
operator|.
name|toShort
argument_list|(
name|mark
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|XDR
operator|.
name|toShort
argument_list|(
name|mark
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|XDR
operator|.
name|toShort
argument_list|(
name|mark
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
return|return
name|n
operator|&
literal|0x7fffffff
return|;
block|}
DECL|method|isLastFragment (byte[] mark)
specifier|public
specifier|static
name|boolean
name|isLastFragment
parameter_list|(
name|byte
index|[]
name|mark
parameter_list|)
block|{
name|int
name|n
init|=
operator|(
name|XDR
operator|.
name|toShort
argument_list|(
name|mark
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|24
operator|)
operator|+
operator|(
name|XDR
operator|.
name|toShort
argument_list|(
name|mark
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|XDR
operator|.
name|toShort
argument_list|(
name|mark
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|XDR
operator|.
name|toShort
argument_list|(
name|mark
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
return|return
operator|(
name|n
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
return|;
block|}
comment|/** check if the rest of data has more than<len> bytes */
DECL|method|verifyLength (XDR xdr, int len)
specifier|public
specifier|static
name|boolean
name|verifyLength
parameter_list|(
name|XDR
name|xdr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
name|xdr
operator|.
name|bytearr
operator|.
name|length
operator|-
name|xdr
operator|.
name|cursor
operator|)
operator|>=
name|len
return|;
block|}
comment|/** Write an XDR message to a TCP ChannelBuffer */
DECL|method|writeMessageTcp (XDR request, boolean last)
specifier|public
specifier|static
name|ChannelBuffer
name|writeMessageTcp
parameter_list|(
name|XDR
name|request
parameter_list|,
name|boolean
name|last
parameter_list|)
block|{
name|byte
index|[]
name|fragmentHeader
init|=
name|XDR
operator|.
name|recordMark
argument_list|(
name|request
operator|.
name|bytearr
operator|.
name|length
argument_list|,
name|last
argument_list|)
decl_stmt|;
name|ChannelBuffer
name|outBuf
init|=
name|ChannelBuffers
operator|.
name|buffer
argument_list|(
name|fragmentHeader
operator|.
name|length
operator|+
name|request
operator|.
name|bytearr
operator|.
name|length
argument_list|)
decl_stmt|;
name|outBuf
operator|.
name|writeBytes
argument_list|(
name|fragmentHeader
argument_list|)
expr_stmt|;
name|outBuf
operator|.
name|writeBytes
argument_list|(
name|request
operator|.
name|bytearr
argument_list|)
expr_stmt|;
return|return
name|outBuf
return|;
block|}
comment|/** Write an XDR message to a UDP ChannelBuffer */
DECL|method|writeMessageUdp (XDR response)
specifier|public
specifier|static
name|ChannelBuffer
name|writeMessageUdp
parameter_list|(
name|XDR
name|response
parameter_list|)
block|{
name|ChannelBuffer
name|outBuf
init|=
name|ChannelBuffers
operator|.
name|buffer
argument_list|(
name|response
operator|.
name|bytearr
operator|.
name|length
argument_list|)
decl_stmt|;
name|outBuf
operator|.
name|writeBytes
argument_list|(
name|response
operator|.
name|bytearr
argument_list|)
expr_stmt|;
return|return
name|outBuf
return|;
block|}
block|}
end_class

end_unit

