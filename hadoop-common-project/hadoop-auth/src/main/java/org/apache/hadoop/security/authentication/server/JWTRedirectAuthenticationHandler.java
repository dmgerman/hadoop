begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License. See accompanying LICENSE file.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security.authentication.server
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|server
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|Cookie
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|interfaces
operator|.
name|RSAPublicKey
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|client
operator|.
name|AuthenticationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|CertificateUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|nimbusds
operator|.
name|jwt
operator|.
name|SignedJWT
import|;
end_import

begin_import
import|import
name|com
operator|.
name|nimbusds
operator|.
name|jose
operator|.
name|JOSEException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|nimbusds
operator|.
name|jose
operator|.
name|JWSObject
import|;
end_import

begin_import
import|import
name|com
operator|.
name|nimbusds
operator|.
name|jose
operator|.
name|JWSVerifier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|nimbusds
operator|.
name|jose
operator|.
name|crypto
operator|.
name|RSASSAVerifier
import|;
end_import

begin_comment
comment|/**  * The {@link JWTRedirectAuthenticationHandler} extends  * AltKerberosAuthenticationHandler to add WebSSO behavior for UIs. The expected  * SSO token is a JsonWebToken (JWT). The supported algorithm is RS256 which  * uses PKI between the token issuer and consumer. The flow requires a redirect  * to a configured authentication server URL and a subsequent request with the  * expected JWT token. This token is cryptographically verified and validated.  * The user identity is then extracted from the token and used to create an  * AuthenticationToken - as expected by the AuthenticationFilter.  *  *<p>  * The supported configuration properties are:  *</p>  *<ul>  *<li>authentication.provider.url: the full URL to the authentication server.  * This is the URL that the handler will redirect the browser to in order to  * authenticate the user. It does not have a default value.</li>  *<li>public.key.pem: This is the PEM formatted public key of the issuer of the  * JWT token. It is required for verifying that the issuer is a trusted party.  * DO NOT include the PEM header and footer portions of the PEM encoded  * certificate. It does not have a default value.</li>  *<li>expected.jwt.audiences: This is a list of strings that identify  * acceptable audiences for the JWT token. The audience is a way for the issuer  * to indicate what entity/s that the token is intended for. Default value is  * null which indicates that all audiences will be accepted.</li>  *<li>jwt.cookie.name: the name of the cookie that contains the JWT token.  * Default value is "hadoop-jwt".</li>  *</ul>  */
end_comment

begin_class
DECL|class|JWTRedirectAuthenticationHandler
specifier|public
class|class
name|JWTRedirectAuthenticationHandler
extends|extends
name|AltKerberosAuthenticationHandler
block|{
DECL|field|LOG
specifier|private
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|JWTRedirectAuthenticationHandler
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|AUTHENTICATION_PROVIDER_URL
specifier|public
specifier|static
specifier|final
name|String
name|AUTHENTICATION_PROVIDER_URL
init|=
literal|"authentication.provider.url"
decl_stmt|;
DECL|field|PUBLIC_KEY_PEM
specifier|public
specifier|static
specifier|final
name|String
name|PUBLIC_KEY_PEM
init|=
literal|"public.key.pem"
decl_stmt|;
DECL|field|EXPECTED_JWT_AUDIENCES
specifier|public
specifier|static
specifier|final
name|String
name|EXPECTED_JWT_AUDIENCES
init|=
literal|"expected.jwt.audiences"
decl_stmt|;
DECL|field|JWT_COOKIE_NAME
specifier|public
specifier|static
specifier|final
name|String
name|JWT_COOKIE_NAME
init|=
literal|"jwt.cookie.name"
decl_stmt|;
DECL|field|ORIGINAL_URL_QUERY_PARAM
specifier|private
specifier|static
specifier|final
name|String
name|ORIGINAL_URL_QUERY_PARAM
init|=
literal|"originalUrl="
decl_stmt|;
DECL|field|authenticationProviderUrl
specifier|private
name|String
name|authenticationProviderUrl
init|=
literal|null
decl_stmt|;
DECL|field|publicKey
specifier|private
name|RSAPublicKey
name|publicKey
init|=
literal|null
decl_stmt|;
DECL|field|audiences
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|audiences
init|=
literal|null
decl_stmt|;
DECL|field|cookieName
specifier|private
name|String
name|cookieName
init|=
literal|"hadoop-jwt"
decl_stmt|;
comment|/**    * Primarily for testing, this provides a way to set the publicKey for    * signature verification without needing to get a PEM encoded value.    *    * @param pk publicKey for the token signtature verification    */
DECL|method|setPublicKey (RSAPublicKey pk)
specifier|public
name|void
name|setPublicKey
parameter_list|(
name|RSAPublicKey
name|pk
parameter_list|)
block|{
name|publicKey
operator|=
name|pk
expr_stmt|;
block|}
comment|/**    * Initializes the authentication handler instance.    *<p>    * This method is invoked by the {@link AuthenticationFilter#init} method.    *</p>    * @param config    *          configuration properties to initialize the handler.    *    * @throws ServletException    *           thrown if the handler could not be initialized.    */
annotation|@
name|Override
DECL|method|init (Properties config)
specifier|public
name|void
name|init
parameter_list|(
name|Properties
name|config
parameter_list|)
throws|throws
name|ServletException
block|{
name|super
operator|.
name|init
argument_list|(
name|config
argument_list|)
expr_stmt|;
comment|// setup the URL to redirect to for authentication
name|authenticationProviderUrl
operator|=
name|config
operator|.
name|getProperty
argument_list|(
name|AUTHENTICATION_PROVIDER_URL
argument_list|)
expr_stmt|;
if|if
condition|(
name|authenticationProviderUrl
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ServletException
argument_list|(
literal|"Authentication provider URL must not be null - configure: "
operator|+
name|AUTHENTICATION_PROVIDER_URL
argument_list|)
throw|;
block|}
comment|// setup the public key of the token issuer for verification
if|if
condition|(
name|publicKey
operator|==
literal|null
condition|)
block|{
name|String
name|pemPublicKey
init|=
name|config
operator|.
name|getProperty
argument_list|(
name|PUBLIC_KEY_PEM
argument_list|)
decl_stmt|;
if|if
condition|(
name|pemPublicKey
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ServletException
argument_list|(
literal|"Public key for signature validation must be provisioned."
argument_list|)
throw|;
block|}
name|publicKey
operator|=
name|CertificateUtil
operator|.
name|parseRSAPublicKey
argument_list|(
name|pemPublicKey
argument_list|)
expr_stmt|;
block|}
comment|// setup the list of valid audiences for token validation
name|String
name|auds
init|=
name|config
operator|.
name|getProperty
argument_list|(
name|EXPECTED_JWT_AUDIENCES
argument_list|)
decl_stmt|;
if|if
condition|(
name|auds
operator|!=
literal|null
condition|)
block|{
comment|// parse into the list
name|String
index|[]
name|audArray
init|=
name|auds
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|audiences
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|a
range|:
name|audArray
control|)
block|{
name|audiences
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
comment|// setup custom cookie name if configured
name|String
name|customCookieName
init|=
name|config
operator|.
name|getProperty
argument_list|(
name|JWT_COOKIE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|customCookieName
operator|!=
literal|null
condition|)
block|{
name|cookieName
operator|=
name|customCookieName
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|alternateAuthenticate (HttpServletRequest request, HttpServletResponse response)
specifier|public
name|AuthenticationToken
name|alternateAuthenticate
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|IOException
throws|,
name|AuthenticationException
block|{
name|AuthenticationToken
name|token
init|=
literal|null
decl_stmt|;
name|String
name|serializedJWT
init|=
literal|null
decl_stmt|;
name|HttpServletRequest
name|req
init|=
operator|(
name|HttpServletRequest
operator|)
name|request
decl_stmt|;
name|serializedJWT
operator|=
name|getJWTFromCookie
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|serializedJWT
operator|==
literal|null
condition|)
block|{
name|String
name|loginURL
init|=
name|constructLoginURL
argument_list|(
name|request
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"sending redirect to: "
operator|+
name|loginURL
argument_list|)
expr_stmt|;
operator|(
operator|(
name|HttpServletResponse
operator|)
name|response
operator|)
operator|.
name|sendRedirect
argument_list|(
name|loginURL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|userName
init|=
literal|null
decl_stmt|;
name|SignedJWT
name|jwtToken
init|=
literal|null
decl_stmt|;
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
try|try
block|{
name|jwtToken
operator|=
name|SignedJWT
operator|.
name|parse
argument_list|(
name|serializedJWT
argument_list|)
expr_stmt|;
name|valid
operator|=
name|validateToken
argument_list|(
name|jwtToken
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
name|userName
operator|=
name|jwtToken
operator|.
name|getJWTClaimsSet
argument_list|()
operator|.
name|getSubject
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"USERNAME: "
operator|+
name|userName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"jwtToken failed validation: "
operator|+
name|jwtToken
operator|.
name|serialize
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
comment|// unable to parse the token let's try and get another one
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to parse the JWT token"
argument_list|,
name|pe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Issuing AuthenticationToken for user."
argument_list|)
expr_stmt|;
name|token
operator|=
operator|new
name|AuthenticationToken
argument_list|(
name|userName
argument_list|,
name|userName
argument_list|,
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|loginURL
init|=
name|constructLoginURL
argument_list|(
name|request
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"token validation failed - sending redirect to: "
operator|+
name|loginURL
argument_list|)
expr_stmt|;
operator|(
operator|(
name|HttpServletResponse
operator|)
name|response
operator|)
operator|.
name|sendRedirect
argument_list|(
name|loginURL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|token
return|;
block|}
comment|/**    * Encapsulate the acquisition of the JWT token from HTTP cookies within the    * request.    *    * @param req servlet request to get the JWT token from    * @return serialized JWT token    */
DECL|method|getJWTFromCookie (HttpServletRequest req)
specifier|protected
name|String
name|getJWTFromCookie
parameter_list|(
name|HttpServletRequest
name|req
parameter_list|)
block|{
name|String
name|serializedJWT
init|=
literal|null
decl_stmt|;
name|Cookie
index|[]
name|cookies
init|=
name|req
operator|.
name|getCookies
argument_list|()
decl_stmt|;
if|if
condition|(
name|cookies
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Cookie
name|cookie
range|:
name|cookies
control|)
block|{
if|if
condition|(
name|cookieName
operator|.
name|equals
argument_list|(
name|cookie
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|cookieName
operator|+
literal|" cookie has been found and is being processed"
argument_list|)
expr_stmt|;
name|serializedJWT
operator|=
name|cookie
operator|.
name|getValue
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|serializedJWT
return|;
block|}
comment|/**    * Create the URL to be used for authentication of the user in the absence of    * a JWT token within the incoming request.    *    * @param request for getting the original request URL    * @return url to use as login url for redirect    */
annotation|@
name|VisibleForTesting
DECL|method|constructLoginURL (HttpServletRequest request)
name|String
name|constructLoginURL
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|)
block|{
name|String
name|delimiter
init|=
literal|"?"
decl_stmt|;
if|if
condition|(
name|authenticationProviderUrl
operator|.
name|contains
argument_list|(
literal|"?"
argument_list|)
condition|)
block|{
name|delimiter
operator|=
literal|"&"
expr_stmt|;
block|}
name|String
name|loginURL
init|=
name|authenticationProviderUrl
operator|+
name|delimiter
operator|+
name|ORIGINAL_URL_QUERY_PARAM
operator|+
name|request
operator|.
name|getRequestURL
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
name|getOriginalQueryString
argument_list|(
name|request
argument_list|)
decl_stmt|;
return|return
name|loginURL
return|;
block|}
DECL|method|getOriginalQueryString (HttpServletRequest request)
specifier|private
name|String
name|getOriginalQueryString
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|)
block|{
name|String
name|originalQueryString
init|=
name|request
operator|.
name|getQueryString
argument_list|()
decl_stmt|;
return|return
operator|(
name|originalQueryString
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
literal|"?"
operator|+
name|originalQueryString
return|;
block|}
comment|/**    * This method provides a single method for validating the JWT for use in    * request processing. It provides for the override of specific aspects of    * this implementation through submethods used within but also allows for the    * override of the entire token validation algorithm.    *    * @param jwtToken the token to validate    * @return true if valid    */
DECL|method|validateToken (SignedJWT jwtToken)
specifier|protected
name|boolean
name|validateToken
parameter_list|(
name|SignedJWT
name|jwtToken
parameter_list|)
block|{
name|boolean
name|sigValid
init|=
name|validateSignature
argument_list|(
name|jwtToken
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sigValid
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Signature could not be verified"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|audValid
init|=
name|validateAudiences
argument_list|(
name|jwtToken
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|audValid
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Audience validation failed."
argument_list|)
expr_stmt|;
block|}
name|boolean
name|expValid
init|=
name|validateExpiration
argument_list|(
name|jwtToken
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expValid
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Expiration validation failed."
argument_list|)
expr_stmt|;
block|}
return|return
name|sigValid
operator|&&
name|audValid
operator|&&
name|expValid
return|;
block|}
comment|/**    * Verify the signature of the JWT token in this method. This method depends    * on the public key that was established during init based upon the    * provisioned public key. Override this method in subclasses in order to    * customize the signature verification behavior.    *    * @param jwtToken the token that contains the signature to be validated    * @return valid true if signature verifies successfully; false otherwise    */
DECL|method|validateSignature (SignedJWT jwtToken)
specifier|protected
name|boolean
name|validateSignature
parameter_list|(
name|SignedJWT
name|jwtToken
parameter_list|)
block|{
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|JWSObject
operator|.
name|State
operator|.
name|SIGNED
operator|==
name|jwtToken
operator|.
name|getState
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"JWT token is in a SIGNED state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jwtToken
operator|.
name|getSignature
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"JWT token signature is not null"
argument_list|)
expr_stmt|;
try|try
block|{
name|JWSVerifier
name|verifier
init|=
operator|new
name|RSASSAVerifier
argument_list|(
name|publicKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|jwtToken
operator|.
name|verify
argument_list|(
name|verifier
argument_list|)
condition|)
block|{
name|valid
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"JWT token has been successfully verified"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"JWT signature verification failed."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|JOSEException
name|je
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while validating signature"
argument_list|,
name|je
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|valid
return|;
block|}
comment|/**    * Validate whether any of the accepted audience claims is present in the    * issued token claims list for audience. Override this method in subclasses    * in order to customize the audience validation behavior.    *    * @param jwtToken    *          the JWT token where the allowed audiences will be found    * @return true if an expected audience is present, otherwise false    */
DECL|method|validateAudiences (SignedJWT jwtToken)
specifier|protected
name|boolean
name|validateAudiences
parameter_list|(
name|SignedJWT
name|jwtToken
parameter_list|)
block|{
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tokenAudienceList
init|=
name|jwtToken
operator|.
name|getJWTClaimsSet
argument_list|()
operator|.
name|getAudience
argument_list|()
decl_stmt|;
comment|// if there were no expected audiences configured then just
comment|// consider any audience acceptable
if|if
condition|(
name|audiences
operator|==
literal|null
condition|)
block|{
name|valid
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// if any of the configured audiences is found then consider it
comment|// acceptable
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|aud
range|:
name|tokenAudienceList
control|)
block|{
if|if
condition|(
name|audiences
operator|.
name|contains
argument_list|(
name|aud
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"JWT token audience has been successfully validated"
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"JWT audience validation failed."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to parse the JWT token."
argument_list|,
name|pe
argument_list|)
expr_stmt|;
block|}
return|return
name|valid
return|;
block|}
comment|/**    * Validate that the expiration time of the JWT token has not been violated.    * If it has then throw an AuthenticationException. Override this method in    * subclasses in order to customize the expiration validation behavior.    *    * @param jwtToken the token that contains the expiration date to validate    * @return valid true if the token has not expired; false otherwise    */
DECL|method|validateExpiration (SignedJWT jwtToken)
specifier|protected
name|boolean
name|validateExpiration
parameter_list|(
name|SignedJWT
name|jwtToken
parameter_list|)
block|{
name|boolean
name|valid
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Date
name|expires
init|=
name|jwtToken
operator|.
name|getJWTClaimsSet
argument_list|()
operator|.
name|getExpirationTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|expires
operator|==
literal|null
operator|||
operator|new
name|Date
argument_list|()
operator|.
name|before
argument_list|(
name|expires
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"JWT token expiration date has been "
operator|+
literal|"successfully validated"
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"JWT expiration date validation failed."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"JWT expiration date validation failed."
argument_list|,
name|pe
argument_list|)
expr_stmt|;
block|}
return|return
name|valid
return|;
block|}
block|}
end_class

end_unit

