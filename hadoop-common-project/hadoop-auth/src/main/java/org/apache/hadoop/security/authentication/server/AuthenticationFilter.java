begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License. See accompanying LICENSE file.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security.authentication.server
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|server
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|client
operator|.
name|AuthenticatedURL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|client
operator|.
name|AuthenticationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|client
operator|.
name|KerberosAuthenticator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|FilterChain
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|FilterConfig
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletResponse
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|Cookie
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequestWrapper
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Principal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * The {@link AuthenticationFilter} enables protecting web application  * resources with different (pluggable)  * authentication mechanisms and signer secret providers.  *<p>  * Additional authentication mechanisms are supported via the {@link AuthenticationHandler} interface.  *<p>  * This filter delegates to the configured authentication handler for authentication and once it obtains an  * {@link AuthenticationToken} from it, sets a signed HTTP cookie with the token. For client requests  * that provide the signed HTTP cookie, it verifies the validity of the cookie, extracts the user information  * and lets the request proceed to the target resource.  *<p>  * The rest of the configuration properties are specific to the {@link AuthenticationHandler} implementation and the  * {@link AuthenticationFilter} will take all the properties that start with the prefix #PREFIX#, it will remove  * the prefix from it and it will pass them to the the authentication handler for initialization. Properties that do  * not start with the prefix will not be passed to the authentication handler initialization.  *<p>  * Details of the configurations are listed on<a href="../../../../../../../Configuration.html">Configuration Page</a>  *<p>  * The "zookeeper" implementation has additional configuration properties that  * must be specified; see {@link ZKSignerSecretProvider} for details.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|AuthenticationFilter
specifier|public
class|class
name|AuthenticationFilter
implements|implements
name|Filter
block|{
DECL|field|LOG
specifier|private
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AuthenticationFilter
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Constant for the property that specifies the configuration prefix.    */
DECL|field|CONFIG_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|CONFIG_PREFIX
init|=
literal|"config.prefix"
decl_stmt|;
comment|/**    * Constant for the property that specifies the authentication handler to use.    */
DECL|field|AUTH_TYPE
specifier|public
specifier|static
specifier|final
name|String
name|AUTH_TYPE
init|=
literal|"type"
decl_stmt|;
comment|/**    * Constant for the property that specifies the secret to use for signing the HTTP Cookies.    */
DECL|field|SIGNATURE_SECRET
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_SECRET
init|=
literal|"signature.secret"
decl_stmt|;
DECL|field|SIGNATURE_SECRET_FILE
specifier|public
specifier|static
specifier|final
name|String
name|SIGNATURE_SECRET_FILE
init|=
name|SIGNATURE_SECRET
operator|+
literal|".file"
decl_stmt|;
comment|/**    * Constant for the configuration property    * that indicates the max inactive interval of the generated token.    */
specifier|public
specifier|static
specifier|final
name|String
DECL|field|AUTH_TOKEN_MAX_INACTIVE_INTERVAL
name|AUTH_TOKEN_MAX_INACTIVE_INTERVAL
init|=
literal|"token.max-inactive-interval"
decl_stmt|;
comment|/**    * Constant for the configuration property that indicates the validity of the generated token.    */
DECL|field|AUTH_TOKEN_VALIDITY
specifier|public
specifier|static
specifier|final
name|String
name|AUTH_TOKEN_VALIDITY
init|=
literal|"token.validity"
decl_stmt|;
comment|/**    * Constant for the configuration property that indicates the domain to use in the HTTP cookie.    */
DECL|field|COOKIE_DOMAIN
specifier|public
specifier|static
specifier|final
name|String
name|COOKIE_DOMAIN
init|=
literal|"cookie.domain"
decl_stmt|;
comment|/**    * Constant for the configuration property that indicates the path to use in the HTTP cookie.    */
DECL|field|COOKIE_PATH
specifier|public
specifier|static
specifier|final
name|String
name|COOKIE_PATH
init|=
literal|"cookie.path"
decl_stmt|;
comment|/**    * Constant for the configuration property    * that indicates the persistence of the HTTP cookie.    */
DECL|field|COOKIE_PERSISTENT
specifier|public
specifier|static
specifier|final
name|String
name|COOKIE_PERSISTENT
init|=
literal|"cookie.persistent"
decl_stmt|;
comment|/**    * Constant for the configuration property that indicates the name of the    * SignerSecretProvider class to use.    * Possible values are: "file", "random", "zookeeper", or a classname.    * If not specified, the "file" implementation will be used with    * SIGNATURE_SECRET_FILE; and if that's not specified, the "random"    * implementation will be used.    */
DECL|field|SIGNER_SECRET_PROVIDER
specifier|public
specifier|static
specifier|final
name|String
name|SIGNER_SECRET_PROVIDER
init|=
literal|"signer.secret.provider"
decl_stmt|;
comment|/**    * Constant for the ServletContext attribute that can be used for providing a    * custom implementation of the SignerSecretProvider. Note that the class    * should already be initialized. If not specified, SIGNER_SECRET_PROVIDER    * will be used.    */
DECL|field|SIGNER_SECRET_PROVIDER_ATTRIBUTE
specifier|public
specifier|static
specifier|final
name|String
name|SIGNER_SECRET_PROVIDER_ATTRIBUTE
init|=
literal|"signer.secret.provider.object"
decl_stmt|;
DECL|field|config
specifier|private
name|Properties
name|config
decl_stmt|;
DECL|field|signer
specifier|private
name|Signer
name|signer
decl_stmt|;
DECL|field|secretProvider
specifier|private
name|SignerSecretProvider
name|secretProvider
decl_stmt|;
DECL|field|authHandler
specifier|private
name|AuthenticationHandler
name|authHandler
decl_stmt|;
DECL|field|maxInactiveInterval
specifier|private
name|long
name|maxInactiveInterval
decl_stmt|;
DECL|field|validity
specifier|private
name|long
name|validity
decl_stmt|;
DECL|field|cookieDomain
specifier|private
name|String
name|cookieDomain
decl_stmt|;
DECL|field|cookiePath
specifier|private
name|String
name|cookiePath
decl_stmt|;
DECL|field|isCookiePersistent
specifier|private
name|boolean
name|isCookiePersistent
decl_stmt|;
DECL|field|destroySecretProvider
specifier|private
name|boolean
name|destroySecretProvider
decl_stmt|;
comment|/**    *<p>Initializes the authentication filter and signer secret provider.</p>    * It instantiates and initializes the specified {@link    * AuthenticationHandler}.    *    * @param filterConfig filter configuration.    *    * @throws ServletException thrown if the filter or the authentication handler could not be initialized properly.    */
annotation|@
name|Override
DECL|method|init (FilterConfig filterConfig)
specifier|public
name|void
name|init
parameter_list|(
name|FilterConfig
name|filterConfig
parameter_list|)
throws|throws
name|ServletException
block|{
name|String
name|configPrefix
init|=
name|filterConfig
operator|.
name|getInitParameter
argument_list|(
name|CONFIG_PREFIX
argument_list|)
decl_stmt|;
name|configPrefix
operator|=
operator|(
name|configPrefix
operator|!=
literal|null
operator|)
condition|?
name|configPrefix
operator|+
literal|"."
else|:
literal|""
expr_stmt|;
name|config
operator|=
name|getConfiguration
argument_list|(
name|configPrefix
argument_list|,
name|filterConfig
argument_list|)
expr_stmt|;
name|String
name|authHandlerName
init|=
name|config
operator|.
name|getProperty
argument_list|(
name|AUTH_TYPE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|String
name|authHandlerClassName
decl_stmt|;
if|if
condition|(
name|authHandlerName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ServletException
argument_list|(
literal|"Authentication type must be specified: "
operator|+
name|PseudoAuthenticationHandler
operator|.
name|TYPE
operator|+
literal|"|"
operator|+
name|KerberosAuthenticationHandler
operator|.
name|TYPE
operator|+
literal|"|<class>"
argument_list|)
throw|;
block|}
name|authHandlerClassName
operator|=
name|AuthenticationHandlerUtil
operator|.
name|getAuthenticationHandlerClassName
argument_list|(
name|authHandlerName
argument_list|)
expr_stmt|;
name|maxInactiveInterval
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|config
operator|.
name|getProperty
argument_list|(
name|AUTH_TOKEN_MAX_INACTIVE_INTERVAL
argument_list|,
literal|"-1"
argument_list|)
argument_list|)
expr_stmt|;
comment|// By default, disable.
if|if
condition|(
name|maxInactiveInterval
operator|>
literal|0
condition|)
block|{
name|maxInactiveInterval
operator|*=
literal|1000
expr_stmt|;
block|}
name|validity
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|config
operator|.
name|getProperty
argument_list|(
name|AUTH_TOKEN_VALIDITY
argument_list|,
literal|"36000"
argument_list|)
argument_list|)
operator|*
literal|1000
expr_stmt|;
comment|//10 hours
name|initializeSecretProvider
argument_list|(
name|filterConfig
argument_list|)
expr_stmt|;
name|initializeAuthHandler
argument_list|(
name|authHandlerClassName
argument_list|,
name|filterConfig
argument_list|)
expr_stmt|;
name|cookieDomain
operator|=
name|config
operator|.
name|getProperty
argument_list|(
name|COOKIE_DOMAIN
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|cookiePath
operator|=
name|config
operator|.
name|getProperty
argument_list|(
name|COOKIE_PATH
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|isCookiePersistent
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|config
operator|.
name|getProperty
argument_list|(
name|COOKIE_PERSISTENT
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|initializeAuthHandler (String authHandlerClassName, FilterConfig filterConfig)
specifier|protected
name|void
name|initializeAuthHandler
parameter_list|(
name|String
name|authHandlerClassName
parameter_list|,
name|FilterConfig
name|filterConfig
parameter_list|)
throws|throws
name|ServletException
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|klass
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|authHandlerClassName
argument_list|)
decl_stmt|;
name|authHandler
operator|=
operator|(
name|AuthenticationHandler
operator|)
name|klass
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|authHandler
operator|.
name|init
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
decl||
name|InstantiationException
decl||
name|IllegalAccessException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|ServletException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|initializeSecretProvider (FilterConfig filterConfig)
specifier|protected
name|void
name|initializeSecretProvider
parameter_list|(
name|FilterConfig
name|filterConfig
parameter_list|)
throws|throws
name|ServletException
block|{
name|secretProvider
operator|=
operator|(
name|SignerSecretProvider
operator|)
name|filterConfig
operator|.
name|getServletContext
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|SIGNER_SECRET_PROVIDER_ATTRIBUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|secretProvider
operator|==
literal|null
condition|)
block|{
comment|// As tomcat cannot specify the provider object in the configuration.
comment|// It'll go into this path
try|try
block|{
name|secretProvider
operator|=
name|constructSecretProvider
argument_list|(
name|filterConfig
operator|.
name|getServletContext
argument_list|()
argument_list|,
name|config
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|destroySecretProvider
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|ServletException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
name|signer
operator|=
operator|new
name|Signer
argument_list|(
name|secretProvider
argument_list|)
expr_stmt|;
block|}
DECL|method|constructSecretProvider ( ServletContext ctx, Properties config, boolean disallowFallbackToRandomSecretProvider)
specifier|public
specifier|static
name|SignerSecretProvider
name|constructSecretProvider
parameter_list|(
name|ServletContext
name|ctx
parameter_list|,
name|Properties
name|config
parameter_list|,
name|boolean
name|disallowFallbackToRandomSecretProvider
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|name
init|=
name|config
operator|.
name|getProperty
argument_list|(
name|SIGNER_SECRET_PROVIDER
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|long
name|validity
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|config
operator|.
name|getProperty
argument_list|(
name|AUTH_TOKEN_VALIDITY
argument_list|,
literal|"36000"
argument_list|)
argument_list|)
operator|*
literal|1000
decl_stmt|;
if|if
condition|(
operator|!
name|disallowFallbackToRandomSecretProvider
operator|&&
literal|"file"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|&&
name|config
operator|.
name|getProperty
argument_list|(
name|SIGNATURE_SECRET_FILE
argument_list|)
operator|==
literal|null
condition|)
block|{
name|name
operator|=
literal|"random"
expr_stmt|;
block|}
name|SignerSecretProvider
name|provider
decl_stmt|;
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|provider
operator|=
operator|new
name|FileSignerSecretProvider
argument_list|()
expr_stmt|;
try|try
block|{
name|provider
operator|.
name|init
argument_list|(
name|config
argument_list|,
name|ctx
argument_list|,
name|validity
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|disallowFallbackToRandomSecretProvider
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to initialize FileSignerSecretProvider, "
operator|+
literal|"falling back to use random secrets."
argument_list|)
expr_stmt|;
name|provider
operator|=
operator|new
name|RandomSignerSecretProvider
argument_list|()
expr_stmt|;
name|provider
operator|.
name|init
argument_list|(
name|config
argument_list|,
name|ctx
argument_list|,
name|validity
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
literal|"random"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|provider
operator|=
operator|new
name|RandomSignerSecretProvider
argument_list|()
expr_stmt|;
name|provider
operator|.
name|init
argument_list|(
name|config
argument_list|,
name|ctx
argument_list|,
name|validity
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"zookeeper"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|provider
operator|=
operator|new
name|ZKSignerSecretProvider
argument_list|()
expr_stmt|;
name|provider
operator|.
name|init
argument_list|(
name|config
argument_list|,
name|ctx
argument_list|,
name|validity
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|provider
operator|=
operator|(
name|SignerSecretProvider
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|name
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|provider
operator|.
name|init
argument_list|(
name|config
argument_list|,
name|ctx
argument_list|,
name|validity
argument_list|)
expr_stmt|;
block|}
return|return
name|provider
return|;
block|}
comment|/**    * Returns the configuration properties of the {@link AuthenticationFilter}    * without the prefix. The returned properties are the same that the    * {@link #getConfiguration(String, FilterConfig)} method returned.    *    * @return the configuration properties.    */
DECL|method|getConfiguration ()
specifier|protected
name|Properties
name|getConfiguration
parameter_list|()
block|{
return|return
name|config
return|;
block|}
comment|/**    * Returns the authentication handler being used.    *    * @return the authentication handler being used.    */
DECL|method|getAuthenticationHandler ()
specifier|protected
name|AuthenticationHandler
name|getAuthenticationHandler
parameter_list|()
block|{
return|return
name|authHandler
return|;
block|}
comment|/**    * Returns if a random secret is being used.    *    * @return if a random secret is being used.    */
DECL|method|isRandomSecret ()
specifier|protected
name|boolean
name|isRandomSecret
parameter_list|()
block|{
return|return
name|secretProvider
operator|.
name|getClass
argument_list|()
operator|==
name|RandomSignerSecretProvider
operator|.
name|class
return|;
block|}
comment|/**    * Returns if a custom implementation of a SignerSecretProvider is being used.    *    * @return if a custom implementation of a SignerSecretProvider is being used.    */
DECL|method|isCustomSignerSecretProvider ()
specifier|protected
name|boolean
name|isCustomSignerSecretProvider
parameter_list|()
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|secretProvider
operator|.
name|getClass
argument_list|()
decl_stmt|;
return|return
name|clazz
operator|!=
name|FileSignerSecretProvider
operator|.
name|class
operator|&&
name|clazz
operator|!=
name|RandomSignerSecretProvider
operator|.
name|class
operator|&&
name|clazz
operator|!=
name|ZKSignerSecretProvider
operator|.
name|class
return|;
block|}
comment|/**    * Returns the max inactive interval time of the generated tokens.    *    * @return the max inactive interval time of the generated tokens in seconds.    */
DECL|method|getMaxInactiveInterval ()
specifier|protected
name|long
name|getMaxInactiveInterval
parameter_list|()
block|{
return|return
name|maxInactiveInterval
operator|/
literal|1000
return|;
block|}
comment|/**    * Returns the validity time of the generated tokens.    *    * @return the validity time of the generated tokens, in seconds.    */
DECL|method|getValidity ()
specifier|protected
name|long
name|getValidity
parameter_list|()
block|{
return|return
name|validity
operator|/
literal|1000
return|;
block|}
comment|/**    * Returns the cookie domain to use for the HTTP cookie.    *    * @return the cookie domain to use for the HTTP cookie.    */
DECL|method|getCookieDomain ()
specifier|protected
name|String
name|getCookieDomain
parameter_list|()
block|{
return|return
name|cookieDomain
return|;
block|}
comment|/**    * Returns the cookie path to use for the HTTP cookie.    *    * @return the cookie path to use for the HTTP cookie.    */
DECL|method|getCookiePath ()
specifier|protected
name|String
name|getCookiePath
parameter_list|()
block|{
return|return
name|cookiePath
return|;
block|}
comment|/**    * Returns the cookie persistence to use for the HTTP cookie.    *    * @return the cookie persistence to use for the HTTP cookie.    */
DECL|method|isCookiePersistent ()
specifier|protected
name|boolean
name|isCookiePersistent
parameter_list|()
block|{
return|return
name|isCookiePersistent
return|;
block|}
comment|/**    * Destroys the filter.    *<p>    * It invokes the {@link AuthenticationHandler#destroy()} method to release any resources it may hold.    */
annotation|@
name|Override
DECL|method|destroy ()
specifier|public
name|void
name|destroy
parameter_list|()
block|{
if|if
condition|(
name|authHandler
operator|!=
literal|null
condition|)
block|{
name|authHandler
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|authHandler
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|secretProvider
operator|!=
literal|null
operator|&&
name|destroySecretProvider
condition|)
block|{
name|secretProvider
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|secretProvider
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Returns the filtered configuration (only properties starting with the specified prefix). The property keys    * are also trimmed from the prefix. The returned {@link Properties} object is used to initialized the    * {@link AuthenticationHandler}.    *<p>    * This method can be overriden by subclasses to obtain the configuration from other configuration source than    * the web.xml file.    *    * @param configPrefix configuration prefix to use for extracting configuration properties.    * @param filterConfig filter configuration object    *    * @return the configuration to be used with the {@link AuthenticationHandler} instance.    *    * @throws ServletException thrown if the configuration could not be created.    */
DECL|method|getConfiguration (String configPrefix, FilterConfig filterConfig)
specifier|protected
name|Properties
name|getConfiguration
parameter_list|(
name|String
name|configPrefix
parameter_list|,
name|FilterConfig
name|filterConfig
parameter_list|)
throws|throws
name|ServletException
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|Enumeration
argument_list|<
name|?
argument_list|>
name|names
init|=
name|filterConfig
operator|.
name|getInitParameterNames
argument_list|()
decl_stmt|;
while|while
condition|(
name|names
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|String
name|name
init|=
operator|(
name|String
operator|)
name|names
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|configPrefix
argument_list|)
condition|)
block|{
name|String
name|value
init|=
name|filterConfig
operator|.
name|getInitParameter
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|props
operator|.
name|put
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|configPrefix
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|props
return|;
block|}
comment|/**    * Returns the full URL of the request including the query string.    *<p>    * Used as a convenience method for logging purposes.    *    * @param request the request object.    *    * @return the full URL of the request including the query string.    */
DECL|method|getRequestURL (HttpServletRequest request)
specifier|protected
name|String
name|getRequestURL
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
name|request
operator|.
name|getRequestURL
argument_list|()
decl_stmt|;
if|if
condition|(
name|request
operator|.
name|getQueryString
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"?"
argument_list|)
operator|.
name|append
argument_list|(
name|request
operator|.
name|getQueryString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns the {@link AuthenticationToken} for the request.    *<p>    * It looks at the received HTTP cookies and extracts the value of the {@link AuthenticatedURL#AUTH_COOKIE}    * if present. It verifies the signature and if correct it creates the {@link AuthenticationToken} and returns    * it.    *<p>    * If this method returns<code>null</code> the filter will invoke the configured {@link AuthenticationHandler}    * to perform user authentication.    *    * @param request request object.    *    * @return the Authentication token if the request is authenticated,<code>null</code> otherwise.    *    * @throws IOException thrown if an IO error occurred.    * @throws AuthenticationException thrown if the token is invalid or if it has expired.    */
DECL|method|getToken (HttpServletRequest request)
specifier|protected
name|AuthenticationToken
name|getToken
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|)
throws|throws
name|IOException
throws|,
name|AuthenticationException
block|{
name|AuthenticationToken
name|token
init|=
literal|null
decl_stmt|;
name|String
name|tokenStr
init|=
literal|null
decl_stmt|;
name|Cookie
index|[]
name|cookies
init|=
name|request
operator|.
name|getCookies
argument_list|()
decl_stmt|;
if|if
condition|(
name|cookies
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Cookie
name|cookie
range|:
name|cookies
control|)
block|{
if|if
condition|(
name|cookie
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|AuthenticatedURL
operator|.
name|AUTH_COOKIE
argument_list|)
condition|)
block|{
name|tokenStr
operator|=
name|cookie
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|tokenStr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AuthenticationException
argument_list|(
literal|"Unauthorized access"
argument_list|)
throw|;
block|}
try|try
block|{
name|tokenStr
operator|=
name|signer
operator|.
name|verifyAndExtract
argument_list|(
name|tokenStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SignerException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|AuthenticationException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|tokenStr
operator|!=
literal|null
condition|)
block|{
name|token
operator|=
name|AuthenticationToken
operator|.
name|parse
argument_list|(
name|tokenStr
argument_list|)
expr_stmt|;
name|boolean
name|match
init|=
name|verifyTokenType
argument_list|(
name|getAuthenticationHandler
argument_list|()
argument_list|,
name|token
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
block|{
throw|throw
operator|new
name|AuthenticationException
argument_list|(
literal|"Invalid AuthenticationToken type"
argument_list|)
throw|;
block|}
if|if
condition|(
name|token
operator|.
name|isExpired
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AuthenticationException
argument_list|(
literal|"AuthenticationToken expired"
argument_list|)
throw|;
block|}
block|}
return|return
name|token
return|;
block|}
comment|/**    * This method verifies if the specified token type matches one of the the    * token types supported by a specified {@link AuthenticationHandler}. This    * method is specifically designed to work with    * {@link CompositeAuthenticationHandler} implementation which supports    * multiple authentication schemes while the {@link AuthenticationHandler}    * interface supports a single type via    * {@linkplain AuthenticationHandler#getType()} method.    *    * @param handler The authentication handler whose supported token types    *                should be used for verification.    * @param token   The token whose type needs to be verified.    * @return true   If the token type matches one of the supported token types    *         false  Otherwise    */
DECL|method|verifyTokenType (AuthenticationHandler handler, AuthenticationToken token)
specifier|protected
name|boolean
name|verifyTokenType
parameter_list|(
name|AuthenticationHandler
name|handler
parameter_list|,
name|AuthenticationToken
name|token
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|handler
operator|instanceof
name|CompositeAuthenticationHandler
operator|)
condition|)
block|{
return|return
name|handler
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|token
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|boolean
name|match
init|=
literal|false
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|tokenTypes
init|=
operator|(
operator|(
name|CompositeAuthenticationHandler
operator|)
name|handler
operator|)
operator|.
name|getTokenTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|tokenType
range|:
name|tokenTypes
control|)
block|{
if|if
condition|(
name|tokenType
operator|.
name|equals
argument_list|(
name|token
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|match
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
return|return
name|match
return|;
block|}
comment|/**    * If the request has a valid authentication token it allows the request to continue to the target resource,    * otherwise it triggers an authentication sequence using the configured {@link AuthenticationHandler}.    *    * @param request the request object.    * @param response the response object.    * @param filterChain the filter chain object.    *    * @throws IOException thrown if an IO error occurred.    * @throws ServletException thrown if a processing error occurred.    */
annotation|@
name|Override
DECL|method|doFilter (ServletRequest request, ServletResponse response, FilterChain filterChain)
specifier|public
name|void
name|doFilter
parameter_list|(
name|ServletRequest
name|request
parameter_list|,
name|ServletResponse
name|response
parameter_list|,
name|FilterChain
name|filterChain
parameter_list|)
throws|throws
name|IOException
throws|,
name|ServletException
block|{
name|boolean
name|unauthorizedResponse
init|=
literal|true
decl_stmt|;
name|int
name|errCode
init|=
name|HttpServletResponse
operator|.
name|SC_UNAUTHORIZED
decl_stmt|;
name|AuthenticationException
name|authenticationEx
init|=
literal|null
decl_stmt|;
name|HttpServletRequest
name|httpRequest
init|=
operator|(
name|HttpServletRequest
operator|)
name|request
decl_stmt|;
name|HttpServletResponse
name|httpResponse
init|=
operator|(
name|HttpServletResponse
operator|)
name|response
decl_stmt|;
name|boolean
name|isHttps
init|=
literal|"https"
operator|.
name|equals
argument_list|(
name|httpRequest
operator|.
name|getScheme
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|newToken
init|=
literal|false
decl_stmt|;
name|AuthenticationToken
name|token
decl_stmt|;
try|try
block|{
name|token
operator|=
name|getToken
argument_list|(
name|httpRequest
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got token {} from httpRequest {}"
argument_list|,
name|token
argument_list|,
name|getRequestURL
argument_list|(
name|httpRequest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|AuthenticationException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"AuthenticationToken ignored: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// will be sent back in a 401 unless filter authenticates
name|authenticationEx
operator|=
name|ex
expr_stmt|;
name|token
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|authHandler
operator|.
name|managementOperation
argument_list|(
name|token
argument_list|,
name|httpRequest
argument_list|,
name|httpResponse
argument_list|)
condition|)
block|{
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Request [{}] triggering authentication. handler: {}"
argument_list|,
name|getRequestURL
argument_list|(
name|httpRequest
argument_list|)
argument_list|,
name|authHandler
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|authHandler
operator|.
name|authenticate
argument_list|(
name|httpRequest
argument_list|,
name|httpResponse
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
operator|&&
name|token
operator|!=
name|AuthenticationToken
operator|.
name|ANONYMOUS
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|getMaxInactives
argument_list|()
operator|>
literal|0
condition|)
block|{
name|token
operator|.
name|setMaxInactives
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|getMaxInactiveInterval
argument_list|()
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|.
name|getExpires
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|token
operator|.
name|setExpires
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|getValidity
argument_list|()
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
name|newToken
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|unauthorizedResponse
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Request [{}] user [{}] authenticated"
argument_list|,
name|getRequestURL
argument_list|(
name|httpRequest
argument_list|)
argument_list|,
name|token
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|AuthenticationToken
name|authToken
init|=
name|token
decl_stmt|;
name|httpRequest
operator|=
operator|new
name|HttpServletRequestWrapper
argument_list|(
name|httpRequest
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|String
name|getAuthType
parameter_list|()
block|{
return|return
name|authToken
operator|.
name|getType
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getRemoteUser
parameter_list|()
block|{
return|return
name|authToken
operator|.
name|getUserName
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Principal
name|getUserPrincipal
parameter_list|()
block|{
return|return
operator|(
name|authToken
operator|!=
name|AuthenticationToken
operator|.
name|ANONYMOUS
operator|)
condition|?
name|authToken
else|:
literal|null
return|;
block|}
block|}
expr_stmt|;
comment|// If cookie persistence is configured to false,
comment|// it means the cookie will be a session cookie.
comment|// If the token is an old one, renew the its maxInactiveInterval.
if|if
condition|(
operator|!
name|newToken
operator|&&
operator|!
name|isCookiePersistent
argument_list|()
operator|&&
name|getMaxInactiveInterval
argument_list|()
operator|>
literal|0
condition|)
block|{
name|token
operator|.
name|setMaxInactives
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|getMaxInactiveInterval
argument_list|()
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|token
operator|.
name|setExpires
argument_list|(
name|token
operator|.
name|getExpires
argument_list|()
argument_list|)
expr_stmt|;
name|newToken
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|newToken
operator|&&
operator|!
name|token
operator|.
name|isExpired
argument_list|()
operator|&&
name|token
operator|!=
name|AuthenticationToken
operator|.
name|ANONYMOUS
condition|)
block|{
name|String
name|signedToken
init|=
name|signer
operator|.
name|sign
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|createAuthCookie
argument_list|(
name|httpResponse
argument_list|,
name|signedToken
argument_list|,
name|getCookieDomain
argument_list|()
argument_list|,
name|getCookiePath
argument_list|()
argument_list|,
name|token
operator|.
name|getExpires
argument_list|()
argument_list|,
name|isCookiePersistent
argument_list|()
argument_list|,
name|isHttps
argument_list|)
expr_stmt|;
block|}
name|doFilter
argument_list|(
name|filterChain
argument_list|,
name|httpRequest
argument_list|,
name|httpResponse
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"managementOperation returned false for request {}."
operator|+
literal|" token: {}"
argument_list|,
name|getRequestURL
argument_list|(
name|httpRequest
argument_list|)
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|unauthorizedResponse
operator|=
literal|false
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|AuthenticationException
name|ex
parameter_list|)
block|{
comment|// exception from the filter itself is fatal
name|errCode
operator|=
name|HttpServletResponse
operator|.
name|SC_FORBIDDEN
expr_stmt|;
name|authenticationEx
operator|=
name|ex
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Authentication exception: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Authentication exception: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unauthorizedResponse
condition|)
block|{
if|if
condition|(
operator|!
name|httpResponse
operator|.
name|isCommitted
argument_list|()
condition|)
block|{
name|createAuthCookie
argument_list|(
name|httpResponse
argument_list|,
literal|""
argument_list|,
name|getCookieDomain
argument_list|()
argument_list|,
name|getCookiePath
argument_list|()
argument_list|,
literal|0
argument_list|,
name|isCookiePersistent
argument_list|()
argument_list|,
name|isHttps
argument_list|)
expr_stmt|;
comment|// If response code is 401. Then WWW-Authenticate Header should be
comment|// present.. reset to 403 if not found..
if|if
condition|(
operator|(
name|errCode
operator|==
name|HttpServletResponse
operator|.
name|SC_UNAUTHORIZED
operator|)
operator|&&
operator|(
operator|!
name|httpResponse
operator|.
name|containsHeader
argument_list|(
name|KerberosAuthenticator
operator|.
name|WWW_AUTHENTICATE
argument_list|)
operator|)
condition|)
block|{
name|errCode
operator|=
name|HttpServletResponse
operator|.
name|SC_FORBIDDEN
expr_stmt|;
block|}
if|if
condition|(
name|authenticationEx
operator|==
literal|null
condition|)
block|{
name|httpResponse
operator|.
name|sendError
argument_list|(
name|errCode
argument_list|,
literal|"Authentication required"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|httpResponse
operator|.
name|sendError
argument_list|(
name|errCode
argument_list|,
name|authenticationEx
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Delegates call to the servlet filter chain. Sub-classes my override this    * method to perform pre and post tasks.    *    * @param filterChain the filter chain object.    * @param request the request object.    * @param response the response object.    *    * @throws IOException thrown if an IO error occurred.    * @throws ServletException thrown if a processing error occurred.    */
DECL|method|doFilter (FilterChain filterChain, HttpServletRequest request, HttpServletResponse response)
specifier|protected
name|void
name|doFilter
parameter_list|(
name|FilterChain
name|filterChain
parameter_list|,
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|IOException
throws|,
name|ServletException
block|{
name|filterChain
operator|.
name|doFilter
argument_list|(
name|request
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates the Hadoop authentication HTTP cookie.    *    * @param resp the response object.    * @param token authentication token for the cookie.    * @param domain the cookie domain.    * @param path the cookie path.    * @param expires UNIX timestamp that indicates the expire date of the    *                cookie. It has no effect if its value&lt; 0.    * @param isSecure is the cookie secure?    * @param isCookiePersistent whether the cookie is persistent or not.    *    * XXX the following code duplicate some logic in Jetty / Servlet API,    * because of the fact that Hadoop is stuck at servlet 2.5 and jetty 6    * right now.    */
DECL|method|createAuthCookie (HttpServletResponse resp, String token, String domain, String path, long expires, boolean isCookiePersistent, boolean isSecure)
specifier|public
specifier|static
name|void
name|createAuthCookie
parameter_list|(
name|HttpServletResponse
name|resp
parameter_list|,
name|String
name|token
parameter_list|,
name|String
name|domain
parameter_list|,
name|String
name|path
parameter_list|,
name|long
name|expires
parameter_list|,
name|boolean
name|isCookiePersistent
parameter_list|,
name|boolean
name|isSecure
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|AuthenticatedURL
operator|.
name|AUTH_COOKIE
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
operator|&&
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
operator|.
name|append
argument_list|(
name|token
argument_list|)
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"; Path="
argument_list|)
operator|.
name|append
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|domain
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"; Domain="
argument_list|)
operator|.
name|append
argument_list|(
name|domain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expires
operator|>=
literal|0
operator|&&
name|isCookiePersistent
condition|)
block|{
name|Date
name|date
init|=
operator|new
name|Date
argument_list|(
name|expires
argument_list|)
decl_stmt|;
name|SimpleDateFormat
name|df
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"EEE, "
operator|+
literal|"dd-MMM-yyyy HH:mm:ss zzz"
argument_list|)
decl_stmt|;
name|df
operator|.
name|setTimeZone
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"GMT"
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"; Expires="
argument_list|)
operator|.
name|append
argument_list|(
name|df
operator|.
name|format
argument_list|(
name|date
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isSecure
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"; Secure"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"; HttpOnly"
argument_list|)
expr_stmt|;
name|resp
operator|.
name|addHeader
argument_list|(
literal|"Set-Cookie"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

