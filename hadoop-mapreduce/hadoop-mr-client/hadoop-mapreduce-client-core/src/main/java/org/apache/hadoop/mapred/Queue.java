begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|QueueState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_comment
comment|/**  * A class for storing the properties of a job queue.  */
end_comment

begin_class
DECL|class|Queue
class|class
name|Queue
implements|implements
name|Comparable
argument_list|<
name|Queue
argument_list|>
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Queue
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//Queue name
DECL|field|name
specifier|private
name|String
name|name
init|=
literal|null
decl_stmt|;
comment|//acls list
DECL|field|acls
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|AccessControlList
argument_list|>
name|acls
decl_stmt|;
comment|//Queue State
DECL|field|state
specifier|private
name|QueueState
name|state
init|=
name|QueueState
operator|.
name|RUNNING
decl_stmt|;
comment|// An Object that can be used by schedulers to fill in
comment|// arbitrary scheduling information. The toString method
comment|// of these objects will be called by the framework to
comment|// get a String that can be displayed on UI.
DECL|field|schedulingInfo
specifier|private
name|Object
name|schedulingInfo
decl_stmt|;
DECL|field|children
specifier|private
name|Set
argument_list|<
name|Queue
argument_list|>
name|children
decl_stmt|;
DECL|field|props
specifier|private
name|Properties
name|props
decl_stmt|;
comment|/**    * Default constructor is useful in creating the hierarchy.    * The variables are populated using mutator methods.    */
DECL|method|Queue ()
name|Queue
parameter_list|()
block|{        }
comment|/**    * Create a job queue    * @param name name of the queue    * @param acls ACLs for the queue    * @param state state of the queue    */
DECL|method|Queue (String name, Map<String, AccessControlList> acls, QueueState state)
name|Queue
parameter_list|(
name|String
name|name
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|AccessControlList
argument_list|>
name|acls
parameter_list|,
name|QueueState
name|state
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|acls
operator|=
name|acls
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
comment|/**    * Return the name of the queue    *     * @return name of the queue    */
DECL|method|getName ()
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/**    * Set the name of the queue    * @param name name of the queue    */
DECL|method|setName (String name)
name|void
name|setName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
comment|/**    * Return the ACLs for the queue    *     * The keys in the map indicate the operations that can be performed,    * and the values indicate the list of users/groups who can perform    * the operation.    *     * @return Map containing the operations that can be performed and    *          who can perform the operations.    */
DECL|method|getAcls ()
name|Map
argument_list|<
name|String
argument_list|,
name|AccessControlList
argument_list|>
name|getAcls
parameter_list|()
block|{
return|return
name|acls
return|;
block|}
comment|/**    * Set the ACLs for the queue    * @param acls Map containing the operations that can be performed and    *          who can perform the operations.    */
DECL|method|setAcls (Map<String, AccessControlList> acls)
name|void
name|setAcls
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|AccessControlList
argument_list|>
name|acls
parameter_list|)
block|{
name|this
operator|.
name|acls
operator|=
name|acls
expr_stmt|;
block|}
comment|/**    * Return the state of the queue.    * @return state of the queue    */
DECL|method|getState ()
name|QueueState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
comment|/**    * Set the state of the queue.    * @param state state of the queue.    */
DECL|method|setState (QueueState state)
name|void
name|setState
parameter_list|(
name|QueueState
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
comment|/**    * Return the scheduling information for the queue    * @return scheduling information for the queue.    */
DECL|method|getSchedulingInfo ()
name|Object
name|getSchedulingInfo
parameter_list|()
block|{
return|return
name|schedulingInfo
return|;
block|}
comment|/**    * Set the scheduling information from the queue.    * @param schedulingInfo scheduling information for the queue.    */
DECL|method|setSchedulingInfo (Object schedulingInfo)
name|void
name|setSchedulingInfo
parameter_list|(
name|Object
name|schedulingInfo
parameter_list|)
block|{
name|this
operator|.
name|schedulingInfo
operator|=
name|schedulingInfo
expr_stmt|;
block|}
comment|/**    * Copy the scheduling information from the sourceQueue into this queue    * recursively.    *     * @param sourceQueue    */
DECL|method|copySchedulingInfo (Queue sourceQueue)
name|void
name|copySchedulingInfo
parameter_list|(
name|Queue
name|sourceQueue
parameter_list|)
block|{
comment|// First update the children queues recursively.
name|Set
argument_list|<
name|Queue
argument_list|>
name|destChildren
init|=
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
name|destChildren
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|Queue
argument_list|>
name|itr1
init|=
name|destChildren
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Queue
argument_list|>
name|itr2
init|=
name|sourceQueue
operator|.
name|getChildren
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr1
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|itr1
operator|.
name|next
argument_list|()
operator|.
name|copySchedulingInfo
argument_list|(
name|itr2
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now, copy the information for the root-queue itself
name|setSchedulingInfo
argument_list|(
name|sourceQueue
operator|.
name|getSchedulingInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    *    */
DECL|method|addChild (Queue child)
name|void
name|addChild
parameter_list|(
name|Queue
name|child
parameter_list|)
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
name|children
operator|=
operator|new
name|TreeSet
argument_list|<
name|Queue
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|children
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|/**    *    * @return    */
DECL|method|getChildren ()
name|Set
argument_list|<
name|Queue
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|children
return|;
block|}
comment|/**    *     * @param props    */
DECL|method|setProperties (Properties props)
name|void
name|setProperties
parameter_list|(
name|Properties
name|props
parameter_list|)
block|{
name|this
operator|.
name|props
operator|=
name|props
expr_stmt|;
block|}
comment|/**    *    * @return    */
DECL|method|getProperties ()
name|Properties
name|getProperties
parameter_list|()
block|{
return|return
name|this
operator|.
name|props
return|;
block|}
comment|/**    * This methods helps in traversing the    * tree hierarchy.    *    * Returns list of all inner queues.i.e nodes which has children.    * below this level.    *    * Incase of children being null , returns an empty map.    * This helps in case of creating union of inner and leaf queues.    * @return    */
DECL|method|getInnerQueues ()
name|Map
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
name|getInnerQueues
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
name|l
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
argument_list|()
decl_stmt|;
comment|//If no children , return empty set.
comment|//This check is required for root node.
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
return|return
name|l
return|;
block|}
comment|//check for children if they are parent.
for|for
control|(
name|Queue
name|child
range|:
name|children
control|)
block|{
comment|//check if children are themselves parent add them
if|if
condition|(
name|child
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
name|child
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|l
operator|.
name|put
argument_list|(
name|child
operator|.
name|getName
argument_list|()
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|l
operator|.
name|putAll
argument_list|(
name|child
operator|.
name|getInnerQueues
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|l
return|;
block|}
comment|/**    * This method helps in maintaining the single    * data structure across QueueManager.    *    * Now if we just maintain list of root queues we    * should be done.    *    * Doesn't return null .    * Adds itself if this is leaf node.    * @return    */
DECL|method|getLeafQueues ()
name|Map
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
name|getLeafQueues
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
name|l
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
name|l
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
for|for
control|(
name|Queue
name|child
range|:
name|children
control|)
block|{
name|l
operator|.
name|putAll
argument_list|(
name|child
operator|.
name|getLeafQueues
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
annotation|@
name|Override
DECL|method|compareTo (Queue queue)
specifier|public
name|int
name|compareTo
parameter_list|(
name|Queue
name|queue
parameter_list|)
block|{
return|return
name|name
operator|.
name|compareTo
argument_list|(
name|queue
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Queue
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|(
operator|(
name|Queue
operator|)
name|o
operator|)
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|getName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|getName
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**    * Return hierarchy of {@link JobQueueInfo} objects    * under this Queue.    *    * @return JobQueueInfo[]    */
DECL|method|getJobQueueInfo ()
name|JobQueueInfo
name|getJobQueueInfo
parameter_list|()
block|{
name|JobQueueInfo
name|queueInfo
init|=
operator|new
name|JobQueueInfo
argument_list|()
decl_stmt|;
name|queueInfo
operator|.
name|setQueueName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"created jobQInfo "
operator|+
name|queueInfo
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setQueueState
argument_list|(
name|state
operator|.
name|getStateName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|schedulingInfo
operator|!=
literal|null
condition|)
block|{
name|queueInfo
operator|.
name|setSchedulingInfo
argument_list|(
name|schedulingInfo
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|props
operator|!=
literal|null
condition|)
block|{
comment|//Create deep copy of properties.
name|Properties
name|newProps
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|key
range|:
name|props
operator|.
name|keySet
argument_list|()
control|)
block|{
name|newProps
operator|.
name|setProperty
argument_list|(
name|key
operator|.
name|toString
argument_list|()
argument_list|,
name|props
operator|.
name|getProperty
argument_list|(
name|key
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|queueInfo
operator|.
name|setProperties
argument_list|(
name|newProps
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|children
operator|!=
literal|null
operator|&&
name|children
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|JobQueueInfo
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|JobQueueInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Queue
name|child
range|:
name|children
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|child
operator|.
name|getJobQueueInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|queueInfo
operator|.
name|setChildren
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|queueInfo
return|;
block|}
comment|/**    * For each node validate if current node hierarchy is same newState.    * recursively check for child nodes.    *     * @param newState    * @return    */
DECL|method|isHierarchySameAs (Queue newState)
name|boolean
name|isHierarchySameAs
parameter_list|(
name|Queue
name|newState
parameter_list|)
block|{
if|if
condition|(
name|newState
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//First check if names are equal
if|if
condition|(
operator|!
operator|(
name|name
operator|.
name|equals
argument_list|(
name|newState
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|" current name "
operator|+
name|name
operator|+
literal|" not equal to "
operator|+
name|newState
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|children
operator|==
literal|null
operator|||
name|children
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|newState
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
name|newState
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|newState
operator|+
literal|" has added children in refresh "
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|//check for the individual children and then see if all of them
comment|//are updated.
if|if
condition|(
name|newState
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"In the current state, queue "
operator|+
name|getName
argument_list|()
operator|+
literal|" has "
operator|+
name|children
operator|.
name|size
argument_list|()
operator|+
literal|" but the new state has none!"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|childrenSize
init|=
name|children
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|newChildrenSize
init|=
name|newState
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|childrenSize
operator|!=
name|newChildrenSize
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Number of children for queue "
operator|+
name|newState
operator|.
name|getName
argument_list|()
operator|+
literal|" in newState is "
operator|+
name|newChildrenSize
operator|+
literal|" which is not equal to "
operator|+
name|childrenSize
operator|+
literal|" in the current state."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|//children are pre sorted as they are stored in treeset.
comment|//hence order shold be the same.
name|Iterator
argument_list|<
name|Queue
argument_list|>
name|itr1
init|=
name|children
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Queue
argument_list|>
name|itr2
init|=
name|newState
operator|.
name|getChildren
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr1
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Queue
name|q
init|=
name|itr1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Queue
name|newq
init|=
name|itr2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|q
operator|.
name|isHierarchySameAs
argument_list|(
name|newq
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|" Queue "
operator|+
name|q
operator|.
name|getName
argument_list|()
operator|+
literal|" not equal to "
operator|+
name|newq
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

