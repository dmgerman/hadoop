begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|CleanupQueue
operator|.
name|PathDeletionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JvmManager
operator|.
name|JvmEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
operator|.
name|ExitCodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
operator|.
name|ShellCommandExecutor
import|;
end_import

begin_comment
comment|/**  * A {@link TaskController} that runs the task JVMs as the user   * who submits the job.  *   * This class executes a setuid executable to implement methods  * of the {@link TaskController}, including launching the task   * JVM and killing it when needed, and also initializing and  * finalizing the task environment.   *<p> The setuid executable is launched using the command line:</p>  *<p>task-controller mapreduce.job.user.name command command-args, where</p>  *<p>mapreduce.job.user.name is the name of the owner who submits the job</p>  *<p>command is one of the cardinal value of the   * {@link LinuxTaskController.TaskControllerCommands} enumeration</p>  *<p>command-args depends on the command being launched.</p>  *   * In addition to running and killing tasks, the class also   * sets up appropriate access for the directories and files   * that will be used by the tasks.   */
end_comment

begin_class
DECL|class|LinuxTaskController
class|class
name|LinuxTaskController
extends|extends
name|TaskController
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|LinuxTaskController
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Name of the executable script that will contain the child
comment|// JVM command line. See writeCommand for details.
DECL|field|COMMAND_FILE
specifier|private
specifier|static
specifier|final
name|String
name|COMMAND_FILE
init|=
literal|"taskjvm.sh"
decl_stmt|;
comment|// Path to the setuid executable.
DECL|field|taskControllerExe
specifier|private
specifier|static
name|String
name|taskControllerExe
decl_stmt|;
static|static
block|{
comment|// the task-controller is expected to be under the $HADOOP_PREFIX/bin
comment|// directory.
name|File
name|hadoopBin
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getenv
argument_list|(
literal|"HADOOP_PREFIX"
argument_list|)
argument_list|,
literal|"bin"
argument_list|)
decl_stmt|;
name|taskControllerExe
operator|=
operator|new
name|File
argument_list|(
name|hadoopBin
argument_list|,
literal|"task-controller"
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
DECL|method|LinuxTaskController ()
specifier|public
name|LinuxTaskController
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**    * List of commands that the setuid script will execute.    */
DECL|enum|TaskControllerCommands
enum|enum
name|TaskControllerCommands
block|{
DECL|enumConstant|INITIALIZE_USER
name|INITIALIZE_USER
block|,
DECL|enumConstant|INITIALIZE_JOB
name|INITIALIZE_JOB
block|,
DECL|enumConstant|INITIALIZE_DISTRIBUTEDCACHE_FILE
name|INITIALIZE_DISTRIBUTEDCACHE_FILE
block|,
DECL|enumConstant|LAUNCH_TASK_JVM
name|LAUNCH_TASK_JVM
block|,
DECL|enumConstant|INITIALIZE_TASK
name|INITIALIZE_TASK
block|,
DECL|enumConstant|TERMINATE_TASK_JVM
name|TERMINATE_TASK_JVM
block|,
DECL|enumConstant|KILL_TASK_JVM
name|KILL_TASK_JVM
block|,
DECL|enumConstant|RUN_DEBUG_SCRIPT
name|RUN_DEBUG_SCRIPT
block|,
DECL|enumConstant|SIGQUIT_TASK_JVM
name|SIGQUIT_TASK_JVM
block|,
DECL|enumConstant|ENABLE_TASK_FOR_CLEANUP
name|ENABLE_TASK_FOR_CLEANUP
block|,
DECL|enumConstant|ENABLE_JOB_FOR_CLEANUP
name|ENABLE_JOB_FOR_CLEANUP
block|}
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
comment|// Check the permissions of the task-controller binary by running it plainly.
comment|// If permissions are correct, it returns an error code 1, else it returns
comment|// 24 or something else if some other bugs are also present.
name|String
index|[]
name|taskControllerCmd
init|=
operator|new
name|String
index|[]
block|{
name|getTaskControllerExecutablePath
argument_list|()
block|}
decl_stmt|;
name|ShellCommandExecutor
name|shExec
init|=
operator|new
name|ShellCommandExecutor
argument_list|(
name|taskControllerCmd
argument_list|)
decl_stmt|;
try|try
block|{
name|shExec
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitCodeException
name|e
parameter_list|)
block|{
name|int
name|exitCode
init|=
name|shExec
operator|.
name|getExitCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|exitCode
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exit code from checking binary permissions is : "
operator|+
name|exitCode
argument_list|)
expr_stmt|;
name|logOutput
argument_list|(
name|shExec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Task controller setup failed because of invalid"
operator|+
literal|"permissions/ownership with exit code "
operator|+
name|exitCode
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Launch a task JVM that will run as the owner of the job.    *     * This method launches a task JVM by executing a setuid executable that will    * switch to the user and run the task. Also does initialization of the first    * task in the same setuid process launch.    */
annotation|@
name|Override
DECL|method|launchTaskJVM (TaskController.TaskControllerContext context)
name|void
name|launchTaskJVM
parameter_list|(
name|TaskController
operator|.
name|TaskControllerContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|JvmEnv
name|env
init|=
name|context
operator|.
name|env
decl_stmt|;
comment|// get the JVM command line.
name|String
name|cmdLine
init|=
name|TaskLog
operator|.
name|buildCommandLine
argument_list|(
name|env
operator|.
name|setup
argument_list|,
name|env
operator|.
name|vargs
argument_list|,
name|env
operator|.
name|stdout
argument_list|,
name|env
operator|.
name|stderr
argument_list|,
name|env
operator|.
name|logSize
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
comment|//export out all the environment variable before child command as
comment|//the setuid/setgid binaries would not be getting, any environmental
comment|//variables which begin with LD_*.
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|env
operator|.
name|env
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"export "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|cmdLine
argument_list|)
expr_stmt|;
comment|// write the command to a file in the
comment|// task specific cache directory
name|writeCommand
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|,
name|getTaskCacheDirectory
argument_list|(
name|context
argument_list|,
name|context
operator|.
name|env
operator|.
name|workDir
argument_list|)
argument_list|)
expr_stmt|;
comment|// Call the taskcontroller with the right parameters.
name|List
argument_list|<
name|String
argument_list|>
name|launchTaskJVMArgs
init|=
name|buildLaunchTaskArgs
argument_list|(
name|context
argument_list|,
name|context
operator|.
name|env
operator|.
name|workDir
argument_list|)
decl_stmt|;
name|ShellCommandExecutor
name|shExec
init|=
name|buildTaskControllerExecutor
argument_list|(
name|TaskControllerCommands
operator|.
name|LAUNCH_TASK_JVM
argument_list|,
name|env
operator|.
name|conf
operator|.
name|getUser
argument_list|()
argument_list|,
name|launchTaskJVMArgs
argument_list|,
name|env
operator|.
name|workDir
argument_list|,
name|env
operator|.
name|env
argument_list|)
decl_stmt|;
name|context
operator|.
name|shExec
operator|=
name|shExec
expr_stmt|;
try|try
block|{
name|shExec
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|int
name|exitCode
init|=
name|shExec
operator|.
name|getExitCode
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exit code from task is : "
operator|+
name|exitCode
argument_list|)
expr_stmt|;
comment|// 143 (SIGTERM) and 137 (SIGKILL) exit codes means the task was
comment|// terminated/killed forcefully. In all other cases, log the
comment|// task-controller output
if|if
condition|(
name|exitCode
operator|!=
literal|143
operator|&&
name|exitCode
operator|!=
literal|137
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception thrown while launching task JVM : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Output from LinuxTaskController's launchTaskJVM follows:"
argument_list|)
expr_stmt|;
name|logOutput
argument_list|(
name|shExec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Output from LinuxTaskController's launchTaskJVM follows:"
argument_list|)
expr_stmt|;
name|logOutput
argument_list|(
name|shExec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Launch the debug script process that will run as the owner of the job.    *     * This method launches the task debug script process by executing a setuid    * executable that will switch to the user and run the task.     */
annotation|@
name|Override
DECL|method|runDebugScript (DebugScriptContext context)
name|void
name|runDebugScript
parameter_list|(
name|DebugScriptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|debugOut
init|=
name|FileUtil
operator|.
name|makeShellPath
argument_list|(
name|context
operator|.
name|stdout
argument_list|)
decl_stmt|;
name|String
name|cmdLine
init|=
name|TaskLog
operator|.
name|buildDebugScriptCommandLine
argument_list|(
name|context
operator|.
name|args
argument_list|,
name|debugOut
argument_list|)
decl_stmt|;
name|writeCommand
argument_list|(
name|cmdLine
argument_list|,
name|getTaskCacheDirectory
argument_list|(
name|context
argument_list|,
name|context
operator|.
name|workDir
argument_list|)
argument_list|)
expr_stmt|;
comment|// Call the taskcontroller with the right parameters.
name|List
argument_list|<
name|String
argument_list|>
name|launchTaskJVMArgs
init|=
name|buildLaunchTaskArgs
argument_list|(
name|context
argument_list|,
name|context
operator|.
name|workDir
argument_list|)
decl_stmt|;
name|runCommand
argument_list|(
name|TaskControllerCommands
operator|.
name|RUN_DEBUG_SCRIPT
argument_list|,
name|context
operator|.
name|task
operator|.
name|getUser
argument_list|()
argument_list|,
name|launchTaskJVMArgs
argument_list|,
name|context
operator|.
name|workDir
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Helper method that runs a LinuxTaskController command    *     * @param taskControllerCommand    * @param user    * @param cmdArgs    * @param env    * @throws IOException    */
DECL|method|runCommand (TaskControllerCommands taskControllerCommand, String user, List<String> cmdArgs, File workDir, Map<String, String> env)
specifier|private
name|void
name|runCommand
parameter_list|(
name|TaskControllerCommands
name|taskControllerCommand
parameter_list|,
name|String
name|user
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|cmdArgs
parameter_list|,
name|File
name|workDir
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|ShellCommandExecutor
name|shExec
init|=
name|buildTaskControllerExecutor
argument_list|(
name|taskControllerCommand
argument_list|,
name|user
argument_list|,
name|cmdArgs
argument_list|,
name|workDir
argument_list|,
name|env
argument_list|)
decl_stmt|;
try|try
block|{
name|shExec
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exit code from "
operator|+
name|taskControllerCommand
operator|.
name|toString
argument_list|()
operator|+
literal|" is : "
operator|+
name|shExec
operator|.
name|getExitCode
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception thrown by "
operator|+
name|taskControllerCommand
operator|.
name|toString
argument_list|()
operator|+
literal|" : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Output from LinuxTaskController's "
operator|+
name|taskControllerCommand
operator|.
name|toString
argument_list|()
operator|+
literal|" follows:"
argument_list|)
expr_stmt|;
name|logOutput
argument_list|(
name|shExec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Output from LinuxTaskController's "
operator|+
name|taskControllerCommand
operator|.
name|toString
argument_list|()
operator|+
literal|" follows:"
argument_list|)
expr_stmt|;
name|logOutput
argument_list|(
name|shExec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns list of arguments to be passed while initializing a new task. See    * {@code buildTaskControllerExecutor(TaskControllerCommands, String,     * List<String>, JvmEnv)} documentation.    *     * @param context    * @return Argument to be used while launching Task VM    */
DECL|method|buildInitializeTaskArgs (TaskExecContext context)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|buildInitializeTaskArgs
parameter_list|(
name|TaskExecContext
name|context
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|commandArgs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|String
name|taskId
init|=
name|context
operator|.
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|jobId
init|=
name|getJobId
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|commandArgs
operator|.
name|add
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
operator|.
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
condition|)
block|{
name|commandArgs
operator|.
name|add
argument_list|(
name|taskId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|commandArgs
operator|.
name|add
argument_list|(
name|taskId
operator|+
name|TaskTracker
operator|.
name|TASK_CLEANUP_SUFFIX
argument_list|)
expr_stmt|;
block|}
return|return
name|commandArgs
return|;
block|}
annotation|@
name|Override
DECL|method|initializeTask (TaskControllerContext context)
name|void
name|initializeTask
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to do "
operator|+
name|TaskControllerCommands
operator|.
name|INITIALIZE_TASK
operator|.
name|toString
argument_list|()
operator|+
literal|" for "
operator|+
name|context
operator|.
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|runCommand
argument_list|(
name|TaskControllerCommands
operator|.
name|INITIALIZE_TASK
argument_list|,
name|context
operator|.
name|env
operator|.
name|conf
operator|.
name|getUser
argument_list|()
argument_list|,
name|buildInitializeTaskArgs
argument_list|(
name|context
argument_list|)
argument_list|,
name|context
operator|.
name|env
operator|.
name|workDir
argument_list|,
name|context
operator|.
name|env
operator|.
name|env
argument_list|)
expr_stmt|;
block|}
comment|/**    * Builds the args to be passed to task-controller for enabling of task for    * cleanup. Last arg in this List is either $attemptId or $attemptId/work    */
DECL|method|buildTaskCleanupArgs ( TaskControllerTaskPathDeletionContext context)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|buildTaskCleanupArgs
parameter_list|(
name|TaskControllerTaskPathDeletionContext
name|context
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|commandArgs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|commandArgs
operator|.
name|add
argument_list|(
name|context
operator|.
name|mapredLocalDir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|commandArgs
operator|.
name|add
argument_list|(
name|context
operator|.
name|task
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|workDir
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|context
operator|.
name|isWorkDir
condition|)
block|{
name|workDir
operator|=
literal|"/work"
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|.
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
condition|)
block|{
name|commandArgs
operator|.
name|add
argument_list|(
name|context
operator|.
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
name|TaskTracker
operator|.
name|TASK_CLEANUP_SUFFIX
operator|+
name|workDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|commandArgs
operator|.
name|add
argument_list|(
name|context
operator|.
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
name|workDir
argument_list|)
expr_stmt|;
block|}
return|return
name|commandArgs
return|;
block|}
comment|/**    * Builds the args to be passed to task-controller for enabling of job for    * cleanup. Last arg in this List is $jobid.    */
DECL|method|buildJobCleanupArgs ( TaskControllerJobPathDeletionContext context)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|buildJobCleanupArgs
parameter_list|(
name|TaskControllerJobPathDeletionContext
name|context
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|commandArgs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|commandArgs
operator|.
name|add
argument_list|(
name|context
operator|.
name|mapredLocalDir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|commandArgs
operator|.
name|add
argument_list|(
name|context
operator|.
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|commandArgs
return|;
block|}
comment|/**    * Enables the task for cleanup by changing permissions of the specified path    * in the local filesystem    */
annotation|@
name|Override
DECL|method|enableTaskForCleanup (PathDeletionContext context)
name|void
name|enableTaskForCleanup
parameter_list|(
name|PathDeletionContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|context
operator|instanceof
name|TaskControllerTaskPathDeletionContext
condition|)
block|{
name|TaskControllerTaskPathDeletionContext
name|tContext
init|=
operator|(
name|TaskControllerTaskPathDeletionContext
operator|)
name|context
decl_stmt|;
name|enablePathForCleanup
argument_list|(
name|tContext
argument_list|,
name|TaskControllerCommands
operator|.
name|ENABLE_TASK_FOR_CLEANUP
argument_list|,
name|buildTaskCleanupArgs
argument_list|(
name|tContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"PathDeletionContext provided is not "
operator|+
literal|"TaskControllerTaskPathDeletionContext."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Enables the job for cleanup by changing permissions of the specified path    * in the local filesystem    */
annotation|@
name|Override
DECL|method|enableJobForCleanup (PathDeletionContext context)
name|void
name|enableJobForCleanup
parameter_list|(
name|PathDeletionContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|context
operator|instanceof
name|TaskControllerJobPathDeletionContext
condition|)
block|{
name|TaskControllerJobPathDeletionContext
name|tContext
init|=
operator|(
name|TaskControllerJobPathDeletionContext
operator|)
name|context
decl_stmt|;
name|enablePathForCleanup
argument_list|(
name|tContext
argument_list|,
name|TaskControllerCommands
operator|.
name|ENABLE_JOB_FOR_CLEANUP
argument_list|,
name|buildJobCleanupArgs
argument_list|(
name|tContext
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"PathDeletionContext provided is not "
operator|+
literal|"TaskControllerJobPathDeletionContext."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Enable a path for cleanup    * @param c {@link TaskControllerPathDeletionContext} for the path to be     *          cleaned up    * @param command {@link TaskControllerCommands} for task/job cleanup    * @param cleanupArgs arguments for the {@link LinuxTaskController} to enable     *                    path cleanup    */
DECL|method|enablePathForCleanup (TaskControllerPathDeletionContext c, TaskControllerCommands command, List<String> cleanupArgs)
specifier|private
name|void
name|enablePathForCleanup
parameter_list|(
name|TaskControllerPathDeletionContext
name|c
parameter_list|,
name|TaskControllerCommands
name|command
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|cleanupArgs
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to do "
operator|+
name|command
operator|.
name|toString
argument_list|()
operator|+
literal|" for "
operator|+
name|c
operator|.
name|fullPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|.
name|user
operator|!=
literal|null
operator|&&
name|c
operator|.
name|fs
operator|instanceof
name|LocalFileSystem
condition|)
block|{
try|try
block|{
name|runCommand
argument_list|(
name|command
argument_list|,
name|c
operator|.
name|user
argument_list|,
name|cleanupArgs
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to change permissions for "
operator|+
name|c
operator|.
name|fullPath
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Either user is null or the "
operator|+
literal|"file system is not local file system."
argument_list|)
throw|;
block|}
block|}
DECL|method|logOutput (String output)
specifier|private
name|void
name|logOutput
parameter_list|(
name|String
name|output
parameter_list|)
block|{
name|String
name|shExecOutput
init|=
name|output
decl_stmt|;
if|if
condition|(
name|shExecOutput
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|str
range|:
name|shExecOutput
operator|.
name|split
argument_list|(
literal|"\n"
argument_list|)
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getJobId (TaskExecContext context)
specifier|private
name|String
name|getJobId
parameter_list|(
name|TaskExecContext
name|context
parameter_list|)
block|{
name|String
name|taskId
init|=
name|context
operator|.
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TaskAttemptID
name|tId
init|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
name|String
name|jobId
init|=
name|tId
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|jobId
return|;
block|}
comment|/**    * Returns list of arguments to be passed while launching task VM.    * See {@code buildTaskControllerExecutor(TaskControllerCommands,     * String, List<String>, JvmEnv)} documentation.    * @param context    * @return Argument to be used while launching Task VM    */
DECL|method|buildLaunchTaskArgs (TaskExecContext context, File workDir)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|buildLaunchTaskArgs
parameter_list|(
name|TaskExecContext
name|context
parameter_list|,
name|File
name|workDir
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|commandArgs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"getting the task directory as: "
operator|+
name|getTaskCacheDirectory
argument_list|(
name|context
argument_list|,
name|workDir
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"getting the tt_root as "
operator|+
name|getDirectoryChosenForTask
argument_list|(
operator|new
name|File
argument_list|(
name|getTaskCacheDirectory
argument_list|(
name|context
argument_list|,
name|workDir
argument_list|)
argument_list|)
argument_list|,
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|commandArgs
operator|.
name|add
argument_list|(
name|getDirectoryChosenForTask
argument_list|(
operator|new
name|File
argument_list|(
name|getTaskCacheDirectory
argument_list|(
name|context
argument_list|,
name|workDir
argument_list|)
argument_list|)
argument_list|,
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|commandArgs
operator|.
name|addAll
argument_list|(
name|buildInitializeTaskArgs
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|commandArgs
return|;
block|}
comment|// Get the directory from the list of directories configured
comment|// in Configs.LOCAL_DIR chosen for storing data pertaining to
comment|// this task.
DECL|method|getDirectoryChosenForTask (File directory, TaskExecContext context)
specifier|private
name|String
name|getDirectoryChosenForTask
parameter_list|(
name|File
name|directory
parameter_list|,
name|TaskExecContext
name|context
parameter_list|)
block|{
name|String
name|jobId
init|=
name|getJobId
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|String
name|taskId
init|=
name|context
operator|.
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|dir
range|:
name|mapredLocalDirs
control|)
block|{
name|File
name|mapredDir
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|File
name|taskDir
init|=
operator|new
name|File
argument_list|(
name|mapredDir
argument_list|,
name|TaskTracker
operator|.
name|getTaskWorkDir
argument_list|(
name|context
operator|.
name|task
operator|.
name|getUser
argument_list|()
argument_list|,
name|jobId
argument_list|,
name|taskId
argument_list|,
name|context
operator|.
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
argument_list|)
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|directory
operator|.
name|equals
argument_list|(
name|taskDir
argument_list|)
condition|)
block|{
return|return
name|dir
return|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't parse task cache directory correctly"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid task cache directory "
operator|+
name|directory
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Builds the command line for launching/terminating/killing task JVM.    * Following is the format for launching/terminating/killing task JVM    *<br/>    * For launching following is command line argument:    *<br/>    * {@code mapreduce.job.user.name command tt-root job_id task_id}     *<br/>    * For terminating/killing task jvm.    * {@code mapreduce.job.user.name command tt-root task-pid}    *     * @param command command to be executed.    * @param userName mapreduce.job.user.name    * @param cmdArgs list of extra arguments    * @param workDir working directory for the task-controller    * @param env JVM environment variables.    * @return {@link ShellCommandExecutor}    * @throws IOException    */
DECL|method|buildTaskControllerExecutor ( TaskControllerCommands command, String userName, List<String> cmdArgs, File workDir, Map<String, String> env)
specifier|private
name|ShellCommandExecutor
name|buildTaskControllerExecutor
parameter_list|(
name|TaskControllerCommands
name|command
parameter_list|,
name|String
name|userName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|cmdArgs
parameter_list|,
name|File
name|workDir
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|taskControllerCmd
init|=
operator|new
name|String
index|[
literal|3
operator|+
name|cmdArgs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|taskControllerCmd
index|[
literal|0
index|]
operator|=
name|getTaskControllerExecutablePath
argument_list|()
expr_stmt|;
name|taskControllerCmd
index|[
literal|1
index|]
operator|=
name|userName
expr_stmt|;
name|taskControllerCmd
index|[
literal|2
index|]
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|command
operator|.
name|ordinal
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|3
decl_stmt|;
for|for
control|(
name|String
name|cmdArg
range|:
name|cmdArgs
control|)
block|{
name|taskControllerCmd
index|[
name|i
operator|++
index|]
operator|=
name|cmdArg
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|cmd
range|:
name|taskControllerCmd
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"taskctrl command = "
operator|+
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|ShellCommandExecutor
name|shExec
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|workDir
operator|!=
literal|null
operator|&&
name|workDir
operator|.
name|exists
argument_list|()
condition|)
block|{
name|shExec
operator|=
operator|new
name|ShellCommandExecutor
argument_list|(
name|taskControllerCmd
argument_list|,
name|workDir
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shExec
operator|=
operator|new
name|ShellCommandExecutor
argument_list|(
name|taskControllerCmd
argument_list|)
expr_stmt|;
block|}
return|return
name|shExec
return|;
block|}
comment|// Return the task specific directory under the cache.
DECL|method|getTaskCacheDirectory (TaskExecContext context, File workDir)
specifier|private
name|String
name|getTaskCacheDirectory
parameter_list|(
name|TaskExecContext
name|context
parameter_list|,
name|File
name|workDir
parameter_list|)
block|{
comment|// In the case of JVM reuse, the task specific directory
comment|// is different from what is set with respect with
comment|// env.workDir. Hence building this from the taskId everytime.
name|String
name|taskId
init|=
name|context
operator|.
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|File
name|cacheDirForJob
init|=
name|workDir
operator|.
name|getParentFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|.
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
condition|)
block|{
name|taskId
operator|=
name|taskId
operator|+
name|TaskTracker
operator|.
name|TASK_CLEANUP_SUFFIX
expr_stmt|;
block|}
return|return
operator|new
name|File
argument_list|(
name|cacheDirForJob
argument_list|,
name|taskId
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
return|;
block|}
comment|// Write the JVM command line to a file under the specified directory
comment|// Note that the JVM will be launched using a setuid executable, and
comment|// could potentially contain strings defined by a user. Hence, to
comment|// prevent special character attacks, we write the command line to
comment|// a file and execute it.
DECL|method|writeCommand (String cmdLine, String directory)
specifier|private
name|void
name|writeCommand
parameter_list|(
name|String
name|cmdLine
parameter_list|,
name|String
name|directory
parameter_list|)
throws|throws
name|IOException
block|{
name|PrintWriter
name|pw
init|=
literal|null
decl_stmt|;
name|String
name|commandFile
init|=
name|directory
operator|+
name|File
operator|.
name|separator
operator|+
name|COMMAND_FILE
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing commands to "
operator|+
name|commandFile
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"--------Commands Begin--------"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|cmdLine
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"--------Commands End--------"
argument_list|)
expr_stmt|;
try|try
block|{
name|FileWriter
name|fw
init|=
operator|new
name|FileWriter
argument_list|(
name|commandFile
argument_list|)
decl_stmt|;
name|BufferedWriter
name|bw
init|=
operator|new
name|BufferedWriter
argument_list|(
name|fw
argument_list|)
decl_stmt|;
name|pw
operator|=
operator|new
name|PrintWriter
argument_list|(
name|bw
argument_list|)
expr_stmt|;
name|pw
operator|.
name|write
argument_list|(
name|cmdLine
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught IOException while writing JVM command line to file. "
operator|+
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|pw
operator|!=
literal|null
condition|)
block|{
name|pw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// set execute permissions for all on the file.
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|commandFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
name|f
operator|.
name|setReadable
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|f
operator|.
name|setExecutable
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|buildInitializeJobCommandArgs ( JobInitializationContext context)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|buildInitializeJobCommandArgs
parameter_list|(
name|JobInitializationContext
name|context
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|initJobCmdArgs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|initJobCmdArgs
operator|.
name|add
argument_list|(
name|context
operator|.
name|jobid
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|initJobCmdArgs
return|;
block|}
annotation|@
name|Override
DECL|method|initializeJob (JobInitializationContext context)
name|void
name|initializeJob
parameter_list|(
name|JobInitializationContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to initialize job "
operator|+
name|context
operator|.
name|jobid
operator|.
name|toString
argument_list|()
operator|+
literal|" on the TT"
argument_list|)
expr_stmt|;
name|runCommand
argument_list|(
name|TaskControllerCommands
operator|.
name|INITIALIZE_JOB
argument_list|,
name|context
operator|.
name|user
argument_list|,
name|buildInitializeJobCommandArgs
argument_list|(
name|context
argument_list|)
argument_list|,
name|context
operator|.
name|workDir
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|initializeDistributedCacheFile (DistributedCacheFileContext context)
specifier|public
name|void
name|initializeDistributedCacheFile
parameter_list|(
name|DistributedCacheFileContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to initialize distributed cache for "
operator|+
name|context
operator|.
name|user
operator|+
literal|" with localizedBaseDir "
operator|+
name|context
operator|.
name|localizedBaseDir
operator|+
literal|" and uniqueString "
operator|+
name|context
operator|.
name|uniqueString
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|args
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Here, uniqueString might start with '-'. Adding -- in front of the
comment|// arguments indicates that they are non-option parameters.
name|args
operator|.
name|add
argument_list|(
literal|"--"
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|context
operator|.
name|localizedBaseDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|context
operator|.
name|uniqueString
argument_list|)
expr_stmt|;
name|runCommand
argument_list|(
name|TaskControllerCommands
operator|.
name|INITIALIZE_DISTRIBUTEDCACHE_FILE
argument_list|,
name|context
operator|.
name|user
argument_list|,
name|args
argument_list|,
name|context
operator|.
name|workDir
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|initializeUser (InitializationContext context)
specifier|public
name|void
name|initializeUser
parameter_list|(
name|InitializationContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Going to initialize user directories for "
operator|+
name|context
operator|.
name|user
operator|+
literal|" on the TT"
argument_list|)
expr_stmt|;
name|runCommand
argument_list|(
name|TaskControllerCommands
operator|.
name|INITIALIZE_USER
argument_list|,
name|context
operator|.
name|user
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|,
name|context
operator|.
name|workDir
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * API which builds the command line to be pass to LinuxTaskController    * binary to terminate/kill the task. See     * {@code buildTaskControllerExecutor(TaskControllerCommands,     * String, List<String>, JvmEnv)} documentation.    *     *     * @param context context of task which has to be passed kill signal.    *     */
DECL|method|buildKillTaskCommandArgs (TaskControllerContext context)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|buildKillTaskCommandArgs
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|killTaskJVMArgs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|killTaskJVMArgs
operator|.
name|add
argument_list|(
name|context
operator|.
name|pid
argument_list|)
expr_stmt|;
return|return
name|killTaskJVMArgs
return|;
block|}
comment|/**    * Convenience method used to sending appropriate signal to the task    * VM    * @param context    * @param command    * @throws IOException    */
DECL|method|signalTask (TaskControllerContext context, TaskControllerCommands command)
specifier|protected
name|void
name|signalTask
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|,
name|TaskControllerCommands
name|command
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|context
operator|.
name|task
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Context task is null; not signaling the JVM"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ShellCommandExecutor
name|shExec
init|=
name|buildTaskControllerExecutor
argument_list|(
name|command
argument_list|,
name|context
operator|.
name|env
operator|.
name|conf
operator|.
name|getUser
argument_list|()
argument_list|,
name|buildKillTaskCommandArgs
argument_list|(
name|context
argument_list|)
argument_list|,
name|context
operator|.
name|env
operator|.
name|workDir
argument_list|,
name|context
operator|.
name|env
operator|.
name|env
argument_list|)
decl_stmt|;
try|try
block|{
name|shExec
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Output from task-contoller is : "
operator|+
name|shExec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|terminateTask (TaskControllerContext context)
name|void
name|terminateTask
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
block|{
try|try
block|{
name|signalTask
argument_list|(
name|context
argument_list|,
name|TaskControllerCommands
operator|.
name|TERMINATE_TASK_JVM
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception thrown while sending kill to the Task VM "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|killTask (TaskControllerContext context)
name|void
name|killTask
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
block|{
try|try
block|{
name|signalTask
argument_list|(
name|context
argument_list|,
name|TaskControllerCommands
operator|.
name|KILL_TASK_JVM
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception thrown while sending destroy to the Task VM "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|dumpTaskStack (TaskControllerContext context)
name|void
name|dumpTaskStack
parameter_list|(
name|TaskControllerContext
name|context
parameter_list|)
block|{
try|try
block|{
name|signalTask
argument_list|(
name|context
argument_list|,
name|TaskControllerCommands
operator|.
name|SIGQUIT_TASK_JVM
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception thrown while sending SIGQUIT to the Task VM "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getTaskControllerExecutablePath ()
specifier|protected
name|String
name|getTaskControllerExecutablePath
parameter_list|()
block|{
return|return
name|taskControllerExe
return|;
block|}
annotation|@
name|Override
DECL|method|getRunAsUser (JobConf conf)
name|String
name|getRunAsUser
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getUser
argument_list|()
return|;
block|}
block|}
end_class

end_unit

