begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|SecretKey
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServlet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|DF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalDirAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|http
operator|.
name|HttpServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SecureIOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|ProtocolSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskController
operator|.
name|DebugScriptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskController
operator|.
name|JobInitializationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|CleanupQueue
operator|.
name|PathDeletionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskController
operator|.
name|TaskControllerPathDeletionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskController
operator|.
name|TaskControllerTaskPathDeletionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskController
operator|.
name|TaskControllerJobPathDeletionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskTrackerStatus
operator|.
name|TaskTrackerHealthStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|pipes
operator|.
name|Submitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|QueueManager
operator|.
name|toFullPropertyName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|filecache
operator|.
name|TrackerDistributedCacheManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|SecureShuffleUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|TokenCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|token
operator|.
name|JobTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|token
operator|.
name|JobTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|JTConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|tasktracker
operator|.
name|TTConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|tasktracker
operator|.
name|Localizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|reduce
operator|.
name|ShuffleHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics
operator|.
name|MetricsContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics
operator|.
name|MetricsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics
operator|.
name|MetricsRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics
operator|.
name|MetricsUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics
operator|.
name|Updater
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|PolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|ConfigUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|MemoryCalculatorPlugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|ResourceCalculatorPlugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|ProcfsBasedProcessTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|RunJar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskErrorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|MRAsyncDiskService
import|;
end_import

begin_comment
comment|/*******************************************************  * TaskTracker is a process that starts and tracks MR Tasks  * in a networked environment.  It contacts the JobTracker  * for Task assignments and reporting results.  *  *******************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|TaskTracker
specifier|public
class|class
name|TaskTracker
implements|implements
name|MRConstants
implements|,
name|TaskUmbilicalProtocol
implements|,
name|Runnable
implements|,
name|TTConfig
block|{
comment|/**    * @deprecated    */
annotation|@
name|Deprecated
DECL|field|MAPRED_TASKTRACKER_VMEM_RESERVED_PROPERTY
specifier|static
specifier|final
name|String
name|MAPRED_TASKTRACKER_VMEM_RESERVED_PROPERTY
init|=
literal|"mapred.tasktracker.vmem.reserved"
decl_stmt|;
comment|/**    * @deprecated    */
annotation|@
name|Deprecated
DECL|field|MAPRED_TASKTRACKER_PMEM_RESERVED_PROPERTY
specifier|static
specifier|final
name|String
name|MAPRED_TASKTRACKER_PMEM_RESERVED_PROPERTY
init|=
literal|"mapred.tasktracker.pmem.reserved"
decl_stmt|;
DECL|field|WAIT_FOR_DONE
specifier|static
specifier|final
name|long
name|WAIT_FOR_DONE
init|=
literal|3
operator|*
literal|1000
decl_stmt|;
DECL|field|httpPort
specifier|private
name|int
name|httpPort
decl_stmt|;
DECL|enum|State
DECL|enumConstant|NORMAL
DECL|enumConstant|STALE
DECL|enumConstant|INTERRUPTED
DECL|enumConstant|DENIED
specifier|static
enum|enum
name|State
block|{
name|NORMAL
block|,
name|STALE
block|,
name|INTERRUPTED
block|,
name|DENIED
block|}
static|static
block|{
name|ConfigUtil
operator|.
name|loadResources
argument_list|()
expr_stmt|;
block|}
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TaskTracker
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MR_CLIENTTRACE_FORMAT
specifier|public
specifier|static
specifier|final
name|String
name|MR_CLIENTTRACE_FORMAT
init|=
literal|"src: %s"
operator|+
comment|// src IP
literal|", dest: %s"
operator|+
comment|// dst IP
literal|", maps: %s"
operator|+
comment|// number of maps
literal|", op: %s"
operator|+
comment|// operation
literal|", reduceID: %s"
operator|+
comment|// reduce id
literal|", duration: %s"
decl_stmt|;
comment|// duration
DECL|field|ClientTraceLog
specifier|public
specifier|static
specifier|final
name|Log
name|ClientTraceLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TaskTracker
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".clienttrace"
argument_list|)
decl_stmt|;
comment|// Job ACLs file is created by TaskTracker under userlogs/$jobid directory for
comment|// each job at job localization time. This will be used by TaskLogServlet for
comment|// authorizing viewing of task logs of that job
DECL|field|jobACLsFile
specifier|static
name|String
name|jobACLsFile
init|=
literal|"job-acls.xml"
decl_stmt|;
DECL|field|running
specifier|volatile
name|boolean
name|running
init|=
literal|true
decl_stmt|;
DECL|field|localDirAllocator
specifier|private
name|LocalDirAllocator
name|localDirAllocator
decl_stmt|;
DECL|field|taskTrackerName
name|String
name|taskTrackerName
decl_stmt|;
DECL|field|localHostname
name|String
name|localHostname
decl_stmt|;
DECL|field|jobTrackAddr
name|InetSocketAddress
name|jobTrackAddr
decl_stmt|;
DECL|field|taskReportAddress
name|InetSocketAddress
name|taskReportAddress
decl_stmt|;
DECL|field|taskReportServer
name|Server
name|taskReportServer
init|=
literal|null
decl_stmt|;
DECL|field|jobClient
name|InterTrackerProtocol
name|jobClient
decl_stmt|;
DECL|field|distributedCacheManager
specifier|private
name|TrackerDistributedCacheManager
name|distributedCacheManager
decl_stmt|;
comment|// last heartbeat response received
DECL|field|heartbeatResponseId
name|short
name|heartbeatResponseId
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|TASK_CLEANUP_SUFFIX
specifier|static
specifier|final
name|String
name|TASK_CLEANUP_SUFFIX
init|=
literal|".cleanup"
decl_stmt|;
comment|/*    * This is the last 'status' report sent by this tracker to the JobTracker.    *     * If the rpc call succeeds, this 'status' is cleared-out by this tracker;    * indicating that a 'fresh' status report be generated; in the event the    * rpc calls fails for whatever reason, the previous status report is sent    * again.    */
DECL|field|status
name|TaskTrackerStatus
name|status
init|=
literal|null
decl_stmt|;
comment|// The system-directory on HDFS where job files are stored
DECL|field|systemDirectory
name|Path
name|systemDirectory
init|=
literal|null
decl_stmt|;
comment|// The filesystem where job files are stored
DECL|field|systemFS
name|FileSystem
name|systemFS
init|=
literal|null
decl_stmt|;
DECL|field|server
specifier|private
specifier|final
name|HttpServer
name|server
decl_stmt|;
DECL|field|shuttingDown
specifier|volatile
name|boolean
name|shuttingDown
init|=
literal|false
decl_stmt|;
DECL|field|tasks
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskInProgress
argument_list|>
name|tasks
init|=
operator|new
name|HashMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Map from taskId -> TaskInProgress.    */
DECL|field|runningTasks
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskInProgress
argument_list|>
name|runningTasks
init|=
literal|null
decl_stmt|;
DECL|field|runningJobs
name|Map
argument_list|<
name|JobID
argument_list|,
name|RunningJob
argument_list|>
name|runningJobs
init|=
operator|new
name|TreeMap
argument_list|<
name|JobID
argument_list|,
name|RunningJob
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|jobTokenSecretManager
specifier|private
specifier|final
name|JobTokenSecretManager
name|jobTokenSecretManager
init|=
operator|new
name|JobTokenSecretManager
argument_list|()
decl_stmt|;
DECL|field|mapTotal
specifier|volatile
name|int
name|mapTotal
init|=
literal|0
decl_stmt|;
DECL|field|reduceTotal
specifier|volatile
name|int
name|reduceTotal
init|=
literal|0
decl_stmt|;
DECL|field|justStarted
name|boolean
name|justStarted
init|=
literal|true
decl_stmt|;
DECL|field|justInited
name|boolean
name|justInited
init|=
literal|true
decl_stmt|;
comment|// Mark reduce tasks that are shuffling to rollback their events index
DECL|field|shouldReset
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|shouldReset
init|=
operator|new
name|HashSet
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
comment|//dir -> DF
DECL|field|localDirsDf
name|Map
argument_list|<
name|String
argument_list|,
name|DF
argument_list|>
name|localDirsDf
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|DF
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|minSpaceStart
name|long
name|minSpaceStart
init|=
literal|0
decl_stmt|;
comment|//must have this much space free to start new tasks
DECL|field|acceptNewTasks
name|boolean
name|acceptNewTasks
init|=
literal|true
decl_stmt|;
DECL|field|minSpaceKill
name|long
name|minSpaceKill
init|=
literal|0
decl_stmt|;
comment|//if we run under this limit, kill one task
comment|//and make sure we never receive any new jobs
comment|//until all the old tasks have been cleaned up.
comment|//this is if a machine is so full it's only good
comment|//for serving map output to the other nodes
DECL|field|r
specifier|static
name|Random
name|r
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|SUBDIR
specifier|public
specifier|static
specifier|final
name|String
name|SUBDIR
init|=
literal|"taskTracker"
decl_stmt|;
DECL|field|DISTCACHEDIR
specifier|static
specifier|final
name|String
name|DISTCACHEDIR
init|=
literal|"distcache"
decl_stmt|;
DECL|field|JOBCACHE
specifier|static
specifier|final
name|String
name|JOBCACHE
init|=
literal|"jobcache"
decl_stmt|;
DECL|field|OUTPUT
specifier|static
specifier|final
name|String
name|OUTPUT
init|=
literal|"output"
decl_stmt|;
DECL|field|JARSDIR
specifier|private
specifier|static
specifier|final
name|String
name|JARSDIR
init|=
literal|"jars"
decl_stmt|;
DECL|field|LOCAL_SPLIT_FILE
specifier|static
specifier|final
name|String
name|LOCAL_SPLIT_FILE
init|=
literal|"split.dta"
decl_stmt|;
DECL|field|LOCAL_SPLIT_META_FILE
specifier|static
specifier|final
name|String
name|LOCAL_SPLIT_META_FILE
init|=
literal|"split.info"
decl_stmt|;
DECL|field|JOBFILE
specifier|static
specifier|final
name|String
name|JOBFILE
init|=
literal|"job.xml"
decl_stmt|;
DECL|field|JOB_TOKEN_FILE
specifier|static
specifier|final
name|String
name|JOB_TOKEN_FILE
init|=
literal|"jobToken"
decl_stmt|;
comment|//localized file
DECL|field|JOB_LOCAL_DIR
specifier|static
specifier|final
name|String
name|JOB_LOCAL_DIR
init|=
name|MRJobConfig
operator|.
name|JOB_LOCAL_DIR
decl_stmt|;
DECL|field|fConf
specifier|private
name|JobConf
name|fConf
decl_stmt|;
DECL|field|localFs
specifier|private
name|FileSystem
name|localFs
decl_stmt|;
DECL|field|localizer
specifier|private
name|Localizer
name|localizer
decl_stmt|;
DECL|field|maxMapSlots
specifier|private
name|int
name|maxMapSlots
decl_stmt|;
DECL|field|maxReduceSlots
specifier|private
name|int
name|maxReduceSlots
decl_stmt|;
DECL|field|failures
specifier|private
name|int
name|failures
decl_stmt|;
DECL|field|aclsManager
specifier|private
name|ACLsManager
name|aclsManager
decl_stmt|;
comment|// Performance-related config knob to send an out-of-band heartbeat
comment|// on task completion
DECL|field|oobHeartbeatOnTaskCompletion
specifier|private
specifier|volatile
name|boolean
name|oobHeartbeatOnTaskCompletion
decl_stmt|;
comment|// Track number of completed tasks to send an out-of-band heartbeat
DECL|field|finishedCount
specifier|private
name|IntWritable
name|finishedCount
init|=
operator|new
name|IntWritable
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|mapEventsFetcher
specifier|private
name|MapEventsFetcherThread
name|mapEventsFetcher
decl_stmt|;
DECL|field|workerThreads
name|int
name|workerThreads
decl_stmt|;
DECL|field|directoryCleanupThread
name|CleanupQueue
name|directoryCleanupThread
decl_stmt|;
DECL|field|jvmManager
specifier|private
specifier|volatile
name|JvmManager
name|jvmManager
decl_stmt|;
DECL|field|taskLogCleanupThread
name|UserLogCleaner
name|taskLogCleanupThread
decl_stmt|;
DECL|field|taskMemoryManager
specifier|private
name|TaskMemoryManagerThread
name|taskMemoryManager
decl_stmt|;
DECL|field|taskMemoryManagerEnabled
specifier|private
name|boolean
name|taskMemoryManagerEnabled
init|=
literal|true
decl_stmt|;
DECL|field|totalVirtualMemoryOnTT
specifier|private
name|long
name|totalVirtualMemoryOnTT
init|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
decl_stmt|;
DECL|field|totalPhysicalMemoryOnTT
specifier|private
name|long
name|totalPhysicalMemoryOnTT
init|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
decl_stmt|;
DECL|field|mapSlotMemorySizeOnTT
specifier|private
name|long
name|mapSlotMemorySizeOnTT
init|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
decl_stmt|;
DECL|field|reduceSlotSizeMemoryOnTT
specifier|private
name|long
name|reduceSlotSizeMemoryOnTT
init|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
decl_stmt|;
DECL|field|totalMemoryAllottedForTasks
specifier|private
name|long
name|totalMemoryAllottedForTasks
init|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
decl_stmt|;
DECL|field|reservedPhysicalMemoryOnTT
specifier|private
name|long
name|reservedPhysicalMemoryOnTT
init|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
decl_stmt|;
DECL|field|resourceCalculatorPlugin
specifier|private
name|ResourceCalculatorPlugin
name|resourceCalculatorPlugin
init|=
literal|null
decl_stmt|;
comment|/**    * the minimum interval between jobtracker polls    */
DECL|field|heartbeatInterval
specifier|private
specifier|volatile
name|int
name|heartbeatInterval
init|=
name|JTConfig
operator|.
name|JT_HEARTBEAT_INTERVAL_MIN_DEFAULT
decl_stmt|;
comment|/**    * Number of maptask completion events locations to poll for at one time    */
DECL|field|probe_sample_size
specifier|private
name|int
name|probe_sample_size
init|=
literal|500
decl_stmt|;
DECL|field|indexCache
specifier|private
name|IndexCache
name|indexCache
decl_stmt|;
DECL|field|asyncDiskService
specifier|private
name|MRAsyncDiskService
name|asyncDiskService
decl_stmt|;
DECL|method|getAsyncDiskService ()
name|MRAsyncDiskService
name|getAsyncDiskService
parameter_list|()
block|{
return|return
name|asyncDiskService
return|;
block|}
DECL|method|setAsyncDiskService (MRAsyncDiskService asyncDiskService)
name|void
name|setAsyncDiskService
parameter_list|(
name|MRAsyncDiskService
name|asyncDiskService
parameter_list|)
block|{
name|this
operator|.
name|asyncDiskService
operator|=
name|asyncDiskService
expr_stmt|;
block|}
comment|/**   * Handle to the specific instance of the {@link TaskController} class   */
DECL|field|taskController
specifier|private
name|TaskController
name|taskController
decl_stmt|;
comment|/**    * Handle to the specific instance of the {@link NodeHealthCheckerService}    */
DECL|field|healthChecker
specifier|private
name|NodeHealthCheckerService
name|healthChecker
decl_stmt|;
comment|/*    * A list of commitTaskActions for whom commit response has been received     */
DECL|field|commitResponses
specifier|private
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|commitResponses
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|shuffleServerMetrics
specifier|private
name|ShuffleServerMetrics
name|shuffleServerMetrics
decl_stmt|;
comment|/** This class contains the methods that should be used for metrics-reporting    * the specific metrics for shuffle. The TaskTracker is actually a server for    * the shuffle and hence the name ShuffleServerMetrics.    */
DECL|class|ShuffleServerMetrics
class|class
name|ShuffleServerMetrics
implements|implements
name|Updater
block|{
DECL|field|shuffleMetricsRecord
specifier|private
name|MetricsRecord
name|shuffleMetricsRecord
init|=
literal|null
decl_stmt|;
DECL|field|serverHandlerBusy
specifier|private
name|int
name|serverHandlerBusy
init|=
literal|0
decl_stmt|;
DECL|field|outputBytes
specifier|private
name|long
name|outputBytes
init|=
literal|0
decl_stmt|;
DECL|field|failedOutputs
specifier|private
name|int
name|failedOutputs
init|=
literal|0
decl_stmt|;
DECL|field|successOutputs
specifier|private
name|int
name|successOutputs
init|=
literal|0
decl_stmt|;
DECL|field|exceptionsCaught
specifier|private
name|int
name|exceptionsCaught
init|=
literal|0
decl_stmt|;
DECL|method|ShuffleServerMetrics (JobConf conf)
name|ShuffleServerMetrics
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
name|MetricsContext
name|context
init|=
name|MetricsUtil
operator|.
name|getContext
argument_list|(
literal|"mapred"
argument_list|)
decl_stmt|;
name|shuffleMetricsRecord
operator|=
name|MetricsUtil
operator|.
name|createRecord
argument_list|(
name|context
argument_list|,
literal|"shuffleOutput"
argument_list|)
expr_stmt|;
name|this
operator|.
name|shuffleMetricsRecord
operator|.
name|setTag
argument_list|(
literal|"sessionId"
argument_list|,
name|conf
operator|.
name|getSessionId
argument_list|()
argument_list|)
expr_stmt|;
name|context
operator|.
name|registerUpdater
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|serverHandlerBusy ()
specifier|synchronized
name|void
name|serverHandlerBusy
parameter_list|()
block|{
operator|++
name|serverHandlerBusy
expr_stmt|;
block|}
DECL|method|serverHandlerFree ()
specifier|synchronized
name|void
name|serverHandlerFree
parameter_list|()
block|{
operator|--
name|serverHandlerBusy
expr_stmt|;
block|}
DECL|method|outputBytes (long bytes)
specifier|synchronized
name|void
name|outputBytes
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
name|outputBytes
operator|+=
name|bytes
expr_stmt|;
block|}
DECL|method|failedOutput ()
specifier|synchronized
name|void
name|failedOutput
parameter_list|()
block|{
operator|++
name|failedOutputs
expr_stmt|;
block|}
DECL|method|successOutput ()
specifier|synchronized
name|void
name|successOutput
parameter_list|()
block|{
operator|++
name|successOutputs
expr_stmt|;
block|}
DECL|method|exceptionsCaught ()
specifier|synchronized
name|void
name|exceptionsCaught
parameter_list|()
block|{
operator|++
name|exceptionsCaught
expr_stmt|;
block|}
DECL|method|doUpdates (MetricsContext unused)
specifier|public
name|void
name|doUpdates
parameter_list|(
name|MetricsContext
name|unused
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|workerThreads
operator|!=
literal|0
condition|)
block|{
name|shuffleMetricsRecord
operator|.
name|setMetric
argument_list|(
literal|"shuffle_handler_busy_percent"
argument_list|,
literal|100
operator|*
operator|(
operator|(
name|float
operator|)
name|serverHandlerBusy
operator|/
name|workerThreads
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shuffleMetricsRecord
operator|.
name|setMetric
argument_list|(
literal|"shuffle_handler_busy_percent"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|shuffleMetricsRecord
operator|.
name|incrMetric
argument_list|(
literal|"shuffle_output_bytes"
argument_list|,
name|outputBytes
argument_list|)
expr_stmt|;
name|shuffleMetricsRecord
operator|.
name|incrMetric
argument_list|(
literal|"shuffle_failed_outputs"
argument_list|,
name|failedOutputs
argument_list|)
expr_stmt|;
name|shuffleMetricsRecord
operator|.
name|incrMetric
argument_list|(
literal|"shuffle_success_outputs"
argument_list|,
name|successOutputs
argument_list|)
expr_stmt|;
name|shuffleMetricsRecord
operator|.
name|incrMetric
argument_list|(
literal|"shuffle_exceptions_caught"
argument_list|,
name|exceptionsCaught
argument_list|)
expr_stmt|;
name|outputBytes
operator|=
literal|0
expr_stmt|;
name|failedOutputs
operator|=
literal|0
expr_stmt|;
name|successOutputs
operator|=
literal|0
expr_stmt|;
name|exceptionsCaught
operator|=
literal|0
expr_stmt|;
block|}
name|shuffleMetricsRecord
operator|.
name|update
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|myInstrumentation
specifier|private
name|TaskTrackerInstrumentation
name|myInstrumentation
init|=
literal|null
decl_stmt|;
DECL|method|getTaskTrackerInstrumentation ()
specifier|public
name|TaskTrackerInstrumentation
name|getTaskTrackerInstrumentation
parameter_list|()
block|{
return|return
name|myInstrumentation
return|;
block|}
comment|// Currently used only in tests
DECL|method|setTaskTrackerInstrumentation ( TaskTrackerInstrumentation trackerInstrumentation)
name|void
name|setTaskTrackerInstrumentation
parameter_list|(
name|TaskTrackerInstrumentation
name|trackerInstrumentation
parameter_list|)
block|{
name|myInstrumentation
operator|=
name|trackerInstrumentation
expr_stmt|;
block|}
comment|/**    * A list of tips that should be cleaned up.    */
DECL|field|tasksToCleanup
specifier|private
name|BlockingQueue
argument_list|<
name|TaskTrackerAction
argument_list|>
name|tasksToCleanup
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|TaskTrackerAction
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getProtocolSignature (String protocol, long clientVersion, int clientMethodsHash)
specifier|public
name|ProtocolSignature
name|getProtocolSignature
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|,
name|int
name|clientMethodsHash
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ProtocolSignature
operator|.
name|getProtocolSignature
argument_list|(
name|this
argument_list|,
name|protocol
argument_list|,
name|clientVersion
argument_list|,
name|clientMethodsHash
argument_list|)
return|;
block|}
comment|/**    * A daemon-thread that pulls tips off the list of things to cleanup.    */
DECL|field|taskCleanupThread
specifier|private
name|Thread
name|taskCleanupThread
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|TaskTrackerAction
name|action
init|=
name|tasksToCleanup
operator|.
name|take
argument_list|()
decl_stmt|;
if|if
condition|(
name|action
operator|instanceof
name|KillJobAction
condition|)
block|{
name|purgeJob
argument_list|(
operator|(
name|KillJobAction
operator|)
name|action
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|instanceof
name|KillTaskAction
condition|)
block|{
name|processKillTaskAction
argument_list|(
operator|(
name|KillTaskAction
operator|)
name|action
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Non-delete action given to cleanup thread: "
operator|+
name|action
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|except
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|except
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|,
literal|"taskCleanup"
argument_list|)
decl_stmt|;
DECL|method|processKillTaskAction (KillTaskAction killAction)
name|void
name|processKillTaskAction
parameter_list|(
name|KillTaskAction
name|killAction
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskInProgress
name|tip
decl_stmt|;
synchronized|synchronized
init|(
name|TaskTracker
operator|.
name|this
init|)
block|{
name|tip
operator|=
name|tasks
operator|.
name|get
argument_list|(
name|killAction
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Received KillTaskAction for task: "
operator|+
name|killAction
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
name|purgeTask
argument_list|(
name|tip
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|getTaskController ()
specifier|public
name|TaskController
name|getTaskController
parameter_list|()
block|{
return|return
name|taskController
return|;
block|}
comment|// Currently this is used only by tests
DECL|method|setTaskController (TaskController t)
name|void
name|setTaskController
parameter_list|(
name|TaskController
name|t
parameter_list|)
block|{
name|taskController
operator|=
name|t
expr_stmt|;
block|}
DECL|method|addTaskToJob (JobID jobId, TaskInProgress tip)
specifier|private
name|RunningJob
name|addTaskToJob
parameter_list|(
name|JobID
name|jobId
parameter_list|,
name|TaskInProgress
name|tip
parameter_list|)
block|{
synchronized|synchronized
init|(
name|runningJobs
init|)
block|{
name|RunningJob
name|rJob
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|runningJobs
operator|.
name|containsKey
argument_list|(
name|jobId
argument_list|)
condition|)
block|{
name|rJob
operator|=
operator|new
name|RunningJob
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
name|rJob
operator|.
name|localized
operator|=
literal|false
expr_stmt|;
name|rJob
operator|.
name|tasks
operator|=
operator|new
name|HashSet
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|runningJobs
operator|.
name|put
argument_list|(
name|jobId
argument_list|,
name|rJob
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rJob
operator|=
name|runningJobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|rJob
init|)
block|{
name|rJob
operator|.
name|tasks
operator|.
name|add
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
name|runningJobs
operator|.
name|notify
argument_list|()
expr_stmt|;
comment|//notify the fetcher thread
return|return
name|rJob
return|;
block|}
block|}
DECL|method|removeTaskFromJob (JobID jobId, TaskInProgress tip)
specifier|private
name|void
name|removeTaskFromJob
parameter_list|(
name|JobID
name|jobId
parameter_list|,
name|TaskInProgress
name|tip
parameter_list|)
block|{
synchronized|synchronized
init|(
name|runningJobs
init|)
block|{
name|RunningJob
name|rjob
init|=
name|runningJobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
if|if
condition|(
name|rjob
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown job "
operator|+
name|jobId
operator|+
literal|" being deleted."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
synchronized|synchronized
init|(
name|rjob
init|)
block|{
name|rjob
operator|.
name|tasks
operator|.
name|remove
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|getJobTokenSecretManager ()
name|JobTokenSecretManager
name|getJobTokenSecretManager
parameter_list|()
block|{
return|return
name|jobTokenSecretManager
return|;
block|}
DECL|method|getRunningJob (JobID jobId)
name|RunningJob
name|getRunningJob
parameter_list|(
name|JobID
name|jobId
parameter_list|)
block|{
return|return
name|runningJobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
return|;
block|}
DECL|method|getLocalizer ()
name|Localizer
name|getLocalizer
parameter_list|()
block|{
return|return
name|localizer
return|;
block|}
DECL|method|setLocalizer (Localizer l)
name|void
name|setLocalizer
parameter_list|(
name|Localizer
name|l
parameter_list|)
block|{
name|localizer
operator|=
name|l
expr_stmt|;
block|}
DECL|method|getUserDir (String user)
specifier|public
specifier|static
name|String
name|getUserDir
parameter_list|(
name|String
name|user
parameter_list|)
block|{
return|return
name|TaskTracker
operator|.
name|SUBDIR
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|user
return|;
block|}
DECL|method|getPrivateDistributedCacheDir (String user)
specifier|public
specifier|static
name|String
name|getPrivateDistributedCacheDir
parameter_list|(
name|String
name|user
parameter_list|)
block|{
return|return
name|getUserDir
argument_list|(
name|user
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|DISTCACHEDIR
return|;
block|}
DECL|method|getPublicDistributedCacheDir ()
specifier|public
specifier|static
name|String
name|getPublicDistributedCacheDir
parameter_list|()
block|{
return|return
name|TaskTracker
operator|.
name|SUBDIR
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|DISTCACHEDIR
return|;
block|}
DECL|method|getJobCacheSubdir (String user)
specifier|public
specifier|static
name|String
name|getJobCacheSubdir
parameter_list|(
name|String
name|user
parameter_list|)
block|{
return|return
name|getUserDir
argument_list|(
name|user
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|JOBCACHE
return|;
block|}
DECL|method|getLocalJobDir (String user, String jobid)
specifier|public
specifier|static
name|String
name|getLocalJobDir
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|)
block|{
return|return
name|getJobCacheSubdir
argument_list|(
name|user
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|jobid
return|;
block|}
DECL|method|getLocalJobConfFile (String user, String jobid)
specifier|static
name|String
name|getLocalJobConfFile
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|)
block|{
return|return
name|getLocalJobDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|JOBFILE
return|;
block|}
DECL|method|getLocalJobTokenFile (String user, String jobid)
specifier|static
name|String
name|getLocalJobTokenFile
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|)
block|{
return|return
name|getLocalJobDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|JOB_TOKEN_FILE
return|;
block|}
DECL|method|getTaskConfFile (String user, String jobid, String taskid, boolean isCleanupAttempt)
specifier|static
name|String
name|getTaskConfFile
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|,
name|String
name|taskid
parameter_list|,
name|boolean
name|isCleanupAttempt
parameter_list|)
block|{
return|return
name|getLocalTaskDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|,
name|taskid
argument_list|,
name|isCleanupAttempt
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|JOBFILE
return|;
block|}
DECL|method|getJobJarsDir (String user, String jobid)
specifier|static
name|String
name|getJobJarsDir
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|)
block|{
return|return
name|getLocalJobDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|JARSDIR
return|;
block|}
DECL|method|getJobJarFile (String user, String jobid)
specifier|static
name|String
name|getJobJarFile
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|)
block|{
return|return
name|getJobJarsDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"job.jar"
return|;
block|}
DECL|method|getJobWorkDir (String user, String jobid)
specifier|static
name|String
name|getJobWorkDir
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|)
block|{
return|return
name|getLocalJobDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|MRConstants
operator|.
name|WORKDIR
return|;
block|}
DECL|method|getLocalSplitMetaFile (String user, String jobid, String taskid)
specifier|static
name|String
name|getLocalSplitMetaFile
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|,
name|String
name|taskid
parameter_list|)
block|{
return|return
name|TaskTracker
operator|.
name|getLocalTaskDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|,
name|taskid
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|LOCAL_SPLIT_META_FILE
return|;
block|}
DECL|method|getLocalSplitFile (String user, String jobid, String taskid)
specifier|static
name|String
name|getLocalSplitFile
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|,
name|String
name|taskid
parameter_list|)
block|{
return|return
name|TaskTracker
operator|.
name|getLocalTaskDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|,
name|taskid
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|LOCAL_SPLIT_FILE
return|;
block|}
DECL|method|getIntermediateOutputDir (String user, String jobid, String taskid)
specifier|static
name|String
name|getIntermediateOutputDir
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|,
name|String
name|taskid
parameter_list|)
block|{
return|return
name|getLocalTaskDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|,
name|taskid
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|OUTPUT
return|;
block|}
DECL|method|getLocalTaskDir (String user, String jobid, String taskid)
specifier|static
name|String
name|getLocalTaskDir
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|,
name|String
name|taskid
parameter_list|)
block|{
return|return
name|getLocalTaskDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|,
name|taskid
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|getLocalTaskDir (String user, String jobid, String taskid, boolean isCleanupAttempt)
specifier|public
specifier|static
name|String
name|getLocalTaskDir
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|,
name|String
name|taskid
parameter_list|,
name|boolean
name|isCleanupAttempt
parameter_list|)
block|{
name|String
name|taskDir
init|=
name|getLocalJobDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|taskid
decl_stmt|;
if|if
condition|(
name|isCleanupAttempt
condition|)
block|{
name|taskDir
operator|=
name|taskDir
operator|+
name|TASK_CLEANUP_SUFFIX
expr_stmt|;
block|}
return|return
name|taskDir
return|;
block|}
DECL|method|getTaskWorkDir (String user, String jobid, String taskid, boolean isCleanupAttempt)
specifier|static
name|String
name|getTaskWorkDir
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|jobid
parameter_list|,
name|String
name|taskid
parameter_list|,
name|boolean
name|isCleanupAttempt
parameter_list|)
block|{
name|String
name|dir
init|=
name|getLocalTaskDir
argument_list|(
name|user
argument_list|,
name|jobid
argument_list|,
name|taskid
argument_list|,
name|isCleanupAttempt
argument_list|)
decl_stmt|;
return|return
name|dir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|MRConstants
operator|.
name|WORKDIR
return|;
block|}
DECL|method|getPid (TaskAttemptID tid)
name|String
name|getPid
parameter_list|(
name|TaskAttemptID
name|tid
parameter_list|)
block|{
name|TaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
return|return
name|jvmManager
operator|.
name|getPid
argument_list|(
name|tip
operator|.
name|getTaskRunner
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|getProtocolVersion (String protocol, long clientVersion)
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|TaskUmbilicalProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|TaskUmbilicalProtocol
operator|.
name|versionID
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol for task tracker: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
block|}
DECL|method|getHttpPort ()
name|int
name|getHttpPort
parameter_list|()
block|{
return|return
name|httpPort
return|;
block|}
comment|/**    * Do the real constructor work here.  It's in a separate method    * so we can call it again and "recycle" the object after calling    * close().    */
DECL|method|initialize ()
specifier|synchronized
name|void
name|initialize
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting tasktracker with owner as "
operator|+
name|aclsManager
operator|.
name|getMROwner
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
name|localFs
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|fConf
argument_list|)
expr_stmt|;
comment|// use configured nameserver& interface to get local hostname
if|if
condition|(
name|fConf
operator|.
name|get
argument_list|(
name|TT_HOST_NAME
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|localHostname
operator|=
name|fConf
operator|.
name|get
argument_list|(
name|TT_HOST_NAME
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localHostname
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|localHostname
operator|=
name|DNS
operator|.
name|getDefaultHost
argument_list|(
name|fConf
operator|.
name|get
argument_list|(
name|TT_DNS_INTERFACE
argument_list|,
literal|"default"
argument_list|)
argument_list|,
name|fConf
operator|.
name|get
argument_list|(
name|TT_DNS_NAMESERVER
argument_list|,
literal|"default"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Check local disk, start async disk service, and clean up all
comment|// local directories.
name|checkLocalDirs
argument_list|(
name|this
operator|.
name|fConf
operator|.
name|getLocalDirs
argument_list|()
argument_list|)
expr_stmt|;
name|setAsyncDiskService
argument_list|(
operator|new
name|MRAsyncDiskService
argument_list|(
name|fConf
argument_list|)
argument_list|)
expr_stmt|;
name|getAsyncDiskService
argument_list|()
operator|.
name|cleanupAllVolumes
argument_list|()
expr_stmt|;
comment|// Clear out state tables
name|this
operator|.
name|tasks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|runningTasks
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|runningJobs
operator|=
operator|new
name|TreeMap
argument_list|<
name|JobID
argument_list|,
name|RunningJob
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|mapTotal
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|reduceTotal
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|acceptNewTasks
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|status
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|minSpaceStart
operator|=
name|this
operator|.
name|fConf
operator|.
name|getLong
argument_list|(
name|TT_LOCAL_DIR_MINSPACE_START
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|this
operator|.
name|minSpaceKill
operator|=
name|this
operator|.
name|fConf
operator|.
name|getLong
argument_list|(
name|TT_LOCAL_DIR_MINSPACE_KILL
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|//tweak the probe sample size (make it a function of numCopiers)
name|probe_sample_size
operator|=
name|this
operator|.
name|fConf
operator|.
name|getInt
argument_list|(
name|TT_MAX_TASK_COMPLETION_EVENTS_TO_POLL
argument_list|,
literal|500
argument_list|)
expr_stmt|;
comment|// Set up TaskTracker instrumentation
name|this
operator|.
name|myInstrumentation
operator|=
name|createInstrumentation
argument_list|(
name|this
argument_list|,
name|fConf
argument_list|)
expr_stmt|;
comment|// bind address
name|InetSocketAddress
name|socAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|fConf
operator|.
name|get
argument_list|(
name|TT_REPORT_ADDRESS
argument_list|,
literal|"127.0.0.1:0"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|bindAddress
init|=
name|socAddr
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|int
name|tmpPort
init|=
name|socAddr
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|this
operator|.
name|jvmManager
operator|=
operator|new
name|JvmManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// RPC initialization
name|int
name|max
init|=
name|maxMapSlots
operator|>
name|maxReduceSlots
condition|?
name|maxMapSlots
else|:
name|maxReduceSlots
decl_stmt|;
comment|//set the num handlers to max*2 since canCommit may wait for the duration
comment|//of a heartbeat RPC
name|this
operator|.
name|taskReportServer
operator|=
name|RPC
operator|.
name|getServer
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|,
name|this
argument_list|,
name|bindAddress
argument_list|,
name|tmpPort
argument_list|,
literal|2
operator|*
name|max
argument_list|,
literal|false
argument_list|,
name|this
operator|.
name|fConf
argument_list|,
name|this
operator|.
name|jobTokenSecretManager
argument_list|)
expr_stmt|;
comment|// Set service-level authorization security policy
if|if
condition|(
name|this
operator|.
name|fConf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|PolicyProvider
name|policyProvider
init|=
call|(
name|PolicyProvider
call|)
argument_list|(
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|this
operator|.
name|fConf
operator|.
name|getClass
argument_list|(
name|PolicyProvider
operator|.
name|POLICY_PROVIDER_CONFIG
argument_list|,
name|MapReducePolicyProvider
operator|.
name|class
argument_list|,
name|PolicyProvider
operator|.
name|class
argument_list|)
argument_list|,
name|this
operator|.
name|fConf
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|taskReportServer
operator|.
name|refreshServiceAcl
argument_list|(
name|fConf
argument_list|,
name|policyProvider
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|taskReportServer
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// get the assigned address
name|this
operator|.
name|taskReportAddress
operator|=
name|taskReportServer
operator|.
name|getListenerAddress
argument_list|()
expr_stmt|;
name|this
operator|.
name|fConf
operator|.
name|set
argument_list|(
name|TT_REPORT_ADDRESS
argument_list|,
name|taskReportAddress
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|taskReportAddress
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"TaskTracker up at: "
operator|+
name|this
operator|.
name|taskReportAddress
argument_list|)
expr_stmt|;
name|this
operator|.
name|taskTrackerName
operator|=
literal|"tracker_"
operator|+
name|localHostname
operator|+
literal|":"
operator|+
name|taskReportAddress
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting tracker "
operator|+
name|taskTrackerName
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|TaskController
argument_list|>
name|taskControllerClass
init|=
name|fConf
operator|.
name|getClass
argument_list|(
name|TT_TASK_CONTROLLER
argument_list|,
name|DefaultTaskController
operator|.
name|class
argument_list|,
name|TaskController
operator|.
name|class
argument_list|)
decl_stmt|;
name|taskController
operator|=
operator|(
name|TaskController
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|taskControllerClass
argument_list|,
name|fConf
argument_list|)
expr_stmt|;
comment|// setup and create jobcache directory with appropriate permissions
name|taskController
operator|.
name|setup
argument_list|()
expr_stmt|;
comment|// Initialize DistributedCache
name|this
operator|.
name|distributedCacheManager
operator|=
operator|new
name|TrackerDistributedCacheManager
argument_list|(
name|this
operator|.
name|fConf
argument_list|,
name|taskController
argument_list|,
name|asyncDiskService
argument_list|)
expr_stmt|;
name|this
operator|.
name|distributedCacheManager
operator|.
name|startCleanupThread
argument_list|()
expr_stmt|;
name|this
operator|.
name|jobClient
operator|=
operator|(
name|InterTrackerProtocol
operator|)
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|RPC
operator|.
name|waitForProxy
argument_list|(
name|InterTrackerProtocol
operator|.
name|class
argument_list|,
name|InterTrackerProtocol
operator|.
name|versionID
argument_list|,
name|jobTrackAddr
argument_list|,
name|fConf
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|this
operator|.
name|justInited
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|running
operator|=
literal|true
expr_stmt|;
comment|// start the thread that will fetch map task completion events
name|this
operator|.
name|mapEventsFetcher
operator|=
operator|new
name|MapEventsFetcherThread
argument_list|()
expr_stmt|;
name|mapEventsFetcher
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|mapEventsFetcher
operator|.
name|setName
argument_list|(
literal|"Map-events fetcher for all reduce tasks "
operator|+
literal|"on "
operator|+
name|taskTrackerName
argument_list|)
expr_stmt|;
name|mapEventsFetcher
operator|.
name|start
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|ResourceCalculatorPlugin
argument_list|>
name|clazz
init|=
name|fConf
operator|.
name|getClass
argument_list|(
name|TT_RESOURCE_CALCULATOR_PLUGIN
argument_list|,
literal|null
argument_list|,
name|ResourceCalculatorPlugin
operator|.
name|class
argument_list|)
decl_stmt|;
name|resourceCalculatorPlugin
operator|=
name|ResourceCalculatorPlugin
operator|.
name|getResourceCalculatorPlugin
argument_list|(
name|clazz
argument_list|,
name|fConf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|" Using ResourceCalculatorPlugin : "
operator|+
name|resourceCalculatorPlugin
argument_list|)
expr_stmt|;
name|initializeMemoryManagement
argument_list|()
expr_stmt|;
name|setIndexCache
argument_list|(
operator|new
name|IndexCache
argument_list|(
name|this
operator|.
name|fConf
argument_list|)
argument_list|)
expr_stmt|;
comment|//clear old user logs
name|taskLogCleanupThread
operator|.
name|clearOldUserLogs
argument_list|(
name|this
operator|.
name|fConf
argument_list|)
expr_stmt|;
name|mapLauncher
operator|=
operator|new
name|TaskLauncher
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|,
name|maxMapSlots
argument_list|)
expr_stmt|;
name|reduceLauncher
operator|=
operator|new
name|TaskLauncher
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|,
name|maxReduceSlots
argument_list|)
expr_stmt|;
name|mapLauncher
operator|.
name|start
argument_list|()
expr_stmt|;
name|reduceLauncher
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// create a localizer instance
name|setLocalizer
argument_list|(
operator|new
name|Localizer
argument_list|(
name|localFs
argument_list|,
name|fConf
operator|.
name|getLocalDirs
argument_list|()
argument_list|,
name|taskController
argument_list|)
argument_list|)
expr_stmt|;
comment|//Start up node health checker service.
if|if
condition|(
name|shouldStartHealthMonitor
argument_list|(
name|this
operator|.
name|fConf
argument_list|)
condition|)
block|{
name|startHealthMonitor
argument_list|(
name|this
operator|.
name|fConf
argument_list|)
expr_stmt|;
block|}
name|oobHeartbeatOnTaskCompletion
operator|=
name|fConf
operator|.
name|getBoolean
argument_list|(
name|TT_OUTOFBAND_HEARBEAT
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Are ACLs for authorization checks enabled on the MR cluster ?    */
DECL|method|areACLsEnabled ()
name|boolean
name|areACLsEnabled
parameter_list|()
block|{
return|return
name|fConf
operator|.
name|getBoolean
argument_list|(
name|MRConfig
operator|.
name|MR_ACLS_ENABLED
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|getInstrumentationClasses (Configuration conf)
specifier|public
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|getInstrumentationClasses
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getClasses
argument_list|(
name|TT_INSTRUMENTATION
argument_list|,
name|TaskTrackerMetricsInst
operator|.
name|class
argument_list|)
return|;
block|}
DECL|method|setInstrumentationClass ( Configuration conf, Class<? extends TaskTrackerInstrumentation> t)
specifier|public
specifier|static
name|void
name|setInstrumentationClass
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|TaskTrackerInstrumentation
argument_list|>
name|t
parameter_list|)
block|{
name|conf
operator|.
name|setClass
argument_list|(
name|TT_INSTRUMENTATION
argument_list|,
name|t
argument_list|,
name|TaskTrackerInstrumentation
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|createInstrumentation ( TaskTracker tt, Configuration conf)
specifier|public
specifier|static
name|TaskTrackerInstrumentation
name|createInstrumentation
parameter_list|(
name|TaskTracker
name|tt
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|instrumentationClasses
init|=
name|getInstrumentationClasses
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|instrumentationClasses
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Empty string given for "
operator|+
name|TT_INSTRUMENTATION
operator|+
literal|" property -- will use default instrumentation class instead"
argument_list|)
expr_stmt|;
return|return
operator|new
name|TaskTrackerMetricsInst
argument_list|(
name|tt
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|instrumentationClasses
operator|.
name|length
operator|==
literal|1
condition|)
block|{
comment|// Just one instrumentation class given; create it directly
name|Class
argument_list|<
name|?
argument_list|>
name|cls
init|=
name|instrumentationClasses
index|[
literal|0
index|]
decl_stmt|;
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
argument_list|<
name|?
argument_list|>
name|c
init|=
name|cls
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
index|[]
block|{
name|TaskTracker
operator|.
name|class
block|}
argument_list|)
decl_stmt|;
return|return
operator|(
name|TaskTrackerInstrumentation
operator|)
name|c
operator|.
name|newInstance
argument_list|(
name|tt
argument_list|)
return|;
block|}
else|else
block|{
comment|// Multiple instrumentation classes given; use a composite object
name|List
argument_list|<
name|TaskTrackerInstrumentation
argument_list|>
name|instrumentations
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerInstrumentation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|cls
range|:
name|instrumentationClasses
control|)
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
argument_list|<
name|?
argument_list|>
name|c
init|=
name|cls
operator|.
name|getConstructor
argument_list|(
operator|new
name|Class
index|[]
block|{
name|TaskTracker
operator|.
name|class
block|}
argument_list|)
decl_stmt|;
name|TaskTrackerInstrumentation
name|inst
init|=
operator|(
name|TaskTrackerInstrumentation
operator|)
name|c
operator|.
name|newInstance
argument_list|(
name|tt
argument_list|)
decl_stmt|;
name|instrumentations
operator|.
name|add
argument_list|(
name|inst
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|CompositeTaskTrackerInstrumentation
argument_list|(
name|tt
argument_list|,
name|instrumentations
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Reflection can throw lots of exceptions -- handle them all by
comment|// falling back on the default.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to initialize TaskTracker metrics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|TaskTrackerMetricsInst
argument_list|(
name|tt
argument_list|)
return|;
block|}
block|}
comment|/**    * Removes all contents of temporary storage.  Called upon    * startup, to remove any leftovers from previous run.    *     * Use MRAsyncDiskService.moveAndDeleteAllVolumes instead.    * @see org.apache.hadoop.mapreduce.util.MRAsyncDiskService#cleanupAllVolumes()    */
annotation|@
name|Deprecated
DECL|method|cleanupStorage ()
specifier|public
name|void
name|cleanupStorage
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|fConf
operator|.
name|deleteLocalFiles
argument_list|()
expr_stmt|;
block|}
comment|// Object on wait which MapEventsFetcherThread is going to wait.
DECL|field|waitingOn
specifier|private
name|Object
name|waitingOn
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|class|MapEventsFetcherThread
specifier|private
class|class
name|MapEventsFetcherThread
extends|extends
name|Thread
block|{
DECL|method|reducesInShuffle ()
specifier|private
name|List
argument_list|<
name|FetchStatus
argument_list|>
name|reducesInShuffle
parameter_list|()
block|{
name|List
argument_list|<
name|FetchStatus
argument_list|>
name|fList
init|=
operator|new
name|ArrayList
argument_list|<
name|FetchStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|JobID
argument_list|,
name|RunningJob
argument_list|>
name|item
range|:
name|runningJobs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RunningJob
name|rjob
init|=
name|item
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|JobID
name|jobId
init|=
name|item
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|FetchStatus
name|f
decl_stmt|;
synchronized|synchronized
init|(
name|rjob
init|)
block|{
name|f
operator|=
name|rjob
operator|.
name|getFetchStatus
argument_list|()
expr_stmt|;
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|rjob
operator|.
name|tasks
control|)
block|{
name|Task
name|task
init|=
name|tip
operator|.
name|getTask
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|task
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ReduceTask
operator|)
name|task
operator|)
operator|.
name|getPhase
argument_list|()
operator|==
name|TaskStatus
operator|.
name|Phase
operator|.
name|SHUFFLE
condition|)
block|{
if|if
condition|(
name|rjob
operator|.
name|getFetchStatus
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|//this is a new job; we start fetching its map events
name|f
operator|=
operator|new
name|FetchStatus
argument_list|(
name|jobId
argument_list|,
operator|(
operator|(
name|ReduceTask
operator|)
name|task
operator|)
operator|.
name|getNumMaps
argument_list|()
argument_list|)
expr_stmt|;
name|rjob
operator|.
name|setFetchStatus
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|rjob
operator|.
name|getFetchStatus
argument_list|()
expr_stmt|;
name|fList
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
break|break;
comment|//no need to check any more tasks belonging to this
block|}
block|}
block|}
block|}
block|}
comment|//at this point, we have information about for which of
comment|//the running jobs do we need to query the jobtracker for map
comment|//outputs (actually map events).
return|return
name|fList
return|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting thread: "
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|List
argument_list|<
name|FetchStatus
argument_list|>
name|fList
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|runningJobs
init|)
block|{
while|while
condition|(
operator|(
operator|(
name|fList
operator|=
name|reducesInShuffle
argument_list|()
operator|)
operator|.
name|size
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|runningJobs
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutting down: "
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// now fetch all the map task events for all the reduce tasks
comment|// possibly belonging to different jobs
name|boolean
name|fetchAgain
init|=
literal|false
decl_stmt|;
comment|//flag signifying whether we want to fetch
comment|//immediately again.
for|for
control|(
name|FetchStatus
name|f
range|:
name|fList
control|)
block|{
name|long
name|currentTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
comment|//the method below will return true when we have not
comment|//fetched all available events yet
if|if
condition|(
name|f
operator|.
name|fetchMapCompletionEvents
argument_list|(
name|currentTime
argument_list|)
condition|)
block|{
name|fetchAgain
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring exception that fetch for map completion"
operator|+
literal|" events threw for "
operator|+
name|f
operator|.
name|jobId
operator|+
literal|" threw: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|running
condition|)
block|{
break|break;
block|}
block|}
synchronized|synchronized
init|(
name|waitingOn
init|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|fetchAgain
condition|)
block|{
name|waitingOn
operator|.
name|wait
argument_list|(
name|heartbeatInterval
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutting down: "
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring exception "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|FetchStatus
specifier|private
class|class
name|FetchStatus
block|{
comment|/** The next event ID that we will start querying the JobTracker from*/
DECL|field|fromEventId
specifier|private
name|IntWritable
name|fromEventId
decl_stmt|;
comment|/** This is the cache of map events for a given job */
DECL|field|allMapEvents
specifier|private
name|List
argument_list|<
name|TaskCompletionEvent
argument_list|>
name|allMapEvents
decl_stmt|;
comment|/** What jobid this fetchstatus object is for*/
DECL|field|jobId
specifier|private
name|JobID
name|jobId
decl_stmt|;
DECL|field|lastFetchTime
specifier|private
name|long
name|lastFetchTime
decl_stmt|;
DECL|field|fetchAgain
specifier|private
name|boolean
name|fetchAgain
decl_stmt|;
DECL|method|FetchStatus (JobID jobId, int numMaps)
specifier|public
name|FetchStatus
parameter_list|(
name|JobID
name|jobId
parameter_list|,
name|int
name|numMaps
parameter_list|)
block|{
name|this
operator|.
name|fromEventId
operator|=
operator|new
name|IntWritable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|jobId
operator|=
name|jobId
expr_stmt|;
name|this
operator|.
name|allMapEvents
operator|=
operator|new
name|ArrayList
argument_list|<
name|TaskCompletionEvent
argument_list|>
argument_list|(
name|numMaps
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reset the events obtained so far.      */
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
comment|// Note that the sync is first on fromEventId and then on allMapEvents
synchronized|synchronized
init|(
name|fromEventId
init|)
block|{
synchronized|synchronized
init|(
name|allMapEvents
init|)
block|{
name|fromEventId
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// set the new index for TCE
name|allMapEvents
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getMapEvents (int fromId, int max)
specifier|public
name|TaskCompletionEvent
index|[]
name|getMapEvents
parameter_list|(
name|int
name|fromId
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|TaskCompletionEvent
index|[]
name|mapEvents
init|=
name|TaskCompletionEvent
operator|.
name|EMPTY_ARRAY
decl_stmt|;
name|boolean
name|notifyFetcher
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|allMapEvents
init|)
block|{
if|if
condition|(
name|allMapEvents
operator|.
name|size
argument_list|()
operator|>
name|fromId
condition|)
block|{
name|int
name|actualMax
init|=
name|Math
operator|.
name|min
argument_list|(
name|max
argument_list|,
operator|(
name|allMapEvents
operator|.
name|size
argument_list|()
operator|-
name|fromId
operator|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TaskCompletionEvent
argument_list|>
name|eventSublist
init|=
name|allMapEvents
operator|.
name|subList
argument_list|(
name|fromId
argument_list|,
name|actualMax
operator|+
name|fromId
argument_list|)
decl_stmt|;
name|mapEvents
operator|=
name|eventSublist
operator|.
name|toArray
argument_list|(
name|mapEvents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Notify Fetcher thread.
name|notifyFetcher
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|notifyFetcher
condition|)
block|{
synchronized|synchronized
init|(
name|waitingOn
init|)
block|{
name|waitingOn
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mapEvents
return|;
block|}
DECL|method|fetchMapCompletionEvents (long currTime)
specifier|public
name|boolean
name|fetchMapCompletionEvents
parameter_list|(
name|long
name|currTime
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|fetchAgain
operator|&&
operator|(
name|currTime
operator|-
name|lastFetchTime
operator|)
operator|<
name|heartbeatInterval
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|currFromEventId
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|fromEventId
init|)
block|{
name|currFromEventId
operator|=
name|fromEventId
operator|.
name|get
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|TaskCompletionEvent
argument_list|>
name|recentMapEvents
init|=
name|queryJobTracker
argument_list|(
name|fromEventId
argument_list|,
name|jobId
argument_list|,
name|jobClient
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|allMapEvents
init|)
block|{
name|allMapEvents
operator|.
name|addAll
argument_list|(
name|recentMapEvents
argument_list|)
expr_stmt|;
block|}
name|lastFetchTime
operator|=
name|currTime
expr_stmt|;
if|if
condition|(
name|fromEventId
operator|.
name|get
argument_list|()
operator|-
name|currFromEventId
operator|>=
name|probe_sample_size
condition|)
block|{
comment|//return true when we have fetched the full payload, indicating
comment|//that we should fetch again immediately (there might be more to
comment|//fetch
name|fetchAgain
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|fetchAgain
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|field|lDirAlloc
specifier|private
specifier|static
name|LocalDirAllocator
name|lDirAlloc
init|=
operator|new
name|LocalDirAllocator
argument_list|(
name|MRConfig
operator|.
name|LOCAL_DIR
argument_list|)
decl_stmt|;
comment|// intialize the job directory
DECL|method|localizeJob (TaskInProgress tip )
name|RunningJob
name|localizeJob
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Task
name|t
init|=
name|tip
operator|.
name|getTask
argument_list|()
decl_stmt|;
name|JobID
name|jobId
init|=
name|t
operator|.
name|getJobID
argument_list|()
decl_stmt|;
name|RunningJob
name|rjob
init|=
name|addTaskToJob
argument_list|(
name|jobId
argument_list|,
name|tip
argument_list|)
decl_stmt|;
comment|// Initialize the user directories if needed.
name|getLocalizer
argument_list|()
operator|.
name|initializeUserDirs
argument_list|(
name|t
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|rjob
init|)
block|{
if|if
condition|(
operator|!
name|rjob
operator|.
name|localized
condition|)
block|{
name|JobConf
name|localJobConf
init|=
name|localizeJobFiles
argument_list|(
name|t
argument_list|,
name|rjob
argument_list|)
decl_stmt|;
comment|// initialize job log directory
name|initializeJobLogDir
argument_list|(
name|jobId
argument_list|,
name|localJobConf
argument_list|)
expr_stmt|;
comment|// Now initialize the job via task-controller so as to set
comment|// ownership/permissions of jars, job-work-dir. Note that initializeJob
comment|// should be the last call after every other directory/file to be
comment|// directly under the job directory is created.
name|JobInitializationContext
name|context
init|=
operator|new
name|JobInitializationContext
argument_list|()
decl_stmt|;
name|context
operator|.
name|jobid
operator|=
name|jobId
expr_stmt|;
name|context
operator|.
name|user
operator|=
name|t
operator|.
name|getUser
argument_list|()
expr_stmt|;
name|context
operator|.
name|workDir
operator|=
operator|new
name|File
argument_list|(
name|localJobConf
operator|.
name|get
argument_list|(
name|JOB_LOCAL_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|taskController
operator|.
name|initializeJob
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|rjob
operator|.
name|jobConf
operator|=
name|localJobConf
expr_stmt|;
name|rjob
operator|.
name|keepJobFiles
operator|=
operator|(
operator|(
name|localJobConf
operator|.
name|getKeepTaskFilesPattern
argument_list|()
operator|!=
literal|null
operator|)
operator|||
name|localJobConf
operator|.
name|getKeepFailedTaskFiles
argument_list|()
operator|)
expr_stmt|;
name|rjob
operator|.
name|localized
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|rjob
return|;
block|}
DECL|method|getFS (final Path filePath, JobID jobId, final Configuration conf)
specifier|private
name|FileSystem
name|getFS
parameter_list|(
specifier|final
name|Path
name|filePath
parameter_list|,
name|JobID
name|jobId
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|RunningJob
name|rJob
init|=
name|runningJobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
name|FileSystem
name|userFs
init|=
name|rJob
operator|.
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|filePath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|userFs
return|;
block|}
comment|/**    * Localize the job on this tasktracker. Specifically    *<ul>    *<li>Cleanup and create job directories on all disks</li>    *<li>Download the job config file job.xml from the FS</li>    *<li>Create the job work directory and set {@link TaskTracker#JOB_LOCAL_DIR}    * in the configuration.    *<li>Download the job jar file job.jar from the FS, unjar it and set jar    * file in the configuration.</li>    *</ul>    *     * @param t task whose job has to be localized on this TT    * @return the modified job configuration to be used for all the tasks of this    *         job as a starting point.    * @throws IOException    */
DECL|method|localizeJobFiles (Task t, RunningJob rjob)
name|JobConf
name|localizeJobFiles
parameter_list|(
name|Task
name|t
parameter_list|,
name|RunningJob
name|rjob
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|JobID
name|jobId
init|=
name|t
operator|.
name|getJobID
argument_list|()
decl_stmt|;
name|String
name|userName
init|=
name|t
operator|.
name|getUser
argument_list|()
decl_stmt|;
comment|// Initialize the job directories
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|fConf
argument_list|)
decl_stmt|;
name|getLocalizer
argument_list|()
operator|.
name|initializeJobDirs
argument_list|(
name|userName
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
comment|// save local copy of JobToken file
name|String
name|localJobTokenFile
init|=
name|localizeJobTokenFile
argument_list|(
name|t
operator|.
name|getUser
argument_list|()
argument_list|,
name|jobId
argument_list|)
decl_stmt|;
name|rjob
operator|.
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|t
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|Credentials
name|ts
init|=
name|TokenCache
operator|.
name|loadTokens
argument_list|(
name|localJobTokenFile
argument_list|,
name|fConf
argument_list|)
decl_stmt|;
name|Token
argument_list|<
name|JobTokenIdentifier
argument_list|>
name|jt
init|=
name|TokenCache
operator|.
name|getJobToken
argument_list|(
name|ts
argument_list|)
decl_stmt|;
if|if
condition|(
name|jt
operator|!=
literal|null
condition|)
block|{
comment|//could be null in the case of some unit tests
name|getJobTokenSecretManager
argument_list|()
operator|.
name|addTokenForJob
argument_list|(
name|jobId
operator|.
name|toString
argument_list|()
argument_list|,
name|jt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
range|:
name|ts
operator|.
name|getAllTokens
argument_list|()
control|)
block|{
name|rjob
operator|.
name|ugi
operator|.
name|addToken
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
comment|// Download the job.xml for this job from the system FS
name|Path
name|localJobFile
init|=
name|localizeJobConfFile
argument_list|(
operator|new
name|Path
argument_list|(
name|t
operator|.
name|getJobFile
argument_list|()
argument_list|)
argument_list|,
name|userName
argument_list|,
name|jobId
argument_list|)
decl_stmt|;
name|JobConf
name|localJobConf
init|=
operator|new
name|JobConf
argument_list|(
name|localJobFile
argument_list|)
decl_stmt|;
comment|//WE WILL TRUST THE USERNAME THAT WE GOT FROM THE JOBTRACKER
comment|//AS PART OF THE TASK OBJECT
name|localJobConf
operator|.
name|setUser
argument_list|(
name|userName
argument_list|)
expr_stmt|;
comment|// set the location of the token file into jobConf to transfer
comment|// the name to TaskRunner
name|localJobConf
operator|.
name|set
argument_list|(
name|TokenCache
operator|.
name|JOB_TOKENS_FILENAME
argument_list|,
name|localJobTokenFile
argument_list|)
expr_stmt|;
comment|// create the 'job-work' directory: job-specific shared directory for use as
comment|// scratch space by all tasks of the same job running on this TaskTracker.
name|Path
name|workDir
init|=
name|lDirAlloc
operator|.
name|getLocalPathForWrite
argument_list|(
name|getJobWorkDir
argument_list|(
name|userName
argument_list|,
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|fConf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|localFs
operator|.
name|mkdirs
argument_list|(
name|workDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|workDir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|System
operator|.
name|setProperty
argument_list|(
name|JOB_LOCAL_DIR
argument_list|,
name|workDir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|localJobConf
operator|.
name|set
argument_list|(
name|JOB_LOCAL_DIR
argument_list|,
name|workDir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// Download the job.jar for this job from the system FS
name|localizeJobJarFile
argument_list|(
name|userName
argument_list|,
name|jobId
argument_list|,
name|localFs
argument_list|,
name|localJobConf
argument_list|)
expr_stmt|;
return|return
name|localJobConf
return|;
block|}
comment|// Create job userlog dir.
comment|// Create job acls file in job log dir, if needed.
DECL|method|initializeJobLogDir (JobID jobId, JobConf localJobConf)
name|void
name|initializeJobLogDir
parameter_list|(
name|JobID
name|jobId
parameter_list|,
name|JobConf
name|localJobConf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// remove it from tasklog cleanup thread first,
comment|// it might be added there because of tasktracker reinit or restart
name|taskLogCleanupThread
operator|.
name|unmarkJobFromLogDeletion
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
name|localizer
operator|.
name|initializeJobLogDir
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
if|if
condition|(
name|areACLsEnabled
argument_list|()
condition|)
block|{
comment|// Create job-acls.xml file in job userlog dir and write the needed
comment|// info for authorization of users for viewing task logs of this job.
name|writeJobACLs
argument_list|(
name|localJobConf
argument_list|,
name|TaskLog
operator|.
name|getJobDir
argument_list|(
name|jobId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    *  Creates job-acls.xml under the given directory logDir and writes    *  job-view-acl, queue-admins-acl, jobOwner name and queue name into this    *  file.    *  queue name is the queue to which the job was submitted to.    *  queue-admins-acl is the queue admins ACL of the queue to which this    *  job was submitted to.    * @param conf   job configuration    * @param logDir job userlog dir    * @throws IOException    */
DECL|method|writeJobACLs (JobConf conf, File logDir)
specifier|private
specifier|static
name|void
name|writeJobACLs
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|File
name|logDir
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|aclFile
init|=
operator|new
name|File
argument_list|(
name|logDir
argument_list|,
name|jobACLsFile
argument_list|)
decl_stmt|;
name|JobConf
name|aclConf
init|=
operator|new
name|JobConf
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// set the job view acl in aclConf
name|String
name|jobViewACL
init|=
name|conf
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|JOB_ACL_VIEW_JOB
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
name|aclConf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|JOB_ACL_VIEW_JOB
argument_list|,
name|jobViewACL
argument_list|)
expr_stmt|;
comment|// set the job queue name in aclConf
name|String
name|queue
init|=
name|conf
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|aclConf
operator|.
name|setQueueName
argument_list|(
name|queue
argument_list|)
expr_stmt|;
comment|// set the queue admins acl in aclConf
name|String
name|qACLName
init|=
name|toFullPropertyName
argument_list|(
name|queue
argument_list|,
name|QueueACL
operator|.
name|ADMINISTER_JOBS
operator|.
name|getAclName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|queueAdminsACL
init|=
name|conf
operator|.
name|get
argument_list|(
name|qACLName
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
name|aclConf
operator|.
name|set
argument_list|(
name|qACLName
argument_list|,
name|queueAdminsACL
argument_list|)
expr_stmt|;
comment|// set jobOwner as user.name in aclConf
name|String
name|jobOwner
init|=
name|conf
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|aclConf
operator|.
name|set
argument_list|(
literal|"user.name"
argument_list|,
name|jobOwner
argument_list|)
expr_stmt|;
name|FileOutputStream
name|out
decl_stmt|;
try|try
block|{
name|out
operator|=
name|SecureIOUtils
operator|.
name|createForWrite
argument_list|(
name|aclFile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecureIOUtils
operator|.
name|AlreadyExistsException
name|aee
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Job ACL file already exists at "
operator|+
name|aclFile
argument_list|,
name|aee
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|aclConf
operator|.
name|writeXml
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Download the job configuration file from the FS.    *     * @param t Task whose job file has to be downloaded    * @param jobId jobid of the task    * @return the local file system path of the downloaded file.    * @throws IOException    */
DECL|method|localizeJobConfFile (Path jobFile, String user, JobID jobId)
specifier|private
name|Path
name|localizeJobConfFile
parameter_list|(
name|Path
name|jobFile
parameter_list|,
name|String
name|user
parameter_list|,
name|JobID
name|jobId
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|JobConf
name|conf
init|=
operator|new
name|JobConf
argument_list|(
name|getJobConf
argument_list|()
argument_list|)
decl_stmt|;
name|FileSystem
name|userFs
init|=
name|getFS
argument_list|(
name|jobFile
argument_list|,
name|jobId
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Get sizes of JobFile
comment|// sizes are -1 if they are not present.
name|FileStatus
name|status
init|=
literal|null
decl_stmt|;
name|long
name|jobFileSize
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|status
operator|=
name|userFs
operator|.
name|getFileStatus
argument_list|(
name|jobFile
argument_list|)
expr_stmt|;
name|jobFileSize
operator|=
name|status
operator|.
name|getLen
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fe
parameter_list|)
block|{
name|jobFileSize
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|Path
name|localJobFile
init|=
name|lDirAlloc
operator|.
name|getLocalPathForWrite
argument_list|(
name|getLocalJobConfFile
argument_list|(
name|user
argument_list|,
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|jobFileSize
argument_list|,
name|fConf
argument_list|)
decl_stmt|;
comment|// Download job.xml
name|userFs
operator|.
name|copyToLocalFile
argument_list|(
name|jobFile
argument_list|,
name|localJobFile
argument_list|)
expr_stmt|;
return|return
name|localJobFile
return|;
block|}
comment|/**    * Download the job jar file from FS to the local file system and unjar it.    * Set the local jar file in the passed configuration.    *     * @param jobId    * @param localFs    * @param localJobConf    * @throws IOException    */
DECL|method|localizeJobJarFile (String user, JobID jobId, FileSystem localFs, JobConf localJobConf)
specifier|private
name|void
name|localizeJobJarFile
parameter_list|(
name|String
name|user
parameter_list|,
name|JobID
name|jobId
parameter_list|,
name|FileSystem
name|localFs
parameter_list|,
name|JobConf
name|localJobConf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// copy Jar file to the local FS and unjar it.
name|String
name|jarFile
init|=
name|localJobConf
operator|.
name|getJar
argument_list|()
decl_stmt|;
name|FileStatus
name|status
init|=
literal|null
decl_stmt|;
name|long
name|jarFileSize
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|jarFile
operator|!=
literal|null
condition|)
block|{
name|Path
name|jarFilePath
init|=
operator|new
name|Path
argument_list|(
name|jarFile
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getFS
argument_list|(
name|jarFilePath
argument_list|,
name|jobId
argument_list|,
name|localJobConf
argument_list|)
decl_stmt|;
try|try
block|{
name|status
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|jarFilePath
argument_list|)
expr_stmt|;
name|jarFileSize
operator|=
name|status
operator|.
name|getLen
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fe
parameter_list|)
block|{
name|jarFileSize
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// Here we check for five times the size of jarFileSize to accommodate for
comment|// unjarring the jar file in the jars directory
name|Path
name|localJarFile
init|=
name|lDirAlloc
operator|.
name|getLocalPathForWrite
argument_list|(
name|getJobJarFile
argument_list|(
name|user
argument_list|,
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
literal|5
operator|*
name|jarFileSize
argument_list|,
name|fConf
argument_list|)
decl_stmt|;
comment|// Download job.jar
name|fs
operator|.
name|copyToLocalFile
argument_list|(
name|jarFilePath
argument_list|,
name|localJarFile
argument_list|)
expr_stmt|;
name|localJobConf
operator|.
name|setJar
argument_list|(
name|localJarFile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Un-jar the parts of the job.jar that need to be added to the classpath
name|RunJar
operator|.
name|unJar
argument_list|(
operator|new
name|File
argument_list|(
name|localJarFile
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
operator|new
name|File
argument_list|(
name|localJarFile
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|localJobConf
operator|.
name|getJarUnpackPattern
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|launchTaskForJob (TaskInProgress tip, JobConf jobConf, UserGroupInformation ugi)
specifier|protected
name|void
name|launchTaskForJob
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|JobConf
name|jobConf
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|tip
init|)
block|{
name|tip
operator|.
name|setJobConf
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
name|tip
operator|.
name|setUGI
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
name|tip
operator|.
name|launchTask
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|shutdown ()
specifier|public
specifier|synchronized
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|shuttingDown
operator|=
literal|true
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|server
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutting down StatusHttpServer"
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception shutting down TaskTracker"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Close down the TaskTracker and all its components.  We must also shutdown    * any running tasks or threads, and cleanup disk space.  A new TaskTracker    * within the same process space might be restarted, so everything must be    * clean.    */
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|//
comment|// Kill running tasks.  Do this in a 2nd vector, called 'tasksToClose',
comment|// because calling jobHasFinished() may result in an edit to 'tasks'.
comment|//
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskInProgress
argument_list|>
name|tasksToClose
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
name|tasksToClose
operator|.
name|putAll
argument_list|(
name|tasks
argument_list|)
expr_stmt|;
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|tasksToClose
operator|.
name|values
argument_list|()
control|)
block|{
name|tip
operator|.
name|jobHasFinished
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|asyncDiskService
operator|!=
literal|null
condition|)
block|{
comment|// Clear local storage
name|asyncDiskService
operator|.
name|cleanupAllVolumes
argument_list|()
expr_stmt|;
comment|// Shutdown all async deletion threads with up to 10 seconds of delay
name|asyncDiskService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|asyncDiskService
operator|.
name|awaitTermination
argument_list|(
literal|10000
argument_list|)
condition|)
block|{
name|asyncDiskService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|asyncDiskService
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|asyncDiskService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|asyncDiskService
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Shutdown the fetcher thread
name|this
operator|.
name|mapEventsFetcher
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|//stop the launchers
name|this
operator|.
name|mapLauncher
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|this
operator|.
name|reduceLauncher
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|this
operator|.
name|distributedCacheManager
operator|.
name|stopCleanupThread
argument_list|()
expr_stmt|;
name|jvmManager
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// shutdown RPC connections
name|RPC
operator|.
name|stopProxy
argument_list|(
name|jobClient
argument_list|)
expr_stmt|;
comment|// wait for the fetcher thread to exit
for|for
control|(
name|boolean
name|done
init|=
literal|false
init|;
operator|!
name|done
condition|;
control|)
block|{
try|try
block|{
name|this
operator|.
name|mapEventsFetcher
operator|.
name|join
argument_list|()
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{       }
block|}
if|if
condition|(
name|taskReportServer
operator|!=
literal|null
condition|)
block|{
name|taskReportServer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|taskReportServer
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|healthChecker
operator|!=
literal|null
condition|)
block|{
comment|//stop node health checker service
name|healthChecker
operator|.
name|stop
argument_list|()
expr_stmt|;
name|healthChecker
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * For testing    */
DECL|method|TaskTracker ()
name|TaskTracker
parameter_list|()
block|{
name|server
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|setConf (JobConf conf)
name|void
name|setConf
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
name|fConf
operator|=
name|conf
expr_stmt|;
block|}
comment|/**    * Start with the local machine name, and the default JobTracker    */
DECL|method|TaskTracker (JobConf conf)
specifier|public
name|TaskTracker
parameter_list|(
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|fConf
operator|=
name|conf
expr_stmt|;
name|maxMapSlots
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|TT_MAP_SLOTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|maxReduceSlots
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|TT_REDUCE_SLOTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|aclsManager
operator|=
operator|new
name|ACLsManager
argument_list|(
name|fConf
argument_list|,
operator|new
name|JobACLsManager
argument_list|(
name|fConf
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|jobTrackAddr
operator|=
name|JobTracker
operator|.
name|getAddress
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|InetSocketAddress
name|infoSocAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|TT_HTTP_ADDRESS
argument_list|,
literal|"0.0.0.0:50060"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|httpBindAddress
init|=
name|infoSocAddr
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|int
name|httpPort
init|=
name|infoSocAddr
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|this
operator|.
name|server
operator|=
operator|new
name|HttpServer
argument_list|(
literal|"task"
argument_list|,
name|httpBindAddress
argument_list|,
name|httpPort
argument_list|,
name|httpPort
operator|==
literal|0
argument_list|,
name|conf
argument_list|,
name|aclsManager
operator|.
name|getAdminsAcl
argument_list|()
argument_list|)
expr_stmt|;
name|workerThreads
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|TT_HTTP_THREADS
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|this
operator|.
name|shuffleServerMetrics
operator|=
operator|new
name|ShuffleServerMetrics
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|server
operator|.
name|setThreads
argument_list|(
literal|1
argument_list|,
name|workerThreads
argument_list|)
expr_stmt|;
comment|// let the jsp pages get to the task tracker, config, and other relevant
comment|// objects
name|FileSystem
name|local
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|localDirAllocator
operator|=
operator|new
name|LocalDirAllocator
argument_list|(
name|MRConfig
operator|.
name|LOCAL_DIR
argument_list|)
expr_stmt|;
name|server
operator|.
name|setAttribute
argument_list|(
literal|"task.tracker"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|server
operator|.
name|setAttribute
argument_list|(
literal|"local.file.system"
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|server
operator|.
name|setAttribute
argument_list|(
literal|"conf"
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|server
operator|.
name|setAttribute
argument_list|(
literal|"log"
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|server
operator|.
name|setAttribute
argument_list|(
literal|"localDirAllocator"
argument_list|,
name|localDirAllocator
argument_list|)
expr_stmt|;
name|server
operator|.
name|setAttribute
argument_list|(
literal|"shuffleServerMetrics"
argument_list|,
name|shuffleServerMetrics
argument_list|)
expr_stmt|;
name|String
name|exceptionStackRegex
init|=
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|SHUFFLE_EXCEPTION_STACK_REGEX
argument_list|)
decl_stmt|;
name|String
name|exceptionMsgRegex
init|=
name|conf
operator|.
name|get
argument_list|(
name|JTConfig
operator|.
name|SHUFFLE_EXCEPTION_MSG_REGEX
argument_list|)
decl_stmt|;
name|server
operator|.
name|setAttribute
argument_list|(
literal|"exceptionStackRegex"
argument_list|,
name|exceptionStackRegex
argument_list|)
expr_stmt|;
name|server
operator|.
name|setAttribute
argument_list|(
literal|"exceptionMsgRegex"
argument_list|,
name|exceptionMsgRegex
argument_list|)
expr_stmt|;
name|server
operator|.
name|addInternalServlet
argument_list|(
literal|"mapOutput"
argument_list|,
literal|"/mapOutput"
argument_list|,
name|MapOutputServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|server
operator|.
name|addServlet
argument_list|(
literal|"taskLog"
argument_list|,
literal|"/tasklog"
argument_list|,
name|TaskLogServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|server
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|httpPort
operator|=
name|server
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|checkJettyPort
argument_list|(
name|httpPort
argument_list|)
expr_stmt|;
comment|// create task log cleanup thread
name|setTaskLogCleanupThread
argument_list|(
operator|new
name|UserLogCleaner
argument_list|(
name|fConf
argument_list|)
argument_list|)
expr_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|fConf
argument_list|)
expr_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|fConf
argument_list|,
name|TTConfig
operator|.
name|TT_KEYTAB_FILE
argument_list|,
name|TTConfig
operator|.
name|TT_USER_NAME
argument_list|)
expr_stmt|;
name|initialize
argument_list|()
expr_stmt|;
block|}
DECL|method|checkJettyPort (int port)
specifier|private
name|void
name|checkJettyPort
parameter_list|(
name|int
name|port
parameter_list|)
throws|throws
name|IOException
block|{
comment|//See HADOOP-4744
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
name|shuttingDown
operator|=
literal|true
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Jetty problem. Jetty didn't bind to a "
operator|+
literal|"valid port"
argument_list|)
throw|;
block|}
block|}
DECL|method|startCleanupThreads ()
specifier|private
name|void
name|startCleanupThreads
parameter_list|()
throws|throws
name|IOException
block|{
name|taskCleanupThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|taskCleanupThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|directoryCleanupThread
operator|=
operator|new
name|CleanupQueue
argument_list|()
expr_stmt|;
comment|// start tasklog cleanup thread
name|taskLogCleanupThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|taskLogCleanupThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// only used by tests
DECL|method|setCleanupThread (CleanupQueue c)
name|void
name|setCleanupThread
parameter_list|(
name|CleanupQueue
name|c
parameter_list|)
block|{
name|directoryCleanupThread
operator|=
name|c
expr_stmt|;
block|}
DECL|method|getCleanupThread ()
name|CleanupQueue
name|getCleanupThread
parameter_list|()
block|{
return|return
name|directoryCleanupThread
return|;
block|}
DECL|method|getTaskLogCleanupThread ()
name|UserLogCleaner
name|getTaskLogCleanupThread
parameter_list|()
block|{
return|return
name|this
operator|.
name|taskLogCleanupThread
return|;
block|}
DECL|method|setTaskLogCleanupThread (UserLogCleaner t)
name|void
name|setTaskLogCleanupThread
parameter_list|(
name|UserLogCleaner
name|t
parameter_list|)
block|{
name|this
operator|.
name|taskLogCleanupThread
operator|=
name|t
expr_stmt|;
block|}
DECL|method|setIndexCache (IndexCache cache)
name|void
name|setIndexCache
parameter_list|(
name|IndexCache
name|cache
parameter_list|)
block|{
name|this
operator|.
name|indexCache
operator|=
name|cache
expr_stmt|;
block|}
comment|/**    * The connection to the JobTracker, used by the TaskRunner     * for locating remote files.    */
DECL|method|getJobClient ()
specifier|public
name|InterTrackerProtocol
name|getJobClient
parameter_list|()
block|{
return|return
name|jobClient
return|;
block|}
comment|/** Return the port at which the tasktracker bound to */
DECL|method|getTaskTrackerReportAddress ()
specifier|public
specifier|synchronized
name|InetSocketAddress
name|getTaskTrackerReportAddress
parameter_list|()
block|{
return|return
name|taskReportAddress
return|;
block|}
comment|/** Queries the job tracker for a set of outputs ready to be copied    * @param fromEventId the first event ID we want to start from, this is    * modified by the call to this method    * @param jobClient the job tracker    * @return a set of locations to copy outputs from    * @throws IOException    */
DECL|method|queryJobTracker (IntWritable fromEventId, JobID jobId, InterTrackerProtocol jobClient)
specifier|private
name|List
argument_list|<
name|TaskCompletionEvent
argument_list|>
name|queryJobTracker
parameter_list|(
name|IntWritable
name|fromEventId
parameter_list|,
name|JobID
name|jobId
parameter_list|,
name|InterTrackerProtocol
name|jobClient
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskCompletionEvent
name|t
index|[]
init|=
name|jobClient
operator|.
name|getTaskCompletionEvents
argument_list|(
name|jobId
argument_list|,
name|fromEventId
operator|.
name|get
argument_list|()
argument_list|,
name|probe_sample_size
argument_list|)
decl_stmt|;
comment|//we are interested in map task completion events only. So store
comment|//only those
name|List
argument_list|<
name|TaskCompletionEvent
argument_list|>
name|recentMapEvents
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskCompletionEvent
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t
index|[
name|i
index|]
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|recentMapEvents
operator|.
name|add
argument_list|(
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fromEventId
operator|.
name|set
argument_list|(
name|fromEventId
operator|.
name|get
argument_list|()
operator|+
name|t
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|recentMapEvents
return|;
block|}
comment|/**    * Main service loop.  Will stay in this loop forever.    */
DECL|method|offerService ()
name|State
name|offerService
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|lastHeartbeat
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|running
operator|&&
operator|!
name|shuttingDown
condition|)
block|{
try|try
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|waitTime
init|=
name|heartbeatInterval
operator|-
operator|(
name|now
operator|-
name|lastHeartbeat
operator|)
decl_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
comment|// sleeps for the wait time or
comment|// until there are empty slots to schedule tasks
synchronized|synchronized
init|(
name|finishedCount
init|)
block|{
if|if
condition|(
name|finishedCount
operator|.
name|get
argument_list|()
operator|==
literal|0
condition|)
block|{
name|finishedCount
operator|.
name|wait
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
name|finishedCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If the TaskTracker is just starting up:
comment|// 1. Verify the buildVersion
comment|// 2. Get the system directory& filesystem
if|if
condition|(
name|justInited
condition|)
block|{
name|String
name|jobTrackerBV
init|=
name|jobClient
operator|.
name|getBuildVersion
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|VersionInfo
operator|.
name|getBuildVersion
argument_list|()
operator|.
name|equals
argument_list|(
name|jobTrackerBV
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Shutting down. Incompatible buildVersion."
operator|+
literal|"\nJobTracker's: "
operator|+
name|jobTrackerBV
operator|+
literal|"\nTaskTracker's: "
operator|+
name|VersionInfo
operator|.
name|getBuildVersion
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
try|try
block|{
name|jobClient
operator|.
name|reportTaskTrackerError
argument_list|(
name|taskTrackerName
argument_list|,
literal|null
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Problem reporting to jobtracker: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|State
operator|.
name|DENIED
return|;
block|}
name|String
name|dir
init|=
name|jobClient
operator|.
name|getSystemDir
argument_list|()
decl_stmt|;
if|if
condition|(
name|dir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to get system directory"
argument_list|)
throw|;
block|}
name|systemDirectory
operator|=
operator|new
name|Path
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|systemFS
operator|=
name|systemDirectory
operator|.
name|getFileSystem
argument_list|(
name|fConf
argument_list|)
expr_stmt|;
block|}
comment|// Send the heartbeat and process the jobtracker's directives
name|HeartbeatResponse
name|heartbeatResponse
init|=
name|transmitHeartBeat
argument_list|(
name|now
argument_list|)
decl_stmt|;
comment|// Note the time when the heartbeat returned, use this to decide when to send the
comment|// next heartbeat
name|lastHeartbeat
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|TaskTrackerAction
index|[]
name|actions
init|=
name|heartbeatResponse
operator|.
name|getActions
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got heartbeatResponse from JobTracker with responseId: "
operator|+
name|heartbeatResponse
operator|.
name|getResponseId
argument_list|()
operator|+
literal|" and "
operator|+
operator|(
operator|(
name|actions
operator|!=
literal|null
operator|)
condition|?
name|actions
operator|.
name|length
else|:
literal|0
operator|)
operator|+
literal|" actions"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reinitTaskTracker
argument_list|(
name|actions
argument_list|)
condition|)
block|{
return|return
name|State
operator|.
name|STALE
return|;
block|}
comment|// resetting heartbeat interval from the response.
name|heartbeatInterval
operator|=
name|heartbeatResponse
operator|.
name|getHeartbeatInterval
argument_list|()
expr_stmt|;
name|justStarted
operator|=
literal|false
expr_stmt|;
name|justInited
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|actions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskTrackerAction
name|action
range|:
name|actions
control|)
block|{
if|if
condition|(
name|action
operator|instanceof
name|LaunchTaskAction
condition|)
block|{
name|addToTaskQueue
argument_list|(
operator|(
name|LaunchTaskAction
operator|)
name|action
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|instanceof
name|CommitTaskAction
condition|)
block|{
name|CommitTaskAction
name|commitAction
init|=
operator|(
name|CommitTaskAction
operator|)
name|action
decl_stmt|;
if|if
condition|(
operator|!
name|commitResponses
operator|.
name|contains
argument_list|(
name|commitAction
operator|.
name|getTaskID
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received commit task action for "
operator|+
name|commitAction
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
name|commitResponses
operator|.
name|add
argument_list|(
name|commitAction
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tasksToCleanup
operator|.
name|put
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|markUnresponsiveTasks
argument_list|()
expr_stmt|;
name|killOverflowingTasks
argument_list|()
expr_stmt|;
comment|//we've cleaned up, resume normal operation
if|if
condition|(
operator|!
name|acceptNewTasks
operator|&&
name|isIdle
argument_list|()
condition|)
block|{
name|acceptNewTasks
operator|=
literal|true
expr_stmt|;
block|}
comment|//The check below may not be required every iteration but we are
comment|//erring on the side of caution here. We have seen many cases where
comment|//the call to jetty's getLocalPort() returns different values at
comment|//different times. Being a real paranoid here.
name|checkJettyPort
argument_list|(
name|server
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted. Closing down."
argument_list|)
expr_stmt|;
return|return
name|State
operator|.
name|INTERRUPTED
return|;
block|}
catch|catch
parameter_list|(
name|DiskErrorException
name|de
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Exiting task tracker for disk error:\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|de
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|jobClient
operator|.
name|reportTaskTrackerError
argument_list|(
name|taskTrackerName
argument_list|,
literal|"DiskErrorException"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|State
operator|.
name|STALE
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
name|String
name|reClass
init|=
name|re
operator|.
name|getClassName
argument_list|()
decl_stmt|;
if|if
condition|(
name|DisallowedTaskTrackerException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Tasktracker disallowed by JobTracker."
argument_list|)
expr_stmt|;
return|return
name|State
operator|.
name|DENIED
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|except
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Caught exception: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|except
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|State
operator|.
name|NORMAL
return|;
block|}
DECL|field|previousUpdate
specifier|private
name|long
name|previousUpdate
init|=
literal|0
decl_stmt|;
comment|/**    * Build and transmit the heart beat to the JobTracker    * @param now current time    * @return false if the tracker was unknown    * @throws IOException    */
DECL|method|transmitHeartBeat (long now)
name|HeartbeatResponse
name|transmitHeartBeat
parameter_list|(
name|long
name|now
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Send Counters in the status once every COUNTER_UPDATE_INTERVAL
name|boolean
name|sendAllCounters
decl_stmt|;
if|if
condition|(
name|now
operator|>
operator|(
name|previousUpdate
operator|+
name|COUNTER_UPDATE_INTERVAL
operator|)
condition|)
block|{
name|sendAllCounters
operator|=
literal|true
expr_stmt|;
name|previousUpdate
operator|=
name|now
expr_stmt|;
block|}
else|else
block|{
name|sendAllCounters
operator|=
literal|false
expr_stmt|;
block|}
comment|//
comment|// Check if the last heartbeat got through...
comment|// if so then build the heartbeat information for the JobTracker;
comment|// else resend the previous status information.
comment|//
if|if
condition|(
name|status
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|status
operator|=
operator|new
name|TaskTrackerStatus
argument_list|(
name|taskTrackerName
argument_list|,
name|localHostname
argument_list|,
name|httpPort
argument_list|,
name|cloneAndResetRunningTaskStatuses
argument_list|(
name|sendAllCounters
argument_list|)
argument_list|,
name|failures
argument_list|,
name|maxMapSlots
argument_list|,
name|maxReduceSlots
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Resending 'status' to '"
operator|+
name|jobTrackAddr
operator|.
name|getHostName
argument_list|()
operator|+
literal|"' with reponseId '"
operator|+
name|heartbeatResponseId
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Check if we should ask for a new Task
comment|//
name|boolean
name|askForNewTask
decl_stmt|;
name|long
name|localMinSpaceStart
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|askForNewTask
operator|=
operator|(
operator|(
name|status
operator|.
name|countOccupiedMapSlots
argument_list|()
operator|<
name|maxMapSlots
operator|||
name|status
operator|.
name|countOccupiedReduceSlots
argument_list|()
operator|<
name|maxReduceSlots
operator|)
operator|&&
name|acceptNewTasks
operator|)
expr_stmt|;
name|localMinSpaceStart
operator|=
name|minSpaceStart
expr_stmt|;
block|}
if|if
condition|(
name|askForNewTask
condition|)
block|{
name|checkLocalDirs
argument_list|(
name|fConf
operator|.
name|getLocalDirs
argument_list|()
argument_list|)
expr_stmt|;
name|askForNewTask
operator|=
name|enoughFreeSpace
argument_list|(
name|localMinSpaceStart
argument_list|)
expr_stmt|;
name|long
name|freeDiskSpace
init|=
name|getFreeSpace
argument_list|()
decl_stmt|;
name|long
name|totVmem
init|=
name|getTotalVirtualMemoryOnTT
argument_list|()
decl_stmt|;
name|long
name|totPmem
init|=
name|getTotalPhysicalMemoryOnTT
argument_list|()
decl_stmt|;
name|long
name|availableVmem
init|=
name|getAvailableVirtualMemoryOnTT
argument_list|()
decl_stmt|;
name|long
name|availablePmem
init|=
name|getAvailablePhysicalMemoryOnTT
argument_list|()
decl_stmt|;
name|long
name|cumuCpuTime
init|=
name|getCumulativeCpuTimeOnTT
argument_list|()
decl_stmt|;
name|long
name|cpuFreq
init|=
name|getCpuFrequencyOnTT
argument_list|()
decl_stmt|;
name|int
name|numCpu
init|=
name|getNumProcessorsOnTT
argument_list|()
decl_stmt|;
name|float
name|cpuUsage
init|=
name|getCpuUsageOnTT
argument_list|()
decl_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setAvailableSpace
argument_list|(
name|freeDiskSpace
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setTotalVirtualMemory
argument_list|(
name|totVmem
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setTotalPhysicalMemory
argument_list|(
name|totPmem
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setMapSlotMemorySizeOnTT
argument_list|(
name|mapSlotMemorySizeOnTT
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setReduceSlotMemorySizeOnTT
argument_list|(
name|reduceSlotSizeMemoryOnTT
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setAvailableVirtualMemory
argument_list|(
name|availableVmem
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setAvailablePhysicalMemory
argument_list|(
name|availablePmem
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setCumulativeCpuTime
argument_list|(
name|cumuCpuTime
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setCpuFrequency
argument_list|(
name|cpuFreq
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setNumProcessors
argument_list|(
name|numCpu
argument_list|)
expr_stmt|;
name|status
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|setCpuUsage
argument_list|(
name|cpuUsage
argument_list|)
expr_stmt|;
block|}
comment|//add node health information
name|TaskTrackerHealthStatus
name|healthStatus
init|=
name|status
operator|.
name|getHealthStatus
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|healthChecker
operator|!=
literal|null
condition|)
block|{
name|healthChecker
operator|.
name|setHealthStatus
argument_list|(
name|healthStatus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|healthStatus
operator|.
name|setNodeHealthy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|healthStatus
operator|.
name|setLastReported
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|healthStatus
operator|.
name|setHealthReport
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Xmit the heartbeat
comment|//
name|HeartbeatResponse
name|heartbeatResponse
init|=
name|jobClient
operator|.
name|heartbeat
argument_list|(
name|status
argument_list|,
name|justStarted
argument_list|,
name|justInited
argument_list|,
name|askForNewTask
argument_list|,
name|heartbeatResponseId
argument_list|)
decl_stmt|;
comment|//
comment|// The heartbeat got through successfully!
comment|//
name|heartbeatResponseId
operator|=
name|heartbeatResponse
operator|.
name|getResponseId
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|TaskStatus
name|taskStatus
range|:
name|status
operator|.
name|getTaskReports
argument_list|()
control|)
block|{
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|&&
operator|!
name|taskStatus
operator|.
name|inTaskCleanupPhase
argument_list|()
condition|)
block|{
if|if
condition|(
name|taskStatus
operator|.
name|getIsMap
argument_list|()
condition|)
block|{
name|mapTotal
operator|--
expr_stmt|;
block|}
else|else
block|{
name|reduceTotal
operator|--
expr_stmt|;
block|}
try|try
block|{
name|myInstrumentation
operator|.
name|completeTask
argument_list|(
name|taskStatus
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetricsException
name|me
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|me
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|runningTasks
operator|.
name|remove
argument_list|(
name|taskStatus
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Clear transient status information which should only
comment|// be sent once to the JobTracker
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|runningTasks
operator|.
name|values
argument_list|()
control|)
block|{
name|tip
operator|.
name|getStatus
argument_list|()
operator|.
name|clearStatus
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Force a rebuild of 'status' on the next iteration
name|status
operator|=
literal|null
expr_stmt|;
return|return
name|heartbeatResponse
return|;
block|}
comment|/**    * Return the total virtual memory available on this TaskTracker.    * @return total size of virtual memory.    */
DECL|method|getTotalVirtualMemoryOnTT ()
name|long
name|getTotalVirtualMemoryOnTT
parameter_list|()
block|{
return|return
name|totalVirtualMemoryOnTT
return|;
block|}
comment|/**    * Return the total physical memory available on this TaskTracker.    * @return total size of physical memory.    */
DECL|method|getTotalPhysicalMemoryOnTT ()
name|long
name|getTotalPhysicalMemoryOnTT
parameter_list|()
block|{
return|return
name|totalPhysicalMemoryOnTT
return|;
block|}
comment|/**    * Return the free virtual memory available on this TaskTracker.    * @return total size of free virtual memory.    */
DECL|method|getAvailableVirtualMemoryOnTT ()
name|long
name|getAvailableVirtualMemoryOnTT
parameter_list|()
block|{
name|long
name|availableVirtualMemoryOnTT
init|=
name|TaskTrackerStatus
operator|.
name|UNAVAILABLE
decl_stmt|;
if|if
condition|(
name|resourceCalculatorPlugin
operator|!=
literal|null
condition|)
block|{
name|availableVirtualMemoryOnTT
operator|=
name|resourceCalculatorPlugin
operator|.
name|getAvailableVirtualMemorySize
argument_list|()
expr_stmt|;
block|}
return|return
name|availableVirtualMemoryOnTT
return|;
block|}
comment|/**    * Return the free physical memory available on this TaskTracker.    * @return total size of free physical memory in bytes    */
DECL|method|getAvailablePhysicalMemoryOnTT ()
name|long
name|getAvailablePhysicalMemoryOnTT
parameter_list|()
block|{
name|long
name|availablePhysicalMemoryOnTT
init|=
name|TaskTrackerStatus
operator|.
name|UNAVAILABLE
decl_stmt|;
if|if
condition|(
name|resourceCalculatorPlugin
operator|!=
literal|null
condition|)
block|{
name|availablePhysicalMemoryOnTT
operator|=
name|resourceCalculatorPlugin
operator|.
name|getAvailablePhysicalMemorySize
argument_list|()
expr_stmt|;
block|}
return|return
name|availablePhysicalMemoryOnTT
return|;
block|}
comment|/**    * Return the cumulative CPU used time on this TaskTracker since system is on    * @return cumulative CPU used time in millisecond    */
DECL|method|getCumulativeCpuTimeOnTT ()
name|long
name|getCumulativeCpuTimeOnTT
parameter_list|()
block|{
name|long
name|cumulativeCpuTime
init|=
name|TaskTrackerStatus
operator|.
name|UNAVAILABLE
decl_stmt|;
if|if
condition|(
name|resourceCalculatorPlugin
operator|!=
literal|null
condition|)
block|{
name|cumulativeCpuTime
operator|=
name|resourceCalculatorPlugin
operator|.
name|getCumulativeCpuTime
argument_list|()
expr_stmt|;
block|}
return|return
name|cumulativeCpuTime
return|;
block|}
comment|/**    * Return the number of Processors on this TaskTracker    * @return number of processors    */
DECL|method|getNumProcessorsOnTT ()
name|int
name|getNumProcessorsOnTT
parameter_list|()
block|{
name|int
name|numProcessors
init|=
name|TaskTrackerStatus
operator|.
name|UNAVAILABLE
decl_stmt|;
if|if
condition|(
name|resourceCalculatorPlugin
operator|!=
literal|null
condition|)
block|{
name|numProcessors
operator|=
name|resourceCalculatorPlugin
operator|.
name|getNumProcessors
argument_list|()
expr_stmt|;
block|}
return|return
name|numProcessors
return|;
block|}
comment|/**    * Return the CPU frequency of this TaskTracker    * @return CPU frequency in kHz    */
DECL|method|getCpuFrequencyOnTT ()
name|long
name|getCpuFrequencyOnTT
parameter_list|()
block|{
name|long
name|cpuFrequency
init|=
name|TaskTrackerStatus
operator|.
name|UNAVAILABLE
decl_stmt|;
if|if
condition|(
name|resourceCalculatorPlugin
operator|!=
literal|null
condition|)
block|{
name|cpuFrequency
operator|=
name|resourceCalculatorPlugin
operator|.
name|getCpuFrequency
argument_list|()
expr_stmt|;
block|}
return|return
name|cpuFrequency
return|;
block|}
comment|/**    * Return the CPU usage in % of this TaskTracker    * @return CPU usage in %    */
DECL|method|getCpuUsageOnTT ()
name|float
name|getCpuUsageOnTT
parameter_list|()
block|{
name|float
name|cpuUsage
init|=
name|TaskTrackerStatus
operator|.
name|UNAVAILABLE
decl_stmt|;
if|if
condition|(
name|resourceCalculatorPlugin
operator|!=
literal|null
condition|)
block|{
name|cpuUsage
operator|=
name|resourceCalculatorPlugin
operator|.
name|getCpuUsage
argument_list|()
expr_stmt|;
block|}
return|return
name|cpuUsage
return|;
block|}
DECL|method|getTotalMemoryAllottedForTasksOnTT ()
name|long
name|getTotalMemoryAllottedForTasksOnTT
parameter_list|()
block|{
return|return
name|totalMemoryAllottedForTasks
return|;
block|}
comment|/**    * @return The amount of physical memory that will not be used for running    *         tasks in bytes. Returns JobConf.DISABLED_MEMORY_LIMIT if it is not    *         configured.    */
DECL|method|getReservedPhysicalMemoryOnTT ()
name|long
name|getReservedPhysicalMemoryOnTT
parameter_list|()
block|{
return|return
name|reservedPhysicalMemoryOnTT
return|;
block|}
comment|/**    * Check if the jobtracker directed a 'reset' of the tasktracker.    *     * @param actions the directives of the jobtracker for the tasktracker.    * @return<code>true</code> if tasktracker is to be reset,     *<code>false</code> otherwise.    */
DECL|method|reinitTaskTracker (TaskTrackerAction[] actions)
specifier|private
name|boolean
name|reinitTaskTracker
parameter_list|(
name|TaskTrackerAction
index|[]
name|actions
parameter_list|)
block|{
if|if
condition|(
name|actions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskTrackerAction
name|action
range|:
name|actions
control|)
block|{
if|if
condition|(
name|action
operator|.
name|getActionId
argument_list|()
operator|==
name|TaskTrackerAction
operator|.
name|ActionType
operator|.
name|REINIT_TRACKER
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received ReinitTrackerAction from JobTracker"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Kill any tasks that have not reported progress in the last X seconds.    */
DECL|method|markUnresponsiveTasks ()
specifier|private
specifier|synchronized
name|void
name|markUnresponsiveTasks
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|runningTasks
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|tip
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|||
name|tip
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|||
name|tip
operator|.
name|isCleaningup
argument_list|()
condition|)
block|{
comment|// Check the per-job timeout interval for tasks;
comment|// an interval of '0' implies it is never timed-out
name|long
name|jobTaskTimeout
init|=
name|tip
operator|.
name|getTaskTimeout
argument_list|()
decl_stmt|;
if|if
condition|(
name|jobTaskTimeout
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|// Check if the task has not reported progress for a
comment|// time-period greater than the configured time-out
name|long
name|timeSinceLastReport
init|=
name|now
operator|-
name|tip
operator|.
name|getLastProgressReport
argument_list|()
decl_stmt|;
if|if
condition|(
name|timeSinceLastReport
operator|>
name|jobTaskTimeout
operator|&&
operator|!
name|tip
operator|.
name|wasKilled
condition|)
block|{
name|String
name|msg
init|=
literal|"Task "
operator|+
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" failed to report status for "
operator|+
operator|(
name|timeSinceLastReport
operator|/
literal|1000
operator|)
operator|+
literal|" seconds. Killing!"
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|+
literal|": "
operator|+
name|msg
argument_list|)
expr_stmt|;
name|ReflectionUtils
operator|.
name|logThreadInfo
argument_list|(
name|LOG
argument_list|,
literal|"lost task"
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|tip
operator|.
name|reportDiagnosticInfo
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|myInstrumentation
operator|.
name|timedoutTask
argument_list|(
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
name|dumpTaskStack
argument_list|(
name|tip
argument_list|)
expr_stmt|;
name|purgeTask
argument_list|(
name|tip
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Builds list of PathDeletionContext objects for the given paths    */
DECL|method|buildPathDeletionContexts (FileSystem fs, Path[] paths)
specifier|private
specifier|static
name|PathDeletionContext
index|[]
name|buildPathDeletionContexts
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
index|[]
name|paths
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|PathDeletionContext
index|[]
name|contexts
init|=
operator|new
name|PathDeletionContext
index|[
name|paths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|paths
control|)
block|{
name|contexts
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|PathDeletionContext
argument_list|(
name|fs
argument_list|,
name|p
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|contexts
return|;
block|}
comment|/**    * Builds list of {@link TaskControllerJobPathDeletionContext} objects for a     * job each pointing to the job's jobLocalDir.    * @param fs    : FileSystem in which the dirs to be deleted    * @param paths : mapred-local-dirs    * @param id    : {@link JobID} of the job for which the local-dir needs to     *                be cleaned up.    * @param user  : Job owner's username    * @param taskController : the task-controller to be used for deletion of    *                         jobLocalDir    */
DECL|method|buildTaskControllerJobPathDeletionContexts ( FileSystem fs, Path[] paths, JobID id, String user, TaskController taskController)
specifier|static
name|PathDeletionContext
index|[]
name|buildTaskControllerJobPathDeletionContexts
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
index|[]
name|paths
parameter_list|,
name|JobID
name|id
parameter_list|,
name|String
name|user
parameter_list|,
name|TaskController
name|taskController
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|PathDeletionContext
index|[]
name|contexts
init|=
operator|new
name|TaskControllerPathDeletionContext
index|[
name|paths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|paths
control|)
block|{
name|contexts
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|TaskControllerJobPathDeletionContext
argument_list|(
name|fs
argument_list|,
name|p
argument_list|,
name|id
argument_list|,
name|user
argument_list|,
name|taskController
argument_list|)
expr_stmt|;
block|}
return|return
name|contexts
return|;
block|}
comment|/**    * Builds list of TaskControllerTaskPathDeletionContext objects for a task    * @param fs    : FileSystem in which the dirs to be deleted    * @param paths : mapred-local-dirs    * @param task  : the task whose taskDir or taskWorkDir is going to be deleted    * @param isWorkDir : the dir to be deleted is workDir or taskDir    * @param taskController : the task-controller to be used for deletion of    *                         taskDir or taskWorkDir    */
DECL|method|buildTaskControllerTaskPathDeletionContexts ( FileSystem fs, Path[] paths, Task task, boolean isWorkDir, TaskController taskController)
specifier|static
name|PathDeletionContext
index|[]
name|buildTaskControllerTaskPathDeletionContexts
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
index|[]
name|paths
parameter_list|,
name|Task
name|task
parameter_list|,
name|boolean
name|isWorkDir
parameter_list|,
name|TaskController
name|taskController
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|PathDeletionContext
index|[]
name|contexts
init|=
operator|new
name|TaskControllerPathDeletionContext
index|[
name|paths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|paths
control|)
block|{
name|contexts
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|TaskControllerTaskPathDeletionContext
argument_list|(
name|fs
argument_list|,
name|p
argument_list|,
name|task
argument_list|,
name|isWorkDir
argument_list|,
name|taskController
argument_list|)
expr_stmt|;
block|}
return|return
name|contexts
return|;
block|}
comment|/**    * Send a signal to a stuck task commanding it to dump stack traces    * to stderr before we kill it with purgeTask().    *    * @param tip {@link TaskInProgress} to dump stack traces.    */
DECL|method|dumpTaskStack (TaskInProgress tip)
specifier|private
name|void
name|dumpTaskStack
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
block|{
name|TaskRunner
name|runner
init|=
name|tip
operator|.
name|getTaskRunner
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|runner
condition|)
block|{
return|return;
comment|// tip is already abandoned.
block|}
name|JvmManager
name|jvmMgr
init|=
name|runner
operator|.
name|getJvmManager
argument_list|()
decl_stmt|;
name|jvmMgr
operator|.
name|dumpStack
argument_list|(
name|runner
argument_list|)
expr_stmt|;
block|}
comment|/**    * The task tracker is done with this job, so we need to clean up.    * @param action The action with the job    * @throws IOException    */
DECL|method|purgeJob (KillJobAction action)
specifier|synchronized
name|void
name|purgeJob
parameter_list|(
name|KillJobAction
name|action
parameter_list|)
throws|throws
name|IOException
block|{
name|JobID
name|jobId
init|=
name|action
operator|.
name|getJobID
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received 'KillJobAction' for job: "
operator|+
name|jobId
argument_list|)
expr_stmt|;
name|RunningJob
name|rjob
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|runningJobs
init|)
block|{
name|rjob
operator|=
name|runningJobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rjob
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown job "
operator|+
name|jobId
operator|+
literal|" being deleted."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
synchronized|synchronized
init|(
name|rjob
init|)
block|{
comment|// Add this tips of this job to queue of tasks to be purged
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|rjob
operator|.
name|tasks
control|)
block|{
name|tip
operator|.
name|jobHasFinished
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Task
name|t
init|=
name|tip
operator|.
name|getTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|indexCache
operator|.
name|removeMap
argument_list|(
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Delete the job directory for this
comment|// task if the job is done/failed
if|if
condition|(
operator|!
name|rjob
operator|.
name|keepJobFiles
condition|)
block|{
name|removeJobFiles
argument_list|(
name|rjob
operator|.
name|jobConf
operator|.
name|getUser
argument_list|()
argument_list|,
name|rjob
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// add job to taskLogCleanupThread
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|taskLogCleanupThread
operator|.
name|markJobLogsForDeletion
argument_list|(
name|now
argument_list|,
name|rjob
operator|.
name|jobConf
argument_list|,
name|rjob
operator|.
name|jobid
argument_list|)
expr_stmt|;
comment|// Remove this job
name|rjob
operator|.
name|tasks
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Close all FileSystems for this job
try|try
block|{
name|FileSystem
operator|.
name|closeAllForUGI
argument_list|(
name|rjob
operator|.
name|getUGI
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring exception "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
operator|+
literal|" while closing FileSystem for "
operator|+
name|rjob
operator|.
name|getUGI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
synchronized|synchronized
init|(
name|runningJobs
init|)
block|{
name|runningJobs
operator|.
name|remove
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
block|}
name|getJobTokenSecretManager
argument_list|()
operator|.
name|removeTokenForJob
argument_list|(
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * This job's files are no longer needed on this TT, remove them.    *     * @param rjob    * @throws IOException    */
DECL|method|removeJobFiles (String user, JobID jobId)
name|void
name|removeJobFiles
parameter_list|(
name|String
name|user
parameter_list|,
name|JobID
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
name|PathDeletionContext
index|[]
name|contexts
init|=
name|buildTaskControllerJobPathDeletionContexts
argument_list|(
name|localFs
argument_list|,
name|getLocalFiles
argument_list|(
name|fConf
argument_list|,
literal|""
argument_list|)
argument_list|,
name|jobId
argument_list|,
name|user
argument_list|,
name|taskController
argument_list|)
decl_stmt|;
name|directoryCleanupThread
operator|.
name|addToQueue
argument_list|(
name|contexts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove the tip and update all relevant state.    *     * @param tip {@link TaskInProgress} to be removed.    * @param wasFailure did the task fail or was it killed?    */
DECL|method|purgeTask (TaskInProgress tip, boolean wasFailure)
specifier|private
name|void
name|purgeTask
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|boolean
name|wasFailure
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"About to purge task: "
operator|+
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove the task from running jobs,
comment|// removing the job if it's the last task
name|removeTaskFromJob
argument_list|(
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|,
name|tip
argument_list|)
expr_stmt|;
name|tip
operator|.
name|jobHasFinished
argument_list|(
name|wasFailure
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|indexCache
operator|.
name|removeMap
argument_list|(
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Check if we're dangerously low on disk space    * If so, kill jobs to free up space and make sure    * we don't accept any new tasks    * Try killing the reduce jobs first, since I believe they    * use up most space    * Then pick the one with least progress    */
DECL|method|killOverflowingTasks ()
specifier|private
name|void
name|killOverflowingTasks
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|localMinSpaceKill
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|localMinSpaceKill
operator|=
name|minSpaceKill
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enoughFreeSpace
argument_list|(
name|localMinSpaceKill
argument_list|)
condition|)
block|{
name|acceptNewTasks
operator|=
literal|false
expr_stmt|;
comment|//we give up! do not accept new tasks until
comment|//all the ones running have finished and they're all cleared up
synchronized|synchronized
init|(
name|this
init|)
block|{
name|TaskInProgress
name|killMe
init|=
name|findTaskToKill
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|killMe
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"Tasktracker running out of space."
operator|+
literal|" Killing task."
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|killMe
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|+
literal|": "
operator|+
name|msg
argument_list|)
expr_stmt|;
name|killMe
operator|.
name|reportDiagnosticInfo
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|purgeTask
argument_list|(
name|killMe
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Pick a task to kill to free up memory/disk-space     * @param tasksToExclude tasks that are to be excluded while trying to find a    *          task to kill. If null, all runningTasks will be searched.    * @return the task to kill or null, if one wasn't found    */
DECL|method|findTaskToKill (List<TaskAttemptID> tasksToExclude)
specifier|synchronized
name|TaskInProgress
name|findTaskToKill
parameter_list|(
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|tasksToExclude
parameter_list|)
block|{
name|TaskInProgress
name|killMe
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
name|it
init|=
name|runningTasks
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TaskInProgress
name|tip
init|=
operator|(
name|TaskInProgress
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tasksToExclude
operator|!=
literal|null
operator|&&
name|tasksToExclude
operator|.
name|contains
argument_list|(
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
argument_list|)
condition|)
block|{
comment|// exclude this task
continue|continue;
block|}
if|if
condition|(
operator|(
name|tip
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|||
name|tip
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|)
operator|&&
operator|!
name|tip
operator|.
name|wasKilled
condition|)
block|{
if|if
condition|(
name|killMe
operator|==
literal|null
condition|)
block|{
name|killMe
operator|=
name|tip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
comment|//reduce task, give priority
if|if
condition|(
name|killMe
operator|.
name|getTask
argument_list|()
operator|.
name|isMapTask
argument_list|()
operator|||
operator|(
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getProgress
argument_list|()
operator|.
name|get
argument_list|()
operator|<
name|killMe
operator|.
name|getTask
argument_list|()
operator|.
name|getProgress
argument_list|()
operator|.
name|get
argument_list|()
operator|)
condition|)
block|{
name|killMe
operator|=
name|tip
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|killMe
operator|.
name|getTask
argument_list|()
operator|.
name|isMapTask
argument_list|()
operator|&&
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getProgress
argument_list|()
operator|.
name|get
argument_list|()
operator|<
name|killMe
operator|.
name|getTask
argument_list|()
operator|.
name|getProgress
argument_list|()
operator|.
name|get
argument_list|()
condition|)
block|{
comment|//map task, only add if the progress is lower
name|killMe
operator|=
name|tip
expr_stmt|;
block|}
block|}
block|}
return|return
name|killMe
return|;
block|}
comment|/**    * Check if any of the local directories has enough    * free space  (more than minSpace)    *     * If not, do not try to get a new task assigned     * @return    * @throws IOException     */
DECL|method|enoughFreeSpace (long minSpace)
specifier|private
name|boolean
name|enoughFreeSpace
parameter_list|(
name|long
name|minSpace
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|minSpace
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|minSpace
operator|<
name|getFreeSpace
argument_list|()
return|;
block|}
DECL|method|getFreeSpace ()
specifier|private
name|long
name|getFreeSpace
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|biggestSeenSoFar
init|=
literal|0
decl_stmt|;
name|String
index|[]
name|localDirs
init|=
name|fConf
operator|.
name|getLocalDirs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|localDirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DF
name|df
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|localDirsDf
operator|.
name|containsKey
argument_list|(
name|localDirs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|df
operator|=
name|localDirsDf
operator|.
name|get
argument_list|(
name|localDirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|df
operator|=
operator|new
name|DF
argument_list|(
operator|new
name|File
argument_list|(
name|localDirs
index|[
name|i
index|]
argument_list|)
argument_list|,
name|fConf
argument_list|)
expr_stmt|;
name|localDirsDf
operator|.
name|put
argument_list|(
name|localDirs
index|[
name|i
index|]
argument_list|,
name|df
argument_list|)
expr_stmt|;
block|}
name|long
name|availOnThisVol
init|=
name|df
operator|.
name|getAvailable
argument_list|()
decl_stmt|;
if|if
condition|(
name|availOnThisVol
operator|>
name|biggestSeenSoFar
condition|)
block|{
name|biggestSeenSoFar
operator|=
name|availOnThisVol
expr_stmt|;
block|}
block|}
comment|//Should ultimately hold back the space we expect running tasks to use but
comment|//that estimate isn't currently being passed down to the TaskTrackers
return|return
name|biggestSeenSoFar
return|;
block|}
DECL|field|mapLauncher
specifier|private
name|TaskLauncher
name|mapLauncher
decl_stmt|;
DECL|field|reduceLauncher
specifier|private
name|TaskLauncher
name|reduceLauncher
decl_stmt|;
DECL|method|getJvmManagerInstance ()
specifier|public
name|JvmManager
name|getJvmManagerInstance
parameter_list|()
block|{
return|return
name|jvmManager
return|;
block|}
comment|// called from unit test
DECL|method|setJvmManagerInstance (JvmManager jvmManager)
name|void
name|setJvmManagerInstance
parameter_list|(
name|JvmManager
name|jvmManager
parameter_list|)
block|{
name|this
operator|.
name|jvmManager
operator|=
name|jvmManager
expr_stmt|;
block|}
DECL|method|addToTaskQueue (LaunchTaskAction action)
specifier|private
name|void
name|addToTaskQueue
parameter_list|(
name|LaunchTaskAction
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|.
name|getTask
argument_list|()
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|mapLauncher
operator|.
name|addToTaskQueue
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reduceLauncher
operator|.
name|addToTaskQueue
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
block|}
comment|// This method is called from unit tests
DECL|method|getFreeSlots (boolean isMap)
name|int
name|getFreeSlots
parameter_list|(
name|boolean
name|isMap
parameter_list|)
block|{
if|if
condition|(
name|isMap
condition|)
block|{
return|return
name|mapLauncher
operator|.
name|numFreeSlots
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|reduceLauncher
operator|.
name|numFreeSlots
operator|.
name|get
argument_list|()
return|;
block|}
block|}
DECL|class|TaskLauncher
class|class
name|TaskLauncher
extends|extends
name|Thread
block|{
DECL|field|numFreeSlots
specifier|private
name|IntWritable
name|numFreeSlots
decl_stmt|;
DECL|field|maxSlots
specifier|private
specifier|final
name|int
name|maxSlots
decl_stmt|;
DECL|field|tasksToLaunch
specifier|private
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|tasksToLaunch
decl_stmt|;
DECL|method|TaskLauncher (TaskType taskType, int numSlots)
specifier|public
name|TaskLauncher
parameter_list|(
name|TaskType
name|taskType
parameter_list|,
name|int
name|numSlots
parameter_list|)
block|{
name|this
operator|.
name|maxSlots
operator|=
name|numSlots
expr_stmt|;
name|this
operator|.
name|numFreeSlots
operator|=
operator|new
name|IntWritable
argument_list|(
name|numSlots
argument_list|)
expr_stmt|;
name|this
operator|.
name|tasksToLaunch
operator|=
operator|new
name|LinkedList
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setName
argument_list|(
literal|"TaskLauncher for "
operator|+
name|taskType
operator|+
literal|" tasks"
argument_list|)
expr_stmt|;
block|}
DECL|method|addToTaskQueue (LaunchTaskAction action)
specifier|public
name|void
name|addToTaskQueue
parameter_list|(
name|LaunchTaskAction
name|action
parameter_list|)
block|{
synchronized|synchronized
init|(
name|tasksToLaunch
init|)
block|{
name|TaskInProgress
name|tip
init|=
name|registerTask
argument_list|(
name|action
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|tasksToLaunch
operator|.
name|add
argument_list|(
name|tip
argument_list|)
expr_stmt|;
name|tasksToLaunch
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|cleanTaskQueue ()
specifier|public
name|void
name|cleanTaskQueue
parameter_list|()
block|{
name|tasksToLaunch
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|addFreeSlots (int numSlots)
specifier|public
name|void
name|addFreeSlots
parameter_list|(
name|int
name|numSlots
parameter_list|)
block|{
synchronized|synchronized
init|(
name|numFreeSlots
init|)
block|{
name|numFreeSlots
operator|.
name|set
argument_list|(
name|numFreeSlots
operator|.
name|get
argument_list|()
operator|+
name|numSlots
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|numFreeSlots
operator|.
name|get
argument_list|()
operator|<=
name|maxSlots
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"addFreeSlot : current free slots : "
operator|+
name|numFreeSlots
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|numFreeSlots
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|notifySlots ()
name|void
name|notifySlots
parameter_list|()
block|{
synchronized|synchronized
init|(
name|numFreeSlots
init|)
block|{
name|numFreeSlots
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getNumWaitingTasksToLaunch ()
name|int
name|getNumWaitingTasksToLaunch
parameter_list|()
block|{
synchronized|synchronized
init|(
name|tasksToLaunch
init|)
block|{
return|return
name|tasksToLaunch
operator|.
name|size
argument_list|()
return|;
block|}
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
try|try
block|{
name|TaskInProgress
name|tip
decl_stmt|;
name|Task
name|task
decl_stmt|;
synchronized|synchronized
init|(
name|tasksToLaunch
init|)
block|{
while|while
condition|(
name|tasksToLaunch
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tasksToLaunch
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
comment|//get the TIP
name|tip
operator|=
name|tasksToLaunch
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|task
operator|=
name|tip
operator|.
name|getTask
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to launch : "
operator|+
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" which needs "
operator|+
name|task
operator|.
name|getNumSlotsRequired
argument_list|()
operator|+
literal|" slots"
argument_list|)
expr_stmt|;
block|}
comment|//wait for free slots to run
synchronized|synchronized
init|(
name|numFreeSlots
init|)
block|{
name|boolean
name|canLaunch
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|numFreeSlots
operator|.
name|get
argument_list|()
operator|<
name|task
operator|.
name|getNumSlotsRequired
argument_list|()
condition|)
block|{
comment|//Make sure that there is no kill task action for this task!
comment|//We are not locking tip here, because it would reverse the
comment|//locking order!
comment|//Also, Lock for the tip is not required here! because :
comment|// 1. runState of TaskStatus is volatile
comment|// 2. Any notification is not missed because notification is
comment|// synchronized on numFreeSlots. So, while we are doing the check,
comment|// if the tip is half way through the kill(), we don't miss
comment|// notification for the following wait().
if|if
condition|(
operator|!
name|tip
operator|.
name|canBeLaunched
argument_list|()
condition|)
block|{
comment|//got killed externally while still in the launcher queue
name|LOG
operator|.
name|info
argument_list|(
literal|"Not blocking slots for "
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" as it got killed externally. Task's state is "
operator|+
name|tip
operator|.
name|getRunState
argument_list|()
argument_list|)
expr_stmt|;
name|canLaunch
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"TaskLauncher : Waiting for "
operator|+
name|task
operator|.
name|getNumSlotsRequired
argument_list|()
operator|+
literal|" to launch "
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|", currently we have "
operator|+
name|numFreeSlots
operator|.
name|get
argument_list|()
operator|+
literal|" free slots"
argument_list|)
expr_stmt|;
name|numFreeSlots
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|canLaunch
condition|)
block|{
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"In TaskLauncher, current free slots : "
operator|+
name|numFreeSlots
operator|.
name|get
argument_list|()
operator|+
literal|" and trying to launch "
operator|+
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" which needs "
operator|+
name|task
operator|.
name|getNumSlotsRequired
argument_list|()
operator|+
literal|" slots"
argument_list|)
expr_stmt|;
name|numFreeSlots
operator|.
name|set
argument_list|(
name|numFreeSlots
operator|.
name|get
argument_list|()
operator|-
name|task
operator|.
name|getNumSlotsRequired
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|numFreeSlots
operator|.
name|get
argument_list|()
operator|>=
literal|0
operator|)
assert|;
block|}
synchronized|synchronized
init|(
name|tip
init|)
block|{
comment|//to make sure that there is no kill task action for this
if|if
condition|(
operator|!
name|tip
operator|.
name|canBeLaunched
argument_list|()
condition|)
block|{
comment|//got killed externally while still in the launcher queue
name|LOG
operator|.
name|info
argument_list|(
literal|"Not launching task "
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" as it got"
operator|+
literal|" killed externally. Task's state is "
operator|+
name|tip
operator|.
name|getRunState
argument_list|()
argument_list|)
expr_stmt|;
name|addFreeSlots
argument_list|(
name|task
operator|.
name|getNumSlotsRequired
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tip
operator|.
name|slotTaken
operator|=
literal|true
expr_stmt|;
block|}
comment|//got a free slot. launch the task
name|startNewTask
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return;
comment|// ALL DONE
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"TaskLauncher error "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|th
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|registerTask (LaunchTaskAction action, TaskLauncher launcher)
specifier|private
name|TaskInProgress
name|registerTask
parameter_list|(
name|LaunchTaskAction
name|action
parameter_list|,
name|TaskLauncher
name|launcher
parameter_list|)
block|{
name|Task
name|t
init|=
name|action
operator|.
name|getTask
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"LaunchTaskAction (registerTask): "
operator|+
name|t
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" task's state:"
operator|+
name|t
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|TaskInProgress
name|tip
init|=
operator|new
name|TaskInProgress
argument_list|(
name|t
argument_list|,
name|this
operator|.
name|fConf
argument_list|,
name|launcher
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|tasks
operator|.
name|put
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|tip
argument_list|)
expr_stmt|;
name|runningTasks
operator|.
name|put
argument_list|(
name|t
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|tip
argument_list|)
expr_stmt|;
name|boolean
name|isMap
init|=
name|t
operator|.
name|isMapTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMap
condition|)
block|{
name|mapTotal
operator|++
expr_stmt|;
block|}
else|else
block|{
name|reduceTotal
operator|++
expr_stmt|;
block|}
block|}
return|return
name|tip
return|;
block|}
comment|/**    * Start a new task.    * All exceptions are handled locally, so that we don't mess up the    * task tracker.    */
DECL|method|startNewTask (final TaskInProgress tip)
name|void
name|startNewTask
parameter_list|(
specifier|final
name|TaskInProgress
name|tip
parameter_list|)
block|{
name|Thread
name|launchThread
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|RunningJob
name|rjob
init|=
name|localizeJob
argument_list|(
name|tip
argument_list|)
decl_stmt|;
comment|// Localization is done. Neither rjob.jobConf nor rjob.ugi can be null
name|launchTaskForJob
argument_list|(
name|tip
argument_list|,
operator|new
name|JobConf
argument_list|(
name|rjob
operator|.
name|getJobConf
argument_list|()
argument_list|)
argument_list|,
name|rjob
operator|.
name|ugi
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
operator|(
literal|"Error initializing "
operator|+
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|+
literal|":\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
operator|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|tip
operator|.
name|reportDiagnosticInfo
argument_list|(
name|msg
argument_list|)
expr_stmt|;
try|try
block|{
name|tip
operator|.
name|kill
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tip
operator|.
name|cleanup
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie2
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Error cleaning up "
operator|+
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|+
literal|":\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|Error
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"TaskLauncher error "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
decl_stmt|;
name|launchThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|addToMemoryManager (TaskAttemptID attemptId, boolean isMap, JobConf conf)
name|void
name|addToMemoryManager
parameter_list|(
name|TaskAttemptID
name|attemptId
parameter_list|,
name|boolean
name|isMap
parameter_list|,
name|JobConf
name|conf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isTaskMemoryManagerEnabled
argument_list|()
condition|)
block|{
return|return;
comment|// Skip this if TaskMemoryManager is not enabled.
block|}
comment|// Obtain physical memory limits from the job configuration
name|long
name|physicalMemoryLimit
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|isMap
condition|?
name|MRJobConfig
operator|.
name|MAP_MEMORY_PHYSICAL_MB
else|:
name|MRJobConfig
operator|.
name|REDUCE_MEMORY_PHYSICAL_MB
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|physicalMemoryLimit
operator|>
literal|0
condition|)
block|{
name|physicalMemoryLimit
operator|*=
literal|1024L
operator|*
literal|1024L
expr_stmt|;
block|}
comment|// Obtain virtual memory limits from the job configuration
name|long
name|virtualMemoryLimit
init|=
name|isMap
condition|?
name|conf
operator|.
name|getMemoryForMapTask
argument_list|()
operator|*
literal|1024
operator|*
literal|1024
else|:
name|conf
operator|.
name|getMemoryForReduceTask
argument_list|()
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|taskMemoryManager
operator|.
name|addTask
argument_list|(
name|attemptId
argument_list|,
name|virtualMemoryLimit
argument_list|,
name|physicalMemoryLimit
argument_list|)
expr_stmt|;
block|}
DECL|method|removeFromMemoryManager (TaskAttemptID attemptId)
name|void
name|removeFromMemoryManager
parameter_list|(
name|TaskAttemptID
name|attemptId
parameter_list|)
block|{
comment|// Remove the entry from taskMemoryManagerThread's data structures.
if|if
condition|(
name|isTaskMemoryManagerEnabled
argument_list|()
condition|)
block|{
name|taskMemoryManager
operator|.
name|removeTask
argument_list|(
name|attemptId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Notify the tasktracker to send an out-of-band heartbeat.    */
DECL|method|notifyTTAboutTaskCompletion ()
specifier|private
name|void
name|notifyTTAboutTaskCompletion
parameter_list|()
block|{
if|if
condition|(
name|oobHeartbeatOnTaskCompletion
condition|)
block|{
synchronized|synchronized
init|(
name|finishedCount
init|)
block|{
name|int
name|value
init|=
name|finishedCount
operator|.
name|get
argument_list|()
decl_stmt|;
name|finishedCount
operator|.
name|set
argument_list|(
name|value
operator|+
literal|1
argument_list|)
expr_stmt|;
name|finishedCount
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The server retry loop.      * This while-loop attempts to connect to the JobTracker.  It only     * loops when the old TaskTracker has gone bad (its state is    * stale somehow) and we need to reinitialize everything.    */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|startCleanupThreads
argument_list|()
expr_stmt|;
name|boolean
name|denied
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|running
operator|&&
operator|!
name|shuttingDown
operator|&&
operator|!
name|denied
condition|)
block|{
name|boolean
name|staleState
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// This while-loop attempts reconnects if we get network errors
while|while
condition|(
name|running
operator|&&
operator|!
name|staleState
operator|&&
operator|!
name|shuttingDown
operator|&&
operator|!
name|denied
condition|)
block|{
try|try
block|{
name|State
name|osState
init|=
name|offerService
argument_list|()
decl_stmt|;
if|if
condition|(
name|osState
operator|==
name|State
operator|.
name|STALE
condition|)
block|{
name|staleState
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osState
operator|==
name|State
operator|.
name|DENIED
condition|)
block|{
name|denied
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
if|if
condition|(
operator|!
name|shuttingDown
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Lost connection to JobTracker ["
operator|+
name|jobTrackAddr
operator|+
literal|"].  Retrying..."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{                 }
block|}
block|}
block|}
block|}
finally|finally
block|{
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|shuttingDown
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reinitializing local state"
argument_list|)
expr_stmt|;
name|initialize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|denied
condition|)
block|{
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Got fatal exception while reinitializing TaskTracker: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|iex
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|i
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Got interrupted while reinitializing TaskTracker: "
operator|+
name|i
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|///////////////////////////////////////////////////////
comment|// TaskInProgress maintains all the info for a Task that
comment|// lives at this TaskTracker.  It maintains the Task object,
comment|// its TaskStatus, and the TaskRunner.
comment|///////////////////////////////////////////////////////
DECL|class|TaskInProgress
class|class
name|TaskInProgress
block|{
DECL|field|task
name|Task
name|task
decl_stmt|;
DECL|field|lastProgressReport
name|long
name|lastProgressReport
decl_stmt|;
DECL|field|diagnosticInfo
name|StringBuffer
name|diagnosticInfo
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
DECL|field|runner
specifier|private
name|TaskRunner
name|runner
decl_stmt|;
DECL|field|done
specifier|volatile
name|boolean
name|done
init|=
literal|false
decl_stmt|;
DECL|field|wasKilled
specifier|volatile
name|boolean
name|wasKilled
init|=
literal|false
decl_stmt|;
DECL|field|defaultJobConf
specifier|private
name|JobConf
name|defaultJobConf
decl_stmt|;
DECL|field|localJobConf
specifier|private
name|JobConf
name|localJobConf
decl_stmt|;
DECL|field|keepFailedTaskFiles
specifier|private
name|boolean
name|keepFailedTaskFiles
decl_stmt|;
DECL|field|alwaysKeepTaskFiles
specifier|private
name|boolean
name|alwaysKeepTaskFiles
decl_stmt|;
DECL|field|taskStatus
specifier|private
name|TaskStatus
name|taskStatus
decl_stmt|;
DECL|field|taskTimeout
specifier|private
name|long
name|taskTimeout
decl_stmt|;
DECL|field|debugCommand
specifier|private
name|String
name|debugCommand
decl_stmt|;
DECL|field|slotTaken
specifier|private
specifier|volatile
name|boolean
name|slotTaken
init|=
literal|false
decl_stmt|;
DECL|field|launcher
specifier|private
name|TaskLauncher
name|launcher
decl_stmt|;
comment|// The ugi of the user who is running the job. This contains all the tokens
comment|// too which will be populated during job-localization
DECL|field|ugi
specifier|private
name|UserGroupInformation
name|ugi
decl_stmt|;
DECL|method|getUGI ()
name|UserGroupInformation
name|getUGI
parameter_list|()
block|{
return|return
name|ugi
return|;
block|}
DECL|method|setUGI (UserGroupInformation userUGI)
name|void
name|setUGI
parameter_list|(
name|UserGroupInformation
name|userUGI
parameter_list|)
block|{
name|ugi
operator|=
name|userUGI
expr_stmt|;
block|}
comment|/**      */
DECL|method|TaskInProgress (Task task, JobConf conf)
specifier|public
name|TaskInProgress
parameter_list|(
name|Task
name|task
parameter_list|,
name|JobConf
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|task
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|TaskInProgress (Task task, JobConf conf, TaskLauncher launcher)
specifier|public
name|TaskInProgress
parameter_list|(
name|Task
name|task
parameter_list|,
name|JobConf
name|conf
parameter_list|,
name|TaskLauncher
name|launcher
parameter_list|)
block|{
name|this
operator|.
name|task
operator|=
name|task
expr_stmt|;
name|this
operator|.
name|launcher
operator|=
name|launcher
expr_stmt|;
name|this
operator|.
name|lastProgressReport
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|defaultJobConf
operator|=
name|conf
expr_stmt|;
name|localJobConf
operator|=
literal|null
expr_stmt|;
name|taskStatus
operator|=
name|TaskStatus
operator|.
name|createTaskStatus
argument_list|(
name|task
operator|.
name|isMapTask
argument_list|()
argument_list|,
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|,
literal|0.0f
argument_list|,
name|task
operator|.
name|getNumSlotsRequired
argument_list|()
argument_list|,
name|task
operator|.
name|getState
argument_list|()
argument_list|,
name|diagnosticInfo
operator|.
name|toString
argument_list|()
argument_list|,
literal|"initializing"
argument_list|,
name|getName
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
condition|?
name|TaskStatus
operator|.
name|Phase
operator|.
name|CLEANUP
else|:
name|task
operator|.
name|isMapTask
argument_list|()
condition|?
name|TaskStatus
operator|.
name|Phase
operator|.
name|MAP
else|:
name|TaskStatus
operator|.
name|Phase
operator|.
name|SHUFFLE
argument_list|,
name|task
operator|.
name|getCounters
argument_list|()
argument_list|)
expr_stmt|;
name|taskTimeout
operator|=
operator|(
literal|10
operator|*
literal|60
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
DECL|method|localizeTask (Task task)
name|void
name|localizeTask
parameter_list|(
name|Task
name|task
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|fConf
argument_list|)
decl_stmt|;
comment|// create taskDirs on all the disks.
name|getLocalizer
argument_list|()
operator|.
name|initializeAttemptDirs
argument_list|(
name|task
operator|.
name|getUser
argument_list|()
argument_list|,
name|task
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
expr_stmt|;
comment|// create the working-directory of the task
name|Path
name|cwd
init|=
name|lDirAlloc
operator|.
name|getLocalPathForWrite
argument_list|(
name|getTaskWorkDir
argument_list|(
name|task
operator|.
name|getUser
argument_list|()
argument_list|,
name|task
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
argument_list|,
name|defaultJobConf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|localFs
operator|.
name|mkdirs
argument_list|(
name|cwd
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|cwd
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|localJobConf
operator|.
name|set
argument_list|(
name|LOCAL_DIR
argument_list|,
name|fConf
operator|.
name|get
argument_list|(
name|LOCAL_DIR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fConf
operator|.
name|get
argument_list|(
name|TT_HOST_NAME
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|localJobConf
operator|.
name|set
argument_list|(
name|TT_HOST_NAME
argument_list|,
name|fConf
operator|.
name|get
argument_list|(
name|TT_HOST_NAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|keepFailedTaskFiles
operator|=
name|localJobConf
operator|.
name|getKeepFailedTaskFiles
argument_list|()
expr_stmt|;
comment|// Do the task-type specific localization
name|task
operator|.
name|localizeConfiguration
argument_list|(
name|localJobConf
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
index|[]
argument_list|>
name|staticResolutions
init|=
name|NetUtils
operator|.
name|getAllStaticResolutions
argument_list|()
decl_stmt|;
if|if
condition|(
name|staticResolutions
operator|!=
literal|null
operator|&&
name|staticResolutions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|StringBuffer
name|str
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|staticResolutions
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|hostToResolved
init|=
name|staticResolutions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|str
operator|.
name|append
argument_list|(
name|hostToResolved
index|[
literal|0
index|]
operator|+
literal|"="
operator|+
name|hostToResolved
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|staticResolutions
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|str
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
name|localJobConf
operator|.
name|set
argument_list|(
name|TT_STATIC_RESOLUTIONS
argument_list|,
name|str
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|task
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|debugCommand
operator|=
name|localJobConf
operator|.
name|getMapDebugScript
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|debugCommand
operator|=
name|localJobConf
operator|.
name|getReduceDebugScript
argument_list|()
expr_stmt|;
block|}
name|String
name|keepPattern
init|=
name|localJobConf
operator|.
name|getKeepTaskFilesPattern
argument_list|()
decl_stmt|;
if|if
condition|(
name|keepPattern
operator|!=
literal|null
condition|)
block|{
name|alwaysKeepTaskFiles
operator|=
name|Pattern
operator|.
name|matches
argument_list|(
name|keepPattern
argument_list|,
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alwaysKeepTaskFiles
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|debugCommand
operator|!=
literal|null
operator|||
name|localJobConf
operator|.
name|getProfileEnabled
argument_list|()
operator|||
name|alwaysKeepTaskFiles
operator|||
name|keepFailedTaskFiles
condition|)
block|{
comment|//disable jvm reuse
name|localJobConf
operator|.
name|setNumTasksToExecutePerJvm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|task
operator|.
name|setConf
argument_list|(
name|localJobConf
argument_list|)
expr_stmt|;
block|}
comment|/**      */
DECL|method|getTask ()
specifier|public
name|Task
name|getTask
parameter_list|()
block|{
return|return
name|task
return|;
block|}
DECL|method|getTaskRunner ()
name|TaskRunner
name|getTaskRunner
parameter_list|()
block|{
return|return
name|runner
return|;
block|}
DECL|method|setTaskRunner (TaskRunner rnr)
name|void
name|setTaskRunner
parameter_list|(
name|TaskRunner
name|rnr
parameter_list|)
block|{
name|this
operator|.
name|runner
operator|=
name|rnr
expr_stmt|;
block|}
DECL|method|setJobConf (JobConf lconf)
specifier|public
specifier|synchronized
name|void
name|setJobConf
parameter_list|(
name|JobConf
name|lconf
parameter_list|)
block|{
name|this
operator|.
name|localJobConf
operator|=
name|lconf
expr_stmt|;
name|keepFailedTaskFiles
operator|=
name|localJobConf
operator|.
name|getKeepFailedTaskFiles
argument_list|()
expr_stmt|;
name|taskTimeout
operator|=
name|localJobConf
operator|.
name|getLong
argument_list|(
name|MRJobConfig
operator|.
name|TASK_TIMEOUT
argument_list|,
literal|10
operator|*
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
DECL|method|getJobConf ()
specifier|public
specifier|synchronized
name|JobConf
name|getJobConf
parameter_list|()
block|{
return|return
name|localJobConf
return|;
block|}
comment|/**      */
DECL|method|getStatus ()
specifier|public
specifier|synchronized
name|TaskStatus
name|getStatus
parameter_list|()
block|{
name|taskStatus
operator|.
name|setDiagnosticInfo
argument_list|(
name|diagnosticInfo
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnosticInfo
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|diagnosticInfo
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
return|return
name|taskStatus
return|;
block|}
DECL|method|createRunner (TaskTracker tracker, TaskInProgress task)
specifier|private
name|TaskRunner
name|createRunner
parameter_list|(
name|TaskTracker
name|tracker
parameter_list|,
name|TaskInProgress
name|task
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|task
operator|.
name|getTask
argument_list|()
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
return|return
operator|new
name|MapTaskRunner
argument_list|(
name|task
argument_list|,
name|tracker
argument_list|,
name|task
operator|.
name|getJobConf
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|new
name|ReduceTaskRunner
argument_list|(
name|task
argument_list|,
name|tracker
argument_list|,
name|task
operator|.
name|getJobConf
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Kick off the task execution      */
DECL|method|launchTask ()
specifier|public
specifier|synchronized
name|void
name|launchTask
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
operator|||
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|||
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
condition|)
block|{
name|localizeTask
argument_list|(
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
condition|)
block|{
name|this
operator|.
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
block|}
name|setTaskRunner
argument_list|(
name|createRunner
argument_list|(
name|TaskTracker
operator|.
name|this
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|runner
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|taskStatus
operator|.
name|setStartTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Not launching task: "
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" since it's state is "
operator|+
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isCleaningup ()
name|boolean
name|isCleaningup
parameter_list|()
block|{
return|return
name|this
operator|.
name|taskStatus
operator|.
name|inTaskCleanupPhase
argument_list|()
return|;
block|}
comment|// checks if state has been changed for the task to be launched
DECL|method|canBeLaunched ()
name|boolean
name|canBeLaunched
parameter_list|()
block|{
return|return
operator|(
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
operator|||
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|||
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
operator|)
return|;
block|}
comment|/**      * The task is reporting its progress      */
DECL|method|reportProgress (TaskStatus taskStatus)
specifier|public
specifier|synchronized
name|void
name|reportProgress
parameter_list|(
name|TaskStatus
name|taskStatus
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" "
operator|+
name|taskStatus
operator|.
name|getProgress
argument_list|()
operator|+
literal|"% "
operator|+
name|taskStatus
operator|.
name|getStateString
argument_list|()
argument_list|)
expr_stmt|;
comment|// task will report its state as
comment|// COMMIT_PENDING when it is waiting for commit response and
comment|// when it is committing.
comment|// cleanup attempt will report its state as FAILED_UNCLEAN/KILLED_UNCLEAN
if|if
condition|(
name|this
operator|.
name|done
operator|||
operator|(
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|&&
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|&&
operator|!
name|isCleaningup
argument_list|()
operator|)
operator|||
operator|(
operator|(
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|||
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|||
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
operator|)
operator|&&
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|)
condition|)
block|{
comment|//make sure we ignore progress messages after a task has
comment|//invoked TaskUmbilicalProtocol.done() or if the task has been
comment|//KILLED/FAILED/FAILED_UNCLEAN/KILLED_UNCLEAN
comment|//Also ignore progress update if the state change is from
comment|//COMMIT_PENDING/FAILED_UNCLEAN/KILLED_UNCLEA to RUNNING
name|LOG
operator|.
name|info
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" Ignoring status-update since "
operator|+
operator|(
operator|(
name|this
operator|.
name|done
operator|)
condition|?
literal|"task is 'done'"
else|:
operator|(
literal|"runState: "
operator|+
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|taskStatus
operator|.
name|statusUpdate
argument_list|(
name|taskStatus
argument_list|)
expr_stmt|;
name|this
operator|.
name|lastProgressReport
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
comment|/**      */
DECL|method|getLastProgressReport ()
specifier|public
name|long
name|getLastProgressReport
parameter_list|()
block|{
return|return
name|lastProgressReport
return|;
block|}
comment|/**      */
DECL|method|getRunState ()
specifier|public
name|TaskStatus
operator|.
name|State
name|getRunState
parameter_list|()
block|{
return|return
name|taskStatus
operator|.
name|getRunState
argument_list|()
return|;
block|}
comment|/**      * The task's configured timeout.      *       * @return the task's configured timeout.      */
DECL|method|getTaskTimeout ()
specifier|public
name|long
name|getTaskTimeout
parameter_list|()
block|{
return|return
name|taskTimeout
return|;
block|}
comment|/**      * The task has reported some diagnostic info about its status      */
DECL|method|reportDiagnosticInfo (String info)
specifier|public
specifier|synchronized
name|void
name|reportDiagnosticInfo
parameter_list|(
name|String
name|info
parameter_list|)
block|{
name|this
operator|.
name|diagnosticInfo
operator|.
name|append
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
DECL|method|reportNextRecordRange (SortedRanges.Range range)
specifier|public
specifier|synchronized
name|void
name|reportNextRecordRange
parameter_list|(
name|SortedRanges
operator|.
name|Range
name|range
parameter_list|)
block|{
name|this
operator|.
name|taskStatus
operator|.
name|setNextRecordRange
argument_list|(
name|range
argument_list|)
expr_stmt|;
block|}
comment|/**      * The task is reporting that it's done running      */
DECL|method|reportDone ()
specifier|public
specifier|synchronized
name|void
name|reportDone
parameter_list|()
block|{
if|if
condition|(
name|isCleaningup
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
condition|)
block|{
name|this
operator|.
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
condition|)
block|{
name|this
operator|.
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|taskStatus
operator|.
name|setProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
name|this
operator|.
name|taskStatus
operator|.
name|setFinishTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|done
operator|=
literal|true
expr_stmt|;
name|jvmManager
operator|.
name|taskFinished
argument_list|(
name|runner
argument_list|)
expr_stmt|;
name|runner
operator|.
name|signalDone
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Task "
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" is done."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"reported output size for "
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
operator|+
literal|"  was "
operator|+
name|taskStatus
operator|.
name|getOutputSize
argument_list|()
argument_list|)
expr_stmt|;
name|myInstrumentation
operator|.
name|statusUpdate
argument_list|(
name|task
argument_list|,
name|taskStatus
argument_list|)
expr_stmt|;
block|}
DECL|method|wasKilled ()
specifier|public
name|boolean
name|wasKilled
parameter_list|()
block|{
return|return
name|wasKilled
return|;
block|}
comment|/**      * A task is reporting in as 'done'.      *       * We need to notify the tasktracker to send an out-of-band heartbeat.      * If isn't<code>commitPending</code>, we need to finalize the task      * and release the slot it's occupied.      *       * @param commitPending is the task-commit pending?      */
DECL|method|reportTaskFinished (boolean commitPending)
name|void
name|reportTaskFinished
parameter_list|(
name|boolean
name|commitPending
parameter_list|)
block|{
if|if
condition|(
operator|!
name|commitPending
condition|)
block|{
try|try
block|{
name|taskFinished
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|releaseSlot
argument_list|()
expr_stmt|;
block|}
block|}
name|notifyTTAboutTaskCompletion
argument_list|()
expr_stmt|;
block|}
comment|/* State changes:      * RUNNING/COMMIT_PENDING -> FAILED_UNCLEAN/FAILED/KILLED_UNCLEAN/KILLED      * FAILED_UNCLEAN -> FAILED      * KILLED_UNCLEAN -> KILLED       */
DECL|method|setTaskFailState (boolean wasFailure)
specifier|private
name|void
name|setTaskFailState
parameter_list|(
name|boolean
name|wasFailure
parameter_list|)
block|{
comment|// go FAILED_UNCLEAN -> FAILED and KILLED_UNCLEAN -> KILLED always
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
condition|)
block|{
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
condition|)
block|{
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|task
operator|.
name|isMapOrReduce
argument_list|()
operator|&&
name|taskStatus
operator|.
name|getPhase
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|Phase
operator|.
name|CLEANUP
condition|)
block|{
if|if
condition|(
name|wasFailure
condition|)
block|{
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|wasFailure
condition|)
block|{
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * The task has actually finished running.      */
DECL|method|taskFinished ()
specifier|public
name|void
name|taskFinished
parameter_list|()
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|//
comment|// Wait until task reports as done.  If it hasn't reported in,
comment|// wait for a second and try again.
comment|//
while|while
condition|(
operator|!
name|done
operator|&&
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|<
name|WAIT_FOR_DONE
operator|)
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{         }
block|}
comment|//
comment|// Change state to success or failure, depending on whether
comment|// task was 'done' before terminating
comment|//
name|boolean
name|needCleanup
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Remove the task from MemoryManager, if the task SUCCEEDED or FAILED.
comment|// KILLED tasks are removed in method kill(), because Kill
comment|// would result in launching a cleanup attempt before
comment|// TaskRunner returns; if remove happens here, it would remove
comment|// wrong task from memory manager.
if|if
condition|(
name|done
operator|||
operator|!
name|wasKilled
condition|)
block|{
name|removeFromMemoryManager
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
operator|!
name|wasKilled
condition|)
block|{
name|failures
operator|+=
literal|1
expr_stmt|;
name|setTaskFailState
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// call the script here for the failed tasks.
if|if
condition|(
name|debugCommand
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|runDebugScript
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Debug-script could not be run successfully : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|reportDiagnosticInfo
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|taskStatus
operator|.
name|setProgress
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|taskStatus
operator|.
name|setFinishTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|needCleanup
operator|=
operator|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|||
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|||
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
operator|||
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
operator|)
expr_stmt|;
block|}
comment|//
comment|// If the task has failed, or if the task was killAndCleanup()'ed,
comment|// we should clean up right away.  We only wait to cleanup
comment|// if the task succeeded, and its results might be useful
comment|// later on to downstream job processing.
comment|//
if|if
condition|(
name|needCleanup
condition|)
block|{
name|removeTaskFromJob
argument_list|(
name|task
operator|.
name|getJobID
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|cleanup
argument_list|(
name|needCleanup
argument_list|)
expr_stmt|;
block|}
comment|/**      * Run the debug-script now. Because debug-script can be user code, we use      * {@link TaskController} to execute the debug script.      *       * @throws IOException      */
DECL|method|runDebugScript ()
specifier|private
name|void
name|runDebugScript
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|taskStdout
init|=
literal|""
decl_stmt|;
name|String
name|taskStderr
init|=
literal|""
decl_stmt|;
name|String
name|taskSyslog
init|=
literal|""
decl_stmt|;
name|String
name|jobConf
init|=
name|task
operator|.
name|getJobFile
argument_list|()
decl_stmt|;
try|try
block|{
comment|// get task's stdout file
name|taskStdout
operator|=
name|FileUtil
operator|.
name|makeShellPath
argument_list|(
name|TaskLog
operator|.
name|getRealTaskLogFileLocation
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|,
name|TaskLog
operator|.
name|LogName
operator|.
name|STDOUT
argument_list|)
argument_list|)
expr_stmt|;
comment|// get task's stderr file
name|taskStderr
operator|=
name|FileUtil
operator|.
name|makeShellPath
argument_list|(
name|TaskLog
operator|.
name|getRealTaskLogFileLocation
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|,
name|TaskLog
operator|.
name|LogName
operator|.
name|STDERR
argument_list|)
argument_list|)
expr_stmt|;
comment|// get task's syslog file
name|taskSyslog
operator|=
name|FileUtil
operator|.
name|makeShellPath
argument_list|(
name|TaskLog
operator|.
name|getRealTaskLogFileLocation
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|,
name|TaskLog
operator|.
name|LogName
operator|.
name|SYSLOG
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception finding task's stdout/err/syslog files"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|File
name|workDir
init|=
operator|new
name|File
argument_list|(
name|lDirAlloc
operator|.
name|getLocalPathToRead
argument_list|(
name|TaskTracker
operator|.
name|getLocalTaskDir
argument_list|(
name|task
operator|.
name|getUser
argument_list|()
argument_list|,
name|task
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|MRConstants
operator|.
name|WORKDIR
argument_list|,
name|localJobConf
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|// Build the command
name|File
name|stdout
init|=
name|TaskLog
operator|.
name|getTaskLogFile
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|,
name|TaskLog
operator|.
name|LogName
operator|.
name|DEBUGOUT
argument_list|)
decl_stmt|;
comment|// add pipes program as argument if it exists.
name|String
name|program
init|=
literal|""
decl_stmt|;
name|String
name|executable
init|=
name|Submitter
operator|.
name|getExecutable
argument_list|(
name|localJobConf
argument_list|)
decl_stmt|;
if|if
condition|(
name|executable
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|program
operator|=
operator|new
name|URI
argument_list|(
name|executable
argument_list|)
operator|.
name|getFragment
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|ur
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem in the URI fragment for pipes executable"
argument_list|)
expr_stmt|;
block|}
block|}
name|String
index|[]
name|debug
init|=
name|debugCommand
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|vargs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|component
range|:
name|debug
control|)
block|{
name|vargs
operator|.
name|add
argument_list|(
name|component
argument_list|)
expr_stmt|;
block|}
name|vargs
operator|.
name|add
argument_list|(
name|taskStdout
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|taskStderr
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|taskSyslog
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|DebugScriptContext
name|context
init|=
operator|new
name|TaskController
operator|.
name|DebugScriptContext
argument_list|()
decl_stmt|;
name|context
operator|.
name|args
operator|=
name|vargs
expr_stmt|;
name|context
operator|.
name|stdout
operator|=
name|stdout
expr_stmt|;
name|context
operator|.
name|workDir
operator|=
name|workDir
expr_stmt|;
name|context
operator|.
name|task
operator|=
name|task
expr_stmt|;
name|getTaskController
argument_list|()
operator|.
name|runDebugScript
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|// add the lines of debug out to diagnostics
name|int
name|num
init|=
name|localJobConf
operator|.
name|getInt
argument_list|(
name|MRJobConfig
operator|.
name|TASK_DEBUGOUT_LINES
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|addDiagnostics
argument_list|(
name|FileUtil
operator|.
name|makeShellPath
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|num
argument_list|,
literal|"DEBUG OUT"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add last 'num' lines of the given file to the diagnostics.      * if num =-1, all the lines of file are added to the diagnostics.      * @param file The file from which to collect diagnostics.      * @param num The number of lines to be sent to diagnostics.      * @param tag The tag is printed before the diagnostics are printed.       */
DECL|method|addDiagnostics (String file, int num, String tag)
specifier|public
name|void
name|addDiagnostics
parameter_list|(
name|String
name|file
parameter_list|,
name|int
name|num
parameter_list|,
name|String
name|tag
parameter_list|)
block|{
name|RandomAccessFile
name|rafile
init|=
literal|null
decl_stmt|;
try|try
block|{
name|rafile
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|int
name|no_lines
init|=
literal|0
decl_stmt|;
name|String
name|line
init|=
literal|null
decl_stmt|;
name|StringBuffer
name|tail
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|tail
operator|.
name|append
argument_list|(
literal|"\n-------------------- "
operator|+
name|tag
operator|+
literal|"---------------------\n"
argument_list|)
expr_stmt|;
name|String
index|[]
name|lines
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|lines
operator|=
operator|new
name|String
index|[
name|num
index|]
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|line
operator|=
name|rafile
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|no_lines
operator|++
expr_stmt|;
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|no_lines
operator|<=
name|num
condition|)
block|{
name|lines
index|[
name|no_lines
operator|-
literal|1
index|]
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
comment|// shift them up
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|lines
index|[
name|i
index|]
operator|=
name|lines
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|lines
index|[
name|num
operator|-
literal|1
index|]
operator|=
name|line
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|num
operator|==
operator|-
literal|1
condition|)
block|{
name|tail
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|tail
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|n
init|=
name|no_lines
operator|>
name|num
condition|?
name|num
else|:
name|no_lines
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|tail
operator|.
name|append
argument_list|(
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tail
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|reportDiagnosticInfo
argument_list|(
name|tail
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"File "
operator|+
name|file
operator|+
literal|" not found"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error reading file "
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|rafile
operator|!=
literal|null
condition|)
block|{
name|rafile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error closing file "
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * We no longer need anything from this task, as the job has      * finished.  If the task is still running, kill it and clean up.      *       * @param wasFailure did the task fail, as opposed to was it killed by      *                   the framework      */
DECL|method|jobHasFinished (boolean wasFailure)
specifier|public
name|void
name|jobHasFinished
parameter_list|(
name|boolean
name|wasFailure
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Kill the task if it is still running
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|||
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
operator|||
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|||
name|isCleaningup
argument_list|()
condition|)
block|{
name|kill
argument_list|(
name|wasFailure
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Cleanup on the finished task
name|cleanup
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Something went wrong and the task must be killed.      *       * @param wasFailure was it a failure (versus a kill request)?      */
DECL|method|kill (boolean wasFailure)
specifier|public
specifier|synchronized
name|void
name|kill
parameter_list|(
name|boolean
name|wasFailure
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
operator|||
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|||
name|isCleaningup
argument_list|()
condition|)
block|{
name|wasKilled
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|wasFailure
condition|)
block|{
name|failures
operator|+=
literal|1
expr_stmt|;
block|}
comment|// runner could be null if task-cleanup attempt is not localized yet
if|if
condition|(
name|runner
operator|!=
literal|null
condition|)
block|{
name|runner
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
name|setTaskFailState
argument_list|(
name|wasFailure
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|UNASSIGNED
condition|)
block|{
if|if
condition|(
name|wasFailure
condition|)
block|{
name|failures
operator|+=
literal|1
expr_stmt|;
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
block|}
name|taskStatus
operator|.
name|setFinishTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|removeFromMemoryManager
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
name|releaseSlot
argument_list|()
expr_stmt|;
name|myInstrumentation
operator|.
name|statusUpdate
argument_list|(
name|task
argument_list|,
name|taskStatus
argument_list|)
expr_stmt|;
name|notifyTTAboutTaskCompletion
argument_list|()
expr_stmt|;
block|}
DECL|method|releaseSlot ()
specifier|private
specifier|synchronized
name|void
name|releaseSlot
parameter_list|()
block|{
if|if
condition|(
name|slotTaken
condition|)
block|{
if|if
condition|(
name|launcher
operator|!=
literal|null
condition|)
block|{
name|launcher
operator|.
name|addFreeSlots
argument_list|(
name|task
operator|.
name|getNumSlotsRequired
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|slotTaken
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// wake up the launcher. it may be waiting to block slots for this task.
if|if
condition|(
name|launcher
operator|!=
literal|null
condition|)
block|{
name|launcher
operator|.
name|notifySlots
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * The map output has been lost.      */
DECL|method|mapOutputLost (String failure )
specifier|private
specifier|synchronized
name|void
name|mapOutputLost
parameter_list|(
name|String
name|failure
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
operator|||
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
condition|)
block|{
comment|// change status to failure
name|LOG
operator|.
name|info
argument_list|(
literal|"Reporting output lost:"
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
name|taskStatus
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
name|taskStatus
operator|.
name|setProgress
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
name|reportDiagnosticInfo
argument_list|(
literal|"Map output lost, rescheduling: "
operator|+
name|failure
argument_list|)
expr_stmt|;
name|runningTasks
operator|.
name|put
argument_list|(
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|mapTotal
operator|++
expr_stmt|;
name|myInstrumentation
operator|.
name|statusUpdate
argument_list|(
name|task
argument_list|,
name|taskStatus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Output already reported lost:"
operator|+
name|task
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * We no longer need anything from this task.  Either the       * controlling job is all done and the files have been copied      * away, or the task failed and we don't need the remains.      * Any calls to cleanup should not lock the tip first.      * cleanup does the right thing- updates tasks in Tasktracker      * by locking tasktracker first and then locks the tip.      *       * if needCleanup is true, the whole task directory is cleaned up.      * otherwise the current working directory of the task       * i.e.&lt;taskid&gt;/work is cleaned up.      */
DECL|method|cleanup (boolean needCleanup)
name|void
name|cleanup
parameter_list|(
name|boolean
name|needCleanup
parameter_list|)
block|{
name|TaskAttemptID
name|taskId
init|=
name|task
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cleaning up "
operator|+
name|taskId
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|TaskTracker
operator|.
name|this
init|)
block|{
if|if
condition|(
name|needCleanup
condition|)
block|{
comment|// see if tasks data structure is holding this tip.
comment|// tasks could hold the tip for cleanup attempt, if cleanup attempt
comment|// got launched before this method.
if|if
condition|(
name|tasks
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
operator|==
name|this
condition|)
block|{
name|tasks
operator|.
name|remove
argument_list|(
name|taskId
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|alwaysKeepTaskFiles
operator|||
operator|(
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|&&
name|keepFailedTaskFiles
operator|)
condition|)
block|{
return|return;
block|}
block|}
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// localJobConf could be null if localization has not happened
comment|// then no cleanup will be required.
if|if
condition|(
name|localJobConf
operator|==
literal|null
condition|)
block|{
return|return;
block|}
try|try
block|{
name|removeTaskFiles
argument_list|(
name|needCleanup
argument_list|,
name|taskId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Error cleaning up task runner: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Some or all of the files from this task are no longer required. Remove      * them via CleanupQueue.      *       * @param needCleanup      * @param taskId      * @throws IOException       */
DECL|method|removeTaskFiles (boolean needCleanup, TaskAttemptID taskId)
name|void
name|removeTaskFiles
parameter_list|(
name|boolean
name|needCleanup
parameter_list|,
name|TaskAttemptID
name|taskId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|needCleanup
condition|)
block|{
if|if
condition|(
name|runner
operator|!=
literal|null
condition|)
block|{
comment|// cleans up the output directory of the task (where map outputs
comment|// and reduce inputs get stored)
name|runner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|localJobConf
operator|.
name|getNumTasksToExecutePerJvm
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// No jvm reuse, remove everything
name|PathDeletionContext
index|[]
name|contexts
init|=
name|buildTaskControllerTaskPathDeletionContexts
argument_list|(
name|localFs
argument_list|,
name|getLocalFiles
argument_list|(
name|fConf
argument_list|,
literal|""
argument_list|)
argument_list|,
name|task
argument_list|,
literal|false
comment|/* not workDir */
argument_list|,
name|taskController
argument_list|)
decl_stmt|;
name|directoryCleanupThread
operator|.
name|addToQueue
argument_list|(
name|contexts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Jvm reuse. We don't delete the workdir since some other task
comment|// (running in the same JVM) might be using the dir. The JVM
comment|// running the tasks would clean the workdir per a task in the
comment|// task process itself.
name|String
name|localTaskDir
init|=
name|getLocalTaskDir
argument_list|(
name|task
operator|.
name|getUser
argument_list|()
argument_list|,
name|task
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|taskId
operator|.
name|toString
argument_list|()
argument_list|,
name|task
operator|.
name|isTaskCleanupTask
argument_list|()
argument_list|)
decl_stmt|;
name|PathDeletionContext
index|[]
name|contexts
init|=
name|buildPathDeletionContexts
argument_list|(
name|localFs
argument_list|,
name|getLocalFiles
argument_list|(
name|defaultJobConf
argument_list|,
name|localTaskDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|TaskTracker
operator|.
name|JOBFILE
argument_list|)
argument_list|)
decl_stmt|;
name|directoryCleanupThread
operator|.
name|addToQueue
argument_list|(
name|contexts
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|localJobConf
operator|.
name|getNumTasksToExecutePerJvm
argument_list|()
operator|==
literal|1
condition|)
block|{
name|PathDeletionContext
index|[]
name|contexts
init|=
name|buildTaskControllerTaskPathDeletionContexts
argument_list|(
name|localFs
argument_list|,
name|getLocalFiles
argument_list|(
name|fConf
argument_list|,
literal|""
argument_list|)
argument_list|,
name|task
argument_list|,
literal|true
comment|/* workDir */
argument_list|,
name|taskController
argument_list|)
decl_stmt|;
name|directoryCleanupThread
operator|.
name|addToQueue
argument_list|(
name|contexts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|instanceof
name|TaskInProgress
operator|)
operator|&&
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|TaskInProgress
operator|)
name|obj
operator|)
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|task
operator|.
name|getTaskID
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
comment|/**    * Check that the current UGI is the JVM authorized to report    * for this particular job.    *    * @throws IOException for unauthorized access    */
DECL|method|ensureAuthorizedJVM (JobID jobId)
specifier|private
name|void
name|ensureAuthorizedJVM
parameter_list|(
name|JobID
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|currentJobId
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getUserName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|currentJobId
operator|.
name|equals
argument_list|(
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"JVM with "
operator|+
name|currentJobId
operator|+
literal|" is not authorized for "
operator|+
name|jobId
argument_list|)
throw|;
block|}
block|}
comment|// ///////////////////////////////////////////////////////////////
comment|// TaskUmbilicalProtocol
comment|/////////////////////////////////////////////////////////////////
comment|/**    * Called upon startup by the child process, to fetch Task data.    */
DECL|method|getTask (JvmContext context)
specifier|public
specifier|synchronized
name|JvmTask
name|getTask
parameter_list|(
name|JvmContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|context
operator|.
name|jvmId
operator|.
name|getJobId
argument_list|()
argument_list|)
expr_stmt|;
name|JVMId
name|jvmId
init|=
name|context
operator|.
name|jvmId
decl_stmt|;
comment|// save pid of task JVM sent by child
name|jvmManager
operator|.
name|setPidToJvm
argument_list|(
name|jvmId
argument_list|,
name|context
operator|.
name|pid
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"JVM with ID : "
operator|+
name|jvmId
operator|+
literal|" asked for a task"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|jvmManager
operator|.
name|isJvmKnown
argument_list|(
name|jvmId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Killing unknown JVM "
operator|+
name|jvmId
argument_list|)
expr_stmt|;
return|return
operator|new
name|JvmTask
argument_list|(
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
name|RunningJob
name|rjob
init|=
name|runningJobs
operator|.
name|get
argument_list|(
name|jvmId
operator|.
name|getJobId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rjob
operator|==
literal|null
condition|)
block|{
comment|//kill the JVM since the job is dead
name|LOG
operator|.
name|info
argument_list|(
literal|"Killing JVM "
operator|+
name|jvmId
operator|+
literal|" since job "
operator|+
name|jvmId
operator|.
name|getJobId
argument_list|()
operator|+
literal|" is dead"
argument_list|)
expr_stmt|;
name|jvmManager
operator|.
name|killJvm
argument_list|(
name|jvmId
argument_list|)
expr_stmt|;
return|return
operator|new
name|JvmTask
argument_list|(
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
name|TaskInProgress
name|tip
init|=
name|jvmManager
operator|.
name|getTaskForJvm
argument_list|(
name|jvmId
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|JvmTask
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|tasks
operator|.
name|get
argument_list|(
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|//is task still present
name|LOG
operator|.
name|info
argument_list|(
literal|"JVM with ID: "
operator|+
name|jvmId
operator|+
literal|" given task: "
operator|+
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|JvmTask
argument_list|(
name|tip
operator|.
name|getTask
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Killing JVM with ID: "
operator|+
name|jvmId
operator|+
literal|" since scheduled task: "
operator|+
name|tip
operator|.
name|getTask
argument_list|()
operator|.
name|getTaskID
argument_list|()
operator|+
literal|" is "
operator|+
name|tip
operator|.
name|taskStatus
operator|.
name|getRunState
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|JvmTask
argument_list|(
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
comment|/**    * Called periodically to report Task progress, from 0.0 to 1.0.    */
DECL|method|statusUpdate (TaskAttemptID taskid, TaskStatus taskStatus)
specifier|public
specifier|synchronized
name|boolean
name|statusUpdate
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|TaskStatus
name|taskStatus
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|taskid
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|TaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|tip
operator|.
name|reportProgress
argument_list|(
name|taskStatus
argument_list|)
expr_stmt|;
name|myInstrumentation
operator|.
name|statusUpdate
argument_list|(
name|tip
operator|.
name|getTask
argument_list|()
argument_list|,
name|taskStatus
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Progress from unknown child task: "
operator|+
name|taskid
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Called when the task dies before completion, and we want to report back    * diagnostic info    */
DECL|method|reportDiagnosticInfo (TaskAttemptID taskid, String info)
specifier|public
specifier|synchronized
name|void
name|reportDiagnosticInfo
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|String
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|taskid
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|internalReportDiagnosticInfo
argument_list|(
name|taskid
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
comment|/**    * Same as reportDiagnosticInfo but does not authorize caller. This is used    * internally within MapReduce, whereas reportDiagonsticInfo may be called    * via RPC.    */
DECL|method|internalReportDiagnosticInfo (TaskAttemptID taskid, String info)
specifier|synchronized
name|void
name|internalReportDiagnosticInfo
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|String
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|tip
operator|.
name|reportDiagnosticInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error from unknown child task: "
operator|+
name|taskid
operator|+
literal|". Ignored."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|reportNextRecordRange (TaskAttemptID taskid, SortedRanges.Range range)
specifier|public
specifier|synchronized
name|void
name|reportNextRecordRange
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|SortedRanges
operator|.
name|Range
name|range
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|taskid
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|TaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|tip
operator|.
name|reportNextRecordRange
argument_list|(
name|range
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"reportNextRecordRange from unknown child task: "
operator|+
name|taskid
operator|+
literal|". "
operator|+
literal|"Ignored."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Child checking to see if we're alive.  Normally does nothing.*/
DECL|method|ping (TaskAttemptID taskid)
specifier|public
specifier|synchronized
name|boolean
name|ping
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|taskid
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|tasks
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Task is reporting that it is in commit_pending    * and it is waiting for the commit Response    */
DECL|method|commitPending (TaskAttemptID taskid, TaskStatus taskStatus)
specifier|public
specifier|synchronized
name|void
name|commitPending
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|TaskStatus
name|taskStatus
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|taskid
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Task "
operator|+
name|taskid
operator|+
literal|" is in commit-pending,"
operator|+
literal|""
operator|+
literal|" task state:"
operator|+
name|taskStatus
operator|.
name|getRunState
argument_list|()
argument_list|)
expr_stmt|;
name|statusUpdate
argument_list|(
name|taskid
argument_list|,
name|taskStatus
argument_list|)
expr_stmt|;
name|reportTaskFinished
argument_list|(
name|taskid
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Child checking whether it can commit     */
DECL|method|canCommit (TaskAttemptID taskid)
specifier|public
specifier|synchronized
name|boolean
name|canCommit
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
block|{
return|return
name|commitResponses
operator|.
name|contains
argument_list|(
name|taskid
argument_list|)
return|;
comment|//don't remove it now
block|}
comment|/**    * The task is done.    */
DECL|method|done (TaskAttemptID taskid)
specifier|public
specifier|synchronized
name|void
name|done
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|taskid
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|TaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
name|commitResponses
operator|.
name|remove
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|tip
operator|.
name|reportDone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown child task done: "
operator|+
name|taskid
operator|+
literal|". Ignored."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * A reduce-task failed to shuffle the map-outputs. Kill the task.    */
DECL|method|shuffleError (TaskAttemptID taskId, String message)
specifier|public
specifier|synchronized
name|void
name|shuffleError
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|taskId
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Task: "
operator|+
name|taskId
operator|+
literal|" - Killed due to Shuffle Failure: "
operator|+
name|message
argument_list|)
expr_stmt|;
name|TaskInProgress
name|tip
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
name|tip
operator|.
name|reportDiagnosticInfo
argument_list|(
literal|"Shuffle Error: "
operator|+
name|message
argument_list|)
expr_stmt|;
name|purgeTask
argument_list|(
name|tip
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**     * A child task had a local filesystem error. Kill the task.    */
DECL|method|fsError (TaskAttemptID taskId, String message)
specifier|public
specifier|synchronized
name|void
name|fsError
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|taskId
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|internalFsError
argument_list|(
name|taskId
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * Version of fsError() that does not do authorization checks, called by    * the TaskRunner.    */
DECL|method|internalFsError (TaskAttemptID taskId, String message)
specifier|synchronized
name|void
name|internalFsError
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Task: "
operator|+
name|taskId
operator|+
literal|" - Killed due to FSError: "
operator|+
name|message
argument_list|)
expr_stmt|;
name|TaskInProgress
name|tip
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
name|tip
operator|.
name|reportDiagnosticInfo
argument_list|(
literal|"FSError: "
operator|+
name|message
argument_list|)
expr_stmt|;
name|purgeTask
argument_list|(
name|tip
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**     * A child task had a fatal error. Kill the task.    */
DECL|method|fatalError (TaskAttemptID taskId, String msg)
specifier|public
specifier|synchronized
name|void
name|fatalError
parameter_list|(
name|TaskAttemptID
name|taskId
parameter_list|,
name|String
name|msg
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureAuthorizedJVM
argument_list|(
name|taskId
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Task: "
operator|+
name|taskId
operator|+
literal|" - exited : "
operator|+
name|msg
argument_list|)
expr_stmt|;
name|TaskInProgress
name|tip
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
name|tip
operator|.
name|reportDiagnosticInfo
argument_list|(
literal|"Error: "
operator|+
name|msg
argument_list|)
expr_stmt|;
name|purgeTask
argument_list|(
name|tip
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|getMapCompletionEvents ( JobID jobId, int fromEventId, int maxLocs, TaskAttemptID id)
specifier|public
specifier|synchronized
name|MapTaskCompletionEventsUpdate
name|getMapCompletionEvents
parameter_list|(
name|JobID
name|jobId
parameter_list|,
name|int
name|fromEventId
parameter_list|,
name|int
name|maxLocs
parameter_list|,
name|TaskAttemptID
name|id
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskCompletionEvent
index|[]
name|mapEvents
init|=
name|TaskCompletionEvent
operator|.
name|EMPTY_ARRAY
decl_stmt|;
synchronized|synchronized
init|(
name|shouldReset
init|)
block|{
if|if
condition|(
name|shouldReset
operator|.
name|remove
argument_list|(
name|id
argument_list|)
condition|)
block|{
return|return
operator|new
name|MapTaskCompletionEventsUpdate
argument_list|(
name|mapEvents
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
name|RunningJob
name|rjob
decl_stmt|;
synchronized|synchronized
init|(
name|runningJobs
init|)
block|{
name|rjob
operator|=
name|runningJobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
if|if
condition|(
name|rjob
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|rjob
init|)
block|{
name|FetchStatus
name|f
init|=
name|rjob
operator|.
name|getFetchStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|mapEvents
operator|=
name|f
operator|.
name|getMapEvents
argument_list|(
name|fromEventId
argument_list|,
name|maxLocs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|new
name|MapTaskCompletionEventsUpdate
argument_list|(
name|mapEvents
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/////////////////////////////////////////////////////
comment|//  Called by TaskTracker thread after task process ends
comment|/////////////////////////////////////////////////////
comment|/**    * The task is no longer running.  It may not have completed successfully    */
DECL|method|reportTaskFinished (TaskAttemptID taskid, boolean commitPending)
name|void
name|reportTaskFinished
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|boolean
name|commitPending
parameter_list|)
block|{
name|TaskInProgress
name|tip
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|tip
operator|=
name|tasks
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|tip
operator|.
name|reportTaskFinished
argument_list|(
name|commitPending
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown child task finished: "
operator|+
name|taskid
operator|+
literal|". Ignored."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A completed map task's output has been lost.    */
DECL|method|mapOutputLost (TaskAttemptID taskid, String errorMsg)
specifier|public
specifier|synchronized
name|void
name|mapOutputLost
parameter_list|(
name|TaskAttemptID
name|taskid
parameter_list|,
name|String
name|errorMsg
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskInProgress
name|tip
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|tip
operator|.
name|mapOutputLost
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown child with bad map output: "
operator|+
name|taskid
operator|+
literal|". Ignored."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    *  The datastructure for initializing a job    */
DECL|class|RunningJob
specifier|static
class|class
name|RunningJob
block|{
DECL|field|jobid
specifier|private
name|JobID
name|jobid
decl_stmt|;
DECL|field|jobConf
specifier|private
name|JobConf
name|jobConf
decl_stmt|;
comment|// keep this for later use
DECL|field|tasks
specifier|volatile
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|tasks
decl_stmt|;
DECL|field|localized
name|boolean
name|localized
decl_stmt|;
DECL|field|keepJobFiles
name|boolean
name|keepJobFiles
decl_stmt|;
DECL|field|ugi
name|UserGroupInformation
name|ugi
decl_stmt|;
DECL|field|f
name|FetchStatus
name|f
decl_stmt|;
DECL|method|RunningJob (JobID jobid)
name|RunningJob
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
name|this
operator|.
name|jobid
operator|=
name|jobid
expr_stmt|;
name|localized
operator|=
literal|false
expr_stmt|;
name|tasks
operator|=
operator|new
name|HashSet
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|keepJobFiles
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|getJobID ()
name|JobID
name|getJobID
parameter_list|()
block|{
return|return
name|jobid
return|;
block|}
DECL|method|getUGI ()
name|UserGroupInformation
name|getUGI
parameter_list|()
block|{
return|return
name|ugi
return|;
block|}
DECL|method|setFetchStatus (FetchStatus f)
name|void
name|setFetchStatus
parameter_list|(
name|FetchStatus
name|f
parameter_list|)
block|{
name|this
operator|.
name|f
operator|=
name|f
expr_stmt|;
block|}
DECL|method|getFetchStatus ()
name|FetchStatus
name|getFetchStatus
parameter_list|()
block|{
return|return
name|f
return|;
block|}
DECL|method|getJobConf ()
name|JobConf
name|getJobConf
parameter_list|()
block|{
return|return
name|jobConf
return|;
block|}
block|}
comment|/**    * Get the name for this task tracker.    * @return the string like "tracker_mymachine:50010"    */
DECL|method|getName ()
name|String
name|getName
parameter_list|()
block|{
return|return
name|taskTrackerName
return|;
block|}
DECL|method|cloneAndResetRunningTaskStatuses ( boolean sendCounters)
specifier|private
specifier|synchronized
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|cloneAndResetRunningTaskStatuses
parameter_list|(
name|boolean
name|sendCounters
parameter_list|)
block|{
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskStatus
argument_list|>
argument_list|(
name|runningTasks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|runningTasks
operator|.
name|values
argument_list|()
control|)
block|{
name|TaskStatus
name|status
init|=
name|tip
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|status
operator|.
name|setIncludeAllCounters
argument_list|(
name|sendCounters
argument_list|)
expr_stmt|;
comment|// send counters for finished or failed tasks and commit pending tasks
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|!=
name|TaskStatus
operator|.
name|State
operator|.
name|RUNNING
condition|)
block|{
name|status
operator|.
name|setIncludeAllCounters
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
operator|(
name|TaskStatus
operator|)
name|status
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|clearStatus
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Get the list of tasks that will be reported back to the     * job tracker in the next heartbeat cycle.    * @return a copy of the list of TaskStatus objects    */
DECL|method|getRunningTaskStatuses ()
specifier|synchronized
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|getRunningTaskStatuses
parameter_list|()
block|{
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskStatus
argument_list|>
argument_list|(
name|runningTasks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|runningTasks
operator|.
name|values
argument_list|()
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|tip
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Get the list of stored tasks on this task tracker.    * @return    */
DECL|method|getNonRunningTasks ()
specifier|synchronized
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|getNonRunningTasks
parameter_list|()
block|{
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskStatus
argument_list|>
argument_list|(
name|tasks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|TaskAttemptID
argument_list|,
name|TaskInProgress
argument_list|>
name|task
range|:
name|tasks
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|runningTasks
operator|.
name|containsKey
argument_list|(
name|task
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|task
operator|.
name|getValue
argument_list|()
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Get the list of tasks from running jobs on this task tracker.    * @return a copy of the list of TaskStatus objects    */
DECL|method|getTasksFromRunningJobs ()
specifier|synchronized
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|getTasksFromRunningJobs
parameter_list|()
block|{
name|List
argument_list|<
name|TaskStatus
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskStatus
argument_list|>
argument_list|(
name|tasks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|JobID
argument_list|,
name|RunningJob
argument_list|>
name|item
range|:
name|runningJobs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RunningJob
name|rjob
init|=
name|item
operator|.
name|getValue
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|rjob
init|)
block|{
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|rjob
operator|.
name|tasks
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|tip
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Get the default job conf for this tracker.    */
DECL|method|getJobConf ()
name|JobConf
name|getJobConf
parameter_list|()
block|{
return|return
name|fConf
return|;
block|}
comment|/**    * Check if the given local directories    * (and parent directories, if necessary) can be created.    * @param localDirs where the new TaskTracker should keep its local files.    * @throws DiskErrorException if all local directories are not writable    */
DECL|method|checkLocalDirs (String[] localDirs)
specifier|private
specifier|static
name|void
name|checkLocalDirs
parameter_list|(
name|String
index|[]
name|localDirs
parameter_list|)
throws|throws
name|DiskErrorException
block|{
name|boolean
name|writable
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|localDirs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|localDirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|DiskChecker
operator|.
name|checkDir
argument_list|(
operator|new
name|File
argument_list|(
name|localDirs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|writable
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DiskErrorException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Task Tracker local "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|writable
condition|)
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"all local directories are not writable"
argument_list|)
throw|;
block|}
comment|/**    * Is this task tracker idle?    * @return has this task tracker finished and cleaned up all of its tasks?    */
DECL|method|isIdle ()
specifier|public
specifier|synchronized
name|boolean
name|isIdle
parameter_list|()
block|{
return|return
name|tasks
operator|.
name|isEmpty
argument_list|()
operator|&&
name|tasksToCleanup
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Start the TaskTracker, point toward the indicated JobTracker    */
DECL|method|main (String argv[])
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
name|argv
index|[]
parameter_list|)
throws|throws
name|Exception
block|{
name|StringUtils
operator|.
name|startupShutdownMessage
argument_list|(
name|TaskTracker
operator|.
name|class
argument_list|,
name|argv
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"usage: TaskTracker"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|JobConf
name|conf
init|=
operator|new
name|JobConf
argument_list|()
decl_stmt|;
comment|// enable the server to track time spent waiting on locks
name|ReflectionUtils
operator|.
name|setContentionTracing
argument_list|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|TT_CONTENTION_TRACKING
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|TaskTracker
argument_list|(
name|conf
argument_list|)
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can not start task tracker because "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This class is used in TaskTracker's Jetty to serve the map outputs    * to other nodes.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|MapOutputServlet
specifier|public
specifier|static
class|class
name|MapOutputServlet
extends|extends
name|HttpServlet
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|field|MAX_BYTES_TO_READ
specifier|private
specifier|static
specifier|final
name|int
name|MAX_BYTES_TO_READ
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
annotation|@
name|Override
DECL|method|doGet (HttpServletRequest request, HttpServletResponse response )
specifier|public
name|void
name|doGet
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|ServletException
throws|,
name|IOException
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|String
name|mapIds
init|=
name|request
operator|.
name|getParameter
argument_list|(
literal|"map"
argument_list|)
decl_stmt|;
name|String
name|reduceId
init|=
name|request
operator|.
name|getParameter
argument_list|(
literal|"reduce"
argument_list|)
decl_stmt|;
name|String
name|jobId
init|=
name|request
operator|.
name|getParameter
argument_list|(
literal|"job"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Shuffle started for maps (mapIds="
operator|+
name|mapIds
operator|+
literal|") to reduce "
operator|+
name|reduceId
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobId
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"job parameter is required"
argument_list|)
throw|;
block|}
if|if
condition|(
name|mapIds
operator|==
literal|null
operator|||
name|reduceId
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"map and reduce parameters are required"
argument_list|)
throw|;
block|}
name|ServletContext
name|context
init|=
name|getServletContext
argument_list|()
decl_stmt|;
name|int
name|reduce
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|reduceId
argument_list|)
decl_stmt|;
name|DataOutputStream
name|outStream
init|=
literal|null
decl_stmt|;
name|ShuffleServerMetrics
name|shuffleMetrics
init|=
operator|(
name|ShuffleServerMetrics
operator|)
name|context
operator|.
name|getAttribute
argument_list|(
literal|"shuffleServerMetrics"
argument_list|)
decl_stmt|;
name|TaskTracker
name|tracker
init|=
operator|(
name|TaskTracker
operator|)
name|context
operator|.
name|getAttribute
argument_list|(
literal|"task.tracker"
argument_list|)
decl_stmt|;
name|String
name|exceptionStackRegex
init|=
operator|(
name|String
operator|)
name|context
operator|.
name|getAttribute
argument_list|(
literal|"exceptionStackRegex"
argument_list|)
decl_stmt|;
name|String
name|exceptionMsgRegex
init|=
operator|(
name|String
operator|)
name|context
operator|.
name|getAttribute
argument_list|(
literal|"exceptionMsgRegex"
argument_list|)
decl_stmt|;
name|verifyRequest
argument_list|(
name|request
argument_list|,
name|response
argument_list|,
name|tracker
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
name|int
name|numMaps
init|=
literal|0
decl_stmt|;
try|try
block|{
name|shuffleMetrics
operator|.
name|serverHandlerBusy
argument_list|()
expr_stmt|;
name|response
operator|.
name|setContentType
argument_list|(
literal|"application/octet-stream"
argument_list|)
expr_stmt|;
name|outStream
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|response
operator|.
name|getOutputStream
argument_list|()
argument_list|)
expr_stmt|;
comment|//use the same buffersize as used for reading the data from disk
name|response
operator|.
name|setBufferSize
argument_list|(
name|MAX_BYTES_TO_READ
argument_list|)
expr_stmt|;
name|JobConf
name|conf
init|=
operator|(
name|JobConf
operator|)
name|context
operator|.
name|getAttribute
argument_list|(
literal|"conf"
argument_list|)
decl_stmt|;
name|LocalDirAllocator
name|lDirAlloc
init|=
operator|(
name|LocalDirAllocator
operator|)
name|context
operator|.
name|getAttribute
argument_list|(
literal|"localDirAllocator"
argument_list|)
decl_stmt|;
name|FileSystem
name|rfs
init|=
operator|(
operator|(
name|LocalFileSystem
operator|)
name|context
operator|.
name|getAttribute
argument_list|(
literal|"local.file.system"
argument_list|)
operator|)
operator|.
name|getRaw
argument_list|()
decl_stmt|;
comment|// Split the map ids, send output for one map at a time
name|StringTokenizer
name|itr
init|=
operator|new
name|StringTokenizer
argument_list|(
name|mapIds
argument_list|,
literal|","
argument_list|)
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|mapId
init|=
name|itr
operator|.
name|nextToken
argument_list|()
decl_stmt|;
operator|++
name|numMaps
expr_stmt|;
name|sendMapFile
argument_list|(
name|jobId
argument_list|,
name|mapId
argument_list|,
name|reduce
argument_list|,
name|conf
argument_list|,
name|outStream
argument_list|,
name|tracker
argument_list|,
name|lDirAlloc
argument_list|,
name|shuffleMetrics
argument_list|,
name|rfs
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|Log
name|log
init|=
operator|(
name|Log
operator|)
name|context
operator|.
name|getAttribute
argument_list|(
literal|"log"
argument_list|)
decl_stmt|;
name|String
name|errorMsg
init|=
operator|(
literal|"getMapOutputs("
operator|+
name|mapIds
operator|+
literal|","
operator|+
name|reduceId
operator|+
literal|") failed"
operator|)
decl_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|errorMsg
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|checkException
argument_list|(
name|ie
argument_list|,
name|exceptionMsgRegex
argument_list|,
name|exceptionStackRegex
argument_list|,
name|shuffleMetrics
argument_list|)
expr_stmt|;
name|response
operator|.
name|sendError
argument_list|(
name|HttpServletResponse
operator|.
name|SC_GONE
argument_list|,
name|errorMsg
argument_list|)
expr_stmt|;
name|shuffleMetrics
operator|.
name|failedOutput
argument_list|()
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
finally|finally
block|{
name|shuffleMetrics
operator|.
name|serverHandlerFree
argument_list|()
expr_stmt|;
block|}
name|outStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|shuffleMetrics
operator|.
name|successOutput
argument_list|()
expr_stmt|;
name|long
name|timeElapsed
init|=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Shuffled "
operator|+
name|numMaps
operator|+
literal|"maps (mapIds="
operator|+
name|mapIds
operator|+
literal|") to reduce "
operator|+
name|reduceId
operator|+
literal|" in "
operator|+
name|timeElapsed
operator|+
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|ClientTraceLog
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|MR_CLIENTTRACE_FORMAT
argument_list|,
name|request
operator|.
name|getLocalAddr
argument_list|()
operator|+
literal|":"
operator|+
name|request
operator|.
name|getLocalPort
argument_list|()
argument_list|,
name|request
operator|.
name|getRemoteAddr
argument_list|()
operator|+
literal|":"
operator|+
name|request
operator|.
name|getRemotePort
argument_list|()
argument_list|,
name|numMaps
argument_list|,
literal|"MAPRED_SHUFFLE"
argument_list|,
name|reduceId
argument_list|,
name|timeElapsed
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkException (IOException ie, String exceptionMsgRegex, String exceptionStackRegex, ShuffleServerMetrics shuffleMetrics)
specifier|protected
name|void
name|checkException
parameter_list|(
name|IOException
name|ie
parameter_list|,
name|String
name|exceptionMsgRegex
parameter_list|,
name|String
name|exceptionStackRegex
parameter_list|,
name|ShuffleServerMetrics
name|shuffleMetrics
parameter_list|)
block|{
comment|// parse exception to see if it looks like a regular expression you
comment|// configure. If both msgRegex and StackRegex set then make sure both
comment|// match, otherwise only the one set has to match.
if|if
condition|(
name|exceptionMsgRegex
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
name|ie
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|msg
operator|==
literal|null
operator|||
operator|!
name|msg
operator|.
name|matches
argument_list|(
name|exceptionMsgRegex
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|exceptionStackRegex
operator|!=
literal|null
operator|&&
operator|!
name|checkStackException
argument_list|(
name|ie
argument_list|,
name|exceptionStackRegex
argument_list|)
condition|)
block|{
return|return;
block|}
name|shuffleMetrics
operator|.
name|exceptionsCaught
argument_list|()
expr_stmt|;
block|}
DECL|method|checkStackException (IOException ie, String exceptionStackRegex)
specifier|private
name|boolean
name|checkStackException
parameter_list|(
name|IOException
name|ie
parameter_list|,
name|String
name|exceptionStackRegex
parameter_list|)
block|{
name|StackTraceElement
index|[]
name|stack
init|=
name|ie
operator|.
name|getStackTrace
argument_list|()
decl_stmt|;
for|for
control|(
name|StackTraceElement
name|elem
range|:
name|stack
control|)
block|{
name|String
name|stacktrace
init|=
name|elem
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|stacktrace
operator|.
name|matches
argument_list|(
name|exceptionStackRegex
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|sendMapFile (String jobId, String mapId, int reduce, Configuration conf, DataOutputStream outStream, TaskTracker tracker, LocalDirAllocator lDirAlloc, ShuffleServerMetrics shuffleMetrics, FileSystem localfs )
specifier|private
name|void
name|sendMapFile
parameter_list|(
name|String
name|jobId
parameter_list|,
name|String
name|mapId
parameter_list|,
name|int
name|reduce
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|DataOutputStream
name|outStream
parameter_list|,
name|TaskTracker
name|tracker
parameter_list|,
name|LocalDirAllocator
name|lDirAlloc
parameter_list|,
name|ShuffleServerMetrics
name|shuffleMetrics
parameter_list|,
name|FileSystem
name|localfs
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"sendMapFile called for "
operator|+
name|mapId
operator|+
literal|" to reduce "
operator|+
name|reduce
argument_list|)
expr_stmt|;
comment|// true iff IOException was caused by attempt to access input
name|boolean
name|isInputException
init|=
literal|false
decl_stmt|;
name|FileInputStream
name|mapOutputIn
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|MAX_BYTES_TO_READ
index|]
decl_stmt|;
name|long
name|totalRead
init|=
literal|0
decl_stmt|;
name|String
name|userName
init|=
literal|null
decl_stmt|;
name|String
name|runAsUserName
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|tracker
operator|.
name|runningJobs
init|)
block|{
name|RunningJob
name|rjob
init|=
name|tracker
operator|.
name|runningJobs
operator|.
name|get
argument_list|(
name|JobID
operator|.
name|forName
argument_list|(
name|jobId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rjob
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown job "
operator|+
name|jobId
operator|+
literal|"!!"
argument_list|)
throw|;
block|}
name|userName
operator|=
name|rjob
operator|.
name|jobConf
operator|.
name|getUser
argument_list|()
expr_stmt|;
name|runAsUserName
operator|=
name|tracker
operator|.
name|getTaskController
argument_list|()
operator|.
name|getRunAsUser
argument_list|(
name|rjob
operator|.
name|jobConf
argument_list|)
expr_stmt|;
block|}
comment|// Index file
name|Path
name|indexFileName
init|=
name|lDirAlloc
operator|.
name|getLocalPathToRead
argument_list|(
name|TaskTracker
operator|.
name|getIntermediateOutputDir
argument_list|(
name|userName
argument_list|,
name|jobId
argument_list|,
name|mapId
argument_list|)
operator|+
literal|"/file.out.index"
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Map-output file
name|Path
name|mapOutputFileName
init|=
name|lDirAlloc
operator|.
name|getLocalPathToRead
argument_list|(
name|TaskTracker
operator|.
name|getIntermediateOutputDir
argument_list|(
name|userName
argument_list|,
name|jobId
argument_list|,
name|mapId
argument_list|)
operator|+
literal|"/file.out"
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|/**        * Read the index file to get the information about where the map-output        * for the given reducer is available.        */
name|IndexRecord
name|info
init|=
name|tracker
operator|.
name|indexCache
operator|.
name|getIndexInformation
argument_list|(
name|mapId
argument_list|,
name|reduce
argument_list|,
name|indexFileName
argument_list|,
name|runAsUserName
argument_list|)
decl_stmt|;
try|try
block|{
comment|/**          * Read the data from the single map-output file and          * send it to the reducer.          */
comment|//open the map-output file
name|mapOutputIn
operator|=
name|SecureIOUtils
operator|.
name|openForRead
argument_list|(
operator|new
name|File
argument_list|(
name|mapOutputFileName
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|runAsUserName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|//seek to the correct offset for the reduce
name|IOUtils
operator|.
name|skipFully
argument_list|(
name|mapOutputIn
argument_list|,
name|info
operator|.
name|startOffset
argument_list|)
expr_stmt|;
comment|// write header for each map output
name|ShuffleHeader
name|header
init|=
operator|new
name|ShuffleHeader
argument_list|(
name|mapId
argument_list|,
name|info
operator|.
name|partLength
argument_list|,
name|info
operator|.
name|rawLength
argument_list|,
name|reduce
argument_list|)
decl_stmt|;
name|header
operator|.
name|write
argument_list|(
name|outStream
argument_list|)
expr_stmt|;
comment|// read the map-output and stream it out
name|isInputException
operator|=
literal|true
expr_stmt|;
name|long
name|rem
init|=
name|info
operator|.
name|partLength
decl_stmt|;
if|if
condition|(
name|rem
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Illegal partLength of 0 for mapId "
operator|+
name|mapId
operator|+
literal|" to reduce "
operator|+
name|reduce
argument_list|)
throw|;
block|}
name|int
name|len
init|=
name|mapOutputIn
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|rem
argument_list|,
name|MAX_BYTES_TO_READ
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|now
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|0
condition|)
block|{
name|rem
operator|-=
name|len
expr_stmt|;
try|try
block|{
name|shuffleMetrics
operator|.
name|outputBytes
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|outStream
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipped zero-length read of map "
operator|+
name|mapId
operator|+
literal|" to reduce "
operator|+
name|reduce
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|isInputException
operator|=
literal|false
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
name|totalRead
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|rem
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|len
operator|=
name|mapOutputIn
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|rem
argument_list|,
name|MAX_BYTES_TO_READ
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|outStream
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|isInputException
operator|=
literal|false
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|String
name|errorMsg
init|=
literal|"error on sending map "
operator|+
name|mapId
operator|+
literal|" to reduce "
operator|+
name|reduce
decl_stmt|;
if|if
condition|(
name|isInputException
condition|)
block|{
name|tracker
operator|.
name|mapOutputLost
argument_list|(
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|mapId
argument_list|)
argument_list|,
name|errorMsg
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|errorMsg
argument_list|,
name|ie
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|mapOutputIn
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|mapOutputIn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"problem closing map output file"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Sent out "
operator|+
name|totalRead
operator|+
literal|" bytes to reduce "
operator|+
name|reduce
operator|+
literal|" from map: "
operator|+
name|mapId
operator|+
literal|" given "
operator|+
name|info
operator|.
name|partLength
operator|+
literal|"/"
operator|+
name|info
operator|.
name|rawLength
argument_list|)
expr_stmt|;
block|}
comment|/**      * verify that request has correct HASH for the url      * and also add a field to reply header with hash of the HASH      * @param request      * @param response      * @param jt the job token      * @throws IOException      */
DECL|method|verifyRequest (HttpServletRequest request, HttpServletResponse response, TaskTracker tracker, String jobId)
specifier|private
name|void
name|verifyRequest
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|,
name|TaskTracker
name|tracker
parameter_list|,
name|String
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
name|SecretKey
name|tokenSecret
init|=
name|tracker
operator|.
name|getJobTokenSecretManager
argument_list|()
operator|.
name|retrieveTokenSecret
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
comment|// string to encrypt
name|String
name|enc_str
init|=
name|SecureShuffleUtils
operator|.
name|buildMsgFrom
argument_list|(
name|request
argument_list|)
decl_stmt|;
comment|// hash from the fetcher
name|String
name|urlHashStr
init|=
name|request
operator|.
name|getHeader
argument_list|(
name|SecureShuffleUtils
operator|.
name|HTTP_HEADER_URL_HASH
argument_list|)
decl_stmt|;
if|if
condition|(
name|urlHashStr
operator|==
literal|null
condition|)
block|{
name|response
operator|.
name|sendError
argument_list|(
name|HttpServletResponse
operator|.
name|SC_UNAUTHORIZED
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"fetcher cannot be authenticated"
argument_list|)
throw|;
block|}
name|int
name|len
init|=
name|urlHashStr
operator|.
name|length
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"verifying request. enc_str="
operator|+
name|enc_str
operator|+
literal|"; hash=..."
operator|+
name|urlHashStr
operator|.
name|substring
argument_list|(
name|len
operator|-
name|len
operator|/
literal|2
argument_list|,
name|len
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// half of the hash for debug
comment|// verify - throws exception
try|try
block|{
name|SecureShuffleUtils
operator|.
name|verifyReply
argument_list|(
name|urlHashStr
argument_list|,
name|enc_str
argument_list|,
name|tokenSecret
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|response
operator|.
name|sendError
argument_list|(
name|HttpServletResponse
operator|.
name|SC_UNAUTHORIZED
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
comment|// verification passed - encode the reply
name|String
name|reply
init|=
name|SecureShuffleUtils
operator|.
name|generateHash
argument_list|(
name|urlHashStr
operator|.
name|getBytes
argument_list|()
argument_list|,
name|tokenSecret
argument_list|)
decl_stmt|;
name|response
operator|.
name|addHeader
argument_list|(
name|SecureShuffleUtils
operator|.
name|HTTP_HEADER_REPLY_URL_HASH
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|len
operator|=
name|reply
operator|.
name|length
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fetcher request verfied. enc_str="
operator|+
name|enc_str
operator|+
literal|";reply="
operator|+
name|reply
operator|.
name|substring
argument_list|(
name|len
operator|-
name|len
operator|/
literal|2
argument_list|,
name|len
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// get the full paths of the directory in all the local disks.
DECL|method|getLocalFiles (JobConf conf, String subdir)
name|Path
index|[]
name|getLocalFiles
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|String
name|subdir
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|localDirs
init|=
name|conf
operator|.
name|getLocalDirs
argument_list|()
decl_stmt|;
name|Path
index|[]
name|paths
init|=
operator|new
name|Path
index|[
name|localDirs
operator|.
name|length
index|]
decl_stmt|;
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|boolean
name|subdirNeeded
init|=
operator|(
name|subdir
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|subdir
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|localDirs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|paths
index|[
name|i
index|]
operator|=
operator|(
name|subdirNeeded
operator|)
condition|?
operator|new
name|Path
argument_list|(
name|localDirs
index|[
name|i
index|]
argument_list|,
name|subdir
argument_list|)
else|:
operator|new
name|Path
argument_list|(
name|localDirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|paths
index|[
name|i
index|]
operator|=
name|paths
index|[
name|i
index|]
operator|.
name|makeQualified
argument_list|(
name|localFs
argument_list|)
expr_stmt|;
block|}
return|return
name|paths
return|;
block|}
DECL|method|getLocalFileSystem ()
name|FileSystem
name|getLocalFileSystem
parameter_list|()
block|{
return|return
name|localFs
return|;
block|}
comment|// only used by tests
DECL|method|setLocalFileSystem (FileSystem fs)
name|void
name|setLocalFileSystem
parameter_list|(
name|FileSystem
name|fs
parameter_list|)
block|{
name|localFs
operator|=
name|fs
expr_stmt|;
block|}
DECL|method|getMaxCurrentMapTasks ()
name|int
name|getMaxCurrentMapTasks
parameter_list|()
block|{
return|return
name|maxMapSlots
return|;
block|}
DECL|method|getMaxCurrentReduceTasks ()
name|int
name|getMaxCurrentReduceTasks
parameter_list|()
block|{
return|return
name|maxReduceSlots
return|;
block|}
comment|//called from unit test
DECL|method|setMaxMapSlots (int mapSlots)
specifier|synchronized
name|void
name|setMaxMapSlots
parameter_list|(
name|int
name|mapSlots
parameter_list|)
block|{
name|maxMapSlots
operator|=
name|mapSlots
expr_stmt|;
block|}
comment|//called from unit test
DECL|method|setMaxReduceSlots (int reduceSlots)
specifier|synchronized
name|void
name|setMaxReduceSlots
parameter_list|(
name|int
name|reduceSlots
parameter_list|)
block|{
name|maxReduceSlots
operator|=
name|reduceSlots
expr_stmt|;
block|}
comment|/**    * Is the TaskMemoryManager Enabled on this system?    * @return true if enabled, false otherwise.    */
DECL|method|isTaskMemoryManagerEnabled ()
specifier|public
name|boolean
name|isTaskMemoryManagerEnabled
parameter_list|()
block|{
return|return
name|taskMemoryManagerEnabled
return|;
block|}
DECL|method|getTaskMemoryManager ()
specifier|public
name|TaskMemoryManagerThread
name|getTaskMemoryManager
parameter_list|()
block|{
return|return
name|taskMemoryManager
return|;
block|}
comment|/**    * Normalize the negative values in configuration    *     * @param val    * @return normalized val    */
DECL|method|normalizeMemoryConfigValue (long val)
specifier|private
name|long
name|normalizeMemoryConfigValue
parameter_list|(
name|long
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Memory-related setup    */
DECL|method|initializeMemoryManagement ()
specifier|private
name|void
name|initializeMemoryManagement
parameter_list|()
block|{
comment|//handling @deprecated
if|if
condition|(
name|fConf
operator|.
name|get
argument_list|(
name|MAPRED_TASKTRACKER_VMEM_RESERVED_PROPERTY
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|JobConf
operator|.
name|deprecatedString
argument_list|(
name|MAPRED_TASKTRACKER_VMEM_RESERVED_PROPERTY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//handling @deprecated
if|if
condition|(
name|fConf
operator|.
name|get
argument_list|(
name|MAPRED_TASKTRACKER_PMEM_RESERVED_PROPERTY
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|JobConf
operator|.
name|deprecatedString
argument_list|(
name|MAPRED_TASKTRACKER_PMEM_RESERVED_PROPERTY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//handling @deprecated
if|if
condition|(
name|fConf
operator|.
name|get
argument_list|(
name|JobConf
operator|.
name|MAPRED_TASK_DEFAULT_MAXVMEM_PROPERTY
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|JobConf
operator|.
name|deprecatedString
argument_list|(
name|JobConf
operator|.
name|MAPRED_TASK_DEFAULT_MAXVMEM_PROPERTY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//handling @deprecated
if|if
condition|(
name|fConf
operator|.
name|get
argument_list|(
name|JobConf
operator|.
name|UPPER_LIMIT_ON_TASK_VMEM_PROPERTY
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|JobConf
operator|.
name|deprecatedString
argument_list|(
name|JobConf
operator|.
name|UPPER_LIMIT_ON_TASK_VMEM_PROPERTY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Use TT_MEMORY_CALCULATOR_PLUGIN if it is configured.
name|Class
argument_list|<
name|?
extends|extends
name|MemoryCalculatorPlugin
argument_list|>
name|clazz
init|=
name|fConf
operator|.
name|getClass
argument_list|(
name|TT_MEMORY_CALCULATOR_PLUGIN
argument_list|,
literal|null
argument_list|,
name|MemoryCalculatorPlugin
operator|.
name|class
argument_list|)
decl_stmt|;
name|MemoryCalculatorPlugin
name|memoryCalculatorPlugin
init|=
operator|(
name|clazz
operator|==
literal|null
condition|?
literal|null
else|:
name|MemoryCalculatorPlugin
operator|.
name|getMemoryCalculatorPlugin
argument_list|(
name|clazz
argument_list|,
name|fConf
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|memoryCalculatorPlugin
operator|!=
literal|null
operator|||
name|resourceCalculatorPlugin
operator|!=
literal|null
condition|)
block|{
name|totalVirtualMemoryOnTT
operator|=
operator|(
name|memoryCalculatorPlugin
operator|==
literal|null
condition|?
name|resourceCalculatorPlugin
operator|.
name|getVirtualMemorySize
argument_list|()
else|:
name|memoryCalculatorPlugin
operator|.
name|getVirtualMemorySize
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|totalVirtualMemoryOnTT
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"TaskTracker's totalVmem could not be calculated. "
operator|+
literal|"Setting it to "
operator|+
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
expr_stmt|;
name|totalVirtualMemoryOnTT
operator|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
expr_stmt|;
block|}
name|totalPhysicalMemoryOnTT
operator|=
operator|(
name|memoryCalculatorPlugin
operator|==
literal|null
condition|?
name|resourceCalculatorPlugin
operator|.
name|getPhysicalMemorySize
argument_list|()
else|:
name|memoryCalculatorPlugin
operator|.
name|getPhysicalMemorySize
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|totalPhysicalMemoryOnTT
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"TaskTracker's totalPmem could not be calculated. "
operator|+
literal|"Setting it to "
operator|+
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
expr_stmt|;
name|totalPhysicalMemoryOnTT
operator|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
expr_stmt|;
block|}
block|}
name|mapSlotMemorySizeOnTT
operator|=
name|fConf
operator|.
name|getLong
argument_list|(
name|MAPMEMORY_MB
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
expr_stmt|;
name|reduceSlotSizeMemoryOnTT
operator|=
name|fConf
operator|.
name|getLong
argument_list|(
name|REDUCEMEMORY_MB
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
expr_stmt|;
name|totalMemoryAllottedForTasks
operator|=
name|maxMapSlots
operator|*
name|mapSlotMemorySizeOnTT
operator|+
name|maxReduceSlots
operator|*
name|reduceSlotSizeMemoryOnTT
expr_stmt|;
if|if
condition|(
name|totalMemoryAllottedForTasks
operator|<
literal|0
condition|)
block|{
comment|//adding check for the old keys which might be used by the administrator
comment|//while configuration of the memory monitoring on TT
name|long
name|memoryAllotedForSlot
init|=
name|fConf
operator|.
name|normalizeMemoryConfigValue
argument_list|(
name|fConf
operator|.
name|getLong
argument_list|(
name|JobConf
operator|.
name|MAPRED_TASK_DEFAULT_MAXVMEM_PROPERTY
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|limitVmPerTask
init|=
name|fConf
operator|.
name|normalizeMemoryConfigValue
argument_list|(
name|fConf
operator|.
name|getLong
argument_list|(
name|JobConf
operator|.
name|UPPER_LIMIT_ON_TASK_VMEM_PROPERTY
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|memoryAllotedForSlot
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
condition|)
block|{
name|totalMemoryAllottedForTasks
operator|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|memoryAllotedForSlot
operator|>
name|limitVmPerTask
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DefaultMaxVmPerTask is mis-configured. "
operator|+
literal|"It shouldn't be greater than task limits"
argument_list|)
expr_stmt|;
name|totalMemoryAllottedForTasks
operator|=
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
expr_stmt|;
block|}
else|else
block|{
name|totalMemoryAllottedForTasks
operator|=
operator|(
name|maxMapSlots
operator|+
name|maxReduceSlots
operator|)
operator|*
operator|(
name|memoryAllotedForSlot
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|totalMemoryAllottedForTasks
operator|>
name|totalPhysicalMemoryOnTT
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"totalMemoryAllottedForTasks> totalPhysicalMemoryOnTT."
operator|+
literal|" Thrashing might happen."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|totalMemoryAllottedForTasks
operator|>
name|totalVirtualMemoryOnTT
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"totalMemoryAllottedForTasks> totalVirtualMemoryOnTT."
operator|+
literal|" Thrashing might happen."
argument_list|)
expr_stmt|;
block|}
name|reservedPhysicalMemoryOnTT
operator|=
name|fConf
operator|.
name|getLong
argument_list|(
name|TTConfig
operator|.
name|TT_RESERVED_PHYSCIALMEMORY_MB
argument_list|,
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
argument_list|)
expr_stmt|;
name|reservedPhysicalMemoryOnTT
operator|=
name|reservedPhysicalMemoryOnTT
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
condition|?
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
else|:
name|reservedPhysicalMemoryOnTT
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
comment|// normalize to bytes
comment|// start the taskMemoryManager thread only if enabled
name|setTaskMemoryManagerEnabledFlag
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTaskMemoryManagerEnabled
argument_list|()
condition|)
block|{
name|taskMemoryManager
operator|=
operator|new
name|TaskMemoryManagerThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|taskMemoryManager
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|taskMemoryManager
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setTaskMemoryManagerEnabledFlag ()
name|void
name|setTaskMemoryManagerEnabledFlag
parameter_list|()
block|{
if|if
condition|(
operator|!
name|ProcfsBasedProcessTree
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ProcessTree implementation is missing on this system. "
operator|+
literal|"TaskMemoryManager is disabled."
argument_list|)
expr_stmt|;
name|taskMemoryManagerEnabled
operator|=
literal|false
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reservedPhysicalMemoryOnTT
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
operator|&&
name|totalMemoryAllottedForTasks
operator|==
name|JobConf
operator|.
name|DISABLED_MEMORY_LIMIT
condition|)
block|{
name|taskMemoryManagerEnabled
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"TaskTracker's totalMemoryAllottedForTasks is -1 and "
operator|+
literal|"reserved physical memory is not configured. "
operator|+
literal|"TaskMemoryManager is disabled."
argument_list|)
expr_stmt|;
return|return;
block|}
name|taskMemoryManagerEnabled
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Clean-up the task that TaskMemoryMangerThread requests to do so.    * @param tid    * @param wasFailure mark the task as failed or killed. 'failed' if true,    *          'killed' otherwise    * @param diagnosticMsg    */
DECL|method|cleanUpOverMemoryTask (TaskAttemptID tid, boolean wasFailure, String diagnosticMsg)
specifier|synchronized
name|void
name|cleanUpOverMemoryTask
parameter_list|(
name|TaskAttemptID
name|tid
parameter_list|,
name|boolean
name|wasFailure
parameter_list|,
name|String
name|diagnosticMsg
parameter_list|)
block|{
name|TaskInProgress
name|tip
init|=
name|runningTasks
operator|.
name|get
argument_list|(
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|tip
operator|.
name|reportDiagnosticInfo
argument_list|(
name|diagnosticMsg
argument_list|)
expr_stmt|;
try|try
block|{
name|purgeTask
argument_list|(
name|tip
argument_list|,
name|wasFailure
argument_list|)
expr_stmt|;
comment|// Marking it as failed/killed.
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't purge the task of "
operator|+
name|tid
operator|+
literal|". Error : "
operator|+
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Wrapper method used by TaskTracker to check if {@link  NodeHealthCheckerService}    * can be started    * @param conf configuration used to check if service can be started    * @return true if service can be started    */
DECL|method|shouldStartHealthMonitor (Configuration conf)
specifier|private
name|boolean
name|shouldStartHealthMonitor
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NodeHealthCheckerService
operator|.
name|shouldRun
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/**    * Wrapper method used to start {@link NodeHealthCheckerService} for     * Task Tracker    * @param conf Configuration used by the service.    */
DECL|method|startHealthMonitor (Configuration conf)
specifier|private
name|void
name|startHealthMonitor
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|healthChecker
operator|=
operator|new
name|NodeHealthCheckerService
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|healthChecker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|getTrackerDistributedCacheManager ()
name|TrackerDistributedCacheManager
name|getTrackerDistributedCacheManager
parameter_list|()
block|{
return|return
name|distributedCacheManager
return|;
block|}
comment|/**      * Download the job-token file from the FS and save on local fs.      * @param user      * @param jobId      * @param jobConf      * @return the local file system path of the downloaded file.      * @throws IOException      */
DECL|method|localizeJobTokenFile (String user, JobID jobId)
specifier|private
name|String
name|localizeJobTokenFile
parameter_list|(
name|String
name|user
parameter_list|,
name|JobID
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check if the tokenJob file is there..
name|Path
name|skPath
init|=
operator|new
name|Path
argument_list|(
name|systemDirectory
argument_list|,
name|jobId
operator|.
name|toString
argument_list|()
operator|+
literal|"/"
operator|+
name|TokenCache
operator|.
name|JOB_TOKEN_HDFS_FILE
argument_list|)
decl_stmt|;
name|FileStatus
name|status
init|=
literal|null
decl_stmt|;
name|long
name|jobTokenSize
init|=
operator|-
literal|1
decl_stmt|;
name|status
operator|=
name|systemFS
operator|.
name|getFileStatus
argument_list|(
name|skPath
argument_list|)
expr_stmt|;
comment|//throws FileNotFoundException
name|jobTokenSize
operator|=
name|status
operator|.
name|getLen
argument_list|()
expr_stmt|;
name|Path
name|localJobTokenFile
init|=
name|lDirAlloc
operator|.
name|getLocalPathForWrite
argument_list|(
name|getLocalJobTokenFile
argument_list|(
name|user
argument_list|,
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|jobTokenSize
argument_list|,
name|fConf
argument_list|)
decl_stmt|;
name|String
name|localJobTokenFileStr
init|=
name|localJobTokenFile
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"localizingJobTokenFile from sd="
operator|+
name|skPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|" to "
operator|+
name|localJobTokenFileStr
argument_list|)
expr_stmt|;
comment|// Download job_token
name|systemFS
operator|.
name|copyToLocalFile
argument_list|(
name|skPath
argument_list|,
name|localJobTokenFile
argument_list|)
expr_stmt|;
return|return
name|localJobTokenFileStr
return|;
block|}
DECL|method|getJobACLsManager ()
name|JobACLsManager
name|getJobACLsManager
parameter_list|()
block|{
return|return
name|aclsManager
operator|.
name|getJobACLsManager
argument_list|()
return|;
block|}
DECL|method|getACLsManager ()
name|ACLsManager
name|getACLsManager
parameter_list|()
block|{
return|return
name|aclsManager
return|;
block|}
DECL|method|getRunningTask (TaskAttemptID tid)
specifier|synchronized
name|TaskInProgress
name|getRunningTask
parameter_list|(
name|TaskAttemptID
name|tid
parameter_list|)
block|{
return|return
name|runningTasks
operator|.
name|get
argument_list|(
name|tid
argument_list|)
return|;
block|}
block|}
end_class

end_unit

