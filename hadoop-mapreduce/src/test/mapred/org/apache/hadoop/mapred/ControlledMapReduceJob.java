begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|NullWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|CompressionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|lib
operator|.
name|NullOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_comment
comment|/**  * A Controlled Map/Reduce Job. The tasks are controlled by the presence of  * particularly named files in the directory signalFileDir on the file-system  * that the job is configured to work with. Tasks get scheduled by the  * scheduler, occupy the slots on the TaskTrackers and keep running till the  * user gives a signal via files whose names are of the form MAPS_[0-9]* and  * REDUCES_[0-9]*. For e.g., whenever the map tasks see that a file name MAPS_5  * is created in the singalFileDir, all the maps whose TaskAttemptIDs are below  * 4 get finished. At any time, there should be only one MAPS_[0-9]* file and  * only one REDUCES_[0-9]* file in the singnalFileDir. In the beginning MAPS_0  * and REDUCE_0 files are present, and further signals are given by renaming  * these files.  *   */
end_comment

begin_class
DECL|class|ControlledMapReduceJob
class|class
name|ControlledMapReduceJob
extends|extends
name|Configured
implements|implements
name|Tool
implements|,
name|Mapper
argument_list|<
name|NullWritable
argument_list|,
name|NullWritable
argument_list|,
name|IntWritable
argument_list|,
name|NullWritable
argument_list|>
implements|,
name|Reducer
argument_list|<
name|IntWritable
argument_list|,
name|NullWritable
argument_list|,
name|NullWritable
argument_list|,
name|NullWritable
argument_list|>
implements|,
name|Partitioner
argument_list|<
name|IntWritable
argument_list|,
name|NullWritable
argument_list|>
implements|,
name|InputFormat
argument_list|<
name|NullWritable
argument_list|,
name|NullWritable
argument_list|>
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ControlledMapReduceJob
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|fs
specifier|private
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
DECL|field|taskNumber
specifier|private
name|int
name|taskNumber
decl_stmt|;
DECL|field|signalFileDirCache
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|Path
argument_list|>
name|signalFileDirCache
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|signalFileDir
specifier|private
name|Path
name|signalFileDir
decl_stmt|;
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|signalFileDir
operator|=
operator|new
name|Path
argument_list|(
literal|"signalFileDir-"
operator|+
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|signalFileDirCache
operator|.
name|contains
argument_list|(
name|signalFileDir
argument_list|)
condition|)
block|{
name|signalFileDir
operator|=
operator|new
name|Path
argument_list|(
literal|"signalFileDir-"
operator|+
name|random
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|signalFileDirCache
operator|.
name|add
parameter_list|(
name|signalFileDir
parameter_list|)
constructor_decl|;
block|}
DECL|field|mapsFinished
specifier|private
name|long
name|mapsFinished
init|=
literal|0
decl_stmt|;
DECL|field|reducesFinished
specifier|private
name|long
name|reducesFinished
init|=
literal|0
decl_stmt|;
DECL|field|rJob
specifier|private
name|RunningJob
name|rJob
init|=
literal|null
decl_stmt|;
DECL|field|numMappers
specifier|private
name|int
name|numMappers
decl_stmt|;
DECL|field|numReducers
specifier|private
name|int
name|numReducers
decl_stmt|;
DECL|field|MAP_SIGFILE_PREFIX
specifier|private
specifier|final
name|String
name|MAP_SIGFILE_PREFIX
init|=
literal|"MAPS_"
decl_stmt|;
DECL|field|REDUCE_SIGFILE_PREFIX
specifier|private
specifier|final
name|String
name|REDUCE_SIGFILE_PREFIX
init|=
literal|"REDUCES_"
decl_stmt|;
DECL|method|initialize ()
specifier|private
name|void
name|initialize
parameter_list|()
throws|throws
name|IOException
block|{
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|signalFileDir
argument_list|)
expr_stmt|;
name|writeFile
argument_list|(
operator|new
name|Path
argument_list|(
name|signalFileDir
argument_list|,
name|MAP_SIGFILE_PREFIX
operator|+
name|mapsFinished
argument_list|)
argument_list|)
expr_stmt|;
name|writeFile
argument_list|(
operator|new
name|Path
argument_list|(
name|signalFileDir
argument_list|,
name|REDUCE_SIGFILE_PREFIX
operator|+
name|reducesFinished
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Finish N number of maps/reduces.    *     * @param isMap    * @param noOfTasksToFinish    * @throws IOException    */
DECL|method|finishNTasks (boolean isMap, int noOfTasksToFinish)
specifier|public
name|void
name|finishNTasks
parameter_list|(
name|boolean
name|isMap
parameter_list|,
name|int
name|noOfTasksToFinish
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|noOfTasksToFinish
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Negative values for noOfTasksToFinish not acceptable"
argument_list|)
throw|;
block|}
if|if
condition|(
name|noOfTasksToFinish
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Going to finish off "
operator|+
name|noOfTasksToFinish
argument_list|)
expr_stmt|;
name|String
name|PREFIX
init|=
name|isMap
condition|?
name|MAP_SIGFILE_PREFIX
else|:
name|REDUCE_SIGFILE_PREFIX
decl_stmt|;
name|long
name|tasksFinished
init|=
name|isMap
condition|?
name|mapsFinished
else|:
name|reducesFinished
decl_stmt|;
name|Path
name|oldSignalFile
init|=
operator|new
name|Path
argument_list|(
name|signalFileDir
argument_list|,
name|PREFIX
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|tasksFinished
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|newSignalFile
init|=
operator|new
name|Path
argument_list|(
name|signalFileDir
argument_list|,
name|PREFIX
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|tasksFinished
operator|+
name|noOfTasksToFinish
argument_list|)
argument_list|)
decl_stmt|;
name|fs
operator|.
name|rename
argument_list|(
name|oldSignalFile
argument_list|,
name|newSignalFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isMap
condition|)
block|{
name|mapsFinished
operator|+=
name|noOfTasksToFinish
expr_stmt|;
block|}
else|else
block|{
name|reducesFinished
operator|+=
name|noOfTasksToFinish
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully sent signal to finish off "
operator|+
name|noOfTasksToFinish
argument_list|)
expr_stmt|;
block|}
comment|/**    * Finished all tasks of type determined by isMap    *     * @param isMap    * @throws IOException    */
DECL|method|finishAllTasks (boolean isMap)
specifier|public
name|void
name|finishAllTasks
parameter_list|(
name|boolean
name|isMap
parameter_list|)
throws|throws
name|IOException
block|{
name|finishNTasks
argument_list|(
name|isMap
argument_list|,
operator|(
name|isMap
condition|?
name|numMappers
else|:
name|numReducers
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Finish the job    *     * @throws IOException    */
DECL|method|finishJob ()
specifier|public
name|void
name|finishJob
parameter_list|()
throws|throws
name|IOException
block|{
name|finishAllTasks
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|finishAllTasks
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait till noOfTasksToBeRunning number of tasks of type specified by isMap    * started running. This currently uses a jip object and directly uses its api    * to determine the number of tasks running.    *     *<p>    *     * TODO: It should eventually use a JobID and then get the information from    * the JT to check the number of running tasks.    *     * @param jip    * @param isMap    * @param noOfTasksToBeRunning    */
DECL|method|waitTillNTasksStartRunning (JobInProgress jip, boolean isMap, int noOfTasksToBeRunning)
specifier|static
name|void
name|waitTillNTasksStartRunning
parameter_list|(
name|JobInProgress
name|jip
parameter_list|,
name|boolean
name|isMap
parameter_list|,
name|int
name|noOfTasksToBeRunning
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|int
name|numTasks
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|numTasks
operator|!=
name|noOfTasksToBeRunning
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|numTasks
operator|=
name|isMap
condition|?
name|jip
operator|.
name|runningMaps
argument_list|()
else|:
name|jip
operator|.
name|runningReduces
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting till "
operator|+
name|noOfTasksToBeRunning
operator|+
operator|(
name|isMap
condition|?
literal|" map"
else|:
literal|" reduce"
operator|)
operator|+
literal|" tasks of the job "
operator|+
name|jip
operator|.
name|getJobID
argument_list|()
operator|+
literal|" start running. "
operator|+
name|numTasks
operator|+
literal|" tasks already started running."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Make sure that the number of tasks of type specified by isMap running in    * the given job is the same as noOfTasksToBeRunning    *     *<p>    *     * TODO: It should eventually use a JobID and then get the information from    * the JT to check the number of running tasks.    *     * @param jip    * @param isMap    * @param noOfTasksToBeRunning    */
DECL|method|assertNumTasksRunning (JobInProgress jip, boolean isMap, int noOfTasksToBeRunning)
specifier|static
name|void
name|assertNumTasksRunning
parameter_list|(
name|JobInProgress
name|jip
parameter_list|,
name|boolean
name|isMap
parameter_list|,
name|int
name|noOfTasksToBeRunning
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|(
name|isMap
condition|?
name|jip
operator|.
name|runningMaps
argument_list|()
else|:
name|jip
operator|.
name|runningReduces
argument_list|()
operator|)
operator|!=
name|noOfTasksToBeRunning
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Number of tasks running is not "
operator|+
name|noOfTasksToBeRunning
argument_list|)
throw|;
block|}
block|}
comment|/**    * Wait till noOfTasksToFinish number of tasks of type specified by isMap    * are finished. This currently uses a jip object and directly uses its api to    * determine the number of tasks finished.    *     *<p>    *     * TODO: It should eventually use a JobID and then get the information from    * the JT to check the number of finished tasks.    *     * @param jip    * @param isMap    * @param noOfTasksToFinish    * @throws InterruptedException    */
DECL|method|waitTillNTotalTasksFinish (JobInProgress jip, boolean isMap, int noOfTasksToFinish)
specifier|static
name|void
name|waitTillNTotalTasksFinish
parameter_list|(
name|JobInProgress
name|jip
parameter_list|,
name|boolean
name|isMap
parameter_list|,
name|int
name|noOfTasksToFinish
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|int
name|noOfTasksAlreadyFinished
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|noOfTasksAlreadyFinished
operator|<
name|noOfTasksToFinish
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|noOfTasksAlreadyFinished
operator|=
operator|(
name|isMap
condition|?
name|jip
operator|.
name|finishedMaps
argument_list|()
else|:
name|jip
operator|.
name|finishedReduces
argument_list|()
operator|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting till "
operator|+
name|noOfTasksToFinish
operator|+
operator|(
name|isMap
condition|?
literal|" map"
else|:
literal|" reduce"
operator|)
operator|+
literal|" tasks of the job "
operator|+
name|jip
operator|.
name|getJobID
argument_list|()
operator|+
literal|" finish. "
operator|+
name|noOfTasksAlreadyFinished
operator|+
literal|" tasks already got finished."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Have all the tasks of type specified by isMap finished in this job?    *     * @param jip    * @param isMap    * @return true if finished, false otherwise    */
DECL|method|haveAllTasksFinished (JobInProgress jip, boolean isMap)
specifier|static
name|boolean
name|haveAllTasksFinished
parameter_list|(
name|JobInProgress
name|jip
parameter_list|,
name|boolean
name|isMap
parameter_list|)
block|{
return|return
operator|(
operator|(
name|isMap
condition|?
name|jip
operator|.
name|runningMaps
argument_list|()
else|:
name|jip
operator|.
name|runningReduces
argument_list|()
operator|)
operator|==
literal|0
operator|)
return|;
block|}
DECL|method|writeFile (Path name)
specifier|private
name|void
name|writeFile
parameter_list|(
name|Path
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Writer
name|writer
init|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|BytesWritable
operator|.
name|class
argument_list|,
name|BytesWritable
operator|.
name|class
argument_list|,
name|CompressionType
operator|.
name|NONE
argument_list|)
decl_stmt|;
name|writer
operator|.
name|append
argument_list|(
operator|new
name|BytesWritable
argument_list|()
argument_list|,
operator|new
name|BytesWritable
argument_list|()
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|configure (JobConf conf)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
try|try
block|{
name|signalFileDir
operator|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"signal.dir.path"
argument_list|)
argument_list|)
expr_stmt|;
name|numReducers
operator|=
name|conf
operator|.
name|getNumReduceTasks
argument_list|()
expr_stmt|;
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|String
name|taskAttemptId
init|=
name|conf
operator|.
name|get
argument_list|(
name|JobContext
operator|.
name|TASK_ATTEMPT_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskAttemptId
operator|!=
literal|null
condition|)
block|{
name|TaskAttemptID
name|taskAttemptID
init|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|taskAttemptId
argument_list|)
decl_stmt|;
name|taskNumber
operator|=
name|taskAttemptID
operator|.
name|getTaskID
argument_list|()
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception "
operator|+
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|listSignalFiles (FileSystem fileSys, final boolean isMap)
specifier|private
name|FileStatus
index|[]
name|listSignalFiles
parameter_list|(
name|FileSystem
name|fileSys
parameter_list|,
specifier|final
name|boolean
name|isMap
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fileSys
operator|.
name|globStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|signalFileDir
operator|.
name|toString
argument_list|()
operator|+
literal|"/*"
argument_list|)
argument_list|,
operator|new
name|PathFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
if|if
condition|(
name|isMap
operator|&&
name|path
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|MAP_SIGFILE_PREFIX
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found signal file : "
operator|+
name|path
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isMap
operator|&&
name|path
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|REDUCE_SIGFILE_PREFIX
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found signal file : "
operator|+
name|path
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Didn't find any relevant signal files."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|map (NullWritable key, NullWritable value, OutputCollector<IntWritable, NullWritable> output, Reporter reporter)
specifier|public
name|void
name|map
parameter_list|(
name|NullWritable
name|key
parameter_list|,
name|NullWritable
name|value
parameter_list|,
name|OutputCollector
argument_list|<
name|IntWritable
argument_list|,
name|NullWritable
argument_list|>
name|output
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|taskNumber
operator|+
literal|" has started."
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|listSignalFiles
argument_list|(
name|fs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|String
index|[]
name|sigFileComps
init|=
name|files
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|split
argument_list|(
literal|"_"
argument_list|)
decl_stmt|;
name|String
name|signalType
init|=
name|sigFileComps
index|[
literal|0
index|]
decl_stmt|;
name|int
name|noOfTasks
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sigFileComps
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|signalType
operator|.
name|equals
argument_list|(
literal|"MAPS"
argument_list|)
operator|||
name|taskNumber
operator|+
literal|1
operator|>
name|noOfTasks
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Signal type found : "
operator|+
name|signalType
operator|+
literal|" .Number of tasks to be finished by this signal : "
operator|+
name|noOfTasks
operator|+
literal|" . My id : "
operator|+
name|taskNumber
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|taskNumber
operator|+
literal|" is still alive."
argument_list|)
expr_stmt|;
try|try
block|{
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|taskNumber
operator|+
literal|" is still alive."
argument_list|)
expr_stmt|;
break|break;
block|}
name|files
operator|=
name|listSignalFiles
argument_list|(
name|fs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|sigFileComps
operator|=
name|files
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|split
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|signalType
operator|=
name|sigFileComps
index|[
literal|0
index|]
expr_stmt|;
name|noOfTasks
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sigFileComps
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Signal type found : "
operator|+
name|signalType
operator|+
literal|" .Number of tasks to be finished by this signal : "
operator|+
name|noOfTasks
operator|+
literal|" . My id : "
operator|+
name|taskNumber
argument_list|)
expr_stmt|;
comment|// output numReduce number of random values, so that
comment|// each reducer will get one key each.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numReducers
condition|;
name|i
operator|++
control|)
block|{
name|output
operator|.
name|collect
argument_list|(
operator|new
name|IntWritable
argument_list|(
name|i
argument_list|)
argument_list|,
name|NullWritable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|taskNumber
operator|+
literal|" is finished."
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|reduce (IntWritable key, Iterator<NullWritable> values, OutputCollector<NullWritable, NullWritable> output, Reporter reporter)
specifier|public
name|void
name|reduce
parameter_list|(
name|IntWritable
name|key
parameter_list|,
name|Iterator
argument_list|<
name|NullWritable
argument_list|>
name|values
parameter_list|,
name|OutputCollector
argument_list|<
name|NullWritable
argument_list|,
name|NullWritable
argument_list|>
name|output
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|taskNumber
operator|+
literal|" has started."
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|listSignalFiles
argument_list|(
name|fs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|String
index|[]
name|sigFileComps
init|=
name|files
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|split
argument_list|(
literal|"_"
argument_list|)
decl_stmt|;
name|String
name|signalType
init|=
name|sigFileComps
index|[
literal|0
index|]
decl_stmt|;
name|int
name|noOfTasks
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sigFileComps
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|signalType
operator|.
name|equals
argument_list|(
literal|"REDUCES"
argument_list|)
operator|||
name|taskNumber
operator|+
literal|1
operator|>
name|noOfTasks
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Signal type found : "
operator|+
name|signalType
operator|+
literal|" .Number of tasks to be finished by this signal : "
operator|+
name|noOfTasks
operator|+
literal|" . My id : "
operator|+
name|taskNumber
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|taskNumber
operator|+
literal|" is still alive."
argument_list|)
expr_stmt|;
try|try
block|{
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|taskNumber
operator|+
literal|" is still alive."
argument_list|)
expr_stmt|;
break|break;
block|}
name|files
operator|=
name|listSignalFiles
argument_list|(
name|fs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|sigFileComps
operator|=
name|files
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|split
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|signalType
operator|=
name|sigFileComps
index|[
literal|0
index|]
expr_stmt|;
name|noOfTasks
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sigFileComps
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Signal type found : "
operator|+
name|signalType
operator|+
literal|" .Number of tasks to be finished by this signal : "
operator|+
name|noOfTasks
operator|+
literal|" . My id : "
operator|+
name|taskNumber
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|taskNumber
operator|+
literal|" is finished."
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// nothing
block|}
DECL|method|getJobId ()
specifier|public
name|JobID
name|getJobId
parameter_list|()
block|{
if|if
condition|(
name|rJob
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|rJob
operator|.
name|getID
argument_list|()
return|;
block|}
DECL|method|run (int numMapper, int numReducer)
specifier|public
name|int
name|run
parameter_list|(
name|int
name|numMapper
parameter_list|,
name|int
name|numReducer
parameter_list|)
throws|throws
name|IOException
block|{
name|JobConf
name|conf
init|=
name|getControlledMapReduceJobConf
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|numMapper
argument_list|,
name|numReducer
argument_list|)
decl_stmt|;
name|JobClient
name|client
init|=
operator|new
name|JobClient
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|rJob
operator|=
name|client
operator|.
name|submitJob
argument_list|(
name|conf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|rJob
operator|.
name|isComplete
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|rJob
operator|.
name|isSuccessful
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
DECL|method|getControlledMapReduceJobConf (Configuration clusterConf, int numMapper, int numReducer)
specifier|private
name|JobConf
name|getControlledMapReduceJobConf
parameter_list|(
name|Configuration
name|clusterConf
parameter_list|,
name|int
name|numMapper
parameter_list|,
name|int
name|numReducer
parameter_list|)
throws|throws
name|IOException
block|{
name|setConf
argument_list|(
name|clusterConf
argument_list|)
expr_stmt|;
name|initialize
argument_list|()
expr_stmt|;
name|JobConf
name|conf
init|=
operator|new
name|JobConf
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|ControlledMapReduceJob
operator|.
name|class
argument_list|)
decl_stmt|;
name|conf
operator|.
name|setJobName
argument_list|(
literal|"ControlledJob"
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"signal.dir.path"
argument_list|,
name|signalFileDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setNumMapTasks
argument_list|(
name|numMapper
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setNumReduceTasks
argument_list|(
name|numReducer
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapperClass
argument_list|(
name|ControlledMapReduceJob
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapOutputKeyClass
argument_list|(
name|IntWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapOutputValueClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setReducerClass
argument_list|(
name|ControlledMapReduceJob
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setOutputKeyClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setOutputValueClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInputFormat
argument_list|(
name|ControlledMapReduceJob
operator|.
name|class
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|addInputPath
argument_list|(
name|conf
argument_list|,
operator|new
name|Path
argument_list|(
literal|"ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setOutputFormat
argument_list|(
name|NullOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapSpeculativeExecution
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setReduceSpeculativeExecution
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Set the following for reduce tasks to be able to be started running
comment|// immediately along with maps.
name|conf
operator|.
name|set
argument_list|(
name|JobContext
operator|.
name|COMPLETED_MAPS_FOR_REDUCE_SLOWSTART
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
annotation|@
name|Override
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|numMappers
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|numReducers
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|run
argument_list|(
name|numMappers
argument_list|,
name|numReducers
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getPartition (IntWritable k, NullWritable v, int numPartitions)
specifier|public
name|int
name|getPartition
parameter_list|(
name|IntWritable
name|k
parameter_list|,
name|NullWritable
name|v
parameter_list|,
name|int
name|numPartitions
parameter_list|)
block|{
return|return
name|k
operator|.
name|get
argument_list|()
operator|%
name|numPartitions
return|;
block|}
annotation|@
name|Override
DECL|method|getRecordReader ( InputSplit split, JobConf job, Reporter reporter)
specifier|public
name|RecordReader
argument_list|<
name|NullWritable
argument_list|,
name|NullWritable
argument_list|>
name|getRecordReader
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|JobConf
name|job
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Inside RecordReader.getRecordReader"
argument_list|)
expr_stmt|;
return|return
operator|new
name|RecordReader
argument_list|<
name|NullWritable
argument_list|,
name|NullWritable
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|pos
init|=
literal|0
decl_stmt|;
specifier|public
name|void
name|close
parameter_list|()
block|{
comment|// nothing
block|}
specifier|public
name|NullWritable
name|createKey
parameter_list|()
block|{
return|return
name|NullWritable
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|NullWritable
name|createValue
parameter_list|()
block|{
return|return
name|NullWritable
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|long
name|getPos
parameter_list|()
block|{
return|return
name|pos
return|;
block|}
specifier|public
name|float
name|getProgress
parameter_list|()
block|{
return|return
name|pos
operator|*
literal|100
return|;
block|}
specifier|public
name|boolean
name|next
parameter_list|(
name|NullWritable
name|key
parameter_list|,
name|NullWritable
name|value
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|++
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning the next record"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"No more records. Returning none."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|getSplits (JobConf job, int numSplits)
specifier|public
name|InputSplit
index|[]
name|getSplits
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|int
name|numSplits
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Inside InputSplit.getSplits"
argument_list|)
expr_stmt|;
name|InputSplit
index|[]
name|ret
init|=
operator|new
name|InputSplit
index|[
name|numSplits
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSplits
condition|;
operator|++
name|i
control|)
block|{
name|ret
index|[
name|i
index|]
operator|=
operator|new
name|EmptySplit
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|class|EmptySplit
specifier|public
specifier|static
class|class
name|EmptySplit
implements|implements
name|InputSplit
block|{
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{     }
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{     }
DECL|method|getLength ()
specifier|public
name|long
name|getLength
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
DECL|method|getLocations ()
specifier|public
name|String
index|[]
name|getLocations
parameter_list|()
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
block|}
DECL|class|ControlledMapReduceJobRunner
specifier|static
class|class
name|ControlledMapReduceJobRunner
extends|extends
name|Thread
block|{
DECL|field|conf
specifier|private
name|JobConf
name|conf
decl_stmt|;
DECL|field|job
specifier|private
name|ControlledMapReduceJob
name|job
decl_stmt|;
DECL|field|jobID
specifier|private
name|JobID
name|jobID
decl_stmt|;
DECL|field|numMappers
specifier|private
name|int
name|numMappers
decl_stmt|;
DECL|field|numReducers
specifier|private
name|int
name|numReducers
decl_stmt|;
DECL|method|ControlledMapReduceJobRunner ()
specifier|public
name|ControlledMapReduceJobRunner
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|JobConf
argument_list|()
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
DECL|method|ControlledMapReduceJobRunner (JobConf cnf, int numMap, int numRed)
specifier|public
name|ControlledMapReduceJobRunner
parameter_list|(
name|JobConf
name|cnf
parameter_list|,
name|int
name|numMap
parameter_list|,
name|int
name|numRed
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|cnf
expr_stmt|;
name|this
operator|.
name|numMappers
operator|=
name|numMap
expr_stmt|;
name|this
operator|.
name|numReducers
operator|=
name|numRed
expr_stmt|;
block|}
DECL|method|getJob ()
specifier|public
name|ControlledMapReduceJob
name|getJob
parameter_list|()
block|{
while|while
condition|(
name|job
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|ControlledMapReduceJobRunner
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|" is interrupted."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|job
return|;
block|}
DECL|method|getJobID ()
specifier|public
name|JobID
name|getJobID
parameter_list|()
throws|throws
name|IOException
block|{
name|ControlledMapReduceJob
name|job
init|=
name|getJob
argument_list|()
decl_stmt|;
name|JobID
name|id
init|=
name|job
operator|.
name|getJobId
argument_list|()
decl_stmt|;
while|while
condition|(
name|id
operator|==
literal|null
condition|)
block|{
name|id
operator|=
name|job
operator|.
name|getJobId
argument_list|()
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|ControlledMapReduceJobRunner
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|" is interrupted."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|id
return|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Job is already running."
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|job
operator|=
operator|new
name|ControlledMapReduceJob
argument_list|()
expr_stmt|;
name|int
name|ret
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|job
argument_list|,
operator|new
name|String
index|[]
block|{
name|String
operator|.
name|valueOf
argument_list|(
name|numMappers
argument_list|)
block|,
name|String
operator|.
name|valueOf
argument_list|(
name|numReducers
argument_list|)
block|}
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Return value for the job : "
operator|+
name|ret
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getControlledMapReduceJobRunner ( JobConf conf, int numMappers, int numReducers)
specifier|static
name|ControlledMapReduceJobRunner
name|getControlledMapReduceJobRunner
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|int
name|numMappers
parameter_list|,
name|int
name|numReducers
parameter_list|)
block|{
return|return
operator|new
name|ControlledMapReduceJobRunner
argument_list|(
name|conf
argument_list|,
name|numMappers
argument_list|,
name|numReducers
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

