begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobInProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobStatusChangeEvent
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|TaskTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|JobStory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|rumen
operator|.
name|TaskAttemptInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SimulatorJobInProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_comment
comment|/**  * {@link SimulatorJobTracker} extends {@link JobTracker}. It implements the  * {@link InterTrackerProtocol} protocols.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|class|SimulatorJobTracker
specifier|public
class|class
name|SimulatorJobTracker
extends|extends
name|JobTracker
block|{
comment|// A queue for cleaning up jobs from the memory. The length of this queue
comment|// is always less than the constant specified by JOBS_IN_MUMAK_MEMORY.
DECL|field|cleanupQueue
specifier|private
name|LinkedList
argument_list|<
name|JobID
argument_list|>
name|cleanupQueue
decl_stmt|;
comment|// The simulatorClock maintains the current simulation time
comment|// and should always be synchronized with the time maintained by the engine.
DECL|field|clock
specifier|private
specifier|static
name|SimulatorClock
name|clock
init|=
literal|null
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SimulatorJobTracker
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// This constant is used to specify how many jobs should be maintained in the
comment|// memory of the mumak simulator.
DECL|field|JOBS_IN_MUMAK_MEMORY
specifier|private
specifier|static
specifier|final
name|int
name|JOBS_IN_MUMAK_MEMORY
init|=
literal|50
decl_stmt|;
comment|// The SimulatorEngine data structure is engine that drives the simulator.
DECL|field|engine
specifier|private
specifier|static
name|SimulatorEngine
name|engine
init|=
literal|null
decl_stmt|;
DECL|method|resetEngineClock (SimulatorEngine engine, SimulatorClock clock)
specifier|private
specifier|static
specifier|synchronized
name|void
name|resetEngineClock
parameter_list|(
name|SimulatorEngine
name|engine
parameter_list|,
name|SimulatorClock
name|clock
parameter_list|)
block|{
name|SimulatorJobTracker
operator|.
name|engine
operator|=
name|engine
expr_stmt|;
name|SimulatorJobTracker
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
block|}
comment|/**    * In addition to the standard JobConf object, the constructor for SimulatorJobTracker requires a     * start time for simulation and a reference to the SimulatorEngine object. The clock of the    * JobTracker is set with this start time.    * @param conf the starting configuration of the SimulatorJobTracker.    * @param clock the SimulatorClock object that we use to maintain simulator time.    * @param simulatorEngine the simulatorEngine that is running the simulation.    */
DECL|method|SimulatorJobTracker (JobConf conf, SimulatorClock clock, SimulatorEngine simulatorEngine)
name|SimulatorJobTracker
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|SimulatorClock
name|clock
parameter_list|,
name|SimulatorEngine
name|simulatorEngine
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Invoke the super constructor with a flag that
comment|// indicates simulation
name|super
argument_list|(
name|conf
argument_list|,
name|clock
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|resetEngineClock
argument_list|(
name|simulatorEngine
argument_list|,
name|clock
argument_list|)
expr_stmt|;
name|cleanupQueue
operator|=
operator|new
name|LinkedList
argument_list|<
name|JobID
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/**    * Starts the JobTracker with given configuration and a given time. It also    * starts the JobNotifier thread.     * @param conf the starting configuration of the SimulatorJobTracker.    * @param startTime the starting time of simulation -- this is used to    * initialize the clock.    * @param engine the SimulatorEngine that we talk to.     * @throws IOException    */
DECL|method|startTracker (JobConf conf, long startTime, SimulatorEngine engine)
specifier|public
specifier|static
name|SimulatorJobTracker
name|startTracker
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|long
name|startTime
parameter_list|,
name|SimulatorEngine
name|engine
parameter_list|)
throws|throws
name|IOException
block|{
name|SimulatorJobTracker
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
name|SimulatorClock
name|simClock
init|=
operator|new
name|SimulatorClock
argument_list|(
name|startTime
argument_list|)
decl_stmt|;
name|result
operator|=
operator|new
name|SimulatorJobTracker
argument_list|(
name|conf
argument_list|,
name|simClock
argument_list|,
name|engine
argument_list|)
expr_stmt|;
name|result
operator|.
name|taskScheduler
operator|.
name|setTaskTrackerManager
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error starting tracker: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|JobEndNotifier
operator|.
name|startNotifier
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Start the SimulatorJobTracker with given configuration after    * creating its own SimulatorEngine. Pretty much    * used for debugging only.     * @param conf :The starting configuration of the SimulatorJobTracker    * @param startTime :The starting time of simulation    * @return void    * @throws IOException    * @throws InterruptedException    */
DECL|method|startTracker (JobConf conf, long startTime)
specifier|public
specifier|static
name|SimulatorJobTracker
name|startTracker
parameter_list|(
name|JobConf
name|conf
parameter_list|,
name|long
name|startTime
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|startTracker
argument_list|(
name|conf
argument_list|,
name|startTime
argument_list|,
operator|new
name|SimulatorEngine
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|offerService ()
specifier|public
name|void
name|offerService
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|taskScheduler
operator|.
name|start
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"started taskScheduler..."
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|state
operator|=
name|State
operator|.
name|RUNNING
expr_stmt|;
block|}
block|}
comment|/**    * Returns the simulatorClock in that is a static object in SimulatorJobTracker.     *     * @return SimulatorClock object.    */
DECL|method|getClock ()
specifier|static
name|Clock
name|getClock
parameter_list|()
block|{
assert|assert
operator|(
name|engine
operator|.
name|getCurrentTime
argument_list|()
operator|==
name|clock
operator|.
name|getTime
argument_list|()
operator|)
operator|:
literal|" Engine time = "
operator|+
name|engine
operator|.
name|getCurrentTime
argument_list|()
operator|+
literal|" JobTracker time = "
operator|+
name|clock
operator|.
name|getTime
argument_list|()
assert|;
return|return
name|clock
return|;
block|}
comment|/**    * Overriding the getCleanTaskReports function of the    * original JobTracker since we do not have setup and cleanup     * tasks.    * @param jobid JobID for which we desire cleanup reports.    */
annotation|@
name|Override
DECL|method|getCleanupTaskReports (JobID jobid)
specifier|public
specifier|synchronized
name|TaskReport
index|[]
name|getCleanupTaskReports
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Overriding since we do not support queue acls.    */
annotation|@
name|Override
DECL|method|getQueueAclsForCurrentUser ()
specifier|public
name|QueueAclsInfo
index|[]
name|getQueueAclsForCurrentUser
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Overriding since we do not simulate setup/cleanup tasks.    */
annotation|@
name|Override
DECL|method|getSetupTaskReports (JobID jobid)
specifier|public
specifier|synchronized
name|TaskReport
index|[]
name|getSetupTaskReports
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|submitJob ( JobID jobId, String jobSubmitDir, Credentials ts)
specifier|public
specifier|synchronized
name|JobStatus
name|submitJob
parameter_list|(
name|JobID
name|jobId
parameter_list|,
name|String
name|jobSubmitDir
parameter_list|,
name|Credentials
name|ts
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|loggingEnabled
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"submitJob for jobname = "
operator|+
name|jobId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jobs
operator|.
name|containsKey
argument_list|(
name|jobId
argument_list|)
condition|)
block|{
comment|// job already running, don't start twice
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Job '"
operator|+
name|jobId
operator|.
name|getId
argument_list|()
operator|+
literal|"' already present "
argument_list|)
expr_stmt|;
block|}
return|return
name|jobs
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
operator|.
name|getStatus
argument_list|()
return|;
block|}
name|JobStory
name|jobStory
init|=
name|SimulatorJobCache
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
if|if
condition|(
name|jobStory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Job not found in SimulatorJobCache: "
operator|+
name|jobId
argument_list|)
throw|;
block|}
name|validateAndSetClock
argument_list|(
name|jobStory
operator|.
name|getSubmissionTime
argument_list|()
argument_list|)
expr_stmt|;
name|SimulatorJobInProgress
name|job
init|=
operator|new
name|SimulatorJobInProgress
argument_list|(
name|jobId
argument_list|,
name|jobSubmitDir
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|jobStory
argument_list|)
decl_stmt|;
comment|// Check whether the queue information provided is valid
try|try
block|{
name|checkQueueValidity
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Queue given for job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|" is not valid:"
operator|+
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
comment|// Check the job if it cannot run in the cluster because of invalid memory
comment|// requirements.
try|try
block|{
name|checkMemoryRequirements
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in checking Memory requirements of jobId: "
operator|+
name|jobId
operator|+
name|ioe
argument_list|)
expr_stmt|;
comment|//throw ioe;
block|}
return|return
name|addJob
argument_list|(
name|jobId
argument_list|,
name|job
argument_list|)
return|;
block|}
comment|/**    * Return the SimulatorJob object given a jobID.    * @param jobid    * @return    */
DECL|method|getSimulatorJob (JobID jobid)
specifier|private
name|SimulatorJobInProgress
name|getSimulatorJob
parameter_list|(
name|JobID
name|jobid
parameter_list|)
block|{
return|return
operator|(
name|SimulatorJobInProgress
operator|)
name|jobs
operator|.
name|get
argument_list|(
name|jobid
argument_list|)
return|;
block|}
comment|/**    * Safely clean-up all data structures at the end of the     * job (success/failure/killed). In addition to performing the tasks that the    * original finalizeJob does, we also inform the SimulatorEngine about the     * completion of this job.     *      * @param job completed job.    */
annotation|@
name|Override
DECL|method|finalizeJob (JobInProgress job)
specifier|synchronized
name|void
name|finalizeJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
comment|// Let the SimulatorEngine know that the job is done
name|JobStatus
name|cloneStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|engine
operator|.
name|markCompletedJob
argument_list|(
name|cloneStatus
argument_list|,
name|SimulatorJobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|JobID
name|jobId
init|=
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getJobID
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished job "
operator|+
name|jobId
operator|+
literal|" endtime = "
operator|+
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
operator|+
literal|" with status: "
operator|+
name|JobStatus
operator|.
name|getJobRunState
argument_list|(
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// for updating the metrics and JobHistory, invoke the original
comment|// finalizeJob.
name|super
operator|.
name|finalizeJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
comment|// now placing this job in queue for future nuking
name|cleanupJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
comment|/**    * The cleanupJob method maintains the queue cleanQueue. When a job is finalized,     * it is added to the cleanupQueue. Jobs are removed from the cleanupQueue    * so that its size is maintained to be less than that specified by    * JOBS_IN_MUMAK_MEMORY.    * @param job : The JobInProgress object that was just finalized and is     * going to be added to the cleanupQueue.     */
DECL|method|cleanupJob (JobInProgress job)
specifier|private
name|void
name|cleanupJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
name|cleanupQueue
operator|.
name|add
argument_list|(
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|cleanupQueue
operator|.
name|size
argument_list|()
operator|>
name|JOBS_IN_MUMAK_MEMORY
condition|)
block|{
name|JobID
name|removedJob
init|=
name|cleanupQueue
operator|.
name|poll
argument_list|()
decl_stmt|;
name|retireJob
argument_list|(
name|removedJob
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
comment|// //////////////////////////////////////////////////
comment|// InterTrackerProtocol
comment|// //////////////////////////////////////////////////
annotation|@
name|Override
DECL|method|processHeartbeat (TaskTrackerStatus trackerStatus, boolean initialContact)
specifier|synchronized
name|boolean
name|processHeartbeat
parameter_list|(
name|TaskTrackerStatus
name|trackerStatus
parameter_list|,
name|boolean
name|initialContact
parameter_list|)
block|{
name|boolean
name|loggingEnabled
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|String
name|trackerName
init|=
name|trackerStatus
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
name|boolean
name|seenBefore
init|=
name|updateTaskTrackerStatus
argument_list|(
name|trackerName
argument_list|,
name|trackerStatus
argument_list|)
decl_stmt|;
name|TaskTracker
name|taskTracker
init|=
name|getTaskTracker
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
comment|// update the status of the task tracker. Also updates all aggregate
comment|// statistics
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"processing heartbeat for "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"updating TaskTracker status for "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initialContact
condition|)
block|{
comment|// If it's first contact, then clear out
comment|// any state hanging around
if|if
condition|(
name|seenBefore
condition|)
block|{
name|lostTaskTracker
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If not first contact, there should be some record of the tracker
if|if
condition|(
operator|!
name|seenBefore
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Status from unknown Tracker : "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
name|updateTaskTrackerStatus
argument_list|(
name|trackerName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|initialContact
condition|)
block|{
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"adding new tracker name = "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
block|}
name|addNewTracker
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"updating TaskStatus for "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
block|}
comment|// update status of all tasks from heartbeat
name|updateTaskStatuses
argument_list|(
name|trackerStatus
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Utility to validate the current simulation time    * @param newSimulationTime    */
DECL|method|validateAndSetClock (long newSimulationTime)
specifier|private
name|void
name|validateAndSetClock
parameter_list|(
name|long
name|newSimulationTime
parameter_list|)
block|{
comment|// We do not use the getClock routine here as
comment|// the Engine and JobTracker clocks are different at
comment|// this point.
name|long
name|currentSimulationTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|newSimulationTime
operator|<
name|currentSimulationTime
condition|)
block|{
comment|// time has gone backwards
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Time has gone backwards! "
operator|+
literal|"newSimulationTime: "
operator|+
name|newSimulationTime
operator|+
literal|" while currentTime: "
operator|+
name|currentSimulationTime
argument_list|)
throw|;
block|}
comment|// the simulation time should also match that in the engine
assert|assert
operator|(
name|newSimulationTime
operator|==
name|engine
operator|.
name|getCurrentTime
argument_list|()
operator|)
operator|:
literal|" newTime ="
operator|+
name|newSimulationTime
operator|+
literal|" engineTime = "
operator|+
name|engine
operator|.
name|getCurrentTime
argument_list|()
assert|;
comment|// set the current simulation time
name|clock
operator|.
name|setTime
argument_list|(
name|newSimulationTime
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|heartbeat (TaskTrackerStatus status, boolean restarted, boolean initialContact, boolean acceptNewTasks, short responseId)
specifier|public
specifier|synchronized
name|HeartbeatResponse
name|heartbeat
parameter_list|(
name|TaskTrackerStatus
name|status
parameter_list|,
name|boolean
name|restarted
parameter_list|,
name|boolean
name|initialContact
parameter_list|,
name|boolean
name|acceptNewTasks
parameter_list|,
name|short
name|responseId
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|loggingEnabled
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got heartbeat from: "
operator|+
name|status
operator|.
name|getTrackerName
argument_list|()
operator|+
literal|" (restarted: "
operator|+
name|restarted
operator|+
literal|" initialContact: "
operator|+
name|initialContact
operator|+
literal|" acceptNewTasks: "
operator|+
name|acceptNewTasks
operator|+
literal|")"
operator|+
literal|" with responseId: "
operator|+
name|responseId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|status
operator|instanceof
name|SimulatorTaskTrackerStatus
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expecting SimulatorTaskTrackerStatus, but got "
operator|+
name|status
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
name|SimulatorTaskTrackerStatus
name|taskTrackerStatus
init|=
operator|(
name|SimulatorTaskTrackerStatus
operator|)
name|status
decl_stmt|;
name|String
name|trackerName
init|=
name|taskTrackerStatus
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
comment|// validate and set the simulation time
comment|// according to the time sent by the tracker
name|validateAndSetClock
argument_list|(
name|taskTrackerStatus
operator|.
name|getCurrentSimulationTime
argument_list|()
argument_list|)
expr_stmt|;
name|HeartbeatResponse
name|prevHeartbeatResponse
init|=
name|trackerToHeartbeatResponseMap
operator|.
name|get
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialContact
operator|!=
literal|true
condition|)
block|{
comment|// If this isn't the 'initial contact' from the tasktracker,
comment|// there is something seriously wrong if the JobTracker has
comment|// no record of the 'previous heartbeat'; if so, ask the
comment|// tasktracker to re-initialize itself.
if|if
condition|(
name|prevHeartbeatResponse
operator|==
literal|null
condition|)
block|{
comment|// This is the first heartbeat from the old tracker to the newly
comment|// started JobTracker
comment|// Jobtracker might have restarted but no recovery is needed
comment|// otherwise this code should not be reached
name|LOG
operator|.
name|warn
argument_list|(
literal|"Serious problem, cannot find record of 'previous' "
operator|+
literal|" heartbeat for '"
operator|+
name|trackerName
operator|+
literal|"'; reinitializing the tasktracker"
argument_list|)
expr_stmt|;
return|return
operator|new
name|HeartbeatResponse
argument_list|(
name|responseId
argument_list|,
operator|new
name|TaskTrackerAction
index|[]
block|{
operator|new
name|ReinitTrackerAction
argument_list|()
block|}
argument_list|)
return|;
block|}
else|else
block|{
comment|// It is completely safe to not process a 'duplicate' heartbeat
comment|// from a
comment|// {@link TaskTracker} since it resends the heartbeat when rpcs
comment|// are
comment|// lost see {@link TaskTracker.transmitHeartbeat()};
comment|// acknowledge it by re-sending the previous response to let the
comment|// {@link TaskTracker} go forward.
if|if
condition|(
name|prevHeartbeatResponse
operator|.
name|getResponseId
argument_list|()
operator|!=
name|responseId
condition|)
block|{
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring 'duplicate' heartbeat from '"
operator|+
name|trackerName
operator|+
literal|"'; resending the previous 'lost' response"
argument_list|)
expr_stmt|;
block|}
return|return
name|prevHeartbeatResponse
return|;
block|}
block|}
block|}
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"processed heartbeat for responseId = "
operator|+
name|responseId
argument_list|)
expr_stmt|;
block|}
name|short
name|newResponseId
init|=
call|(
name|short
call|)
argument_list|(
name|responseId
operator|+
literal|1
argument_list|)
decl_stmt|;
name|status
operator|.
name|setLastSeen
argument_list|(
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// process the incoming heartbeat
if|if
condition|(
operator|!
name|processHeartbeat
argument_list|(
name|taskTrackerStatus
argument_list|,
name|initialContact
argument_list|)
condition|)
block|{
if|if
condition|(
name|prevHeartbeatResponse
operator|!=
literal|null
condition|)
block|{
name|trackerToHeartbeatResponseMap
operator|.
name|remove
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|HeartbeatResponse
argument_list|(
name|newResponseId
argument_list|,
operator|new
name|TaskTrackerAction
index|[]
block|{
operator|new
name|ReinitTrackerAction
argument_list|()
block|}
argument_list|)
return|;
block|}
comment|// Initialize the response to be sent for the heartbeat
name|HeartbeatResponse
name|response
init|=
operator|new
name|HeartbeatResponse
argument_list|(
name|newResponseId
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerAction
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|acceptNewTasks
condition|)
block|{
name|TaskTracker
name|taskTracker
init|=
name|getTaskTracker
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
comment|// get the list of tasks to be executed on this tasktracker
name|List
argument_list|<
name|Task
argument_list|>
name|tasks
init|=
name|taskScheduler
operator|.
name|assignTasks
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|tasks
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|loggingEnabled
operator|&&
name|tasks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Tasks found from TaskScheduler: number = "
operator|+
name|tasks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Task
name|task
range|:
name|tasks
control|)
block|{
name|TaskAttemptID
name|taskAttemptID
init|=
name|task
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
comment|// get the JobID and the JIP object for this taskAttempt
name|JobID
name|jobID
init|=
name|taskAttemptID
operator|.
name|getJobID
argument_list|()
decl_stmt|;
name|SimulatorJobInProgress
name|job
init|=
name|getSimulatorJob
argument_list|(
name|jobID
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Getting taskAttemptId="
operator|+
name|taskAttemptID
operator|+
literal|" for job "
operator|+
name|jobID
operator|+
literal|" not present in SimulatorJobTracker"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Getting taskAttemptId="
operator|+
name|taskAttemptID
operator|+
literal|" for job "
operator|+
name|jobID
operator|+
literal|" not present in SimulatorJobTracker"
argument_list|)
throw|;
block|}
comment|// add the launch task action to the list
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting taskAttemptInfo for '"
operator|+
name|taskAttemptID
operator|+
literal|"' for tracker '"
operator|+
name|trackerName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|TaskAttemptInfo
name|taskAttemptInfo
init|=
name|job
operator|.
name|getTaskAttemptInfo
argument_list|(
name|taskTracker
argument_list|,
name|taskAttemptID
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskAttemptInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Empty taskAttemptInfo: "
operator|+
literal|"task information missing"
argument_list|)
throw|;
block|}
comment|// create the SLTA object using the task attempt information
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding LaunchTaskAction for '"
operator|+
name|taskAttemptID
operator|+
literal|"' for tracker "
operator|+
name|trackerName
operator|+
literal|" taskType="
operator|+
name|taskAttemptID
operator|.
name|getTaskType
argument_list|()
operator|+
literal|" time="
operator|+
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SimulatorLaunchTaskAction
name|newlaunchTask
init|=
operator|new
name|SimulatorLaunchTaskAction
argument_list|(
name|task
argument_list|,
name|taskAttemptInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Job "
operator|+
name|jobID
operator|+
literal|" launched taskattempt "
operator|+
name|taskAttemptID
operator|+
literal|" at "
operator|+
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|actions
operator|.
name|add
argument_list|(
name|newlaunchTask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Check for tasks to be killed
comment|// also get the attemptIDs in a separate set for quick lookup
comment|// during the MapCompletion generation
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|killTasksList
init|=
name|getTasksToKill
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|killTasksList
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|loggingEnabled
condition|)
block|{
for|for
control|(
name|TaskTrackerAction
name|ttAction
range|:
name|killTasksList
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Time ="
operator|+
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
operator|+
literal|" tracker="
operator|+
name|trackerName
operator|+
literal|" KillTaskAction for:"
operator|+
operator|(
operator|(
name|KillTaskAction
operator|)
name|ttAction
operator|)
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|actions
operator|.
name|addAll
argument_list|(
name|killTasksList
argument_list|)
expr_stmt|;
block|}
comment|// Check for tasks whose outputs can be saved
comment|// this is currently a no-op
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|commitTasksList
init|=
name|getTasksToSave
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|commitTasksList
operator|!=
literal|null
condition|)
block|{
name|actions
operator|.
name|addAll
argument_list|(
name|commitTasksList
argument_list|)
expr_stmt|;
block|}
comment|// check the reduce tasks in this task-tracker, and add in the
comment|// AllMapTasksCompletedTaskAction for each of the reduce tasks
comment|// this enables the reduce tasks to move from shuffle to reduce phase
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|mapCompletionTasks
init|=
name|getMapCompletionTasks
argument_list|(
name|taskTrackerStatus
argument_list|,
name|killTasksList
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapCompletionTasks
operator|!=
literal|null
condition|)
block|{
name|actions
operator|.
name|addAll
argument_list|(
name|mapCompletionTasks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done with collection actions for tracker "
operator|+
name|trackerName
operator|+
literal|" for responseId "
operator|+
name|responseId
argument_list|)
expr_stmt|;
block|}
comment|// calculate next heartbeat interval and put in heartbeat response
name|int
name|nextInterval
init|=
name|getNextHeartbeatInterval
argument_list|()
decl_stmt|;
name|response
operator|.
name|setHeartbeatInterval
argument_list|(
name|nextInterval
argument_list|)
expr_stmt|;
name|response
operator|.
name|setActions
argument_list|(
name|actions
operator|.
name|toArray
argument_list|(
operator|new
name|TaskTrackerAction
index|[
name|actions
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Nextinterval for tracker "
operator|+
name|trackerName
operator|+
literal|" is "
operator|+
name|nextInterval
argument_list|)
expr_stmt|;
block|}
comment|// Update the trackerToHeartbeatResponseMap
name|trackerToHeartbeatResponseMap
operator|.
name|put
argument_list|(
name|trackerName
argument_list|,
name|response
argument_list|)
expr_stmt|;
comment|// Done processing the hearbeat, now remove 'marked' tasks
name|removeMarkedTasks
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
comment|/**    * The getMapCompletion method is intended to inform taskTrackes when to change the status    * of reduce tasks from "shuffle" to "reduce".    * For all reduce tasks in this TaskTracker that are    * in the shuffle phase, getMapCompletionTasks finds the number of finished maps for     * this job from the jobInProgress object. If this    * number equals the number of desired maps for this job, then it adds an     * AllMapsCompletedTaskAction for this reduce task-attempt.    *     * @param status    *            The status of the task tracker    * @return List of TaskTrackerActions    */
DECL|method|getMapCompletionTasks ( TaskTrackerStatus status, List<TaskTrackerAction> tasksToKill)
specifier|private
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|getMapCompletionTasks
parameter_list|(
name|TaskTrackerStatus
name|status
parameter_list|,
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|tasksToKill
parameter_list|)
block|{
name|boolean
name|loggingEnabled
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
comment|// Build up the list of tasks about to be killed
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|killedTasks
init|=
operator|new
name|HashSet
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|tasksToKill
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TaskTrackerAction
name|taskToKill
range|:
name|tasksToKill
control|)
block|{
name|killedTasks
operator|.
name|add
argument_list|(
operator|(
operator|(
name|KillTaskAction
operator|)
name|taskToKill
operator|)
operator|.
name|getTaskID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|trackerName
init|=
name|status
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TaskTrackerAction
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskTrackerAction
argument_list|>
argument_list|()
decl_stmt|;
comment|// loop through the list of task statuses
for|for
control|(
name|TaskStatus
name|report
range|:
name|status
operator|.
name|getTaskReports
argument_list|()
control|)
block|{
name|TaskAttemptID
name|taskAttemptId
init|=
name|report
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|SimulatorJobInProgress
name|job
init|=
name|getSimulatorJob
argument_list|(
name|taskAttemptId
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
comment|// This job has completed before.
comment|// and this is a zombie reduce-task
name|Set
argument_list|<
name|JobID
argument_list|>
name|jobsToCleanup
init|=
name|trackerToJobsToCleanup
operator|.
name|get
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|jobsToCleanup
operator|==
literal|null
condition|)
block|{
name|jobsToCleanup
operator|=
operator|new
name|HashSet
argument_list|<
name|JobID
argument_list|>
argument_list|()
expr_stmt|;
name|trackerToJobsToCleanup
operator|.
name|put
argument_list|(
name|trackerName
argument_list|,
name|jobsToCleanup
argument_list|)
expr_stmt|;
block|}
name|jobsToCleanup
operator|.
name|add
argument_list|(
name|taskAttemptId
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|JobStatus
name|jobStatus
init|=
name|job
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|TaskInProgress
name|tip
init|=
name|taskidToTIPMap
operator|.
name|get
argument_list|(
name|taskAttemptId
argument_list|)
decl_stmt|;
comment|// if the  job is running, attempt is running
comment|// no KillTask is being sent for this attempt
comment|// task is a reduce and attempt is in shuffle phase
comment|// this precludes sending both KillTask and AllMapsCompletion
comment|// for same reduce-attempt
if|if
condition|(
name|jobStatus
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
operator|&&
name|tip
operator|.
name|isRunningTask
argument_list|(
name|taskAttemptId
argument_list|)
operator|&&
operator|!
name|killedTasks
operator|.
name|contains
argument_list|(
name|taskAttemptId
argument_list|)
operator|&&
operator|!
name|report
operator|.
name|getIsMap
argument_list|()
operator|&&
name|report
operator|.
name|getPhase
argument_list|()
operator|==
name|TaskStatus
operator|.
name|Phase
operator|.
name|SHUFFLE
condition|)
block|{
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Need map-completion information for REDUCEattempt "
operator|+
name|taskAttemptId
operator|+
literal|" in tracker "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"getMapCompletion: job="
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|" pendingMaps="
operator|+
name|job
operator|.
name|pendingMaps
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Check whether the number of finishedMaps equals the
comment|// number of maps
name|boolean
name|canSendMapCompletion
init|=
literal|false
decl_stmt|;
name|canSendMapCompletion
operator|=
operator|(
name|job
operator|.
name|finishedMaps
argument_list|()
operator|==
name|job
operator|.
name|desiredMaps
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|canSendMapCompletion
condition|)
block|{
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding MapCompletion for taskAttempt "
operator|+
name|taskAttemptId
operator|+
literal|" in tracker "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"FinishedMaps for job:"
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|" is = "
operator|+
name|job
operator|.
name|finishedMaps
argument_list|()
operator|+
literal|"/"
operator|+
name|job
operator|.
name|desiredMaps
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"AllMapsCompleted for task "
operator|+
name|taskAttemptId
operator|+
literal|" time="
operator|+
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|actions
operator|.
name|add
argument_list|(
operator|new
name|AllMapsCompletedTaskAction
argument_list|(
name|taskAttemptId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|actions
return|;
block|}
annotation|@
name|Override
DECL|method|updateTaskStatuses (TaskTrackerStatus status)
name|void
name|updateTaskStatuses
parameter_list|(
name|TaskTrackerStatus
name|status
parameter_list|)
block|{
name|boolean
name|loggingEnabled
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
name|String
name|trackerName
init|=
name|status
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
comment|// loop through the list of task statuses
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating task statuses for tracker "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TaskStatus
name|report
range|:
name|status
operator|.
name|getTaskReports
argument_list|()
control|)
block|{
name|report
operator|.
name|setTaskTracker
argument_list|(
name|trackerName
argument_list|)
expr_stmt|;
name|TaskAttemptID
name|taskAttemptId
init|=
name|report
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|JobID
name|jobid
init|=
name|taskAttemptId
operator|.
name|getJobID
argument_list|()
decl_stmt|;
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating status for job "
operator|+
name|jobid
operator|+
literal|" for task = "
operator|+
name|taskAttemptId
operator|+
literal|" status="
operator|+
name|report
operator|.
name|getProgress
argument_list|()
operator|+
literal|" for tracker: "
operator|+
name|trackerName
argument_list|)
expr_stmt|;
block|}
name|SimulatorJobInProgress
name|job
init|=
name|getSimulatorJob
argument_list|(
name|taskAttemptId
operator|.
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
comment|// This job bas completed before.
name|Set
argument_list|<
name|JobID
argument_list|>
name|jobsToCleanup
init|=
name|trackerToJobsToCleanup
operator|.
name|get
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|jobsToCleanup
operator|==
literal|null
condition|)
block|{
name|jobsToCleanup
operator|=
operator|new
name|HashSet
argument_list|<
name|JobID
argument_list|>
argument_list|()
expr_stmt|;
name|trackerToJobsToCleanup
operator|.
name|put
argument_list|(
name|trackerName
argument_list|,
name|jobsToCleanup
argument_list|)
expr_stmt|;
block|}
name|jobsToCleanup
operator|.
name|add
argument_list|(
name|taskAttemptId
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TaskInProgress
name|tip
init|=
name|taskidToTIPMap
operator|.
name|get
argument_list|(
name|taskAttemptId
argument_list|)
decl_stmt|;
name|JobStatus
name|prevStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
name|job
operator|.
name|updateTaskStatus
argument_list|(
name|tip
argument_list|,
operator|(
name|TaskStatus
operator|)
name|report
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
name|JobStatus
name|newStatus
init|=
operator|(
name|JobStatus
operator|)
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|tip
operator|.
name|isComplete
argument_list|()
condition|)
block|{
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Completed task attempt "
operator|+
name|taskAttemptId
operator|+
literal|" tracker:"
operator|+
name|trackerName
operator|+
literal|" time="
operator|+
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prevStatus
operator|.
name|getRunState
argument_list|()
operator|!=
name|newStatus
operator|.
name|getRunState
argument_list|()
condition|)
block|{
if|if
condition|(
name|loggingEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Informing Listeners of job "
operator|+
name|jobid
operator|+
literal|" of newStatus "
operator|+
name|JobStatus
operator|.
name|getJobRunState
argument_list|(
name|newStatus
operator|.
name|getRunState
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|JobStatusChangeEvent
name|event
init|=
operator|new
name|JobStatusChangeEvent
argument_list|(
name|job
argument_list|,
name|EventType
operator|.
name|RUN_STATE_CHANGED
argument_list|,
name|prevStatus
argument_list|,
name|newStatus
argument_list|)
decl_stmt|;
name|updateJobInProgressListeners
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

