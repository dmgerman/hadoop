begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.streaming
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|streaming
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Counters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|MiniMRCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MapReduceTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|JTConfig
import|;
end_import

begin_comment
comment|/**  * Tests if mapper/reducer with empty/nonempty input works properly if  * reporting is done using lines like "reporter:status:" and  * "reporter:counter:" before map()/reduce() method is called.  * Validates the task's log of STDERR if messages are written to stderr before  * map()/reduce() is called.  * Also validates job output.  * Uses MiniMR since the local jobtracker doesn't track task status.   */
end_comment

begin_class
DECL|class|TestStreamingStatus
specifier|public
class|class
name|TestStreamingStatus
block|{
DECL|field|TEST_ROOT_DIR
specifier|protected
specifier|static
name|String
name|TEST_ROOT_DIR
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.build.data"
argument_list|,
literal|"/tmp"
argument_list|)
argument_list|,
name|TestStreamingStatus
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|toURI
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
literal|' '
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
DECL|field|INPUT_FILE
specifier|protected
name|String
name|INPUT_FILE
init|=
name|TEST_ROOT_DIR
operator|+
literal|"/input.txt"
decl_stmt|;
DECL|field|OUTPUT_DIR
specifier|protected
name|String
name|OUTPUT_DIR
init|=
name|TEST_ROOT_DIR
operator|+
literal|"/out"
decl_stmt|;
DECL|field|input
specifier|protected
name|String
name|input
init|=
literal|"roses.are.red\nviolets.are.blue\nbunnies.are.pink\n"
decl_stmt|;
DECL|field|map
specifier|protected
name|String
name|map
init|=
literal|null
decl_stmt|;
DECL|field|reduce
specifier|protected
name|String
name|reduce
init|=
literal|null
decl_stmt|;
DECL|field|scriptFile
specifier|protected
name|String
name|scriptFile
init|=
name|TEST_ROOT_DIR
operator|+
literal|"/perlScript.pl"
decl_stmt|;
DECL|field|scriptFileName
specifier|protected
name|String
name|scriptFileName
init|=
operator|new
name|Path
argument_list|(
name|scriptFile
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
DECL|field|expectedStderr
name|String
name|expectedStderr
init|=
literal|"my error msg before consuming input\n"
operator|+
literal|"my error msg after consuming input\n"
decl_stmt|;
DECL|field|expectedOutput
name|String
name|expectedOutput
init|=
literal|null
decl_stmt|;
comment|// inited in setUp()
DECL|field|expectedStatus
name|String
name|expectedStatus
init|=
literal|"before consuming input"
decl_stmt|;
comment|// This script does the following
comment|// (a) setting task status before reading input
comment|// (b) writing to stderr before reading input and after reading input
comment|// (c) writing to stdout before reading input
comment|// (d) incrementing user counter before reading input and after reading input
comment|// Write lines to stdout before reading input{(c) above} is to validate
comment|// the hanging task issue when input to task is empty(because of not starting
comment|// output thread).
DECL|field|script
specifier|protected
name|String
name|script
init|=
literal|"#!/usr/bin/perl\n"
operator|+
literal|"print STDERR \"reporter:status:"
operator|+
name|expectedStatus
operator|+
literal|"\\n\";\n"
operator|+
literal|"print STDERR \"reporter:counter:myOwnCounterGroup,myOwnCounter,1\\n\";\n"
operator|+
literal|"print STDERR \"my error msg before consuming input\\n\";\n"
operator|+
literal|"for($count = 1500; $count>= 1; $count--) {print STDOUT \"$count \";}"
operator|+
literal|"while(<STDIN>) {chomp;}\n"
operator|+
literal|"print STDERR \"my error msg after consuming input\\n\";\n"
operator|+
literal|"print STDERR \"reporter:counter:myOwnCounterGroup,myOwnCounter,1\\n\";\n"
decl_stmt|;
DECL|field|mr
name|MiniMRCluster
name|mr
init|=
literal|null
decl_stmt|;
DECL|field|fs
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
DECL|field|conf
name|JobConf
name|conf
init|=
literal|null
decl_stmt|;
comment|/**    * Start the cluster and create input file before running the actual test.    *    * @throws IOException    */
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|IOException
block|{
name|conf
operator|=
operator|new
name|JobConf
argument_list|()
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|JTConfig
operator|.
name|JT_RETIREJOBS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|JTConfig
operator|.
name|JT_PERSIST_JOBSTATUS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|mr
operator|=
operator|new
name|MiniMRCluster
argument_list|(
literal|1
argument_list|,
literal|"file:///"
argument_list|,
literal|3
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|Path
name|inFile
init|=
operator|new
name|Path
argument_list|(
name|INPUT_FILE
argument_list|)
decl_stmt|;
name|fs
operator|=
name|inFile
operator|.
name|getFileSystem
argument_list|(
name|mr
operator|.
name|createJobConf
argument_list|()
argument_list|)
expr_stmt|;
name|clean
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|buildExpectedJobOutput
argument_list|()
expr_stmt|;
block|}
comment|/**    * Kill the cluster after the test is done.    */
annotation|@
name|After
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
block|{
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
name|clean
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mr
operator|!=
literal|null
condition|)
block|{
name|mr
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Updates expectedOutput to have the expected job output as a string
DECL|method|buildExpectedJobOutput ()
name|void
name|buildExpectedJobOutput
parameter_list|()
block|{
if|if
condition|(
name|expectedOutput
operator|==
literal|null
condition|)
block|{
name|expectedOutput
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1500
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|expectedOutput
operator|=
name|expectedOutput
operator|.
name|concat
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
name|expectedOutput
operator|=
name|expectedOutput
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Create empty/nonempty input file.
comment|// Create script file with the specified content.
DECL|method|createInputAndScript (boolean isEmptyInput, String script)
specifier|protected
name|void
name|createInputAndScript
parameter_list|(
name|boolean
name|isEmptyInput
parameter_list|,
name|String
name|script
parameter_list|)
throws|throws
name|IOException
block|{
name|makeInput
argument_list|(
name|fs
argument_list|,
name|isEmptyInput
condition|?
literal|""
else|:
name|input
argument_list|)
expr_stmt|;
comment|// create script file
name|DataOutputStream
name|file
init|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|scriptFileName
argument_list|)
argument_list|)
decl_stmt|;
name|file
operator|.
name|writeBytes
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|genArgs (int jobtrackerPort, String mapper, String reducer)
specifier|protected
name|String
index|[]
name|genArgs
parameter_list|(
name|int
name|jobtrackerPort
parameter_list|,
name|String
name|mapper
parameter_list|,
name|String
name|reducer
parameter_list|)
block|{
return|return
operator|new
name|String
index|[]
block|{
literal|"-input"
block|,
name|INPUT_FILE
block|,
literal|"-output"
block|,
name|OUTPUT_DIR
block|,
literal|"-mapper"
block|,
name|mapper
block|,
literal|"-reducer"
block|,
name|reducer
block|,
literal|"-jobconf"
block|,
name|MRJobConfig
operator|.
name|NUM_MAPS
operator|+
literal|"=1"
block|,
literal|"-jobconf"
block|,
name|MRJobConfig
operator|.
name|NUM_REDUCES
operator|+
literal|"=1"
block|,
literal|"-jobconf"
block|,
name|MRJobConfig
operator|.
name|PRESERVE_FAILED_TASK_FILES
operator|+
literal|"=true"
block|,
literal|"-jobconf"
block|,
literal|"stream.tmpdir="
operator|+
operator|new
name|Path
argument_list|(
name|TEST_ROOT_DIR
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
block|,
literal|"-jobconf"
block|,
name|JTConfig
operator|.
name|JT_IPC_ADDRESS
operator|+
literal|"=localhost:"
operator|+
name|jobtrackerPort
block|,
literal|"-jobconf"
block|,
literal|"fs.default.name=file:///"
block|}
return|;
block|}
comment|// create input file with the given content
DECL|method|makeInput (FileSystem fs, String input)
specifier|public
name|void
name|makeInput
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|String
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|inFile
init|=
operator|new
name|Path
argument_list|(
name|INPUT_FILE
argument_list|)
decl_stmt|;
name|DataOutputStream
name|file
init|=
name|fs
operator|.
name|create
argument_list|(
name|inFile
argument_list|)
decl_stmt|;
name|file
operator|.
name|writeBytes
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Delete output directory
DECL|method|deleteOutDir (FileSystem fs)
specifier|protected
name|void
name|deleteOutDir
parameter_list|(
name|FileSystem
name|fs
parameter_list|)
block|{
try|try
block|{
name|Path
name|outDir
init|=
operator|new
name|Path
argument_list|(
name|OUTPUT_DIR
argument_list|)
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|outDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
comment|// Delete input file, script file and output directory
DECL|method|clean (FileSystem fs)
specifier|public
name|void
name|clean
parameter_list|(
name|FileSystem
name|fs
parameter_list|)
block|{
name|deleteOutDir
argument_list|(
name|fs
argument_list|)
expr_stmt|;
try|try
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|INPUT_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|file
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
operator|new
name|Path
argument_list|(
name|scriptFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|file
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check if mapper/reducer with empty/nonempty input works properly if    * reporting is done using lines like "reporter:status:" and    * "reporter:counter:" before map()/reduce() method is called.    * Validate the task's log of STDERR if messages are written    * to stderr before map()/reduce() is called.    * Also validate job output.    *    * @throws IOException    */
annotation|@
name|Test
DECL|method|testReporting ()
specifier|public
name|void
name|testReporting
parameter_list|()
throws|throws
name|Exception
block|{
name|testStreamJob
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// nonempty input
name|testStreamJob
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// empty input
block|}
comment|/**    * Run a streaming job with the given script as mapper and validate.    * Run another streaming job with the given script as reducer and validate.    *    * @param isEmptyInput Should the input to the script be empty ?    * @param script The content of the script that will run as the streaming task    */
DECL|method|testStreamJob (boolean isEmptyInput)
specifier|private
name|void
name|testStreamJob
parameter_list|(
name|boolean
name|isEmptyInput
parameter_list|)
throws|throws
name|IOException
block|{
name|createInputAndScript
argument_list|(
name|isEmptyInput
argument_list|,
name|script
argument_list|)
expr_stmt|;
comment|// Check if streaming mapper works as expected
name|map
operator|=
name|scriptFileName
expr_stmt|;
name|reduce
operator|=
literal|"/bin/cat"
expr_stmt|;
name|runStreamJob
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|,
name|isEmptyInput
argument_list|)
expr_stmt|;
name|deleteOutDir
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|// Check if streaming reducer works as expected.
name|map
operator|=
literal|"/bin/cat"
expr_stmt|;
name|reduce
operator|=
name|scriptFileName
expr_stmt|;
name|runStreamJob
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|,
name|isEmptyInput
argument_list|)
expr_stmt|;
name|clean
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
comment|// Run streaming job for the specified input file, mapper and reducer and
comment|// (1) Validate if the job succeeds.
comment|// (2) Validate if user counter is incremented properly for the cases of
comment|//   (a) nonempty input to map
comment|//   (b) empty input to map and
comment|//   (c) nonempty input to reduce
comment|// (3) Validate task status for the cases of (2)(a),(2)(b),(2)(c).
comment|//     Because empty input to reduce task => reporter is dummy and ignores
comment|//     all "reporter:status" and "reporter:counter" lines.
comment|// (4) Validate stderr of task of given task type.
comment|// (5) Validate job output
DECL|method|runStreamJob (TaskType type, boolean isEmptyInput)
name|void
name|runStreamJob
parameter_list|(
name|TaskType
name|type
parameter_list|,
name|boolean
name|isEmptyInput
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|mayExit
init|=
literal|false
decl_stmt|;
name|StreamJob
name|job
init|=
operator|new
name|StreamJob
argument_list|(
name|genArgs
argument_list|(
name|mr
operator|.
name|getJobTrackerPort
argument_list|()
argument_list|,
name|map
argument_list|,
name|reduce
argument_list|)
argument_list|,
name|mayExit
argument_list|)
decl_stmt|;
name|int
name|returnValue
init|=
name|job
operator|.
name|go
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|returnValue
argument_list|)
expr_stmt|;
comment|// If input to reducer is empty, dummy reporter(which ignores all
comment|// reporting lines) is set for MRErrorThread in waitOutputThreads(). So
comment|// expectedCounterValue is 0 for empty-input-to-reducer case.
comment|// Output of reducer is also empty for empty-input-to-reducer case.
name|int
name|expectedCounterValue
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
operator|||
operator|!
name|isEmptyInput
condition|)
block|{
name|validateTaskStatus
argument_list|(
name|job
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|// output is from "print STDOUT" statements in perl script
name|validateJobOutput
argument_list|(
name|job
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|expectedCounterValue
operator|=
literal|2
expr_stmt|;
block|}
name|validateUserCounter
argument_list|(
name|job
argument_list|,
name|expectedCounterValue
argument_list|)
expr_stmt|;
name|validateTaskStderr
argument_list|(
name|job
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|deleteOutDir
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
comment|// validate task status of task of given type(validates 1st task of that type)
DECL|method|validateTaskStatus (StreamJob job, TaskType type)
name|void
name|validateTaskStatus
parameter_list|(
name|StreamJob
name|job
parameter_list|,
name|TaskType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Map Task has 2 phases: map, sort
comment|// Reduce Task has 3 phases: copy, sort, reduce
name|String
name|finalPhaseInTask
decl_stmt|;
name|TaskReport
index|[]
name|reports
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
name|reports
operator|=
name|job
operator|.
name|jc_
operator|.
name|getMapTaskReports
argument_list|(
name|job
operator|.
name|jobId_
argument_list|)
expr_stmt|;
name|finalPhaseInTask
operator|=
literal|"sort"
expr_stmt|;
block|}
else|else
block|{
comment|// reduce task
name|reports
operator|=
name|job
operator|.
name|jc_
operator|.
name|getReduceTaskReports
argument_list|(
name|job
operator|.
name|jobId_
argument_list|)
expr_stmt|;
name|finalPhaseInTask
operator|=
literal|"reduce"
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|reports
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedStatus
operator|+
literal|"> "
operator|+
name|finalPhaseInTask
argument_list|,
name|reports
index|[
literal|0
index|]
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Validate the job output
DECL|method|validateJobOutput (Configuration conf)
name|void
name|validateJobOutput
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|output
init|=
name|MapReduceTestUtil
operator|.
name|readOutput
argument_list|(
operator|new
name|Path
argument_list|(
name|OUTPUT_DIR
argument_list|)
argument_list|,
name|conf
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|output
operator|.
name|equals
argument_list|(
name|expectedOutput
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Validate stderr task log of given task type(validates 1st
comment|// task of that type).
DECL|method|validateTaskStderr (StreamJob job, TaskType type)
name|void
name|validateTaskStderr
parameter_list|(
name|StreamJob
name|job
parameter_list|,
name|TaskType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskAttemptID
name|attemptId
init|=
operator|new
name|TaskAttemptID
argument_list|(
operator|new
name|TaskID
argument_list|(
name|job
operator|.
name|jobId_
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|String
name|log
init|=
name|MapReduceTestUtil
operator|.
name|readTaskLog
argument_list|(
name|TaskLog
operator|.
name|LogName
operator|.
name|STDERR
argument_list|,
name|attemptId
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// trim() is called on expectedStderr here because the method
comment|// MapReduceTestUtil.readTaskLog() returns trimmed String.
name|assertTrue
argument_list|(
name|log
operator|.
name|equals
argument_list|(
name|expectedStderr
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Validate if user counter is incremented properly
DECL|method|validateUserCounter (StreamJob job, int expectedCounterValue)
name|void
name|validateUserCounter
parameter_list|(
name|StreamJob
name|job
parameter_list|,
name|int
name|expectedCounterValue
parameter_list|)
throws|throws
name|IOException
block|{
name|Counters
name|counters
init|=
name|job
operator|.
name|running_
operator|.
name|getCounters
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedCounterValue
argument_list|,
name|counters
operator|.
name|findCounter
argument_list|(
literal|"myOwnCounterGroup"
argument_list|,
literal|"myOwnCounter"
argument_list|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

