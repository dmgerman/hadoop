begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobQueueJobInProgressListener
operator|.
name|JobSchedulingInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * This class asynchronously initializes jobs submitted to the  * Map/Reduce cluster running with the {@link CapacityTaskScheduler}.  *  *<p>  * The class comprises of a main poller thread, and a set of worker  * threads that together initialize the jobs. The poller thread periodically  * looks at jobs submitted to the scheduler, and selects a set of them  * to be initialized. It passes these to the worker threads for initializing.  * Each worker thread is configured to look at jobs submitted to a fixed  * set of queues. It initializes jobs in a round robin manner - selecting  * the first job in order from each queue ready to be initialized.  *</p>  *   *<p>  * An initialized job occupies memory resources on the Job Tracker. Hence,  * the poller limits the number of jobs initialized at any given time to  * a configured limit. The limit is specified per user per queue.  *</p>  *   *<p>  * However, since a job needs to be initialized before the scheduler can  * select tasks from it to run, it tries to keep a backlog of jobs   * initialized so the scheduler does not need to wait and let empty slots  * go waste. The core logic of the poller is to pick up the right jobs,  * which have a good potential to be run next by the scheduler. To do this,  * it picks up jobs submitted across users and across queues to account  * both for guaranteed capacities and user limits. It also always initializes  * high priority jobs, whenever they need to be initialized, even if this  * means going over the limit for initialized jobs.  *</p>  */
end_comment

begin_class
DECL|class|JobInitializationPoller
specifier|public
class|class
name|JobInitializationPoller
extends|extends
name|Thread
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|JobInitializationPoller
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/*    * The poller picks up jobs across users to initialize based on user limits.    * Suppose the user limit for a queue is 25%, it means atmost 4 users' jobs    * can run together. However, in order to account for jobs from a user that    * might complete faster than others, it initializes jobs from an additional    * number of users as a backlog. This variable defines the additional    * number of users whose jobs can be considered for initializing.     */
DECL|field|MAX_ADDITIONAL_USERS_TO_INIT
specifier|private
specifier|static
specifier|final
name|int
name|MAX_ADDITIONAL_USERS_TO_INIT
init|=
literal|2
decl_stmt|;
DECL|field|jobQueueManager
specifier|private
name|JobQueuesManager
name|jobQueueManager
decl_stmt|;
DECL|field|sleepInterval
specifier|private
name|long
name|sleepInterval
decl_stmt|;
DECL|field|poolSize
specifier|private
name|int
name|poolSize
decl_stmt|;
comment|/**    * A worker thread that initializes jobs in one or more queues assigned to    * it.    *    * Jobs are initialized in a round robin fashion one from each queue at a    * time.    */
DECL|class|JobInitializationThread
class|class
name|JobInitializationThread
extends|extends
name|Thread
block|{
DECL|field|initializingJob
specifier|private
name|JobInProgress
name|initializingJob
decl_stmt|;
DECL|field|startIniting
specifier|private
specifier|volatile
name|boolean
name|startIniting
decl_stmt|;
DECL|field|currentJobCount
specifier|private
name|AtomicInteger
name|currentJobCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// number of jobs to initialize
comment|/**      * The hash map which maintains relationship between queue to jobs to      * initialize per queue.      */
DECL|field|jobsPerQueue
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|TreeMap
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
argument_list|>
name|jobsPerQueue
decl_stmt|;
DECL|method|JobInitializationThread ()
specifier|public
name|JobInitializationThread
parameter_list|()
block|{
name|startIniting
operator|=
literal|true
expr_stmt|;
name|jobsPerQueue
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TreeMap
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|startIniting
condition|)
block|{
name|initializeJobs
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|startIniting
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepInterval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{         }
block|}
block|}
comment|// The key method that initializes jobs from queues
comment|// This method is package-private to allow test cases to call it
comment|// synchronously in a controlled manner.
DECL|method|initializeJobs ()
name|void
name|initializeJobs
parameter_list|()
block|{
comment|// while there are more jobs to initialize...
while|while
condition|(
name|currentJobCount
operator|.
name|get
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|queues
init|=
name|jobsPerQueue
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|queue
range|:
name|queues
control|)
block|{
name|JobInProgress
name|job
init|=
name|getFirstJobInQueue
argument_list|(
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing job : "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|" in AbstractQueue "
operator|+
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" For user : "
operator|+
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|startIniting
condition|)
block|{
name|setInitializingJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|ttm
operator|.
name|initJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|setInitializingJob
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
block|}
comment|/**      * This method returns the first job in the queue and removes the same.      *       * @param queue      *          queue name      * @return First job in the queue and removes it.      */
DECL|method|getFirstJobInQueue (String queue)
specifier|private
name|JobInProgress
name|getFirstJobInQueue
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|TreeMap
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
name|jobsList
init|=
name|jobsPerQueue
operator|.
name|get
argument_list|(
name|queue
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|jobsList
init|)
block|{
if|if
condition|(
name|jobsList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Iterator
argument_list|<
name|JobInProgress
argument_list|>
name|jobIterator
init|=
name|jobsList
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|JobInProgress
name|job
init|=
name|jobIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|jobIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|currentJobCount
operator|.
name|getAndDecrement
argument_list|()
expr_stmt|;
return|return
name|job
return|;
block|}
block|}
comment|/*      * Test method to check if the thread is currently initialising the job      */
DECL|method|getInitializingJob ()
specifier|synchronized
name|JobInProgress
name|getInitializingJob
parameter_list|()
block|{
return|return
name|this
operator|.
name|initializingJob
return|;
block|}
DECL|method|setInitializingJob (JobInProgress job)
specifier|synchronized
name|void
name|setInitializingJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
name|this
operator|.
name|initializingJob
operator|=
name|job
expr_stmt|;
block|}
DECL|method|terminate ()
name|void
name|terminate
parameter_list|()
block|{
name|startIniting
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|addJobsToQueue (String queue, JobInProgress job)
name|void
name|addJobsToQueue
parameter_list|(
name|String
name|queue
parameter_list|,
name|JobInProgress
name|job
parameter_list|)
block|{
name|TreeMap
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
name|jobs
init|=
name|jobsPerQueue
operator|.
name|get
argument_list|(
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|jobs
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid queue passed to the thread : "
operator|+
name|queue
operator|+
literal|" For job :: "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|jobs
init|)
block|{
name|JobSchedulingInfo
name|schedInfo
init|=
operator|new
name|JobSchedulingInfo
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|jobs
operator|.
name|put
argument_list|(
name|schedInfo
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|currentJobCount
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addQueue (String queue)
name|void
name|addQueue
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|TreeMap
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
name|jobs
init|=
operator|new
name|TreeMap
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
argument_list|(
name|jobQueueManager
operator|.
name|getComparator
argument_list|(
name|queue
argument_list|)
argument_list|)
decl_stmt|;
name|jobsPerQueue
operator|.
name|put
argument_list|(
name|queue
argument_list|,
name|jobs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The queue information class maintains following information per queue:    * Maximum users allowed to initialize job in the particular queue. Maximum    * jobs allowed to be initialize per user in the queue.    *     */
DECL|class|QueueInfo
specifier|private
specifier|static
class|class
name|QueueInfo
block|{
DECL|field|maxUsersAllowedToInitialize
name|int
name|maxUsersAllowedToInitialize
decl_stmt|;
DECL|field|maxJobsPerUserToInitialize
name|int
name|maxJobsPerUserToInitialize
decl_stmt|;
DECL|method|QueueInfo (int maxUsersAllowedToInitialize, int maxJobsPerUserToInitialize)
specifier|public
name|QueueInfo
parameter_list|(
name|int
name|maxUsersAllowedToInitialize
parameter_list|,
name|int
name|maxJobsPerUserToInitialize
parameter_list|)
block|{
name|this
operator|.
name|maxJobsPerUserToInitialize
operator|=
name|maxJobsPerUserToInitialize
expr_stmt|;
name|this
operator|.
name|maxUsersAllowedToInitialize
operator|=
name|maxUsersAllowedToInitialize
expr_stmt|;
block|}
block|}
comment|/**    * Map which contains the configuration used for initializing jobs    * in that associated to a particular job queue.    */
DECL|field|jobQueues
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|QueueInfo
argument_list|>
name|jobQueues
decl_stmt|;
comment|/**    * Set of jobs which have been passed to Initialization threads.    * This is maintained so that we dont call initTasks() for same job twice.    */
DECL|field|initializedJobs
specifier|private
name|HashMap
argument_list|<
name|JobID
argument_list|,
name|JobInProgress
argument_list|>
name|initializedJobs
decl_stmt|;
DECL|field|running
specifier|private
specifier|volatile
name|boolean
name|running
decl_stmt|;
DECL|field|ttm
specifier|private
name|TaskTrackerManager
name|ttm
decl_stmt|;
comment|/**    * The map which provides information which thread should be used to    * initialize jobs for a given job queue.    */
DECL|field|threadsToQueueMap
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|JobInitializationThread
argument_list|>
name|threadsToQueueMap
decl_stmt|;
DECL|method|JobInitializationPoller ( JobQueuesManager mgr, TaskTrackerManager ttm)
specifier|public
name|JobInitializationPoller
parameter_list|(
name|JobQueuesManager
name|mgr
parameter_list|,
name|TaskTrackerManager
name|ttm
parameter_list|)
block|{
name|initializedJobs
operator|=
operator|new
name|HashMap
argument_list|<
name|JobID
argument_list|,
name|JobInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|jobQueues
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|QueueInfo
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|jobQueueManager
operator|=
name|mgr
expr_stmt|;
name|threadsToQueueMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|JobInitializationThread
argument_list|>
argument_list|()
expr_stmt|;
name|super
operator|.
name|setName
argument_list|(
literal|"JobInitializationPollerThread"
argument_list|)
expr_stmt|;
name|running
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|ttm
operator|=
name|ttm
expr_stmt|;
block|}
comment|/*    * method to read all configuration values required by the initialisation    * poller    */
DECL|method|init (Set<String> queues, CapacitySchedulerConf capacityConf)
name|void
name|init
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|queues
parameter_list|,
name|CapacitySchedulerConf
name|capacityConf
parameter_list|)
block|{
name|setupJobInitializerConfiguration
argument_list|(
name|queues
argument_list|,
name|capacityConf
argument_list|)
expr_stmt|;
name|assignThreadsToQueues
argument_list|()
expr_stmt|;
name|Collection
argument_list|<
name|JobInitializationThread
argument_list|>
name|threads
init|=
name|threadsToQueueMap
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|JobInitializationThread
name|t
range|:
name|threads
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Initialize the configuration of the JobInitializer as well as of the specific    * queues.    *     * @param queues    * @param schedulerConf    */
DECL|method|setupJobInitializerConfiguration (Set<String> queues, CapacitySchedulerConf schedulerConf)
specifier|private
name|void
name|setupJobInitializerConfiguration
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|queues
parameter_list|,
name|CapacitySchedulerConf
name|schedulerConf
parameter_list|)
block|{
for|for
control|(
name|String
name|queue
range|:
name|queues
control|)
block|{
name|int
name|maxUsersToInitialize
init|=
name|getMaxUsersToInit
argument_list|(
name|schedulerConf
argument_list|,
name|queue
argument_list|)
decl_stmt|;
name|int
name|maxJobsPerUserToInitialize
init|=
name|schedulerConf
operator|.
name|getMaxJobsPerUserToInitialize
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|QueueInfo
name|qi
init|=
operator|new
name|QueueInfo
argument_list|(
name|maxUsersToInitialize
argument_list|,
name|maxJobsPerUserToInitialize
argument_list|)
decl_stmt|;
name|jobQueues
operator|.
name|put
argument_list|(
name|queue
argument_list|,
name|qi
argument_list|)
expr_stmt|;
block|}
name|sleepInterval
operator|=
name|schedulerConf
operator|.
name|getSleepInterval
argument_list|()
expr_stmt|;
name|poolSize
operator|=
name|schedulerConf
operator|.
name|getMaxWorkerThreads
argument_list|()
expr_stmt|;
if|if
condition|(
name|poolSize
operator|>
name|queues
operator|.
name|size
argument_list|()
condition|)
block|{
name|poolSize
operator|=
name|queues
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    *     * @param schedulerConf    * @param queue    * @return    */
DECL|method|getMaxUsersToInit (CapacitySchedulerConf schedulerConf, String queue)
specifier|private
name|int
name|getMaxUsersToInit
parameter_list|(
name|CapacitySchedulerConf
name|schedulerConf
parameter_list|,
name|String
name|queue
parameter_list|)
block|{
name|int
name|userlimit
init|=
name|schedulerConf
operator|.
name|getMinimumUserLimitPercent
argument_list|(
name|queue
argument_list|)
decl_stmt|;
return|return
operator|(
literal|100
operator|/
name|userlimit
operator|)
operator|+
name|MAX_ADDITIONAL_USERS_TO_INIT
return|;
block|}
comment|/**    * Refresh the Scheduler configuration cached with the initializer. This    * should be called only by    * {@link CapacityTaskScheduler.CapacitySchedulerQueueRefresher#refreshQueues()}    * . The cached configuration currently is only used by the main thread in the    * initializer. So, any updates are picked up automatically by subsequent    * iterations of the main thread.    */
DECL|method|refreshQueueInfo (CapacitySchedulerConf schedulerConf)
name|void
name|refreshQueueInfo
parameter_list|(
name|CapacitySchedulerConf
name|schedulerConf
parameter_list|)
block|{
for|for
control|(
name|String
name|queue
range|:
name|jobQueues
operator|.
name|keySet
argument_list|()
control|)
block|{
name|QueueInfo
name|queueInfo
init|=
name|jobQueues
operator|.
name|get
argument_list|(
name|queue
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|queueInfo
init|)
block|{
name|queueInfo
operator|.
name|maxUsersAllowedToInitialize
operator|=
name|getMaxUsersToInit
argument_list|(
name|schedulerConf
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|maxJobsPerUserToInitialize
operator|=
name|schedulerConf
operator|.
name|getMaxJobsPerUserToInitialize
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * This is main thread of initialization poller, We essentially do     * following in the main threads:    *     *<ol>    *<li> Clean up the list of initialized jobs list which poller maintains    *</li>    *<li> Select jobs to initialize in the polling interval.</li>    *</ol>    */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|cleanUpInitializedJobsList
argument_list|()
expr_stmt|;
name|selectJobsToInitialize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepInterval
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Job Initialization poller interrupted"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The key method which does selecting jobs to be initalized across     * queues and assign those jobs to their appropriate init-worker threads.    *<br/>    * This method is overriden in test case which is used to test job    * initialization poller.    *     */
DECL|method|selectJobsToInitialize ()
name|void
name|selectJobsToInitialize
parameter_list|()
block|{
for|for
control|(
name|String
name|queue
range|:
name|jobQueues
operator|.
name|keySet
argument_list|()
control|)
block|{
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
name|jobsToInitialize
init|=
name|getJobsToInitialize
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|printJobs
argument_list|(
name|jobsToInitialize
argument_list|)
expr_stmt|;
name|JobInitializationThread
name|t
init|=
name|threadsToQueueMap
operator|.
name|get
argument_list|(
name|queue
argument_list|)
decl_stmt|;
for|for
control|(
name|JobInProgress
name|job
range|:
name|jobsToInitialize
control|)
block|{
name|t
operator|.
name|addJobsToQueue
argument_list|(
name|queue
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Method used to print log statements about which jobs are being    * passed to init-threads.     *     * @param jobsToInitialize list of jobs which are passed to be     * init-threads.    */
DECL|method|printJobs (ArrayList<JobInProgress> jobsToInitialize)
specifier|private
name|void
name|printJobs
parameter_list|(
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
name|jobsToInitialize
parameter_list|)
block|{
for|for
control|(
name|JobInProgress
name|job
range|:
name|jobsToInitialize
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Passing to Initializer Job Id :"
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|" User: "
operator|+
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
operator|+
literal|" AbstractQueue : "
operator|+
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method exists to be overridden by test cases that wish to    * create a test-friendly worker thread which can be controlled    * synchronously.    *     * @return Instance of worker init-threads.    */
DECL|method|createJobInitializationThread ()
name|JobInitializationThread
name|createJobInitializationThread
parameter_list|()
block|{
return|return
operator|new
name|JobInitializationThread
argument_list|()
return|;
block|}
comment|/**    * Method which is used by the poller to assign appropriate worker thread    * to a queue. The number of threads would be always less than or equal    * to number of queues in a system. If number of threads is configured to     * be more than number of queues then poller does not create threads more    * than number of queues.     *     */
DECL|method|assignThreadsToQueues ()
specifier|private
name|void
name|assignThreadsToQueues
parameter_list|()
block|{
name|int
name|countOfQueues
init|=
name|jobQueues
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
index|[]
name|queues
init|=
operator|(
name|String
index|[]
operator|)
name|jobQueues
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|countOfQueues
index|]
argument_list|)
decl_stmt|;
name|int
name|numberOfQueuesPerThread
init|=
name|countOfQueues
operator|/
name|poolSize
decl_stmt|;
name|int
name|numberOfQueuesAssigned
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|poolSize
condition|;
name|i
operator|++
control|)
block|{
name|JobInitializationThread
name|initializer
init|=
name|createJobInitializationThread
argument_list|()
decl_stmt|;
name|int
name|batch
init|=
operator|(
name|i
operator|*
name|numberOfQueuesPerThread
operator|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|batch
init|;
name|j
operator|<
operator|(
name|batch
operator|+
name|numberOfQueuesPerThread
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|initializer
operator|.
name|addQueue
argument_list|(
name|queues
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|threadsToQueueMap
operator|.
name|put
argument_list|(
name|queues
index|[
name|j
index|]
argument_list|,
name|initializer
argument_list|)
expr_stmt|;
name|numberOfQueuesAssigned
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numberOfQueuesAssigned
operator|<
name|countOfQueues
condition|)
block|{
comment|// Assign remaining queues in round robin fashion to other queues
name|int
name|startIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|numberOfQueuesAssigned
init|;
name|i
operator|<
name|countOfQueues
condition|;
name|i
operator|++
control|)
block|{
name|JobInitializationThread
name|t
init|=
name|threadsToQueueMap
operator|.
name|get
argument_list|(
name|queues
index|[
name|startIndex
index|]
argument_list|)
decl_stmt|;
name|t
operator|.
name|addQueue
argument_list|(
name|queues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|threadsToQueueMap
operator|.
name|put
argument_list|(
name|queues
index|[
name|i
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|startIndex
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/**    *     * Method used to select jobs to be initialized for a given queue.<br/>    *     * We want to ensure that enough jobs have been initialized, so that when the    * Scheduler wants to consider a new job to run, it's ready. We clearly don't    * want to initialize too many jobs as each initialized job has a memory    * footprint, sometimes significant.    *     * Number of jobs to be initialized is restricted by two values: - Maximum    * number of users whose jobs we want to initialize, which is equal to     * the number of concurrent users the queue can support. - Maximum number     * of initialized jobs per user. The product of these two gives us the    * total number of initialized jobs.    *     * Note that this is a rough number, meant for decreasing extra memory    * footprint. It's OK if we go over it once in a while, if we have to.    *     * This can happen as follows. Suppose we have initialized 3 jobs for a    * user. Now, suppose the user submits a job who's priority is higher than    * that of the 3 jobs initialized. This job needs to be initialized, since it    * will run earlier than the 3 jobs. We'll now have 4 initialized jobs for the    * user. If memory becomes a problem, we should ideally un-initialize one of    * the 3 jobs, to keep the count of initialized jobs at 3, but that's    * something we don't do for now. This situation can also arise when a new    * user submits a high priority job, thus superceeding a user whose jobs have    * already been initialized. The latter user's initialized jobs are redundant,    * but we'll leave them initialized.    *     * @param queue name of the queue to pick the jobs to initialize.    * @return list of jobs to be initalized in a queue. An empty queue is    *         returned if no jobs are found.    */
DECL|method|getJobsToInitialize (String queue)
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
name|getJobsToInitialize
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|QueueInfo
name|qi
init|=
name|jobQueues
operator|.
name|get
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
name|jobsToInitialize
init|=
operator|new
name|ArrayList
argument_list|<
name|JobInProgress
argument_list|>
argument_list|()
decl_stmt|;
comment|// use the configuration parameter which is configured for the particular
comment|// queue.
name|int
name|maximumUsersAllowedToInitialize
decl_stmt|;
name|int
name|maxJobsPerUserAllowedToInitialize
decl_stmt|;
synchronized|synchronized
init|(
name|qi
init|)
block|{
name|maximumUsersAllowedToInitialize
operator|=
name|qi
operator|.
name|maxUsersAllowedToInitialize
expr_stmt|;
name|maxJobsPerUserAllowedToInitialize
operator|=
name|qi
operator|.
name|maxJobsPerUserToInitialize
expr_stmt|;
block|}
name|int
name|maxJobsPerQueueToInitialize
init|=
name|maximumUsersAllowedToInitialize
operator|*
name|maxJobsPerUserAllowedToInitialize
decl_stmt|;
name|int
name|countOfJobsInitialized
init|=
literal|0
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|userJobsInitialized
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|jobs
init|=
name|jobQueueManager
operator|.
name|getJobQueue
argument_list|(
name|queue
argument_list|)
operator|.
name|getWaitingJobs
argument_list|()
decl_stmt|;
comment|/*      * Walk through the collection of waiting jobs.      *  We maintain a map of jobs that have already been initialized. If a       *  job exists in that map, increment the count for that job's user       *  and move on to the next job.      *         *  If the job doesn't exist, see whether we  want to initialize it.       *  We initialize it if: - at least one job of the user has already       *  been initialized, but the user's total initialized jobs are below       *  the limit, OR - this is a new user, and we haven't reached the limit      *  for the number of users whose jobs we want to initialize. We break       *  when we've reached the limit of maximum jobs to initialize.      */
for|for
control|(
name|JobInProgress
name|job
range|:
name|jobs
control|)
block|{
name|String
name|user
init|=
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|int
name|numberOfJobs
init|=
name|userJobsInitialized
operator|.
name|get
argument_list|(
name|user
argument_list|)
operator|==
literal|null
condition|?
literal|0
else|:
name|userJobsInitialized
operator|.
name|get
argument_list|(
name|user
argument_list|)
decl_stmt|;
comment|// If the job is already initialized then add the count against user
comment|// then continue.
if|if
condition|(
name|initializedJobs
operator|.
name|containsKey
argument_list|(
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
condition|)
block|{
name|userJobsInitialized
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|numberOfJobs
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|countOfJobsInitialized
operator|++
expr_stmt|;
continue|continue;
block|}
name|boolean
name|isUserPresent
init|=
name|userJobsInitialized
operator|.
name|containsKey
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isUserPresent
operator|&&
name|userJobsInitialized
operator|.
name|size
argument_list|()
operator|<
name|maximumUsersAllowedToInitialize
condition|)
block|{
comment|// this is a new user being considered and the number of users
comment|// is within limits.
name|userJobsInitialized
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|numberOfJobs
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jobsToInitialize
operator|.
name|add
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|initializedJobs
operator|.
name|put
argument_list|(
name|job
operator|.
name|getJobID
argument_list|()
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|countOfJobsInitialized
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isUserPresent
operator|&&
name|numberOfJobs
operator|<
name|maxJobsPerUserAllowedToInitialize
condition|)
block|{
name|userJobsInitialized
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|numberOfJobs
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|jobsToInitialize
operator|.
name|add
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|initializedJobs
operator|.
name|put
argument_list|(
name|job
operator|.
name|getJobID
argument_list|()
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|countOfJobsInitialized
operator|++
expr_stmt|;
block|}
comment|/*        * if the maximum number of jobs to initalize for a queue is reached        * then we stop looking at further jobs. The jobs beyond this number        * can be initialized.        */
if|if
condition|(
name|countOfJobsInitialized
operator|>
name|maxJobsPerQueueToInitialize
condition|)
block|{
break|break;
block|}
block|}
return|return
name|jobsToInitialize
return|;
block|}
comment|/**    * Method which is used internally to clean up the initialized jobs    * data structure which the job initialization poller uses to check    * if a job is initalized or not.    *     * Algorithm for cleaning up task is as follows:    *     *<ul>    *<li> For jobs in<b>initalizedJobs</b> list</li>    *<ul>    *<li> If job is running</li>    *<ul>    *<li> If job is scheduled then remove the job from the waiting queue     * of the scheduler and<b>initalizedJobs</b>.<br/>    *  The check for a job is scheduled or not is done by following     *  formulae:<br/>     *  if pending<i>task</i>&lt; desired<i>task</i> then scheduled else    *  not scheduled.<br/>    *  The formulae would return<i>scheduled</i> if one task has run or failed,    *  any cases in which there has been a failure but not enough to mark task     *  as failed, we return<i>not scheduled</i> in formulae.    *</li>    *</ul>    *     *<li> If job is complete, then remove the job from<b>initalizedJobs</b>.    *</li>    *     *</ul>    *</ul>    *     */
DECL|method|cleanUpInitializedJobsList ()
name|void
name|cleanUpInitializedJobsList
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|JobID
argument_list|,
name|JobInProgress
argument_list|>
argument_list|>
name|jobsIterator
init|=
name|initializedJobs
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|jobsIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|JobID
argument_list|,
name|JobInProgress
argument_list|>
name|entry
init|=
name|jobsIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|JobInProgress
name|job
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
if|if
condition|(
name|isScheduled
argument_list|(
name|job
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing scheduled jobs from waiting queue"
operator|+
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|jobsIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|jobQueueManager
operator|.
name|getJobQueue
argument_list|(
name|job
argument_list|)
operator|.
name|removeWaitingJob
argument_list|(
operator|new
name|JobSchedulingInfo
argument_list|(
name|job
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|job
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing killed/completed job from initalized jobs "
operator|+
literal|"list : "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|jobsIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Convenience method to check if job has been scheduled or not.    *     * The method may return false in case of job which has failure but    * has not failed the tip.    * @param job    * @return    */
DECL|method|isScheduled (JobInProgress job)
specifier|private
name|boolean
name|isScheduled
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
return|return
operator|(
operator|(
name|job
operator|.
name|pendingMaps
argument_list|()
operator|<
name|job
operator|.
name|desiredMaps
argument_list|()
operator|)
operator|||
operator|(
name|job
operator|.
name|pendingReduces
argument_list|()
operator|<
name|job
operator|.
name|desiredReduces
argument_list|()
operator|)
operator|)
return|;
block|}
DECL|method|terminate ()
name|void
name|terminate
parameter_list|()
block|{
name|running
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|JobInitializationThread
argument_list|>
name|entry
range|:
name|threadsToQueueMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|JobInitializationThread
name|t
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|t
operator|.
name|terminate
argument_list|()
expr_stmt|;
name|t
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Test method used only for testing purposes.    */
DECL|method|getInitializingJob (String queue)
name|JobInProgress
name|getInitializingJob
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|JobInitializationThread
name|t
init|=
name|threadsToQueueMap
operator|.
name|get
argument_list|(
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|t
operator|.
name|getInitializingJob
argument_list|()
return|;
block|}
block|}
DECL|method|getInitializedJobList ()
name|Set
argument_list|<
name|JobID
argument_list|>
name|getInitializedJobList
parameter_list|()
block|{
return|return
name|initializedJobs
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|getThreadsToQueueMap ()
specifier|public
name|HashMap
argument_list|<
name|String
argument_list|,
name|JobInitializationThread
argument_list|>
name|getThreadsToQueueMap
parameter_list|()
block|{
return|return
name|threadsToQueueMap
return|;
block|}
DECL|method|getSleepInterval ()
specifier|public
name|long
name|getSleepInterval
parameter_list|()
block|{
return|return
name|sleepInterval
return|;
block|}
block|}
end_class

end_unit

