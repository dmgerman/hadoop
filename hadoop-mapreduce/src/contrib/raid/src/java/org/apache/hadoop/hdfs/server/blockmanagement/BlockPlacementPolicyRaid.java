begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|RaidNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * This BlockPlacementPolicy spreads out the group of blocks which used by RAID  * for recovering each other. This is important for the availability  * of the blocks. This class can be used by multiple threads. It has to be  * thread safe.  */
end_comment

begin_class
DECL|class|BlockPlacementPolicyRaid
specifier|public
class|class
name|BlockPlacementPolicyRaid
extends|extends
name|BlockPlacementPolicy
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BlockPlacementPolicyRaid
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|conf
name|Configuration
name|conf
decl_stmt|;
DECL|field|stripeLength
specifier|private
name|int
name|stripeLength
decl_stmt|;
DECL|field|xorParityLength
specifier|private
name|int
name|xorParityLength
decl_stmt|;
DECL|field|rsParityLength
specifier|private
name|int
name|rsParityLength
decl_stmt|;
DECL|field|xorPrefix
specifier|private
name|String
name|xorPrefix
init|=
literal|null
decl_stmt|;
DECL|field|rsPrefix
specifier|private
name|String
name|rsPrefix
init|=
literal|null
decl_stmt|;
DECL|field|raidTempPrefix
specifier|private
name|String
name|raidTempPrefix
init|=
literal|null
decl_stmt|;
DECL|field|raidrsTempPrefix
specifier|private
name|String
name|raidrsTempPrefix
init|=
literal|null
decl_stmt|;
DECL|field|raidHarTempPrefix
specifier|private
name|String
name|raidHarTempPrefix
init|=
literal|null
decl_stmt|;
DECL|field|raidrsHarTempPrefix
specifier|private
name|String
name|raidrsHarTempPrefix
init|=
literal|null
decl_stmt|;
DECL|field|namesystem
specifier|private
name|FSNamesystem
name|namesystem
init|=
literal|null
decl_stmt|;
DECL|field|defaultPolicy
specifier|private
name|BlockPlacementPolicyDefault
name|defaultPolicy
decl_stmt|;
DECL|field|cachedLocatedBlocks
name|CachedLocatedBlocks
name|cachedLocatedBlocks
decl_stmt|;
DECL|field|cachedFullPathNames
name|CachedFullPathNames
name|cachedFullPathNames
decl_stmt|;
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|initialize (Configuration conf, FSClusterStats stats, NetworkTopology clusterMap)
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSClusterStats
name|stats
parameter_list|,
name|NetworkTopology
name|clusterMap
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|stripeLength
operator|=
name|RaidNode
operator|.
name|getStripeLength
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|rsParityLength
operator|=
name|RaidNode
operator|.
name|rsParityLength
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|xorParityLength
operator|=
literal|1
expr_stmt|;
try|try
block|{
name|this
operator|.
name|xorPrefix
operator|=
name|RaidNode
operator|.
name|xorDestinationPath
argument_list|(
name|conf
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|this
operator|.
name|rsPrefix
operator|=
name|RaidNode
operator|.
name|rsDestinationPath
argument_list|(
name|conf
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{     }
if|if
condition|(
name|this
operator|.
name|xorPrefix
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|xorPrefix
operator|=
name|RaidNode
operator|.
name|DEFAULT_RAID_LOCATION
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|rsPrefix
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|rsPrefix
operator|=
name|RaidNode
operator|.
name|DEFAULT_RAIDRS_LOCATION
expr_stmt|;
block|}
comment|// Throws ClassCastException if we cannot cast here.
name|this
operator|.
name|namesystem
operator|=
operator|(
name|FSNamesystem
operator|)
name|stats
expr_stmt|;
name|this
operator|.
name|cachedLocatedBlocks
operator|=
operator|new
name|CachedLocatedBlocks
argument_list|(
name|namesystem
argument_list|)
expr_stmt|;
name|this
operator|.
name|cachedFullPathNames
operator|=
operator|new
name|CachedFullPathNames
argument_list|(
name|namesystem
argument_list|)
expr_stmt|;
name|this
operator|.
name|raidTempPrefix
operator|=
name|RaidNode
operator|.
name|xorTempPrefix
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|raidrsTempPrefix
operator|=
name|RaidNode
operator|.
name|rsTempPrefix
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|raidHarTempPrefix
operator|=
name|RaidNode
operator|.
name|xorHarTempPrefix
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|raidrsHarTempPrefix
operator|=
name|RaidNode
operator|.
name|rsHarTempPrefix
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|defaultPolicy
operator|=
operator|new
name|BlockPlacementPolicyDefault
argument_list|(
name|conf
argument_list|,
name|stats
argument_list|,
name|clusterMap
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|chooseTarget (String srcPath, int numOfReplicas, DatanodeDescriptor writer, List<DatanodeDescriptor> chosenNodes, long blocksize)
name|DatanodeDescriptor
index|[]
name|chooseTarget
parameter_list|(
name|String
name|srcPath
parameter_list|,
name|int
name|numOfReplicas
parameter_list|,
name|DatanodeDescriptor
name|writer
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|chosenNodes
parameter_list|,
name|long
name|blocksize
parameter_list|)
block|{
return|return
name|chooseTarget
argument_list|(
name|srcPath
argument_list|,
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|chosenNodes
argument_list|,
literal|null
argument_list|,
name|blocksize
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|chooseTarget (String srcPath, int numOfReplicas, DatanodeDescriptor writer, List<DatanodeDescriptor> chosenNodes, boolean returnChosenNodes, HashMap<Node, Node> excludedNodes, long blocksize)
specifier|public
name|DatanodeDescriptor
index|[]
name|chooseTarget
parameter_list|(
name|String
name|srcPath
parameter_list|,
name|int
name|numOfReplicas
parameter_list|,
name|DatanodeDescriptor
name|writer
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|chosenNodes
parameter_list|,
name|boolean
name|returnChosenNodes
parameter_list|,
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|)
block|{
try|try
block|{
name|FileType
name|type
init|=
name|getFileType
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|FileType
operator|.
name|NOT_RAID
condition|)
block|{
return|return
name|defaultPolicy
operator|.
name|chooseTarget
argument_list|(
name|srcPath
argument_list|,
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|chosenNodes
argument_list|,
name|blocksize
argument_list|)
return|;
block|}
if|if
condition|(
name|excludedNodes
operator|==
literal|null
condition|)
block|{
name|excludedNodes
operator|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|addExcludedNodes
argument_list|(
name|srcPath
argument_list|,
name|type
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
name|DatanodeDescriptor
index|[]
name|result
init|=
name|defaultPolicy
operator|.
name|chooseTarget
argument_list|(
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|chosenNodes
argument_list|,
name|returnChosenNodes
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|)
decl_stmt|;
comment|// Add the added block locations in the block locations cache.
comment|// So the rest of the blocks know about these locations.
name|cachedLocatedBlocks
operator|.
name|get
argument_list|(
name|srcPath
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|LocatedBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|()
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error happend when choosing datanode to write:"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|defaultPolicy
operator|.
name|chooseTarget
argument_list|(
name|srcPath
argument_list|,
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|chosenNodes
argument_list|,
name|blocksize
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|verifyBlockPlacement (String srcPath, LocatedBlock lBlk, int minRacks)
specifier|public
name|int
name|verifyBlockPlacement
parameter_list|(
name|String
name|srcPath
parameter_list|,
name|LocatedBlock
name|lBlk
parameter_list|,
name|int
name|minRacks
parameter_list|)
block|{
return|return
name|defaultPolicy
operator|.
name|verifyBlockPlacement
argument_list|(
name|srcPath
argument_list|,
name|lBlk
argument_list|,
name|minRacks
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|chooseReplicaToDelete (FSInodeInfo inode, Block block, short replicationFactor, Collection<DatanodeDescriptor> first, Collection<DatanodeDescriptor> second)
specifier|public
name|DatanodeDescriptor
name|chooseReplicaToDelete
parameter_list|(
name|FSInodeInfo
name|inode
parameter_list|,
name|Block
name|block
parameter_list|,
name|short
name|replicationFactor
parameter_list|,
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|first
parameter_list|,
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|second
parameter_list|)
block|{
name|DatanodeDescriptor
name|chosenNode
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|path
init|=
name|cachedFullPathNames
operator|.
name|get
argument_list|(
name|inode
argument_list|)
decl_stmt|;
name|FileType
name|type
init|=
name|getFileType
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|FileType
operator|.
name|NOT_RAID
condition|)
block|{
return|return
name|defaultPolicy
operator|.
name|chooseReplicaToDelete
argument_list|(
name|inode
argument_list|,
name|block
argument_list|,
name|replicationFactor
argument_list|,
name|first
argument_list|,
name|second
argument_list|)
return|;
block|}
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|companionBlocks
init|=
name|getCompanionBlocks
argument_list|(
name|path
argument_list|,
name|type
argument_list|,
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|companionBlocks
operator|==
literal|null
operator|||
name|companionBlocks
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Use the default method if it is not a valid raided or parity file
return|return
name|defaultPolicy
operator|.
name|chooseReplicaToDelete
argument_list|(
name|inode
argument_list|,
name|block
argument_list|,
name|replicationFactor
argument_list|,
name|first
argument_list|,
name|second
argument_list|)
return|;
block|}
comment|// Delete from the first collection first
comment|// This ensures the number of unique rack of this block is not reduced
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|all
init|=
operator|new
name|HashSet
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|all
operator|.
name|addAll
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|all
operator|.
name|addAll
argument_list|(
name|second
argument_list|)
expr_stmt|;
name|chosenNode
operator|=
name|chooseReplicaToDelete
argument_list|(
name|companionBlocks
argument_list|,
name|all
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosenNode
operator|!=
literal|null
condition|)
block|{
return|return
name|chosenNode
return|;
block|}
return|return
name|defaultPolicy
operator|.
name|chooseReplicaToDelete
argument_list|(
name|inode
argument_list|,
name|block
argument_list|,
name|replicationFactor
argument_list|,
name|first
argument_list|,
name|second
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error happend when choosing replica to delete"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|defaultPolicy
operator|.
name|chooseReplicaToDelete
argument_list|(
name|inode
argument_list|,
name|block
argument_list|,
name|replicationFactor
argument_list|,
name|first
argument_list|,
name|second
argument_list|)
return|;
block|}
block|}
comment|/**    * Obtain the excluded nodes for the current block that is being written    */
DECL|method|addExcludedNodes (String file, FileType type, HashMap<Node, Node> excluded)
name|void
name|addExcludedNodes
parameter_list|(
name|String
name|file
parameter_list|,
name|FileType
name|type
parameter_list|,
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
name|excluded
parameter_list|)
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|LocatedBlock
argument_list|>
name|blocks
init|=
name|getCompanionBlocks
argument_list|(
name|file
argument_list|,
name|type
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|LocatedBlock
name|b
range|:
name|blocks
control|)
block|{
for|for
control|(
name|Node
name|n
range|:
name|b
operator|.
name|getLocations
argument_list|()
control|)
block|{
name|excluded
operator|.
name|put
argument_list|(
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|chooseReplicaToDelete ( Collection<LocatedBlock> companionBlocks, Collection<DatanodeDescriptor> dataNodes)
specifier|private
name|DatanodeDescriptor
name|chooseReplicaToDelete
parameter_list|(
name|Collection
argument_list|<
name|LocatedBlock
argument_list|>
name|companionBlocks
parameter_list|,
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dataNodes
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dataNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Count the number of replicas on each node and rack
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nodeCompanionBlockCount
init|=
name|countCompanionBlocks
argument_list|(
name|companionBlocks
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rackCompanionBlockCount
init|=
name|countCompanionBlocks
argument_list|(
name|companionBlocks
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|NodeComparator
name|comparator
init|=
operator|new
name|NodeComparator
argument_list|(
name|nodeCompanionBlockCount
argument_list|,
name|rackCompanionBlockCount
argument_list|)
decl_stmt|;
return|return
name|Collections
operator|.
name|max
argument_list|(
name|dataNodes
argument_list|,
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Count how many companion blocks are on each datanode or the each rack    * @param companionBlocks a collection of all the companion blocks    * @param doRackCount count the companion blocks on the racks of datanodes    * @param result the map from node name to the number of companion blocks    */
DECL|method|countCompanionBlocks ( Collection<LocatedBlock> companionBlocks, boolean doRackCount)
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|countCompanionBlocks
parameter_list|(
name|Collection
argument_list|<
name|LocatedBlock
argument_list|>
name|companionBlocks
parameter_list|,
name|boolean
name|doRackCount
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|LocatedBlock
name|block
range|:
name|companionBlocks
control|)
block|{
for|for
control|(
name|DatanodeInfo
name|d
range|:
name|block
operator|.
name|getLocations
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|doRackCount
condition|?
name|d
operator|.
name|getParent
argument_list|()
operator|.
name|getName
argument_list|()
else|:
name|d
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|int
name|count
init|=
name|result
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|put
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Compares the datanodes based on the number of companion blocks on the same    * node and rack. If even, compare the remaining space on the datanodes.    */
DECL|class|NodeComparator
class|class
name|NodeComparator
implements|implements
name|Comparator
argument_list|<
name|DatanodeDescriptor
argument_list|>
block|{
DECL|field|nodeBlockCount
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nodeBlockCount
decl_stmt|;
DECL|field|rackBlockCount
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rackBlockCount
decl_stmt|;
DECL|method|NodeComparator (Map<String, Integer> nodeBlockCount, Map<String, Integer> rackBlockCount)
specifier|private
name|NodeComparator
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nodeBlockCount
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rackBlockCount
parameter_list|)
block|{
name|this
operator|.
name|nodeBlockCount
operator|=
name|nodeBlockCount
expr_stmt|;
name|this
operator|.
name|rackBlockCount
operator|=
name|rackBlockCount
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare (DatanodeDescriptor d1, DatanodeDescriptor d2)
specifier|public
name|int
name|compare
parameter_list|(
name|DatanodeDescriptor
name|d1
parameter_list|,
name|DatanodeDescriptor
name|d2
parameter_list|)
block|{
name|int
name|res
init|=
name|compareBlockCount
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|,
name|nodeBlockCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
return|return
name|res
return|;
block|}
name|res
operator|=
name|compareBlockCount
argument_list|(
name|d1
operator|.
name|getParent
argument_list|()
argument_list|,
name|d2
operator|.
name|getParent
argument_list|()
argument_list|,
name|rackBlockCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
return|return
name|res
return|;
block|}
if|if
condition|(
name|d1
operator|.
name|getRemaining
argument_list|()
operator|>
name|d2
operator|.
name|getRemaining
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|d1
operator|.
name|getRemaining
argument_list|()
operator|<
name|d2
operator|.
name|getRemaining
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|method|compareBlockCount (Node node1, Node node2, Map<String, Integer> blockCount)
specifier|private
name|int
name|compareBlockCount
parameter_list|(
name|Node
name|node1
parameter_list|,
name|Node
name|node2
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|blockCount
parameter_list|)
block|{
name|Integer
name|count1
init|=
name|blockCount
operator|.
name|get
argument_list|(
name|node1
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Integer
name|count2
init|=
name|blockCount
operator|.
name|get
argument_list|(
name|node2
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|count1
operator|=
name|count1
operator|==
literal|null
condition|?
literal|0
else|:
name|count1
expr_stmt|;
name|count2
operator|=
name|count2
operator|==
literal|null
condition|?
literal|0
else|:
name|count2
expr_stmt|;
if|if
condition|(
name|count1
operator|>
name|count2
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|count1
operator|<
name|count2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/**    * Obtain the companion blocks of the give block    * Companion blocks are defined as the blocks that can help recover each    * others by using raid decoder.    * @param path The path of the file contains the block    * @param type The type of this file    * @param block The given block    *              null if it is the block which is currently being written to    * @return the block locations of companion blocks    */
DECL|method|getCompanionBlocks (String path, FileType type, Block block)
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|getCompanionBlocks
parameter_list|(
name|String
name|path
parameter_list|,
name|FileType
name|type
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NOT_RAID
case|:
return|return
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
return|;
case|case
name|XOR_HAR_TEMP_PARITY
case|:
return|return
name|getCompanionBlocksForHarParityBlock
argument_list|(
name|path
argument_list|,
name|xorParityLength
argument_list|,
name|block
argument_list|)
return|;
case|case
name|RS_HAR_TEMP_PARITY
case|:
return|return
name|getCompanionBlocksForHarParityBlock
argument_list|(
name|path
argument_list|,
name|rsParityLength
argument_list|,
name|block
argument_list|)
return|;
case|case
name|XOR_TEMP_PARITY
case|:
return|return
name|getCompanionBlocksForParityBlock
argument_list|(
name|getSourceFile
argument_list|(
name|path
argument_list|,
name|raidTempPrefix
argument_list|)
argument_list|,
name|path
argument_list|,
name|xorParityLength
argument_list|,
name|block
argument_list|)
return|;
case|case
name|RS_TEMP_PARITY
case|:
return|return
name|getCompanionBlocksForParityBlock
argument_list|(
name|getSourceFile
argument_list|(
name|path
argument_list|,
name|raidrsTempPrefix
argument_list|)
argument_list|,
name|path
argument_list|,
name|rsParityLength
argument_list|,
name|block
argument_list|)
return|;
case|case
name|XOR_PARITY
case|:
return|return
name|getCompanionBlocksForParityBlock
argument_list|(
name|getSourceFile
argument_list|(
name|path
argument_list|,
name|xorPrefix
argument_list|)
argument_list|,
name|path
argument_list|,
name|xorParityLength
argument_list|,
name|block
argument_list|)
return|;
case|case
name|RS_PARITY
case|:
return|return
name|getCompanionBlocksForParityBlock
argument_list|(
name|getSourceFile
argument_list|(
name|path
argument_list|,
name|rsPrefix
argument_list|)
argument_list|,
name|path
argument_list|,
name|rsParityLength
argument_list|,
name|block
argument_list|)
return|;
case|case
name|XOR_SOURCE
case|:
return|return
name|getCompanionBlocksForSourceBlock
argument_list|(
name|path
argument_list|,
name|getParityFile
argument_list|(
name|path
argument_list|)
argument_list|,
name|xorParityLength
argument_list|,
name|block
argument_list|)
return|;
case|case
name|RS_SOURCE
case|:
return|return
name|getCompanionBlocksForSourceBlock
argument_list|(
name|path
argument_list|,
name|getParityFile
argument_list|(
name|path
argument_list|)
argument_list|,
name|xorParityLength
argument_list|,
name|block
argument_list|)
return|;
block|}
return|return
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
return|;
block|}
DECL|method|getCompanionBlocksForHarParityBlock ( String parity, int parityLength, Block block)
specifier|private
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|getCompanionBlocksForHarParityBlock
parameter_list|(
name|String
name|parity
parameter_list|,
name|int
name|parityLength
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|blockIndex
init|=
name|getBlockIndex
argument_list|(
name|parity
argument_list|,
name|block
argument_list|)
decl_stmt|;
comment|// consider only parity file in this case because source file block
comment|// location is not easy to obtain
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|parityBlocks
init|=
name|cachedLocatedBlocks
operator|.
name|get
argument_list|(
name|parity
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|parityBlocks
init|)
block|{
name|int
name|start
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|blockIndex
operator|-
name|parityLength
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|parityBlocks
operator|.
name|size
argument_list|()
argument_list|,
name|blockIndex
operator|+
name|parityLength
argument_list|)
decl_stmt|;
name|result
operator|.
name|addAll
argument_list|(
name|parityBlocks
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|getCompanionBlocksForParityBlock ( String src, String parity, int parityLength, Block block)
specifier|private
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|getCompanionBlocksForParityBlock
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|parity
parameter_list|,
name|int
name|parityLength
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|blockIndex
init|=
name|getBlockIndex
argument_list|(
name|parity
argument_list|,
name|block
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|parityBlocks
init|=
name|cachedLocatedBlocks
operator|.
name|get
argument_list|(
name|parity
argument_list|)
decl_stmt|;
name|int
name|stripeIndex
init|=
name|blockIndex
operator|/
name|parityLength
decl_stmt|;
synchronized|synchronized
init|(
name|parityBlocks
init|)
block|{
name|int
name|parityStart
init|=
name|stripeIndex
operator|*
name|parityLength
decl_stmt|;
name|int
name|parityEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|parityStart
operator|+
name|parityLength
argument_list|,
name|parityBlocks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// for parity, always consider the neighbor blocks as companion blocks
if|if
condition|(
name|parityStart
operator|<
name|parityBlocks
operator|.
name|size
argument_list|()
condition|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|parityBlocks
operator|.
name|subList
argument_list|(
name|parityStart
argument_list|,
name|parityEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src
operator|==
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|sourceBlocks
init|=
name|cachedLocatedBlocks
operator|.
name|get
argument_list|(
name|src
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|sourceBlocks
init|)
block|{
name|int
name|sourceStart
init|=
name|stripeIndex
operator|*
name|stripeLength
decl_stmt|;
name|int
name|sourceEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|sourceStart
operator|+
name|stripeLength
argument_list|,
name|sourceBlocks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceStart
operator|<
name|sourceBlocks
operator|.
name|size
argument_list|()
condition|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|sourceBlocks
operator|.
name|subList
argument_list|(
name|sourceStart
argument_list|,
name|sourceEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|getCompanionBlocksForSourceBlock ( String src, String parity, int parityLength, Block block)
specifier|private
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|getCompanionBlocksForSourceBlock
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|parity
parameter_list|,
name|int
name|parityLength
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|blockIndex
init|=
name|getBlockIndex
argument_list|(
name|src
argument_list|,
name|block
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|sourceBlocks
init|=
name|cachedLocatedBlocks
operator|.
name|get
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|int
name|stripeIndex
init|=
name|blockIndex
operator|/
name|stripeLength
decl_stmt|;
synchronized|synchronized
init|(
name|sourceBlocks
init|)
block|{
name|int
name|sourceStart
init|=
name|stripeIndex
operator|*
name|stripeLength
decl_stmt|;
name|int
name|sourceEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|sourceStart
operator|+
name|stripeLength
argument_list|,
name|sourceBlocks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceStart
operator|<
name|sourceBlocks
operator|.
name|size
argument_list|()
condition|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|sourceBlocks
operator|.
name|subList
argument_list|(
name|sourceStart
argument_list|,
name|sourceEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|parity
operator|==
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|parityBlocks
init|=
name|cachedLocatedBlocks
operator|.
name|get
argument_list|(
name|parity
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|parityBlocks
init|)
block|{
name|int
name|parityStart
init|=
name|stripeIndex
operator|*
name|parityLength
decl_stmt|;
name|int
name|parityEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|parityStart
operator|+
name|parityLength
argument_list|,
name|parityBlocks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|parityStart
operator|<
name|parityBlocks
operator|.
name|size
argument_list|()
condition|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|parityBlocks
operator|.
name|subList
argument_list|(
name|parityStart
argument_list|,
name|parityEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|getBlockIndex (String file, Block block)
specifier|private
name|int
name|getBlockIndex
parameter_list|(
name|String
name|file
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|blocks
init|=
name|cachedLocatedBlocks
operator|.
name|get
argument_list|(
name|file
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|blocks
init|)
block|{
comment|// null indicates that this block is currently added. Return size()
comment|// as the index in this case
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
return|return
name|blocks
operator|.
name|size
argument_list|()
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getBlock
argument_list|()
operator|.
name|getLocalBlock
argument_list|()
operator|.
name|equals
argument_list|(
name|block
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot locate "
operator|+
name|block
operator|+
literal|" in file "
operator|+
name|file
argument_list|)
throw|;
block|}
comment|/**    * Cache results for FSInodeInfo.getFullPathName()    */
DECL|class|CachedFullPathNames
specifier|static
class|class
name|CachedFullPathNames
block|{
DECL|field|namesystem
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|method|CachedFullPathNames (FSNamesystem namesystem)
name|CachedFullPathNames
parameter_list|(
name|FSNamesystem
name|namesystem
parameter_list|)
block|{
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
block|}
DECL|field|cacheInternal
specifier|private
name|Cache
argument_list|<
name|INodeWithHashCode
argument_list|,
name|String
argument_list|>
name|cacheInternal
init|=
operator|new
name|Cache
argument_list|<
name|INodeWithHashCode
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|getDirectly
parameter_list|(
name|INodeWithHashCode
name|inode
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|inode
operator|.
name|getFullPathName
argument_list|()
return|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
DECL|class|INodeWithHashCode
specifier|static
specifier|private
class|class
name|INodeWithHashCode
block|{
DECL|field|inode
name|FSInodeInfo
name|inode
decl_stmt|;
DECL|method|INodeWithHashCode (FSInodeInfo inode)
name|INodeWithHashCode
parameter_list|(
name|FSInodeInfo
name|inode
parameter_list|)
block|{
name|this
operator|.
name|inode
operator|=
name|inode
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|inode
operator|==
name|obj
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|inode
argument_list|)
return|;
block|}
DECL|method|getFullPathName ()
name|String
name|getFullPathName
parameter_list|()
block|{
return|return
name|inode
operator|.
name|getFullPathName
argument_list|()
return|;
block|}
block|}
DECL|method|get (FSInodeInfo inode)
specifier|public
name|String
name|get
parameter_list|(
name|FSInodeInfo
name|inode
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|cacheInternal
operator|.
name|get
argument_list|(
operator|new
name|INodeWithHashCode
argument_list|(
name|inode
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Cache results for FSNamesystem.getBlockLocations()    */
DECL|class|CachedLocatedBlocks
specifier|static
class|class
name|CachedLocatedBlocks
extends|extends
name|Cache
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|>
block|{
DECL|field|namesystem
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|method|CachedLocatedBlocks (FSNamesystem namesystem)
name|CachedLocatedBlocks
parameter_list|(
name|FSNamesystem
name|namesystem
parameter_list|)
block|{
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDirectly (String file)
specifier|public
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|getDirectly
parameter_list|(
name|String
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|len
init|=
name|NameNodeRaidUtil
operator|.
name|getFileInfo
argument_list|(
name|namesystem
argument_list|,
name|file
argument_list|,
literal|true
argument_list|)
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|result
init|=
name|NameNodeRaidUtil
operator|.
name|getBlockLocations
argument_list|(
name|namesystem
argument_list|,
name|file
argument_list|,
literal|0L
argument_list|,
name|len
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
operator|.
name|getLocatedBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|||
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|=
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|synchronizedList
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
DECL|class|Cache
specifier|static
specifier|abstract
class|class
name|Cache
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|cache
specifier|private
name|Map
argument_list|<
name|K
argument_list|,
name|ValueWithTime
argument_list|>
name|cache
decl_stmt|;
DECL|field|CACHE_TIMEOUT
specifier|private
specifier|static
specifier|final
name|long
name|CACHE_TIMEOUT
init|=
literal|300000L
decl_stmt|;
comment|// 5 minutes
comment|// The timeout is long but the consequence of stale value is not serious
DECL|method|Cache ()
name|Cache
parameter_list|()
block|{
name|Map
argument_list|<
name|K
argument_list|,
name|ValueWithTime
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|ValueWithTime
argument_list|>
argument_list|()
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|final
specifier|private
name|int
name|MAX_ENTRIES
init|=
literal|50000
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|ValueWithTime
argument_list|>
name|eldest
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>
name|MAX_ENTRIES
return|;
block|}
block|}
decl_stmt|;
name|this
operator|.
name|cache
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
comment|// Note that this method may hold FSNamesystem.readLock() and it may
comment|// be called inside FSNamesystem.writeLock(). If we make this method
comment|// synchronized, it will deadlock.
DECL|method|getDirectly (K key)
specifier|abstract
specifier|protected
name|V
name|getDirectly
parameter_list|(
name|K
name|key
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|get (K key)
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|)
throws|throws
name|IOException
block|{
comment|// The method is not synchronized so we may get some stale value here but
comment|// it's OK.
name|ValueWithTime
name|result
init|=
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|now
operator|-
name|result
operator|.
name|cachedTime
operator|<
name|CACHE_TIMEOUT
condition|)
block|{
return|return
name|result
operator|.
name|value
return|;
block|}
name|result
operator|=
operator|new
name|ValueWithTime
argument_list|()
expr_stmt|;
name|result
operator|.
name|value
operator|=
name|getDirectly
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|result
operator|.
name|cachedTime
operator|=
name|now
expr_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|value
return|;
block|}
DECL|class|ValueWithTime
specifier|private
class|class
name|ValueWithTime
block|{
DECL|field|value
name|V
name|value
init|=
literal|null
decl_stmt|;
DECL|field|cachedTime
name|long
name|cachedTime
init|=
literal|0L
decl_stmt|;
block|}
block|}
comment|/**    * Get path for the corresponding source file for a valid parity    * file. Returns null if it does not exists    * @param parity the toUri path of the parity file    * @return the toUri path of the source file    */
DECL|method|getSourceFile (String parity, String prefix)
name|String
name|getSourceFile
parameter_list|(
name|String
name|parity
parameter_list|,
name|String
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isHarFile
argument_list|(
name|parity
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// remove the prefix
name|String
name|src
init|=
name|parity
operator|.
name|substring
argument_list|(
name|prefix
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|NameNodeRaidUtil
operator|.
name|getFileInfo
argument_list|(
name|namesystem
argument_list|,
name|src
argument_list|,
literal|true
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|src
return|;
block|}
comment|/**    * Get path for the corresponding parity file for a source file.    * Returns null if it does not exists    * @param src the toUri path of the source file    * @return the toUri path of the parity file    */
DECL|method|getParityFile (String src)
name|String
name|getParityFile
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|xorParity
init|=
name|getParityFile
argument_list|(
name|xorPrefix
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|xorParity
operator|!=
literal|null
condition|)
block|{
return|return
name|xorParity
return|;
block|}
name|String
name|rsParity
init|=
name|getParityFile
argument_list|(
name|rsPrefix
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsParity
operator|!=
literal|null
condition|)
block|{
return|return
name|rsParity
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get path for the parity file. Returns null if it does not exists    * @param parityPrefix usuall "/raid/" or "/raidrs/"    * @return the toUri path of the parity file    */
DECL|method|getParityFile (String parityPrefix, String src)
specifier|private
name|String
name|getParityFile
parameter_list|(
name|String
name|parityPrefix
parameter_list|,
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|parity
init|=
name|parityPrefix
operator|+
name|src
decl_stmt|;
if|if
condition|(
name|NameNodeRaidUtil
operator|.
name|getFileInfo
argument_list|(
name|namesystem
argument_list|,
name|parity
argument_list|,
literal|true
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|parity
return|;
block|}
DECL|method|isHarFile (String path)
specifier|private
name|boolean
name|isHarFile
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|lastIndexOf
argument_list|(
name|RaidNode
operator|.
name|HAR_SUFFIX
argument_list|)
operator|!=
operator|-
literal|1
return|;
block|}
DECL|enum|FileType
enum|enum
name|FileType
block|{
DECL|enumConstant|NOT_RAID
name|NOT_RAID
block|,
DECL|enumConstant|XOR_HAR_TEMP_PARITY
name|XOR_HAR_TEMP_PARITY
block|,
DECL|enumConstant|XOR_TEMP_PARITY
name|XOR_TEMP_PARITY
block|,
DECL|enumConstant|XOR_PARITY
name|XOR_PARITY
block|,
DECL|enumConstant|XOR_SOURCE
name|XOR_SOURCE
block|,
DECL|enumConstant|RS_HAR_TEMP_PARITY
name|RS_HAR_TEMP_PARITY
block|,
DECL|enumConstant|RS_TEMP_PARITY
name|RS_TEMP_PARITY
block|,
DECL|enumConstant|RS_PARITY
name|RS_PARITY
block|,
DECL|enumConstant|RS_SOURCE
name|RS_SOURCE
block|,   }
DECL|method|getFileType (String path)
name|FileType
name|getFileType
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|raidHarTempPrefix
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
return|return
name|FileType
operator|.
name|XOR_HAR_TEMP_PARITY
return|;
block|}
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|raidrsHarTempPrefix
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
return|return
name|FileType
operator|.
name|RS_HAR_TEMP_PARITY
return|;
block|}
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|raidTempPrefix
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
return|return
name|FileType
operator|.
name|XOR_TEMP_PARITY
return|;
block|}
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|raidrsTempPrefix
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
return|return
name|FileType
operator|.
name|RS_TEMP_PARITY
return|;
block|}
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|xorPrefix
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
return|return
name|FileType
operator|.
name|XOR_PARITY
return|;
block|}
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|rsPrefix
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
return|return
name|FileType
operator|.
name|RS_PARITY
return|;
block|}
name|String
name|parity
init|=
name|getParityFile
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|parity
operator|==
literal|null
condition|)
block|{
return|return
name|FileType
operator|.
name|NOT_RAID
return|;
block|}
if|if
condition|(
name|parity
operator|.
name|startsWith
argument_list|(
name|xorPrefix
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
return|return
name|FileType
operator|.
name|XOR_SOURCE
return|;
block|}
if|if
condition|(
name|parity
operator|.
name|startsWith
argument_list|(
name|rsPrefix
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
return|return
name|FileType
operator|.
name|RS_SOURCE
return|;
block|}
return|return
name|FileType
operator|.
name|NOT_RAID
return|;
block|}
block|}
end_class

end_unit

