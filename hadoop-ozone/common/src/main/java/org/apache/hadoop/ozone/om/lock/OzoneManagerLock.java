begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.om.lock
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|om
operator|.
name|lock
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|lock
operator|.
name|LockManager
import|;
end_import

begin_comment
comment|/**  * Provides different locks to handle concurrency in OzoneMaster.  * We also maintain lock hierarchy, based on the weight.  *  *<table>  *<caption></caption>  *<tr>  *<td><b> WEIGHT</b></td><td><b> LOCK</b></td>  *</tr>  *<tr>  *<td> 0</td><td> S3 Bucket Lock</td>  *</tr>  *<tr>  *<td> 1</td><td> Volume Lock</td>  *</tr>  *<tr>  *<td> 2</td><td> Bucket Lock</td>  *</tr>  *<tr>  *<td> 3</td><td> User Lock</td>  *</tr>  *<tr>  *<td> 4</td><td> S3 Secret Lock</td>  *</tr>  *<tr>  *<td> 5</td><td> Prefix Lock</td>  *</tr>  *</table>  *  * One cannot obtain a lower weight lock while holding a lock with higher  * weight. The other way around is possible.<br>  *<br>  *<p>  * For example:  *<br>  * {@literal ->} acquire volume lock (will work)<br>  *   {@literal +->} acquire bucket lock (will work)<br>  *     {@literal +-->} acquire s3 bucket lock (will throw Exception)<br>  *</p>  *<br>  */
end_comment

begin_class
DECL|class|OzoneManagerLock
specifier|public
class|class
name|OzoneManagerLock
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|OzoneManagerLock
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|manager
specifier|private
specifier|final
name|LockManager
argument_list|<
name|String
argument_list|>
name|manager
decl_stmt|;
DECL|field|lockSet
specifier|private
specifier|final
name|ThreadLocal
argument_list|<
name|Short
argument_list|>
name|lockSet
init|=
name|ThreadLocal
operator|.
name|withInitial
argument_list|(
parameter_list|()
lambda|->
name|Short
operator|.
name|valueOf
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Creates new OzoneManagerLock instance.    * @param conf Configuration object    */
DECL|method|OzoneManagerLock (Configuration conf)
specifier|public
name|OzoneManagerLock
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|manager
operator|=
operator|new
name|LockManager
argument_list|<>
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Acquire lock on resource.    *    * For S3_Bucket, VOLUME, BUCKET type resource, same thread acquiring lock    * again is allowed.    *    * For USER, PREFIX, S3_SECRET type resource, same thread acquiring lock    * again is not allowed.    *    * Special Note for UserLock: Single thread can acquire single user lock/    * multi user lock. But not both at the same time.    * @param resourceName - Resource name on which user want to acquire lock.    * @param resource - Type of the resource.    */
DECL|method|acquireLock (String resourceName, Resource resource)
specifier|public
name|void
name|acquireLock
parameter_list|(
name|String
name|resourceName
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
if|if
condition|(
operator|!
name|resource
operator|.
name|canLock
argument_list|(
name|lockSet
operator|.
name|get
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|errorMessage
init|=
name|getErrorMessage
argument_list|(
name|resource
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|errorMessage
argument_list|)
throw|;
block|}
else|else
block|{
name|manager
operator|.
name|lock
argument_list|(
name|resourceName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Acquired {} lock on resource {}"
argument_list|,
name|resource
operator|.
name|name
argument_list|,
name|resourceName
argument_list|)
expr_stmt|;
name|lockSet
operator|.
name|set
argument_list|(
name|resource
operator|.
name|setLock
argument_list|(
name|lockSet
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getErrorMessage (Resource resource)
specifier|private
name|String
name|getErrorMessage
parameter_list|(
name|Resource
name|resource
parameter_list|)
block|{
return|return
literal|"Thread '"
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' cannot "
operator|+
literal|"acquire "
operator|+
name|resource
operator|.
name|name
operator|+
literal|" lock while holding "
operator|+
name|getCurrentLocks
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" lock(s)."
return|;
block|}
DECL|method|getCurrentLocks ()
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getCurrentLocks
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|currentLocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|short
name|lockSetVal
init|=
name|lockSet
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|Resource
name|value
range|:
name|Resource
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|value
operator|.
name|isLevelLocked
argument_list|(
name|lockSetVal
argument_list|)
condition|)
block|{
name|currentLocks
operator|.
name|add
argument_list|(
name|value
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|currentLocks
return|;
block|}
comment|/**    * Acquire lock on multiple users.    * @param firstUser    * @param secondUser    */
DECL|method|acquireMultiUserLock (String firstUser, String secondUser)
specifier|public
name|void
name|acquireMultiUserLock
parameter_list|(
name|String
name|firstUser
parameter_list|,
name|String
name|secondUser
parameter_list|)
block|{
name|Resource
name|resource
init|=
name|Resource
operator|.
name|USER
decl_stmt|;
if|if
condition|(
operator|!
name|resource
operator|.
name|canLock
argument_list|(
name|lockSet
operator|.
name|get
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|errorMessage
init|=
name|getErrorMessage
argument_list|(
name|resource
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|errorMessage
argument_list|)
throw|;
block|}
else|else
block|{
comment|// When acquiring multiple user locks, the reason for doing lexical
comment|// order comparision is to avoid deadlock scenario.
comment|// Example: 1st thread acquire lock(ozone, hdfs)
comment|// 2nd thread acquire lock(hdfs, ozone).
comment|// If we don't acquire user locks in an order, there can be a deadlock.
comment|// 1st thread acquired lock on ozone, waiting for lock on hdfs, 2nd
comment|// thread acquired lock on hdfs, waiting for lock on ozone.
comment|// To avoid this when we acquire lock on multiple users, we acquire
comment|// locks in lexical order, which can help us to avoid dead locks.
comment|// Now if first thread acquires lock on hdfs, 2nd thread wait for lock
comment|// on hdfs, and first thread acquires lock on ozone. Once after first
comment|// thread releases user locks, 2nd thread acquires them.
name|int
name|compare
init|=
name|firstUser
operator|.
name|compareTo
argument_list|(
name|secondUser
argument_list|)
decl_stmt|;
name|String
name|temp
decl_stmt|;
comment|// Order the user names in sorted order. Swap them.
if|if
condition|(
name|compare
operator|>
literal|0
condition|)
block|{
name|temp
operator|=
name|secondUser
expr_stmt|;
name|secondUser
operator|=
name|firstUser
expr_stmt|;
name|firstUser
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|compare
operator|==
literal|0
condition|)
block|{
comment|// both users are equal.
name|manager
operator|.
name|lock
argument_list|(
name|firstUser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|manager
operator|.
name|lock
argument_list|(
name|firstUser
argument_list|)
expr_stmt|;
try|try
block|{
name|manager
operator|.
name|lock
argument_list|(
name|secondUser
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|// We got an exception acquiring 2nd user lock. Release already
comment|// acquired user lock, and throw exception to the user.
name|manager
operator|.
name|unlock
argument_list|(
name|firstUser
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Acquired {} lock on resource {} and {}"
argument_list|,
name|resource
operator|.
name|name
argument_list|,
name|firstUser
argument_list|,
name|secondUser
argument_list|)
expr_stmt|;
name|lockSet
operator|.
name|set
argument_list|(
name|resource
operator|.
name|setLock
argument_list|(
name|lockSet
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Release lock on multiple users.    * @param firstUser    * @param secondUser    */
DECL|method|releaseMultiUserLock (String firstUser, String secondUser)
specifier|public
name|void
name|releaseMultiUserLock
parameter_list|(
name|String
name|firstUser
parameter_list|,
name|String
name|secondUser
parameter_list|)
block|{
name|Resource
name|resource
init|=
name|Resource
operator|.
name|USER
decl_stmt|;
name|int
name|compare
init|=
name|firstUser
operator|.
name|compareTo
argument_list|(
name|secondUser
argument_list|)
decl_stmt|;
name|String
name|temp
decl_stmt|;
comment|// Order the user names in sorted order. Swap them.
if|if
condition|(
name|compare
operator|>
literal|0
condition|)
block|{
name|temp
operator|=
name|secondUser
expr_stmt|;
name|secondUser
operator|=
name|firstUser
expr_stmt|;
name|firstUser
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|compare
operator|==
literal|0
condition|)
block|{
comment|// both users are equal.
name|manager
operator|.
name|unlock
argument_list|(
name|firstUser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|manager
operator|.
name|unlock
argument_list|(
name|firstUser
argument_list|)
expr_stmt|;
name|manager
operator|.
name|unlock
argument_list|(
name|secondUser
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Release {} lock on resource {} and {}"
argument_list|,
name|resource
operator|.
name|name
argument_list|,
name|firstUser
argument_list|,
name|secondUser
argument_list|)
expr_stmt|;
name|lockSet
operator|.
name|set
argument_list|(
name|resource
operator|.
name|clearLock
argument_list|(
name|lockSet
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|releaseLock (String resourceName, Resource resource)
specifier|public
name|void
name|releaseLock
parameter_list|(
name|String
name|resourceName
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
comment|// TODO: Not checking release of higher order level lock happened while
comment|// releasing lower order level lock, as for that we need counter for
comment|// locks, as some locks support acquiring lock again.
name|manager
operator|.
name|unlock
argument_list|(
name|resourceName
argument_list|)
expr_stmt|;
comment|// clear lock
name|LOG
operator|.
name|debug
argument_list|(
literal|"Release {}, lock on resource {}"
argument_list|,
name|resource
operator|.
name|name
argument_list|,
name|resource
operator|.
name|name
argument_list|,
name|resourceName
argument_list|)
expr_stmt|;
name|lockSet
operator|.
name|set
argument_list|(
name|resource
operator|.
name|clearLock
argument_list|(
name|lockSet
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Resource defined in Ozone.    */
DECL|enum|Resource
specifier|public
enum|enum
name|Resource
block|{
comment|// For S3 Bucket need to allow only for S3, that should be means only 1.
DECL|enumConstant|S3_BUCKET
name|S3_BUCKET
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|,
literal|"S3_BUCKET"
argument_list|)
block|,
comment|// = 1
comment|// For volume need to allow both s3 bucket and volume. 01 + 10 = 11 (3)
DECL|enumConstant|VOLUME
name|VOLUME
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|,
literal|"VOLUME"
argument_list|)
block|,
comment|// = 2
comment|// For bucket we need to allow both s3 bucket, volume and bucket. Which
comment|// is equal to 100 + 010 + 001 = 111 = 4 + 2 + 1 = 7
DECL|enumConstant|BUCKET
name|BUCKET
argument_list|(
operator|(
name|byte
operator|)
literal|2
argument_list|,
literal|"BUCKET"
argument_list|)
block|,
comment|// = 4
comment|// For user we need to allow s3 bucket, volume, bucket and user lock.
comment|// Which is 8  4 + 2 + 1 = 15
DECL|enumConstant|USER
name|USER
argument_list|(
operator|(
name|byte
operator|)
literal|3
argument_list|,
literal|"USER"
argument_list|)
block|,
comment|// 15
DECL|enumConstant|S3_SECRET
name|S3_SECRET
argument_list|(
operator|(
name|byte
operator|)
literal|4
argument_list|,
literal|"S3_SECRET"
argument_list|)
block|,
comment|// 31
DECL|enumConstant|PREFIX
name|PREFIX
argument_list|(
operator|(
name|byte
operator|)
literal|5
argument_list|,
literal|"PREFIX"
argument_list|)
block|;
comment|//63
comment|// level of the resource
DECL|field|lockLevel
specifier|private
name|byte
name|lockLevel
decl_stmt|;
comment|// This will tell the value, till which we can allow locking.
DECL|field|mask
specifier|private
name|short
name|mask
decl_stmt|;
comment|// This value will help during setLock, and also will tell whether we can
comment|// re-acquire lock or not.
DECL|field|setMask
specifier|private
name|short
name|setMask
decl_stmt|;
comment|// Name of the resource.
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|method|Resource (byte pos, String name)
name|Resource
parameter_list|(
name|byte
name|pos
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|lockLevel
operator|=
name|pos
expr_stmt|;
name|this
operator|.
name|mask
operator|=
call|(
name|short
call|)
argument_list|(
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|lockLevel
operator|+
literal|1
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|setMask
operator|=
operator|(
name|short
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|lockLevel
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
DECL|method|canLock (short lockSetVal)
name|boolean
name|canLock
parameter_list|(
name|short
name|lockSetVal
parameter_list|)
block|{
comment|// For USER, S3_SECRET and  PREFIX we shall not allow re-acquire locks at
comment|// from single thread. 2nd condition is we have acquired one of these
comment|// locks, but after that trying to acquire a lock with less than equal of
comment|// lockLevel, we should disallow.
if|if
condition|(
operator|(
operator|(
name|USER
operator|.
name|setMask
operator|&
name|lockSetVal
operator|)
operator|==
name|USER
operator|.
name|setMask
operator|||
operator|(
name|S3_SECRET
operator|.
name|setMask
operator|&
name|lockSetVal
operator|)
operator|==
name|S3_SECRET
operator|.
name|setMask
operator|||
operator|(
name|PREFIX
operator|.
name|setMask
operator|&
name|lockSetVal
operator|)
operator|==
name|PREFIX
operator|.
name|setMask
operator|)
operator|&&
name|setMask
operator|<=
name|lockSetVal
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Our mask is the summation of bits of all previous possible locks. In
comment|// other words it is the largest possible value for that bit position.
comment|// For example for Volume lock, bit position is 1, and mask is 3. Which
comment|// is the largest value that can be represented with 2 bits is 3.
comment|// Therefore if lockSet is larger than mask we have to return false i.e
comment|// some other higher order lock has been acquired.
return|return
name|lockSetVal
operator|<=
name|mask
return|;
block|}
comment|/**      * Set Lock bits in lockSetVal.      *      * @param lockSetVal      * @return Updated value which has set lock bits.      */
DECL|method|setLock (short lockSetVal)
name|short
name|setLock
parameter_list|(
name|short
name|lockSetVal
parameter_list|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
name|lockSetVal
operator||
name|setMask
argument_list|)
return|;
block|}
comment|/**      * Clear lock from lockSetVal.      *      * @param lockSetVal      * @return Updated value which has cleared lock bits.      */
DECL|method|clearLock (short lockSetVal)
name|short
name|clearLock
parameter_list|(
name|short
name|lockSetVal
parameter_list|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
name|lockSetVal
operator|&
operator|~
name|setMask
argument_list|)
return|;
block|}
comment|/**      * Return true, if this level is locked, else false.      * @param lockSetVal      */
DECL|method|isLevelLocked (short lockSetVal)
name|boolean
name|isLevelLocked
parameter_list|(
name|short
name|lockSetVal
parameter_list|)
block|{
return|return
operator|(
name|lockSetVal
operator|&
name|setMask
operator|)
operator|==
name|setMask
return|;
block|}
DECL|method|getName ()
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getMask ()
name|short
name|getMask
parameter_list|()
block|{
return|return
name|mask
return|;
block|}
block|}
block|}
end_class

end_unit

