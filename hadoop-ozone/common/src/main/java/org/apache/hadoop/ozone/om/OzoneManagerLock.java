begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with this  * work for additional information regarding copyright ownership.  The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.om
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|om
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|lock
operator|.
name|LockManager
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
operator|.
name|OM_KEY_PREFIX
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
operator|.
name|OM_S3_PREFIX
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
operator|.
name|OM_USER_PREFIX
import|;
end_import

begin_comment
comment|/**  * Provides different locks to handle concurrency in OzoneMaster.  * We also maintain lock hierarchy, based on the weight.  *  *<table>  *<caption></caption>  *<tr>  *<td><b> WEIGHT</b></td><td><b> LOCK</b></td>  *</tr>  *<tr>  *<td> 0</td><td> User Lock</td>  *</tr>  *<tr>  *<td> 1</td><td> Volume Lock</td>  *</tr>  *<tr>  *<td> 2</td><td> Bucket Lock</td>  *</tr>  *<tr>  *<td> 3</td><td> Prefix Lock</td>  *</tr>  *</table>  *  * One cannot obtain a lower weight lock while holding a lock with higher  * weight. The other way around is possible.<br>  *<br>  *<p>  * For example:  *<br>  * {@literal ->} acquireVolumeLock (will work)<br>  *   {@literal +->} acquireBucketLock (will work)<br>  *     {@literal +-->} acquireUserLock (will throw Exception)<br>  *</p>  *<br>  * To acquire a user lock you should not hold any Volume/Bucket lock. Similarly  * to acquire a Volume lock you should not hold any Bucket lock.  */
end_comment

begin_class
DECL|class|OzoneManagerLock
specifier|public
specifier|final
class|class
name|OzoneManagerLock
block|{
DECL|field|VOLUME_LOCK
specifier|private
specifier|static
specifier|final
name|String
name|VOLUME_LOCK
init|=
literal|"volumeLock"
decl_stmt|;
DECL|field|BUCKET_LOCK
specifier|private
specifier|static
specifier|final
name|String
name|BUCKET_LOCK
init|=
literal|"bucketLock"
decl_stmt|;
DECL|field|PREFIX_LOCK
specifier|private
specifier|static
specifier|final
name|String
name|PREFIX_LOCK
init|=
literal|"prefixLock"
decl_stmt|;
DECL|field|S3_BUCKET_LOCK
specifier|private
specifier|static
specifier|final
name|String
name|S3_BUCKET_LOCK
init|=
literal|"s3BucketLock"
decl_stmt|;
DECL|field|S3_SECRET_LOCK
specifier|private
specifier|static
specifier|final
name|String
name|S3_SECRET_LOCK
init|=
literal|"s3SecretetLock"
decl_stmt|;
DECL|field|manager
specifier|private
specifier|final
name|LockManager
argument_list|<
name|String
argument_list|>
name|manager
decl_stmt|;
comment|// To maintain locks held by current thread.
DECL|field|myLocks
specifier|private
specifier|final
name|ThreadLocal
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|>
name|myLocks
init|=
name|ThreadLocal
operator|.
name|withInitial
argument_list|(
parameter_list|()
lambda|->
name|ImmutableMap
operator|.
name|of
argument_list|(
name|VOLUME_LOCK
argument_list|,
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
argument_list|,
name|BUCKET_LOCK
argument_list|,
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PREFIX_LOCK
argument_list|,
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
argument_list|,
name|S3_BUCKET_LOCK
argument_list|,
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
argument_list|,
name|S3_SECRET_LOCK
argument_list|,
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Creates new OzoneManagerLock instance.    * @param conf Configuration object    */
DECL|method|OzoneManagerLock (Configuration conf)
specifier|public
name|OzoneManagerLock
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|manager
operator|=
operator|new
name|LockManager
argument_list|<>
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Acquires user lock on the given resource.    *    *<p>If the lock is not available then the current thread becomes    * disabled for thread scheduling purposes and lies dormant until the    * lock has been acquired.    *    * @param user User on which the lock has to be acquired    */
DECL|method|acquireUserLock (String user)
specifier|public
name|void
name|acquireUserLock
parameter_list|(
name|String
name|user
parameter_list|)
block|{
comment|// Calling thread should not hold any volume or bucket lock.
if|if
condition|(
name|hasAnyVolumeLock
argument_list|()
operator|||
name|hasAnyBucketLock
argument_list|()
operator|||
name|hasAnyS3Lock
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Thread '"
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' cannot acquire user lock"
operator|+
literal|" while holding volume, bucket or S3 bucket lock(s)."
argument_list|)
throw|;
block|}
name|manager
operator|.
name|lock
argument_list|(
name|OM_USER_PREFIX
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
comment|/**    * Releases the user lock on given resource.    */
DECL|method|releaseUserLock (String user)
specifier|public
name|void
name|releaseUserLock
parameter_list|(
name|String
name|user
parameter_list|)
block|{
name|manager
operator|.
name|unlock
argument_list|(
name|OM_USER_PREFIX
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
comment|/**    * Acquires volume lock on the given resource.    *    *<p>If the lock is not available then the current thread becomes    * disabled for thread scheduling purposes and lies dormant until the    * lock has been acquired.    *    * @param volume Volume on which the lock has to be acquired    */
DECL|method|acquireVolumeLock (String volume)
specifier|public
name|void
name|acquireVolumeLock
parameter_list|(
name|String
name|volume
parameter_list|)
block|{
comment|// Calling thread should not hold any bucket lock.
comment|// You can take an Volume while holding S3 bucket lock, since
comment|// semantically an S3 bucket maps to the ozone volume. So we check here
comment|// only if ozone bucket lock is taken.
if|if
condition|(
name|hasAnyBucketLock
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Thread '"
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' cannot acquire volume lock while holding bucket lock(s)."
argument_list|)
throw|;
block|}
name|manager
operator|.
name|lock
argument_list|(
name|OM_KEY_PREFIX
operator|+
name|volume
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|VOLUME_LOCK
argument_list|)
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Releases the volume lock on given resource.    */
DECL|method|releaseVolumeLock (String volume)
specifier|public
name|void
name|releaseVolumeLock
parameter_list|(
name|String
name|volume
parameter_list|)
block|{
name|manager
operator|.
name|unlock
argument_list|(
name|OM_KEY_PREFIX
operator|+
name|volume
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|VOLUME_LOCK
argument_list|)
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Acquires S3 Bucket lock on the given resource.    *    *<p>If the lock is not available then the current thread becomes    * disabled for thread scheduling purposes and lies dormant until the lock has    * been acquired.    *    * @param s3BucketName S3Bucket Name on which the lock has to be acquired    */
DECL|method|acquireS3Lock (String s3BucketName)
specifier|public
name|void
name|acquireS3Lock
parameter_list|(
name|String
name|s3BucketName
parameter_list|)
block|{
comment|// Calling thread should not hold any bucket lock.
comment|// You can take an Volume while holding S3 bucket lock, since
comment|// semantically an S3 bucket maps to the ozone volume. So we check here
comment|// only if ozone bucket lock is taken.
if|if
condition|(
name|hasAnyBucketLock
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Thread '"
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' cannot acquire S3 bucket lock while holding Ozone bucket "
operator|+
literal|"lock(s)."
argument_list|)
throw|;
block|}
name|manager
operator|.
name|lock
argument_list|(
name|OM_S3_PREFIX
operator|+
name|s3BucketName
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|S3_BUCKET_LOCK
argument_list|)
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Releases the volume lock on given resource.    */
DECL|method|releaseS3Lock (String s3BucketName)
specifier|public
name|void
name|releaseS3Lock
parameter_list|(
name|String
name|s3BucketName
parameter_list|)
block|{
name|manager
operator|.
name|unlock
argument_list|(
name|OM_S3_PREFIX
operator|+
name|s3BucketName
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|S3_BUCKET_LOCK
argument_list|)
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Acquires bucket lock on the given resource.    *    *<p>If the lock is not available then the current thread becomes    * disabled for thread scheduling purposes and lies dormant until the    * lock has been acquired.    *    * @param bucket Bucket on which the lock has to be acquired    */
DECL|method|acquireBucketLock (String volume, String bucket)
specifier|public
name|void
name|acquireBucketLock
parameter_list|(
name|String
name|volume
parameter_list|,
name|String
name|bucket
parameter_list|)
block|{
name|manager
operator|.
name|lock
argument_list|(
name|OM_KEY_PREFIX
operator|+
name|volume
operator|+
name|OM_KEY_PREFIX
operator|+
name|bucket
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|BUCKET_LOCK
argument_list|)
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Releases the bucket lock on given resource.    */
DECL|method|releaseBucketLock (String volume, String bucket)
specifier|public
name|void
name|releaseBucketLock
parameter_list|(
name|String
name|volume
parameter_list|,
name|String
name|bucket
parameter_list|)
block|{
name|manager
operator|.
name|unlock
argument_list|(
name|OM_KEY_PREFIX
operator|+
name|volume
operator|+
name|OM_KEY_PREFIX
operator|+
name|bucket
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|BUCKET_LOCK
argument_list|)
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns true if the current thread holds any volume lock.    * @return true if current thread holds volume lock, else false    */
DECL|method|hasAnyVolumeLock ()
specifier|private
name|boolean
name|hasAnyVolumeLock
parameter_list|()
block|{
return|return
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|VOLUME_LOCK
argument_list|)
operator|.
name|get
argument_list|()
operator|!=
literal|0
return|;
block|}
comment|/**    * Returns true if the current thread holds any bucket lock.    * @return true if current thread holds bucket lock, else false    */
DECL|method|hasAnyBucketLock ()
specifier|private
name|boolean
name|hasAnyBucketLock
parameter_list|()
block|{
return|return
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|BUCKET_LOCK
argument_list|)
operator|.
name|get
argument_list|()
operator|!=
literal|0
return|;
block|}
DECL|method|hasAnyS3Lock ()
specifier|private
name|boolean
name|hasAnyS3Lock
parameter_list|()
block|{
return|return
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|S3_BUCKET_LOCK
argument_list|)
operator|.
name|get
argument_list|()
operator|!=
literal|0
return|;
block|}
DECL|method|acquireS3SecretLock (String awsAccessId)
specifier|public
name|void
name|acquireS3SecretLock
parameter_list|(
name|String
name|awsAccessId
parameter_list|)
block|{
if|if
condition|(
name|hasAnyS3SecretLock
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Thread '"
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' cannot acquire S3 Secret lock while holding S3 "
operator|+
literal|"awsAccessKey lock(s)."
argument_list|)
throw|;
block|}
name|manager
operator|.
name|lock
argument_list|(
name|awsAccessId
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|S3_SECRET_LOCK
argument_list|)
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|hasAnyS3SecretLock ()
specifier|private
name|boolean
name|hasAnyS3SecretLock
parameter_list|()
block|{
return|return
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|S3_SECRET_LOCK
argument_list|)
operator|.
name|get
argument_list|()
operator|!=
literal|0
return|;
block|}
DECL|method|releaseS3SecretLock (String awsAccessId)
specifier|public
name|void
name|releaseS3SecretLock
parameter_list|(
name|String
name|awsAccessId
parameter_list|)
block|{
name|manager
operator|.
name|unlock
argument_list|(
name|awsAccessId
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|S3_SECRET_LOCK
argument_list|)
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|acquirePrefixLock (String prefixPath)
specifier|public
name|void
name|acquirePrefixLock
parameter_list|(
name|String
name|prefixPath
parameter_list|)
block|{
if|if
condition|(
name|hasAnyPrefixLock
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Thread '"
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' cannot acquire prefix path lock while holding prefix "
operator|+
literal|"path lock(s) for path: "
operator|+
name|prefixPath
operator|+
literal|"."
argument_list|)
throw|;
block|}
name|manager
operator|.
name|lock
argument_list|(
name|prefixPath
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|PREFIX_LOCK
argument_list|)
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|hasAnyPrefixLock ()
specifier|private
name|boolean
name|hasAnyPrefixLock
parameter_list|()
block|{
return|return
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|PREFIX_LOCK
argument_list|)
operator|.
name|get
argument_list|()
operator|!=
literal|0
return|;
block|}
DECL|method|releasePrefixLock (String prefixPath)
specifier|public
name|void
name|releasePrefixLock
parameter_list|(
name|String
name|prefixPath
parameter_list|)
block|{
name|manager
operator|.
name|unlock
argument_list|(
name|prefixPath
argument_list|)
expr_stmt|;
name|myLocks
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|PREFIX_LOCK
argument_list|)
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

