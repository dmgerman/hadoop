begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with this  * work for additional information regarding copyright ownership.  The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|security
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|SecurityConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|security
operator|.
name|x509
operator|.
name|certificate
operator|.
name|client
operator|.
name|CertificateClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|InvalidKeyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|KeyPair
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivateKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Signature
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SignatureException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * SecretManager for Ozone Master. Responsible for signing identifiers with  * private key,  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|OzoneSecretManager
specifier|public
specifier|abstract
class|class
name|OzoneSecretManager
parameter_list|<
name|T
extends|extends
name|TokenIdentifier
parameter_list|>
extends|extends
name|SecretManager
argument_list|<
name|T
argument_list|>
block|{
DECL|field|logger
specifier|private
specifier|final
name|Logger
name|logger
decl_stmt|;
comment|/**    * The name of the Private/Public Key based hashing algorithm.    */
DECL|field|securityConfig
specifier|private
specifier|final
name|SecurityConfig
name|securityConfig
decl_stmt|;
DECL|field|tokenMaxLifetime
specifier|private
specifier|final
name|long
name|tokenMaxLifetime
decl_stmt|;
DECL|field|tokenRenewInterval
specifier|private
specifier|final
name|long
name|tokenRenewInterval
decl_stmt|;
DECL|field|service
specifier|private
specifier|final
name|Text
name|service
decl_stmt|;
DECL|field|certClient
specifier|private
name|CertificateClient
name|certClient
decl_stmt|;
DECL|field|running
specifier|private
specifier|volatile
name|boolean
name|running
decl_stmt|;
DECL|field|currentKey
specifier|private
name|OzoneSecretKey
name|currentKey
decl_stmt|;
DECL|field|currentKeyId
specifier|private
name|AtomicInteger
name|currentKeyId
decl_stmt|;
DECL|field|tokenSequenceNumber
specifier|private
name|AtomicInteger
name|tokenSequenceNumber
decl_stmt|;
comment|/**    * Create a secret manager.    *    * @param secureConf configuration.    * @param tokenMaxLifetime the maximum lifetime of the delegation tokens in    * milliseconds    * @param tokenRenewInterval how often the tokens must be renewed in    * milliseconds    * @param service name of service    * @param logger logger for the secret manager    */
DECL|method|OzoneSecretManager (SecurityConfig secureConf, long tokenMaxLifetime, long tokenRenewInterval, Text service, Logger logger)
specifier|public
name|OzoneSecretManager
parameter_list|(
name|SecurityConfig
name|secureConf
parameter_list|,
name|long
name|tokenMaxLifetime
parameter_list|,
name|long
name|tokenRenewInterval
parameter_list|,
name|Text
name|service
parameter_list|,
name|Logger
name|logger
parameter_list|)
block|{
name|this
operator|.
name|securityConfig
operator|=
name|secureConf
expr_stmt|;
name|this
operator|.
name|tokenMaxLifetime
operator|=
name|tokenMaxLifetime
expr_stmt|;
name|this
operator|.
name|tokenRenewInterval
operator|=
name|tokenRenewInterval
expr_stmt|;
name|currentKeyId
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
name|tokenSequenceNumber
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
name|this
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
block|}
comment|/**    * Compute HMAC of the identifier using the private key and return the output    * as password.    *    * @param identifier    * @param privateKey    * @return byte[] signed byte array    */
DECL|method|createPassword (byte[] identifier, PrivateKey privateKey)
specifier|public
name|byte
index|[]
name|createPassword
parameter_list|(
name|byte
index|[]
name|identifier
parameter_list|,
name|PrivateKey
name|privateKey
parameter_list|)
throws|throws
name|OzoneSecurityException
block|{
try|try
block|{
name|Signature
name|rsaSignature
init|=
name|Signature
operator|.
name|getInstance
argument_list|(
name|getDefaultSignatureAlgorithm
argument_list|()
argument_list|)
decl_stmt|;
name|rsaSignature
operator|.
name|initSign
argument_list|(
name|privateKey
argument_list|)
expr_stmt|;
name|rsaSignature
operator|.
name|update
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
return|return
name|rsaSignature
operator|.
name|sign
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InvalidKeyException
decl||
name|NoSuchAlgorithmException
decl||
name|SignatureException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|OzoneSecurityException
argument_list|(
literal|"Error while creating HMAC hash for "
operator|+
literal|"token."
argument_list|,
name|ex
argument_list|,
name|OzoneSecurityException
operator|.
name|ResultCodes
operator|.
name|SECRET_MANAGER_HMAC_ERROR
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|createPassword (T identifier)
specifier|public
name|byte
index|[]
name|createPassword
parameter_list|(
name|T
name|identifier
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Creating password for identifier: {}, currentKey: {}"
argument_list|,
name|formatTokenId
argument_list|(
name|identifier
argument_list|)
argument_list|,
name|currentKey
operator|.
name|getKeyId
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|password
init|=
literal|null
decl_stmt|;
try|try
block|{
name|password
operator|=
name|createPassword
argument_list|(
name|identifier
operator|.
name|getBytes
argument_list|()
argument_list|,
name|currentKey
operator|.
name|getPrivateKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"Could not store token {}!!"
argument_list|,
name|formatTokenId
argument_list|(
name|identifier
argument_list|)
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
return|return
name|password
return|;
block|}
comment|/**    * Renew a delegation token.    *    * @param token the token to renew    * @param renewer the full principal name of the user doing the renewal    * @return the new expiration time    * @throws InvalidToken           if the token is invalid    * @throws AccessControlException if the user can't renew token    */
DECL|method|renewToken (Token<T> token, String renewer)
specifier|public
specifier|abstract
name|long
name|renewToken
parameter_list|(
name|Token
argument_list|<
name|T
argument_list|>
name|token
parameter_list|,
name|String
name|renewer
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Cancel a token by removing it from store and cache.    *    * @return Identifier of the canceled token    * @throws InvalidToken           for invalid token    * @throws AccessControlException if the user isn't allowed to cancel    */
DECL|method|cancelToken (Token<T> token, String canceller)
specifier|public
specifier|abstract
name|T
name|cancelToken
parameter_list|(
name|Token
argument_list|<
name|T
argument_list|>
name|token
parameter_list|,
name|String
name|canceller
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|incrementCurrentKeyId ()
specifier|public
name|int
name|incrementCurrentKeyId
parameter_list|()
block|{
return|return
name|currentKeyId
operator|.
name|incrementAndGet
argument_list|()
return|;
block|}
DECL|method|getDelegationTokenSeqNum ()
specifier|public
name|int
name|getDelegationTokenSeqNum
parameter_list|()
block|{
return|return
name|tokenSequenceNumber
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|setDelegationTokenSeqNum (int seqNum)
specifier|public
name|void
name|setDelegationTokenSeqNum
parameter_list|(
name|int
name|seqNum
parameter_list|)
block|{
name|tokenSequenceNumber
operator|.
name|set
argument_list|(
name|seqNum
argument_list|)
expr_stmt|;
block|}
DECL|method|incrementDelegationTokenSeqNum ()
specifier|public
name|int
name|incrementDelegationTokenSeqNum
parameter_list|()
block|{
return|return
name|tokenSequenceNumber
operator|.
name|incrementAndGet
argument_list|()
return|;
block|}
comment|/**    * Update the current master key. This is called once by start method before    * tokenRemoverThread is created,    */
DECL|method|updateCurrentKey (KeyPair keyPair)
specifier|private
name|OzoneSecretKey
name|updateCurrentKey
parameter_list|(
name|KeyPair
name|keyPair
parameter_list|)
throws|throws
name|IOException
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Updating the current master key for generating tokens"
argument_list|)
expr_stmt|;
comment|// TODO: fix me based on the certificate expire time to set the key
comment|// expire time.
name|int
name|newCurrentId
init|=
name|incrementCurrentKeyId
argument_list|()
decl_stmt|;
name|OzoneSecretKey
name|newKey
init|=
operator|new
name|OzoneSecretKey
argument_list|(
name|newCurrentId
argument_list|,
operator|-
literal|1
argument_list|,
name|keyPair
argument_list|)
decl_stmt|;
name|currentKey
operator|=
name|newKey
expr_stmt|;
return|return
name|currentKey
return|;
block|}
DECL|method|formatTokenId (T id)
specifier|public
name|String
name|formatTokenId
parameter_list|(
name|T
name|id
parameter_list|)
block|{
return|return
literal|"("
operator|+
name|id
operator|+
literal|")"
return|;
block|}
comment|/**    * Should be called before this object is used.    *    * @param client    * @throws IOException    */
DECL|method|start (CertificateClient client)
specifier|public
specifier|synchronized
name|void
name|start
parameter_list|(
name|CertificateClient
name|client
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|isRunning
argument_list|()
argument_list|)
expr_stmt|;
name|setCertClient
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|updateCurrentKey
argument_list|(
operator|new
name|KeyPair
argument_list|(
name|certClient
operator|.
name|getPublicKey
argument_list|()
argument_list|,
name|certClient
operator|.
name|getPrivateKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setIsRunning
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stops the OzoneDelegationTokenSecretManager.    *    * @throws IOException    */
DECL|method|stop ()
specifier|public
specifier|synchronized
name|void
name|stop
parameter_list|()
throws|throws
name|IOException
block|{
name|setIsRunning
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|getDefaultSignatureAlgorithm ()
specifier|public
name|String
name|getDefaultSignatureAlgorithm
parameter_list|()
block|{
return|return
name|securityConfig
operator|.
name|getSignatureAlgo
argument_list|()
return|;
block|}
DECL|method|getTokenMaxLifetime ()
specifier|public
name|long
name|getTokenMaxLifetime
parameter_list|()
block|{
return|return
name|tokenMaxLifetime
return|;
block|}
DECL|method|getTokenRenewInterval ()
specifier|public
name|long
name|getTokenRenewInterval
parameter_list|()
block|{
return|return
name|tokenRenewInterval
return|;
block|}
DECL|method|getService ()
specifier|public
name|Text
name|getService
parameter_list|()
block|{
return|return
name|service
return|;
block|}
comment|/**    * Is Secret Manager running.    *    * @return true if secret mgr is running    */
DECL|method|isRunning ()
specifier|public
specifier|synchronized
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|running
return|;
block|}
DECL|method|setIsRunning (boolean val)
specifier|public
name|void
name|setIsRunning
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|running
operator|=
name|val
expr_stmt|;
block|}
DECL|method|getCurrentKey ()
specifier|public
name|OzoneSecretKey
name|getCurrentKey
parameter_list|()
block|{
return|return
name|currentKey
return|;
block|}
DECL|method|getCurrentKeyId ()
specifier|public
name|AtomicInteger
name|getCurrentKeyId
parameter_list|()
block|{
return|return
name|currentKeyId
return|;
block|}
DECL|method|getTokenSequenceNumber ()
specifier|public
name|AtomicInteger
name|getTokenSequenceNumber
parameter_list|()
block|{
return|return
name|tokenSequenceNumber
return|;
block|}
DECL|method|getCertClient ()
specifier|public
name|CertificateClient
name|getCertClient
parameter_list|()
block|{
return|return
name|certClient
return|;
block|}
DECL|method|setCertClient (CertificateClient client)
specifier|public
name|void
name|setCertClient
parameter_list|(
name|CertificateClient
name|client
parameter_list|)
block|{
name|this
operator|.
name|certClient
operator|=
name|client
expr_stmt|;
block|}
block|}
end_class

end_unit

