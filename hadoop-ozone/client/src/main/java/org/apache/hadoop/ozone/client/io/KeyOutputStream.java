begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.client.io
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|client
operator|.
name|io
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|DatanodeDetails
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|ChecksumType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|client
operator|.
name|HddsClientUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ContainerNotOpenException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ExcludeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|pipeline
operator|.
name|Pipeline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|pipeline
operator|.
name|PipelineID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|om
operator|.
name|helpers
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|ReplicationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|ReplicationFactor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|om
operator|.
name|protocol
operator|.
name|OzoneManagerProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|XceiverClientManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ratis
operator|.
name|protocol
operator|.
name|AlreadyClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ratis
operator|.
name|protocol
operator|.
name|GroupMismatchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ratis
operator|.
name|protocol
operator|.
name|NotReplicatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ratis
operator|.
name|protocol
operator|.
name|RaftRetryFailureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_comment
comment|/**  * Maintaining a list of BlockInputStream. Write based on offset.  *  * Note that this may write to multiple containers in one write call. In case  * that first container succeeded but later ones failed, the succeeded writes  * are not rolled back.  *  * TODO : currently not support multi-thread access.  */
end_comment

begin_class
DECL|class|KeyOutputStream
specifier|public
class|class
name|KeyOutputStream
extends|extends
name|OutputStream
block|{
comment|/**    * Defines stream action while calling handleFlushOrClose.    */
DECL|enum|StreamAction
enum|enum
name|StreamAction
block|{
DECL|enumConstant|FLUSH
DECL|enumConstant|CLOSE
DECL|enumConstant|FULL
name|FLUSH
block|,
name|CLOSE
block|,
name|FULL
block|}
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|KeyOutputStream
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|feInfo
specifier|private
name|FileEncryptionInfo
name|feInfo
decl_stmt|;
DECL|field|retryPolicyMap
specifier|private
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Throwable
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|retryPolicyMap
decl_stmt|;
DECL|field|retryCount
specifier|private
name|int
name|retryCount
decl_stmt|;
DECL|field|offset
specifier|private
name|long
name|offset
decl_stmt|;
DECL|field|blockOutputStreamEntryPool
specifier|private
specifier|final
name|BlockOutputStreamEntryPool
name|blockOutputStreamEntryPool
decl_stmt|;
comment|/**    * A constructor for testing purpose only.    */
annotation|@
name|VisibleForTesting
DECL|method|KeyOutputStream ()
specifier|public
name|KeyOutputStream
parameter_list|()
block|{
name|closed
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|retryPolicyMap
operator|=
name|HddsClientUtils
operator|.
name|getExceptionList
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|Function
operator|.
name|identity
argument_list|()
argument_list|,
name|e
lambda|->
name|RetryPolicies
operator|.
name|TRY_ONCE_THEN_FAIL
argument_list|)
argument_list|)
expr_stmt|;
name|retryCount
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|blockOutputStreamEntryPool
operator|=
operator|new
name|BlockOutputStreamEntryPool
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStreamEntries ()
specifier|public
name|List
argument_list|<
name|BlockOutputStreamEntry
argument_list|>
name|getStreamEntries
parameter_list|()
block|{
return|return
name|blockOutputStreamEntryPool
operator|.
name|getStreamEntries
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getXceiverClientManager ()
specifier|public
name|XceiverClientManager
name|getXceiverClientManager
parameter_list|()
block|{
return|return
name|blockOutputStreamEntryPool
operator|.
name|getXceiverClientManager
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getLocationInfoList ()
specifier|public
name|List
argument_list|<
name|OmKeyLocationInfo
argument_list|>
name|getLocationInfoList
parameter_list|()
block|{
return|return
name|blockOutputStreamEntryPool
operator|.
name|getLocationInfoList
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getRetryCount ()
specifier|public
name|int
name|getRetryCount
parameter_list|()
block|{
return|return
name|retryCount
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"parameternumber"
argument_list|)
DECL|method|KeyOutputStream (OpenKeySession handler, XceiverClientManager xceiverClientManager, OzoneManagerProtocol omClient, int chunkSize, String requestId, ReplicationFactor factor, ReplicationType type, long bufferFlushSize, long bufferMaxSize, long size, long watchTimeout, ChecksumType checksumType, int bytesPerChecksum, String uploadID, int partNumber, boolean isMultipart, int maxRetryCount, long retryInterval)
specifier|public
name|KeyOutputStream
parameter_list|(
name|OpenKeySession
name|handler
parameter_list|,
name|XceiverClientManager
name|xceiverClientManager
parameter_list|,
name|OzoneManagerProtocol
name|omClient
parameter_list|,
name|int
name|chunkSize
parameter_list|,
name|String
name|requestId
parameter_list|,
name|ReplicationFactor
name|factor
parameter_list|,
name|ReplicationType
name|type
parameter_list|,
name|long
name|bufferFlushSize
parameter_list|,
name|long
name|bufferMaxSize
parameter_list|,
name|long
name|size
parameter_list|,
name|long
name|watchTimeout
parameter_list|,
name|ChecksumType
name|checksumType
parameter_list|,
name|int
name|bytesPerChecksum
parameter_list|,
name|String
name|uploadID
parameter_list|,
name|int
name|partNumber
parameter_list|,
name|boolean
name|isMultipart
parameter_list|,
name|int
name|maxRetryCount
parameter_list|,
name|long
name|retryInterval
parameter_list|)
block|{
name|OmKeyInfo
name|info
init|=
name|handler
operator|.
name|getKeyInfo
argument_list|()
decl_stmt|;
name|blockOutputStreamEntryPool
operator|=
operator|new
name|BlockOutputStreamEntryPool
argument_list|(
name|omClient
argument_list|,
name|chunkSize
argument_list|,
name|requestId
argument_list|,
name|factor
argument_list|,
name|type
argument_list|,
name|bufferFlushSize
argument_list|,
name|bufferMaxSize
argument_list|,
name|size
argument_list|,
name|watchTimeout
argument_list|,
name|checksumType
argument_list|,
name|bytesPerChecksum
argument_list|,
name|uploadID
argument_list|,
name|partNumber
argument_list|,
name|isMultipart
argument_list|,
name|info
argument_list|,
name|xceiverClientManager
argument_list|,
name|handler
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Retrieve the file encryption key info, null if file is not in
comment|// encrypted bucket.
name|this
operator|.
name|feInfo
operator|=
name|info
operator|.
name|getFileEncryptionInfo
argument_list|()
expr_stmt|;
name|this
operator|.
name|retryPolicyMap
operator|=
name|HddsClientUtils
operator|.
name|getRetryPolicyByException
argument_list|(
name|maxRetryCount
argument_list|,
name|retryInterval
argument_list|)
expr_stmt|;
name|this
operator|.
name|retryCount
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * When a key is opened, it is possible that there are some blocks already    * allocated to it for this open session. In this case, to make use of these    * blocks, we need to add these blocks to stream entries. But, a key's version    * also includes blocks from previous versions, we need to avoid adding these    * old blocks to stream entries, because these old blocks should not be picked    * for write. To do this, the following method checks that, only those    * blocks created in this particular open version are added to stream entries.    *    * @param version the set of blocks that are pre-allocated.    * @param openVersion the version corresponding to the pre-allocation.    * @throws IOException    */
DECL|method|addPreallocateBlocks (OmKeyLocationInfoGroup version, long openVersion)
specifier|public
name|void
name|addPreallocateBlocks
parameter_list|(
name|OmKeyLocationInfoGroup
name|version
parameter_list|,
name|long
name|openVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|blockOutputStreamEntryPool
operator|.
name|addPreallocateBlocks
argument_list|(
name|version
argument_list|,
name|openVersion
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Try to write the bytes sequence b[off:off+len) to streams.    *    * NOTE: Throws exception if the data could not fit into the remaining space.    * In which case nothing will be written.    * TODO:May need to revisit this behaviour.    *    * @param b byte data    * @param off starting offset    * @param len length to write    * @throws IOException    */
annotation|@
name|Override
DECL|method|write (byte[] b, int off, int len)
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
if|if
condition|(
operator|(
name|off
operator|<
literal|0
operator|)
operator|||
operator|(
name|off
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
name|len
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|handleWrite
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|handleWrite (byte[] b, int off, long len, boolean retry)
specifier|private
name|void
name|handleWrite
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|long
name|len
parameter_list|,
name|boolean
name|retry
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|BlockOutputStreamEntry
name|current
init|=
name|blockOutputStreamEntryPool
operator|.
name|allocateBlockIfNeeded
argument_list|()
decl_stmt|;
comment|// length(len) will be in int range if the call is happening through
comment|// write API of blockOutputStream. Length can be in long range if it
comment|// comes via Exception path.
name|int
name|writeLen
init|=
name|Math
operator|.
name|min
argument_list|(
operator|(
name|int
operator|)
name|len
argument_list|,
operator|(
name|int
operator|)
name|current
operator|.
name|getRemaining
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|currentPos
init|=
name|current
operator|.
name|getWrittenDataLength
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|retry
condition|)
block|{
name|current
operator|.
name|writeOnRetry
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|writeLen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|writeLen
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// for the current iteration, totalDataWritten - currentPos gives the
comment|// amount of data already written to the buffer
comment|// In the retryPath, the total data to be written will always be equal
comment|// to or less than the max length of the buffer allocated.
comment|// The len specified here is the combined sum of the data length of
comment|// the buffers
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|retry
operator|||
name|len
operator|<=
name|blockOutputStreamEntryPool
operator|.
name|getStreamBufferMaxSize
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|dataWritten
init|=
call|(
name|int
call|)
argument_list|(
name|current
operator|.
name|getWrittenDataLength
argument_list|()
operator|-
name|currentPos
argument_list|)
decl_stmt|;
name|writeLen
operator|=
name|retry
condition|?
operator|(
name|int
operator|)
name|len
else|:
name|dataWritten
expr_stmt|;
comment|// In retry path, the data written is already accounted in offset.
if|if
condition|(
operator|!
name|retry
condition|)
block|{
name|offset
operator|+=
name|writeLen
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"writeLen {}, total len {}"
argument_list|,
name|writeLen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|handleException
argument_list|(
name|current
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|.
name|getRemaining
argument_list|()
operator|<=
literal|0
condition|)
block|{
comment|// since the current block is already written close the stream.
name|handleFlushOrClose
argument_list|(
name|StreamAction
operator|.
name|FULL
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|writeLen
expr_stmt|;
name|off
operator|+=
name|writeLen
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|markStreamClosed
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * It performs following actions :    * a. Updates the committed length at datanode for the current stream in    * datanode.    * b. Reads the data from the underlying buffer and writes it the next stream.    *    * @param streamEntry StreamEntry    * @param exception   actual exception that occurred    * @throws IOException Throws IOException if Write fails    */
DECL|method|handleException (BlockOutputStreamEntry streamEntry, IOException exception)
specifier|private
name|void
name|handleException
parameter_list|(
name|BlockOutputStreamEntry
name|streamEntry
parameter_list|,
name|IOException
name|exception
parameter_list|)
throws|throws
name|IOException
block|{
name|Throwable
name|t
init|=
name|HddsClientUtils
operator|.
name|checkForException
argument_list|(
name|exception
argument_list|)
decl_stmt|;
name|boolean
name|retryFailure
init|=
name|checkForRetryFailure
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|boolean
name|closedContainerException
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|retryFailure
condition|)
block|{
name|closedContainerException
operator|=
name|checkIfContainerIsClosed
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|Pipeline
name|pipeline
init|=
name|streamEntry
operator|.
name|getPipeline
argument_list|()
decl_stmt|;
name|PipelineID
name|pipelineId
init|=
name|pipeline
operator|.
name|getId
argument_list|()
decl_stmt|;
name|long
name|totalSuccessfulFlushedData
init|=
name|streamEntry
operator|.
name|getTotalAckDataLength
argument_list|()
decl_stmt|;
comment|//set the correct length for the current stream
name|streamEntry
operator|.
name|setCurrentPosition
argument_list|(
name|totalSuccessfulFlushedData
argument_list|)
expr_stmt|;
name|long
name|bufferedDataLen
init|=
name|blockOutputStreamEntryPool
operator|.
name|computeBufferData
argument_list|()
decl_stmt|;
if|if
condition|(
name|closedContainerException
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encountered exception {}. The last committed block length is {}, "
operator|+
literal|"uncommitted data length is {} retry count {}"
argument_list|,
name|exception
argument_list|,
name|totalSuccessfulFlushedData
argument_list|,
name|bufferedDataLen
argument_list|,
name|retryCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception {} on the pipeline {}. "
operator|+
literal|"The last committed block length is {}, "
operator|+
literal|"uncommitted data length is {} retry count {}"
argument_list|,
name|exception
argument_list|,
name|pipeline
argument_list|,
name|totalSuccessfulFlushedData
argument_list|,
name|bufferedDataLen
argument_list|,
name|retryCount
argument_list|)
expr_stmt|;
block|}
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|bufferedDataLen
operator|<=
name|blockOutputStreamEntryPool
operator|.
name|getStreamBufferMaxSize
argument_list|()
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offset
operator|-
name|blockOutputStreamEntryPool
operator|.
name|getKeyLength
argument_list|()
operator|==
name|bufferedDataLen
argument_list|)
expr_stmt|;
name|long
name|containerId
init|=
name|streamEntry
operator|.
name|getBlockID
argument_list|()
operator|.
name|getContainerID
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDetails
argument_list|>
name|failedServers
init|=
name|streamEntry
operator|.
name|getFailedServers
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|failedServers
argument_list|)
expr_stmt|;
name|ExcludeList
name|excludeList
init|=
name|blockOutputStreamEntryPool
operator|.
name|getExcludeList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|failedServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|excludeList
operator|.
name|addDatanodes
argument_list|(
name|failedServers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closedContainerException
condition|)
block|{
name|excludeList
operator|.
name|addConatinerId
argument_list|(
name|ContainerID
operator|.
name|valueof
argument_list|(
name|containerId
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retryFailure
operator|||
name|t
operator|instanceof
name|TimeoutException
operator|||
name|t
operator|instanceof
name|GroupMismatchException
operator|||
name|t
operator|instanceof
name|NotReplicatedException
condition|)
block|{
name|excludeList
operator|.
name|addPipeline
argument_list|(
name|pipelineId
argument_list|)
expr_stmt|;
block|}
comment|// just clean up the current stream.
name|streamEntry
operator|.
name|cleanup
argument_list|(
name|retryFailure
argument_list|)
expr_stmt|;
comment|// discard all subsequent blocks the containers and pipelines which
comment|// are in the exclude list so that, the very next retry should never
comment|// write data on the  closed container/pipeline
if|if
condition|(
name|closedContainerException
condition|)
block|{
comment|// discard subsequent pre allocated blocks from the streamEntries list
comment|// from the closed container
name|blockOutputStreamEntryPool
operator|.
name|discardPreallocatedBlocks
argument_list|(
name|streamEntry
operator|.
name|getBlockID
argument_list|()
operator|.
name|getContainerID
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// In case there is timeoutException or Watch for commit happening over
comment|// majority or the client connection failure to the leader in the
comment|// pipeline, just discard all the pre allocated blocks on this pipeline.
comment|// Next block allocation will happen with excluding this specific pipeline
comment|// This will ensure if 2 way commit happens , it cannot span over multiple
comment|// blocks
name|blockOutputStreamEntryPool
operator|.
name|discardPreallocatedBlocks
argument_list|(
operator|-
literal|1
argument_list|,
name|pipelineId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufferedDataLen
operator|>
literal|0
condition|)
block|{
comment|// If the data is still cached in the underlying stream, we need to
comment|// allocate new block and write this data in the datanode.
name|handleRetry
argument_list|(
name|exception
argument_list|,
name|bufferedDataLen
argument_list|)
expr_stmt|;
comment|// reset the retryCount after handling the exception
name|retryCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|method|markStreamClosed ()
specifier|private
name|void
name|markStreamClosed
parameter_list|()
block|{
name|blockOutputStreamEntryPool
operator|.
name|cleanup
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|handleRetry (IOException exception, long len)
specifier|private
name|void
name|handleRetry
parameter_list|(
name|IOException
name|exception
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|RetryPolicy
name|retryPolicy
init|=
name|retryPolicyMap
operator|.
name|get
argument_list|(
name|HddsClientUtils
operator|.
name|checkForException
argument_list|(
name|exception
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|retryPolicy
operator|==
literal|null
condition|)
block|{
name|retryPolicy
operator|=
name|retryPolicyMap
operator|.
name|get
argument_list|(
name|Exception
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
name|RetryPolicy
operator|.
name|RetryAction
name|action
decl_stmt|;
try|try
block|{
name|action
operator|=
name|retryPolicy
operator|.
name|shouldRetry
argument_list|(
name|exception
argument_list|,
name|retryCount
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|instanceof
name|IOException
condition|?
operator|(
name|IOException
operator|)
name|e
else|:
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|action
operator|.
name|action
operator|==
name|RetryPolicy
operator|.
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|FAIL
condition|)
block|{
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|action
operator|.
name|reason
operator|!=
literal|null
condition|)
block|{
name|msg
operator|=
literal|"Retry request failed. "
operator|+
name|action
operator|.
name|reason
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|,
name|exception
argument_list|)
throw|;
block|}
comment|// Throw the exception if the thread is interrupted
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying for retry"
argument_list|)
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|action
operator|.
name|action
operator|==
name|RetryPolicy
operator|.
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|.
name|delayMillis
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|action
operator|.
name|delayMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted: action="
operator|+
name|action
operator|+
literal|", retry policy="
operator|+
name|retryPolicy
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|retryCount
operator|++
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Retrying Write request. Already tried "
operator|+
name|retryCount
operator|+
literal|" time(s); retry policy is "
operator|+
name|retryPolicy
argument_list|)
expr_stmt|;
name|handleWrite
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks if the provided exception signifies retry failure in ratis client.    * In case of retry failure, ratis client throws RaftRetryFailureException    * and all succeeding operations are failed with AlreadyClosedException.    */
DECL|method|checkForRetryFailure (Throwable t)
specifier|private
name|boolean
name|checkForRetryFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|t
operator|instanceof
name|RaftRetryFailureException
operator|||
name|t
operator|instanceof
name|AlreadyClosedException
return|;
block|}
DECL|method|checkIfContainerIsClosed (Throwable t)
specifier|private
name|boolean
name|checkIfContainerIsClosed
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|t
operator|instanceof
name|ContainerNotOpenException
return|;
block|}
annotation|@
name|Override
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|checkNotClosed
argument_list|()
expr_stmt|;
name|handleFlushOrClose
argument_list|(
name|StreamAction
operator|.
name|FLUSH
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close or Flush the latest outputStream depending upon the action.    * This function gets called when while write is going on, the current stream    * gets full or explicit flush or close request is made by client. when the    * stream gets full and we try to close the stream , we might end up hitting    * an exception in the exception handling path, we write the data residing in    * in the buffer pool to a new Block. In cases, as such, when the data gets    * written to new stream , it will be at max half full. In such cases, we    * should just write the data and not close the stream as the block won't be    * completely full.    *    * @param op Flag which decides whether to call close or flush on the    *           outputStream.    * @throws IOException In case, flush or close fails with exception.    */
DECL|method|handleFlushOrClose (StreamAction op)
specifier|private
name|void
name|handleFlushOrClose
parameter_list|(
name|StreamAction
name|op
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockOutputStreamEntryPool
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|BlockOutputStreamEntry
name|entry
init|=
name|blockOutputStreamEntryPool
operator|.
name|getCurrentStreamEntry
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Collection
argument_list|<
name|DatanodeDetails
argument_list|>
name|failedServers
init|=
name|entry
operator|.
name|getFailedServers
argument_list|()
decl_stmt|;
comment|// failed servers can be null in case there is no data written in
comment|// the stream
if|if
condition|(
name|failedServers
operator|!=
literal|null
operator|&&
operator|!
name|failedServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|blockOutputStreamEntryPool
operator|.
name|getExcludeList
argument_list|()
operator|.
name|addDatanodes
argument_list|(
name|failedServers
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|CLOSE
case|:
name|entry
operator|.
name|close
argument_list|()
expr_stmt|;
break|break;
case|case
name|FULL
case|:
if|if
condition|(
name|entry
operator|.
name|getRemaining
argument_list|()
operator|==
literal|0
condition|)
block|{
name|entry
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FLUSH
case|:
name|entry
operator|.
name|flush
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid Operation"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|handleException
argument_list|(
name|entry
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|markStreamClosed
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Commit the key to OM, this will add the blocks as the new key blocks.    *    * @throws IOException    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
name|closed
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|handleFlushOrClose
argument_list|(
name|StreamAction
operator|.
name|CLOSE
argument_list|)
expr_stmt|;
name|blockOutputStreamEntryPool
operator|.
name|commitKey
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
name|ioe
throw|;
block|}
finally|finally
block|{
name|blockOutputStreamEntryPool
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getCommitUploadPartInfo ()
specifier|public
name|OmMultipartCommitUploadPartInfo
name|getCommitUploadPartInfo
parameter_list|()
block|{
return|return
name|blockOutputStreamEntryPool
operator|.
name|getCommitUploadPartInfo
argument_list|()
return|;
block|}
DECL|method|getFileEncryptionInfo ()
specifier|public
name|FileEncryptionInfo
name|getFileEncryptionInfo
parameter_list|()
block|{
return|return
name|feInfo
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getExcludeList ()
specifier|public
name|ExcludeList
name|getExcludeList
parameter_list|()
block|{
return|return
name|blockOutputStreamEntryPool
operator|.
name|getExcludeList
argument_list|()
return|;
block|}
comment|/**    * Builder class of KeyOutputStream.    */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
block|{
DECL|field|openHandler
specifier|private
name|OpenKeySession
name|openHandler
decl_stmt|;
DECL|field|xceiverManager
specifier|private
name|XceiverClientManager
name|xceiverManager
decl_stmt|;
DECL|field|omClient
specifier|private
name|OzoneManagerProtocol
name|omClient
decl_stmt|;
DECL|field|chunkSize
specifier|private
name|int
name|chunkSize
decl_stmt|;
DECL|field|requestID
specifier|private
name|String
name|requestID
decl_stmt|;
DECL|field|type
specifier|private
name|ReplicationType
name|type
decl_stmt|;
DECL|field|factor
specifier|private
name|ReplicationFactor
name|factor
decl_stmt|;
DECL|field|streamBufferFlushSize
specifier|private
name|long
name|streamBufferFlushSize
decl_stmt|;
DECL|field|streamBufferMaxSize
specifier|private
name|long
name|streamBufferMaxSize
decl_stmt|;
DECL|field|blockSize
specifier|private
name|long
name|blockSize
decl_stmt|;
DECL|field|watchTimeout
specifier|private
name|long
name|watchTimeout
decl_stmt|;
DECL|field|checksumType
specifier|private
name|ChecksumType
name|checksumType
decl_stmt|;
DECL|field|bytesPerChecksum
specifier|private
name|int
name|bytesPerChecksum
decl_stmt|;
DECL|field|multipartUploadID
specifier|private
name|String
name|multipartUploadID
decl_stmt|;
DECL|field|multipartNumber
specifier|private
name|int
name|multipartNumber
decl_stmt|;
DECL|field|isMultipartKey
specifier|private
name|boolean
name|isMultipartKey
decl_stmt|;
DECL|field|maxRetryCount
specifier|private
name|int
name|maxRetryCount
decl_stmt|;
DECL|field|retryInterval
specifier|private
name|long
name|retryInterval
decl_stmt|;
DECL|method|setMultipartUploadID (String uploadID)
specifier|public
name|Builder
name|setMultipartUploadID
parameter_list|(
name|String
name|uploadID
parameter_list|)
block|{
name|this
operator|.
name|multipartUploadID
operator|=
name|uploadID
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setMultipartNumber (int partNumber)
specifier|public
name|Builder
name|setMultipartNumber
parameter_list|(
name|int
name|partNumber
parameter_list|)
block|{
name|this
operator|.
name|multipartNumber
operator|=
name|partNumber
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setHandler (OpenKeySession handler)
specifier|public
name|Builder
name|setHandler
parameter_list|(
name|OpenKeySession
name|handler
parameter_list|)
block|{
name|this
operator|.
name|openHandler
operator|=
name|handler
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setXceiverClientManager (XceiverClientManager manager)
specifier|public
name|Builder
name|setXceiverClientManager
parameter_list|(
name|XceiverClientManager
name|manager
parameter_list|)
block|{
name|this
operator|.
name|xceiverManager
operator|=
name|manager
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setOmClient (OzoneManagerProtocol client)
specifier|public
name|Builder
name|setOmClient
parameter_list|(
name|OzoneManagerProtocol
name|client
parameter_list|)
block|{
name|this
operator|.
name|omClient
operator|=
name|client
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setChunkSize (int size)
specifier|public
name|Builder
name|setChunkSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|chunkSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setRequestID (String id)
specifier|public
name|Builder
name|setRequestID
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|requestID
operator|=
name|id
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setType (ReplicationType replicationType)
specifier|public
name|Builder
name|setType
parameter_list|(
name|ReplicationType
name|replicationType
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|replicationType
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setFactor (ReplicationFactor replicationFactor)
specifier|public
name|Builder
name|setFactor
parameter_list|(
name|ReplicationFactor
name|replicationFactor
parameter_list|)
block|{
name|this
operator|.
name|factor
operator|=
name|replicationFactor
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setStreamBufferFlushSize (long size)
specifier|public
name|Builder
name|setStreamBufferFlushSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|streamBufferFlushSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setStreamBufferMaxSize (long size)
specifier|public
name|Builder
name|setStreamBufferMaxSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|streamBufferMaxSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBlockSize (long size)
specifier|public
name|Builder
name|setBlockSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|blockSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setWatchTimeout (long timeout)
specifier|public
name|Builder
name|setWatchTimeout
parameter_list|(
name|long
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|watchTimeout
operator|=
name|timeout
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setChecksumType (ChecksumType cType)
specifier|public
name|Builder
name|setChecksumType
parameter_list|(
name|ChecksumType
name|cType
parameter_list|)
block|{
name|this
operator|.
name|checksumType
operator|=
name|cType
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBytesPerChecksum (int bytes)
specifier|public
name|Builder
name|setBytesPerChecksum
parameter_list|(
name|int
name|bytes
parameter_list|)
block|{
name|this
operator|.
name|bytesPerChecksum
operator|=
name|bytes
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setIsMultipartKey (boolean isMultipart)
specifier|public
name|Builder
name|setIsMultipartKey
parameter_list|(
name|boolean
name|isMultipart
parameter_list|)
block|{
name|this
operator|.
name|isMultipartKey
operator|=
name|isMultipart
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setMaxRetryCount (int maxCount)
specifier|public
name|Builder
name|setMaxRetryCount
parameter_list|(
name|int
name|maxCount
parameter_list|)
block|{
name|this
operator|.
name|maxRetryCount
operator|=
name|maxCount
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setRetryInterval (long retryIntervalInMS)
specifier|public
name|Builder
name|setRetryInterval
parameter_list|(
name|long
name|retryIntervalInMS
parameter_list|)
block|{
name|this
operator|.
name|retryInterval
operator|=
name|retryIntervalInMS
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|build ()
specifier|public
name|KeyOutputStream
name|build
parameter_list|()
block|{
return|return
operator|new
name|KeyOutputStream
argument_list|(
name|openHandler
argument_list|,
name|xceiverManager
argument_list|,
name|omClient
argument_list|,
name|chunkSize
argument_list|,
name|requestID
argument_list|,
name|factor
argument_list|,
name|type
argument_list|,
name|streamBufferFlushSize
argument_list|,
name|streamBufferMaxSize
argument_list|,
name|blockSize
argument_list|,
name|watchTimeout
argument_list|,
name|checksumType
argument_list|,
name|bytesPerChecksum
argument_list|,
name|multipartUploadID
argument_list|,
name|multipartNumber
argument_list|,
name|isMultipartKey
argument_list|,
name|maxRetryCount
argument_list|,
name|retryInterval
argument_list|)
return|;
block|}
block|}
comment|/**    * Verify that the output stream is open. Non blocking; this gives    * the last state of the volatile {@link #closed} field.    * @throws IOException if the connection is closed.    */
DECL|method|checkNotClosed ()
specifier|private
name|void
name|checkNotClosed
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|": "
operator|+
name|FSExceptionMessages
operator|.
name|STREAM_IS_CLOSED
operator|+
literal|" Key: "
operator|+
name|blockOutputStreamEntryPool
operator|.
name|getKeyName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

