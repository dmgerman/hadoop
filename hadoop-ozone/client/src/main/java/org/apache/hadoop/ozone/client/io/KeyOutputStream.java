begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.client.io
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|client
operator|.
name|io
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|DatanodeDetails
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|datanode
operator|.
name|proto
operator|.
name|ContainerProtos
operator|.
name|ChecksumType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|ContainerID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ContainerNotOpenException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|storage
operator|.
name|BufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ExcludeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|pipeline
operator|.
name|PipelineID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|client
operator|.
name|OzoneClientUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|om
operator|.
name|helpers
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|ReplicationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HddsProtos
operator|.
name|ReplicationFactor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|om
operator|.
name|protocol
operator|.
name|OzoneManagerProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdds
operator|.
name|scm
operator|.
name|XceiverClientManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ratis
operator|.
name|protocol
operator|.
name|AlreadyClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ratis
operator|.
name|protocol
operator|.
name|GroupMismatchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ratis
operator|.
name|protocol
operator|.
name|RaftRetryFailureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_comment
comment|/**  * Maintaining a list of BlockInputStream. Write based on offset.  *  * Note that this may write to multiple containers in one write call. In case  * that first container succeeded but later ones failed, the succeeded writes  * are not rolled back.  *  * TODO : currently not support multi-thread access.  */
end_comment

begin_class
DECL|class|KeyOutputStream
specifier|public
class|class
name|KeyOutputStream
extends|extends
name|OutputStream
block|{
comment|/**    * Defines stream action while calling handleFlushOrClose.    */
DECL|enum|StreamAction
enum|enum
name|StreamAction
block|{
DECL|enumConstant|FLUSH
DECL|enumConstant|CLOSE
DECL|enumConstant|FULL
name|FLUSH
block|,
name|CLOSE
block|,
name|FULL
block|}
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|KeyOutputStream
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// array list's get(index) is O(1)
DECL|field|streamEntries
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|BlockOutputStreamEntry
argument_list|>
name|streamEntries
decl_stmt|;
DECL|field|currentStreamIndex
specifier|private
name|int
name|currentStreamIndex
decl_stmt|;
DECL|field|omClient
specifier|private
specifier|final
name|OzoneManagerProtocol
name|omClient
decl_stmt|;
DECL|field|keyArgs
specifier|private
specifier|final
name|OmKeyArgs
name|keyArgs
decl_stmt|;
DECL|field|openID
specifier|private
specifier|final
name|long
name|openID
decl_stmt|;
DECL|field|xceiverClientManager
specifier|private
specifier|final
name|XceiverClientManager
name|xceiverClientManager
decl_stmt|;
DECL|field|chunkSize
specifier|private
specifier|final
name|int
name|chunkSize
decl_stmt|;
DECL|field|requestID
specifier|private
specifier|final
name|String
name|requestID
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|streamBufferFlushSize
specifier|private
specifier|final
name|long
name|streamBufferFlushSize
decl_stmt|;
DECL|field|streamBufferMaxSize
specifier|private
specifier|final
name|long
name|streamBufferMaxSize
decl_stmt|;
DECL|field|watchTimeout
specifier|private
specifier|final
name|long
name|watchTimeout
decl_stmt|;
DECL|field|blockSize
specifier|private
specifier|final
name|long
name|blockSize
decl_stmt|;
DECL|field|bytesPerChecksum
specifier|private
specifier|final
name|int
name|bytesPerChecksum
decl_stmt|;
DECL|field|checksumType
specifier|private
specifier|final
name|ChecksumType
name|checksumType
decl_stmt|;
DECL|field|bufferPool
specifier|private
specifier|final
name|BufferPool
name|bufferPool
decl_stmt|;
DECL|field|commitUploadPartInfo
specifier|private
name|OmMultipartCommitUploadPartInfo
name|commitUploadPartInfo
decl_stmt|;
DECL|field|feInfo
specifier|private
name|FileEncryptionInfo
name|feInfo
decl_stmt|;
DECL|field|excludeList
specifier|private
name|ExcludeList
name|excludeList
decl_stmt|;
DECL|field|retryPolicy
specifier|private
specifier|final
name|RetryPolicy
name|retryPolicy
decl_stmt|;
DECL|field|retryCount
specifier|private
name|int
name|retryCount
decl_stmt|;
DECL|field|offset
specifier|private
name|long
name|offset
decl_stmt|;
comment|/**    * A constructor for testing purpose only.    */
annotation|@
name|VisibleForTesting
annotation|@
name|SuppressWarnings
argument_list|(
literal|"parameternumber"
argument_list|)
DECL|method|KeyOutputStream ()
specifier|public
name|KeyOutputStream
parameter_list|()
block|{
name|streamEntries
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|omClient
operator|=
literal|null
expr_stmt|;
name|keyArgs
operator|=
literal|null
expr_stmt|;
name|openID
operator|=
operator|-
literal|1
expr_stmt|;
name|xceiverClientManager
operator|=
literal|null
expr_stmt|;
name|chunkSize
operator|=
literal|0
expr_stmt|;
name|requestID
operator|=
literal|null
expr_stmt|;
name|closed
operator|=
literal|false
expr_stmt|;
name|streamBufferFlushSize
operator|=
literal|0
expr_stmt|;
name|streamBufferMaxSize
operator|=
literal|0
expr_stmt|;
name|bufferPool
operator|=
operator|new
name|BufferPool
argument_list|(
name|chunkSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|watchTimeout
operator|=
literal|0
expr_stmt|;
name|blockSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|checksumType
operator|=
name|ChecksumType
operator|.
name|valueOf
argument_list|(
name|OzoneConfigKeys
operator|.
name|OZONE_CLIENT_CHECKSUM_TYPE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|bytesPerChecksum
operator|=
name|OzoneConfigKeys
operator|.
name|OZONE_CLIENT_BYTES_PER_CHECKSUM_DEFAULT_BYTES
expr_stmt|;
comment|// Default is 1MB
name|this
operator|.
name|retryPolicy
operator|=
name|RetryPolicies
operator|.
name|TRY_ONCE_THEN_FAIL
expr_stmt|;
name|retryCount
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStreamEntries ()
specifier|public
name|List
argument_list|<
name|BlockOutputStreamEntry
argument_list|>
name|getStreamEntries
parameter_list|()
block|{
return|return
name|streamEntries
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getXceiverClientManager ()
specifier|public
name|XceiverClientManager
name|getXceiverClientManager
parameter_list|()
block|{
return|return
name|xceiverClientManager
return|;
block|}
DECL|method|getLocationInfoList ()
specifier|public
name|List
argument_list|<
name|OmKeyLocationInfo
argument_list|>
name|getLocationInfoList
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|OmKeyLocationInfo
argument_list|>
name|locationInfoList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockOutputStreamEntry
name|streamEntry
range|:
name|streamEntries
control|)
block|{
name|OmKeyLocationInfo
name|info
init|=
operator|new
name|OmKeyLocationInfo
operator|.
name|Builder
argument_list|()
operator|.
name|setBlockID
argument_list|(
name|streamEntry
operator|.
name|getBlockID
argument_list|()
argument_list|)
operator|.
name|setLength
argument_list|(
name|streamEntry
operator|.
name|getCurrentPosition
argument_list|()
argument_list|)
operator|.
name|setOffset
argument_list|(
literal|0
argument_list|)
operator|.
name|setToken
argument_list|(
name|streamEntry
operator|.
name|getToken
argument_list|()
argument_list|)
operator|.
name|setPipeline
argument_list|(
name|streamEntry
operator|.
name|getPipeline
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"block written "
operator|+
name|streamEntry
operator|.
name|getBlockID
argument_list|()
operator|+
literal|", length "
operator|+
name|streamEntry
operator|.
name|getCurrentPosition
argument_list|()
operator|+
literal|" bcsID "
operator|+
name|streamEntry
operator|.
name|getBlockID
argument_list|()
operator|.
name|getBlockCommitSequenceId
argument_list|()
argument_list|)
expr_stmt|;
name|locationInfoList
operator|.
name|add
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|locationInfoList
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getRetryCount ()
specifier|public
name|int
name|getRetryCount
parameter_list|()
block|{
return|return
name|retryCount
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"parameternumber"
argument_list|)
DECL|method|KeyOutputStream (OpenKeySession handler, XceiverClientManager xceiverClientManager, OzoneManagerProtocol omClient, int chunkSize, String requestId, ReplicationFactor factor, ReplicationType type, long bufferFlushSize, long bufferMaxSize, long size, long watchTimeout, ChecksumType checksumType, int bytesPerChecksum, String uploadID, int partNumber, boolean isMultipart, int maxRetryCount)
specifier|public
name|KeyOutputStream
parameter_list|(
name|OpenKeySession
name|handler
parameter_list|,
name|XceiverClientManager
name|xceiverClientManager
parameter_list|,
name|OzoneManagerProtocol
name|omClient
parameter_list|,
name|int
name|chunkSize
parameter_list|,
name|String
name|requestId
parameter_list|,
name|ReplicationFactor
name|factor
parameter_list|,
name|ReplicationType
name|type
parameter_list|,
name|long
name|bufferFlushSize
parameter_list|,
name|long
name|bufferMaxSize
parameter_list|,
name|long
name|size
parameter_list|,
name|long
name|watchTimeout
parameter_list|,
name|ChecksumType
name|checksumType
parameter_list|,
name|int
name|bytesPerChecksum
parameter_list|,
name|String
name|uploadID
parameter_list|,
name|int
name|partNumber
parameter_list|,
name|boolean
name|isMultipart
parameter_list|,
name|int
name|maxRetryCount
parameter_list|)
block|{
name|this
operator|.
name|streamEntries
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentStreamIndex
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|omClient
operator|=
name|omClient
expr_stmt|;
name|OmKeyInfo
name|info
init|=
name|handler
operator|.
name|getKeyInfo
argument_list|()
decl_stmt|;
comment|// Retrieve the file encryption key info, null if file is not in
comment|// encrypted bucket.
name|this
operator|.
name|feInfo
operator|=
name|info
operator|.
name|getFileEncryptionInfo
argument_list|()
expr_stmt|;
name|this
operator|.
name|keyArgs
operator|=
operator|new
name|OmKeyArgs
operator|.
name|Builder
argument_list|()
operator|.
name|setVolumeName
argument_list|(
name|info
operator|.
name|getVolumeName
argument_list|()
argument_list|)
operator|.
name|setBucketName
argument_list|(
name|info
operator|.
name|getBucketName
argument_list|()
argument_list|)
operator|.
name|setKeyName
argument_list|(
name|info
operator|.
name|getKeyName
argument_list|()
argument_list|)
operator|.
name|setType
argument_list|(
name|type
argument_list|)
operator|.
name|setFactor
argument_list|(
name|factor
argument_list|)
operator|.
name|setDataSize
argument_list|(
name|info
operator|.
name|getDataSize
argument_list|()
argument_list|)
operator|.
name|setIsMultipartKey
argument_list|(
name|isMultipart
argument_list|)
operator|.
name|setMultipartUploadID
argument_list|(
name|uploadID
argument_list|)
operator|.
name|setMultipartUploadPartNumber
argument_list|(
name|partNumber
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|this
operator|.
name|openID
operator|=
name|handler
operator|.
name|getId
argument_list|()
expr_stmt|;
name|this
operator|.
name|xceiverClientManager
operator|=
name|xceiverClientManager
expr_stmt|;
name|this
operator|.
name|chunkSize
operator|=
name|chunkSize
expr_stmt|;
name|this
operator|.
name|requestID
operator|=
name|requestId
expr_stmt|;
name|this
operator|.
name|streamBufferFlushSize
operator|=
name|bufferFlushSize
expr_stmt|;
name|this
operator|.
name|streamBufferMaxSize
operator|=
name|bufferMaxSize
expr_stmt|;
name|this
operator|.
name|blockSize
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|watchTimeout
operator|=
name|watchTimeout
expr_stmt|;
name|this
operator|.
name|bytesPerChecksum
operator|=
name|bytesPerChecksum
expr_stmt|;
name|this
operator|.
name|checksumType
operator|=
name|checksumType
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|chunkSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|streamBufferFlushSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|streamBufferMaxSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|blockSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|streamBufferFlushSize
operator|%
name|chunkSize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|streamBufferMaxSize
operator|%
name|streamBufferFlushSize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|blockSize
operator|%
name|streamBufferMaxSize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|bufferPool
operator|=
operator|new
name|BufferPool
argument_list|(
name|chunkSize
argument_list|,
operator|(
name|int
operator|)
name|streamBufferMaxSize
operator|/
name|chunkSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|excludeList
operator|=
operator|new
name|ExcludeList
argument_list|()
expr_stmt|;
name|this
operator|.
name|retryPolicy
operator|=
name|OzoneClientUtils
operator|.
name|createRetryPolicy
argument_list|(
name|maxRetryCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|retryCount
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * When a key is opened, it is possible that there are some blocks already    * allocated to it for this open session. In this case, to make use of these    * blocks, we need to add these blocks to stream entries. But, a key's version    * also includes blocks from previous versions, we need to avoid adding these    * old blocks to stream entries, because these old blocks should not be picked    * for write. To do this, the following method checks that, only those    * blocks created in this particular open version are added to stream entries.    *    * @param version the set of blocks that are pre-allocated.    * @param openVersion the version corresponding to the pre-allocation.    * @throws IOException    */
DECL|method|addPreallocateBlocks (OmKeyLocationInfoGroup version, long openVersion)
specifier|public
name|void
name|addPreallocateBlocks
parameter_list|(
name|OmKeyLocationInfoGroup
name|version
parameter_list|,
name|long
name|openVersion
parameter_list|)
throws|throws
name|IOException
block|{
comment|// server may return any number of blocks, (0 to any)
comment|// only the blocks allocated in this open session (block createVersion
comment|// equals to open session version)
for|for
control|(
name|OmKeyLocationInfo
name|subKeyInfo
range|:
name|version
operator|.
name|getLocationList
argument_list|()
control|)
block|{
if|if
condition|(
name|subKeyInfo
operator|.
name|getCreateVersion
argument_list|()
operator|==
name|openVersion
condition|)
block|{
name|addKeyLocationInfo
argument_list|(
name|subKeyInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|addKeyLocationInfo (OmKeyLocationInfo subKeyInfo)
specifier|private
name|void
name|addKeyLocationInfo
parameter_list|(
name|OmKeyLocationInfo
name|subKeyInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|subKeyInfo
operator|.
name|getPipeline
argument_list|()
argument_list|)
expr_stmt|;
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|addToken
argument_list|(
name|subKeyInfo
operator|.
name|getToken
argument_list|()
argument_list|)
expr_stmt|;
name|BlockOutputStreamEntry
operator|.
name|Builder
name|builder
init|=
operator|new
name|BlockOutputStreamEntry
operator|.
name|Builder
argument_list|()
operator|.
name|setBlockID
argument_list|(
name|subKeyInfo
operator|.
name|getBlockID
argument_list|()
argument_list|)
operator|.
name|setKey
argument_list|(
name|keyArgs
operator|.
name|getKeyName
argument_list|()
argument_list|)
operator|.
name|setXceiverClientManager
argument_list|(
name|xceiverClientManager
argument_list|)
operator|.
name|setPipeline
argument_list|(
name|subKeyInfo
operator|.
name|getPipeline
argument_list|()
argument_list|)
operator|.
name|setRequestId
argument_list|(
name|requestID
argument_list|)
operator|.
name|setChunkSize
argument_list|(
name|chunkSize
argument_list|)
operator|.
name|setLength
argument_list|(
name|subKeyInfo
operator|.
name|getLength
argument_list|()
argument_list|)
operator|.
name|setStreamBufferFlushSize
argument_list|(
name|streamBufferFlushSize
argument_list|)
operator|.
name|setStreamBufferMaxSize
argument_list|(
name|streamBufferMaxSize
argument_list|)
operator|.
name|setWatchTimeout
argument_list|(
name|watchTimeout
argument_list|)
operator|.
name|setbufferPool
argument_list|(
name|bufferPool
argument_list|)
operator|.
name|setChecksumType
argument_list|(
name|checksumType
argument_list|)
operator|.
name|setBytesPerChecksum
argument_list|(
name|bytesPerChecksum
argument_list|)
operator|.
name|setToken
argument_list|(
name|subKeyInfo
operator|.
name|getToken
argument_list|()
argument_list|)
decl_stmt|;
name|streamEntries
operator|.
name|add
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Try to write the bytes sequence b[off:off+len) to streams.    *    * NOTE: Throws exception if the data could not fit into the remaining space.    * In which case nothing will be written.    * TODO:May need to revisit this behaviour.    *    * @param b byte data    * @param off starting offset    * @param len length to write    * @throws IOException    */
annotation|@
name|Override
DECL|method|write (byte[] b, int off, int len)
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
if|if
condition|(
operator|(
name|off
operator|<
literal|0
operator|)
operator|||
operator|(
name|off
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
name|len
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|handleWrite
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|computeBufferData ()
specifier|private
name|long
name|computeBufferData
parameter_list|()
block|{
return|return
name|bufferPool
operator|.
name|computeBufferData
argument_list|()
return|;
block|}
DECL|method|handleWrite (byte[] b, int off, long len, boolean retry)
specifier|private
name|void
name|handleWrite
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|long
name|len
parameter_list|,
name|boolean
name|retry
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|succeededAllocates
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
try|try
block|{
if|if
condition|(
name|streamEntries
operator|.
name|size
argument_list|()
operator|<=
name|currentStreamIndex
condition|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|omClient
argument_list|)
expr_stmt|;
comment|// allocate a new block, if a exception happens, log an error and
comment|// throw exception to the caller directly, and the write fails.
try|try
block|{
name|allocateNewBlock
argument_list|(
name|currentStreamIndex
argument_list|)
expr_stmt|;
name|succeededAllocates
operator|+=
literal|1
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Try to allocate more blocks for write failed, already "
operator|+
literal|"allocated "
operator|+
name|succeededAllocates
operator|+
literal|" blocks for this write."
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
comment|// in theory, this condition should never violate due the check above
comment|// still do a sanity check.
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|currentStreamIndex
operator|<
name|streamEntries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|BlockOutputStreamEntry
name|current
init|=
name|streamEntries
operator|.
name|get
argument_list|(
name|currentStreamIndex
argument_list|)
decl_stmt|;
comment|// length(len) will be in int range if the call is happening through
comment|// write API of blockOutputStream. Length can be in long range if it
comment|// comes via Exception path.
name|int
name|writeLen
init|=
name|Math
operator|.
name|min
argument_list|(
operator|(
name|int
operator|)
name|len
argument_list|,
operator|(
name|int
operator|)
name|current
operator|.
name|getRemaining
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|currentPos
init|=
name|current
operator|.
name|getWrittenDataLength
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|retry
condition|)
block|{
name|current
operator|.
name|writeOnRetry
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|writeLen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|writeLen
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// for the current iteration, totalDataWritten - currentPos gives the
comment|// amount of data already written to the buffer
comment|// In the retryPath, the total data to be written will always be equal
comment|// to or less than the max length of the buffer allocated.
comment|// The len specified here is the combined sum of the data length of
comment|// the buffers
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|retry
operator|||
name|len
operator|<=
name|streamBufferMaxSize
argument_list|)
expr_stmt|;
name|int
name|dataWritten
init|=
call|(
name|int
call|)
argument_list|(
name|current
operator|.
name|getWrittenDataLength
argument_list|()
operator|-
name|currentPos
argument_list|)
decl_stmt|;
name|writeLen
operator|=
name|retry
condition|?
operator|(
name|int
operator|)
name|len
else|:
name|dataWritten
expr_stmt|;
comment|// In retry path, the data written is already accounted in offset.
if|if
condition|(
operator|!
name|retry
condition|)
block|{
name|offset
operator|+=
name|writeLen
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"writeLen {}, total len {}"
argument_list|,
name|writeLen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|handleException
argument_list|(
name|current
argument_list|,
name|currentStreamIndex
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|.
name|getRemaining
argument_list|()
operator|<=
literal|0
condition|)
block|{
comment|// since the current block is already written close the stream.
name|handleFlushOrClose
argument_list|(
name|StreamAction
operator|.
name|FULL
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|writeLen
expr_stmt|;
name|off
operator|+=
name|writeLen
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|markStreamClosed
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Discards the subsequent pre allocated blocks and removes the streamEntries    * from the streamEntries list for the container which is closed.    * @param containerID id of the closed container    * @param pipelineId id of the associated pipeline    * @param streamIndex index of the stream    */
DECL|method|discardPreallocatedBlocks (long containerID, PipelineID pipelineId, int streamIndex)
specifier|private
name|void
name|discardPreallocatedBlocks
parameter_list|(
name|long
name|containerID
parameter_list|,
name|PipelineID
name|pipelineId
parameter_list|,
name|int
name|streamIndex
parameter_list|)
block|{
comment|// streamIndex< streamEntries.size() signifies that, there are still
comment|// pre allocated blocks available.
comment|// This will be called only to discard the next subsequent unused blocks
comment|// in the streamEntryList.
if|if
condition|(
name|streamIndex
operator|<
name|streamEntries
operator|.
name|size
argument_list|()
condition|)
block|{
name|ListIterator
argument_list|<
name|BlockOutputStreamEntry
argument_list|>
name|streamEntryIterator
init|=
name|streamEntries
operator|.
name|listIterator
argument_list|(
name|streamIndex
argument_list|)
decl_stmt|;
while|while
condition|(
name|streamEntryIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockOutputStreamEntry
name|streamEntry
init|=
name|streamEntryIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|streamEntry
operator|.
name|getCurrentPosition
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|pipelineId
operator|!=
literal|null
operator|&&
name|streamEntry
operator|.
name|getPipeline
argument_list|()
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|pipelineId
argument_list|)
operator|)
operator|||
operator|(
name|containerID
operator|!=
operator|-
literal|1
operator|&&
name|streamEntry
operator|.
name|getBlockID
argument_list|()
operator|.
name|getContainerID
argument_list|()
operator|==
name|containerID
operator|)
operator|)
condition|)
block|{
name|streamEntryIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * It might be possible that the blocks pre allocated might never get written    * while the stream gets closed normally. In such cases, it would be a good    * idea to trim down the locationInfoList by removing the unused blocks if any    * so as only the used block info gets updated on OzoneManager during close.    */
DECL|method|removeEmptyBlocks ()
specifier|private
name|void
name|removeEmptyBlocks
parameter_list|()
block|{
if|if
condition|(
name|currentStreamIndex
operator|<
name|streamEntries
operator|.
name|size
argument_list|()
condition|)
block|{
name|ListIterator
argument_list|<
name|BlockOutputStreamEntry
argument_list|>
name|streamEntryIterator
init|=
name|streamEntries
operator|.
name|listIterator
argument_list|(
name|currentStreamIndex
argument_list|)
decl_stmt|;
while|while
condition|(
name|streamEntryIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|streamEntryIterator
operator|.
name|next
argument_list|()
operator|.
name|getCurrentPosition
argument_list|()
operator|==
literal|0
condition|)
block|{
name|streamEntryIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|cleanup ()
specifier|private
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|excludeList
operator|!=
literal|null
condition|)
block|{
name|excludeList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|excludeList
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|bufferPool
operator|!=
literal|null
condition|)
block|{
name|bufferPool
operator|.
name|clearBufferPool
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|streamEntries
operator|!=
literal|null
condition|)
block|{
name|streamEntries
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * It performs following actions :    * a. Updates the committed length at datanode for the current stream in    *    datanode.    * b. Reads the data from the underlying buffer and writes it the next stream.    *    * @param streamEntry StreamEntry    * @param streamIndex Index of the entry    * @param exception actual exception that occurred    * @throws IOException Throws IOException if Write fails    */
DECL|method|handleException (BlockOutputStreamEntry streamEntry, int streamIndex, IOException exception)
specifier|private
name|void
name|handleException
parameter_list|(
name|BlockOutputStreamEntry
name|streamEntry
parameter_list|,
name|int
name|streamIndex
parameter_list|,
name|IOException
name|exception
parameter_list|)
throws|throws
name|IOException
block|{
name|Throwable
name|t
init|=
name|checkForException
argument_list|(
name|exception
argument_list|)
decl_stmt|;
name|boolean
name|retryFailure
init|=
name|checkForRetryFailure
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|boolean
name|closedContainerException
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|retryFailure
condition|)
block|{
name|closedContainerException
operator|=
name|checkIfContainerIsClosed
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|PipelineID
name|pipelineId
init|=
literal|null
decl_stmt|;
name|long
name|totalSuccessfulFlushedData
init|=
name|streamEntry
operator|.
name|getTotalAckDataLength
argument_list|()
decl_stmt|;
comment|//set the correct length for the current stream
name|streamEntry
operator|.
name|setCurrentPosition
argument_list|(
name|totalSuccessfulFlushedData
argument_list|)
expr_stmt|;
name|long
name|bufferedDataLen
init|=
name|computeBufferData
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception {}. The last committed block length is {}, "
operator|+
literal|"uncommitted data length is {} retry count {}"
argument_list|,
name|exception
argument_list|,
name|totalSuccessfulFlushedData
argument_list|,
name|bufferedDataLen
argument_list|,
name|retryCount
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|bufferedDataLen
operator|<=
name|streamBufferMaxSize
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offset
operator|-
name|getKeyLength
argument_list|()
operator|==
name|bufferedDataLen
argument_list|)
expr_stmt|;
name|long
name|containerId
init|=
name|streamEntry
operator|.
name|getBlockID
argument_list|()
operator|.
name|getContainerID
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDetails
argument_list|>
name|failedServers
init|=
name|streamEntry
operator|.
name|getFailedServers
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|failedServers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|failedServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|excludeList
operator|.
name|addDatanodes
argument_list|(
name|failedServers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closedContainerException
condition|)
block|{
name|excludeList
operator|.
name|addConatinerId
argument_list|(
name|ContainerID
operator|.
name|valueof
argument_list|(
name|containerId
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retryFailure
operator|||
name|t
operator|instanceof
name|TimeoutException
operator|||
name|t
operator|instanceof
name|GroupMismatchException
condition|)
block|{
name|pipelineId
operator|=
name|streamEntry
operator|.
name|getPipeline
argument_list|()
operator|.
name|getId
argument_list|()
expr_stmt|;
name|excludeList
operator|.
name|addPipeline
argument_list|(
name|pipelineId
argument_list|)
expr_stmt|;
block|}
comment|// just clean up the current stream.
name|streamEntry
operator|.
name|cleanup
argument_list|(
name|retryFailure
argument_list|)
expr_stmt|;
comment|// discard all sunsequent blocks the containers and pipelines which
comment|// are in the exclude list so that, the very next retry should never
comment|// write data on the  closed container/pipeline
if|if
condition|(
name|closedContainerException
condition|)
block|{
comment|// discard subsequent pre allocated blocks from the streamEntries list
comment|// from the closed container
name|discardPreallocatedBlocks
argument_list|(
name|streamEntry
operator|.
name|getBlockID
argument_list|()
operator|.
name|getContainerID
argument_list|()
argument_list|,
literal|null
argument_list|,
name|streamIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// In case there is timeoutException or Watch for commit happening over
comment|// majority or the client connection failure to the leader in the
comment|// pipeline, just discard all the preallocated blocks on this pipeline.
comment|// Next block allocation will happen with excluding this specific pipeline
comment|// This will ensure if 2 way commit happens , it cannot span over multiple
comment|// blocks
name|discardPreallocatedBlocks
argument_list|(
operator|-
literal|1
argument_list|,
name|pipelineId
argument_list|,
name|streamIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufferedDataLen
operator|>
literal|0
condition|)
block|{
comment|// If the data is still cached in the underlying stream, we need to
comment|// allocate new block and write this data in the datanode.
name|currentStreamIndex
operator|+=
literal|1
expr_stmt|;
name|handleRetry
argument_list|(
name|exception
argument_list|,
name|bufferedDataLen
argument_list|)
expr_stmt|;
comment|// reset the retryCount after handling the exception
name|retryCount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|totalSuccessfulFlushedData
operator|==
literal|0
condition|)
block|{
name|streamEntries
operator|.
name|remove
argument_list|(
name|streamIndex
argument_list|)
expr_stmt|;
name|currentStreamIndex
operator|-=
literal|1
expr_stmt|;
block|}
block|}
DECL|method|markStreamClosed ()
specifier|private
name|void
name|markStreamClosed
parameter_list|()
block|{
name|cleanup
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|handleRetry (IOException exception, long len)
specifier|private
name|void
name|handleRetry
parameter_list|(
name|IOException
name|exception
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|RetryPolicy
operator|.
name|RetryAction
name|action
decl_stmt|;
try|try
block|{
name|action
operator|=
name|retryPolicy
operator|.
name|shouldRetry
argument_list|(
name|exception
argument_list|,
name|retryCount
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|instanceof
name|IOException
condition|?
operator|(
name|IOException
operator|)
name|e
else|:
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|action
operator|.
name|action
operator|==
name|RetryPolicy
operator|.
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|FAIL
condition|)
block|{
name|String
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|action
operator|.
name|reason
operator|!=
literal|null
condition|)
block|{
name|msg
operator|=
literal|"Retry request failed. "
operator|+
name|action
operator|.
name|reason
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|,
name|exception
argument_list|)
throw|;
block|}
comment|// Throw the exception if the thread is interrupted
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying for retry"
argument_list|)
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|action
operator|.
name|action
operator|==
name|RetryPolicy
operator|.
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|.
name|delayMillis
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|action
operator|.
name|delayMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted: action="
operator|+
name|action
operator|+
literal|", retry policy="
operator|+
name|retryPolicy
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|retryCount
operator|++
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Retrying Write request. Already tried "
operator|+
name|retryCount
operator|+
literal|" time(s); retry policy is "
operator|+
name|retryPolicy
argument_list|)
expr_stmt|;
name|handleWrite
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks if the provided exception signifies retry failure in ratis client.    * In case of retry failure, ratis client throws RaftRetryFailureException    * and all succeeding operations are failed with AlreadyClosedException.    */
DECL|method|checkForRetryFailure (Throwable t)
specifier|private
name|boolean
name|checkForRetryFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|t
operator|instanceof
name|RaftRetryFailureException
operator|||
name|t
operator|instanceof
name|AlreadyClosedException
return|;
block|}
DECL|method|checkIfContainerIsClosed (Throwable t)
specifier|private
name|boolean
name|checkIfContainerIsClosed
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|t
operator|instanceof
name|ContainerNotOpenException
return|;
block|}
DECL|method|checkForException (IOException ioe)
specifier|public
name|Throwable
name|checkForException
parameter_list|(
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|Throwable
name|t
init|=
name|ioe
operator|.
name|getCause
argument_list|()
decl_stmt|;
while|while
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
name|cls
range|:
name|OzoneClientUtils
operator|.
name|getExceptionList
argument_list|()
control|)
block|{
if|if
condition|(
name|cls
operator|.
name|isInstance
argument_list|(
name|t
argument_list|)
condition|)
block|{
return|return
name|t
return|;
block|}
block|}
name|t
operator|=
name|t
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
throw|throw
name|ioe
throw|;
block|}
DECL|method|getKeyLength ()
specifier|private
name|long
name|getKeyLength
parameter_list|()
block|{
return|return
name|streamEntries
operator|.
name|stream
argument_list|()
operator|.
name|mapToLong
argument_list|(
name|e
lambda|->
name|e
operator|.
name|getCurrentPosition
argument_list|()
argument_list|)
operator|.
name|sum
argument_list|()
return|;
block|}
comment|/**    * Contact OM to get a new block. Set the new block with the index (e.g.    * first block has index = 0, second has index = 1 etc.)    *    * The returned block is made to new BlockOutputStreamEntry to write.    *    * @param index the index of the block.    * @throws IOException    */
DECL|method|allocateNewBlock (int index)
specifier|private
name|void
name|allocateNewBlock
parameter_list|(
name|int
name|index
parameter_list|)
throws|throws
name|IOException
block|{
name|OmKeyLocationInfo
name|subKeyInfo
init|=
name|omClient
operator|.
name|allocateBlock
argument_list|(
name|keyArgs
argument_list|,
name|openID
argument_list|,
name|excludeList
argument_list|)
decl_stmt|;
name|addKeyLocationInfo
argument_list|(
name|subKeyInfo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|checkNotClosed
argument_list|()
expr_stmt|;
name|handleFlushOrClose
argument_list|(
name|StreamAction
operator|.
name|FLUSH
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close or Flush the latest outputStream depending upon the action.    * This function gets called when while write is going on, the current stream    * gets full or explicit flush or close request is made by client. when the    * stream gets full and we try to close the stream , we might end up hitting    * an exception in the exception handling path, we write the data residing in    * in the buffer pool to a new Block. In cases, as such, when the data gets    * written to new stream , it will be at max half full. In such cases, we    * should just write the data and not close the stream as the block won't be    * completely full.    * @param op Flag which decides whether to call close or flush on the    *              outputStream.    * @throws IOException In case, flush or close fails with exception.    */
DECL|method|handleFlushOrClose (StreamAction op)
specifier|private
name|void
name|handleFlushOrClose
parameter_list|(
name|StreamAction
name|op
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamEntries
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|int
name|size
init|=
name|streamEntries
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|streamIndex
init|=
name|currentStreamIndex
operator|>=
name|size
condition|?
name|size
operator|-
literal|1
else|:
name|currentStreamIndex
decl_stmt|;
name|BlockOutputStreamEntry
name|entry
init|=
name|streamEntries
operator|.
name|get
argument_list|(
name|streamIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Collection
argument_list|<
name|DatanodeDetails
argument_list|>
name|failedServers
init|=
name|entry
operator|.
name|getFailedServers
argument_list|()
decl_stmt|;
comment|// failed servers can be null in case there is no data written in
comment|// the stream
if|if
condition|(
name|failedServers
operator|!=
literal|null
operator|&&
operator|!
name|failedServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|excludeList
operator|.
name|addDatanodes
argument_list|(
name|failedServers
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|CLOSE
case|:
name|entry
operator|.
name|close
argument_list|()
expr_stmt|;
break|break;
case|case
name|FULL
case|:
if|if
condition|(
name|entry
operator|.
name|getRemaining
argument_list|()
operator|==
literal|0
condition|)
block|{
name|entry
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentStreamIndex
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|FLUSH
case|:
name|entry
operator|.
name|flush
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid Operation"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|handleException
argument_list|(
name|entry
argument_list|,
name|streamIndex
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|markStreamClosed
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Commit the key to OM, this will add the blocks as the new key blocks.    *    * @throws IOException    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
name|closed
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|handleFlushOrClose
argument_list|(
name|StreamAction
operator|.
name|CLOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyArgs
operator|!=
literal|null
condition|)
block|{
comment|// in test, this could be null
name|removeEmptyBlocks
argument_list|()
expr_stmt|;
name|long
name|length
init|=
name|getKeyLength
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offset
operator|==
name|length
argument_list|)
expr_stmt|;
name|keyArgs
operator|.
name|setDataSize
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|keyArgs
operator|.
name|setLocationInfoList
argument_list|(
name|getLocationInfoList
argument_list|()
argument_list|)
expr_stmt|;
comment|// When the key is multipart upload part file upload, we should not
comment|// commit the key, as this is not an actual key, this is a just a
comment|// partial key of a large file.
if|if
condition|(
name|keyArgs
operator|.
name|getIsMultipartKey
argument_list|()
condition|)
block|{
name|commitUploadPartInfo
operator|=
name|omClient
operator|.
name|commitMultipartUploadPart
argument_list|(
name|keyArgs
argument_list|,
name|openID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|omClient
operator|.
name|commitKey
argument_list|(
name|keyArgs
argument_list|,
name|openID
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Closing KeyOutputStream, but key args is null"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
name|ioe
throw|;
block|}
finally|finally
block|{
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getCommitUploadPartInfo ()
specifier|public
name|OmMultipartCommitUploadPartInfo
name|getCommitUploadPartInfo
parameter_list|()
block|{
return|return
name|commitUploadPartInfo
return|;
block|}
DECL|method|getFileEncryptionInfo ()
specifier|public
name|FileEncryptionInfo
name|getFileEncryptionInfo
parameter_list|()
block|{
return|return
name|feInfo
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getExcludeList ()
specifier|public
name|ExcludeList
name|getExcludeList
parameter_list|()
block|{
return|return
name|excludeList
return|;
block|}
comment|/**    * Builder class of KeyOutputStream.    */
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
block|{
DECL|field|openHandler
specifier|private
name|OpenKeySession
name|openHandler
decl_stmt|;
DECL|field|xceiverManager
specifier|private
name|XceiverClientManager
name|xceiverManager
decl_stmt|;
DECL|field|omClient
specifier|private
name|OzoneManagerProtocol
name|omClient
decl_stmt|;
DECL|field|chunkSize
specifier|private
name|int
name|chunkSize
decl_stmt|;
DECL|field|requestID
specifier|private
name|String
name|requestID
decl_stmt|;
DECL|field|type
specifier|private
name|ReplicationType
name|type
decl_stmt|;
DECL|field|factor
specifier|private
name|ReplicationFactor
name|factor
decl_stmt|;
DECL|field|streamBufferFlushSize
specifier|private
name|long
name|streamBufferFlushSize
decl_stmt|;
DECL|field|streamBufferMaxSize
specifier|private
name|long
name|streamBufferMaxSize
decl_stmt|;
DECL|field|blockSize
specifier|private
name|long
name|blockSize
decl_stmt|;
DECL|field|watchTimeout
specifier|private
name|long
name|watchTimeout
decl_stmt|;
DECL|field|checksumType
specifier|private
name|ChecksumType
name|checksumType
decl_stmt|;
DECL|field|bytesPerChecksum
specifier|private
name|int
name|bytesPerChecksum
decl_stmt|;
DECL|field|multipartUploadID
specifier|private
name|String
name|multipartUploadID
decl_stmt|;
DECL|field|multipartNumber
specifier|private
name|int
name|multipartNumber
decl_stmt|;
DECL|field|isMultipartKey
specifier|private
name|boolean
name|isMultipartKey
decl_stmt|;
DECL|field|maxRetryCount
specifier|private
name|int
name|maxRetryCount
decl_stmt|;
DECL|method|setMultipartUploadID (String uploadID)
specifier|public
name|Builder
name|setMultipartUploadID
parameter_list|(
name|String
name|uploadID
parameter_list|)
block|{
name|this
operator|.
name|multipartUploadID
operator|=
name|uploadID
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setMultipartNumber (int partNumber)
specifier|public
name|Builder
name|setMultipartNumber
parameter_list|(
name|int
name|partNumber
parameter_list|)
block|{
name|this
operator|.
name|multipartNumber
operator|=
name|partNumber
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setHandler (OpenKeySession handler)
specifier|public
name|Builder
name|setHandler
parameter_list|(
name|OpenKeySession
name|handler
parameter_list|)
block|{
name|this
operator|.
name|openHandler
operator|=
name|handler
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setXceiverClientManager (XceiverClientManager manager)
specifier|public
name|Builder
name|setXceiverClientManager
parameter_list|(
name|XceiverClientManager
name|manager
parameter_list|)
block|{
name|this
operator|.
name|xceiverManager
operator|=
name|manager
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setOmClient ( OzoneManagerProtocol client)
specifier|public
name|Builder
name|setOmClient
parameter_list|(
name|OzoneManagerProtocol
name|client
parameter_list|)
block|{
name|this
operator|.
name|omClient
operator|=
name|client
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setChunkSize (int size)
specifier|public
name|Builder
name|setChunkSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|chunkSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setRequestID (String id)
specifier|public
name|Builder
name|setRequestID
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|requestID
operator|=
name|id
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setType (ReplicationType replicationType)
specifier|public
name|Builder
name|setType
parameter_list|(
name|ReplicationType
name|replicationType
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|replicationType
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setFactor (ReplicationFactor replicationFactor)
specifier|public
name|Builder
name|setFactor
parameter_list|(
name|ReplicationFactor
name|replicationFactor
parameter_list|)
block|{
name|this
operator|.
name|factor
operator|=
name|replicationFactor
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setStreamBufferFlushSize (long size)
specifier|public
name|Builder
name|setStreamBufferFlushSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|streamBufferFlushSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setStreamBufferMaxSize (long size)
specifier|public
name|Builder
name|setStreamBufferMaxSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|streamBufferMaxSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBlockSize (long size)
specifier|public
name|Builder
name|setBlockSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|blockSize
operator|=
name|size
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setWatchTimeout (long timeout)
specifier|public
name|Builder
name|setWatchTimeout
parameter_list|(
name|long
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|watchTimeout
operator|=
name|timeout
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setChecksumType (ChecksumType cType)
specifier|public
name|Builder
name|setChecksumType
parameter_list|(
name|ChecksumType
name|cType
parameter_list|)
block|{
name|this
operator|.
name|checksumType
operator|=
name|cType
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBytesPerChecksum (int bytes)
specifier|public
name|Builder
name|setBytesPerChecksum
parameter_list|(
name|int
name|bytes
parameter_list|)
block|{
name|this
operator|.
name|bytesPerChecksum
operator|=
name|bytes
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setIsMultipartKey (boolean isMultipart)
specifier|public
name|Builder
name|setIsMultipartKey
parameter_list|(
name|boolean
name|isMultipart
parameter_list|)
block|{
name|this
operator|.
name|isMultipartKey
operator|=
name|isMultipart
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setMaxRetryCount (int maxCount)
specifier|public
name|Builder
name|setMaxRetryCount
parameter_list|(
name|int
name|maxCount
parameter_list|)
block|{
name|this
operator|.
name|maxRetryCount
operator|=
name|maxCount
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|build ()
specifier|public
name|KeyOutputStream
name|build
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|KeyOutputStream
argument_list|(
name|openHandler
argument_list|,
name|xceiverManager
argument_list|,
name|omClient
argument_list|,
name|chunkSize
argument_list|,
name|requestID
argument_list|,
name|factor
argument_list|,
name|type
argument_list|,
name|streamBufferFlushSize
argument_list|,
name|streamBufferMaxSize
argument_list|,
name|blockSize
argument_list|,
name|watchTimeout
argument_list|,
name|checksumType
argument_list|,
name|bytesPerChecksum
argument_list|,
name|multipartUploadID
argument_list|,
name|multipartNumber
argument_list|,
name|isMultipartKey
argument_list|,
name|maxRetryCount
argument_list|)
return|;
block|}
block|}
comment|/**    * Verify that the output stream is open. Non blocking; this gives    * the last state of the volatile {@link #closed} field.    * @throws IOException if the connection is closed.    */
DECL|method|checkNotClosed ()
specifier|private
name|void
name|checkNotClosed
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|": "
operator|+
name|FSExceptionMessages
operator|.
name|STREAM_IS_CLOSED
operator|+
literal|" Key: "
operator|+
name|keyArgs
operator|.
name|getKeyName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

