begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.web.localstorage
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|localstorage
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|codec
operator|.
name|digest
operator|.
name|DigestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|client
operator|.
name|io
operator|.
name|LengthInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|exceptions
operator|.
name|ErrorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|client
operator|.
name|rest
operator|.
name|OzoneException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|handlers
operator|.
name|BucketArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|handlers
operator|.
name|KeyArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|handlers
operator|.
name|ListArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|handlers
operator|.
name|UserArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|handlers
operator|.
name|VolumeArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneAcl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|response
operator|.
name|BucketInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|response
operator|.
name|KeyInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|response
operator|.
name|ListBuckets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|response
operator|.
name|ListKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|response
operator|.
name|ListVolumes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|response
operator|.
name|VolumeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|response
operator|.
name|VolumeOwner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|utils
operator|.
name|MetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|utils
operator|.
name|MetadataStoreBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_comment
comment|/**  * A stand alone Ozone implementation that allows us to run Ozone tests in local  * mode. This acts as the ozone backend when using MiniDFSCluster for testing.  */
end_comment

begin_class
DECL|class|OzoneMetadataManager
specifier|public
specifier|final
class|class
name|OzoneMetadataManager
block|{
comment|/*     OzoneMetadataManager manages volume/bucket/object metadata and     data.      Metadata is maintained in 2 level DB files, UserDB and MetadataDB.      UserDB contains a Name and a List. For example volumes owned by the user     bilbo, would be maintained in UserDB as {bilbo}->{shire, rings}      This list part of mapping is context sensitive.  That is, if you use {user     name} as the key, the list you get is a list of volumes. if you use     {user/volume} as the key the list you get is list of buckets. if you use     {user/volume/bucket} as key the list you get is the list of objects.      All keys in the UserDB starts with the UserName.      We also need to maintain a flat namespace for volumes. This is     maintained by the MetadataDB. MetadataDB contains the name of an     object(volume, bucket or key) and its associated metadata.     The keys in the Metadata DB are {volume}, {volume/bucket} or     {volume/bucket/key}. User name is absent, so we have a common root name     space for the volume.      The value of part of metadataDB points to corresponding *Info structures.     {volume] -> volumeInfo     {volume/bucket} -> bucketInfo     {volume/bucket/key} -> keyInfo       Here are various work flows :      CreateVolume -> Check if Volume exists in metadataDB, if not update UserDB     with a list of volumes and update metadataDB with VolumeInfo.      DeleteVolume -> Check the Volume, and check the VolumeInfo->bucketCount.     if bucketCount == 0, delete volume from userDB->{List of volumes} and     metadataDB.      Very similar work flows exist for CreateBucket and DeleteBucket.        // Please note : These database operations are *not* transactional,       // which means that failure can lead to inconsistencies.       // Only way to recover is to reset to a clean state, or       // use rm -rf /tmp/ozone :)      We have very simple locking policy. We have a ReaderWriter lock that is     taken for each action, this lock is aptly named "lock".      All actions *must* be performed with a lock held, either a read     lock or a write lock. Violation of these locking policies can be harmful.         // // IMPORTANT :       // //  This is a simulation layer, this is NOT how the real       // //  OZONE functions. This is written to so that we can write       // //  stand-alone tests for the protocol and client code.  */
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|OzoneMetadataManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|USER_DB
specifier|private
specifier|static
specifier|final
name|String
name|USER_DB
init|=
literal|"/user.db"
decl_stmt|;
DECL|field|META_DB
specifier|private
specifier|static
specifier|final
name|String
name|META_DB
init|=
literal|"/metadata.db"
decl_stmt|;
DECL|field|bm
specifier|private
specifier|static
name|OzoneMetadataManager
name|bm
init|=
literal|null
decl_stmt|;
DECL|field|userDB
specifier|private
name|MetadataStore
name|userDB
decl_stmt|;
DECL|field|metadataDB
specifier|private
name|MetadataStore
name|metadataDB
decl_stmt|;
DECL|field|lock
specifier|private
name|ReadWriteLock
name|lock
decl_stmt|;
DECL|field|encoding
specifier|private
name|Charset
name|encoding
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
DECL|field|storageRoot
specifier|private
name|String
name|storageRoot
decl_stmt|;
DECL|field|OBJECT_DIR
specifier|private
specifier|static
specifier|final
name|String
name|OBJECT_DIR
init|=
literal|"/_objects/"
decl_stmt|;
comment|// This table keeps a pointer to objects whose operations
comment|// are in progress but not yet committed to persistent store
DECL|field|inProgressObjects
specifier|private
name|ConcurrentHashMap
argument_list|<
name|OutputStream
argument_list|,
name|String
argument_list|>
name|inProgressObjects
decl_stmt|;
comment|/**    * Constructs OzoneMetadataManager.    */
DECL|method|OzoneMetadataManager (Configuration conf)
specifier|private
name|OzoneMetadataManager
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|lock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
expr_stmt|;
name|storageRoot
operator|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|OzoneConfigKeys
operator|.
name|OZONE_LOCALSTORAGE_ROOT
argument_list|,
name|OzoneConfigKeys
operator|.
name|OZONE_LOCALSTORAGE_ROOT_DEFAULT
argument_list|)
expr_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|storageRoot
operator|+
name|OBJECT_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|file
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Creation of Ozone root failed. "
operator|+
name|file
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Creation of Ozone root failed."
argument_list|)
throw|;
block|}
try|try
block|{
name|userDB
operator|=
name|MetadataStoreBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|setDbFile
argument_list|(
operator|new
name|File
argument_list|(
name|storageRoot
operator|+
name|USER_DB
argument_list|)
argument_list|)
operator|.
name|setCreateIfMissing
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|metadataDB
operator|=
name|MetadataStoreBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|setDbFile
argument_list|(
operator|new
name|File
argument_list|(
name|storageRoot
operator|+
name|META_DB
argument_list|)
argument_list|)
operator|.
name|setCreateIfMissing
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|inProgressObjects
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot open db :"
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
block|}
comment|/**    * Gets Ozone Manager.    *    * @return OzoneMetadataManager    */
specifier|public
specifier|static
specifier|synchronized
name|OzoneMetadataManager
DECL|method|getOzoneMetadataManager (Configuration conf)
name|getOzoneMetadataManager
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|bm
operator|==
literal|null
condition|)
block|{
name|bm
operator|=
operator|new
name|OzoneMetadataManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
return|return
name|bm
return|;
block|}
comment|/**    * Creates a volume.    *    * @param args - VolumeArgs    * @throws OzoneException    */
DECL|method|createVolume (VolumeArgs args)
specifier|public
name|void
name|createVolume
parameter_list|(
name|VolumeArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|SimpleDateFormat
name|format
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|OzoneConsts
operator|.
name|OZONE_DATE_FORMAT
argument_list|,
name|Locale
operator|.
name|US
argument_list|)
decl_stmt|;
name|format
operator|.
name|setTimeZone
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|OzoneConsts
operator|.
name|OZONE_TIME_ZONE
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|volumeName
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|volumeName
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Volume {} already exists."
argument_list|,
name|volumeName
argument_list|)
expr_stmt|;
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|VOLUME_ALREADY_EXISTS
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|VolumeInfo
name|newVInfo
init|=
operator|new
name|VolumeInfo
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
argument_list|,
name|format
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|args
operator|.
name|getAdminName
argument_list|()
argument_list|)
decl_stmt|;
name|newVInfo
operator|.
name|setQuota
argument_list|(
name|args
operator|.
name|getQuota
argument_list|()
argument_list|)
expr_stmt|;
name|VolumeOwner
name|owner
init|=
operator|new
name|VolumeOwner
argument_list|(
name|args
operator|.
name|getUserName
argument_list|()
argument_list|)
decl_stmt|;
name|newVInfo
operator|.
name|setOwner
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|ListVolumes
name|volumeList
decl_stmt|;
name|byte
index|[]
name|userVolumes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getUserName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|userVolumes
operator|==
literal|null
condition|)
block|{
name|volumeList
operator|=
operator|new
name|ListVolumes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|volumeList
operator|=
name|ListVolumes
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|userVolumes
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|volumeList
operator|.
name|addVolume
argument_list|(
name|newVInfo
argument_list|)
expr_stmt|;
name|volumeList
operator|.
name|sort
argument_list|()
expr_stmt|;
comment|// Please note : These database operations are *not* transactional,
comment|// which means that failure can lead to inconsistencies.
comment|// Only way to recover is to reset to a clean state, or
comment|// use rm -rf /tmp/ozone :)
name|userDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getUserName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|volumeList
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|metadataDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|newVInfo
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Updates the Volume properties like Owner Name and Quota.    *    * @param args     - Volume Args    * @param property - Flag which tells us what property to upgrade    * @throws OzoneException    */
DECL|method|setVolumeProperty (VolumeArgs args, VolumeProperty property)
specifier|public
name|void
name|setVolumeProperty
parameter_list|(
name|VolumeArgs
name|args
parameter_list|,
name|VolumeProperty
name|property
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|volumeInfo
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|volumeInfo
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|VOLUME_NOT_FOUND
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|VolumeInfo
name|info
init|=
name|VolumeInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|volumeInfo
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|userBytes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|ListVolumes
name|volumeList
decl_stmt|;
if|if
condition|(
name|userBytes
operator|==
literal|null
condition|)
block|{
name|volumeList
operator|=
operator|new
name|ListVolumes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|volumeList
operator|=
name|ListVolumes
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|userBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|property
condition|)
block|{
case|case
name|OWNER
case|:
comment|// needs new owner, we delete the volume object from the
comment|// old user's volume list
name|removeOldOwner
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|VolumeOwner
name|owner
init|=
operator|new
name|VolumeOwner
argument_list|(
name|args
operator|.
name|getUserName
argument_list|()
argument_list|)
decl_stmt|;
comment|// set the new owner
name|info
operator|.
name|setOwner
argument_list|(
name|owner
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUOTA
case|:
comment|// if this is quota update we just remove the old object from the
comment|// current users list and update the same object later.
name|volumeList
operator|.
name|getVolumes
argument_list|()
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|setQuota
argument_list|(
name|args
operator|.
name|getQuota
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OzoneException
name|ozEx
init|=
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|BAD_PROPERTY
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|ozEx
operator|.
name|setMessage
argument_list|(
literal|"Volume property is not recognized"
argument_list|)
expr_stmt|;
throw|throw
name|ozEx
throw|;
block|}
name|volumeList
operator|.
name|addVolume
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|metadataDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|info
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
comment|// if this is an owner change this put will create a new owner or update
comment|// the owner's volume list.
name|userDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|volumeList
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Removes the old owner from the volume.    *    * @param info - VolumeInfo    * @throws IOException    */
DECL|method|removeOldOwner (VolumeInfo info)
specifier|private
name|void
name|removeOldOwner
parameter_list|(
name|VolumeInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We need to look the owner that we know is the current owner
name|byte
index|[]
name|volumeBytes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|info
operator|.
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|ListVolumes
name|volumeList
init|=
name|ListVolumes
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|volumeBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|volumeList
operator|.
name|getVolumes
argument_list|()
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|// Write the new list info to the old user data
name|userDB
operator|.
name|put
argument_list|(
name|info
operator|.
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|volumeList
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks if you are the owner of a specific volume.    *    * @param volume - Volume Name whose access permissions needs to be checked    * @param acl - requested acls which needs to be checked for access    * @return - True if you are the owner, false otherwise    * @throws OzoneException    */
DECL|method|checkVolumeAccess (String volume, OzoneAcl acl)
specifier|public
name|boolean
name|checkVolumeAccess
parameter_list|(
name|String
name|volume
parameter_list|,
name|OzoneAcl
name|acl
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|volumeInfo
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|volume
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|volumeInfo
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|VOLUME_NOT_FOUND
argument_list|,
literal|null
argument_list|)
throw|;
block|}
name|VolumeInfo
name|info
init|=
name|VolumeInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|volumeInfo
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|info
operator|.
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|acl
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
literal|null
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * getVolumeInfo returns the Volume Info of a specific volume.    *    * @param args - Volume args    * @return VolumeInfo    * @throws OzoneException    */
DECL|method|getVolumeInfo (VolumeArgs args)
specifier|public
name|VolumeInfo
name|getVolumeInfo
parameter_list|(
name|VolumeArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|volumeInfo
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|volumeInfo
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|VOLUME_NOT_FOUND
argument_list|,
name|args
argument_list|)
throw|;
block|}
return|return
name|VolumeInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|volumeInfo
argument_list|,
name|encoding
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns all the volumes owned by a specific user.    *    * @param args - User Args    * @return - ListVolumes    * @throws OzoneException    */
DECL|method|listVolumes (ListArgs args)
specifier|public
name|ListVolumes
name|listVolumes
parameter_list|(
name|ListArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|args
operator|.
name|isRootScan
argument_list|()
condition|)
block|{
return|return
name|listAllVolumes
argument_list|(
name|args
argument_list|)
return|;
block|}
name|UserArgs
name|uArgs
init|=
operator|(
name|UserArgs
operator|)
name|args
operator|.
name|getArgs
argument_list|()
decl_stmt|;
name|byte
index|[]
name|volumeList
init|=
name|userDB
operator|.
name|get
argument_list|(
name|uArgs
operator|.
name|getUserName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|volumeList
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|USER_NOT_FOUND
argument_list|,
name|uArgs
argument_list|)
throw|;
block|}
name|String
name|prefix
init|=
name|args
operator|.
name|getPrefix
argument_list|()
decl_stmt|;
name|int
name|maxCount
init|=
name|args
operator|.
name|getMaxKeys
argument_list|()
decl_stmt|;
name|String
name|prevKey
init|=
name|args
operator|.
name|getPrevKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevKey
operator|!=
literal|null
condition|)
block|{
comment|// Format is username/volumeName, in local mode we don't use the
comment|// user name since we have a userName DB.
name|String
index|[]
name|volName
init|=
name|args
operator|.
name|getPrevKey
argument_list|()
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|volName
operator|.
name|length
operator|<
literal|2
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|USER_NOT_FOUND
argument_list|,
name|uArgs
argument_list|)
throw|;
block|}
name|prevKey
operator|=
name|volName
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|getFilteredVolumes
argument_list|(
name|volumeList
argument_list|,
name|prefix
argument_list|,
name|prevKey
argument_list|,
name|maxCount
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
operator|.
name|getArgs
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns a List of Volumes that meet the prefix, prevkey and maxCount    * constraints.    *    * @param volumeList - Byte Array of Volume Info.    * @param prefix     - prefix string.    * @param prevKey    - PrevKey    * @param maxCount   - Maximum Count.    * @return ListVolumes.    * @throws IOException    */
DECL|method|getFilteredVolumes (byte[] volumeList, String prefix, String prevKey, int maxCount)
specifier|private
name|ListVolumes
name|getFilteredVolumes
parameter_list|(
name|byte
index|[]
name|volumeList
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|prevKey
parameter_list|,
name|int
name|maxCount
parameter_list|)
throws|throws
name|IOException
block|{
name|ListVolumes
name|volumes
init|=
name|ListVolumes
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|volumeList
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|currentCount
init|=
literal|0
decl_stmt|;
name|ListIterator
argument_list|<
name|VolumeInfo
argument_list|>
name|iter
init|=
name|volumes
operator|.
name|getVolumes
argument_list|()
operator|.
name|listIterator
argument_list|()
decl_stmt|;
name|ListVolumes
name|filteredVolumes
init|=
operator|new
name|ListVolumes
argument_list|()
decl_stmt|;
while|while
condition|(
name|currentCount
operator|<
name|maxCount
operator|&&
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|VolumeInfo
name|vInfo
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMatchingPrefix
argument_list|(
name|prefix
argument_list|,
name|vInfo
argument_list|)
operator|&&
name|isAfterKey
argument_list|(
name|prevKey
argument_list|,
name|vInfo
argument_list|)
condition|)
block|{
name|filteredVolumes
operator|.
name|addVolume
argument_list|(
name|vInfo
argument_list|)
expr_stmt|;
name|currentCount
operator|++
expr_stmt|;
block|}
block|}
return|return
name|filteredVolumes
return|;
block|}
comment|/**    * Returns all volumes in a cluster.    *    * @param args - ListArgs.    * @return ListVolumes.    * @throws OzoneException    */
DECL|method|listAllVolumes (ListArgs args)
specifier|public
name|ListVolumes
name|listAllVolumes
parameter_list|(
name|ListArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
throws|,
name|IOException
block|{
name|String
name|prefix
init|=
name|args
operator|.
name|getPrefix
argument_list|()
decl_stmt|;
specifier|final
name|String
name|prevKey
decl_stmt|;
name|int
name|maxCount
init|=
name|args
operator|.
name|getMaxKeys
argument_list|()
decl_stmt|;
name|String
name|userName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|getPrevKey
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Format is username/volumeName
name|String
index|[]
name|volName
init|=
name|args
operator|.
name|getPrevKey
argument_list|()
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|volName
operator|.
name|length
operator|<
literal|2
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|USER_NOT_FOUND
argument_list|,
name|args
operator|.
name|getArgs
argument_list|()
argument_list|)
throw|;
block|}
name|byte
index|[]
name|userNameBytes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|volName
index|[
literal|0
index|]
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|userName
operator|=
operator|new
name|String
argument_list|(
name|userNameBytes
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|prevKey
operator|=
name|volName
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|userName
operator|=
operator|new
name|String
argument_list|(
name|userDB
operator|.
name|peekAround
argument_list|(
literal|0
argument_list|,
literal|null
argument_list|)
operator|.
name|getKey
argument_list|()
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|prevKey
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|userName
operator|==
literal|null
operator|||
name|userName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|USER_NOT_FOUND
argument_list|,
name|args
operator|.
name|getArgs
argument_list|()
argument_list|)
throw|;
block|}
name|ListVolumes
name|returnSet
init|=
operator|new
name|ListVolumes
argument_list|()
decl_stmt|;
comment|// we need to iterate through users until we get maxcount volumes
comment|// or no more volumes are left.
name|userDB
operator|.
name|iterate
argument_list|(
literal|null
argument_list|,
parameter_list|(
name|key
parameter_list|,
name|value
parameter_list|)
lambda|->
block|{
name|int
name|currentSize
init|=
name|returnSet
operator|.
name|getVolumes
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentSize
operator|<
name|maxCount
condition|)
block|{
name|String
name|name
init|=
operator|new
name|String
argument_list|(
name|key
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
name|byte
index|[]
name|volumeList
init|=
name|userDB
operator|.
name|get
argument_list|(
name|name
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|volumeList
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|USER_NOT_FOUND
argument_list|,
name|args
operator|.
name|getArgs
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|returnSet
operator|.
name|getVolumes
argument_list|()
operator|.
name|addAll
argument_list|(
name|getFilteredVolumes
argument_list|(
name|volumeList
argument_list|,
name|prefix
argument_list|,
name|prevKey
argument_list|,
name|maxCount
operator|-
name|currentSize
argument_list|)
operator|.
name|getVolumes
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|returnSet
return|;
block|}
comment|/**    * Checks if a name starts with a matching prefix.    *    * @param prefix - prefix string.    * @param vInfo  - volume info.    * @return true or false.    */
DECL|method|isMatchingPrefix (String prefix, VolumeInfo vInfo)
specifier|private
name|boolean
name|isMatchingPrefix
parameter_list|(
name|String
name|prefix
parameter_list|,
name|VolumeInfo
name|vInfo
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|==
literal|null
operator|||
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|vInfo
operator|.
name|getVolumeName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
return|;
block|}
comment|/**    * Checks if the key is after the prevKey.    *    * @param prevKey - String prevKey.    * @param vInfo   - volume Info.    * @return - true or false.    */
DECL|method|isAfterKey (String prevKey, VolumeInfo vInfo)
specifier|private
name|boolean
name|isAfterKey
parameter_list|(
name|String
name|prevKey
parameter_list|,
name|VolumeInfo
name|vInfo
parameter_list|)
block|{
if|if
condition|(
name|prevKey
operator|==
literal|null
operator|||
name|prevKey
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|prevKey
operator|.
name|compareTo
argument_list|(
name|vInfo
operator|.
name|getVolumeName
argument_list|()
argument_list|)
operator|<
literal|0
return|;
block|}
comment|/**    * Deletes a volume if it exists and is empty.    *    * @param args - volume args    * @throws OzoneException    */
DECL|method|deleteVolume (VolumeArgs args)
specifier|public
name|void
name|deleteVolume
parameter_list|(
name|VolumeArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|volumeName
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|volumeName
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|VOLUME_NOT_FOUND
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|VolumeInfo
name|vInfo
init|=
name|VolumeInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|volumeName
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
comment|// Only remove volumes if they are empty.
if|if
condition|(
name|vInfo
operator|.
name|getBucketCount
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|VOLUME_NOT_EMPTY
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|ListVolumes
name|volumeList
decl_stmt|;
name|String
name|user
init|=
name|vInfo
operator|.
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|byte
index|[]
name|userVolumes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|user
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|userVolumes
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|VOLUME_NOT_FOUND
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|volumeList
operator|=
name|ListVolumes
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|userVolumes
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|volumeList
operator|.
name|getVolumes
argument_list|()
operator|.
name|remove
argument_list|(
name|vInfo
argument_list|)
expr_stmt|;
name|metadataDB
operator|.
name|delete
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|userDB
operator|.
name|put
argument_list|(
name|user
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|volumeList
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create a bucket if it does not exist.    *    * @param args - BucketArgs    * @throws OzoneException    */
DECL|method|createBucket (BucketArgs args)
specifier|public
name|void
name|createBucket
parameter_list|(
name|BucketArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// check if volume exists, buckets cannot be created without volumes
name|byte
index|[]
name|volumeName
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|volumeName
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|VOLUME_NOT_FOUND
argument_list|,
name|args
argument_list|)
throw|;
block|}
comment|// A resource name is volume/bucket -- That is the key in metadata table
name|byte
index|[]
name|bucketName
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketName
operator|!=
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|BUCKET_ALREADY_EXISTS
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|BucketInfo
name|bucketInfo
init|=
operator|new
name|BucketInfo
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
argument_list|,
name|args
operator|.
name|getBucketName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|getRemoveAcls
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|OzoneException
name|ex
init|=
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|MALFORMED_ACL
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|ex
operator|.
name|setMessage
argument_list|(
literal|"Remove ACLs specified in bucket create. Please remove "
operator|+
literal|"them and retry."
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
name|VolumeInfo
name|volInfo
init|=
name|VolumeInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|volumeName
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|volInfo
operator|.
name|setBucketCount
argument_list|(
name|volInfo
operator|.
name|getBucketCount
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bucketInfo
operator|.
name|setAcls
argument_list|(
name|args
operator|.
name|getAddAcls
argument_list|()
argument_list|)
expr_stmt|;
name|bucketInfo
operator|.
name|setStorageType
argument_list|(
name|args
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
name|bucketInfo
operator|.
name|setVersioning
argument_list|(
name|args
operator|.
name|getVersioning
argument_list|()
argument_list|)
expr_stmt|;
name|ListBuckets
name|bucketList
decl_stmt|;
comment|// get bucket list from user/volume -> bucketList
name|byte
index|[]
name|volumeBuckets
init|=
name|userDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|volumeBuckets
operator|==
literal|null
condition|)
block|{
name|bucketList
operator|=
operator|new
name|ListBuckets
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bucketList
operator|=
name|ListBuckets
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|volumeBuckets
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bucketList
operator|.
name|addBucket
argument_list|(
name|bucketInfo
argument_list|)
expr_stmt|;
name|bucketList
operator|.
name|sort
argument_list|()
expr_stmt|;
comment|// Update Volume->bucketCount
name|userDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getVolumeName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|volInfo
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now update the userDB with user/volume -> bucketList
name|userDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|bucketList
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
comment|// Update userDB with volume/bucket -> empty key list
name|userDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
operator|new
name|ListKeys
argument_list|()
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
comment|// and update the metadataDB with volume/bucket->BucketInfo
name|metadataDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|bucketInfo
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Updates the Bucket properties like ACls and Storagetype.    *    * @param args     - Bucket Args    * @param property - Flag which tells us what property to upgrade    * @throws OzoneException    */
DECL|method|setBucketProperty (BucketArgs args, BucketProperty property)
specifier|public
name|void
name|setBucketProperty
parameter_list|(
name|BucketArgs
name|args
parameter_list|,
name|BucketProperty
name|property
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// volume/bucket-> bucketInfo
name|byte
index|[]
name|bucketInfo
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketInfo
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_BUCKET_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|BucketInfo
name|info
init|=
name|BucketInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketInfo
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|volumeBuckets
init|=
name|userDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|ListBuckets
name|bucketList
init|=
name|ListBuckets
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|volumeBuckets
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|bucketList
operator|.
name|getBuckets
argument_list|()
operator|.
name|remove
argument_list|(
name|info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|property
condition|)
block|{
case|case
name|ACLS
case|:
name|processRemoveAcls
argument_list|(
name|args
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|processAddAcls
argument_list|(
name|args
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|STORAGETYPE
case|:
name|info
operator|.
name|setStorageType
argument_list|(
name|args
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|VERSIONING
case|:
name|info
operator|.
name|setVersioning
argument_list|(
name|args
operator|.
name|getVersioning
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OzoneException
name|ozEx
init|=
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|BAD_PROPERTY
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|ozEx
operator|.
name|setMessage
argument_list|(
literal|"Bucket property is not recognized."
argument_list|)
expr_stmt|;
throw|throw
name|ozEx
throw|;
block|}
name|bucketList
operator|.
name|addBucket
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|metadataDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|info
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|userDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|bucketList
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Process Remove Acls and remove them from the bucket.    *    * @param args - BucketArgs    * @param info - BucketInfo    */
DECL|method|processRemoveAcls (BucketArgs args, BucketInfo info)
specifier|private
name|void
name|processRemoveAcls
parameter_list|(
name|BucketArgs
name|args
parameter_list|,
name|BucketInfo
name|info
parameter_list|)
block|{
name|List
argument_list|<
name|OzoneAcl
argument_list|>
name|removeAcls
init|=
name|args
operator|.
name|getRemoveAcls
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|removeAcls
operator|==
literal|null
operator|)
operator|||
operator|(
name|info
operator|.
name|getAcls
argument_list|()
operator|==
literal|null
operator|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|OzoneAcl
name|racl
range|:
name|args
operator|.
name|getRemoveAcls
argument_list|()
control|)
block|{
name|ListIterator
argument_list|<
name|OzoneAcl
argument_list|>
name|aclIter
init|=
name|info
operator|.
name|getAcls
argument_list|()
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|aclIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|racl
operator|.
name|equals
argument_list|(
name|aclIter
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|aclIter
operator|.
name|remove
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/**    * Process Add Acls and Add them to the bucket.    *    * @param args - BucketArgs    * @param info - BucketInfo    */
DECL|method|processAddAcls (BucketArgs args, BucketInfo info)
specifier|private
name|void
name|processAddAcls
parameter_list|(
name|BucketArgs
name|args
parameter_list|,
name|BucketInfo
name|info
parameter_list|)
block|{
name|List
argument_list|<
name|OzoneAcl
argument_list|>
name|addAcls
init|=
name|args
operator|.
name|getAddAcls
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|addAcls
operator|==
literal|null
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|info
operator|.
name|getAcls
argument_list|()
operator|==
literal|null
condition|)
block|{
name|info
operator|.
name|setAcls
argument_list|(
name|addAcls
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|OzoneAcl
name|newacl
range|:
name|addAcls
control|)
block|{
name|ListIterator
argument_list|<
name|OzoneAcl
argument_list|>
name|aclIter
init|=
name|info
operator|.
name|getAcls
argument_list|()
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|aclIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|newacl
operator|.
name|equals
argument_list|(
name|aclIter
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
name|info
operator|.
name|getAcls
argument_list|()
operator|.
name|add
argument_list|(
name|newacl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes a given bucket.    *    * @param args - BucketArgs    * @throws OzoneException    */
DECL|method|deleteBucket (BucketArgs args)
specifier|public
name|void
name|deleteBucket
parameter_list|(
name|BucketArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|bucketInfo
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketInfo
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_BUCKET_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|BucketInfo
name|bInfo
init|=
name|BucketInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketInfo
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
comment|// Only remove buckets if they are empty.
if|if
condition|(
name|bInfo
operator|.
name|getKeyCount
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|BUCKET_NOT_EMPTY
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|byte
index|[]
name|bucketBytes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketBytes
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_BUCKET_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|ListBuckets
name|bucketList
init|=
name|ListBuckets
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|bucketList
operator|.
name|getBuckets
argument_list|()
operator|.
name|remove
argument_list|(
name|bInfo
argument_list|)
expr_stmt|;
name|metadataDB
operator|.
name|delete
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|userDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|bucketList
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the Bucket info for a given bucket.    *    * @param args - Bucket Args    * @return BucketInfo   -  Bucket Information    * @throws OzoneException    */
DECL|method|getBucketInfo (BucketArgs args)
specifier|public
name|BucketInfo
name|getBucketInfo
parameter_list|(
name|BucketArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|bucketBytes
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketBytes
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_BUCKET_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
return|return
name|BucketInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns a list of buckets for a given volume.    *    * @param args - volume args    * @return List of buckets    * @throws OzoneException    */
DECL|method|listBuckets (ListArgs args)
specifier|public
name|ListBuckets
name|listBuckets
parameter_list|(
name|ListArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|args
operator|.
name|getArgs
argument_list|()
operator|instanceof
name|VolumeArgs
argument_list|)
expr_stmt|;
name|VolumeArgs
name|vArgs
init|=
operator|(
name|VolumeArgs
operator|)
name|args
operator|.
name|getArgs
argument_list|()
decl_stmt|;
name|String
name|userVolKey
init|=
name|vArgs
operator|.
name|getUserName
argument_list|()
operator|+
literal|"/"
operator|+
name|vArgs
operator|.
name|getVolumeName
argument_list|()
decl_stmt|;
comment|// TODO : Query using Prefix and PrevKey
name|byte
index|[]
name|bucketBytes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|userVolKey
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketBytes
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_VOLUME_NAME
argument_list|,
name|args
operator|.
name|getArgs
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|ListBuckets
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
operator|.
name|getArgs
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Creates a key and returns a stream to which this key can be written to.    *    * @param args KeyArgs    * @return - A stream into which key can be written to.    * @throws OzoneException    */
DECL|method|createKey (KeyArgs args)
specifier|public
name|OutputStream
name|createKey
parameter_list|(
name|KeyArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|String
name|fileNameHash
init|=
name|DigestUtils
operator|.
name|sha256Hex
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
argument_list|)
decl_stmt|;
comment|// Please don't try trillion objects unless the physical file system
comment|// is capable of doing that in a single directory.
name|String
name|fullPath
init|=
name|storageRoot
operator|+
name|OBJECT_DIR
operator|+
name|fileNameHash
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|fullPath
argument_list|)
decl_stmt|;
comment|// In real ozone it would not be this way, a file will be overwritten
comment|// only if the upload is successful.
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"we are overwriting a file. This is by design."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to delete the file: {}"
argument_list|,
name|fullPath
argument_list|)
expr_stmt|;
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|)
throw|;
block|}
block|}
comment|// f.createNewFile();
name|FileOutputStream
name|fsStream
init|=
operator|new
name|FileOutputStream
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|inProgressObjects
operator|.
name|put
argument_list|(
name|fsStream
argument_list|,
name|fullPath
argument_list|)
expr_stmt|;
return|return
name|fsStream
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * commit keys moves an In progress object into the metadata store so that key    * is visible in the metadata operations from that point onwards.    *    * @param args Object args    * @throws OzoneException    */
DECL|method|commitKey (KeyArgs args, OutputStream stream)
specifier|public
name|void
name|commitKey
parameter_list|(
name|KeyArgs
name|args
parameter_list|,
name|OutputStream
name|stream
parameter_list|)
throws|throws
name|OzoneException
block|{
name|SimpleDateFormat
name|format
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"EEE, dd MMM yyyy HH:mm:ss ZZZ"
argument_list|,
name|Locale
operator|.
name|US
argument_list|)
decl_stmt|;
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|bucketInfo
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketInfo
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_RESOURCE_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|BucketInfo
name|bInfo
init|=
name|BucketInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketInfo
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|bInfo
operator|.
name|setKeyCount
argument_list|(
name|bInfo
operator|.
name|getKeyCount
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|String
name|fileNameHash
init|=
name|inProgressObjects
operator|.
name|get
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|inProgressObjects
operator|.
name|remove
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileNameHash
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|ListKeys
name|keyList
decl_stmt|;
name|byte
index|[]
name|bucketListBytes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|keyList
operator|=
name|ListKeys
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketListBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|KeyInfo
name|keyInfo
decl_stmt|;
name|byte
index|[]
name|objectBytes
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectBytes
operator|!=
literal|null
condition|)
block|{
comment|// we are overwriting an existing object.
comment|// TODO : Emit info for Accounting
name|keyInfo
operator|=
name|KeyInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|objectBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|keyList
operator|.
name|getKeyList
argument_list|()
operator|.
name|remove
argument_list|(
name|keyInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|keyInfo
operator|=
operator|new
name|KeyInfo
argument_list|()
expr_stmt|;
block|}
name|keyInfo
operator|.
name|setCreatedOn
argument_list|(
name|format
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO : support version, we need to check if versioning
comment|// is switched on the bucket and make appropriate calls.
name|keyInfo
operator|.
name|setVersion
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|keyInfo
operator|.
name|setDataFileName
argument_list|(
name|fileNameHash
argument_list|)
expr_stmt|;
name|keyInfo
operator|.
name|setKeyName
argument_list|(
name|args
operator|.
name|getKeyName
argument_list|()
argument_list|)
expr_stmt|;
name|keyInfo
operator|.
name|setMd5hash
argument_list|(
name|args
operator|.
name|getHash
argument_list|()
argument_list|)
expr_stmt|;
name|keyInfo
operator|.
name|setSize
argument_list|(
name|args
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|keyList
operator|.
name|getKeyList
argument_list|()
operator|.
name|add
argument_list|(
name|keyInfo
argument_list|)
expr_stmt|;
comment|// if the key exists, we overwrite happily :). since the
comment|// earlier call - createObject -  has overwritten the data.
name|metadataDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|keyInfo
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|metadataDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|bInfo
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|userDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|keyList
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * deletes an key from a given bucket.    *    * @param args - ObjectArgs    * @throws OzoneException    */
DECL|method|deleteKey (KeyArgs args)
specifier|public
name|void
name|deleteKey
parameter_list|(
name|KeyArgs
name|args
parameter_list|)
throws|throws
name|OzoneException
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|bucketInfo
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketInfo
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_BUCKET_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|BucketInfo
name|bInfo
init|=
name|BucketInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketInfo
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|bInfo
operator|.
name|setKeyCount
argument_list|(
name|bInfo
operator|.
name|getKeyCount
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bucketListBytes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketListBytes
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_BUCKET_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|ListKeys
name|keyList
init|=
name|ListKeys
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketListBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|objectBytes
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectBytes
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_KEY
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|KeyInfo
name|oInfo
init|=
name|KeyInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|objectBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
name|keyList
operator|.
name|getKeyList
argument_list|()
operator|.
name|remove
argument_list|(
name|oInfo
argument_list|)
expr_stmt|;
name|String
name|fileNameHash
init|=
name|DigestUtils
operator|.
name|sha256Hex
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|fullPath
init|=
name|storageRoot
operator|+
name|OBJECT_DIR
operator|+
name|fileNameHash
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|fullPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|KEY_OPERATION_CONFLICT
argument_list|,
name|args
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_KEY
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|metadataDB
operator|.
name|delete
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|metadataDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|bInfo
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|userDB
operator|.
name|put
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|,
name|keyList
operator|.
name|toDBString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns a Stream for the file.    *    * @param args - Object args    * @return Stream    * @throws IOException    * @throws OzoneException    */
DECL|method|newKeyReader (KeyArgs args)
specifier|public
name|LengthInputStream
name|newKeyReader
parameter_list|(
name|KeyArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|OzoneException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|String
name|fileNameHash
init|=
name|DigestUtils
operator|.
name|sha256Hex
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|fullPath
init|=
name|storageRoot
operator|+
name|OBJECT_DIR
operator|+
name|fileNameHash
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|fullPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_RESOURCE_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|long
name|size
init|=
name|f
operator|.
name|length
argument_list|()
decl_stmt|;
name|FileInputStream
name|fileStream
init|=
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|LengthInputStream
argument_list|(
name|fileStream
argument_list|,
name|size
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns keys in a bucket.    *    * @param args    * @return List of keys.    * @throws IOException    * @throws OzoneException    */
DECL|method|listKeys (ListArgs args)
specifier|public
name|ListKeys
name|listKeys
parameter_list|(
name|ListArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|OzoneException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// TODO : Support Prefix and PrevKey lookup.
try|try
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|args
operator|.
name|getArgs
argument_list|()
operator|instanceof
name|BucketArgs
argument_list|)
expr_stmt|;
name|BucketArgs
name|bArgs
init|=
operator|(
name|BucketArgs
operator|)
name|args
operator|.
name|getArgs
argument_list|()
decl_stmt|;
name|byte
index|[]
name|bucketInfo
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|bArgs
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketInfo
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_RESOURCE_NAME
argument_list|,
name|bArgs
argument_list|)
throw|;
block|}
name|byte
index|[]
name|bucketListBytes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|bArgs
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketListBytes
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_RESOURCE_NAME
argument_list|,
name|bArgs
argument_list|)
throw|;
block|}
return|return
name|ListKeys
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|bucketListBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the Key information for a given key.    *    * @param args - Key Args    * @return KeyInfo - Key Information    * @throws OzoneException    */
DECL|method|getKeyInfo (KeyArgs args)
specifier|public
name|KeyInfo
name|getKeyInfo
parameter_list|(
name|KeyArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|OzoneException
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|bucketInfo
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketInfo
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_BUCKET_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|byte
index|[]
name|bucketListBytes
init|=
name|userDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getParentName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketListBytes
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_BUCKET_NAME
argument_list|,
name|args
argument_list|)
throw|;
block|}
name|byte
index|[]
name|objectBytes
init|=
name|metadataDB
operator|.
name|get
argument_list|(
name|args
operator|.
name|getResourceName
argument_list|()
operator|.
name|getBytes
argument_list|(
name|encoding
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectBytes
operator|==
literal|null
condition|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|INVALID_KEY
argument_list|,
name|args
argument_list|)
throw|;
block|}
return|return
name|KeyInfo
operator|.
name|parse
argument_list|(
operator|new
name|String
argument_list|(
name|objectBytes
argument_list|,
name|encoding
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|ErrorTable
operator|.
name|newError
argument_list|(
name|ErrorTable
operator|.
name|SERVER_ERROR
argument_list|,
name|args
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This is used in updates to volume metadata.    */
DECL|enum|VolumeProperty
specifier|public
enum|enum
name|VolumeProperty
block|{
DECL|enumConstant|OWNER
DECL|enumConstant|QUOTA
name|OWNER
block|,
name|QUOTA
block|}
comment|/**    * Bucket Properties.    */
DECL|enum|BucketProperty
specifier|public
enum|enum
name|BucketProperty
block|{
DECL|enumConstant|ACLS
DECL|enumConstant|STORAGETYPE
DECL|enumConstant|VERSIONING
name|ACLS
block|,
name|STORAGETYPE
block|,
name|VERSIONING
block|}
block|}
end_class

end_unit

