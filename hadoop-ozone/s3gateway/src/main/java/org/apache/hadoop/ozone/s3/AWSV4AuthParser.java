begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.s3
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|s3
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|s3
operator|.
name|exception
operator|.
name|OS3Exception
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|s3
operator|.
name|header
operator|.
name|AuthorizationHeaderV4
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|s3
operator|.
name|header
operator|.
name|Credential
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kerby
operator|.
name|util
operator|.
name|Hex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|container
operator|.
name|ContainerRequestContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|MultivaluedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLEncoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|LocalDate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|ChronoUnit
operator|.
name|SECONDS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|s3
operator|.
name|exception
operator|.
name|S3ErrorTable
operator|.
name|S3_TOKEN_CREATION_ERROR
import|;
end_import

begin_comment
comment|/**  * Parser to process AWS v4 auth request. Creates string to sign and auth  * header. For more details refer to AWS documentation https://docs.aws  * .amazon.com/general/latest/gr/sigv4-create-canonical-request.html.  **/
end_comment

begin_class
DECL|class|AWSV4AuthParser
specifier|public
class|class
name|AWSV4AuthParser
implements|implements
name|AWSAuthParser
block|{
DECL|field|LOG
specifier|private
specifier|final
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AWSV4AuthParser
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|headerMap
specifier|private
name|MultivaluedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|headerMap
decl_stmt|;
DECL|field|queryMap
specifier|private
name|MultivaluedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|queryMap
decl_stmt|;
DECL|field|uri
specifier|private
name|String
name|uri
decl_stmt|;
DECL|field|method
specifier|private
name|String
name|method
decl_stmt|;
DECL|field|v4Header
specifier|private
name|AuthorizationHeaderV4
name|v4Header
decl_stmt|;
DECL|field|stringToSign
specifier|private
name|String
name|stringToSign
decl_stmt|;
DECL|field|amzContentPayload
specifier|private
name|String
name|amzContentPayload
decl_stmt|;
DECL|method|AWSV4AuthParser (ContainerRequestContext context)
specifier|public
name|AWSV4AuthParser
parameter_list|(
name|ContainerRequestContext
name|context
parameter_list|)
throws|throws
name|OS3Exception
block|{
name|this
operator|.
name|headerMap
operator|=
name|context
operator|.
name|getHeaders
argument_list|()
expr_stmt|;
name|this
operator|.
name|queryMap
operator|=
name|context
operator|.
name|getUriInfo
argument_list|()
operator|.
name|getQueryParameters
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|uri
operator|=
operator|new
name|URI
argument_list|(
name|context
operator|.
name|getUriInfo
argument_list|()
operator|.
name|getRequestUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"\\/+"
argument_list|,
literal|"/"
argument_list|)
argument_list|)
operator|.
name|normalize
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
name|S3_TOKEN_CREATION_ERROR
throw|;
block|}
name|this
operator|.
name|method
operator|=
name|context
operator|.
name|getMethod
argument_list|()
expr_stmt|;
name|v4Header
operator|=
operator|new
name|AuthorizationHeaderV4
argument_list|(
name|headerMap
operator|.
name|getFirst
argument_list|(
name|AUTHORIZATION_HEADER
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|parse ()
specifier|public
name|void
name|parse
parameter_list|()
throws|throws
name|Exception
block|{
name|StringBuilder
name|strToSign
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// According to AWS sigv4 documentation, authorization header should be
comment|// in following format.
comment|// Authorization: algorithm Credential=access key ID/credential scope,
comment|// SignedHeaders=SignedHeaders, Signature=signature
comment|// Construct String to sign in below format.
comment|// StringToSign =
comment|//    Algorithm + \n +
comment|//    RequestDateTime + \n +
comment|//    CredentialScope + \n +
comment|//    HashedCanonicalRequest
name|String
name|algorithm
decl_stmt|,
name|requestDateTime
decl_stmt|,
name|credentialScope
decl_stmt|,
name|canonicalRequest
decl_stmt|;
name|algorithm
operator|=
name|v4Header
operator|.
name|getAlgorithm
argument_list|()
expr_stmt|;
name|requestDateTime
operator|=
name|headerMap
operator|.
name|getFirst
argument_list|(
name|X_AMAZ_DATE
argument_list|)
expr_stmt|;
name|Credential
name|credential
init|=
name|v4Header
operator|.
name|getCredentialObj
argument_list|()
decl_stmt|;
name|credentialScope
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%s/%s/%s/%s"
argument_list|,
name|credential
operator|.
name|getDate
argument_list|()
argument_list|,
name|credential
operator|.
name|getAwsRegion
argument_list|()
argument_list|,
name|credential
operator|.
name|getAwsService
argument_list|()
argument_list|,
name|credential
operator|.
name|getAwsRequest
argument_list|()
argument_list|)
expr_stmt|;
comment|// If the absolute path is empty, use a forward slash (/)
name|uri
operator|=
operator|(
name|uri
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|uri
else|:
literal|"/"
expr_stmt|;
comment|// Encode URI and preserve forward slashes
name|strToSign
operator|.
name|append
argument_list|(
name|algorithm
operator|+
name|NEWLINE
argument_list|)
expr_stmt|;
name|strToSign
operator|.
name|append
argument_list|(
name|requestDateTime
operator|+
name|NEWLINE
argument_list|)
expr_stmt|;
name|strToSign
operator|.
name|append
argument_list|(
name|credentialScope
operator|+
name|NEWLINE
argument_list|)
expr_stmt|;
name|canonicalRequest
operator|=
name|buildCanonicalRequest
argument_list|()
expr_stmt|;
name|strToSign
operator|.
name|append
argument_list|(
name|hash
argument_list|(
name|canonicalRequest
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"canonicalRequest:[{}]"
argument_list|,
name|canonicalRequest
argument_list|)
expr_stmt|;
name|headerMap
operator|.
name|keySet
argument_list|()
operator|.
name|forEach
argument_list|(
name|k
lambda|->
name|LOG
operator|.
name|trace
argument_list|(
literal|"Header:{},value:{}"
argument_list|,
name|k
argument_list|,
name|headerMap
operator|.
name|get
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"StringToSign:[{}]"
argument_list|,
name|strToSign
argument_list|)
expr_stmt|;
name|stringToSign
operator|=
name|strToSign
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
DECL|method|buildCanonicalRequest ()
specifier|private
name|String
name|buildCanonicalRequest
parameter_list|()
throws|throws
name|OS3Exception
block|{
name|Iterable
argument_list|<
name|String
argument_list|>
name|parts
init|=
name|split
argument_list|(
literal|"/"
argument_list|,
name|uri
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|encParts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|p
range|:
name|parts
control|)
block|{
name|encParts
operator|.
name|add
argument_list|(
name|urlEncode
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|canonicalUri
init|=
name|join
argument_list|(
literal|"/"
argument_list|,
name|encParts
argument_list|)
decl_stmt|;
name|String
name|canonicalQueryStr
init|=
name|getQueryParamString
argument_list|()
decl_stmt|;
name|StringBuilder
name|canonicalHeaders
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|header
range|:
name|v4Header
operator|.
name|getSignedHeaders
argument_list|()
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|headerValue
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|canonicalHeaders
operator|.
name|append
argument_list|(
name|header
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
name|canonicalHeaders
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|originalHeader
range|:
name|headerMap
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|originalHeader
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|headerValue
operator|.
name|add
argument_list|(
name|headerMap
operator|.
name|getFirst
argument_list|(
name|originalHeader
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|headerValue
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Header "
operator|+
name|header
operator|+
literal|" not present in "
operator|+
literal|"request"
argument_list|)
throw|;
block|}
if|if
condition|(
name|headerValue
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|headerValue
argument_list|)
expr_stmt|;
block|}
comment|// Set for testing purpose only to skip date and host validation.
name|validateSignedHeader
argument_list|(
name|header
argument_list|,
name|headerValue
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|canonicalHeaders
operator|.
name|append
argument_list|(
name|join
argument_list|(
literal|","
argument_list|,
name|headerValue
argument_list|)
argument_list|)
expr_stmt|;
name|canonicalHeaders
operator|.
name|append
argument_list|(
name|NEWLINE
argument_list|)
expr_stmt|;
block|}
name|String
name|payloadHash
decl_stmt|;
if|if
condition|(
name|UNSIGNED_PAYLOAD
operator|.
name|equals
argument_list|(
name|headerMap
operator|.
name|get
argument_list|(
name|X_AMZ_CONTENT_SHA256
argument_list|)
argument_list|)
condition|)
block|{
name|payloadHash
operator|=
name|UNSIGNED_PAYLOAD
expr_stmt|;
block|}
else|else
block|{
name|payloadHash
operator|=
name|headerMap
operator|.
name|getFirst
argument_list|(
name|X_AMZ_CONTENT_SHA256
argument_list|)
expr_stmt|;
block|}
name|String
name|signedHeaderStr
init|=
name|v4Header
operator|.
name|getSignedHeaderString
argument_list|()
decl_stmt|;
name|String
name|canonicalRequest
init|=
name|method
operator|+
name|NEWLINE
operator|+
name|canonicalUri
operator|+
name|NEWLINE
operator|+
name|canonicalQueryStr
operator|+
name|NEWLINE
operator|+
name|canonicalHeaders
operator|+
name|NEWLINE
operator|+
name|signedHeaderStr
operator|+
name|NEWLINE
operator|+
name|payloadHash
decl_stmt|;
return|return
name|canonicalRequest
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|validateSignedHeader (String header, String headerValue)
name|void
name|validateSignedHeader
parameter_list|(
name|String
name|header
parameter_list|,
name|String
name|headerValue
parameter_list|)
throws|throws
name|OS3Exception
block|{
switch|switch
condition|(
name|header
condition|)
block|{
case|case
name|HOST
case|:
try|try
block|{
name|URI
name|hostUri
init|=
operator|new
name|URI
argument_list|(
name|headerValue
argument_list|)
decl_stmt|;
name|InetAddress
operator|.
name|getByName
argument_list|(
name|hostUri
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Validate if current request is coming from same host.
block|}
catch|catch
parameter_list|(
name|UnknownHostException
decl||
name|URISyntaxException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Host value mentioned in signed header is not valid. "
operator|+
literal|"Host:{}"
argument_list|,
name|headerValue
argument_list|)
expr_stmt|;
throw|throw
name|S3_TOKEN_CREATION_ERROR
throw|;
block|}
break|break;
case|case
name|X_AMAZ_DATE
case|:
name|LocalDate
name|date
init|=
name|LocalDate
operator|.
name|parse
argument_list|(
name|headerValue
argument_list|,
name|TIME_FORMATTER
argument_list|)
decl_stmt|;
name|LocalDate
name|now
init|=
name|LocalDate
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|date
operator|.
name|isBefore
argument_list|(
name|now
operator|.
name|minus
argument_list|(
name|PRESIGN_URL_MAX_EXPIRATION_SECONDS
argument_list|,
name|SECONDS
argument_list|)
argument_list|)
operator|||
name|date
operator|.
name|isAfter
argument_list|(
name|now
operator|.
name|plus
argument_list|(
name|PRESIGN_URL_MAX_EXPIRATION_SECONDS
argument_list|,
name|SECONDS
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"AWS date not in valid range. Request timestamp:{} should "
operator|+
literal|"not be older than {} seconds."
argument_list|,
name|headerValue
argument_list|,
name|PRESIGN_URL_MAX_EXPIRATION_SECONDS
argument_list|)
expr_stmt|;
throw|throw
name|S3_TOKEN_CREATION_ERROR
throw|;
block|}
break|break;
case|case
name|X_AMZ_CONTENT_SHA256
case|:
comment|// TODO: Construct request payload and match HEX(SHA256(requestPayload))
break|break;
default|default:
break|break;
block|}
block|}
comment|/**    * String join that also works with empty strings.    *    * @return joined string    */
DECL|method|join (String glue, List<String> parts)
specifier|private
specifier|static
name|String
name|join
parameter_list|(
name|String
name|glue
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|parts
parameter_list|)
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|addSeparator
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|p
range|:
name|parts
control|)
block|{
if|if
condition|(
name|addSeparator
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|glue
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|addSeparator
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Returns matching strings.    *    * @param regex Regular expression to split by    * @param whole The string to split    * @return pieces    */
DECL|method|split (String regex, String whole)
specifier|private
specifier|static
name|Iterable
argument_list|<
name|String
argument_list|>
name|split
parameter_list|(
name|String
name|regex
parameter_list|,
name|String
name|whole
parameter_list|)
block|{
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
decl_stmt|;
name|Matcher
name|m
init|=
name|p
operator|.
name|matcher
argument_list|(
name|whole
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|whole
operator|.
name|substring
argument_list|(
name|pos
argument_list|,
name|m
operator|.
name|start
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|m
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
name|whole
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|urlEncode (String str)
specifier|private
name|String
name|urlEncode
parameter_list|(
name|String
name|str
parameter_list|)
block|{
try|try
block|{
return|return
name|URLEncoder
operator|.
name|encode
argument_list|(
name|str
argument_list|,
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\+"
argument_list|,
literal|"%20"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"%7E"
argument_list|,
literal|"~"
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|getQueryParamString ()
specifier|private
name|String
name|getQueryParamString
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|params
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|queryMap
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
comment|// Sort by name, then by value
name|Collections
operator|.
name|sort
argument_list|(
name|params
argument_list|,
operator|(
name|o1
operator|,
name|o2
operator|)
operator|->
name|o1
operator|.
name|equals
argument_list|(
name|o2
argument_list|)
condition|?
name|queryMap
operator|.
name|getFirst
argument_list|(
name|o1
argument_list|)
operator|.
name|compareTo
argument_list|(
name|queryMap
operator|.
name|getFirst
argument_list|(
name|o2
argument_list|)
argument_list|)
else|:
name|o1
operator|.
name|compareTo
argument_list|(
name|o2
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|p
range|:
name|params
control|)
block|{
if|if
condition|(
name|result
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
name|urlEncode
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|urlEncode
argument_list|(
name|queryMap
operator|.
name|getFirst
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|hash (String payload)
specifier|public
specifier|static
name|String
name|hash
parameter_list|(
name|String
name|payload
parameter_list|)
throws|throws
name|NoSuchAlgorithmException
block|{
name|MessageDigest
name|md
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"SHA-256"
argument_list|)
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|payload
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Hex
operator|.
name|encode
argument_list|(
name|md
operator|.
name|digest
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
return|;
block|}
DECL|method|getAwsAccessId ()
specifier|public
name|String
name|getAwsAccessId
parameter_list|()
block|{
return|return
name|v4Header
operator|.
name|getAccessKeyID
argument_list|()
return|;
block|}
DECL|method|getSignature ()
specifier|public
name|String
name|getSignature
parameter_list|()
block|{
return|return
name|v4Header
operator|.
name|getSignature
argument_list|()
return|;
block|}
DECL|method|getStringToSign ()
specifier|public
name|String
name|getStringToSign
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|stringToSign
return|;
block|}
block|}
end_class

end_unit

