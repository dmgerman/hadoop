begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Basic functional tests on a fuse-dfs mount.  */
end_comment

begin_class
DECL|class|TestFuseDFS
specifier|public
class|class
name|TestFuseDFS
block|{
DECL|field|cluster
specifier|private
specifier|static
name|MiniDFSCluster
name|cluster
decl_stmt|;
DECL|field|fs
specifier|private
specifier|static
name|FileSystem
name|fs
decl_stmt|;
DECL|field|fuseProcess
specifier|private
specifier|static
name|Process
name|fuseProcess
decl_stmt|;
DECL|field|r
specifier|private
specifier|static
name|Runtime
name|r
decl_stmt|;
DECL|field|mountPoint
specifier|private
specifier|static
name|String
name|mountPoint
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestFuseDFS
operator|.
name|class
argument_list|)
decl_stmt|;
block|{
name|GenericTestUtils
operator|.
name|setLogLevel
parameter_list|(
name|LOG
parameter_list|,
name|Level
operator|.
name|ALL
parameter_list|)
constructor_decl|;
block|}
comment|/** Dump the given intput stream to stderr */
DECL|method|dumpInputStream (InputStream is)
specifier|private
specifier|static
name|void
name|dumpInputStream
parameter_list|(
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
decl_stmt|;
do|do
block|{
name|byte
name|b
index|[]
init|=
operator|new
name|byte
index|[
name|is
operator|.
name|available
argument_list|()
index|]
decl_stmt|;
name|len
operator|=
name|is
operator|.
name|read
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Read "
operator|+
name|len
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|>
literal|0
condition|)
do|;
block|}
comment|/**     * Wait for the given process to return and check that it exited    * as required. Log if the process failed.    */
DECL|method|checkProcessRet (Process p, boolean expectPass)
specifier|private
specifier|static
name|void
name|checkProcessRet
parameter_list|(
name|Process
name|p
parameter_list|,
name|boolean
name|expectPass
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|int
name|ret
init|=
name|p
operator|.
name|waitFor
argument_list|()
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|dumpInputStream
argument_list|(
name|p
operator|.
name|getErrorStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expectPass
condition|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Process interrupted: "
operator|+
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Exec the given command and assert it executed successfully */
DECL|method|execWaitRet (String cmd)
specifier|private
specifier|static
name|void
name|execWaitRet
parameter_list|(
name|String
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"EXEC "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|Process
name|p
init|=
name|r
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
try|try
block|{
name|p
operator|.
name|waitFor
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Process interrupted: "
operator|+
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Exec the given command and assert it executed successfully */
DECL|method|execIgnoreRet (String cmd)
specifier|private
specifier|static
name|void
name|execIgnoreRet
parameter_list|(
name|String
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"EXEC "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|r
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/** Exec the given command and assert it executed successfully */
DECL|method|execAssertSucceeds (String cmd)
specifier|private
specifier|static
name|void
name|execAssertSucceeds
parameter_list|(
name|String
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"EXEC "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|checkProcessRet
argument_list|(
name|r
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Exec the given command, assert it returned an error code */
DECL|method|execAssertFails (String cmd)
specifier|private
specifier|static
name|void
name|execAssertFails
parameter_list|(
name|String
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"EXEC "
operator|+
name|cmd
argument_list|)
expr_stmt|;
name|checkProcessRet
argument_list|(
name|r
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Create and write the given file */
DECL|method|createFile (File f, String s)
specifier|private
specifier|static
name|void
name|createFile
parameter_list|(
name|File
name|f
parameter_list|,
name|String
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|s
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
name|FileOutputStream
name|fos
init|=
operator|new
name|FileOutputStream
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|is
argument_list|,
name|fos
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Check that the given file exists with the given contents */
DECL|method|checkFile (File f, String expectedContents)
specifier|private
specifier|static
name|void
name|checkFile
parameter_list|(
name|File
name|f
parameter_list|,
name|String
name|expectedContents
parameter_list|)
throws|throws
name|IOException
block|{
name|FileInputStream
name|fi
init|=
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|expectedContents
operator|.
name|length
argument_list|()
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
try|try
block|{
name|IOUtils
operator|.
name|readFully
argument_list|(
name|fi
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Reading "
operator|+
name|f
operator|.
name|getName
argument_list|()
operator|+
literal|" failed with "
operator|+
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fi
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// NB: leaving f unclosed prevents unmount
block|}
name|String
name|s
init|=
operator|new
name|String
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"File content differs"
argument_list|,
name|expectedContents
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
DECL|class|RedirectToStdoutThread
specifier|private
specifier|static
class|class
name|RedirectToStdoutThread
extends|extends
name|Thread
block|{
DECL|field|is
specifier|private
name|InputStream
name|is
decl_stmt|;
DECL|method|RedirectToStdoutThread (InputStream is)
name|RedirectToStdoutThread
parameter_list|(
name|InputStream
name|is
parameter_list|)
block|{
name|this
operator|.
name|is
operator|=
name|is
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|InputStreamReader
name|isr
init|=
operator|new
name|InputStreamReader
argument_list|(
name|is
argument_list|)
decl_stmt|;
name|BufferedReader
name|br
init|=
operator|new
name|BufferedReader
argument_list|(
name|isr
argument_list|)
decl_stmt|;
name|String
name|line
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|br
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"FUSE_LINE:"
operator|+
name|line
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Run a fuse-dfs process to mount the given DFS */
DECL|method|establishMount (URI uri)
specifier|private
specifier|static
name|Process
name|establishMount
parameter_list|(
name|URI
name|uri
parameter_list|)
throws|throws
name|IOException
block|{
name|Runtime
name|r
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
name|String
name|cp
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.class.path"
argument_list|)
decl_stmt|;
name|String
name|buildTestDir
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"build.test"
argument_list|)
decl_stmt|;
name|String
name|fuseCmd
init|=
name|buildTestDir
operator|+
literal|"/../fuse_dfs"
decl_stmt|;
name|String
name|libHdfs
init|=
name|buildTestDir
operator|+
literal|"/../../../c++/lib"
decl_stmt|;
name|String
name|arch
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.arch"
argument_list|)
decl_stmt|;
name|String
name|jvm
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.home"
argument_list|)
operator|+
literal|"/lib/"
operator|+
name|arch
operator|+
literal|"/server"
decl_stmt|;
name|String
name|lp
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
operator|+
literal|":"
operator|+
name|libHdfs
operator|+
literal|":"
operator|+
name|jvm
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"LD_LIBRARY_PATH="
operator|+
name|lp
argument_list|)
expr_stmt|;
name|String
name|nameNode
init|=
literal|"dfs://"
operator|+
name|uri
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|uri
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
comment|// NB: We're mounting via an unprivileged user, therefore
comment|// user_allow_other needs to be set in /etc/fuse.conf, which also
comment|// needs to be world readable.
name|String
name|mountCmd
index|[]
init|=
block|{
name|fuseCmd
block|,
name|nameNode
block|,
name|mountPoint
block|,
comment|// "-odebug",              // Don't daemonize
literal|"-obig_writes"
block|,
comment|// Allow>4kb writes
literal|"-oentry_timeout=0.1"
block|,
comment|// Don't cache dents long
literal|"-oattribute_timeout=0.1"
block|,
comment|// Don't cache attributes long
literal|"-ononempty"
block|,
comment|// Don't complain about junk in mount point
literal|"-f"
block|,
comment|// Don't background the process
literal|"-ordbuffer=32768"
block|,
comment|// Read buffer size in kb
literal|"rw"
block|}
decl_stmt|;
name|String
index|[]
name|env
init|=
block|{
literal|"CLASSPATH="
operator|+
name|cp
block|,
literal|"LD_LIBRARY_PATH="
operator|+
name|lp
block|,
literal|"PATH=/usr/bin:/bin"
block|}
decl_stmt|;
name|execWaitRet
argument_list|(
literal|"fusermount -u "
operator|+
name|mountPoint
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"rm -rf "
operator|+
name|mountPoint
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"mkdir -p "
operator|+
name|mountPoint
argument_list|)
expr_stmt|;
comment|// Mount the mini cluster
name|String
name|cmdStr
init|=
literal|""
decl_stmt|;
for|for
control|(
name|String
name|c
range|:
name|mountCmd
control|)
block|{
name|cmdStr
operator|+=
operator|(
literal|" "
operator|+
name|c
operator|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"now mounting with:"
operator|+
name|cmdStr
argument_list|)
expr_stmt|;
name|Process
name|fuseProcess
init|=
name|r
operator|.
name|exec
argument_list|(
name|mountCmd
argument_list|,
name|env
argument_list|)
decl_stmt|;
name|RedirectToStdoutThread
name|stdoutThread
init|=
operator|new
name|RedirectToStdoutThread
argument_list|(
name|fuseProcess
operator|.
name|getInputStream
argument_list|()
argument_list|)
decl_stmt|;
name|RedirectToStdoutThread
name|stderrThread
init|=
operator|new
name|RedirectToStdoutThread
argument_list|(
name|fuseProcess
operator|.
name|getErrorStream
argument_list|()
argument_list|)
decl_stmt|;
name|stdoutThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|stderrThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Wait for fusermount to start up, so that we know we're operating on the
comment|// FUSE FS when we run the tests.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{     }
return|return
name|fuseProcess
return|;
block|}
comment|/** Tear down the fuse-dfs process and mount */
DECL|method|teardownMount ()
specifier|private
specifier|static
name|void
name|teardownMount
parameter_list|()
throws|throws
name|IOException
block|{
name|execWaitRet
argument_list|(
literal|"fusermount -u "
operator|+
name|mountPoint
argument_list|)
expr_stmt|;
try|try
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fuseProcess
operator|.
name|waitFor
argument_list|()
argument_list|)
expr_stmt|;
comment|// fuse_dfs should exit cleanly
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|fail
argument_list|(
literal|"interrupted while waiting for fuse_dfs process to exit."
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|BeforeClass
DECL|method|startUp ()
specifier|public
specifier|static
name|void
name|startUp
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|r
operator|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
expr_stmt|;
name|mountPoint
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"build.test"
argument_list|)
operator|+
literal|"/mnt"
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_KEY
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitClusterUp
argument_list|()
expr_stmt|;
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|fuseProcess
operator|=
name|establishMount
argument_list|(
name|fs
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|AfterClass
DECL|method|tearDown ()
specifier|public
specifier|static
name|void
name|tearDown
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Unmount before taking down the mini cluster
comment|// so no outstanding operations hang.
name|teardownMount
argument_list|()
expr_stmt|;
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Test basic directory creation, access, removal */
annotation|@
name|Test
DECL|method|testBasicDir ()
specifier|public
name|void
name|testBasicDir
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|d
init|=
operator|new
name|File
argument_list|(
name|mountPoint
argument_list|,
literal|"dir1"
argument_list|)
decl_stmt|;
comment|// Mkdir, access and rm via the mount
name|execAssertSucceeds
argument_list|(
literal|"mkdir "
operator|+
name|d
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"ls "
operator|+
name|d
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"rmdir "
operator|+
name|d
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dir should no longer exist
name|execAssertFails
argument_list|(
literal|"ls "
operator|+
name|d
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Test basic file creation and writing */
annotation|@
name|Test
DECL|method|testCreate ()
specifier|public
name|void
name|testCreate
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|String
name|contents
init|=
literal|"hello world"
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|mountPoint
argument_list|,
literal|"file1"
argument_list|)
decl_stmt|;
comment|// Create and access via the mount
name|createFile
argument_list|(
name|f
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|// XX avoids premature EOF
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{ }
name|checkFile
argument_list|(
name|f
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|// Cat, stat and delete via the mount
name|execAssertSucceeds
argument_list|(
literal|"cat "
operator|+
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"stat "
operator|+
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"rm "
operator|+
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// The file should no longer exist
name|execAssertFails
argument_list|(
literal|"ls "
operator|+
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Test creating a file via touch */
annotation|@
name|Test
DECL|method|testTouch ()
specifier|public
name|void
name|testTouch
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|mountPoint
argument_list|,
literal|"file1"
argument_list|)
decl_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"touch "
operator|+
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"rm "
operator|+
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Test random access to a file */
annotation|@
name|Test
DECL|method|testRandomAccess ()
specifier|public
name|void
name|testRandomAccess
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|String
name|contents
init|=
literal|"hello world"
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|mountPoint
argument_list|,
literal|"file1"
argument_list|)
decl_stmt|;
name|createFile
argument_list|(
name|f
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|RandomAccessFile
name|raf
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|f
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|raf
operator|.
name|seek
argument_list|(
name|f
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|raf
operator|.
name|write
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected: fuse-dfs not yet support append
name|assertEquals
argument_list|(
literal|"Operation not supported"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|raf
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|raf
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|f
argument_list|,
literal|"rw"
argument_list|)
expr_stmt|;
name|raf
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
name|raf
operator|.
name|write
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Over-wrote existing bytes"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected: can-not overwrite a file
name|assertEquals
argument_list|(
literal|"Invalid argument"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|raf
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|execAssertSucceeds
argument_list|(
literal|"rm "
operator|+
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Test copying a set of files from the mount to itself */
annotation|@
name|Test
DECL|method|testCopyFiles ()
specifier|public
name|void
name|testCopyFiles
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|String
name|contents
init|=
literal|"hello world"
decl_stmt|;
name|File
name|d1
init|=
operator|new
name|File
argument_list|(
name|mountPoint
argument_list|,
literal|"dir1"
argument_list|)
decl_stmt|;
name|File
name|d2
init|=
operator|new
name|File
argument_list|(
name|mountPoint
argument_list|,
literal|"dir2"
argument_list|)
decl_stmt|;
comment|// Create and populate dir1 via the mount
name|execAssertSucceeds
argument_list|(
literal|"mkdir "
operator|+
name|d1
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|createFile
argument_list|(
operator|new
name|File
argument_list|(
name|d1
argument_list|,
literal|"file"
operator|+
name|i
argument_list|)
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|d1
operator|.
name|listFiles
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Copy dir from the mount to the mount
name|execAssertSucceeds
argument_list|(
literal|"cp -r "
operator|+
name|d1
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" "
operator|+
name|d2
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|d2
operator|.
name|listFiles
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Access all the files in the dirs and remove them
name|execAssertSucceeds
argument_list|(
literal|"find "
operator|+
name|d1
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"find "
operator|+
name|d2
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"rm -r "
operator|+
name|d1
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|execAssertSucceeds
argument_list|(
literal|"rm -r "
operator|+
name|d2
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Test concurrent creation and access of the mount */
annotation|@
name|Test
DECL|method|testMultipleThreads ()
specifier|public
name|void
name|testMultipleThreads
parameter_list|()
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|Thread
argument_list|>
name|threads
init|=
operator|new
name|ArrayList
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|String
argument_list|>
name|errorMessage
init|=
operator|new
name|AtomicReference
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|File
name|d
init|=
operator|new
name|File
argument_list|(
name|mountPoint
argument_list|,
literal|"dir"
operator|+
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|execWaitRet
argument_list|(
literal|"mkdir "
operator|+
name|d
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|d
argument_list|,
literal|"file"
operator|+
name|j
argument_list|)
decl_stmt|;
specifier|final
name|String
name|contents
init|=
literal|"thread "
operator|+
name|getId
argument_list|()
operator|+
literal|" "
operator|+
name|j
decl_stmt|;
name|createFile
argument_list|(
name|f
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|d
argument_list|,
literal|"file"
operator|+
name|j
argument_list|)
decl_stmt|;
name|execWaitRet
argument_list|(
literal|"cat "
operator|+
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|execWaitRet
argument_list|(
literal|"rm "
operator|+
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|execWaitRet
argument_list|(
literal|"rmdir "
operator|+
name|d
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|errorMessage
operator|.
name|set
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Exception %s"
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
name|threads
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Thread
name|t
range|:
name|threads
control|)
block|{
try|try
block|{
name|t
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|fail
argument_list|(
literal|"Thread interrupted: "
operator|+
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|assertNull
argument_list|(
name|errorMessage
operator|.
name|get
argument_list|()
argument_list|,
name|errorMessage
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

