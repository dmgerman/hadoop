begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.federation.router
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|RouterConfigBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|RouterDFSCluster
operator|.
name|NamenodeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|RouterDFSCluster
operator|.
name|RouterContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|StateStoreDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|MountTableManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|MultipleDestinationMountTableResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|order
operator|.
name|DestinationOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|AddMountTableEntryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|AddMountTableEntryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|GetMountTableEntriesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|GetMountTableEntriesResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|MountTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * Tests the use of the resolvers that write in all subclusters from the  * Router. It supports:  *<li>HashResolver  *<li>RandomResolver.  */
end_comment

begin_class
DECL|class|TestRouterAllResolver
specifier|public
class|class
name|TestRouterAllResolver
block|{
comment|/** Directory that will be in a HASH_ALL mount point. */
DECL|field|TEST_DIR_HASH_ALL
specifier|private
specifier|static
specifier|final
name|String
name|TEST_DIR_HASH_ALL
init|=
literal|"/hashall"
decl_stmt|;
comment|/** Directory that will be in a HASH_ALL mount point. */
DECL|field|TEST_DIR_RANDOM
specifier|private
specifier|static
specifier|final
name|String
name|TEST_DIR_RANDOM
init|=
literal|"/random"
decl_stmt|;
comment|/** Number of namespaces. */
DECL|field|NUM_NAMESPACES
specifier|private
specifier|static
specifier|final
name|int
name|NUM_NAMESPACES
init|=
literal|2
decl_stmt|;
comment|/** Mini HDFS clusters with Routers and State Store. */
DECL|field|cluster
specifier|private
specifier|static
name|StateStoreDFSCluster
name|cluster
decl_stmt|;
comment|/** Router for testing. */
DECL|field|routerContext
specifier|private
specifier|static
name|RouterContext
name|routerContext
decl_stmt|;
comment|/** Router/federated filesystem. */
DECL|field|routerFs
specifier|private
specifier|static
name|FileSystem
name|routerFs
decl_stmt|;
comment|/** Filesystem for each namespace. */
DECL|field|nsFss
specifier|private
specifier|static
name|List
argument_list|<
name|FileSystem
argument_list|>
name|nsFss
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Before
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
comment|// 2 nameservices with 1 namenode each (no HA needed for this test)
name|cluster
operator|=
operator|new
name|StateStoreDFSCluster
argument_list|(
literal|false
argument_list|,
name|NUM_NAMESPACES
argument_list|,
name|MultipleDestinationMountTableResolver
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// Start NNs and DNs and wait until ready
name|cluster
operator|.
name|startCluster
argument_list|()
expr_stmt|;
comment|// Build and start a Router with: State Store + Admin + RPC
name|Configuration
name|routerConf
init|=
operator|new
name|RouterConfigBuilder
argument_list|()
operator|.
name|stateStore
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|rpc
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|cluster
operator|.
name|addRouterOverrides
argument_list|(
name|routerConf
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|startRouters
argument_list|()
expr_stmt|;
name|routerContext
operator|=
name|cluster
operator|.
name|getRandomRouter
argument_list|()
expr_stmt|;
comment|// Register and verify all NNs with all routers
name|cluster
operator|.
name|registerNamenodes
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitNamenodeRegistration
argument_list|()
expr_stmt|;
comment|// Setup the test mount point
name|createMountTableEntry
argument_list|(
name|TEST_DIR_HASH_ALL
argument_list|,
name|DestinationOrder
operator|.
name|HASH_ALL
argument_list|)
expr_stmt|;
name|createMountTableEntry
argument_list|(
name|TEST_DIR_RANDOM
argument_list|,
name|DestinationOrder
operator|.
name|RANDOM
argument_list|)
expr_stmt|;
comment|// Get filesystems for federated and each namespace
name|routerFs
operator|=
name|routerContext
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|nsId
range|:
name|cluster
operator|.
name|getNameservices
argument_list|()
control|)
block|{
name|List
argument_list|<
name|NamenodeContext
argument_list|>
name|nns
init|=
name|cluster
operator|.
name|getNamenodes
argument_list|(
name|nsId
argument_list|)
decl_stmt|;
for|for
control|(
name|NamenodeContext
name|nn
range|:
name|nns
control|)
block|{
name|FileSystem
name|nnFs
init|=
name|nn
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|nsFss
operator|.
name|add
argument_list|(
name|nnFs
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|NUM_NAMESPACES
argument_list|,
name|nsFss
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|cleanup ()
specifier|public
name|void
name|cleanup
parameter_list|()
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
name|routerContext
operator|=
literal|null
expr_stmt|;
name|routerFs
operator|=
literal|null
expr_stmt|;
name|nsFss
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testHashAll ()
specifier|public
name|void
name|testHashAll
parameter_list|()
throws|throws
name|Exception
block|{
name|testAll
argument_list|(
name|TEST_DIR_HASH_ALL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRandomAll ()
specifier|public
name|void
name|testRandomAll
parameter_list|()
throws|throws
name|Exception
block|{
name|testAll
argument_list|(
name|TEST_DIR_RANDOM
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that the resolver spreads files across subclusters in the whole    * tree.    * @throws Exception If the resolver is not working.    */
DECL|method|testAll (final String path)
specifier|private
name|void
name|testAll
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Create directories in different levels
name|routerFs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir0"
argument_list|)
argument_list|)
expr_stmt|;
name|routerFs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir1"
argument_list|)
argument_list|)
expr_stmt|;
name|routerFs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir2/dir20"
argument_list|)
argument_list|)
expr_stmt|;
name|routerFs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir2/dir21"
argument_list|)
argument_list|)
expr_stmt|;
name|routerFs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir2/dir22"
argument_list|)
argument_list|)
expr_stmt|;
name|routerFs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir2/dir22/dir220"
argument_list|)
argument_list|)
expr_stmt|;
name|routerFs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir2/dir22/dir221"
argument_list|)
argument_list|)
expr_stmt|;
name|routerFs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir2/dir22/dir222"
argument_list|)
argument_list|)
expr_stmt|;
name|assertDirsEverywhere
argument_list|(
name|path
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|// Create 14 files at different levels of the tree
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir0/file1.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir0/file2.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir1/file2.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir1/file3.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir20/file4.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir20/file5.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir21/file6.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir21/file7.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir22/file8.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir22/file9.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir22/dir220/file10.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir22/dir220/file11.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir22/dir220/file12.txt"
argument_list|)
expr_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|path
operator|+
literal|"/dir2/dir22/dir220/file13.txt"
argument_list|)
expr_stmt|;
name|assertDirsEverywhere
argument_list|(
name|path
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|assertFilesDistributed
argument_list|(
name|path
argument_list|,
literal|14
argument_list|)
expr_stmt|;
comment|// Test append
name|String
name|testFile
init|=
name|path
operator|+
literal|"/dir2/dir22/dir220/file-append.txt"
decl_stmt|;
name|createTestFile
argument_list|(
name|routerFs
argument_list|,
name|testFile
argument_list|)
expr_stmt|;
name|Path
name|testFilePath
init|=
operator|new
name|Path
argument_list|(
name|testFile
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Created file is too small"
argument_list|,
name|routerFs
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
operator|.
name|getLen
argument_list|()
operator|>
literal|50
argument_list|)
expr_stmt|;
name|appendTestFile
argument_list|(
name|routerFs
argument_list|,
name|testFile
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Append file is too small"
argument_list|,
name|routerFs
operator|.
name|getFileStatus
argument_list|(
name|testFilePath
argument_list|)
operator|.
name|getLen
argument_list|()
operator|>
literal|110
argument_list|)
expr_stmt|;
name|assertDirsEverywhere
argument_list|(
name|path
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|assertFilesDistributed
argument_list|(
name|path
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|// Removing a directory should remove it from every subcluster
name|routerFs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir2/dir22/dir220"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertDirsEverywhere
argument_list|(
name|path
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|assertFilesDistributed
argument_list|(
name|path
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|// Removing all sub directories
name|routerFs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir0"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|routerFs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir1"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|routerFs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|path
operator|+
literal|"/dir2"
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertDirsEverywhere
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertFilesDistributed
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Directories in HASH_ALL mount points must be in every namespace.    * @param path Path to check under.    * @param expectedNumDirs Expected number of directories.    * @throws IOException If it cannot check the directories.    */
DECL|method|assertDirsEverywhere (String path, int expectedNumDirs)
specifier|private
name|void
name|assertDirsEverywhere
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|expectedNumDirs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Check for the directories in each filesystem
name|List
argument_list|<
name|FileStatus
argument_list|>
name|files
init|=
name|listRecursive
argument_list|(
name|routerFs
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|int
name|numDirs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FileStatus
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|numDirs
operator|++
expr_stmt|;
name|Path
name|dirPath
init|=
name|file
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|checkPath
init|=
name|getRelativePath
argument_list|(
name|dirPath
argument_list|)
decl_stmt|;
for|for
control|(
name|FileSystem
name|nsFs
range|:
name|nsFss
control|)
block|{
name|FileStatus
name|fileStatus1
init|=
name|nsFs
operator|.
name|getFileStatus
argument_list|(
name|checkPath
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|file
operator|+
literal|" should be a directory"
argument_list|,
name|fileStatus1
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|assertEquals
argument_list|(
name|expectedNumDirs
argument_list|,
name|numDirs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the files are somewhat spread across namespaces.    * @param path Path to check under.    * @param expectedNumFiles Number of files expected.    * @throws IOException If the files cannot be checked.    */
DECL|method|assertFilesDistributed (String path, int expectedNumFiles)
specifier|private
name|void
name|assertFilesDistributed
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|expectedNumFiles
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Check where the files went
name|List
argument_list|<
name|FileStatus
argument_list|>
name|routerFiles
init|=
name|listRecursive
argument_list|(
name|routerFs
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|FileStatus
argument_list|>
argument_list|>
name|nssFiles
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileSystem
name|nsFs
range|:
name|nsFss
control|)
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|nsFiles
init|=
name|listRecursive
argument_list|(
name|nsFs
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|nssFiles
operator|.
name|add
argument_list|(
name|nsFiles
argument_list|)
expr_stmt|;
block|}
comment|// We should see all the files in the federated view
name|int
name|numRouterFiles
init|=
name|getNumTxtFiles
argument_list|(
name|routerFiles
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|numRouterFiles
argument_list|,
name|expectedNumFiles
argument_list|)
expr_stmt|;
comment|// All the files should be spread somewhat evenly across subclusters
name|List
argument_list|<
name|Integer
argument_list|>
name|numNsFiles
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|sumNsFiles
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_NAMESPACES
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|nsFiles
init|=
name|nssFiles
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|numFiles
init|=
name|getNumTxtFiles
argument_list|(
name|nsFiles
argument_list|)
decl_stmt|;
name|numNsFiles
operator|.
name|add
argument_list|(
name|numFiles
argument_list|)
expr_stmt|;
name|sumNsFiles
operator|+=
name|numFiles
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|numRouterFiles
argument_list|,
name|sumNsFiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedNumFiles
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|numFiles
range|:
name|numNsFiles
control|)
block|{
name|assertTrue
argument_list|(
literal|"Files not distributed: "
operator|+
name|numNsFiles
argument_list|,
name|numFiles
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Create a test file in the filesystem and check if it was written.    * @param fs Filesystem.    * @param filename Name of the file to create.    * @throws IOException If it cannot create the file.    */
DECL|method|createTestFile ( final FileSystem fs, final String filename)
specifier|private
specifier|static
name|void
name|createTestFile
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|filename
argument_list|)
decl_stmt|;
comment|// Write the data
name|FSDataOutputStream
name|os
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|os
operator|.
name|writeUTF
argument_list|(
literal|"Test data "
operator|+
name|filename
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Read the data and check
name|FSDataInputStream
name|is
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|read
init|=
name|is
operator|.
name|readUTF
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Test data "
operator|+
name|filename
argument_list|,
name|read
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Append to a test file in the filesystem and check if we appended.    * @param fs Filesystem.    * @param filename Name of the file to append to.    * @throws IOException    */
DECL|method|appendTestFile ( final FileSystem fs, final String filename)
specifier|private
specifier|static
name|void
name|appendTestFile
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|filename
argument_list|)
decl_stmt|;
comment|// Write the data
name|FSDataOutputStream
name|os
init|=
name|fs
operator|.
name|append
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|os
operator|.
name|writeUTF
argument_list|(
literal|"Test append data "
operator|+
name|filename
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Read the data previous data
name|FSDataInputStream
name|is
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|read
init|=
name|is
operator|.
name|readUTF
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|read
argument_list|,
literal|"Test data "
operator|+
name|filename
argument_list|)
expr_stmt|;
comment|// Read the new data and check
name|read
operator|=
name|is
operator|.
name|readUTF
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|read
argument_list|,
literal|"Test append data "
operator|+
name|filename
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Count the number of text files in a list.    * @param files File list.    * @return Number of .txt files.    */
DECL|method|getNumTxtFiles (final List<FileStatus> files)
specifier|private
specifier|static
name|int
name|getNumTxtFiles
parameter_list|(
specifier|final
name|List
argument_list|<
name|FileStatus
argument_list|>
name|files
parameter_list|)
block|{
name|int
name|numFiles
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FileStatus
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".txt"
argument_list|)
condition|)
block|{
name|numFiles
operator|++
expr_stmt|;
block|}
block|}
return|return
name|numFiles
return|;
block|}
comment|/**    * Get the relative path within a filesystem (removes the filesystem prefix).    * @param path Path to check.    * @return File within the filesystem.    */
DECL|method|getRelativePath (final Path path)
specifier|private
specifier|static
name|Path
name|getRelativePath
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
block|{
name|URI
name|uri
init|=
name|path
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|String
name|uriPath
init|=
name|uri
operator|.
name|getPath
argument_list|()
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|uriPath
argument_list|)
return|;
block|}
comment|/**    * Get the list the files/dirs under a path.    * @param fs Filesystem to check in.    * @param path Path to check for.    * @return List of files.    * @throws IOException If it cannot list the files.    */
DECL|method|listRecursive ( final FileSystem fs, final String path)
specifier|private
name|List
argument_list|<
name|FileStatus
argument_list|>
name|listRecursive
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|ret
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|temp
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|temp
operator|.
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|temp
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Path
name|p
init|=
name|temp
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|fs
operator|.
name|listStatus
argument_list|(
name|p
argument_list|)
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|fileStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|temp
operator|.
name|add
argument_list|(
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Add a mount table entry in all nameservices and wait until it is    * available in all routers.    * @param mountPoint Name of the mount point.    * @param order Order of the mount table entry.    * @throws Exception If the entry could not be created.    */
DECL|method|createMountTableEntry ( final String mountPoint, final DestinationOrder order)
specifier|private
name|void
name|createMountTableEntry
parameter_list|(
specifier|final
name|String
name|mountPoint
parameter_list|,
specifier|final
name|DestinationOrder
name|order
parameter_list|)
throws|throws
name|Exception
block|{
name|RouterClient
name|admin
init|=
name|routerContext
operator|.
name|getAdminClient
argument_list|()
decl_stmt|;
name|MountTableManager
name|mountTable
init|=
name|admin
operator|.
name|getMountTableManager
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|destMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|nsId
range|:
name|cluster
operator|.
name|getNameservices
argument_list|()
control|)
block|{
name|destMap
operator|.
name|put
argument_list|(
name|nsId
argument_list|,
name|mountPoint
argument_list|)
expr_stmt|;
block|}
name|MountTable
name|newEntry
init|=
name|MountTable
operator|.
name|newInstance
argument_list|(
name|mountPoint
argument_list|,
name|destMap
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|setDestOrder
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|AddMountTableEntryRequest
name|addRequest
init|=
name|AddMountTableEntryRequest
operator|.
name|newInstance
argument_list|(
name|newEntry
argument_list|)
decl_stmt|;
name|AddMountTableEntryResponse
name|addResponse
init|=
name|mountTable
operator|.
name|addMountTableEntry
argument_list|(
name|addRequest
argument_list|)
decl_stmt|;
name|boolean
name|created
init|=
name|addResponse
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|created
argument_list|)
expr_stmt|;
comment|// Refresh the caches to get the mount table
name|Router
name|router
init|=
name|routerContext
operator|.
name|getRouter
argument_list|()
decl_stmt|;
name|StateStoreService
name|stateStore
init|=
name|router
operator|.
name|getStateStore
argument_list|()
decl_stmt|;
name|stateStore
operator|.
name|refreshCaches
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Check for the path
name|GetMountTableEntriesRequest
name|getRequest
init|=
name|GetMountTableEntriesRequest
operator|.
name|newInstance
argument_list|(
name|mountPoint
argument_list|)
decl_stmt|;
name|GetMountTableEntriesResponse
name|getResponse
init|=
name|mountTable
operator|.
name|getMountTableEntries
argument_list|(
name|getRequest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|MountTable
argument_list|>
name|entries
init|=
name|getResponse
operator|.
name|getEntries
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|mountPoint
argument_list|,
name|entries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getSourcePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

