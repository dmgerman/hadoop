begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.federation.router
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|FederationStateStoreTestUtils
operator|.
name|getStateStoreConfiguration
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|MockNamenode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|RouterConfigBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|ActiveNamenodeResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|FileSubclusterResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|MembershipNamenodeResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|MountTableManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|MultipleDestinationMountTableResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|NamenodeStatusReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|order
operator|.
name|DestinationOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|AddMountTableEntryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|AddMountTableEntryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|GetMountTableEntriesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|GetMountTableEntriesResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|UpdateMountTableEntryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|UpdateMountTableEntryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|MountTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Test the handling of fault tolerant mount points in the Router.  */
end_comment

begin_class
DECL|class|TestRouterFaultTolerant
specifier|public
class|class
name|TestRouterFaultTolerant
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestRouterFaultTolerant
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Number of files to create for testing. */
DECL|field|NUM_FILES
specifier|private
specifier|static
specifier|final
name|int
name|NUM_FILES
init|=
literal|10
decl_stmt|;
comment|/** Number of Routers for test. */
DECL|field|NUM_ROUTERS
specifier|private
specifier|static
specifier|final
name|int
name|NUM_ROUTERS
init|=
literal|2
decl_stmt|;
comment|/** Namenodes for the test per name service id (subcluster). */
DECL|field|namenodes
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|MockNamenode
argument_list|>
name|namenodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Routers for the test. */
DECL|field|routers
specifier|private
name|List
argument_list|<
name|Router
argument_list|>
name|routers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Run test tasks in parallel. */
DECL|field|service
specifier|private
name|ExecutorService
name|service
decl_stmt|;
annotation|@
name|Before
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Start the Namenodes"
argument_list|)
expr_stmt|;
name|Configuration
name|nnConf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|nnConf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HANDLER_COUNT_KEY
argument_list|,
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|String
name|nsId
range|:
name|asList
argument_list|(
literal|"ns0"
argument_list|,
literal|"ns1"
argument_list|)
control|)
block|{
name|MockNamenode
name|nn
init|=
operator|new
name|MockNamenode
argument_list|(
name|nsId
argument_list|,
name|nnConf
argument_list|)
decl_stmt|;
name|nn
operator|.
name|transitionToActive
argument_list|()
expr_stmt|;
name|nn
operator|.
name|addFileSystemMock
argument_list|()
expr_stmt|;
name|namenodes
operator|.
name|put
argument_list|(
name|nsId
argument_list|,
name|nn
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Start the Routers"
argument_list|)
expr_stmt|;
name|Configuration
name|routerConf
init|=
operator|new
name|RouterConfigBuilder
argument_list|()
operator|.
name|stateStore
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|rpc
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|routerConf
operator|.
name|set
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_RPC_ADDRESS_KEY
argument_list|,
literal|"0.0.0.0:0"
argument_list|)
expr_stmt|;
name|routerConf
operator|.
name|set
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_HTTP_ADDRESS_KEY
argument_list|,
literal|"0.0.0.0:0"
argument_list|)
expr_stmt|;
name|routerConf
operator|.
name|set
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_ADMIN_ADDRESS_KEY
argument_list|,
literal|"0.0.0.0:0"
argument_list|)
expr_stmt|;
comment|// Speedup time outs
name|routerConf
operator|.
name|setTimeDuration
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_CLIENT_CONNECT_TIMEOUT
argument_list|,
literal|500
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|Configuration
name|stateStoreConf
init|=
name|getStateStoreConfiguration
argument_list|()
decl_stmt|;
name|stateStoreConf
operator|.
name|setClass
argument_list|(
name|RBFConfigKeys
operator|.
name|FEDERATION_NAMENODE_RESOLVER_CLIENT_CLASS
argument_list|,
name|MembershipNamenodeResolver
operator|.
name|class
argument_list|,
name|ActiveNamenodeResolver
operator|.
name|class
argument_list|)
expr_stmt|;
name|stateStoreConf
operator|.
name|setClass
argument_list|(
name|RBFConfigKeys
operator|.
name|FEDERATION_FILE_RESOLVER_CLIENT_CLASS
argument_list|,
name|MultipleDestinationMountTableResolver
operator|.
name|class
argument_list|,
name|FileSubclusterResolver
operator|.
name|class
argument_list|)
expr_stmt|;
name|routerConf
operator|.
name|addResource
argument_list|(
name|stateStoreConf
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_ROUTERS
condition|;
name|i
operator|++
control|)
block|{
comment|// router0 doesn't allow partial listing
name|routerConf
operator|.
name|setBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_ALLOW_PARTIAL_LIST
argument_list|,
name|i
operator|!=
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|Router
name|router
init|=
operator|new
name|Router
argument_list|()
decl_stmt|;
name|router
operator|.
name|init
argument_list|(
name|routerConf
argument_list|)
expr_stmt|;
name|router
operator|.
name|start
argument_list|()
expr_stmt|;
name|routers
operator|.
name|add
argument_list|(
name|router
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registering the subclusters in the Routers"
argument_list|)
expr_stmt|;
name|registerSubclusters
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
literal|"ns1"
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Stop ns1 to simulate an unavailable subcluster"
argument_list|)
expr_stmt|;
name|namenodes
operator|.
name|get
argument_list|(
literal|"ns1"
argument_list|)
operator|.
name|stop
argument_list|()
expr_stmt|;
name|service
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/**    * Register the subclusters in all Routers.    * @param unavailableSubclusters Set of unavailable subclusters.    * @throws IOException If it cannot register a subcluster.    */
DECL|method|registerSubclusters (Set<String> unavailableSubclusters)
specifier|private
name|void
name|registerSubclusters
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|unavailableSubclusters
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
specifier|final
name|Router
name|router
range|:
name|routers
control|)
block|{
name|MembershipNamenodeResolver
name|resolver
init|=
operator|(
name|MembershipNamenodeResolver
operator|)
name|router
operator|.
name|getNamenodeResolver
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|MockNamenode
name|nn
range|:
name|namenodes
operator|.
name|values
argument_list|()
control|)
block|{
name|String
name|nsId
init|=
name|nn
operator|.
name|getNameserviceId
argument_list|()
decl_stmt|;
name|String
name|rpcAddress
init|=
literal|"localhost:"
operator|+
name|nn
operator|.
name|getRPCPort
argument_list|()
decl_stmt|;
name|String
name|httpAddress
init|=
literal|"localhost:"
operator|+
name|nn
operator|.
name|getHTTPPort
argument_list|()
decl_stmt|;
name|NamenodeStatusReport
name|report
init|=
operator|new
name|NamenodeStatusReport
argument_list|(
name|nsId
argument_list|,
literal|null
argument_list|,
name|rpcAddress
argument_list|,
name|rpcAddress
argument_list|,
name|rpcAddress
argument_list|,
name|httpAddress
argument_list|)
decl_stmt|;
if|if
condition|(
name|unavailableSubclusters
operator|.
name|contains
argument_list|(
name|nsId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Register {} as UNAVAILABLE"
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
name|report
operator|.
name|setRegistrationValid
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Register {} as ACTIVE"
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
name|report
operator|.
name|setRegistrationValid
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|report
operator|.
name|setNamespaceInfo
argument_list|(
operator|new
name|NamespaceInfo
argument_list|(
literal|0
argument_list|,
name|nsId
argument_list|,
name|nsId
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|resolver
operator|.
name|registerNamenode
argument_list|(
name|report
argument_list|)
expr_stmt|;
block|}
name|resolver
operator|.
name|loadCache
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|After
DECL|method|cleanup ()
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping the cluster"
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|MockNamenode
name|nn
range|:
name|namenodes
operator|.
name|values
argument_list|()
control|)
block|{
name|nn
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|namenodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|routers
operator|.
name|forEach
argument_list|(
name|router
lambda|->
name|router
operator|.
name|stop
argument_list|()
argument_list|)
expr_stmt|;
name|routers
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|service
operator|!=
literal|null
condition|)
block|{
name|service
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|service
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Add a mount table entry in some name services and wait until it is    * available.    * @param mountPoint Name of the mount point.    * @param order Order of the mount table entry.    * @param nsIds Name service identifiers.    * @throws Exception If the entry could not be created.    */
DECL|method|createMountTableEntry ( final String mountPoint, final DestinationOrder order, Collection<String> nsIds)
specifier|private
name|void
name|createMountTableEntry
parameter_list|(
specifier|final
name|String
name|mountPoint
parameter_list|,
specifier|final
name|DestinationOrder
name|order
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|nsIds
parameter_list|)
throws|throws
name|Exception
block|{
name|Router
name|router
init|=
name|getRandomRouter
argument_list|()
decl_stmt|;
name|RouterClient
name|admin
init|=
name|getAdminClient
argument_list|(
name|router
argument_list|)
decl_stmt|;
name|MountTableManager
name|mountTable
init|=
name|admin
operator|.
name|getMountTableManager
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|destMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|nsId
range|:
name|nsIds
control|)
block|{
name|destMap
operator|.
name|put
argument_list|(
name|nsId
argument_list|,
name|mountPoint
argument_list|)
expr_stmt|;
block|}
name|MountTable
name|newEntry
init|=
name|MountTable
operator|.
name|newInstance
argument_list|(
name|mountPoint
argument_list|,
name|destMap
argument_list|)
decl_stmt|;
name|newEntry
operator|.
name|setDestOrder
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|AddMountTableEntryRequest
name|addRequest
init|=
name|AddMountTableEntryRequest
operator|.
name|newInstance
argument_list|(
name|newEntry
argument_list|)
decl_stmt|;
name|AddMountTableEntryResponse
name|addResponse
init|=
name|mountTable
operator|.
name|addMountTableEntry
argument_list|(
name|addRequest
argument_list|)
decl_stmt|;
name|boolean
name|created
init|=
name|addResponse
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|created
argument_list|)
expr_stmt|;
name|refreshRoutersCaches
argument_list|()
expr_stmt|;
comment|// Check for the path
name|GetMountTableEntriesRequest
name|getRequest
init|=
name|GetMountTableEntriesRequest
operator|.
name|newInstance
argument_list|(
name|mountPoint
argument_list|)
decl_stmt|;
name|GetMountTableEntriesResponse
name|getResponse
init|=
name|mountTable
operator|.
name|getMountTableEntries
argument_list|(
name|getRequest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|MountTable
argument_list|>
name|entries
init|=
name|getResponse
operator|.
name|getEntries
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Too many entries: "
operator|+
name|entries
argument_list|,
literal|1
argument_list|,
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|mountPoint
argument_list|,
name|entries
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getSourcePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update a mount table entry to be fault tolerant.    * @param mountPoint Mount point to update.    * @throws IOException If it cannot update the mount point.    */
DECL|method|updateMountPointFaultTolerant (final String mountPoint)
specifier|private
name|void
name|updateMountPointFaultTolerant
parameter_list|(
specifier|final
name|String
name|mountPoint
parameter_list|)
throws|throws
name|IOException
block|{
name|Router
name|router
init|=
name|getRandomRouter
argument_list|()
decl_stmt|;
name|RouterClient
name|admin
init|=
name|getAdminClient
argument_list|(
name|router
argument_list|)
decl_stmt|;
name|MountTableManager
name|mountTable
init|=
name|admin
operator|.
name|getMountTableManager
argument_list|()
decl_stmt|;
name|GetMountTableEntriesRequest
name|getRequest
init|=
name|GetMountTableEntriesRequest
operator|.
name|newInstance
argument_list|(
name|mountPoint
argument_list|)
decl_stmt|;
name|GetMountTableEntriesResponse
name|entries
init|=
name|mountTable
operator|.
name|getMountTableEntries
argument_list|(
name|getRequest
argument_list|)
decl_stmt|;
name|MountTable
name|updateEntry
init|=
name|entries
operator|.
name|getEntries
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|updateEntry
operator|.
name|setFaultTolerant
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|UpdateMountTableEntryRequest
name|updateRequest
init|=
name|UpdateMountTableEntryRequest
operator|.
name|newInstance
argument_list|(
name|updateEntry
argument_list|)
decl_stmt|;
name|UpdateMountTableEntryResponse
name|updateResponse
init|=
name|mountTable
operator|.
name|updateMountTableEntry
argument_list|(
name|updateRequest
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|updateResponse
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
name|refreshRoutersCaches
argument_list|()
expr_stmt|;
block|}
comment|/**    * Refresh the caches of all Routers (to get the mount table).    */
DECL|method|refreshRoutersCaches ()
specifier|private
name|void
name|refreshRoutersCaches
parameter_list|()
block|{
for|for
control|(
specifier|final
name|Router
name|router
range|:
name|routers
control|)
block|{
name|StateStoreService
name|stateStore
init|=
name|router
operator|.
name|getStateStore
argument_list|()
decl_stmt|;
name|stateStore
operator|.
name|refreshCaches
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test the behavior of the Router when one of the subclusters in a mount    * point fails. In particular, it checks if it can write files or not.    * Related to {@link TestRouterRpcMultiDestination#testSubclusterDown()}.    */
annotation|@
name|Test
DECL|method|testWriteWithFailedSubcluster ()
specifier|public
name|void
name|testWriteWithFailedSubcluster
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Run the actual tests with each approach
specifier|final
name|List
argument_list|<
name|Callable
argument_list|<
name|Boolean
argument_list|>
argument_list|>
name|tasks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DestinationOrder
argument_list|>
name|orders
init|=
name|asList
argument_list|(
name|DestinationOrder
operator|.
name|HASH_ALL
argument_list|,
name|DestinationOrder
operator|.
name|SPACE
argument_list|,
name|DestinationOrder
operator|.
name|RANDOM
argument_list|,
name|DestinationOrder
operator|.
name|HASH
argument_list|)
decl_stmt|;
for|for
control|(
name|DestinationOrder
name|order
range|:
name|orders
control|)
block|{
name|tasks
operator|.
name|add
argument_list|(
parameter_list|()
lambda|->
block|{
name|testWriteWithFailedSubcluster
argument_list|(
name|order
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
argument_list|)
expr_stmt|;
block|}
name|TaskResults
name|results
init|=
name|collectResults
argument_list|(
literal|"Full tests"
argument_list|,
name|tasks
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|orders
operator|.
name|size
argument_list|()
argument_list|,
name|results
operator|.
name|getSuccess
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the behavior of the Router when one of the subclusters in a mount    * point fails. It assumes that ns1 is already down.    * @param order Destination order of the mount point.    * @throws Exception If we cannot run the test.    */
DECL|method|testWriteWithFailedSubcluster (final DestinationOrder order)
specifier|private
name|void
name|testWriteWithFailedSubcluster
parameter_list|(
specifier|final
name|DestinationOrder
name|order
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|FileSystem
name|router0Fs
init|=
name|getFileSystem
argument_list|(
name|routers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|router1Fs
init|=
name|getFileSystem
argument_list|(
name|routers
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|ns0Fs
init|=
name|getFileSystem
argument_list|(
name|namenodes
operator|.
name|get
argument_list|(
literal|"ns0"
argument_list|)
operator|.
name|getRPCPort
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|mountPoint
init|=
literal|"/"
operator|+
name|order
operator|+
literal|"-failsubcluster"
decl_stmt|;
specifier|final
name|Path
name|mountPath
init|=
operator|new
name|Path
argument_list|(
name|mountPoint
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setup {} with order {}"
argument_list|,
name|mountPoint
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|createMountTableEntry
argument_list|(
name|mountPoint
argument_list|,
name|order
argument_list|,
name|namenodes
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Write in {} should succeed writing in ns0 and fail for ns1"
argument_list|,
name|mountPath
argument_list|)
expr_stmt|;
name|checkDirectoriesFaultTolerant
argument_list|(
name|mountPath
argument_list|,
name|order
argument_list|,
name|router0Fs
argument_list|,
name|router1Fs
argument_list|,
name|ns0Fs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkFilesFaultTolerant
argument_list|(
name|mountPath
argument_list|,
name|order
argument_list|,
name|router0Fs
argument_list|,
name|router1Fs
argument_list|,
name|ns0Fs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Make {} fault tolerant and everything succeeds"
argument_list|,
name|mountPath
argument_list|)
expr_stmt|;
name|IOException
name|ioe
init|=
literal|null
decl_stmt|;
try|try
block|{
name|updateMountPointFaultTolerant
argument_list|(
name|mountPoint
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ioe
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|DestinationOrder
operator|.
name|FOLDER_ALL
operator|.
name|contains
argument_list|(
name|order
argument_list|)
condition|)
block|{
name|assertNull
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
name|checkDirectoriesFaultTolerant
argument_list|(
name|mountPath
argument_list|,
name|order
argument_list|,
name|router0Fs
argument_list|,
name|router1Fs
argument_list|,
name|ns0Fs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|checkFilesFaultTolerant
argument_list|(
name|mountPath
argument_list|,
name|order
argument_list|,
name|router0Fs
argument_list|,
name|router1Fs
argument_list|,
name|ns0Fs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertTrue
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"Invalid entry, fault tolerance only supported for ALL order"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check directory creation on a mount point.    * If it is fault tolerant, it should be able to write everything.    * If it is not fault tolerant, it should fail to write some.    */
DECL|method|checkDirectoriesFaultTolerant ( Path mountPoint, DestinationOrder order, FileSystem router0Fs, FileSystem router1Fs, FileSystem ns0Fs, boolean faultTolerant)
specifier|private
name|void
name|checkDirectoriesFaultTolerant
parameter_list|(
name|Path
name|mountPoint
parameter_list|,
name|DestinationOrder
name|order
parameter_list|,
name|FileSystem
name|router0Fs
parameter_list|,
name|FileSystem
name|router1Fs
parameter_list|,
name|FileSystem
name|ns0Fs
parameter_list|,
name|boolean
name|faultTolerant
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|FileStatus
index|[]
name|dirs0
init|=
name|listStatus
argument_list|(
name|router1Fs
argument_list|,
name|mountPoint
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Create directories in {}"
argument_list|,
name|mountPoint
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Callable
argument_list|<
name|Boolean
argument_list|>
argument_list|>
name|tasks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_FILES
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|mountPoint
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"dir-%s-%03d"
argument_list|,
name|faultTolerant
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getRandomRouterFileSystem
argument_list|()
decl_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|getDirCreateTask
argument_list|(
name|fs
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TaskResults
name|results
init|=
name|collectResults
argument_list|(
literal|"Create dir "
operator|+
name|mountPoint
argument_list|,
name|tasks
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Check directories results for {}: {}"
argument_list|,
name|mountPoint
argument_list|,
name|results
argument_list|)
expr_stmt|;
if|if
condition|(
name|faultTolerant
operator|||
name|DestinationOrder
operator|.
name|FOLDER_ALL
operator|.
name|contains
argument_list|(
name|order
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
name|NUM_FILES
argument_list|,
name|results
operator|.
name|getSuccess
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|results
operator|.
name|getFailure
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertBothResults
argument_list|(
literal|"check dir "
operator|+
name|mountPoint
argument_list|,
name|NUM_FILES
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Check directories listing for {}"
argument_list|,
name|mountPoint
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|getListFailTask
argument_list|(
name|router0Fs
argument_list|,
name|mountPoint
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|filesExpected
init|=
name|dirs0
operator|.
name|length
operator|+
name|results
operator|.
name|getSuccess
argument_list|()
decl_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|getListSuccessTask
argument_list|(
name|router1Fs
argument_list|,
name|mountPoint
argument_list|,
name|filesExpected
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|collectResults
argument_list|(
literal|"List "
operator|+
name|mountPoint
argument_list|,
name|tasks
argument_list|)
operator|.
name|getSuccess
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check file creation on a mount point.    * If it is fault tolerant, it should be able to write everything.    * If it is not fault tolerant, it should fail to write some of the files.    */
DECL|method|checkFilesFaultTolerant ( Path mountPoint, DestinationOrder order, FileSystem router0Fs, FileSystem router1Fs, FileSystem ns0Fs, boolean faultTolerant)
specifier|private
name|void
name|checkFilesFaultTolerant
parameter_list|(
name|Path
name|mountPoint
parameter_list|,
name|DestinationOrder
name|order
parameter_list|,
name|FileSystem
name|router0Fs
parameter_list|,
name|FileSystem
name|router1Fs
parameter_list|,
name|FileSystem
name|ns0Fs
parameter_list|,
name|boolean
name|faultTolerant
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Get one of the existing sub directories
specifier|final
name|FileStatus
index|[]
name|dirs0
init|=
name|listStatus
argument_list|(
name|router1Fs
argument_list|,
name|mountPoint
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dir0
init|=
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
name|dirs0
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Create files in {}"
argument_list|,
name|dir0
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Callable
argument_list|<
name|Boolean
argument_list|>
argument_list|>
name|tasks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_FILES
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|newFile
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s/file-%03d.txt"
argument_list|,
name|dir0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getRandomRouterFileSystem
argument_list|()
decl_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|getFileCreateTask
argument_list|(
name|fs
argument_list|,
name|newFile
argument_list|,
name|ns0Fs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TaskResults
name|results
init|=
name|collectResults
argument_list|(
literal|"Create file "
operator|+
name|dir0
argument_list|,
name|tasks
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Check files results for {}: {}"
argument_list|,
name|dir0
argument_list|,
name|results
argument_list|)
expr_stmt|;
if|if
condition|(
name|faultTolerant
operator|||
operator|!
name|DestinationOrder
operator|.
name|FOLDER_ALL
operator|.
name|contains
argument_list|(
name|order
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
name|NUM_FILES
argument_list|,
name|results
operator|.
name|getSuccess
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|results
operator|.
name|getFailure
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertBothResults
argument_list|(
literal|"check files "
operator|+
name|dir0
argument_list|,
name|NUM_FILES
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Check files listing for {}"
argument_list|,
name|dir0
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|getListFailTask
argument_list|(
name|router0Fs
argument_list|,
name|dir0
argument_list|)
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|getListSuccessTask
argument_list|(
name|router1Fs
argument_list|,
name|dir0
argument_list|,
name|results
operator|.
name|getSuccess
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|collectResults
argument_list|(
literal|"List "
operator|+
name|dir0
argument_list|,
name|tasks
argument_list|)
operator|.
name|getSuccess
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the string representation for the files.    * @param files Files to check.    * @return String representation.    */
DECL|method|toString (final FileStatus[] files)
specifier|private
specifier|static
name|String
name|toString
parameter_list|(
specifier|final
name|FileStatus
index|[]
name|files
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|FileStatus
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * List the files in a path.    * @param fs File system to check.    * @param path Path to list.    * @return List of files.    * @throws IOException If we cannot list.    */
DECL|method|listStatus (final FileSystem fs, final Path path)
specifier|private
name|FileStatus
index|[]
name|listStatus
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|files
init|=
operator|new
name|FileStatus
index|[]
block|{}
decl_stmt|;
try|try
block|{
name|files
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"File not found: {}"
argument_list|,
name|fnfe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|files
return|;
block|}
comment|/**    * Task that creates a file and checks if it is available.    * @param file File to create.    * @param checkFs File system for checking if the file is properly created.    * @return Result of creating the file.    */
DECL|method|getFileCreateTask ( final FileSystem fs, final String file, FileSystem checkFs)
specifier|private
specifier|static
name|Callable
argument_list|<
name|Boolean
argument_list|>
name|getFileCreateTask
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|String
name|file
parameter_list|,
name|FileSystem
name|checkFs
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
block|{
try|try
block|{
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|os
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|// We don't write because we have no mock Datanodes
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
name|FileStatus
name|fileStatus
init|=
name|checkFs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"File not created properly: "
operator|+
name|fileStatus
argument_list|,
name|fileStatus
operator|.
name|getLen
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|;
block|}
comment|/**    * Task that creates a directory.    * @param dir Directory to create.    * @return Result of creating the directory..    */
DECL|method|getDirCreateTask ( final FileSystem fs, final Path dir)
specifier|private
specifier|static
name|Callable
argument_list|<
name|Boolean
argument_list|>
name|getDirCreateTask
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|dir
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
block|{
try|try
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|;
block|}
comment|/**    * Task that lists a directory and expects to fail.    * @param fs File system to check.    * @param path Path to try to list.    * @return If the listing failed as expected.    */
DECL|method|getListFailTask (FileSystem fs, Path path)
specifier|private
specifier|static
name|Callable
argument_list|<
name|Boolean
argument_list|>
name|getListFailTask
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
block|{
try|try
block|{
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|;
block|}
comment|/**    * Task that lists a directory and succeeds.    * @param fs File system to check.    * @param path Path to list.    * @param expected Number of files to expect to find.    * @return If the listing succeeds.    */
DECL|method|getListSuccessTask ( FileSystem fs, Path path, int expected)
specifier|private
specifier|static
name|Callable
argument_list|<
name|Boolean
argument_list|>
name|getListSuccessTask
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
block|{
specifier|final
name|FileStatus
index|[]
name|dirs
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|toString
argument_list|(
name|dirs
argument_list|)
argument_list|,
name|expected
argument_list|,
name|dirs
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|;
block|}
comment|/**    * Invoke a set of tasks and collect their outputs.    * The tasks should do assertions.    *    * @param service Execution Service to run the tasks.    * @param tasks Tasks to run.    * @throws Exception If it cannot collect the results.    */
DECL|method|collectResults (final String tag, final Collection<Callable<Boolean>> tasks)
specifier|private
name|TaskResults
name|collectResults
parameter_list|(
specifier|final
name|String
name|tag
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|Callable
argument_list|<
name|Boolean
argument_list|>
argument_list|>
name|tasks
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|TaskResults
name|results
init|=
operator|new
name|TaskResults
argument_list|()
decl_stmt|;
name|service
operator|.
name|invokeAll
argument_list|(
name|tasks
argument_list|)
operator|.
name|forEach
argument_list|(
name|task
lambda|->
block|{
try|try
block|{
name|boolean
name|succeeded
init|=
name|task
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|succeeded
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got success for {}"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|results
operator|.
name|incrSuccess
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got failure for {}"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|results
operator|.
name|incrFailure
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|fail
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|results
return|;
block|}
comment|/**    * Class to summarize the results of running a task.    */
DECL|class|TaskResults
specifier|static
class|class
name|TaskResults
block|{
DECL|field|success
specifier|private
specifier|final
name|AtomicInteger
name|success
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|failure
specifier|private
specifier|final
name|AtomicInteger
name|failure
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|method|incrSuccess ()
specifier|public
name|void
name|incrSuccess
parameter_list|()
block|{
name|success
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|incrFailure ()
specifier|public
name|void
name|incrFailure
parameter_list|()
block|{
name|failure
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|getSuccess ()
specifier|public
name|int
name|getSuccess
parameter_list|()
block|{
return|return
name|success
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getFailure ()
specifier|public
name|int
name|getFailure
parameter_list|()
block|{
return|return
name|failure
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getTotal ()
specifier|public
name|int
name|getTotal
parameter_list|()
block|{
return|return
name|success
operator|.
name|get
argument_list|()
operator|+
name|failure
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
literal|"Success="
argument_list|)
operator|.
name|append
argument_list|(
name|getSuccess
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" Failure="
argument_list|)
operator|.
name|append
argument_list|(
name|getFailure
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Asserts that the results are the expected amount and it has both success    * and failure.    * @param msg Message to show when the assertion fails.    * @param expected Expected number of results.    * @param actual Actual results.    */
DECL|method|assertBothResults (String msg, int expected, TaskResults actual)
specifier|private
specifier|static
name|void
name|assertBothResults
parameter_list|(
name|String
name|msg
parameter_list|,
name|int
name|expected
parameter_list|,
name|TaskResults
name|actual
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|msg
argument_list|,
name|expected
argument_list|,
name|actual
operator|.
name|getTotal
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Expected some success for "
operator|+
name|msg
argument_list|,
name|actual
operator|.
name|getSuccess
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Expected some failure for "
operator|+
name|msg
argument_list|,
name|actual
operator|.
name|getFailure
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a random Router from the cluster.    * @return Random Router.    */
DECL|method|getRandomRouter ()
specifier|private
name|Router
name|getRandomRouter
parameter_list|()
block|{
name|Random
name|rnd
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|rnd
operator|.
name|nextInt
argument_list|(
name|routers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|routers
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/**    * Get a file system from one of the Routers as a random user to allow better    * concurrency in the Router.    * @return File system from a random user.    * @throws Exception If we cannot create the file system.    */
DECL|method|getRandomRouterFileSystem ()
specifier|private
name|FileSystem
name|getRandomRouterFileSystem
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|UserGroupInformation
name|userUgi
init|=
name|UserGroupInformation
operator|.
name|createUserForTesting
argument_list|(
literal|"user-"
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"group"
block|}
argument_list|)
decl_stmt|;
name|Router
name|router
init|=
name|getRandomRouter
argument_list|()
decl_stmt|;
return|return
name|userUgi
operator|.
name|doAs
argument_list|(
call|(
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
call|)
argument_list|()
operator|->
name|getFileSystem
argument_list|(
name|router
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getFileSystem (int rpcPort)
specifier|private
specifier|static
name|FileSystem
name|getFileSystem
parameter_list|(
name|int
name|rpcPort
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|URI
name|uri
init|=
name|URI
operator|.
name|create
argument_list|(
literal|"hdfs://localhost:"
operator|+
name|rpcPort
argument_list|)
decl_stmt|;
return|return
name|DistributedFileSystem
operator|.
name|get
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
return|;
block|}
DECL|method|getFileSystem (final Router router)
specifier|private
specifier|static
name|FileSystem
name|getFileSystem
parameter_list|(
specifier|final
name|Router
name|router
parameter_list|)
throws|throws
name|IOException
block|{
name|InetSocketAddress
name|rpcAddress
init|=
name|router
operator|.
name|getRpcServerAddress
argument_list|()
decl_stmt|;
name|int
name|rpcPort
init|=
name|rpcAddress
operator|.
name|getPort
argument_list|()
decl_stmt|;
return|return
name|getFileSystem
argument_list|(
name|rpcPort
argument_list|)
return|;
block|}
DECL|method|getAdminClient ( final Router router)
specifier|private
specifier|static
name|RouterClient
name|getAdminClient
parameter_list|(
specifier|final
name|Router
name|router
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|InetSocketAddress
name|routerSocket
init|=
name|router
operator|.
name|getAdminServerAddress
argument_list|()
decl_stmt|;
return|return
operator|new
name|RouterClient
argument_list|(
name|routerSocket
argument_list|,
name|conf
argument_list|)
return|;
block|}
block|}
end_class

end_unit

