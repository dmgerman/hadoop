begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.federation.router
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|NameNodeProxiesClient
operator|.
name|ProxyAndInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|ActiveNamenodeResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|FederationNamenodeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|FederationNamenodeServiceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|RemoteLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
operator|.
name|RetryAction
operator|.
name|RetryDecision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|StandbyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_comment
comment|/**  * A client proxy for Router -> NN communication using the NN ClientProtocol.  *<p>  * Provides routers to invoke remote ClientProtocol methods and handle  * retries/failover.  *<ul>  *<li>invokeSingle Make a single request to a single namespace  *<li>invokeSequential Make a sequential series of requests to multiple  * ordered namespaces until a condition is met.  *<li>invokeConcurrent Make concurrent requests to multiple namespaces and  * return all of the results.  *</ul>  * Also maintains a cached pool of connections to NNs. Connections are managed  * by the ConnectionManager and are unique to each user + NN. The size of the  * connection pool can be configured. Larger pools allow for more simultaneous  * requests to a single NN from a single user.  */
end_comment

begin_class
DECL|class|RouterRpcClient
specifier|public
class|class
name|RouterRpcClient
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RouterRpcClient
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Router identifier. */
DECL|field|routerId
specifier|private
specifier|final
name|String
name|routerId
decl_stmt|;
comment|/** Interface to identify the active NN for a nameservice or blockpool ID. */
DECL|field|namenodeResolver
specifier|private
specifier|final
name|ActiveNamenodeResolver
name|namenodeResolver
decl_stmt|;
comment|/** Connection pool to the Namenodes per user for performance. */
DECL|field|connectionManager
specifier|private
specifier|final
name|ConnectionManager
name|connectionManager
decl_stmt|;
comment|/** Service to run asynchronous calls. */
DECL|field|executorService
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
comment|/** Retry policy for router -> NN communication. */
DECL|field|retryPolicy
specifier|private
specifier|final
name|RetryPolicy
name|retryPolicy
decl_stmt|;
comment|/** Optional perf monitor. */
DECL|field|rpcMonitor
specifier|private
specifier|final
name|RouterRpcMonitor
name|rpcMonitor
decl_stmt|;
comment|/** Pattern to parse a stack trace line. */
DECL|field|STACK_TRACE_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|STACK_TRACE_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\tat (.*)\\.(.*)\\((.*):(\\d*)\\)"
argument_list|)
decl_stmt|;
comment|/**    * Create a router RPC client to manage remote procedure calls to NNs.    *    * @param conf Hdfs Configuation.    * @param resolver A NN resolver to determine the currently active NN in HA.    * @param monitor Optional performance monitor.    */
DECL|method|RouterRpcClient (Configuration conf, String identifier, ActiveNamenodeResolver resolver, RouterRpcMonitor monitor)
specifier|public
name|RouterRpcClient
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|identifier
parameter_list|,
name|ActiveNamenodeResolver
name|resolver
parameter_list|,
name|RouterRpcMonitor
name|monitor
parameter_list|)
block|{
name|this
operator|.
name|routerId
operator|=
name|identifier
expr_stmt|;
name|this
operator|.
name|namenodeResolver
operator|=
name|resolver
expr_stmt|;
name|this
operator|.
name|connectionManager
operator|=
operator|new
name|ConnectionManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectionManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|numThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_CLIENT_THREADS_SIZE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_CLIENT_THREADS_SIZE_DEFAULT
argument_list|)
decl_stmt|;
name|ThreadFactory
name|threadFactory
init|=
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"RPC Router Client-%d"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|this
operator|.
name|executorService
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|numThreads
argument_list|,
name|threadFactory
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcMonitor
operator|=
name|monitor
expr_stmt|;
name|int
name|maxFailoverAttempts
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HdfsClientConfigKeys
operator|.
name|Failover
operator|.
name|MAX_ATTEMPTS_KEY
argument_list|,
name|HdfsClientConfigKeys
operator|.
name|Failover
operator|.
name|MAX_ATTEMPTS_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|maxRetryAttempts
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_CLIENT_MAX_ATTEMPTS
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_CLIENT_MAX_ATTEMPTS_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|failoverSleepBaseMillis
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HdfsClientConfigKeys
operator|.
name|Failover
operator|.
name|SLEEPTIME_BASE_KEY
argument_list|,
name|HdfsClientConfigKeys
operator|.
name|Failover
operator|.
name|SLEEPTIME_BASE_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|failoverSleepMaxMillis
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HdfsClientConfigKeys
operator|.
name|Failover
operator|.
name|SLEEPTIME_MAX_KEY
argument_list|,
name|HdfsClientConfigKeys
operator|.
name|Failover
operator|.
name|SLEEPTIME_MAX_DEFAULT
argument_list|)
decl_stmt|;
name|this
operator|.
name|retryPolicy
operator|=
name|RetryPolicies
operator|.
name|failoverOnNetworkException
argument_list|(
name|RetryPolicies
operator|.
name|TRY_ONCE_THEN_FAIL
argument_list|,
name|maxFailoverAttempts
argument_list|,
name|maxRetryAttempts
argument_list|,
name|failoverSleepBaseMillis
argument_list|,
name|failoverSleepMaxMillis
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the active namenode resolver used by this client.    * @return Active namenode resolver.    */
DECL|method|getNamenodeResolver ()
specifier|public
name|ActiveNamenodeResolver
name|getNamenodeResolver
parameter_list|()
block|{
return|return
name|this
operator|.
name|namenodeResolver
return|;
block|}
comment|/**    * Shutdown the client.    */
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|connectionManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|connectionManager
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|executorService
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|executorService
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Total number of available sockets between the router and NNs.    *    * @return Number of namenode clients.    */
DECL|method|getNumConnections ()
specifier|public
name|int
name|getNumConnections
parameter_list|()
block|{
return|return
name|this
operator|.
name|connectionManager
operator|.
name|getNumConnections
argument_list|()
return|;
block|}
comment|/**    * Total number of available sockets between the router and NNs.    *    * @return Number of namenode clients.    */
DECL|method|getNumActiveConnections ()
specifier|public
name|int
name|getNumActiveConnections
parameter_list|()
block|{
return|return
name|this
operator|.
name|connectionManager
operator|.
name|getNumActiveConnections
argument_list|()
return|;
block|}
comment|/**    * Total number of open connection pools to a NN. Each connection pool.    * represents one user + one NN.    *    * @return Number of connection pools.    */
DECL|method|getNumConnectionPools ()
specifier|public
name|int
name|getNumConnectionPools
parameter_list|()
block|{
return|return
name|this
operator|.
name|connectionManager
operator|.
name|getNumConnectionPools
argument_list|()
return|;
block|}
comment|/**    * Number of connections between the router and NNs being created sockets.    *    * @return Number of connections waiting to be created.    */
DECL|method|getNumCreatingConnections ()
specifier|public
name|int
name|getNumCreatingConnections
parameter_list|()
block|{
return|return
name|this
operator|.
name|connectionManager
operator|.
name|getNumCreatingConnections
argument_list|()
return|;
block|}
comment|/**    * JSON representation of the connection pool.    *    * @return String representation of the JSON.    */
DECL|method|getJSON ()
specifier|public
name|String
name|getJSON
parameter_list|()
block|{
return|return
name|this
operator|.
name|connectionManager
operator|.
name|getJSON
argument_list|()
return|;
block|}
comment|/**    * Get ClientProtocol proxy client for a NameNode. Each combination of user +    * NN must use a unique proxy client. Previously created clients are cached    * and stored in a connection pool by the ConnectionManager.    *    * @param ugi User group information.    * @param nsId Nameservice identifier.    * @param rpcAddress ClientProtocol RPC server address of the NN.    * @return ConnectionContext containing a ClientProtocol proxy client for the    *         NN + current user.    * @throws IOException If we cannot get a connection to the NameNode.    */
DECL|method|getConnection ( UserGroupInformation ugi, String nsId, String rpcAddress)
specifier|private
name|ConnectionContext
name|getConnection
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|String
name|nsId
parameter_list|,
name|String
name|rpcAddress
parameter_list|)
throws|throws
name|IOException
block|{
name|ConnectionContext
name|connection
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Each proxy holds the UGI info for the current user when it is created.
comment|// This cache does not scale very well, one entry per user per namenode,
comment|// and may need to be adjusted and/or selectively pruned. The cache is
comment|// important due to the excessive overhead of creating a new proxy wrapper
comment|// for each individual request.
comment|// TODO Add tokens from the federated UGI
name|connection
operator|=
name|this
operator|.
name|connectionManager
operator|.
name|getConnection
argument_list|(
name|ugi
argument_list|,
name|rpcAddress
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"User {} NN {} is using connection {}"
argument_list|,
name|ugi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|rpcAddress
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot open NN client to address: {}"
argument_list|,
name|rpcAddress
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot get a connection to "
operator|+
name|rpcAddress
argument_list|)
throw|;
block|}
return|return
name|connection
return|;
block|}
comment|/**    * Convert an exception to an IOException.    *    * For a non-IOException, wrap it with IOException. For a RemoteException,    * unwrap it. For an IOException which is not a RemoteException, return it.    *    * @param e Exception to convert into an exception.    * @return Created IO exception.    */
DECL|method|toIOException (Exception e)
specifier|private
specifier|static
name|IOException
name|toIOException
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
return|return
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
return|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
return|return
operator|(
name|IOException
operator|)
name|e
return|;
block|}
return|return
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**    * If we should retry the RPC call.    *    * @param ioe IOException reported.    * @param retryCount Number of retries.    * @param nsId Nameservice ID.    * @return Retry decision.    * @throws IOException Original exception if the retry policy generates one    *                     or IOException for no available namenodes.    */
DECL|method|shouldRetry (final IOException ioe, final int retryCount, final String nsId)
specifier|private
name|RetryDecision
name|shouldRetry
parameter_list|(
specifier|final
name|IOException
name|ioe
parameter_list|,
specifier|final
name|int
name|retryCount
parameter_list|,
specifier|final
name|String
name|nsId
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check for the case of cluster unavailable state
if|if
condition|(
name|isClusterUnAvailable
argument_list|(
name|nsId
argument_list|)
condition|)
block|{
comment|// we allow to retry once if cluster is unavailable
if|if
condition|(
name|retryCount
operator|==
literal|0
condition|)
block|{
return|return
name|RetryDecision
operator|.
name|RETRY
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No namenode available under nameservice "
operator|+
name|nsId
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
try|try
block|{
specifier|final
name|RetryPolicy
operator|.
name|RetryAction
name|a
init|=
name|this
operator|.
name|retryPolicy
operator|.
name|shouldRetry
argument_list|(
name|ioe
argument_list|,
name|retryCount
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|a
operator|.
name|action
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Re-throwing API exception, no more retries"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|toIOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**    * Invokes a method against the ClientProtocol proxy server. If a standby    * exception is generated by the call to the client, retries using the    * alternate server.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param ugi User group information.    * @param namenodes A prioritized list of namenodes within the same    *                  nameservice.    * @param method Remote ClientProtcol method to invoke.    * @param params Variable list of parameters matching the method.    * @return The result of invoking the method.    * @throws IOException    */
DECL|method|invokeMethod ( final UserGroupInformation ugi, final List<? extends FederationNamenodeContext> namenodes, final Method method, final Object... params)
specifier|private
name|Object
name|invokeMethod
parameter_list|(
specifier|final
name|UserGroupInformation
name|ugi
parameter_list|,
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|namenodes
parameter_list|,
specifier|final
name|Method
name|method
parameter_list|,
specifier|final
name|Object
modifier|...
name|params
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|namenodes
operator|==
literal|null
operator|||
name|namenodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No namenodes to invoke "
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|" with params "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|params
argument_list|)
operator|+
literal|" from "
operator|+
name|this
operator|.
name|routerId
argument_list|)
throw|;
block|}
name|Object
name|ret
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rpcMonitor
operator|!=
literal|null
condition|)
block|{
name|rpcMonitor
operator|.
name|proxyOp
argument_list|()
expr_stmt|;
block|}
name|boolean
name|failover
init|=
literal|false
decl_stmt|;
name|Map
argument_list|<
name|FederationNamenodeContext
argument_list|,
name|IOException
argument_list|>
name|ioes
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FederationNamenodeContext
name|namenode
range|:
name|namenodes
control|)
block|{
name|ConnectionContext
name|connection
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|nsId
init|=
name|namenode
operator|.
name|getNameserviceId
argument_list|()
decl_stmt|;
name|String
name|rpcAddress
init|=
name|namenode
operator|.
name|getRpcAddress
argument_list|()
decl_stmt|;
name|connection
operator|=
name|this
operator|.
name|getConnection
argument_list|(
name|ugi
argument_list|,
name|nsId
argument_list|,
name|rpcAddress
argument_list|)
expr_stmt|;
name|ProxyAndInfo
argument_list|<
name|ClientProtocol
argument_list|>
name|client
init|=
name|connection
operator|.
name|getClient
argument_list|()
decl_stmt|;
name|ClientProtocol
name|proxy
init|=
name|client
operator|.
name|getProxy
argument_list|()
decl_stmt|;
name|ret
operator|=
name|invoke
argument_list|(
name|nsId
argument_list|,
literal|0
argument_list|,
name|method
argument_list|,
name|proxy
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|failover
condition|)
block|{
comment|// Success on alternate server, update
name|InetSocketAddress
name|address
init|=
name|client
operator|.
name|getAddress
argument_list|()
decl_stmt|;
name|namenodeResolver
operator|.
name|updateActiveNamenode
argument_list|(
name|nsId
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|rpcMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rpcMonitor
operator|.
name|proxyOpComplete
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|ioes
operator|.
name|put
argument_list|(
name|namenode
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioe
operator|instanceof
name|StandbyException
condition|)
block|{
comment|// Fail over indicated by retry policy and/or NN
if|if
condition|(
name|this
operator|.
name|rpcMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rpcMonitor
operator|.
name|proxyOpFailureStandby
argument_list|()
expr_stmt|;
block|}
name|failover
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioe
operator|instanceof
name|RemoteException
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|rpcMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rpcMonitor
operator|.
name|proxyOpComplete
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// RemoteException returned by NN
throw|throw
operator|(
name|RemoteException
operator|)
name|ioe
throw|;
block|}
else|else
block|{
comment|// Other communication error, this is a failure
comment|// Communication retries are handled by the retry policy
if|if
condition|(
name|this
operator|.
name|rpcMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rpcMonitor
operator|.
name|proxyOpFailureCommunicate
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcMonitor
operator|.
name|proxyOpComplete
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ioe
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|.
name|rpcMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rpcMonitor
operator|.
name|proxyOpComplete
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// All namenodes were unavailable or in standby
name|String
name|msg
init|=
literal|"No namenode available to invoke "
operator|+
name|method
operator|.
name|getName
argument_list|()
operator|+
literal|" "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|params
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|FederationNamenodeContext
argument_list|,
name|IOException
argument_list|>
name|entry
range|:
name|ioes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|FederationNamenodeContext
name|namenode
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|nsId
init|=
name|namenode
operator|.
name|getNameserviceId
argument_list|()
decl_stmt|;
name|String
name|nnId
init|=
name|namenode
operator|.
name|getNamenodeId
argument_list|()
decl_stmt|;
name|String
name|addr
init|=
name|namenode
operator|.
name|getRpcAddress
argument_list|()
decl_stmt|;
name|IOException
name|ioe
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|ioe
operator|instanceof
name|StandbyException
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} {} at {} is in Standby"
argument_list|,
name|nsId
argument_list|,
name|nnId
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} {} at {} error: \"{}\""
argument_list|,
name|nsId
argument_list|,
name|nnId
argument_list|,
name|addr
argument_list|,
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|StandbyException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|/**    * Invokes a method on the designated object. Catches exceptions specific to    * the invocation.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param nsId Identifier for the namespace    * @param retryCount Current retry times    * @param method Method to invoke    * @param obj Target object for the method    * @param params Variable parameters    * @return Response from the remote server    * @throws IOException    * @throws InterruptedException    */
DECL|method|invoke (String nsId, int retryCount, final Method method, final Object obj, final Object... params)
specifier|private
name|Object
name|invoke
parameter_list|(
name|String
name|nsId
parameter_list|,
name|int
name|retryCount
parameter_list|,
specifier|final
name|Method
name|method
parameter_list|,
specifier|final
name|Object
name|obj
parameter_list|,
specifier|final
name|Object
modifier|...
name|params
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|method
operator|.
name|invoke
argument_list|(
name|obj
argument_list|,
name|params
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected exception while proxying API"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected exception while proxying API"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|IOException
condition|)
block|{
name|IOException
name|ioe
init|=
operator|(
name|IOException
operator|)
name|cause
decl_stmt|;
comment|// Check if we should retry.
name|RetryDecision
name|decision
init|=
name|shouldRetry
argument_list|(
name|ioe
argument_list|,
name|retryCount
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
if|if
condition|(
name|decision
operator|==
name|RetryDecision
operator|.
name|RETRY
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|rpcMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rpcMonitor
operator|.
name|proxyOpRetries
argument_list|()
expr_stmt|;
block|}
comment|// retry
return|return
name|invoke
argument_list|(
name|nsId
argument_list|,
operator|++
name|retryCount
argument_list|,
name|method
argument_list|,
name|obj
argument_list|,
name|params
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|decision
operator|==
name|RetryDecision
operator|.
name|FAILOVER_AND_RETRY
condition|)
block|{
comment|// failover, invoker looks for standby exceptions for failover.
if|if
condition|(
name|ioe
operator|instanceof
name|StandbyException
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|StandbyException
argument_list|(
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ioe
operator|instanceof
name|RemoteException
condition|)
block|{
name|RemoteException
name|re
init|=
operator|(
name|RemoteException
operator|)
name|ioe
decl_stmt|;
name|ioe
operator|=
name|re
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
name|ioe
operator|=
name|getCleanException
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ioe
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Check if the cluster of given nameservice id is available.    * @param nsId nameservice ID.    * @return    * @throws IOException    */
DECL|method|isClusterUnAvailable (String nsId)
specifier|private
name|boolean
name|isClusterUnAvailable
parameter_list|(
name|String
name|nsId
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|nnState
init|=
name|this
operator|.
name|namenodeResolver
operator|.
name|getNamenodesForNameserviceId
argument_list|(
name|nsId
argument_list|)
decl_stmt|;
if|if
condition|(
name|nnState
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FederationNamenodeContext
name|nnContext
range|:
name|nnState
control|)
block|{
comment|// Once we find one NN is in active state, we assume this
comment|// cluster is available.
if|if
condition|(
name|nnContext
operator|.
name|getState
argument_list|()
operator|==
name|FederationNamenodeServiceState
operator|.
name|ACTIVE
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Get a clean copy of the exception. Sometimes the exceptions returned by the    * server contain the full stack trace in the message.    *    * @param ioe Exception to clean up.    * @return Copy of the original exception with a clean message.    */
DECL|method|getCleanException (IOException ioe)
specifier|private
specifier|static
name|IOException
name|getCleanException
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|IOException
name|ret
init|=
literal|null
decl_stmt|;
name|String
name|msg
init|=
name|ioe
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|Throwable
name|cause
init|=
name|ioe
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|StackTraceElement
index|[]
name|stackTrace
init|=
name|ioe
operator|.
name|getStackTrace
argument_list|()
decl_stmt|;
comment|// Clean the message by removing the stack trace
name|int
name|index
init|=
name|msg
operator|.
name|indexOf
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|String
index|[]
name|msgSplit
init|=
name|msg
operator|.
name|split
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
name|msg
operator|=
name|msgSplit
index|[
literal|0
index|]
expr_stmt|;
comment|// Parse stack trace from the message
name|List
argument_list|<
name|StackTraceElement
argument_list|>
name|elements
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|msgSplit
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|line
init|=
name|msgSplit
index|[
name|i
index|]
decl_stmt|;
name|Matcher
name|matcher
init|=
name|STACK_TRACE_PATTERN
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|declaringClass
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|methodName
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|String
name|fileName
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|int
name|lineNumber
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|StackTraceElement
name|element
init|=
operator|new
name|StackTraceElement
argument_list|(
name|declaringClass
argument_list|,
name|methodName
argument_list|,
name|fileName
argument_list|,
name|lineNumber
argument_list|)
decl_stmt|;
name|elements
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
block|}
name|stackTrace
operator|=
name|elements
operator|.
name|toArray
argument_list|(
operator|new
name|StackTraceElement
index|[
name|elements
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Create the new output exception
if|if
condition|(
name|ioe
operator|instanceof
name|RemoteException
condition|)
block|{
name|RemoteException
name|re
init|=
operator|(
name|RemoteException
operator|)
name|ioe
decl_stmt|;
name|ret
operator|=
operator|new
name|RemoteException
argument_list|(
name|re
operator|.
name|getClassName
argument_list|()
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Try the simple constructor and initialize the fields
name|Class
argument_list|<
name|?
extends|extends
name|IOException
argument_list|>
name|ioeClass
init|=
name|ioe
operator|.
name|getClass
argument_list|()
decl_stmt|;
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|IOException
argument_list|>
name|constructor
init|=
name|ioeClass
operator|.
name|getDeclaredConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
name|ret
operator|=
name|constructor
operator|.
name|newInstance
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
comment|// If there are errors, just use the input one
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not create exception {}"
argument_list|,
name|ioeClass
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ioe
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
literal|null
condition|)
block|{
name|ret
operator|.
name|initCause
argument_list|(
name|cause
argument_list|)
expr_stmt|;
name|ret
operator|.
name|setStackTrace
argument_list|(
name|stackTrace
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Invokes a ClientProtocol method. Determines the target nameservice via a    * provided block.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param block Block used to determine appropriate nameservice.    * @param method The remote method and parameters to invoke.    * @return The result of invoking the method.    * @throws IOException    */
DECL|method|invokeSingle (final ExtendedBlock block, RemoteMethod method)
specifier|public
name|Object
name|invokeSingle
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|,
name|RemoteMethod
name|method
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|bpId
init|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
return|return
name|invokeSingleBlockPool
argument_list|(
name|bpId
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Invokes a ClientProtocol method. Determines the target nameservice using    * the block pool id.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param bpId Block pool identifier.    * @param method The remote method and parameters to invoke.    * @return The result of invoking the method.    * @throws IOException    */
DECL|method|invokeSingleBlockPool (final String bpId, RemoteMethod method)
specifier|public
name|Object
name|invokeSingleBlockPool
parameter_list|(
specifier|final
name|String
name|bpId
parameter_list|,
name|RemoteMethod
name|method
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nsId
init|=
name|getNameserviceForBlockPoolId
argument_list|(
name|bpId
argument_list|)
decl_stmt|;
return|return
name|invokeSingle
argument_list|(
name|nsId
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Invokes a ClientProtocol method against the specified namespace.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param nsId Target namespace for the method.    * @param method The remote method and parameters to invoke.    * @return The result of invoking the method.    * @throws IOException    */
DECL|method|invokeSingle (final String nsId, RemoteMethod method)
specifier|public
name|Object
name|invokeSingle
parameter_list|(
specifier|final
name|String
name|nsId
parameter_list|,
name|RemoteMethod
name|method
parameter_list|)
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|ugi
init|=
name|RouterRpcServer
operator|.
name|getRemoteUser
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|nns
init|=
name|getNamenodesForNameservice
argument_list|(
name|nsId
argument_list|)
decl_stmt|;
name|RemoteLocationContext
name|loc
init|=
operator|new
name|RemoteLocation
argument_list|(
name|nsId
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
return|return
name|invokeMethod
argument_list|(
name|ugi
argument_list|,
name|nns
argument_list|,
name|method
operator|.
name|getMethod
argument_list|()
argument_list|,
name|method
operator|.
name|getParams
argument_list|(
name|loc
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Invokes a single proxy call for a single location.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param location RemoteLocation to invoke.    * @param remoteMethod The remote method and parameters to invoke.    * @return The result of invoking the method if successful.    * @throws IOException    */
DECL|method|invokeSingle (final RemoteLocationContext location, RemoteMethod remoteMethod)
specifier|public
name|Object
name|invokeSingle
parameter_list|(
specifier|final
name|RemoteLocationContext
name|location
parameter_list|,
name|RemoteMethod
name|remoteMethod
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|RemoteLocationContext
argument_list|>
name|locations
init|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|location
argument_list|)
decl_stmt|;
return|return
name|invokeSequential
argument_list|(
name|locations
argument_list|,
name|remoteMethod
argument_list|)
return|;
block|}
comment|/**    * Invokes sequential proxy calls to different locations. Continues to invoke    * calls until a call returns without throwing a remote exception.    *    * @param locations List of locations/nameservices to call concurrently.    * @param remoteMethod The remote method and parameters to invoke.    * @return The result of the first successful call, or if no calls are    *         successful, the result of the last RPC call executed.    * @throws IOException if the success condition is not met and one of the RPC    *           calls generated a remote exception.    */
DECL|method|invokeSequential ( final List<? extends RemoteLocationContext> locations, final RemoteMethod remoteMethod)
specifier|public
name|Object
name|invokeSequential
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|RemoteLocationContext
argument_list|>
name|locations
parameter_list|,
specifier|final
name|RemoteMethod
name|remoteMethod
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|invokeSequential
argument_list|(
name|locations
argument_list|,
name|remoteMethod
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Invokes sequential proxy calls to different locations. Continues to invoke    * calls until the success condition is met, or until all locations have been    * attempted.    *    * The success condition may be specified by:    *<ul>    *<li>An expected result class    *<li>An expected result value    *</ul>    *    * If no expected result class/values are specified, the success condition is    * a call that does not throw a remote exception.    *    * @param locations List of locations/nameservices to call concurrently.    * @param remoteMethod The remote method and parameters to invoke.    * @param expectedResultClass In order to be considered a positive result, the    *          return type must be of this class.    * @param expectedResultValue In order to be considered a positive result, the    *          return value must equal the value of this object.    * @return The result of the first successful call, or if no calls are    *         successful, the result of the first RPC call executed.    * @throws IOException if the success condition is not met, return the first    *                     remote exception generated.    */
DECL|method|invokeSequential ( final List<? extends RemoteLocationContext> locations, final RemoteMethod remoteMethod, Class<T> expectedResultClass, Object expectedResultValue)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|invokeSequential
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|RemoteLocationContext
argument_list|>
name|locations
parameter_list|,
specifier|final
name|RemoteMethod
name|remoteMethod
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|expectedResultClass
parameter_list|,
name|Object
name|expectedResultValue
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|UserGroupInformation
name|ugi
init|=
name|RouterRpcServer
operator|.
name|getRemoteUser
argument_list|()
decl_stmt|;
specifier|final
name|Method
name|m
init|=
name|remoteMethod
operator|.
name|getMethod
argument_list|()
decl_stmt|;
name|IOException
name|firstThrownException
init|=
literal|null
decl_stmt|;
name|IOException
name|lastThrownException
init|=
literal|null
decl_stmt|;
name|Object
name|firstResult
init|=
literal|null
decl_stmt|;
comment|// Invoke in priority order
for|for
control|(
specifier|final
name|RemoteLocationContext
name|loc
range|:
name|locations
control|)
block|{
name|String
name|ns
init|=
name|loc
operator|.
name|getNameserviceId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|namenodes
init|=
name|getNamenodesForNameservice
argument_list|(
name|ns
argument_list|)
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|params
init|=
name|remoteMethod
operator|.
name|getParams
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|Object
name|result
init|=
name|invokeMethod
argument_list|(
name|ugi
argument_list|,
name|namenodes
argument_list|,
name|m
argument_list|,
name|params
argument_list|)
decl_stmt|;
comment|// Check if the result is what we expected
if|if
condition|(
name|isExpectedClass
argument_list|(
name|expectedResultClass
argument_list|,
name|result
argument_list|)
operator|&&
name|isExpectedValue
argument_list|(
name|expectedResultValue
argument_list|,
name|result
argument_list|)
condition|)
block|{
comment|// Valid result, stop here
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|ret
init|=
operator|(
name|T
operator|)
name|result
decl_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|firstResult
operator|==
literal|null
condition|)
block|{
name|firstResult
operator|=
name|result
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// Record it and move on
name|lastThrownException
operator|=
operator|(
name|IOException
operator|)
name|ioe
expr_stmt|;
if|if
condition|(
name|firstThrownException
operator|==
literal|null
condition|)
block|{
name|firstThrownException
operator|=
name|lastThrownException
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Unusual error, ClientProtocol calls always use IOException (or
comment|// RemoteException). Re-wrap in IOException for compatibility with
comment|// ClientProtcol.
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected exception {} proxying {} to {}"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|,
name|m
operator|.
name|getName
argument_list|()
argument_list|,
name|ns
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|lastThrownException
operator|=
operator|new
name|IOException
argument_list|(
literal|"Unexpected exception proxying API "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstThrownException
operator|==
literal|null
condition|)
block|{
name|firstThrownException
operator|=
name|lastThrownException
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|firstThrownException
operator|!=
literal|null
condition|)
block|{
comment|// re-throw the last exception thrown for compatibility
throw|throw
name|firstThrownException
throw|;
block|}
comment|// Return the last result, whether it is the value we are looking for or a
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|ret
init|=
operator|(
name|T
operator|)
name|firstResult
decl_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Checks if a result matches the required result class.    *    * @param expectedClass Required result class, null to skip the check.    * @param clazz The result to check.    * @return True if the result is an instance of the required class or if the    *         expected class is null.    */
DECL|method|isExpectedClass (Class<?> expectedClass, Object clazz)
specifier|private
specifier|static
name|boolean
name|isExpectedClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|expectedClass
parameter_list|,
name|Object
name|clazz
parameter_list|)
block|{
if|if
condition|(
name|expectedClass
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|expectedClass
operator|.
name|isInstance
argument_list|(
name|clazz
argument_list|)
return|;
block|}
block|}
comment|/**    * Checks if a result matches the expected value.    *    * @param expectedValue The expected value, null to skip the check.    * @param value The result to check.    * @return True if the result is equals to the expected value or if the    *         expected value is null.    */
DECL|method|isExpectedValue (Object expectedValue, Object value)
specifier|private
specifier|static
name|boolean
name|isExpectedValue
parameter_list|(
name|Object
name|expectedValue
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|expectedValue
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|value
operator|.
name|equals
argument_list|(
name|expectedValue
argument_list|)
return|;
block|}
block|}
comment|/**    * Invoke method in all locations and return success if any succeeds.    *    * @param locations List of remote locations to call concurrently.    * @param method The remote method and parameters to invoke.    * @return If the call succeeds in any location.    * @throws IOException If any of the calls return an exception.    */
DECL|method|invokeAll ( final Collection<T> locations, final RemoteMethod method)
specifier|public
parameter_list|<
name|T
extends|extends
name|RemoteLocationContext
parameter_list|,
name|R
parameter_list|>
name|boolean
name|invokeAll
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|locations
parameter_list|,
specifier|final
name|RemoteMethod
name|method
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|anyResult
init|=
literal|false
decl_stmt|;
name|Map
argument_list|<
name|T
argument_list|,
name|Boolean
argument_list|>
name|results
init|=
name|invokeConcurrent
argument_list|(
name|locations
argument_list|,
name|method
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|Boolean
name|value
range|:
name|results
operator|.
name|values
argument_list|()
control|)
block|{
name|boolean
name|result
init|=
name|value
operator|.
name|booleanValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|anyResult
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|anyResult
return|;
block|}
comment|/**    * Invoke multiple concurrent proxy calls to different clients. Returns an    * array of results.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param<T> The type of the remote location.    * @param locations List of remote locations to call concurrently.    * @param method The remote method and parameters to invoke.    * @throws IOException If all the calls throw an exception.    */
DECL|method|invokeConcurrent ( final Collection<T> locations, final RemoteMethod method)
specifier|public
parameter_list|<
name|T
extends|extends
name|RemoteLocationContext
parameter_list|,
name|R
parameter_list|>
name|void
name|invokeConcurrent
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|locations
parameter_list|,
specifier|final
name|RemoteMethod
name|method
parameter_list|)
throws|throws
name|IOException
block|{
name|invokeConcurrent
argument_list|(
name|locations
argument_list|,
name|method
argument_list|,
name|void
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Invoke multiple concurrent proxy calls to different clients. Returns an    * array of results.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param<T> The type of the remote location.    * @param locations List of remote locations to call concurrently.    * @param method The remote method and parameters to invoke.    * @return Result of invoking the method per subcluster: nsId -> result.    * @throws IOException If all the calls throw an exception.    */
DECL|method|invokeConcurrent ( final Collection<T> locations, final RemoteMethod method, Class<R> clazz)
specifier|public
parameter_list|<
name|T
extends|extends
name|RemoteLocationContext
parameter_list|,
name|R
parameter_list|>
name|Map
argument_list|<
name|T
argument_list|,
name|R
argument_list|>
name|invokeConcurrent
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|locations
parameter_list|,
specifier|final
name|RemoteMethod
name|method
parameter_list|,
name|Class
argument_list|<
name|R
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|invokeConcurrent
argument_list|(
name|locations
argument_list|,
name|method
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|clazz
argument_list|)
return|;
block|}
comment|/**    * Invoke multiple concurrent proxy calls to different clients. Returns an    * array of results.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param<T> The type of the remote location.    * @param locations List of remote locations to call concurrently.    * @param method The remote method and parameters to invoke.    * @param requireResponse If true an exception will be thrown if all calls do    *          not complete. If false exceptions are ignored and all data results    *          successfully received are returned.    * @param standby If the requests should go to the standby namenodes too.    * @throws IOException If all the calls throw an exception.    */
DECL|method|invokeConcurrent ( final Collection<T> locations, final RemoteMethod method, boolean requireResponse, boolean standby)
specifier|public
parameter_list|<
name|T
extends|extends
name|RemoteLocationContext
parameter_list|,
name|R
parameter_list|>
name|void
name|invokeConcurrent
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|locations
parameter_list|,
specifier|final
name|RemoteMethod
name|method
parameter_list|,
name|boolean
name|requireResponse
parameter_list|,
name|boolean
name|standby
parameter_list|)
throws|throws
name|IOException
block|{
name|invokeConcurrent
argument_list|(
name|locations
argument_list|,
name|method
argument_list|,
name|requireResponse
argument_list|,
name|standby
argument_list|,
name|void
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Invokes multiple concurrent proxy calls to different clients. Returns an    * array of results.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param<T> The type of the remote location.    * @param<R> The type of the remote method return.    * @param locations List of remote locations to call concurrently.    * @param method The remote method and parameters to invoke.    * @param requireResponse If true an exception will be thrown if all calls do    *          not complete. If false exceptions are ignored and all data results    *          successfully received are returned.    * @param standby If the requests should go to the standby namenodes too.    * @param clazz Type of the remote return type.    * @return Result of invoking the method per subcluster: nsId -> result.    * @throws IOException If requiredResponse=true and any of the calls throw an    *           exception.    */
DECL|method|invokeConcurrent ( final Collection<T> locations, final RemoteMethod method, boolean requireResponse, boolean standby, Class<R> clazz)
specifier|public
parameter_list|<
name|T
extends|extends
name|RemoteLocationContext
parameter_list|,
name|R
parameter_list|>
name|Map
argument_list|<
name|T
argument_list|,
name|R
argument_list|>
name|invokeConcurrent
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|locations
parameter_list|,
specifier|final
name|RemoteMethod
name|method
parameter_list|,
name|boolean
name|requireResponse
parameter_list|,
name|boolean
name|standby
parameter_list|,
name|Class
argument_list|<
name|R
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|invokeConcurrent
argument_list|(
name|locations
argument_list|,
name|method
argument_list|,
name|requireResponse
argument_list|,
name|standby
argument_list|,
operator|-
literal|1
argument_list|,
name|clazz
argument_list|)
return|;
block|}
comment|/**    * Invokes multiple concurrent proxy calls to different clients. Returns an    * array of results.    *    * Re-throws exceptions generated by the remote RPC call as either    * RemoteException or IOException.    *    * @param<T> The type of the remote location.    * @param<R> The type of the remote method return.    * @param locations List of remote locations to call concurrently.    * @param method The remote method and parameters to invoke.    * @param requireResponse If true an exception will be thrown if all calls do    *          not complete. If false exceptions are ignored and all data results    *          successfully received are returned.    * @param standby If the requests should go to the standby namenodes too.    * @param timeOutMs Timeout for each individual call.    * @param clazz Type of the remote return type.    * @return Result of invoking the method per subcluster: nsId -> result.    * @throws IOException If requiredResponse=true and any of the calls throw an    *           exception.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|invokeConcurrent ( final Collection<T> locations, final RemoteMethod method, boolean requireResponse, boolean standby, long timeOutMs, Class<R> clazz)
specifier|public
parameter_list|<
name|T
extends|extends
name|RemoteLocationContext
parameter_list|,
name|R
parameter_list|>
name|Map
argument_list|<
name|T
argument_list|,
name|R
argument_list|>
name|invokeConcurrent
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|T
argument_list|>
name|locations
parameter_list|,
specifier|final
name|RemoteMethod
name|method
parameter_list|,
name|boolean
name|requireResponse
parameter_list|,
name|boolean
name|standby
parameter_list|,
name|long
name|timeOutMs
parameter_list|,
name|Class
argument_list|<
name|R
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|UserGroupInformation
name|ugi
init|=
name|RouterRpcServer
operator|.
name|getRemoteUser
argument_list|()
decl_stmt|;
specifier|final
name|Method
name|m
init|=
name|method
operator|.
name|getMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|locations
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// Shortcut, just one call
name|T
name|location
init|=
name|locations
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|ns
init|=
name|location
operator|.
name|getNameserviceId
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|namenodes
init|=
name|getNamenodesForNameservice
argument_list|(
name|ns
argument_list|)
decl_stmt|;
name|Object
index|[]
name|paramList
init|=
name|method
operator|.
name|getParams
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|Object
name|result
init|=
name|invokeMethod
argument_list|(
name|ugi
argument_list|,
name|namenodes
argument_list|,
name|m
argument_list|,
name|paramList
argument_list|)
decl_stmt|;
return|return
name|Collections
operator|.
name|singletonMap
argument_list|(
name|location
argument_list|,
name|clazz
operator|.
name|cast
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
name|List
argument_list|<
name|T
argument_list|>
name|orderedLocations
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Callable
argument_list|<
name|Object
argument_list|>
argument_list|>
name|callables
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|T
name|location
range|:
name|locations
control|)
block|{
name|String
name|nsId
init|=
name|location
operator|.
name|getNameserviceId
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|namenodes
init|=
name|getNamenodesForNameservice
argument_list|(
name|nsId
argument_list|)
decl_stmt|;
specifier|final
name|Object
index|[]
name|paramList
init|=
name|method
operator|.
name|getParams
argument_list|(
name|location
argument_list|)
decl_stmt|;
if|if
condition|(
name|standby
condition|)
block|{
comment|// Call the objectGetter to all NNs (including standby)
for|for
control|(
specifier|final
name|FederationNamenodeContext
name|nn
range|:
name|namenodes
control|)
block|{
name|String
name|nnId
init|=
name|nn
operator|.
name|getNamenodeId
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FederationNamenodeContext
argument_list|>
name|nnList
init|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|nn
argument_list|)
decl_stmt|;
name|T
name|nnLocation
init|=
name|location
decl_stmt|;
if|if
condition|(
name|location
operator|instanceof
name|RemoteLocation
condition|)
block|{
name|nnLocation
operator|=
operator|(
name|T
operator|)
operator|new
name|RemoteLocation
argument_list|(
name|nsId
argument_list|,
name|nnId
argument_list|,
name|location
operator|.
name|getDest
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|orderedLocations
operator|.
name|add
argument_list|(
name|nnLocation
argument_list|)
expr_stmt|;
name|callables
operator|.
name|add
argument_list|(
operator|new
name|Callable
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|invokeMethod
argument_list|(
name|ugi
argument_list|,
name|nnList
argument_list|,
name|m
argument_list|,
name|paramList
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Call the objectGetter in order of nameservices in the NS list
name|orderedLocations
operator|.
name|add
argument_list|(
name|location
argument_list|)
expr_stmt|;
name|callables
operator|.
name|add
argument_list|(
operator|new
name|Callable
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|call
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|invokeMethod
argument_list|(
name|ugi
argument_list|,
name|namenodes
argument_list|,
name|m
argument_list|,
name|paramList
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rpcMonitor
operator|!=
literal|null
condition|)
block|{
name|rpcMonitor
operator|.
name|proxyOp
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|List
argument_list|<
name|Future
argument_list|<
name|Object
argument_list|>
argument_list|>
name|futures
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|timeOutMs
operator|>
literal|0
condition|)
block|{
name|futures
operator|=
name|executorService
operator|.
name|invokeAll
argument_list|(
name|callables
argument_list|,
name|timeOutMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|futures
operator|=
name|executorService
operator|.
name|invokeAll
argument_list|(
name|callables
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|T
argument_list|,
name|R
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|T
argument_list|,
name|IOException
argument_list|>
name|exceptions
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|futures
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|T
name|location
init|=
name|orderedLocations
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|Future
argument_list|<
name|Object
argument_list|>
name|future
init|=
name|futures
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Object
name|result
init|=
name|future
operator|.
name|get
argument_list|()
decl_stmt|;
name|results
operator|.
name|put
argument_list|(
name|location
argument_list|,
name|clazz
operator|.
name|cast
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|ce
parameter_list|)
block|{
name|T
name|loc
init|=
name|orderedLocations
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|msg
init|=
literal|"Invocation to \""
operator|+
name|loc
operator|+
literal|"\" for \""
operator|+
name|method
operator|+
literal|"\" timed out"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|IOException
name|ioe
init|=
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
decl_stmt|;
name|exceptions
operator|.
name|put
argument_list|(
name|location
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|ex
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|ex
operator|.
name|getCause
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Canot execute {} in {}: {}"
argument_list|,
name|m
operator|.
name|getName
argument_list|()
argument_list|,
name|location
argument_list|,
name|cause
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// Convert into IOException if needed
name|IOException
name|ioe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|IOException
condition|)
block|{
name|ioe
operator|=
operator|(
name|IOException
operator|)
name|cause
expr_stmt|;
block|}
else|else
block|{
name|ioe
operator|=
operator|new
name|IOException
argument_list|(
literal|"Unhandled exception while proxying API "
operator|+
name|m
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|cause
operator|.
name|getMessage
argument_list|()
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
comment|// Response from all servers required, use this error.
if|if
condition|(
name|requireResponse
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
comment|// Store the exceptions
name|exceptions
operator|.
name|put
argument_list|(
name|location
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Throw the exception for the first location if there are no results
if|if
condition|(
name|results
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|T
name|location
init|=
name|orderedLocations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|IOException
name|ioe
init|=
name|exceptions
operator|.
name|get
argument_list|(
name|location
argument_list|)
decl_stmt|;
if|if
condition|(
name|ioe
operator|!=
literal|null
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
block|}
return|return
name|results
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected error while invoking API: {}"
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected error while invoking API "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get a prioritized list of NNs that share the same nameservice ID (in the    * same namespace). NNs that are reported as ACTIVE will be first in the list.    *    * @param nsId The nameservice ID for the namespace.    * @return A prioritized list of NNs to use for communication.    * @throws IOException If a NN cannot be located for the nameservice ID.    */
DECL|method|getNamenodesForNameservice ( final String nsId)
specifier|private
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|getNamenodesForNameservice
parameter_list|(
specifier|final
name|String
name|nsId
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|namenodes
init|=
name|namenodeResolver
operator|.
name|getNamenodesForNameserviceId
argument_list|(
name|nsId
argument_list|)
decl_stmt|;
if|if
condition|(
name|namenodes
operator|==
literal|null
operator|||
name|namenodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot locate a registered namenode for "
operator|+
name|nsId
operator|+
literal|" from "
operator|+
name|this
operator|.
name|routerId
argument_list|)
throw|;
block|}
return|return
name|namenodes
return|;
block|}
comment|/**    * Get a prioritized list of NNs that share the same block pool ID (in the    * same namespace). NNs that are reported as ACTIVE will be first in the list.    *    * @param bpId The blockpool ID for the namespace.    * @return A prioritized list of NNs to use for communication.    * @throws IOException If a NN cannot be located for the block pool ID.    */
DECL|method|getNamenodesForBlockPoolId ( final String bpId)
specifier|private
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|getNamenodesForBlockPoolId
parameter_list|(
specifier|final
name|String
name|bpId
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|namenodes
init|=
name|namenodeResolver
operator|.
name|getNamenodesForBlockPoolId
argument_list|(
name|bpId
argument_list|)
decl_stmt|;
if|if
condition|(
name|namenodes
operator|==
literal|null
operator|||
name|namenodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot locate a registered namenode for "
operator|+
name|bpId
operator|+
literal|" from "
operator|+
name|this
operator|.
name|routerId
argument_list|)
throw|;
block|}
return|return
name|namenodes
return|;
block|}
comment|/**    * Get the nameservice identifier for a block pool.    *    * @param bpId Identifier of the block pool.    * @return Nameservice identifier.    * @throws IOException If a NN cannot be located for the block pool ID.    */
DECL|method|getNameserviceForBlockPoolId (final String bpId)
specifier|private
name|String
name|getNameserviceForBlockPoolId
parameter_list|(
specifier|final
name|String
name|bpId
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|?
extends|extends
name|FederationNamenodeContext
argument_list|>
name|namenodes
init|=
name|getNamenodesForBlockPoolId
argument_list|(
name|bpId
argument_list|)
decl_stmt|;
name|FederationNamenodeContext
name|namenode
init|=
name|namenodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|namenode
operator|.
name|getNameserviceId
argument_list|()
return|;
block|}
block|}
end_class

end_unit

