begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.federation.resolver.order
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|order
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|net
operator|.
name|HostAndPort
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|PathLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
operator|.
name|RBFConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
operator|.
name|Router
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
operator|.
name|RouterRpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|MembershipStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|GetNamenodeRegistrationsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|protocol
operator|.
name|GetNamenodeRegistrationsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|MembershipState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The local subcluster (where the writer is) should be tried first. The writer  * is defined from the RPC query received in the RPC server.  */
end_comment

begin_class
DECL|class|LocalResolver
specifier|public
class|class
name|LocalResolver
implements|implements
name|OrderedResolver
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LocalResolver
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Configuration key to set the minimum time to update the local cache.*/
DECL|field|MIN_UPDATE_PERIOD_KEY
specifier|public
specifier|static
specifier|final
name|String
name|MIN_UPDATE_PERIOD_KEY
init|=
name|RBFConfigKeys
operator|.
name|FEDERATION_ROUTER_PREFIX
operator|+
literal|"local-resolver.update-period"
decl_stmt|;
comment|/** 10 seconds by default. */
DECL|field|MIN_UPDATE_PERIOD_DEFAULT
specifier|private
specifier|static
specifier|final
name|long
name|MIN_UPDATE_PERIOD_DEFAULT
init|=
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
literal|10
argument_list|)
decl_stmt|;
comment|/** Router service. */
DECL|field|router
specifier|private
specifier|final
name|Router
name|router
decl_stmt|;
comment|/** Minimum update time. */
DECL|field|minUpdateTime
specifier|private
specifier|final
name|long
name|minUpdateTime
decl_stmt|;
comment|/** Node IP -> Subcluster. */
DECL|field|nodeSubcluster
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|nodeSubcluster
init|=
literal|null
decl_stmt|;
comment|/** Last time the subcluster map was updated. */
DECL|field|lastUpdated
specifier|private
name|long
name|lastUpdated
decl_stmt|;
DECL|method|LocalResolver (final Configuration conf, final Router routerService)
specifier|public
name|LocalResolver
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|Router
name|routerService
parameter_list|)
block|{
name|this
operator|.
name|minUpdateTime
operator|=
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|MIN_UPDATE_PERIOD_KEY
argument_list|,
name|MIN_UPDATE_PERIOD_DEFAULT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|router
operator|=
name|routerService
expr_stmt|;
block|}
comment|/**    * Get the local name space. This relies on the RPC Server to get the address    * from the client.    *    * TODO we only support DN and NN locations, we need to add others like    * Resource Managers.    *    * @param path Path ignored by this policy.    * @param loc Federated location with multiple destinations.    * @return Local name space. Null if we don't know about this machine.    */
annotation|@
name|Override
DECL|method|getFirstNamespace (final String path, final PathLocation loc)
specifier|public
name|String
name|getFirstNamespace
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|PathLocation
name|loc
parameter_list|)
block|{
name|String
name|localSubcluster
init|=
literal|null
decl_stmt|;
name|String
name|clientAddr
init|=
name|getClientAddr
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|nodeToSubcluster
init|=
name|getSubclusterMappings
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeToSubcluster
operator|!=
literal|null
condition|)
block|{
name|localSubcluster
operator|=
name|nodeToSubcluster
operator|.
name|get
argument_list|(
name|clientAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|localSubcluster
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Local namespace for {} is {}"
argument_list|,
name|clientAddr
argument_list|,
name|localSubcluster
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot get local namespace for {}"
argument_list|,
name|clientAddr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot get node mapping when resolving {} at {} from {}"
argument_list|,
name|path
argument_list|,
name|loc
argument_list|,
name|clientAddr
argument_list|)
expr_stmt|;
block|}
return|return
name|localSubcluster
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getClientAddr ()
name|String
name|getClientAddr
parameter_list|()
block|{
return|return
name|Server
operator|.
name|getRemoteAddress
argument_list|()
return|;
block|}
comment|/**    * Get the mapping from nodes to subcluster. It gets this mapping from the    * subclusters through expensive calls (e.g., RPC) and uses caching to avoid    * too many calls. The cache might be updated asynchronously to reduce    * latency.    *    * @return Node IP -> Subcluster.    */
annotation|@
name|VisibleForTesting
DECL|method|getSubclusterMappings ()
specifier|synchronized
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getSubclusterMappings
parameter_list|()
block|{
if|if
condition|(
name|nodeSubcluster
operator|==
literal|null
operator|||
operator|(
name|monotonicNow
argument_list|()
operator|-
name|lastUpdated
operator|)
operator|>
name|minUpdateTime
condition|)
block|{
comment|// Fetch the mapping asynchronously
name|Thread
name|updater
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dnSubcluster
init|=
name|getDatanodesSubcluster
argument_list|()
decl_stmt|;
if|if
condition|(
name|dnSubcluster
operator|!=
literal|null
condition|)
block|{
name|mapping
operator|.
name|putAll
argument_list|(
name|dnSubcluster
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|nnSubcluster
init|=
name|getNamenodesSubcluster
argument_list|()
decl_stmt|;
if|if
condition|(
name|nnSubcluster
operator|!=
literal|null
condition|)
block|{
name|mapping
operator|.
name|putAll
argument_list|(
name|nnSubcluster
argument_list|)
expr_stmt|;
block|}
name|nodeSubcluster
operator|=
name|mapping
expr_stmt|;
name|lastUpdated
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
decl_stmt|;
name|updater
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Wait until initialized
if|if
condition|(
name|nodeSubcluster
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wait to get the mapping for the first time"
argument_list|)
expr_stmt|;
name|updater
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot wait for the updater to finish"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|nodeSubcluster
return|;
block|}
comment|/**    * Get the Datanode mapping from the subclusters from the Namenodes. This    * needs to be done as a privileged action to use the user for the Router and    * not the one from the client in the RPC call.    *    * @return DN IP -> Subcluster.    */
DECL|method|getDatanodesSubcluster ()
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getDatanodesSubcluster
parameter_list|()
block|{
specifier|final
name|RouterRpcServer
name|rpcServer
init|=
name|getRpcServer
argument_list|()
decl_stmt|;
if|if
condition|(
name|rpcServer
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot access the Router RPC server"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|ret
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
comment|// We need to get the DNs as a privileged user
name|UserGroupInformation
name|loginUser
init|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|DatanodeStorageReport
index|[]
argument_list|>
name|dnMap
init|=
name|loginUser
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|DatanodeStorageReport
index|[]
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|DatanodeStorageReport
index|[]
argument_list|>
name|run
parameter_list|()
block|{
try|try
block|{
return|return
name|rpcServer
operator|.
name|getDatanodeStorageReportMap
argument_list|(
name|DatanodeReportType
operator|.
name|ALL
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot get the datanodes from the RPC server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|DatanodeStorageReport
index|[]
argument_list|>
name|entry
range|:
name|dnMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|nsId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|DatanodeStorageReport
index|[]
name|dns
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeStorageReport
name|dn
range|:
name|dns
control|)
block|{
name|DatanodeInfo
name|dnInfo
init|=
name|dn
operator|.
name|getDatanodeInfo
argument_list|()
decl_stmt|;
name|String
name|ipAddr
init|=
name|dnInfo
operator|.
name|getIpAddr
argument_list|()
decl_stmt|;
name|ret
operator|.
name|put
argument_list|(
name|ipAddr
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot get Datanodes from the Namenodes: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Get the Namenode mapping from the subclusters from the Membership store. As    * the Routers are usually co-located with Namenodes, we also check for the    * local address for this Router here.    *    * @return NN IP -> Subcluster.    */
DECL|method|getNamenodesSubcluster ()
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getNamenodesSubcluster
parameter_list|()
block|{
specifier|final
name|MembershipStore
name|membershipStore
init|=
name|getMembershipStore
argument_list|()
decl_stmt|;
if|if
condition|(
name|membershipStore
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot access the Membership store"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Manage requests from this hostname (127.0.0.1)
name|String
name|localIp
init|=
literal|"127.0.0.1"
decl_stmt|;
name|String
name|localHostname
init|=
name|localIp
decl_stmt|;
try|try
block|{
name|localHostname
operator|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getHostName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot get local host name"
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|ret
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Get the values from the store
name|GetNamenodeRegistrationsRequest
name|request
init|=
name|GetNamenodeRegistrationsRequest
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|GetNamenodeRegistrationsResponse
name|response
init|=
name|membershipStore
operator|.
name|getNamenodeRegistrations
argument_list|(
name|request
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MembershipState
argument_list|>
name|nns
init|=
name|response
operator|.
name|getNamenodeMemberships
argument_list|()
decl_stmt|;
for|for
control|(
name|MembershipState
name|nn
range|:
name|nns
control|)
block|{
try|try
block|{
name|String
name|nsId
init|=
name|nn
operator|.
name|getNameserviceId
argument_list|()
decl_stmt|;
name|String
name|rpcAddress
init|=
name|nn
operator|.
name|getRpcAddress
argument_list|()
decl_stmt|;
name|String
name|hostname
init|=
name|HostAndPort
operator|.
name|fromString
argument_list|(
name|rpcAddress
argument_list|)
operator|.
name|getHostText
argument_list|()
decl_stmt|;
name|ret
operator|.
name|put
argument_list|(
name|hostname
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|.
name|equals
argument_list|(
name|localHostname
argument_list|)
condition|)
block|{
name|ret
operator|.
name|put
argument_list|(
name|localIp
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
block|}
name|InetAddress
name|addr
init|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|hostname
argument_list|)
decl_stmt|;
name|String
name|ipAddr
init|=
name|addr
operator|.
name|getHostAddress
argument_list|()
decl_stmt|;
name|ret
operator|.
name|put
argument_list|(
name|ipAddr
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot get address for {}: {}"
argument_list|,
name|nn
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot get Namenodes from the State Store: {}"
argument_list|,
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Get the Router RPC server.    *    * @return Router RPC server. Null if not possible.    */
DECL|method|getRpcServer ()
specifier|private
name|RouterRpcServer
name|getRpcServer
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|router
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|router
operator|.
name|getRpcServer
argument_list|()
return|;
block|}
comment|/**    * Get the Membership store.    *    * @return Membership store.    */
DECL|method|getMembershipStore ()
specifier|private
name|MembershipStore
name|getMembershipStore
parameter_list|()
block|{
name|StateStoreService
name|stateStore
init|=
name|router
operator|.
name|getStateStore
argument_list|()
decl_stmt|;
if|if
condition|(
name|stateStore
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|stateStore
operator|.
name|getRegisteredRecordStore
argument_list|(
name|MembershipStore
operator|.
name|class
argument_list|)
return|;
block|}
block|}
end_class

end_unit

