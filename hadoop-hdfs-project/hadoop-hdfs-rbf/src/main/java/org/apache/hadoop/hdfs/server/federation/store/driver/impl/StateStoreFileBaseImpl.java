begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.federation.store.driver.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|driver
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreUtils
operator|.
name|filterMultiple
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|metrics
operator|.
name|StateStoreMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreUnavailableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|driver
operator|.
name|StateStoreDriver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|BaseRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|QueryResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * {@link StateStoreDriver} implementation based on files. In this approach, we  * use temporary files for the writes and renaming "atomically" to the final  * value. Instead of writing to the final location, it will go to a temporary  * one and then rename to the final destination.  */
end_comment

begin_class
DECL|class|StateStoreFileBaseImpl
specifier|public
specifier|abstract
class|class
name|StateStoreFileBaseImpl
extends|extends
name|StateStoreSerializableImpl
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StateStoreFileBaseImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** File extension for temporary files. */
DECL|field|TMP_MARK
specifier|private
specifier|static
specifier|final
name|String
name|TMP_MARK
init|=
literal|".tmp"
decl_stmt|;
comment|/** We remove temporary files older than 10 seconds. */
DECL|field|OLD_TMP_RECORD_MS
specifier|private
specifier|static
specifier|final
name|long
name|OLD_TMP_RECORD_MS
init|=
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
literal|10
argument_list|)
decl_stmt|;
comment|/** File pattern for temporary records: file.XYZ.tmp. */
DECL|field|OLD_TMP_RECORD_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|OLD_TMP_RECORD_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|".+\\.(\\d+)\\.tmp"
argument_list|)
decl_stmt|;
comment|/** If it is initialized. */
DECL|field|initialized
specifier|private
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
comment|/**    * Get the reader of a record for the file system.    *    * @param path Path of the record to read.    * @return Reader for the record.    */
DECL|method|getReader ( String path)
specifier|protected
specifier|abstract
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|BufferedReader
name|getReader
parameter_list|(
name|String
name|path
parameter_list|)
function_decl|;
comment|/**    * Get the writer of a record for the file system.    *    * @param path Path of the record to write.    * @return Writer for the record.    */
DECL|method|getWriter ( String path)
specifier|protected
specifier|abstract
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|BufferedWriter
name|getWriter
parameter_list|(
name|String
name|path
parameter_list|)
function_decl|;
comment|/**    * Check if a path exists.    *    * @param path Path to check.    * @return If the path exists.    */
DECL|method|exists (String path)
specifier|protected
specifier|abstract
name|boolean
name|exists
parameter_list|(
name|String
name|path
parameter_list|)
function_decl|;
comment|/**    * Make a directory.    *    * @param path Path of the directory to create.    * @return If the directory was created.    */
DECL|method|mkdir (String path)
specifier|protected
specifier|abstract
name|boolean
name|mkdir
parameter_list|(
name|String
name|path
parameter_list|)
function_decl|;
comment|/**    * Rename a file. This should be atomic.    *    * @param src Source name.    * @param dst Destination name.    * @return If the rename was successful.    */
DECL|method|rename (String src, String dst)
specifier|protected
specifier|abstract
name|boolean
name|rename
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
function_decl|;
comment|/**    * Remove a file.    *    * @param path Path for the file to remove    * @return If the file was removed.    */
DECL|method|remove (String path)
specifier|protected
specifier|abstract
name|boolean
name|remove
parameter_list|(
name|String
name|path
parameter_list|)
function_decl|;
comment|/**    * Get the children for a path.    *    * @param path Path to check.    * @return List of children.    */
DECL|method|getChildren (String path)
specifier|protected
specifier|abstract
name|List
argument_list|<
name|String
argument_list|>
name|getChildren
parameter_list|(
name|String
name|path
parameter_list|)
function_decl|;
comment|/**    * Get root directory.    *    * @return Root directory.    */
DECL|method|getRootDir ()
specifier|protected
specifier|abstract
name|String
name|getRootDir
parameter_list|()
function_decl|;
comment|/**    * Set the driver as initialized.    *    * @param ini If the driver is initialized.    */
DECL|method|setInitialized (boolean ini)
specifier|public
name|void
name|setInitialized
parameter_list|(
name|boolean
name|ini
parameter_list|)
block|{
name|this
operator|.
name|initialized
operator|=
name|ini
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|initDriver ()
specifier|public
name|boolean
name|initDriver
parameter_list|()
block|{
name|String
name|rootDir
init|=
name|getRootDir
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|rootDir
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid root directory, unable to initialize driver."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Check root path
if|if
condition|(
operator|!
name|exists
argument_list|(
name|rootDir
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mkdir
argument_list|(
name|rootDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot create State Store root directory {}"
argument_list|,
name|rootDir
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot initialize filesystem using root directory {}"
argument_list|,
name|rootDir
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|setInitialized
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|initRecordStorage ( String className, Class<T> recordClass)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|boolean
name|initRecordStorage
parameter_list|(
name|String
name|className
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|recordClass
parameter_list|)
block|{
name|String
name|dataDirPath
init|=
name|getRootDir
argument_list|()
operator|+
literal|"/"
operator|+
name|className
decl_stmt|;
try|try
block|{
comment|// Create data directories for files
if|if
condition|(
operator|!
name|exists
argument_list|(
name|dataDirPath
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} data directory doesn't exist, creating it"
argument_list|,
name|dataDirPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mkdir
argument_list|(
name|dataDirPath
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot create data directory {}"
argument_list|,
name|dataDirPath
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot create data directory {}"
argument_list|,
name|dataDirPath
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|get (Class<T> clazz)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|QueryResult
argument_list|<
name|T
argument_list|>
name|get
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyDriverReady
argument_list|()
expr_stmt|;
name|long
name|start
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
name|StateStoreMetrics
name|metrics
init|=
name|getMetrics
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|path
init|=
name|getPathForClass
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|getChildren
argument_list|(
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|String
name|pathRecord
init|=
name|path
operator|+
literal|"/"
operator|+
name|child
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|endsWith
argument_list|(
name|TMP_MARK
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"There is a temporary file {} in {}"
argument_list|,
name|child
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOldTempRecord
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing {} as it's an old temporary record"
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|pathRecord
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|T
name|record
init|=
name|getRecord
argument_list|(
name|pathRecord
argument_list|,
name|clazz
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|record
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addFailure
argument_list|(
name|monotonicNow
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
name|String
name|msg
init|=
literal|"Cannot fetch records for "
operator|+
name|clazz
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addRead
argument_list|(
name|monotonicNow
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|QueryResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|ret
argument_list|,
name|getTime
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Check if a record is temporary and old.    *    * @param pathRecord Path for the record to check.    * @return If the record is temporary and old.    */
annotation|@
name|VisibleForTesting
DECL|method|isOldTempRecord (final String pathRecord)
specifier|public
specifier|static
name|boolean
name|isOldTempRecord
parameter_list|(
specifier|final
name|String
name|pathRecord
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pathRecord
operator|.
name|endsWith
argument_list|(
name|TMP_MARK
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Extract temporary record creation time
name|Matcher
name|m
init|=
name|OLD_TMP_RECORD_PATTERN
operator|.
name|matcher
argument_list|(
name|pathRecord
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|long
name|time
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|now
argument_list|()
operator|-
name|time
operator|>
name|OLD_TMP_RECORD_MS
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Read a record from a file.    *    * @param path Path to the file containing the record.    * @param clazz Class of the record.    * @return Record read from the file.    * @throws IOException If the file cannot be read.    */
DECL|method|getRecord ( final String path, final Class<T> clazz)
specifier|private
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|T
name|getRecord
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|IOException
block|{
name|BufferedReader
name|reader
init|=
name|getReader
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|line
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
operator|&&
name|line
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|T
name|record
init|=
name|newRecord
argument_list|(
name|line
argument_list|,
name|clazz
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|record
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot parse line {} in file {}"
argument_list|,
name|line
argument_list|,
name|path
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot read "
operator|+
name|path
operator|+
literal|" for record "
operator|+
name|clazz
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Get the path for a record class.    * @param clazz Class of the record.    * @return Path for this record class.    */
DECL|method|getPathForClass (final Class<T> clazz)
specifier|private
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|String
name|getPathForClass
parameter_list|(
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
name|String
name|className
init|=
name|StateStoreUtils
operator|.
name|getRecordName
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getRootDir
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
literal|'/'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|className
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isDriverReady ()
specifier|public
name|boolean
name|isDriverReady
parameter_list|()
block|{
return|return
name|this
operator|.
name|initialized
return|;
block|}
annotation|@
name|Override
DECL|method|putAll ( List<T> records, boolean allowUpdate, boolean errorIfExists)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|boolean
name|putAll
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|records
parameter_list|,
name|boolean
name|allowUpdate
parameter_list|,
name|boolean
name|errorIfExists
parameter_list|)
throws|throws
name|StateStoreUnavailableException
block|{
name|verifyDriverReady
argument_list|()
expr_stmt|;
if|if
condition|(
name|records
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|long
name|start
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
name|StateStoreMetrics
name|metrics
init|=
name|getMetrics
argument_list|()
decl_stmt|;
comment|// Check if any record exists
name|Map
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|toWrite
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|record
range|:
name|records
control|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|BaseRecord
argument_list|>
name|recordClass
init|=
name|record
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|getPathForClass
argument_list|(
name|recordClass
argument_list|)
decl_stmt|;
name|String
name|primaryKey
init|=
name|getPrimaryKey
argument_list|(
name|record
argument_list|)
decl_stmt|;
name|String
name|recordPath
init|=
name|path
operator|+
literal|"/"
operator|+
name|primaryKey
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|recordPath
argument_list|)
condition|)
block|{
if|if
condition|(
name|allowUpdate
condition|)
block|{
comment|// Update the mod time stamp. Many backends will use their
comment|// own timestamp for the mod time.
name|record
operator|.
name|setDateModified
argument_list|(
name|this
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|toWrite
operator|.
name|put
argument_list|(
name|recordPath
argument_list|,
name|record
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errorIfExists
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Attempt to insert record {} that already exists"
argument_list|,
name|recordPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addFailure
argument_list|(
name|monotonicNow
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not updating {}"
argument_list|,
name|record
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toWrite
operator|.
name|put
argument_list|(
name|recordPath
argument_list|,
name|record
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Write the records
name|boolean
name|success
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|T
argument_list|>
name|entry
range|:
name|toWrite
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|recordPath
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|recordPathTemp
init|=
name|recordPath
operator|+
literal|"."
operator|+
name|now
argument_list|()
operator|+
name|TMP_MARK
decl_stmt|;
name|BufferedWriter
name|writer
init|=
name|getWriter
argument_list|(
name|recordPathTemp
argument_list|)
decl_stmt|;
try|try
block|{
name|T
name|record
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|line
init|=
name|serializeString
argument_list|(
name|record
argument_list|)
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot write {}"
argument_list|,
name|recordPathTemp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot close the writer for {}"
argument_list|,
name|recordPathTemp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Commit
if|if
condition|(
operator|!
name|rename
argument_list|(
name|recordPathTemp
argument_list|,
name|recordPath
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed committing record into {}"
argument_list|,
name|recordPath
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|long
name|end
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|success
condition|)
block|{
name|metrics
operator|.
name|addWrite
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metrics
operator|.
name|addFailure
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Class<T> clazz, Query<T> query)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|int
name|remove
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|Query
argument_list|<
name|T
argument_list|>
name|query
parameter_list|)
throws|throws
name|StateStoreUnavailableException
block|{
name|verifyDriverReady
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|long
name|start
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|StateStoreMetrics
name|metrics
init|=
name|getMetrics
argument_list|()
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
comment|// Get the current records
try|try
block|{
specifier|final
name|QueryResult
argument_list|<
name|T
argument_list|>
name|result
init|=
name|get
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|existingRecords
init|=
name|result
operator|.
name|getRecords
argument_list|()
decl_stmt|;
comment|// Write all of the existing records except those to be removed
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|recordsToRemove
init|=
name|filterMultiple
argument_list|(
name|query
argument_list|,
name|existingRecords
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
for|for
control|(
name|T
name|recordToRemove
range|:
name|recordsToRemove
control|)
block|{
name|String
name|path
init|=
name|getPathForClass
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
name|String
name|primaryKey
init|=
name|getPrimaryKey
argument_list|(
name|recordToRemove
argument_list|)
decl_stmt|;
name|String
name|recordToRemovePath
init|=
name|path
operator|+
literal|"/"
operator|+
name|primaryKey
decl_stmt|;
if|if
condition|(
name|remove
argument_list|(
name|recordToRemovePath
argument_list|)
condition|)
block|{
name|removed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot remove record {}"
argument_list|,
name|recordToRemovePath
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot remove records {} query {}"
argument_list|,
name|clazz
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addFailure
argument_list|(
name|monotonicNow
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot remove records {} query {}"
argument_list|,
name|clazz
argument_list|,
name|query
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addFailure
argument_list|(
name|monotonicNow
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|removed
operator|>
literal|0
operator|&&
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addRemove
argument_list|(
name|monotonicNow
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Class<T> clazz)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|boolean
name|removeAll
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|StateStoreUnavailableException
block|{
name|verifyDriverReady
argument_list|()
expr_stmt|;
name|long
name|start
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|StateStoreMetrics
name|metrics
init|=
name|getMetrics
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
name|String
name|path
init|=
name|getPathForClass
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|getChildren
argument_list|(
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|String
name|pathRecord
init|=
name|path
operator|+
literal|"/"
operator|+
name|child
decl_stmt|;
if|if
condition|(
operator|!
name|remove
argument_list|(
name|pathRecord
argument_list|)
condition|)
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|long
name|time
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|metrics
operator|.
name|addRemove
argument_list|(
name|time
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metrics
operator|.
name|addFailure
argument_list|(
name|time
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
block|}
end_class

end_unit

