begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.federation.router
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
operator|.
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_KERBEROS_PRINCIPAL_HOSTNAME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
operator|.
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_KERBEROS_PRINCIPAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
operator|.
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_KEYTAB_FILE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
operator|.
name|FederationUtil
operator|.
name|newActiveNamenodeResolver
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
operator|.
name|FederationUtil
operator|.
name|newFileSubclusterResolver
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|metrics
operator|.
name|FederationMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|metrics
operator|.
name|NamenodeBeanMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|ActiveNamenodeResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|FileSubclusterResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|RouterStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|source
operator|.
name|JvmMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|CompositeService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|JvmPauseMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Router that provides a unified view of multiple federated HDFS clusters. It  * has two main roles: (1) federated interface and (2) NameNode heartbeat.  *<p>  * For the federated interface, the Router receives a client request, checks the  * State Store for the correct subcluster, and forwards the request to the  * active Namenode of that subcluster. The reply from the Namenode then flows in  * the opposite direction. The Routers are stateless and can be behind a load  * balancer. HDFS clients connect to the router using the same interfaces as are  * used to communicate with a namenode, namely the ClientProtocol RPC interface  * and the WebHdfs HTTP interface exposed by the router. {@link RouterRpcServer}  * {@link RouterHttpServer}  *<p>  * For NameNode heartbeat, the Router periodically checks the state of a  * NameNode (usually on the same server) and reports their high availability  * (HA) state and load/space status to the State Store. Note that this is an  * optional role as a Router can be independent of any subcluster.  * {@link StateStoreService} {@link NamenodeHeartbeatService}  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|Router
specifier|public
class|class
name|Router
extends|extends
name|CompositeService
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Router
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Configuration for the Router. */
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
comment|/** Router address/identifier. */
DECL|field|routerId
specifier|private
name|String
name|routerId
decl_stmt|;
comment|/** RPC interface to the client. */
DECL|field|rpcServer
specifier|private
name|RouterRpcServer
name|rpcServer
decl_stmt|;
DECL|field|rpcAddress
specifier|private
name|InetSocketAddress
name|rpcAddress
decl_stmt|;
comment|/** RPC interface for the admin. */
DECL|field|adminServer
specifier|private
name|RouterAdminServer
name|adminServer
decl_stmt|;
DECL|field|adminAddress
specifier|private
name|InetSocketAddress
name|adminAddress
decl_stmt|;
comment|/** HTTP interface and web application. */
DECL|field|httpServer
specifier|private
name|RouterHttpServer
name|httpServer
decl_stmt|;
comment|/** Interface with the State Store. */
DECL|field|stateStore
specifier|private
name|StateStoreService
name|stateStore
decl_stmt|;
comment|/** Interface to map global name space to HDFS subcluster name spaces. */
DECL|field|subclusterResolver
specifier|private
name|FileSubclusterResolver
name|subclusterResolver
decl_stmt|;
comment|/** Interface to identify the active NN for a nameservice or blockpool ID. */
DECL|field|namenodeResolver
specifier|private
name|ActiveNamenodeResolver
name|namenodeResolver
decl_stmt|;
comment|/** Updates the namenode status in the namenode resolver. */
DECL|field|namenodeHeartbeatServices
specifier|private
name|Collection
argument_list|<
name|NamenodeHeartbeatService
argument_list|>
name|namenodeHeartbeatServices
decl_stmt|;
comment|/** Router metrics. */
DECL|field|metrics
specifier|private
name|RouterMetricsService
name|metrics
decl_stmt|;
comment|/** JVM pauses (GC and others). */
DECL|field|pauseMonitor
specifier|private
name|JvmPauseMonitor
name|pauseMonitor
decl_stmt|;
comment|/** Quota usage update service. */
DECL|field|quotaUpdateService
specifier|private
name|RouterQuotaUpdateService
name|quotaUpdateService
decl_stmt|;
comment|/** Quota cache manager. */
DECL|field|quotaManager
specifier|private
name|RouterQuotaManager
name|quotaManager
decl_stmt|;
comment|/** Manages the current state of the router. */
DECL|field|routerStateManager
specifier|private
name|RouterStore
name|routerStateManager
decl_stmt|;
comment|/** Heartbeat our run status to the router state manager. */
DECL|field|routerHeartbeatService
specifier|private
name|RouterHeartbeatService
name|routerHeartbeatService
decl_stmt|;
comment|/** Enter/exit safemode. */
DECL|field|safemodeService
specifier|private
name|RouterSafemodeService
name|safemodeService
decl_stmt|;
comment|/** The start time of the namesystem. */
DECL|field|startTime
specifier|private
specifier|final
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
comment|/** State of the Router. */
DECL|field|state
specifier|private
name|RouterServiceState
name|state
init|=
name|RouterServiceState
operator|.
name|UNINITIALIZED
decl_stmt|;
comment|/////////////////////////////////////////////////////////
comment|// Constructor
comment|/////////////////////////////////////////////////////////
DECL|method|Router ()
specifier|public
name|Router
parameter_list|()
block|{
name|super
argument_list|(
name|Router
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/////////////////////////////////////////////////////////
comment|// Service management
comment|/////////////////////////////////////////////////////////
annotation|@
name|Override
DECL|method|serviceInit (Configuration configuration)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|conf
operator|=
name|configuration
expr_stmt|;
name|updateRouterState
argument_list|(
name|RouterServiceState
operator|.
name|INITIALIZING
argument_list|)
expr_stmt|;
comment|// Enable the security for the Router
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_ROUTER_KEYTAB_FILE_KEY
argument_list|,
name|DFS_ROUTER_KERBEROS_PRINCIPAL_KEY
argument_list|,
name|getHostName
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_STORE_ENABLE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_STORE_ENABLE_DEFAULT
argument_list|)
condition|)
block|{
comment|// Service that maintains the State Store connection
name|this
operator|.
name|stateStore
operator|=
operator|new
name|StateStoreService
argument_list|()
expr_stmt|;
name|addService
argument_list|(
name|this
operator|.
name|stateStore
argument_list|)
expr_stmt|;
block|}
comment|// Resolver to track active NNs
name|this
operator|.
name|namenodeResolver
operator|=
name|newActiveNamenodeResolver
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|stateStore
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|namenodeResolver
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find namenode resolver."
argument_list|)
throw|;
block|}
comment|// Lookup interface to map between the global and subcluster name spaces
name|this
operator|.
name|subclusterResolver
operator|=
name|newFileSubclusterResolver
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|subclusterResolver
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot find subcluster resolver"
argument_list|)
throw|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_RPC_ENABLE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_RPC_ENABLE_DEFAULT
argument_list|)
condition|)
block|{
comment|// Create RPC server
name|this
operator|.
name|rpcServer
operator|=
name|createRpcServer
argument_list|()
expr_stmt|;
name|addService
argument_list|(
name|this
operator|.
name|rpcServer
argument_list|)
expr_stmt|;
name|this
operator|.
name|setRpcServerAddress
argument_list|(
name|rpcServer
operator|.
name|getRpcAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_ADMIN_ENABLE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_ADMIN_ENABLE_DEFAULT
argument_list|)
condition|)
block|{
comment|// Create admin server
name|this
operator|.
name|adminServer
operator|=
name|createAdminServer
argument_list|()
expr_stmt|;
name|addService
argument_list|(
name|this
operator|.
name|adminServer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_HTTP_ENABLE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_HTTP_ENABLE_DEFAULT
argument_list|)
condition|)
block|{
comment|// Create HTTP server
name|this
operator|.
name|httpServer
operator|=
name|createHttpServer
argument_list|()
expr_stmt|;
name|addService
argument_list|(
name|this
operator|.
name|httpServer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_HEARTBEAT_ENABLE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_HEARTBEAT_ENABLE_DEFAULT
argument_list|)
condition|)
block|{
comment|// Create status updater for each monitored Namenode
name|this
operator|.
name|namenodeHeartbeatServices
operator|=
name|createNamenodeHeartbeatServices
argument_list|()
expr_stmt|;
for|for
control|(
name|NamenodeHeartbeatService
name|hearbeatService
range|:
name|this
operator|.
name|namenodeHeartbeatServices
control|)
block|{
name|addService
argument_list|(
name|hearbeatService
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|namenodeHeartbeatServices
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Heartbeat is enabled but there are no namenodes to monitor"
argument_list|)
expr_stmt|;
block|}
comment|// Periodically update the router state
name|this
operator|.
name|routerHeartbeatService
operator|=
operator|new
name|RouterHeartbeatService
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|this
operator|.
name|routerHeartbeatService
argument_list|)
expr_stmt|;
block|}
comment|// Router metrics system
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_METRICS_ENABLE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_METRICS_ENABLE_DEFAULT
argument_list|)
condition|)
block|{
name|DefaultMetricsSystem
operator|.
name|initialize
argument_list|(
literal|"Router"
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
operator|new
name|RouterMetricsService
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|this
operator|.
name|metrics
argument_list|)
expr_stmt|;
comment|// JVM pause monitor
name|this
operator|.
name|pauseMonitor
operator|=
operator|new
name|JvmPauseMonitor
argument_list|()
expr_stmt|;
name|this
operator|.
name|pauseMonitor
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Initial quota relevant service
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_QUOTA_ENABLE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_QUOTA_ENABLED_DEFAULT
argument_list|)
condition|)
block|{
name|this
operator|.
name|quotaManager
operator|=
operator|new
name|RouterQuotaManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|quotaUpdateService
operator|=
operator|new
name|RouterQuotaUpdateService
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|this
operator|.
name|quotaUpdateService
argument_list|)
expr_stmt|;
block|}
comment|// Safemode service to refuse RPC calls when the router is out of sync
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_SAFEMODE_ENABLE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_SAFEMODE_ENABLE_DEFAULT
argument_list|)
condition|)
block|{
comment|// Create safemode monitoring service
name|this
operator|.
name|safemodeService
operator|=
operator|new
name|RouterSafemodeService
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|this
operator|.
name|safemodeService
argument_list|)
expr_stmt|;
block|}
comment|/*      * Refresh mount table cache immediately after adding, modifying or deleting      * the mount table entries. If this service is not enabled mount table cache      * are refreshed periodically by StateStoreCacheUpdateService      */
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|MOUNT_TABLE_CACHE_UPDATE
argument_list|,
name|RBFConfigKeys
operator|.
name|MOUNT_TABLE_CACHE_UPDATE_DEFAULT
argument_list|)
condition|)
block|{
comment|// There is no use of starting refresh service if state store and admin
comment|// servers are not enabled
name|String
name|disabledDependentServices
init|=
name|getDisabledDependentServices
argument_list|()
decl_stmt|;
comment|/*        * disabledDependentServices null means all dependent services are        * enabled.        */
if|if
condition|(
name|disabledDependentServices
operator|==
literal|null
condition|)
block|{
name|MountTableRefresherService
name|refreshService
init|=
operator|new
name|MountTableRefresherService
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|addService
argument_list|(
name|refreshService
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Service {} is enabled."
argument_list|,
name|MountTableRefresherService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Service {} not enabled: depenendent service(s) {} not enabled."
argument_list|,
name|MountTableRefresherService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|disabledDependentServices
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|getDisabledDependentServices ()
specifier|private
name|String
name|getDisabledDependentServices
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|stateStore
operator|==
literal|null
operator|&&
name|this
operator|.
name|adminServer
operator|==
literal|null
condition|)
block|{
return|return
name|StateStoreService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|","
operator|+
name|RouterAdminServer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|stateStore
operator|==
literal|null
condition|)
block|{
return|return
name|StateStoreService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|adminServer
operator|==
literal|null
condition|)
block|{
return|return
name|RouterAdminServer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Returns the hostname for this Router. If the hostname is not    * explicitly configured in the given config, then it is determined.    *    * @param config configuration    * @return the hostname (NB: may not be a FQDN)    * @throws UnknownHostException if the hostname cannot be determined    */
DECL|method|getHostName (Configuration config)
specifier|private
specifier|static
name|String
name|getHostName
parameter_list|(
name|Configuration
name|config
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|String
name|name
init|=
name|config
operator|.
name|get
argument_list|(
name|DFS_ROUTER_KERBEROS_PRINCIPAL_HOSTNAME_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|name
operator|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getHostName
argument_list|()
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|protected
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|this
operator|.
name|safemodeService
operator|==
literal|null
condition|)
block|{
comment|// Router is running now
name|updateRouterState
argument_list|(
name|RouterServiceState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|pauseMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|pauseMonitor
operator|.
name|start
argument_list|()
expr_stmt|;
name|JvmMetrics
name|jvmMetrics
init|=
name|this
operator|.
name|metrics
operator|.
name|getJvmMetrics
argument_list|()
decl_stmt|;
if|if
condition|(
name|jvmMetrics
operator|!=
literal|null
condition|)
block|{
name|jvmMetrics
operator|.
name|setPauseMonitor
argument_list|(
name|pauseMonitor
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|protected
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Update state
name|updateRouterState
argument_list|(
name|RouterServiceState
operator|.
name|SHUTDOWN
argument_list|)
expr_stmt|;
comment|// JVM pause monitor
if|if
condition|(
name|this
operator|.
name|pauseMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|pauseMonitor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
comment|/**    * Shutdown the router.    */
DECL|method|shutDown ()
specifier|public
name|void
name|shutDown
parameter_list|()
block|{
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Router
operator|.
name|this
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/////////////////////////////////////////////////////////
comment|// RPC Server
comment|/////////////////////////////////////////////////////////
comment|/**    * Create a new Router RPC server to proxy ClientProtocol requests.    *    * @return New Router RPC Server.    * @throws IOException If the router RPC server was not started.    */
DECL|method|createRpcServer ()
specifier|protected
name|RouterRpcServer
name|createRpcServer
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|RouterRpcServer
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|getNamenodeResolver
argument_list|()
argument_list|,
name|this
operator|.
name|getSubclusterResolver
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the Router RPC server.    *    * @return Router RPC server.    */
DECL|method|getRpcServer ()
specifier|public
name|RouterRpcServer
name|getRpcServer
parameter_list|()
block|{
return|return
name|this
operator|.
name|rpcServer
return|;
block|}
comment|/**    * Set the current RPC socket for the router.    *    * @param address RPC address.    */
DECL|method|setRpcServerAddress (InetSocketAddress address)
specifier|protected
name|void
name|setRpcServerAddress
parameter_list|(
name|InetSocketAddress
name|address
parameter_list|)
block|{
name|this
operator|.
name|rpcAddress
operator|=
name|address
expr_stmt|;
comment|// Use the RPC address as our unique router Id
if|if
condition|(
name|this
operator|.
name|rpcAddress
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|String
name|hostname
init|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|setRouterId
argument_list|(
name|hostname
operator|+
literal|":"
operator|+
name|this
operator|.
name|rpcAddress
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot set unique router ID, address not resolvable {}"
argument_list|,
name|this
operator|.
name|rpcAddress
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get the current RPC socket address for the router.    *    * @return InetSocketAddress    */
DECL|method|getRpcServerAddress ()
specifier|public
name|InetSocketAddress
name|getRpcServerAddress
parameter_list|()
block|{
return|return
name|this
operator|.
name|rpcAddress
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|// Admin server
comment|/////////////////////////////////////////////////////////
comment|/**    * Create a new router admin server to handle the router admin interface.    *    * @return RouterAdminServer    * @throws IOException If the admin server was not successfully started.    */
DECL|method|createAdminServer ()
specifier|protected
name|RouterAdminServer
name|createAdminServer
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|RouterAdminServer
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * Set the current Admin socket for the router.    *    * @param address Admin RPC address.    */
DECL|method|setAdminServerAddress (InetSocketAddress address)
specifier|protected
name|void
name|setAdminServerAddress
parameter_list|(
name|InetSocketAddress
name|address
parameter_list|)
block|{
name|this
operator|.
name|adminAddress
operator|=
name|address
expr_stmt|;
block|}
comment|/**    * Get the current Admin socket address for the router.    *    * @return InetSocketAddress Admin address.    */
DECL|method|getAdminServerAddress ()
specifier|public
name|InetSocketAddress
name|getAdminServerAddress
parameter_list|()
block|{
return|return
name|adminAddress
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|// HTTP server
comment|/////////////////////////////////////////////////////////
comment|/**    * Create an HTTP server for this Router.    *    * @return HTTP server for this Router.    */
DECL|method|createHttpServer ()
specifier|protected
name|RouterHttpServer
name|createHttpServer
parameter_list|()
block|{
return|return
operator|new
name|RouterHttpServer
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Get the current HTTP socket address for the router.    *    * @return InetSocketAddress HTTP address.    */
DECL|method|getHttpServerAddress ()
specifier|public
name|InetSocketAddress
name|getHttpServerAddress
parameter_list|()
block|{
if|if
condition|(
name|httpServer
operator|!=
literal|null
condition|)
block|{
return|return
name|httpServer
operator|.
name|getHttpAddress
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|// Namenode heartbeat monitors
comment|/////////////////////////////////////////////////////////
comment|/**    * Create each of the services that will monitor a Namenode.    *    * @return List of heartbeat services.    */
specifier|protected
name|Collection
argument_list|<
name|NamenodeHeartbeatService
argument_list|>
DECL|method|createNamenodeHeartbeatServices ()
name|createNamenodeHeartbeatServices
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|NamenodeHeartbeatService
argument_list|>
name|ret
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_MONITOR_LOCAL_NAMENODE
argument_list|,
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_MONITOR_LOCAL_NAMENODE_DEFAULT
argument_list|)
condition|)
block|{
comment|// Create a local heartbet service
name|NamenodeHeartbeatService
name|localHeartbeatService
init|=
name|createLocalNamenodeHearbeatService
argument_list|()
decl_stmt|;
if|if
condition|(
name|localHeartbeatService
operator|!=
literal|null
condition|)
block|{
name|String
name|nnDesc
init|=
name|localHeartbeatService
operator|.
name|getNamenodeDesc
argument_list|()
decl_stmt|;
name|ret
operator|.
name|put
argument_list|(
name|nnDesc
argument_list|,
name|localHeartbeatService
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create heartbeat services for a list specified by the admin
name|String
name|namenodes
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|RBFConfigKeys
operator|.
name|DFS_ROUTER_MONITOR_NAMENODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|namenodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|namenode
range|:
name|namenodes
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
name|String
index|[]
name|namenodeSplit
init|=
name|namenode
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
name|String
name|nsId
init|=
literal|null
decl_stmt|;
name|String
name|nnId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|namenodeSplit
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|nsId
operator|=
name|namenodeSplit
index|[
literal|0
index|]
expr_stmt|;
name|nnId
operator|=
name|namenodeSplit
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|namenodeSplit
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|nsId
operator|=
name|namenode
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Wrong Namenode to monitor: {}"
argument_list|,
name|namenode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nsId
operator|!=
literal|null
condition|)
block|{
name|NamenodeHeartbeatService
name|heartbeatService
init|=
name|createNamenodeHearbeatService
argument_list|(
name|nsId
argument_list|,
name|nnId
argument_list|)
decl_stmt|;
if|if
condition|(
name|heartbeatService
operator|!=
literal|null
condition|)
block|{
name|ret
operator|.
name|put
argument_list|(
name|heartbeatService
operator|.
name|getNamenodeDesc
argument_list|()
argument_list|,
name|heartbeatService
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|ret
operator|.
name|values
argument_list|()
return|;
block|}
comment|/**    * Create a new status updater for the local Namenode.    *    * @return Updater of the status for the local Namenode.    */
DECL|method|createLocalNamenodeHearbeatService ()
specifier|protected
name|NamenodeHeartbeatService
name|createLocalNamenodeHearbeatService
parameter_list|()
block|{
comment|// Detect NN running in this machine
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|nnId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
condition|)
block|{
name|nnId
operator|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
if|if
condition|(
name|nnId
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot find namenode id for local {}"
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|createNamenodeHearbeatService
argument_list|(
name|nsId
argument_list|,
name|nnId
argument_list|)
return|;
block|}
comment|/**    * Create a heartbeat monitor for a particular Namenode.    *    * @param nsId Identifier of the nameservice to monitor.    * @param nnId Identifier of the namenode (HA) to monitor.    * @return Updater of the status for the specified Namenode.    */
DECL|method|createNamenodeHearbeatService ( String nsId, String nnId)
specifier|protected
name|NamenodeHeartbeatService
name|createNamenodeHearbeatService
parameter_list|(
name|String
name|nsId
parameter_list|,
name|String
name|nnId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating heartbeat service for Namenode {} in {}"
argument_list|,
name|nnId
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
name|NamenodeHeartbeatService
name|ret
init|=
operator|new
name|NamenodeHeartbeatService
argument_list|(
name|namenodeResolver
argument_list|,
name|nsId
argument_list|,
name|nnId
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|// Router State Management
comment|/////////////////////////////////////////////////////////
comment|/**    * Update the router state and heartbeat to the state store.    *    * @param newState The new router state.    */
DECL|method|updateRouterState (RouterServiceState newState)
specifier|public
name|void
name|updateRouterState
parameter_list|(
name|RouterServiceState
name|newState
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|newState
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|routerHeartbeatService
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|routerHeartbeatService
operator|.
name|updateStateAsync
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the status of the router.    *    * @return Status of the router.    */
DECL|method|getRouterState ()
specifier|public
name|RouterServiceState
name|getRouterState
parameter_list|()
block|{
return|return
name|this
operator|.
name|state
return|;
block|}
comment|/**    * Compare router state.    */
DECL|method|isRouterState (RouterServiceState routerState)
specifier|public
name|boolean
name|isRouterState
parameter_list|(
name|RouterServiceState
name|routerState
parameter_list|)
block|{
return|return
name|routerState
operator|.
name|equals
argument_list|(
name|this
operator|.
name|state
argument_list|)
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|// Submodule getters
comment|/////////////////////////////////////////////////////////
comment|/**    * Get the State Store service.    *    * @return State Store service.    */
DECL|method|getStateStore ()
specifier|public
name|StateStoreService
name|getStateStore
parameter_list|()
block|{
return|return
name|this
operator|.
name|stateStore
return|;
block|}
comment|/**    * Get the metrics system for the Router.    *    * @return Router metrics.    */
DECL|method|getRouterMetrics ()
specifier|public
name|RouterMetrics
name|getRouterMetrics
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|metrics
operator|!=
literal|null
condition|)
block|{
return|return
name|this
operator|.
name|metrics
operator|.
name|getRouterMetrics
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get the federation metrics.    *    * @return Federation metrics.    */
DECL|method|getMetrics ()
specifier|public
name|FederationMetrics
name|getMetrics
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|metrics
operator|!=
literal|null
condition|)
block|{
return|return
name|this
operator|.
name|metrics
operator|.
name|getFederationMetrics
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get the Namenode metrics.    *    * @return Namenode metrics.    */
DECL|method|getNamenodeMetrics ()
specifier|public
name|NamenodeBeanMetrics
name|getNamenodeMetrics
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|metrics
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Namenode metrics is not initialized"
argument_list|)
throw|;
block|}
return|return
name|this
operator|.
name|metrics
operator|.
name|getNamenodeMetrics
argument_list|()
return|;
block|}
comment|/**    * Get the subcluster resolver for files.    *    * @return Subcluster resolver for files.    */
DECL|method|getSubclusterResolver ()
specifier|public
name|FileSubclusterResolver
name|getSubclusterResolver
parameter_list|()
block|{
return|return
name|this
operator|.
name|subclusterResolver
return|;
block|}
comment|/**    * Get the namenode resolver for a subcluster.    *    * @return The namenode resolver for a subcluster.    */
DECL|method|getNamenodeResolver ()
specifier|public
name|ActiveNamenodeResolver
name|getNamenodeResolver
parameter_list|()
block|{
return|return
name|this
operator|.
name|namenodeResolver
return|;
block|}
comment|/**    * Get the state store interface for the router heartbeats.    *    * @return FederationRouterStateStore state store API handle.    */
DECL|method|getRouterStateManager ()
specifier|public
name|RouterStore
name|getRouterStateManager
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|routerStateManager
operator|==
literal|null
operator|&&
name|this
operator|.
name|stateStore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|routerStateManager
operator|=
name|this
operator|.
name|stateStore
operator|.
name|getRegisteredRecordStore
argument_list|(
name|RouterStore
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|routerStateManager
return|;
block|}
comment|/////////////////////////////////////////////////////////
comment|// Router info
comment|/////////////////////////////////////////////////////////
comment|/**    * Get the start date of the Router.    *    * @return Start date of the router.    */
DECL|method|getStartTime ()
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|this
operator|.
name|startTime
return|;
block|}
comment|/**    * Unique ID for the router, typically the hostname:port string for the    * router's RPC server. This ID may be null on router startup before the RPC    * server has bound to a port.    *    * @return Router identifier.    */
DECL|method|getRouterId ()
specifier|public
name|String
name|getRouterId
parameter_list|()
block|{
return|return
name|this
operator|.
name|routerId
return|;
block|}
comment|/**    * Sets a unique ID for this router.    *    * @param id Identifier of the Router.    */
DECL|method|setRouterId (String id)
specifier|public
name|void
name|setRouterId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|routerId
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|stateStore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|stateStore
operator|.
name|setIdentifier
argument_list|(
name|this
operator|.
name|routerId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|namenodeResolver
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|namenodeResolver
operator|.
name|setRouterId
argument_list|(
name|this
operator|.
name|routerId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check if the quota system is enabled in Router.    * @return True if the quota system is enabled in Router.    */
DECL|method|isQuotaEnabled ()
specifier|public
name|boolean
name|isQuotaEnabled
parameter_list|()
block|{
return|return
name|this
operator|.
name|quotaManager
operator|!=
literal|null
return|;
block|}
comment|/**    * Get route quota manager.    * @return RouterQuotaManager Quota manager.    */
DECL|method|getQuotaManager ()
specifier|public
name|RouterQuotaManager
name|getQuotaManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|quotaManager
return|;
block|}
comment|/**    * Get quota cache update service.    */
annotation|@
name|VisibleForTesting
DECL|method|getQuotaCacheUpdateService ()
name|RouterQuotaUpdateService
name|getQuotaCacheUpdateService
parameter_list|()
block|{
return|return
name|this
operator|.
name|quotaUpdateService
return|;
block|}
comment|/**    * Get the list of namenode heartbeat service.    */
annotation|@
name|VisibleForTesting
DECL|method|getNamenodeHearbeatServices ()
name|Collection
argument_list|<
name|NamenodeHeartbeatService
argument_list|>
name|getNamenodeHearbeatServices
parameter_list|()
block|{
return|return
name|this
operator|.
name|namenodeHeartbeatServices
return|;
block|}
comment|/**    * Get the Router safe mode service.    */
DECL|method|getSafemodeService ()
name|RouterSafemodeService
name|getSafemodeService
parameter_list|()
block|{
return|return
name|this
operator|.
name|safemodeService
return|;
block|}
comment|/**    * Get router admin server.    *    * @return Null if admin is not enabled.    */
DECL|method|getAdminServer ()
specifier|public
name|RouterAdminServer
name|getAdminServer
parameter_list|()
block|{
return|return
name|adminServer
return|;
block|}
block|}
end_class

end_unit

