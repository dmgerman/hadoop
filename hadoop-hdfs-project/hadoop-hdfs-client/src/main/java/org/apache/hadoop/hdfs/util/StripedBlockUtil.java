begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.util
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedStripedBlock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSStripedOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * When accessing a file in striped layout, operations on logical byte ranges  * in the file need to be mapped to physical byte ranges on block files stored  * on DataNodes. This utility class facilities this mapping by defining and  * exposing a number of striping-related concepts. The most basic ones are  * illustrated in the following diagram. Unless otherwise specified, all  * range-related calculations are inclusive (the end offset of the previous  * range should be 1 byte lower than the start offset of the next one).  *  *  |<----  Block Group ----> |<- Block Group: logical unit composing  *  |                          |        striped HDFS files.  *  blk_0      blk_1       blk_2<- Internal Blocks: each internal block  *    |          |           |          represents a physically stored local  *    v          v           v          block file  * +------+   +------+   +------+  * |cell_0|   |cell_1|   |cell_2|<- {@link StripingCell} represents the  * +------+   +------+   +------+       logical order that a Block Group should  * |cell_3|   |cell_4|   |cell_5|       be accessed: cell_0, cell_1, ...  * +------+   +------+   +------+  * |cell_6|   |cell_7|   |cell_8|  * +------+   +------+   +------+  * |cell_9|  * +------+<- A cell contains cellSize bytes of data  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|StripedBlockUtil
specifier|public
class|class
name|StripedBlockUtil
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StripedBlockUtil
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * This method parses a striped block group into individual blocks.    *    * @param bg The striped block group    * @param cellSize The size of a striping cell    * @param dataBlkNum The number of data blocks    * @return An array containing the blocks in the group    */
DECL|method|parseStripedBlockGroup (LocatedStripedBlock bg, int cellSize, int dataBlkNum, int parityBlkNum)
specifier|public
specifier|static
name|LocatedBlock
index|[]
name|parseStripedBlockGroup
parameter_list|(
name|LocatedStripedBlock
name|bg
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|)
block|{
name|int
name|locatedBGSize
init|=
name|bg
operator|.
name|getBlockIndices
argument_list|()
operator|.
name|length
decl_stmt|;
name|LocatedBlock
index|[]
name|lbs
init|=
operator|new
name|LocatedBlock
index|[
name|dataBlkNum
operator|+
name|parityBlkNum
index|]
decl_stmt|;
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locatedBGSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|idx
init|=
name|bg
operator|.
name|getBlockIndices
argument_list|()
index|[
name|i
index|]
decl_stmt|;
comment|// for now we do not use redundant replica of an internal block
if|if
condition|(
name|idx
operator|<
operator|(
name|dataBlkNum
operator|+
name|parityBlkNum
operator|)
operator|&&
name|lbs
index|[
name|idx
index|]
operator|==
literal|null
condition|)
block|{
name|lbs
index|[
name|idx
index|]
operator|=
name|constructInternalBlock
argument_list|(
name|bg
argument_list|,
name|i
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lbs
return|;
block|}
comment|/**    * This method creates an internal block at the given index of a block group.    *    * @param idxInReturnedLocs The index in the stored locations in the    *                          {@link LocatedStripedBlock} object    * @param idxInBlockGroup The logical index in the striped block group    * @return The constructed internal block    */
DECL|method|constructInternalBlock (LocatedStripedBlock bg, int idxInReturnedLocs, int cellSize, int dataBlkNum, int idxInBlockGroup)
specifier|public
specifier|static
name|LocatedBlock
name|constructInternalBlock
parameter_list|(
name|LocatedStripedBlock
name|bg
parameter_list|,
name|int
name|idxInReturnedLocs
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
specifier|final
name|ExtendedBlock
name|blk
init|=
name|constructInternalBlock
argument_list|(
name|bg
operator|.
name|getBlock
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idxInBlockGroup
argument_list|)
decl_stmt|;
specifier|final
name|LocatedBlock
name|locatedBlock
decl_stmt|;
if|if
condition|(
name|idxInReturnedLocs
operator|<
name|bg
operator|.
name|getLocations
argument_list|()
operator|.
name|length
condition|)
block|{
name|locatedBlock
operator|=
operator|new
name|LocatedBlock
argument_list|(
name|blk
argument_list|,
operator|new
name|DatanodeInfo
index|[]
block|{
name|bg
operator|.
name|getLocations
argument_list|()
index|[
name|idxInReturnedLocs
index|]
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
name|bg
operator|.
name|getStorageIDs
argument_list|()
index|[
name|idxInReturnedLocs
index|]
block|}
argument_list|,
operator|new
name|StorageType
index|[]
block|{
name|bg
operator|.
name|getStorageTypes
argument_list|()
index|[
name|idxInReturnedLocs
index|]
block|}
argument_list|,
name|bg
operator|.
name|getStartOffset
argument_list|()
argument_list|,
name|bg
operator|.
name|isCorrupt
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locatedBlock
operator|=
operator|new
name|LocatedBlock
argument_list|(
name|blk
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|bg
operator|.
name|getStartOffset
argument_list|()
argument_list|,
name|bg
operator|.
name|isCorrupt
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
index|[]
name|blockTokens
init|=
name|bg
operator|.
name|getBlockTokens
argument_list|()
decl_stmt|;
if|if
condition|(
name|idxInReturnedLocs
operator|<
name|blockTokens
operator|.
name|length
condition|)
block|{
name|locatedBlock
operator|.
name|setBlockToken
argument_list|(
name|blockTokens
index|[
name|idxInReturnedLocs
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|locatedBlock
return|;
block|}
DECL|method|constructInternalBlock ( ExtendedBlock blockGroup, ErasureCodingPolicy ecPolicy, int idxInBlockGroup)
specifier|public
specifier|static
name|ExtendedBlock
name|constructInternalBlock
parameter_list|(
name|ExtendedBlock
name|blockGroup
parameter_list|,
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
return|return
name|constructInternalBlock
argument_list|(
name|blockGroup
argument_list|,
name|ecPolicy
operator|.
name|getCellSize
argument_list|()
argument_list|,
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
argument_list|,
name|idxInBlockGroup
argument_list|)
return|;
block|}
comment|/**    * This method creates an internal {@link ExtendedBlock} at the given index    * of a block group.    */
DECL|method|constructInternalBlock (ExtendedBlock blockGroup, int cellSize, int dataBlkNum, int idxInBlockGroup)
specifier|public
specifier|static
name|ExtendedBlock
name|constructInternalBlock
parameter_list|(
name|ExtendedBlock
name|blockGroup
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
name|ExtendedBlock
name|block
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|blockGroup
argument_list|)
decl_stmt|;
name|block
operator|.
name|setBlockId
argument_list|(
name|blockGroup
operator|.
name|getBlockId
argument_list|()
operator|+
name|idxInBlockGroup
argument_list|)
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|getInternalBlockLength
argument_list|(
name|blockGroup
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|idxInBlockGroup
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
DECL|method|getInternalBlockLength (long dataSize, ErasureCodingPolicy ecPolicy, int idxInBlockGroup)
specifier|public
specifier|static
name|long
name|getInternalBlockLength
parameter_list|(
name|long
name|dataSize
parameter_list|,
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
return|return
name|getInternalBlockLength
argument_list|(
name|dataSize
argument_list|,
name|ecPolicy
operator|.
name|getCellSize
argument_list|()
argument_list|,
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
argument_list|,
name|idxInBlockGroup
argument_list|)
return|;
block|}
comment|/**    * Get the size of an internal block at the given index of a block group.    *    * @param dataSize Size of the block group only counting data blocks    * @param cellSize The size of a striping cell    * @param numDataBlocks The number of data blocks    * @param idxInBlockGroup The logical index in the striped block group    * @return The size of the internal block at the specified index    */
DECL|method|getInternalBlockLength (long dataSize, int cellSize, int numDataBlocks, int idxInBlockGroup)
specifier|public
specifier|static
name|long
name|getInternalBlockLength
parameter_list|(
name|long
name|dataSize
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|numDataBlocks
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|dataSize
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|cellSize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numDataBlocks
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|idxInBlockGroup
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// Size of each stripe (only counting data blocks)
specifier|final
name|int
name|stripeSize
init|=
name|cellSize
operator|*
name|numDataBlocks
decl_stmt|;
comment|// If block group ends at stripe boundary, each internal block has an equal
comment|// share of the group
specifier|final
name|int
name|lastStripeDataLen
init|=
call|(
name|int
call|)
argument_list|(
name|dataSize
operator|%
name|stripeSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastStripeDataLen
operator|==
literal|0
condition|)
block|{
return|return
name|dataSize
operator|/
name|numDataBlocks
return|;
block|}
specifier|final
name|int
name|numStripes
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|dataSize
operator|-
literal|1
operator|)
operator|/
name|stripeSize
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|numStripes
operator|-
literal|1L
operator|)
operator|*
name|cellSize
operator|+
name|lastCellSize
argument_list|(
name|lastStripeDataLen
argument_list|,
name|cellSize
argument_list|,
name|numDataBlocks
argument_list|,
name|idxInBlockGroup
argument_list|)
return|;
block|}
comment|/**    * Compute the safe length given the internal block lengths.    *    * @param ecPolicy The EC policy used for the block group    * @param blockLens The lengths of internal blocks    * @return The safe length    */
DECL|method|getSafeLength (ErasureCodingPolicy ecPolicy, long[] blockLens)
specifier|public
specifier|static
name|long
name|getSafeLength
parameter_list|(
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|long
index|[]
name|blockLens
parameter_list|)
block|{
specifier|final
name|int
name|cellSize
init|=
name|ecPolicy
operator|.
name|getCellSize
argument_list|()
decl_stmt|;
specifier|final
name|int
name|dataBlkNum
init|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|blockLens
operator|.
name|length
operator|>=
name|dataBlkNum
argument_list|)
expr_stmt|;
specifier|final
name|int
name|stripeSize
init|=
name|dataBlkNum
operator|*
name|cellSize
decl_stmt|;
name|long
index|[]
name|cpy
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|blockLens
argument_list|,
name|blockLens
operator|.
name|length
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|cpy
argument_list|)
expr_stmt|;
comment|// full stripe is a stripe has at least dataBlkNum full cells.
comment|// lastFullStripeIdx is the index of the last full stripe.
name|int
name|lastFullStripeIdx
init|=
call|(
name|int
call|)
argument_list|(
name|cpy
index|[
name|cpy
operator|.
name|length
operator|-
name|dataBlkNum
index|]
operator|/
name|cellSize
argument_list|)
decl_stmt|;
return|return
name|lastFullStripeIdx
operator|*
name|stripeSize
return|;
comment|// return the safeLength
comment|// TODO: Include lastFullStripeIdx+1 stripe in safeLength, if there exists
comment|// such a stripe (and it must be partial).
block|}
DECL|method|lastCellSize (int size, int cellSize, int numDataBlocks, int i)
specifier|private
specifier|static
name|int
name|lastCellSize
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|numDataBlocks
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
name|numDataBlocks
condition|)
block|{
comment|// parity block size (i.e. i>= numDataBlocks) is the same as
comment|// the first data block size (i.e. i = 0).
name|size
operator|-=
name|i
operator|*
name|cellSize
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|size
operator|>
name|cellSize
condition|?
name|cellSize
else|:
name|size
return|;
block|}
comment|/**    * Given a byte's offset in an internal block, calculate the offset in    * the block group.    */
DECL|method|offsetInBlkToOffsetInBG (int cellSize, int dataBlkNum, long offsetInBlk, int idxInBlockGroup)
specifier|public
specifier|static
name|long
name|offsetInBlkToOffsetInBG
parameter_list|(
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|long
name|offsetInBlk
parameter_list|,
name|int
name|idxInBlockGroup
parameter_list|)
block|{
name|int
name|cellIdxInBlk
init|=
call|(
name|int
call|)
argument_list|(
name|offsetInBlk
operator|/
name|cellSize
argument_list|)
decl_stmt|;
return|return
name|cellIdxInBlk
operator|*
name|cellSize
operator|*
name|dataBlkNum
comment|// n full stripes before offset
operator|+
name|idxInBlockGroup
operator|*
name|cellSize
comment|// m full cells before offset
operator|+
name|offsetInBlk
operator|%
name|cellSize
return|;
comment|// partial cell
block|}
comment|/**    * Get the next completed striped read task.    *    * @return {@link StripingChunkReadResult} indicating the status of the read    *          task succeeded, and the block index of the task. If the method    *          times out without getting any completed read tasks, -1 is    *          returned as block index.    * @throws InterruptedException    */
DECL|method|getNextCompletedStripedRead ( CompletionService<Void> readService, Map<Future<Void>, Integer> futures, final long timeoutMillis)
specifier|public
specifier|static
name|StripingChunkReadResult
name|getNextCompletedStripedRead
parameter_list|(
name|CompletionService
argument_list|<
name|Void
argument_list|>
name|readService
parameter_list|,
name|Map
argument_list|<
name|Future
argument_list|<
name|Void
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|futures
parameter_list|,
specifier|final
name|long
name|timeoutMillis
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|futures
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Future
argument_list|<
name|Void
argument_list|>
name|future
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|timeoutMillis
operator|>
literal|0
condition|)
block|{
name|future
operator|=
name|readService
operator|.
name|poll
argument_list|(
name|timeoutMillis
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|future
operator|=
name|readService
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|future
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
argument_list|,
name|StripingChunkReadResult
operator|.
name|SUCCESSFUL
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|StripingChunkReadResult
operator|.
name|TIMEOUT
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception during striped read task"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
argument_list|,
name|StripingChunkReadResult
operator|.
name|FAILED
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|CancellationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception during striped read task"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|StripingChunkReadResult
argument_list|(
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
argument_list|,
name|StripingChunkReadResult
operator|.
name|CANCELLED
argument_list|)
return|;
block|}
block|}
comment|/**    * Get the total usage of the striped blocks, which is the total of data    * blocks and parity blocks.    *    * @param numDataBlkBytes    *          Size of the block group only counting data blocks    * @param dataBlkNum    *          The number of data blocks    * @param parityBlkNum    *          The number of parity blocks    * @param cellSize    *          The size of a striping cell    * @return The total usage of data blocks and parity blocks    */
DECL|method|spaceConsumedByStripedBlock (long numDataBlkBytes, int dataBlkNum, int parityBlkNum, int cellSize)
specifier|public
specifier|static
name|long
name|spaceConsumedByStripedBlock
parameter_list|(
name|long
name|numDataBlkBytes
parameter_list|,
name|int
name|dataBlkNum
parameter_list|,
name|int
name|parityBlkNum
parameter_list|,
name|int
name|cellSize
parameter_list|)
block|{
name|int
name|parityIndex
init|=
name|dataBlkNum
operator|+
literal|1
decl_stmt|;
name|long
name|numParityBlkBytes
init|=
name|getInternalBlockLength
argument_list|(
name|numDataBlkBytes
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|parityIndex
argument_list|)
operator|*
name|parityBlkNum
decl_stmt|;
return|return
name|numDataBlkBytes
operator|+
name|numParityBlkBytes
return|;
block|}
comment|/**    * Similar functionality with {@link #divideByteRangeIntoStripes}, but is used    * by stateful read and uses ByteBuffer as reading target buffer. Besides the    * read range is within a single stripe thus the calculation logic is simpler.    */
DECL|method|divideOneStripe (ErasureCodingPolicy ecPolicy, int cellSize, LocatedStripedBlock blockGroup, long rangeStartInBlockGroup, long rangeEndInBlockGroup, ByteBuffer buf)
specifier|public
specifier|static
name|AlignedStripe
index|[]
name|divideOneStripe
parameter_list|(
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|long
name|rangeStartInBlockGroup
parameter_list|,
name|long
name|rangeEndInBlockGroup
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
block|{
specifier|final
name|int
name|dataBlkNum
init|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
comment|// Step 1: map the byte range to StripingCells
name|StripingCell
index|[]
name|cells
init|=
name|getStripingCellsOfByteRange
argument_list|(
name|ecPolicy
argument_list|,
name|cellSize
argument_list|,
name|blockGroup
argument_list|,
name|rangeStartInBlockGroup
argument_list|,
name|rangeEndInBlockGroup
argument_list|)
decl_stmt|;
comment|// Step 2: get the unmerged ranges on each internal block
name|VerticalRange
index|[]
name|ranges
init|=
name|getRangesForInternalBlocks
argument_list|(
name|ecPolicy
argument_list|,
name|cellSize
argument_list|,
name|cells
argument_list|)
decl_stmt|;
comment|// Step 3: merge into stripes
name|AlignedStripe
index|[]
name|stripes
init|=
name|mergeRangesForInternalBlocks
argument_list|(
name|ecPolicy
argument_list|,
name|ranges
argument_list|)
decl_stmt|;
comment|// Step 4: calculate each chunk's position in destination buffer. Since the
comment|// whole read range is within a single stripe, the logic is simpler here.
name|int
name|bufOffset
init|=
call|(
name|int
call|)
argument_list|(
name|rangeStartInBlockGroup
operator|%
operator|(
operator|(
name|long
operator|)
name|cellSize
operator|*
name|dataBlkNum
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|StripingCell
name|cell
range|:
name|cells
control|)
block|{
name|long
name|cellStart
init|=
name|cell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
operator|+
name|cell
operator|.
name|offset
decl_stmt|;
name|long
name|cellEnd
init|=
name|cellStart
operator|+
name|cell
operator|.
name|size
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AlignedStripe
name|s
range|:
name|stripes
control|)
block|{
name|long
name|stripeEnd
init|=
name|s
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
name|s
operator|.
name|getSpanInBlock
argument_list|()
operator|-
literal|1
decl_stmt|;
name|long
name|overlapStart
init|=
name|Math
operator|.
name|max
argument_list|(
name|cellStart
argument_list|,
name|s
operator|.
name|getOffsetInBlock
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|overlapEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|cellEnd
argument_list|,
name|stripeEnd
argument_list|)
decl_stmt|;
name|int
name|overLapLen
init|=
call|(
name|int
call|)
argument_list|(
name|overlapEnd
operator|-
name|overlapStart
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|overLapLen
operator|>
literal|0
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|==
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|int
name|pos
init|=
call|(
name|int
call|)
argument_list|(
name|bufOffset
operator|+
name|overlapStart
operator|-
name|cellStart
argument_list|)
decl_stmt|;
name|buf
operator|.
name|position
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|pos
operator|+
name|overLapLen
argument_list|)
expr_stmt|;
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|=
operator|new
name|StripingChunk
argument_list|(
name|buf
operator|.
name|slice
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|bufOffset
operator|+=
name|cell
operator|.
name|size
expr_stmt|;
block|}
comment|// Step 5: prepare ALLZERO blocks
name|prepareAllZeroChunks
argument_list|(
name|blockGroup
argument_list|,
name|stripes
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|)
expr_stmt|;
return|return
name|stripes
return|;
block|}
comment|/**    * This method divides a requested byte range into an array of inclusive    * {@link AlignedStripe}.    * @param ecPolicy The codec policy for the file, which carries the numbers    *                 of data / parity blocks    * @param cellSize Cell size of stripe    * @param blockGroup The striped block group    * @param rangeStartInBlockGroup The byte range's start offset in block group    * @param rangeEndInBlockGroup The byte range's end offset in block group    * @param buf Destination buffer of the read operation for the byte range    *    * At most 5 stripes will be generated from each logical range, as    * demonstrated in the header of {@link AlignedStripe}.    */
DECL|method|divideByteRangeIntoStripes ( ErasureCodingPolicy ecPolicy, int cellSize, LocatedStripedBlock blockGroup, long rangeStartInBlockGroup, long rangeEndInBlockGroup, ByteBuffer buf)
specifier|public
specifier|static
name|AlignedStripe
index|[]
name|divideByteRangeIntoStripes
parameter_list|(
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|long
name|rangeStartInBlockGroup
parameter_list|,
name|long
name|rangeEndInBlockGroup
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
block|{
comment|// Step 0: analyze range and calculate basic parameters
specifier|final
name|int
name|dataBlkNum
init|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
comment|// Step 1: map the byte range to StripingCells
name|StripingCell
index|[]
name|cells
init|=
name|getStripingCellsOfByteRange
argument_list|(
name|ecPolicy
argument_list|,
name|cellSize
argument_list|,
name|blockGroup
argument_list|,
name|rangeStartInBlockGroup
argument_list|,
name|rangeEndInBlockGroup
argument_list|)
decl_stmt|;
comment|// Step 2: get the unmerged ranges on each internal block
name|VerticalRange
index|[]
name|ranges
init|=
name|getRangesForInternalBlocks
argument_list|(
name|ecPolicy
argument_list|,
name|cellSize
argument_list|,
name|cells
argument_list|)
decl_stmt|;
comment|// Step 3: merge into at most 5 stripes
name|AlignedStripe
index|[]
name|stripes
init|=
name|mergeRangesForInternalBlocks
argument_list|(
name|ecPolicy
argument_list|,
name|ranges
argument_list|)
decl_stmt|;
comment|// Step 4: calculate each chunk's position in destination buffer
name|calcualteChunkPositionsInBuf
argument_list|(
name|cellSize
argument_list|,
name|stripes
argument_list|,
name|cells
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|// Step 5: prepare ALLZERO blocks
name|prepareAllZeroChunks
argument_list|(
name|blockGroup
argument_list|,
name|stripes
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|)
expr_stmt|;
return|return
name|stripes
return|;
block|}
comment|/**    * Map the logical byte range to a set of inclusive {@link StripingCell}    * instances, each representing the overlap of the byte range to a cell    * used by {@link DFSStripedOutputStream} in encoding.    */
annotation|@
name|VisibleForTesting
DECL|method|getStripingCellsOfByteRange ( ErasureCodingPolicy ecPolicy, int cellSize, LocatedStripedBlock blockGroup, long rangeStartInBlockGroup, long rangeEndInBlockGroup)
specifier|private
specifier|static
name|StripingCell
index|[]
name|getStripingCellsOfByteRange
parameter_list|(
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|long
name|rangeStartInBlockGroup
parameter_list|,
name|long
name|rangeEndInBlockGroup
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|rangeStartInBlockGroup
operator|<=
name|rangeEndInBlockGroup
operator|&&
name|rangeEndInBlockGroup
operator|<
name|blockGroup
operator|.
name|getBlockSize
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|len
init|=
name|rangeEndInBlockGroup
operator|-
name|rangeStartInBlockGroup
operator|+
literal|1
decl_stmt|;
name|int
name|firstCellIdxInBG
init|=
call|(
name|int
call|)
argument_list|(
name|rangeStartInBlockGroup
operator|/
name|cellSize
argument_list|)
decl_stmt|;
name|int
name|lastCellIdxInBG
init|=
call|(
name|int
call|)
argument_list|(
name|rangeEndInBlockGroup
operator|/
name|cellSize
argument_list|)
decl_stmt|;
name|int
name|numCells
init|=
name|lastCellIdxInBG
operator|-
name|firstCellIdxInBG
operator|+
literal|1
decl_stmt|;
name|StripingCell
index|[]
name|cells
init|=
operator|new
name|StripingCell
index|[
name|numCells
index|]
decl_stmt|;
specifier|final
name|int
name|firstCellOffset
init|=
call|(
name|int
call|)
argument_list|(
name|rangeStartInBlockGroup
operator|%
name|cellSize
argument_list|)
decl_stmt|;
specifier|final
name|int
name|firstCellSize
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|cellSize
operator|-
operator|(
name|rangeStartInBlockGroup
operator|%
name|cellSize
operator|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|cells
index|[
literal|0
index|]
operator|=
operator|new
name|StripingCell
argument_list|(
name|ecPolicy
argument_list|,
name|firstCellSize
argument_list|,
name|firstCellIdxInBG
argument_list|,
name|firstCellOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastCellIdxInBG
operator|!=
name|firstCellIdxInBG
condition|)
block|{
specifier|final
name|int
name|lastCellSize
init|=
call|(
name|int
call|)
argument_list|(
name|rangeEndInBlockGroup
operator|%
name|cellSize
argument_list|)
operator|+
literal|1
decl_stmt|;
name|cells
index|[
name|numCells
operator|-
literal|1
index|]
operator|=
operator|new
name|StripingCell
argument_list|(
name|ecPolicy
argument_list|,
name|lastCellSize
argument_list|,
name|lastCellIdxInBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numCells
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|cells
index|[
name|i
index|]
operator|=
operator|new
name|StripingCell
argument_list|(
name|ecPolicy
argument_list|,
name|cellSize
argument_list|,
name|i
operator|+
name|firstCellIdxInBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|cells
return|;
block|}
comment|/**    * Given a logical byte range, mapped to each {@link StripingCell}, calculate    * the physical byte range (inclusive) on each stored internal block.    */
annotation|@
name|VisibleForTesting
DECL|method|getRangesForInternalBlocks ( ErasureCodingPolicy ecPolicy, int cellSize, StripingCell[] cells)
specifier|private
specifier|static
name|VerticalRange
index|[]
name|getRangesForInternalBlocks
parameter_list|(
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|StripingCell
index|[]
name|cells
parameter_list|)
block|{
name|int
name|dataBlkNum
init|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|int
name|parityBlkNum
init|=
name|ecPolicy
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
name|VerticalRange
index|[]
name|ranges
init|=
operator|new
name|VerticalRange
index|[
name|dataBlkNum
operator|+
name|parityBlkNum
index|]
decl_stmt|;
name|long
name|earliestStart
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|long
name|latestEnd
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|StripingCell
name|cell
range|:
name|cells
control|)
block|{
comment|// iterate through all cells and update the list of StripeRanges
if|if
condition|(
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|==
literal|null
condition|)
block|{
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|=
operator|new
name|VerticalRange
argument_list|(
name|cell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
operator|+
name|cell
operator|.
name|offset
argument_list|,
name|cell
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|.
name|spanInBlock
operator|+=
name|cell
operator|.
name|size
expr_stmt|;
block|}
name|VerticalRange
name|range
init|=
name|ranges
index|[
name|cell
operator|.
name|idxInStripe
index|]
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|offsetInBlock
operator|<
name|earliestStart
condition|)
block|{
name|earliestStart
operator|=
name|range
operator|.
name|offsetInBlock
expr_stmt|;
block|}
if|if
condition|(
name|range
operator|.
name|offsetInBlock
operator|+
name|range
operator|.
name|spanInBlock
operator|-
literal|1
operator|>
name|latestEnd
condition|)
block|{
name|latestEnd
operator|=
name|range
operator|.
name|offsetInBlock
operator|+
name|range
operator|.
name|spanInBlock
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|// Each parity block should be fetched at maximum range of all data blocks
for|for
control|(
name|int
name|i
init|=
name|dataBlkNum
init|;
name|i
operator|<
name|dataBlkNum
operator|+
name|parityBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|ranges
index|[
name|i
index|]
operator|=
operator|new
name|VerticalRange
argument_list|(
name|earliestStart
argument_list|,
name|latestEnd
operator|-
name|earliestStart
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ranges
return|;
block|}
comment|/**    * Merge byte ranges on each internal block into a set of inclusive    * {@link AlignedStripe} instances.    */
DECL|method|mergeRangesForInternalBlocks ( ErasureCodingPolicy ecPolicy, VerticalRange[] ranges)
specifier|private
specifier|static
name|AlignedStripe
index|[]
name|mergeRangesForInternalBlocks
parameter_list|(
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|VerticalRange
index|[]
name|ranges
parameter_list|)
block|{
name|int
name|dataBlkNum
init|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|int
name|parityBlkNum
init|=
name|ecPolicy
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AlignedStripe
argument_list|>
name|stripes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|SortedSet
argument_list|<
name|Long
argument_list|>
name|stripePoints
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|VerticalRange
name|r
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|stripePoints
operator|.
name|add
argument_list|(
name|r
operator|.
name|offsetInBlock
argument_list|)
expr_stmt|;
name|stripePoints
operator|.
name|add
argument_list|(
name|r
operator|.
name|offsetInBlock
operator|+
name|r
operator|.
name|spanInBlock
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|prev
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|long
name|point
range|:
name|stripePoints
control|)
block|{
if|if
condition|(
name|prev
operator|>=
literal|0
condition|)
block|{
name|stripes
operator|.
name|add
argument_list|(
operator|new
name|AlignedStripe
argument_list|(
name|prev
argument_list|,
name|point
operator|-
name|prev
argument_list|,
name|dataBlkNum
operator|+
name|parityBlkNum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|point
expr_stmt|;
block|}
return|return
name|stripes
operator|.
name|toArray
argument_list|(
operator|new
name|AlignedStripe
index|[
name|stripes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|calcualteChunkPositionsInBuf (int cellSize, AlignedStripe[] stripes, StripingCell[] cells, ByteBuffer buf)
specifier|private
specifier|static
name|void
name|calcualteChunkPositionsInBuf
parameter_list|(
name|int
name|cellSize
parameter_list|,
name|AlignedStripe
index|[]
name|stripes
parameter_list|,
name|StripingCell
index|[]
name|cells
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
block|{
comment|/**      *     |<--------------- AlignedStripe --------------->|      *      *     |<- length_0 ->|<--  length_1  -->|<- length_2 ->|      * +------------------+------------------+----------------+      * |    cell_0_0_0    |    cell_3_1_0    |   cell_6_2_0   |<- blk_0      * +------------------+------------------+----------------+      *   _/                \_______________________      *  |                                          |      *  v offset_0                                 v offset_1      * +----------------------------------------------------------+      * |  cell_0_0_0 |  cell_1_0_1 and cell_2_0_2  |cell_3_1_0 ...|<- buf      * |  (partial)  |    (from blk_1 and blk_2)   |              |      * +----------------------------------------------------------+      *      * Cell indexing convention defined in {@link StripingCell}      */
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|StripingCell
name|cell
range|:
name|cells
control|)
block|{
name|long
name|cellStart
init|=
name|cell
operator|.
name|idxInInternalBlk
operator|*
name|cellSize
operator|+
name|cell
operator|.
name|offset
decl_stmt|;
name|long
name|cellEnd
init|=
name|cellStart
operator|+
name|cell
operator|.
name|size
operator|-
literal|1
decl_stmt|;
name|StripingChunk
name|chunk
decl_stmt|;
for|for
control|(
name|AlignedStripe
name|s
range|:
name|stripes
control|)
block|{
name|long
name|stripeEnd
init|=
name|s
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
name|s
operator|.
name|getSpanInBlock
argument_list|()
operator|-
literal|1
decl_stmt|;
name|long
name|overlapStart
init|=
name|Math
operator|.
name|max
argument_list|(
name|cellStart
argument_list|,
name|s
operator|.
name|getOffsetInBlock
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|overlapEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|cellEnd
argument_list|,
name|stripeEnd
argument_list|)
decl_stmt|;
name|int
name|overLapLen
init|=
call|(
name|int
call|)
argument_list|(
name|overlapEnd
operator|-
name|overlapStart
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|overLapLen
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
name|chunk
operator|=
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|null
condition|)
block|{
name|chunk
operator|=
operator|new
name|StripingChunk
argument_list|()
expr_stmt|;
name|s
operator|.
name|chunks
index|[
name|cell
operator|.
name|idxInStripe
index|]
operator|=
name|chunk
expr_stmt|;
block|}
name|chunk
operator|.
name|getChunkBuffer
argument_list|()
operator|.
name|addSlice
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|done
operator|+
name|overlapStart
operator|-
name|cellStart
argument_list|)
argument_list|,
name|overLapLen
argument_list|)
expr_stmt|;
block|}
name|done
operator|+=
name|cell
operator|.
name|size
expr_stmt|;
block|}
block|}
comment|/**    * If a {@link StripingChunk} maps to a byte range beyond an internal block's    * size, the chunk should be treated as zero bytes in decoding.    */
DECL|method|prepareAllZeroChunks (LocatedStripedBlock blockGroup, AlignedStripe[] stripes, int cellSize, int dataBlkNum)
specifier|private
specifier|static
name|void
name|prepareAllZeroChunks
parameter_list|(
name|LocatedStripedBlock
name|blockGroup
parameter_list|,
name|AlignedStripe
index|[]
name|stripes
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|dataBlkNum
parameter_list|)
block|{
for|for
control|(
name|AlignedStripe
name|s
range|:
name|stripes
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|long
name|internalBlkLen
init|=
name|getInternalBlockLength
argument_list|(
name|blockGroup
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|internalBlkLen
operator|<=
name|s
operator|.
name|getOffsetInBlock
argument_list|()
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|s
operator|.
name|chunks
index|[
name|i
index|]
operator|==
literal|null
argument_list|)
expr_stmt|;
name|s
operator|.
name|chunks
index|[
name|i
index|]
operator|=
operator|new
name|StripingChunk
argument_list|(
name|StripingChunk
operator|.
name|ALLZERO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Cell is the unit of encoding used in {@link DFSStripedOutputStream}. This    * size impacts how a logical offset in the file or block group translates    * to physical byte offset in a stored internal block. The StripingCell util    * class facilitates this calculation. Each StripingCell is inclusive with    * its start and end offsets -- e.g., the end logical offset of cell_0_0_0    * should be 1 byte lower than the start logical offset of cell_1_0_1.    *    *  |<------- Striped Block Group -------> |    *    blk_0          blk_1          blk_2    *      |              |              |    *      v              v              v    * +----------+   +----------+   +----------+    * |cell_0_0_0|   |cell_1_0_1|   |cell_2_0_2|    * +----------+   +----------+   +----------+    * |cell_3_1_0|   |cell_4_1_1|   |cell_5_1_2|<- {@link #idxInBlkGroup} = 5    * +----------+   +----------+   +----------+    {@link #idxInInternalBlk} = 1    *                                               {@link #idxInStripe} = 2    * A StripingCell is a special instance of {@link StripingChunk} whose offset    * and size align with the cell used when writing data.    * TODO: consider parity cells    */
annotation|@
name|VisibleForTesting
DECL|class|StripingCell
specifier|public
specifier|static
class|class
name|StripingCell
block|{
DECL|field|ecPolicy
specifier|final
name|ErasureCodingPolicy
name|ecPolicy
decl_stmt|;
comment|/** Logical order in a block group, used when doing I/O to a block group. */
DECL|field|idxInBlkGroup
specifier|final
name|int
name|idxInBlkGroup
decl_stmt|;
DECL|field|idxInInternalBlk
specifier|final
name|int
name|idxInInternalBlk
decl_stmt|;
DECL|field|idxInStripe
specifier|final
name|int
name|idxInStripe
decl_stmt|;
comment|/**      * When a logical byte range is mapped to a set of cells, it might      * partially overlap with the first and last cells. This field and the      * {@link #size} variable represent the start offset and size of the      * overlap.      */
DECL|field|offset
specifier|final
name|int
name|offset
decl_stmt|;
DECL|field|size
specifier|final
name|int
name|size
decl_stmt|;
DECL|method|StripingCell (ErasureCodingPolicy ecPolicy, int cellSize, int idxInBlkGroup, int offset)
name|StripingCell
parameter_list|(
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|int
name|cellSize
parameter_list|,
name|int
name|idxInBlkGroup
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|this
operator|.
name|ecPolicy
operator|=
name|ecPolicy
expr_stmt|;
name|this
operator|.
name|idxInBlkGroup
operator|=
name|idxInBlkGroup
expr_stmt|;
name|this
operator|.
name|idxInInternalBlk
operator|=
name|idxInBlkGroup
operator|/
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
expr_stmt|;
name|this
operator|.
name|idxInStripe
operator|=
name|idxInBlkGroup
operator|-
name|this
operator|.
name|idxInInternalBlk
operator|*
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|cellSize
expr_stmt|;
block|}
block|}
comment|/**    * Given a requested byte range on a striped block group, an AlignedStripe    * represents an inclusive {@link VerticalRange} that is aligned with both    * the byte range and boundaries of all internal blocks. As illustrated in    * the diagram, any given byte range on a block group leads to 1~5    * AlignedStripe's.    *    * |<-------- Striped Block Group -------->|    * blk_0   blk_1   blk_2      blk_3   blk_4    *                 +----+  |  +----+  +----+    *                 |full|  |  |    |  |    |<- AlignedStripe0:    *         +----+  |~~~~|  |  |~~~~|  |~~~~|      1st cell is partial    *         |part|  |    |  |  |    |  |    |<- AlignedStripe1: byte range    * +----+  +----+  +----+  |  |~~~~|  |~~~~|      doesn't start at 1st block    * |full|  |full|  |full|  |  |    |  |    |    * |cell|  |cell|  |cell|  |  |    |  |    |<- AlignedStripe2 (full stripe)    * |    |  |    |  |    |  |  |    |  |    |    * +----+  +----+  +----+  |  |~~~~|  |~~~~|    * |full|  |part|          |  |    |  |    |<- AlignedStripe3: byte range    * |~~~~|  +----+          |  |~~~~|  |~~~~|      doesn't end at last block    * |    |                  |  |    |  |    |<- AlignedStripe4:    * +----+                  |  +----+  +----+      last cell is partial    *                         |    *<---- data blocks ----> |<--- parity --->    *    * An AlignedStripe is the basic unit of reading from a striped block group,    * because within the AlignedStripe, all internal blocks can be processed in    * a uniform manner.    *    * The coverage of an AlignedStripe on an internal block is represented as a    * {@link StripingChunk}.    *    * To simplify the logic of reading a logical byte range from a block group,    * a StripingChunk is either completely in the requested byte range or    * completely outside the requested byte range.    */
DECL|class|AlignedStripe
specifier|public
specifier|static
class|class
name|AlignedStripe
block|{
DECL|field|range
specifier|public
name|VerticalRange
name|range
decl_stmt|;
comment|/** status of each chunk in the stripe. */
DECL|field|chunks
specifier|public
specifier|final
name|StripingChunk
index|[]
name|chunks
decl_stmt|;
DECL|field|fetchedChunksNum
specifier|public
name|int
name|fetchedChunksNum
init|=
literal|0
decl_stmt|;
DECL|field|missingChunksNum
specifier|public
name|int
name|missingChunksNum
init|=
literal|0
decl_stmt|;
DECL|method|AlignedStripe (long offsetInBlock, long length, int width)
specifier|public
name|AlignedStripe
parameter_list|(
name|long
name|offsetInBlock
parameter_list|,
name|long
name|length
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offsetInBlock
operator|>=
literal|0
operator|&&
name|length
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|range
operator|=
operator|new
name|VerticalRange
argument_list|(
name|offsetInBlock
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|chunks
operator|=
operator|new
name|StripingChunk
index|[
name|width
index|]
expr_stmt|;
block|}
DECL|method|include (long pos)
specifier|public
name|boolean
name|include
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
return|return
name|range
operator|.
name|include
argument_list|(
name|pos
argument_list|)
return|;
block|}
DECL|method|getOffsetInBlock ()
specifier|public
name|long
name|getOffsetInBlock
parameter_list|()
block|{
return|return
name|range
operator|.
name|offsetInBlock
return|;
block|}
DECL|method|getSpanInBlock ()
specifier|public
name|long
name|getSpanInBlock
parameter_list|()
block|{
return|return
name|range
operator|.
name|spanInBlock
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Offset="
operator|+
name|range
operator|.
name|offsetInBlock
operator|+
literal|", length="
operator|+
name|range
operator|.
name|spanInBlock
operator|+
literal|", fetchedChunksNum="
operator|+
name|fetchedChunksNum
operator|+
literal|", missingChunksNum="
operator|+
name|missingChunksNum
return|;
block|}
block|}
comment|/**    * A simple utility class representing an arbitrary vertical inclusive range    * starting at {@link #offsetInBlock} and lasting for {@link #spanInBlock}    * bytes in an internal block. Note that VerticalRange doesn't necessarily    * align with {@link StripingCell}.    *    * |<- Striped Block Group ->|    *  blk_0    *    |    *    v    * +-----+    * |~~~~~|<-- {@link #offsetInBlock}    * |     |  ^    * |     |  |    * |     |  | {@link #spanInBlock}    * |     |  v    * |~~~~~| ---    * |     |    * +-----+    */
DECL|class|VerticalRange
specifier|public
specifier|static
class|class
name|VerticalRange
block|{
comment|/** start offset in the block group (inclusive). */
DECL|field|offsetInBlock
specifier|public
name|long
name|offsetInBlock
decl_stmt|;
comment|/** length of the stripe range. */
DECL|field|spanInBlock
specifier|public
name|long
name|spanInBlock
decl_stmt|;
DECL|method|VerticalRange (long offsetInBlock, long length)
specifier|public
name|VerticalRange
parameter_list|(
name|long
name|offsetInBlock
parameter_list|,
name|long
name|length
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offsetInBlock
operator|>=
literal|0
operator|&&
name|length
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|offsetInBlock
operator|=
name|offsetInBlock
expr_stmt|;
name|this
operator|.
name|spanInBlock
operator|=
name|length
expr_stmt|;
block|}
comment|/** whether a position is in the range. */
DECL|method|include (long pos)
specifier|public
name|boolean
name|include
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
return|return
name|pos
operator|>=
name|offsetInBlock
operator|&&
name|pos
operator|<
name|offsetInBlock
operator|+
name|spanInBlock
return|;
block|}
block|}
comment|/**    * Indicates the coverage of an {@link AlignedStripe} on an internal block,    * and the state of the chunk in the context of the read request.    *    * |<---------------- Striped Block Group --------------->|    *   blk_0        blk_1        blk_2          blk_3   blk_4    *                           +---------+  |  +----+  +----+    *     null         null     |REQUESTED|  |  |null|  |null|<- AlignedStripe0    *              +---------+  |---------|  |  |----|  |----|    *     null     |REQUESTED|  |REQUESTED|  |  |null|  |null|<- AlignedStripe1    * +---------+  +---------+  +---------+  |  +----+  +----+    * |REQUESTED|  |REQUESTED|    ALLZERO    |  |null|  |null|<- AlignedStripe2    * +---------+  +---------+               |  +----+  +----+    *<----------- data blocks ------------> |<--- parity --->    */
DECL|class|StripingChunk
specifier|public
specifier|static
class|class
name|StripingChunk
block|{
comment|/** Chunk has been successfully fetched */
DECL|field|FETCHED
specifier|public
specifier|static
specifier|final
name|int
name|FETCHED
init|=
literal|0x01
decl_stmt|;
comment|/** Chunk has encountered failed when being fetched */
DECL|field|MISSING
specifier|public
specifier|static
specifier|final
name|int
name|MISSING
init|=
literal|0x02
decl_stmt|;
comment|/** Chunk being fetched (fetching task is in-flight) */
DECL|field|PENDING
specifier|public
specifier|static
specifier|final
name|int
name|PENDING
init|=
literal|0x04
decl_stmt|;
comment|/**      * Chunk is requested either by application or for decoding, need to      * schedule read task      */
DECL|field|REQUESTED
specifier|public
specifier|static
specifier|final
name|int
name|REQUESTED
init|=
literal|0X08
decl_stmt|;
comment|/**      * Internal block is short and has no overlap with chunk. Chunk considered      * all-zero bytes in codec calculations.      */
DECL|field|ALLZERO
specifier|public
specifier|static
specifier|final
name|int
name|ALLZERO
init|=
literal|0X0f
decl_stmt|;
comment|/**      * If a chunk is completely in requested range, the state transition is:      * REQUESTED (when AlignedStripe created) -> PENDING -> {FETCHED | MISSING}      * If a chunk is completely outside requested range (including parity      * chunks), state transition is:      * null (AlignedStripe created) -> REQUESTED (upon failure) -> PENDING ...      */
DECL|field|state
specifier|public
name|int
name|state
init|=
name|REQUESTED
decl_stmt|;
DECL|field|chunkBuffer
specifier|private
specifier|final
name|ChunkByteBuffer
name|chunkBuffer
decl_stmt|;
DECL|field|byteBuffer
specifier|private
specifier|final
name|ByteBuffer
name|byteBuffer
decl_stmt|;
DECL|method|StripingChunk ()
specifier|public
name|StripingChunk
parameter_list|()
block|{
name|this
operator|.
name|chunkBuffer
operator|=
operator|new
name|ChunkByteBuffer
argument_list|()
expr_stmt|;
name|byteBuffer
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|StripingChunk (ByteBuffer buf)
specifier|public
name|StripingChunk
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
block|{
name|this
operator|.
name|chunkBuffer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|byteBuffer
operator|=
name|buf
expr_stmt|;
block|}
DECL|method|StripingChunk (int state)
specifier|public
name|StripingChunk
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|this
operator|.
name|chunkBuffer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|byteBuffer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
DECL|method|useByteBuffer ()
specifier|public
name|boolean
name|useByteBuffer
parameter_list|()
block|{
return|return
name|byteBuffer
operator|!=
literal|null
return|;
block|}
DECL|method|useChunkBuffer ()
specifier|public
name|boolean
name|useChunkBuffer
parameter_list|()
block|{
return|return
name|chunkBuffer
operator|!=
literal|null
return|;
block|}
DECL|method|getByteBuffer ()
specifier|public
name|ByteBuffer
name|getByteBuffer
parameter_list|()
block|{
assert|assert
name|byteBuffer
operator|!=
literal|null
assert|;
return|return
name|byteBuffer
return|;
block|}
DECL|method|getChunkBuffer ()
specifier|public
name|ChunkByteBuffer
name|getChunkBuffer
parameter_list|()
block|{
assert|assert
name|chunkBuffer
operator|!=
literal|null
assert|;
return|return
name|chunkBuffer
return|;
block|}
block|}
comment|/**    * A utility to manage ByteBuffer slices for a reader.    */
DECL|class|ChunkByteBuffer
specifier|public
specifier|static
class|class
name|ChunkByteBuffer
block|{
DECL|field|slices
specifier|private
specifier|final
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|slices
decl_stmt|;
DECL|method|ChunkByteBuffer ()
name|ChunkByteBuffer
parameter_list|()
block|{
name|this
operator|.
name|slices
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|addSlice (ByteBuffer buffer, int offset, int len)
specifier|public
name|void
name|addSlice
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|ByteBuffer
name|tmp
init|=
name|buffer
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|tmp
operator|.
name|position
argument_list|(
name|buffer
operator|.
name|position
argument_list|()
operator|+
name|offset
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|limit
argument_list|(
name|buffer
operator|.
name|position
argument_list|()
operator|+
name|offset
operator|+
name|len
argument_list|)
expr_stmt|;
name|slices
operator|.
name|add
argument_list|(
name|tmp
operator|.
name|slice
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getSlice (int i)
specifier|public
name|ByteBuffer
name|getSlice
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|slices
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
DECL|method|getSlices ()
specifier|public
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|getSlices
parameter_list|()
block|{
return|return
name|slices
return|;
block|}
comment|/**      *  Note: target will be ready-to-read state after the call.      */
DECL|method|copyTo (ByteBuffer target)
specifier|public
name|void
name|copyTo
parameter_list|(
name|ByteBuffer
name|target
parameter_list|)
block|{
for|for
control|(
name|ByteBuffer
name|slice
range|:
name|slices
control|)
block|{
name|slice
operator|.
name|flip
argument_list|()
expr_stmt|;
name|target
operator|.
name|put
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
name|target
operator|.
name|flip
argument_list|()
expr_stmt|;
block|}
DECL|method|copyFrom (ByteBuffer src)
specifier|public
name|void
name|copyFrom
parameter_list|(
name|ByteBuffer
name|src
parameter_list|)
block|{
name|ByteBuffer
name|tmp
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|ByteBuffer
name|slice
range|:
name|slices
control|)
block|{
name|len
operator|=
name|slice
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|src
operator|.
name|duplicate
argument_list|()
expr_stmt|;
name|tmp
operator|.
name|limit
argument_list|(
name|tmp
operator|.
name|position
argument_list|()
operator|+
name|len
argument_list|)
expr_stmt|;
name|slice
operator|.
name|put
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|src
operator|.
name|position
argument_list|(
name|src
operator|.
name|position
argument_list|()
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * This class represents result from a striped read request.    * If the task was successful or the internal computation failed,    * an index is also returned.    */
DECL|class|StripingChunkReadResult
specifier|public
specifier|static
class|class
name|StripingChunkReadResult
block|{
DECL|field|SUCCESSFUL
specifier|public
specifier|static
specifier|final
name|int
name|SUCCESSFUL
init|=
literal|0x01
decl_stmt|;
DECL|field|FAILED
specifier|public
specifier|static
specifier|final
name|int
name|FAILED
init|=
literal|0x02
decl_stmt|;
DECL|field|TIMEOUT
specifier|public
specifier|static
specifier|final
name|int
name|TIMEOUT
init|=
literal|0x04
decl_stmt|;
DECL|field|CANCELLED
specifier|public
specifier|static
specifier|final
name|int
name|CANCELLED
init|=
literal|0x08
decl_stmt|;
DECL|field|index
specifier|public
specifier|final
name|int
name|index
decl_stmt|;
DECL|field|state
specifier|public
specifier|final
name|int
name|state
decl_stmt|;
DECL|method|StripingChunkReadResult (int state)
specifier|public
name|StripingChunkReadResult
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|state
operator|==
name|TIMEOUT
argument_list|,
literal|"Only timeout result should return negative index."
argument_list|)
expr_stmt|;
name|this
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
DECL|method|StripingChunkReadResult (int index, int state)
specifier|public
name|StripingChunkReadResult
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|state
operator|!=
name|TIMEOUT
argument_list|,
literal|"Timeout result should return negative index."
argument_list|)
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"(index="
operator|+
name|index
operator|+
literal|", state ="
operator|+
name|state
operator|+
literal|")"
return|;
block|}
block|}
comment|/** Used to indicate the buffered data's range in the block group. */
DECL|class|StripeRange
specifier|public
specifier|static
class|class
name|StripeRange
block|{
comment|/** start offset in the block group (inclusive). */
DECL|field|offsetInBlock
specifier|final
name|long
name|offsetInBlock
decl_stmt|;
comment|/** length of the stripe range. */
DECL|field|length
specifier|final
name|long
name|length
decl_stmt|;
DECL|method|StripeRange (long offsetInBlock, long length)
specifier|public
name|StripeRange
parameter_list|(
name|long
name|offsetInBlock
parameter_list|,
name|long
name|length
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offsetInBlock
operator|>=
literal|0
operator|&&
name|length
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|offsetInBlock
operator|=
name|offsetInBlock
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
DECL|method|include (long pos)
specifier|public
name|boolean
name|include
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
return|return
name|pos
operator|>=
name|offsetInBlock
operator|&&
name|pos
operator|<
name|offsetInBlock
operator|+
name|length
return|;
block|}
DECL|method|getLength ()
specifier|public
name|long
name|getLength
parameter_list|()
block|{
return|return
name|length
return|;
block|}
block|}
comment|/**    * Check if the information such as IDs and generation stamps in block-i    * match the block group.    */
DECL|method|checkBlocks (ExtendedBlock blockGroup, int i, ExtendedBlock blocki)
specifier|public
specifier|static
name|void
name|checkBlocks
parameter_list|(
name|ExtendedBlock
name|blockGroup
parameter_list|,
name|int
name|i
parameter_list|,
name|ExtendedBlock
name|blocki
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blocki
operator|.
name|getBlockPoolId
argument_list|()
operator|.
name|equals
argument_list|(
name|blockGroup
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block pool IDs mismatched: block"
operator|+
name|i
operator|+
literal|"="
operator|+
name|blocki
operator|+
literal|", expected block group="
operator|+
name|blockGroup
argument_list|)
throw|;
block|}
if|if
condition|(
name|blocki
operator|.
name|getBlockId
argument_list|()
operator|-
name|i
operator|!=
name|blockGroup
operator|.
name|getBlockId
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block IDs mismatched: block"
operator|+
name|i
operator|+
literal|"="
operator|+
name|blocki
operator|+
literal|", expected block group="
operator|+
name|blockGroup
argument_list|)
throw|;
block|}
if|if
condition|(
name|blocki
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|blockGroup
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Generation stamps mismatched: block"
operator|+
name|i
operator|+
literal|"="
operator|+
name|blocki
operator|+
literal|", expected block group="
operator|+
name|blockGroup
argument_list|)
throw|;
block|}
block|}
DECL|method|getBlockIndex (Block reportedBlock)
specifier|public
specifier|static
name|int
name|getBlockIndex
parameter_list|(
name|Block
name|reportedBlock
parameter_list|)
block|{
name|long
name|BLOCK_GROUP_INDEX_MASK
init|=
literal|15
decl_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|reportedBlock
operator|.
name|getBlockId
argument_list|()
operator|&
name|BLOCK_GROUP_INDEX_MASK
argument_list|)
return|;
block|}
block|}
end_class

end_unit

