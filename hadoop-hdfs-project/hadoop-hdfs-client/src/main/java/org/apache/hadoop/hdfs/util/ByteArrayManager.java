begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.util
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Manage byte array creation and release.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|ByteArrayManager
specifier|public
specifier|abstract
class|class
name|ByteArrayManager
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ByteArrayManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MIN_ARRAY_LENGTH
specifier|static
specifier|final
name|int
name|MIN_ARRAY_LENGTH
init|=
literal|32
decl_stmt|;
DECL|field|EMPTY_BYTE_ARRAY
specifier|static
specifier|final
name|byte
index|[]
name|EMPTY_BYTE_ARRAY
init|=
block|{}
decl_stmt|;
comment|/**    * @return the least power of two greater than or equal to n, i.e. return    *         the least integer x with x>= n and x a power of two.    *    * @throws HadoopIllegalArgumentException    *           if n<= 0.    */
DECL|method|leastPowerOfTwo (final int n)
specifier|public
specifier|static
name|int
name|leastPowerOfTwo
parameter_list|(
specifier|final
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"n = "
operator|+
name|n
operator|+
literal|"<= 0"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|highestOne
init|=
name|Integer
operator|.
name|highestOneBit
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|highestOne
operator|==
name|n
condition|)
block|{
return|return
name|n
return|;
comment|// n is a power of two.
block|}
specifier|final
name|int
name|roundUp
init|=
name|highestOne
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|roundUp
operator|<
literal|0
condition|)
block|{
specifier|final
name|long
name|overflow
init|=
operator|(
operator|(
name|long
operator|)
name|highestOne
operator|)
operator|<<
literal|1
decl_stmt|;
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"Overflow: for n = "
operator|+
name|n
operator|+
literal|", the least power of two (the least"
operator|+
literal|" integer x with x>= n and x a power of two) = "
operator|+
name|overflow
operator|+
literal|"> Integer.MAX_VALUE = "
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
return|return
name|roundUp
return|;
block|}
comment|/**    * A counter with a time stamp so that it is reset automatically    * if there is no increment for the time period.    */
DECL|class|Counter
specifier|static
class|class
name|Counter
block|{
DECL|field|countResetTimePeriodMs
specifier|private
specifier|final
name|long
name|countResetTimePeriodMs
decl_stmt|;
DECL|field|count
specifier|private
name|long
name|count
init|=
literal|0L
decl_stmt|;
DECL|field|timestamp
specifier|private
name|long
name|timestamp
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
DECL|method|Counter (long countResetTimePeriodMs)
name|Counter
parameter_list|(
name|long
name|countResetTimePeriodMs
parameter_list|)
block|{
name|this
operator|.
name|countResetTimePeriodMs
operator|=
name|countResetTimePeriodMs
expr_stmt|;
block|}
DECL|method|getCount ()
specifier|synchronized
name|long
name|getCount
parameter_list|()
block|{
return|return
name|count
return|;
block|}
comment|/**      * Increment the counter, and reset it if there is no increment      * for a certain time period.      *      * @return the new count.      */
DECL|method|increment ()
specifier|synchronized
name|long
name|increment
parameter_list|()
block|{
specifier|final
name|long
name|now
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|timestamp
operator|>
name|countResetTimePeriodMs
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
comment|// reset the counter
block|}
name|timestamp
operator|=
name|now
expr_stmt|;
return|return
operator|++
name|count
return|;
block|}
block|}
comment|/** A map from integers to counters. */
DECL|class|CounterMap
specifier|static
specifier|final
class|class
name|CounterMap
block|{
comment|/** @see ByteArrayManager.Conf#countResetTimePeriodMs */
DECL|field|countResetTimePeriodMs
specifier|private
specifier|final
name|long
name|countResetTimePeriodMs
decl_stmt|;
DECL|field|map
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Counter
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|CounterMap (long countResetTimePeriodMs)
specifier|private
name|CounterMap
parameter_list|(
name|long
name|countResetTimePeriodMs
parameter_list|)
block|{
name|this
operator|.
name|countResetTimePeriodMs
operator|=
name|countResetTimePeriodMs
expr_stmt|;
block|}
comment|/**      * @return the counter for the given key;      *         and create a new counter if it does not exist.      */
DECL|method|get (final Integer key, final boolean createIfNotExist)
specifier|synchronized
name|Counter
name|get
parameter_list|(
specifier|final
name|Integer
name|key
parameter_list|,
specifier|final
name|boolean
name|createIfNotExist
parameter_list|)
block|{
name|Counter
name|count
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|null
operator|&&
name|createIfNotExist
condition|)
block|{
name|count
operator|=
operator|new
name|Counter
argument_list|(
name|countResetTimePeriodMs
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
block|}
comment|/** Manage byte arrays with the same fixed length. */
DECL|class|FixedLengthManager
specifier|static
class|class
name|FixedLengthManager
block|{
DECL|field|byteArrayLength
specifier|private
specifier|final
name|int
name|byteArrayLength
decl_stmt|;
DECL|field|maxAllocated
specifier|private
specifier|final
name|int
name|maxAllocated
decl_stmt|;
DECL|field|freeQueue
specifier|private
specifier|final
name|Queue
argument_list|<
name|byte
index|[]
argument_list|>
name|freeQueue
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|numAllocated
specifier|private
name|int
name|numAllocated
init|=
literal|0
decl_stmt|;
DECL|method|FixedLengthManager (int arrayLength, int maxAllocated)
name|FixedLengthManager
parameter_list|(
name|int
name|arrayLength
parameter_list|,
name|int
name|maxAllocated
parameter_list|)
block|{
name|this
operator|.
name|byteArrayLength
operator|=
name|arrayLength
expr_stmt|;
name|this
operator|.
name|maxAllocated
operator|=
name|maxAllocated
expr_stmt|;
block|}
comment|/**      * Allocate a byte array.      *      * If the number of allocated arrays>= maximum, the current thread is      * blocked until the number of allocated arrays drops to below the maximum.      *      * The byte array allocated by this method must be returned for recycling      * via the {@link FixedLengthManager#recycle(byte[])} method.      */
DECL|method|allocate ()
specifier|synchronized
name|byte
index|[]
name|allocate
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|", {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|numAllocated
operator|>=
name|maxAllocated
condition|;
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|": wait ..."
argument_list|)
expr_stmt|;
name|wait
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"wake up: {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|numAllocated
operator|++
expr_stmt|;
specifier|final
name|byte
index|[]
name|array
init|=
name|freeQueue
operator|.
name|poll
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|", recycled? {}"
argument_list|,
name|array
operator|!=
literal|null
argument_list|)
expr_stmt|;
return|return
name|array
operator|!=
literal|null
condition|?
name|array
else|:
operator|new
name|byte
index|[
name|byteArrayLength
index|]
return|;
block|}
comment|/**      * Recycle the given byte array, which must have the same length as the      * array length managed by this object.      *      * The byte array may or may not be allocated      * by the {@link FixedLengthManager#allocate()} method.      */
DECL|method|recycle (byte[] array)
specifier|synchronized
name|int
name|recycle
parameter_list|(
name|byte
index|[]
name|array
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|array
operator|.
name|length
operator|==
name|byteArrayLength
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|", {}"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
name|numAllocated
operator|--
expr_stmt|;
if|if
condition|(
name|numAllocated
operator|<
literal|0
condition|)
block|{
comment|// it is possible to drop below 0 since
comment|// some byte arrays may not be created by the allocate() method.
name|numAllocated
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|freeQueue
operator|.
name|size
argument_list|()
operator|<
name|maxAllocated
operator|-
name|numAllocated
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|", freeQueue.offer"
argument_list|)
expr_stmt|;
name|freeQueue
operator|.
name|offer
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
return|return
name|freeQueue
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
specifier|synchronized
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|byteArrayLength
operator|+
literal|": "
operator|+
name|numAllocated
operator|+
literal|"/"
operator|+
name|maxAllocated
operator|+
literal|", free="
operator|+
name|freeQueue
operator|.
name|size
argument_list|()
operator|+
literal|"]"
return|;
block|}
block|}
comment|/** A map from array lengths to byte array managers. */
DECL|class|ManagerMap
specifier|static
class|class
name|ManagerMap
block|{
DECL|field|countLimit
specifier|private
specifier|final
name|int
name|countLimit
decl_stmt|;
DECL|field|map
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|FixedLengthManager
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|ManagerMap (int countLimit)
name|ManagerMap
parameter_list|(
name|int
name|countLimit
parameter_list|)
block|{
name|this
operator|.
name|countLimit
operator|=
name|countLimit
expr_stmt|;
block|}
comment|/** @return the manager for the given array length. */
DECL|method|get (final Integer arrayLength, final boolean createIfNotExist)
specifier|synchronized
name|FixedLengthManager
name|get
parameter_list|(
specifier|final
name|Integer
name|arrayLength
parameter_list|,
specifier|final
name|boolean
name|createIfNotExist
parameter_list|)
block|{
name|FixedLengthManager
name|manager
init|=
name|map
operator|.
name|get
argument_list|(
name|arrayLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|manager
operator|==
literal|null
operator|&&
name|createIfNotExist
condition|)
block|{
name|manager
operator|=
operator|new
name|FixedLengthManager
argument_list|(
name|arrayLength
argument_list|,
name|countLimit
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|arrayLength
argument_list|,
name|manager
argument_list|)
expr_stmt|;
block|}
return|return
name|manager
return|;
block|}
block|}
comment|/**    * Configuration for ByteArrayManager.    */
DECL|class|Conf
specifier|public
specifier|static
class|class
name|Conf
block|{
comment|/**      * The count threshold for each array length so that a manager is created      * only after the allocation count exceeds the threshold.      */
DECL|field|countThreshold
specifier|private
specifier|final
name|int
name|countThreshold
decl_stmt|;
comment|/**      * The maximum number of arrays allowed for each array length.      */
DECL|field|countLimit
specifier|private
specifier|final
name|int
name|countLimit
decl_stmt|;
comment|/**      * The time period in milliseconds that the allocation count for each array      * length is reset to zero if there is no increment.      */
DECL|field|countResetTimePeriodMs
specifier|private
specifier|final
name|long
name|countResetTimePeriodMs
decl_stmt|;
DECL|method|Conf (int countThreshold, int countLimit, long countResetTimePeriodMs)
specifier|public
name|Conf
parameter_list|(
name|int
name|countThreshold
parameter_list|,
name|int
name|countLimit
parameter_list|,
name|long
name|countResetTimePeriodMs
parameter_list|)
block|{
name|this
operator|.
name|countThreshold
operator|=
name|countThreshold
expr_stmt|;
name|this
operator|.
name|countLimit
operator|=
name|countLimit
expr_stmt|;
name|this
operator|.
name|countResetTimePeriodMs
operator|=
name|countResetTimePeriodMs
expr_stmt|;
block|}
block|}
comment|/**    * Create a byte array for the given length, where the length of    * the returned array is larger than or equal to the given length.    *    * The current thread may be blocked if some resource is unavailable.    *    * The byte array created by this method must be released    * via the {@link ByteArrayManager#release(byte[])} method.    *    * @return a byte array with length larger than or equal to the given length.    */
DECL|method|newByteArray (int size)
specifier|public
specifier|abstract
name|byte
index|[]
name|newByteArray
parameter_list|(
name|int
name|size
parameter_list|)
throws|throws
name|InterruptedException
function_decl|;
comment|/**    * Release the given byte array.    *    * The byte array may or may not be created    * by the {@link ByteArrayManager#newByteArray(int)} method.    *    * @return the number of free array.    */
DECL|method|release (byte[] array)
specifier|public
specifier|abstract
name|int
name|release
parameter_list|(
name|byte
index|[]
name|array
parameter_list|)
function_decl|;
DECL|method|newInstance (Conf conf)
specifier|public
specifier|static
name|ByteArrayManager
name|newInstance
parameter_list|(
name|Conf
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|==
literal|null
condition|?
operator|new
name|NewByteArrayWithoutLimit
argument_list|()
else|:
operator|new
name|Impl
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/**    * A dummy implementation which simply calls new byte[].    */
DECL|class|NewByteArrayWithoutLimit
specifier|static
class|class
name|NewByteArrayWithoutLimit
extends|extends
name|ByteArrayManager
block|{
annotation|@
name|Override
DECL|method|newByteArray (int size)
specifier|public
name|byte
index|[]
name|newByteArray
parameter_list|(
name|int
name|size
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
operator|new
name|byte
index|[
name|size
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|release (byte[] array)
specifier|public
name|int
name|release
parameter_list|(
name|byte
index|[]
name|array
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/**    * Manage byte array allocation and provide a mechanism for recycling the byte    * array objects.    */
DECL|class|Impl
specifier|static
class|class
name|Impl
extends|extends
name|ByteArrayManager
block|{
DECL|field|conf
specifier|private
specifier|final
name|Conf
name|conf
decl_stmt|;
DECL|field|counters
specifier|private
specifier|final
name|CounterMap
name|counters
decl_stmt|;
DECL|field|managers
specifier|private
specifier|final
name|ManagerMap
name|managers
decl_stmt|;
DECL|method|Impl (Conf conf)
name|Impl
parameter_list|(
name|Conf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|counters
operator|=
operator|new
name|CounterMap
argument_list|(
name|conf
operator|.
name|countResetTimePeriodMs
argument_list|)
expr_stmt|;
name|this
operator|.
name|managers
operator|=
operator|new
name|ManagerMap
argument_list|(
name|conf
operator|.
name|countLimit
argument_list|)
expr_stmt|;
block|}
comment|/**      * Allocate a byte array, where the length of the allocated array      * is the least power of two of the given length      * unless the given length is less than {@link #MIN_ARRAY_LENGTH}.      * In such case, the returned array length is equal to {@link      * #MIN_ARRAY_LENGTH}.      *      * If the number of allocated arrays exceeds the capacity,      * the current thread is blocked until      * the number of allocated arrays drops to below the capacity.      *      * The byte array allocated by this method must be returned for recycling      * via the {@link Impl#release(byte[])} method.      *      * @return a byte array with length larger than or equal to the given      * length.      */
annotation|@
name|Override
DECL|method|newByteArray (final int arrayLength)
specifier|public
name|byte
index|[]
name|newByteArray
parameter_list|(
specifier|final
name|int
name|arrayLength
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|arrayLength
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"allocate({})"
argument_list|,
name|arrayLength
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|array
decl_stmt|;
if|if
condition|(
name|arrayLength
operator|==
literal|0
condition|)
block|{
name|array
operator|=
name|EMPTY_BYTE_ARRAY
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|powerOfTwo
init|=
name|arrayLength
operator|<=
name|MIN_ARRAY_LENGTH
condition|?
name|MIN_ARRAY_LENGTH
else|:
name|leastPowerOfTwo
argument_list|(
name|arrayLength
argument_list|)
decl_stmt|;
specifier|final
name|long
name|count
init|=
name|counters
operator|.
name|get
argument_list|(
name|powerOfTwo
argument_list|,
literal|true
argument_list|)
operator|.
name|increment
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|aboveThreshold
init|=
name|count
operator|>
name|conf
operator|.
name|countThreshold
decl_stmt|;
comment|// create a new manager only if the count is above threshold.
specifier|final
name|FixedLengthManager
name|manager
init|=
name|managers
operator|.
name|get
argument_list|(
name|powerOfTwo
argument_list|,
name|aboveThreshold
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|": count={}, {}Threshold"
argument_list|,
name|count
argument_list|,
name|aboveThreshold
condition|?
literal|"above"
else|:
literal|"below"
argument_list|)
expr_stmt|;
name|array
operator|=
name|manager
operator|!=
literal|null
condition|?
name|manager
operator|.
name|allocate
argument_list|()
else|:
operator|new
name|byte
index|[
name|powerOfTwo
index|]
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|", return byte[{}]"
argument_list|,
name|array
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
comment|/**      * Recycle the given byte array.      *      * The byte array may or may not be allocated      * by the {@link Impl#newByteArray(int)} method.      *      * This is a non-blocking call.      */
annotation|@
name|Override
DECL|method|release (final byte[] array)
specifier|public
name|int
name|release
parameter_list|(
specifier|final
name|byte
index|[]
name|array
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"recycle: array.length={}"
argument_list|,
name|array
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|int
name|freeQueueSize
decl_stmt|;
if|if
condition|(
name|array
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|freeQueueSize
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|FixedLengthManager
name|manager
init|=
name|managers
operator|.
name|get
argument_list|(
name|array
operator|.
name|length
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|freeQueueSize
operator|=
name|manager
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|manager
operator|.
name|recycle
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|", freeQueueSize={}"
argument_list|,
name|freeQueueSize
argument_list|)
expr_stmt|;
return|return
name|freeQueueSize
return|;
block|}
DECL|method|getCounters ()
name|CounterMap
name|getCounters
parameter_list|()
block|{
return|return
name|counters
return|;
block|}
DECL|method|getManagers ()
name|ManagerMap
name|getManagers
parameter_list|()
block|{
return|return
name|managers
return|;
block|}
block|}
block|}
end_class

end_unit

