begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.client.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ReadOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|BlockReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|DfsClientConf
operator|.
name|ShortCircuitConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|metrics
operator|.
name|BlockReaderIoProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|metrics
operator|.
name|BlockReaderLocalMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|BlockMetadataHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|CachingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ClientMmap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ShortCircuitReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DirectBufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Tracer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * BlockReaderLocal enables local short circuited reads. If the DFS client is on  * the same machine as the datanode, then the client can read files directly  * from the local file system rather than going through the datanode for better  * performance.<br>  * {@link BlockReaderLocal} works as follows:  *<ul>  *<li>The client performing short circuit reads must be configured at the  * datanode.</li>  *<li>The client gets the file descriptors for the metadata file and the data  * file for the block using  * {@link org.apache.hadoop.hdfs.server.datanode.DataXceiver#requestShortCircuitFds}.  *</li>  *<li>The client reads the file descriptors.</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockReaderLocal
class|class
name|BlockReaderLocal
implements|implements
name|BlockReader
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BlockReaderLocal
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|bufferPool
specifier|private
specifier|static
specifier|final
name|DirectBufferPool
name|bufferPool
init|=
operator|new
name|DirectBufferPool
argument_list|()
decl_stmt|;
DECL|field|metrics
specifier|private
specifier|static
name|BlockReaderLocalMetrics
name|metrics
decl_stmt|;
DECL|field|metricsInitializationLock
specifier|private
specifier|static
name|Lock
name|metricsInitializationLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|blockReaderIoProvider
specifier|private
specifier|final
name|BlockReaderIoProvider
name|blockReaderIoProvider
decl_stmt|;
DECL|field|TIMER
specifier|private
specifier|static
specifier|final
name|Timer
name|TIMER
init|=
operator|new
name|Timer
argument_list|()
decl_stmt|;
DECL|class|Builder
specifier|public
specifier|static
class|class
name|Builder
block|{
DECL|field|bufferSize
specifier|private
specifier|final
name|int
name|bufferSize
decl_stmt|;
DECL|field|verifyChecksum
specifier|private
name|boolean
name|verifyChecksum
decl_stmt|;
DECL|field|maxReadahead
specifier|private
name|int
name|maxReadahead
decl_stmt|;
DECL|field|filename
specifier|private
name|String
name|filename
decl_stmt|;
DECL|field|replica
specifier|private
name|ShortCircuitReplica
name|replica
decl_stmt|;
DECL|field|dataPos
specifier|private
name|long
name|dataPos
decl_stmt|;
DECL|field|block
specifier|private
name|ExtendedBlock
name|block
decl_stmt|;
DECL|field|storageType
specifier|private
name|StorageType
name|storageType
decl_stmt|;
DECL|field|tracer
specifier|private
name|Tracer
name|tracer
decl_stmt|;
DECL|field|shortCircuitConf
specifier|private
name|ShortCircuitConf
name|shortCircuitConf
decl_stmt|;
DECL|method|Builder (ShortCircuitConf conf)
specifier|public
name|Builder
parameter_list|(
name|ShortCircuitConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|shortCircuitConf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|maxReadahead
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|this
operator|.
name|verifyChecksum
operator|=
operator|!
name|conf
operator|.
name|isSkipShortCircuitChecksums
argument_list|()
expr_stmt|;
name|this
operator|.
name|bufferSize
operator|=
name|conf
operator|.
name|getShortCircuitBufferSize
argument_list|()
expr_stmt|;
block|}
DECL|method|setVerifyChecksum (boolean verifyChecksum)
specifier|public
name|Builder
name|setVerifyChecksum
parameter_list|(
name|boolean
name|verifyChecksum
parameter_list|)
block|{
name|this
operator|.
name|verifyChecksum
operator|=
name|verifyChecksum
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setCachingStrategy (CachingStrategy cachingStrategy)
specifier|public
name|Builder
name|setCachingStrategy
parameter_list|(
name|CachingStrategy
name|cachingStrategy
parameter_list|)
block|{
name|long
name|readahead
init|=
name|cachingStrategy
operator|.
name|getReadahead
argument_list|()
operator|!=
literal|null
condition|?
name|cachingStrategy
operator|.
name|getReadahead
argument_list|()
else|:
name|HdfsClientConfigKeys
operator|.
name|DFS_DATANODE_READAHEAD_BYTES_DEFAULT
decl_stmt|;
name|this
operator|.
name|maxReadahead
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|readahead
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setFilename (String filename)
specifier|public
name|Builder
name|setFilename
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
name|this
operator|.
name|filename
operator|=
name|filename
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setShortCircuitReplica (ShortCircuitReplica replica)
specifier|public
name|Builder
name|setShortCircuitReplica
parameter_list|(
name|ShortCircuitReplica
name|replica
parameter_list|)
block|{
name|this
operator|.
name|replica
operator|=
name|replica
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setStartOffset (long startOffset)
specifier|public
name|Builder
name|setStartOffset
parameter_list|(
name|long
name|startOffset
parameter_list|)
block|{
name|this
operator|.
name|dataPos
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|startOffset
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBlock (ExtendedBlock block)
specifier|public
name|Builder
name|setBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setStorageType (StorageType storageType)
specifier|public
name|Builder
name|setStorageType
parameter_list|(
name|StorageType
name|storageType
parameter_list|)
block|{
name|this
operator|.
name|storageType
operator|=
name|storageType
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setTracer (Tracer tracer)
specifier|public
name|Builder
name|setTracer
parameter_list|(
name|Tracer
name|tracer
parameter_list|)
block|{
name|this
operator|.
name|tracer
operator|=
name|tracer
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|build ()
specifier|public
name|BlockReaderLocal
name|build
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|replica
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlockReaderLocal
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
DECL|field|closed
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
comment|/**    * Pair of streams for this block.    */
DECL|field|replica
specifier|private
specifier|final
name|ShortCircuitReplica
name|replica
decl_stmt|;
comment|/**    * The data FileChannel.    */
DECL|field|dataIn
specifier|private
specifier|final
name|FileChannel
name|dataIn
decl_stmt|;
comment|/**    * The next place we'll read from in the block data FileChannel.    *    * If data is buffered in dataBuf, this offset will be larger than the    * offset of the next byte which a read() operation will give us.    */
DECL|field|dataPos
specifier|private
name|long
name|dataPos
decl_stmt|;
comment|/**    * The Checksum FileChannel.    */
DECL|field|checksumIn
specifier|private
specifier|final
name|FileChannel
name|checksumIn
decl_stmt|;
comment|/**    * Checksum type and size.    */
DECL|field|checksum
specifier|private
specifier|final
name|DataChecksum
name|checksum
decl_stmt|;
comment|/**    * If false, we will always skip the checksum.    */
DECL|field|verifyChecksum
specifier|private
specifier|final
name|boolean
name|verifyChecksum
decl_stmt|;
comment|/**    * Name of the block, for logging purposes.    */
DECL|field|filename
specifier|private
specifier|final
name|String
name|filename
decl_stmt|;
comment|/**    * Block ID and Block Pool ID.    */
DECL|field|block
specifier|private
specifier|final
name|ExtendedBlock
name|block
decl_stmt|;
comment|/**    * Cache of Checksum#bytesPerChecksum.    */
DECL|field|bytesPerChecksum
specifier|private
specifier|final
name|int
name|bytesPerChecksum
decl_stmt|;
comment|/**    * Cache of Checksum#checksumSize.    */
DECL|field|checksumSize
specifier|private
specifier|final
name|int
name|checksumSize
decl_stmt|;
comment|/**    * Maximum number of chunks to allocate.    *    * This is used to allocate dataBuf and checksumBuf, in the event that    * we need them.    */
DECL|field|maxAllocatedChunks
specifier|private
specifier|final
name|int
name|maxAllocatedChunks
decl_stmt|;
comment|/**    * True if zero readahead was requested.    */
DECL|field|zeroReadaheadRequested
specifier|private
specifier|final
name|boolean
name|zeroReadaheadRequested
decl_stmt|;
comment|/**    * Maximum amount of readahead we'll do.  This will always be at least the,    * size of a single chunk, even if {@link #zeroReadaheadRequested} is true.    * The reason is because we need to do a certain amount of buffering in order    * to do checksumming.    *    * This determines how many bytes we'll use out of dataBuf and checksumBuf.    * Why do we allocate buffers, and then (potentially) only use part of them?    * The rationale is that allocating a lot of buffers of different sizes would    * make it very difficult for the DirectBufferPool to re-use buffers.    */
DECL|field|maxReadaheadLength
specifier|private
specifier|final
name|int
name|maxReadaheadLength
decl_stmt|;
comment|/**    * Buffers data starting at the current dataPos and extending on    * for dataBuf.limit().    *    * This may be null if we don't need it.    */
DECL|field|dataBuf
specifier|private
name|ByteBuffer
name|dataBuf
decl_stmt|;
comment|/**    * Buffers checksums starting at the current checksumPos and extending on    * for checksumBuf.limit().    *    * This may be null if we don't need it.    */
DECL|field|checksumBuf
specifier|private
name|ByteBuffer
name|checksumBuf
decl_stmt|;
comment|/**    * StorageType of replica on DataNode.    */
DECL|field|storageType
specifier|private
name|StorageType
name|storageType
decl_stmt|;
comment|/**    * The Tracer to use.    */
DECL|field|tracer
specifier|private
specifier|final
name|Tracer
name|tracer
decl_stmt|;
DECL|method|BlockReaderLocal (Builder builder)
specifier|private
name|BlockReaderLocal
parameter_list|(
name|Builder
name|builder
parameter_list|)
block|{
name|this
operator|.
name|replica
operator|=
name|builder
operator|.
name|replica
expr_stmt|;
name|this
operator|.
name|dataIn
operator|=
name|replica
operator|.
name|getDataStream
argument_list|()
operator|.
name|getChannel
argument_list|()
expr_stmt|;
name|this
operator|.
name|dataPos
operator|=
name|builder
operator|.
name|dataPos
expr_stmt|;
name|this
operator|.
name|checksumIn
operator|=
name|replica
operator|.
name|getMetaStream
argument_list|()
operator|.
name|getChannel
argument_list|()
expr_stmt|;
name|BlockMetadataHeader
name|header
init|=
name|builder
operator|.
name|replica
operator|.
name|getMetaHeader
argument_list|()
decl_stmt|;
name|this
operator|.
name|checksum
operator|=
name|header
operator|.
name|getChecksum
argument_list|()
expr_stmt|;
name|this
operator|.
name|verifyChecksum
operator|=
name|builder
operator|.
name|verifyChecksum
operator|&&
operator|(
name|this
operator|.
name|checksum
operator|.
name|getChecksumType
argument_list|()
operator|.
name|id
operator|!=
name|DataChecksum
operator|.
name|CHECKSUM_NULL
operator|)
expr_stmt|;
name|this
operator|.
name|filename
operator|=
name|builder
operator|.
name|filename
expr_stmt|;
name|this
operator|.
name|block
operator|=
name|builder
operator|.
name|block
expr_stmt|;
name|this
operator|.
name|bytesPerChecksum
operator|=
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
name|this
operator|.
name|checksumSize
operator|=
name|checksum
operator|.
name|getChecksumSize
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxAllocatedChunks
operator|=
operator|(
name|bytesPerChecksum
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|builder
operator|.
name|bufferSize
operator|+
name|bytesPerChecksum
operator|-
literal|1
operator|)
operator|/
name|bytesPerChecksum
operator|)
expr_stmt|;
comment|// Calculate the effective maximum readahead.
comment|// We can't do more readahead than there is space in the buffer.
name|int
name|maxReadaheadChunks
init|=
operator|(
name|bytesPerChecksum
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|bufferSize
argument_list|,
name|builder
operator|.
name|maxReadahead
argument_list|)
operator|+
name|bytesPerChecksum
operator|-
literal|1
operator|)
operator|/
name|bytesPerChecksum
operator|)
decl_stmt|;
if|if
condition|(
name|maxReadaheadChunks
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|zeroReadaheadRequested
operator|=
literal|true
expr_stmt|;
name|maxReadaheadChunks
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|zeroReadaheadRequested
operator|=
literal|false
expr_stmt|;
block|}
name|this
operator|.
name|maxReadaheadLength
operator|=
name|maxReadaheadChunks
operator|*
name|bytesPerChecksum
expr_stmt|;
name|this
operator|.
name|storageType
operator|=
name|builder
operator|.
name|storageType
expr_stmt|;
name|this
operator|.
name|tracer
operator|=
name|builder
operator|.
name|tracer
expr_stmt|;
if|if
condition|(
name|builder
operator|.
name|shortCircuitConf
operator|.
name|isScrMetricsEnabled
argument_list|()
condition|)
block|{
name|metricsInitializationLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|metrics
operator|==
literal|null
condition|)
block|{
name|metrics
operator|=
name|BlockReaderLocalMetrics
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|metricsInitializationLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|this
operator|.
name|blockReaderIoProvider
operator|=
operator|new
name|BlockReaderIoProvider
argument_list|(
name|builder
operator|.
name|shortCircuitConf
argument_list|,
name|metrics
argument_list|,
name|TIMER
argument_list|)
expr_stmt|;
block|}
DECL|method|createDataBufIfNeeded ()
specifier|private
specifier|synchronized
name|void
name|createDataBufIfNeeded
parameter_list|()
block|{
if|if
condition|(
name|dataBuf
operator|==
literal|null
condition|)
block|{
name|dataBuf
operator|=
name|bufferPool
operator|.
name|getBuffer
argument_list|(
name|maxAllocatedChunks
operator|*
name|bytesPerChecksum
argument_list|)
expr_stmt|;
name|dataBuf
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dataBuf
operator|.
name|limit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|freeDataBufIfExists ()
specifier|private
specifier|synchronized
name|void
name|freeDataBufIfExists
parameter_list|()
block|{
if|if
condition|(
name|dataBuf
operator|!=
literal|null
condition|)
block|{
comment|// When disposing of a dataBuf, we have to move our stored file index
comment|// backwards.
name|dataPos
operator|-=
name|dataBuf
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|dataBuf
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bufferPool
operator|.
name|returnBuffer
argument_list|(
name|dataBuf
argument_list|)
expr_stmt|;
name|dataBuf
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|createChecksumBufIfNeeded ()
specifier|private
specifier|synchronized
name|void
name|createChecksumBufIfNeeded
parameter_list|()
block|{
if|if
condition|(
name|checksumBuf
operator|==
literal|null
condition|)
block|{
name|checksumBuf
operator|=
name|bufferPool
operator|.
name|getBuffer
argument_list|(
name|maxAllocatedChunks
operator|*
name|checksumSize
argument_list|)
expr_stmt|;
name|checksumBuf
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|checksumBuf
operator|.
name|limit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|freeChecksumBufIfExists ()
specifier|private
specifier|synchronized
name|void
name|freeChecksumBufIfExists
parameter_list|()
block|{
if|if
condition|(
name|checksumBuf
operator|!=
literal|null
condition|)
block|{
name|checksumBuf
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bufferPool
operator|.
name|returnBuffer
argument_list|(
name|checksumBuf
argument_list|)
expr_stmt|;
name|checksumBuf
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|drainDataBuf (ByteBuffer buf)
specifier|private
specifier|synchronized
name|int
name|drainDataBuf
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
block|{
if|if
condition|(
name|dataBuf
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|oldLimit
init|=
name|dataBuf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|int
name|nRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|dataBuf
operator|.
name|remaining
argument_list|()
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nRead
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|dataBuf
operator|.
name|remaining
argument_list|()
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
try|try
block|{
name|dataBuf
operator|.
name|limit
argument_list|(
name|dataBuf
operator|.
name|position
argument_list|()
operator|+
name|nRead
argument_list|)
expr_stmt|;
name|buf
operator|.
name|put
argument_list|(
name|dataBuf
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dataBuf
operator|.
name|limit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
block|}
return|return
name|nRead
return|;
block|}
comment|/**    * Read from the block file into a buffer.    *    * This function overwrites checksumBuf.  It will increment dataPos.    *    * @param buf   The buffer to read into.  May be dataBuf.    *              The position and limit of this buffer should be set to    *              multiples of the checksum size.    * @param canSkipChecksum  True if we can skip checksumming.    *    * @return      Total bytes read.  0 on EOF.    */
DECL|method|fillBuffer (ByteBuffer buf, boolean canSkipChecksum)
specifier|private
specifier|synchronized
name|int
name|fillBuffer
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|,
name|boolean
name|canSkipChecksum
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|TraceScope
name|ignored
init|=
name|tracer
operator|.
name|newScope
argument_list|(
literal|"BlockReaderLocal#fillBuffer("
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|")"
argument_list|)
init|)
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
name|long
name|startDataPos
init|=
name|dataPos
decl_stmt|;
name|int
name|startBufPos
init|=
name|buf
operator|.
name|position
argument_list|()
decl_stmt|;
while|while
condition|(
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|int
name|nRead
init|=
name|blockReaderIoProvider
operator|.
name|read
argument_list|(
name|dataIn
argument_list|,
name|buf
argument_list|,
name|dataPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|nRead
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|dataPos
operator|+=
name|nRead
expr_stmt|;
name|total
operator|+=
name|nRead
expr_stmt|;
block|}
if|if
condition|(
name|canSkipChecksum
condition|)
block|{
name|freeChecksumBufIfExists
argument_list|()
expr_stmt|;
return|return
name|total
return|;
block|}
if|if
condition|(
name|total
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|position
argument_list|(
name|startBufPos
argument_list|)
expr_stmt|;
name|createChecksumBufIfNeeded
argument_list|()
expr_stmt|;
name|int
name|checksumsNeeded
init|=
operator|(
name|total
operator|+
name|bytesPerChecksum
operator|-
literal|1
operator|)
operator|/
name|bytesPerChecksum
decl_stmt|;
name|checksumBuf
operator|.
name|clear
argument_list|()
expr_stmt|;
name|checksumBuf
operator|.
name|limit
argument_list|(
name|checksumsNeeded
operator|*
name|checksumSize
argument_list|)
expr_stmt|;
name|long
name|checksumPos
init|=
name|BlockMetadataHeader
operator|.
name|getHeaderSize
argument_list|()
operator|+
operator|(
operator|(
name|startDataPos
operator|/
name|bytesPerChecksum
operator|)
operator|*
name|checksumSize
operator|)
decl_stmt|;
while|while
condition|(
name|checksumBuf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|int
name|nRead
init|=
name|checksumIn
operator|.
name|read
argument_list|(
name|checksumBuf
argument_list|,
name|checksumPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|nRead
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got unexpected checksum file EOF at "
operator|+
name|checksumPos
operator|+
literal|", block file position "
operator|+
name|startDataPos
operator|+
literal|" for block "
operator|+
name|block
operator|+
literal|" of file "
operator|+
name|filename
argument_list|)
throw|;
block|}
name|checksumPos
operator|+=
name|nRead
expr_stmt|;
block|}
name|checksumBuf
operator|.
name|flip
argument_list|()
expr_stmt|;
name|checksum
operator|.
name|verifyChunkedSums
argument_list|(
name|buf
argument_list|,
name|checksumBuf
argument_list|,
name|filename
argument_list|,
name|startDataPos
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|buf
operator|.
name|position
argument_list|(
name|buf
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|total
return|;
block|}
block|}
DECL|method|createNoChecksumContext ()
specifier|private
name|boolean
name|createNoChecksumContext
parameter_list|()
block|{
return|return
operator|!
name|verifyChecksum
operator|||
comment|// Checksums are not stored for replicas on transient storage.  We do
comment|// not anchor, because we do not intend for client activity to block
comment|// eviction from transient storage on the DataNode side.
operator|(
name|storageType
operator|!=
literal|null
operator|&&
name|storageType
operator|.
name|isTransient
argument_list|()
operator|)
operator|||
name|replica
operator|.
name|addNoChecksumAnchor
argument_list|()
return|;
block|}
DECL|method|releaseNoChecksumContext ()
specifier|private
name|void
name|releaseNoChecksumContext
parameter_list|()
block|{
if|if
condition|(
name|verifyChecksum
condition|)
block|{
if|if
condition|(
name|storageType
operator|==
literal|null
operator|||
operator|!
name|storageType
operator|.
name|isTransient
argument_list|()
condition|)
block|{
name|replica
operator|.
name|removeNoChecksumAnchor
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|read (ByteBuffer buf)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|canSkipChecksum
init|=
name|createNoChecksumContext
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|traceFormatStr
init|=
literal|"read(buf.remaining={}, block={}, filename={}, "
operator|+
literal|"canSkipChecksum={})"
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
name|traceFormatStr
operator|+
literal|": starting"
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|block
argument_list|,
name|filename
argument_list|,
name|canSkipChecksum
argument_list|)
expr_stmt|;
name|int
name|nRead
decl_stmt|;
try|try
block|{
if|if
condition|(
name|canSkipChecksum
operator|&&
name|zeroReadaheadRequested
condition|)
block|{
name|nRead
operator|=
name|readWithoutBounceBuffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nRead
operator|=
name|readWithBounceBuffer
argument_list|(
name|buf
argument_list|,
name|canSkipChecksum
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|traceFormatStr
operator|+
literal|": I/O error"
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|block
argument_list|,
name|filename
argument_list|,
name|canSkipChecksum
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
name|traceFormatStr
operator|+
literal|": returning {}"
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|block
argument_list|,
name|filename
argument_list|,
name|canSkipChecksum
argument_list|,
name|nRead
argument_list|)
expr_stmt|;
return|return
name|nRead
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|canSkipChecksum
condition|)
name|releaseNoChecksumContext
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|readWithoutBounceBuffer (ByteBuffer buf)
specifier|private
specifier|synchronized
name|int
name|readWithoutBounceBuffer
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|freeDataBufIfExists
argument_list|()
expr_stmt|;
name|freeChecksumBufIfExists
argument_list|()
expr_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|int
name|nRead
init|=
name|blockReaderIoProvider
operator|.
name|read
argument_list|(
name|dataIn
argument_list|,
name|buf
argument_list|,
name|dataPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|nRead
operator|<=
literal|0
condition|)
break|break;
name|dataPos
operator|+=
name|nRead
expr_stmt|;
name|total
operator|+=
name|nRead
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|==
literal|0
operator|&&
operator|(
name|dataPos
operator|==
name|dataIn
operator|.
name|size
argument_list|()
operator|)
operator|)
condition|?
operator|-
literal|1
else|:
name|total
return|;
block|}
comment|/**    * Fill the data buffer.  If necessary, validate the data against the    * checksums.    *    * We always want the offsets of the data contained in dataBuf to be    * aligned to the chunk boundary.  If we are validating checksums, we    * accomplish this by seeking backwards in the file until we're on a    * chunk boundary.  (This is necessary because we can't checksum a    * partial chunk.)  If we are not validating checksums, we simply only    * fill the latter part of dataBuf.    *    * @param canSkipChecksum  true if we can skip checksumming.    * @return                 true if we hit EOF.    * @throws IOException    */
DECL|method|fillDataBuf (boolean canSkipChecksum)
specifier|private
specifier|synchronized
name|boolean
name|fillDataBuf
parameter_list|(
name|boolean
name|canSkipChecksum
parameter_list|)
throws|throws
name|IOException
block|{
name|createDataBufIfNeeded
argument_list|()
expr_stmt|;
specifier|final
name|int
name|slop
init|=
call|(
name|int
call|)
argument_list|(
name|dataPos
operator|%
name|bytesPerChecksum
argument_list|)
decl_stmt|;
specifier|final
name|long
name|oldDataPos
init|=
name|dataPos
decl_stmt|;
name|dataBuf
operator|.
name|limit
argument_list|(
name|maxReadaheadLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|canSkipChecksum
condition|)
block|{
name|dataBuf
operator|.
name|position
argument_list|(
name|slop
argument_list|)
expr_stmt|;
name|fillBuffer
argument_list|(
name|dataBuf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataPos
operator|-=
name|slop
expr_stmt|;
name|dataBuf
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fillBuffer
argument_list|(
name|dataBuf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|dataBuf
operator|.
name|limit
argument_list|(
name|dataBuf
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
name|dataBuf
operator|.
name|position
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|dataBuf
operator|.
name|position
argument_list|()
argument_list|,
name|slop
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"loaded {} bytes into bounce buffer from offset {} of {}"
argument_list|,
name|dataBuf
operator|.
name|remaining
argument_list|()
argument_list|,
name|oldDataPos
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return
name|dataBuf
operator|.
name|limit
argument_list|()
operator|!=
name|maxReadaheadLength
return|;
block|}
comment|/**    * Read using the bounce buffer.    *    * A 'direct' read actually has three phases. The first drains any    * remaining bytes from the slow read buffer. After this the read is    * guaranteed to be on a checksum chunk boundary. If there are still bytes    * to read, the fast direct path is used for as many remaining bytes as    * possible, up to a multiple of the checksum chunk size. Finally, any    * 'odd' bytes remaining at the end of the read cause another slow read to    * be issued, which involves an extra copy.    *    * Every 'slow' read tries to fill the slow read buffer in one go for    * efficiency's sake. As described above, all non-checksum-chunk-aligned    * reads will be served from the slower read path.    *    * @param buf              The buffer to read into.    * @param canSkipChecksum  True if we can skip checksums.    */
DECL|method|readWithBounceBuffer (ByteBuffer buf, boolean canSkipChecksum)
specifier|private
specifier|synchronized
name|int
name|readWithBounceBuffer
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|,
name|boolean
name|canSkipChecksum
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
name|int
name|bb
init|=
name|drainDataBuf
argument_list|(
name|buf
argument_list|)
decl_stmt|;
comment|// drain bounce buffer if possible
if|if
condition|(
name|bb
operator|>=
literal|0
condition|)
block|{
name|total
operator|+=
name|bb
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
return|return
name|total
return|;
block|}
name|boolean
name|eof
init|=
literal|true
decl_stmt|,
name|done
init|=
literal|false
decl_stmt|;
do|do
block|{
if|if
condition|(
name|buf
operator|.
name|isDirect
argument_list|()
operator|&&
operator|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>=
name|maxReadaheadLength
operator|)
operator|&&
operator|(
operator|(
name|dataPos
operator|%
name|bytesPerChecksum
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|// Fast lane: try to read directly into user-supplied buffer, bypassing
comment|// bounce buffer.
name|int
name|oldLimit
init|=
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|int
name|nRead
decl_stmt|;
try|try
block|{
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|maxReadaheadLength
argument_list|)
expr_stmt|;
name|nRead
operator|=
name|fillBuffer
argument_list|(
name|buf
argument_list|,
name|canSkipChecksum
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|buf
operator|.
name|limit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nRead
operator|<
name|maxReadaheadLength
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|nRead
operator|>
literal|0
condition|)
block|{
name|eof
operator|=
literal|false
expr_stmt|;
block|}
name|total
operator|+=
name|nRead
expr_stmt|;
block|}
else|else
block|{
comment|// Slow lane: refill bounce buffer.
if|if
condition|(
name|fillDataBuf
argument_list|(
name|canSkipChecksum
argument_list|)
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
name|bb
operator|=
name|drainDataBuf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// drain bounce buffer if possible
if|if
condition|(
name|bb
operator|>=
literal|0
condition|)
block|{
name|eof
operator|=
literal|false
expr_stmt|;
name|total
operator|+=
name|bb
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
operator|!
name|done
operator|)
operator|&&
operator|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>
literal|0
operator|)
condition|)
do|;
return|return
operator|(
name|eof
operator|&&
name|total
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|total
return|;
block|}
annotation|@
name|Override
DECL|method|read (byte[] arr, int off, int len)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|byte
index|[]
name|arr
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|canSkipChecksum
init|=
name|createNoChecksumContext
argument_list|()
decl_stmt|;
name|int
name|nRead
decl_stmt|;
try|try
block|{
specifier|final
name|String
name|traceFormatStr
init|=
literal|"read(arr.length={}, off={}, len={}, "
operator|+
literal|"filename={}, block={}, canSkipChecksum={})"
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
name|traceFormatStr
operator|+
literal|": starting"
argument_list|,
name|arr
operator|.
name|length
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|filename
argument_list|,
name|block
argument_list|,
name|canSkipChecksum
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|canSkipChecksum
operator|&&
name|zeroReadaheadRequested
condition|)
block|{
name|nRead
operator|=
name|readWithoutBounceBuffer
argument_list|(
name|arr
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nRead
operator|=
name|readWithBounceBuffer
argument_list|(
name|arr
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|canSkipChecksum
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|traceFormatStr
operator|+
literal|": I/O error"
argument_list|,
name|arr
operator|.
name|length
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|filename
argument_list|,
name|block
argument_list|,
name|canSkipChecksum
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
name|traceFormatStr
operator|+
literal|": returning {}"
argument_list|,
name|arr
operator|.
name|length
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|filename
argument_list|,
name|block
argument_list|,
name|canSkipChecksum
argument_list|,
name|nRead
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|canSkipChecksum
condition|)
name|releaseNoChecksumContext
argument_list|()
expr_stmt|;
block|}
return|return
name|nRead
return|;
block|}
DECL|method|readWithoutBounceBuffer (byte arr[], int off, int len)
specifier|private
specifier|synchronized
name|int
name|readWithoutBounceBuffer
parameter_list|(
name|byte
name|arr
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|freeDataBufIfExists
argument_list|()
expr_stmt|;
name|freeChecksumBufIfExists
argument_list|()
expr_stmt|;
name|int
name|nRead
init|=
name|blockReaderIoProvider
operator|.
name|read
argument_list|(
name|dataIn
argument_list|,
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|arr
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
argument_list|,
name|dataPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|nRead
operator|>
literal|0
condition|)
block|{
name|dataPos
operator|+=
name|nRead
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nRead
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dataPos
operator|==
name|dataIn
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|nRead
return|;
block|}
DECL|method|readWithBounceBuffer (byte arr[], int off, int len, boolean canSkipChecksum)
specifier|private
specifier|synchronized
name|int
name|readWithBounceBuffer
parameter_list|(
name|byte
name|arr
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|boolean
name|canSkipChecksum
parameter_list|)
throws|throws
name|IOException
block|{
name|createDataBufIfNeeded
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dataBuf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|dataBuf
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dataBuf
operator|.
name|limit
argument_list|(
name|maxReadaheadLength
argument_list|)
expr_stmt|;
name|fillDataBuf
argument_list|(
name|canSkipChecksum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dataBuf
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|toRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|dataBuf
operator|.
name|remaining
argument_list|()
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|dataBuf
operator|.
name|get
argument_list|(
name|arr
argument_list|,
name|off
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
return|return
name|toRead
return|;
block|}
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
specifier|synchronized
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|discardedFromBuf
init|=
literal|0
decl_stmt|;
name|long
name|remaining
init|=
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|dataBuf
operator|!=
literal|null
operator|)
operator|&&
name|dataBuf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|discardedFromBuf
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|dataBuf
operator|.
name|remaining
argument_list|()
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dataBuf
operator|.
name|position
argument_list|(
name|dataBuf
operator|.
name|position
argument_list|()
operator|+
name|discardedFromBuf
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|discardedFromBuf
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"skip(n={}, block={}, filename={}): discarded {} bytes from "
operator|+
literal|"dataBuf and advanced dataPos by {}"
argument_list|,
name|n
argument_list|,
name|block
argument_list|,
name|filename
argument_list|,
name|discardedFromBuf
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
name|dataPos
operator|+=
name|remaining
expr_stmt|;
return|return
name|n
return|;
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
name|int
name|available
parameter_list|()
block|{
comment|// We never do network I/O in BlockReaderLocal.
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
return|return;
name|closed
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"close(filename={}, block={})"
argument_list|,
name|filename
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|replica
operator|.
name|unref
argument_list|()
expr_stmt|;
name|freeDataBufIfExists
argument_list|()
expr_stmt|;
name|freeChecksumBufIfExists
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|collectThreadLocalStates
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|readFully (byte[] arr, int off, int len)
specifier|public
specifier|synchronized
name|void
name|readFully
parameter_list|(
name|byte
index|[]
name|arr
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockReaderUtil
operator|.
name|readFully
argument_list|(
name|this
argument_list|,
name|arr
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readAll (byte[] buf, int off, int len)
specifier|public
specifier|synchronized
name|int
name|readAll
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|BlockReaderUtil
operator|.
name|readAll
argument_list|(
name|this
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isShortCircuit ()
specifier|public
name|boolean
name|isShortCircuit
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Get or create a memory map for this replica.    *    * There are two kinds of ClientMmap objects we could fetch here: one that    * will always read pre-checksummed data, and one that may read data that    * hasn't been checksummed.    *    * If we fetch the former, "safe" kind of ClientMmap, we have to increment    * the anchor count on the shared memory slot.  This will tell the DataNode    * not to munlock the block until this ClientMmap is closed.    * If we fetch the latter, we don't bother with anchoring.    *    * @param opts     The options to use, such as SKIP_CHECKSUMS.    *    * @return         null on failure; the ClientMmap otherwise.    */
annotation|@
name|Override
DECL|method|getClientMmap (EnumSet<ReadOption> opts)
specifier|public
name|ClientMmap
name|getClientMmap
parameter_list|(
name|EnumSet
argument_list|<
name|ReadOption
argument_list|>
name|opts
parameter_list|)
block|{
name|boolean
name|anchor
init|=
name|verifyChecksum
operator|&&
operator|!
name|opts
operator|.
name|contains
argument_list|(
name|ReadOption
operator|.
name|SKIP_CHECKSUMS
argument_list|)
decl_stmt|;
if|if
condition|(
name|anchor
condition|)
block|{
if|if
condition|(
operator|!
name|createNoChecksumContext
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"can't get an mmap for {} of {} since SKIP_CHECKSUMS was not "
operator|+
literal|"given, we aren't skipping checksums, and the block is not "
operator|+
literal|"mlocked."
argument_list|,
name|block
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
name|ClientMmap
name|clientMmap
init|=
literal|null
decl_stmt|;
try|try
block|{
name|clientMmap
operator|=
name|replica
operator|.
name|getOrCreateClientMmap
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|(
name|clientMmap
operator|==
literal|null
operator|)
operator|&&
name|anchor
condition|)
block|{
name|releaseNoChecksumContext
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|clientMmap
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getVerifyChecksum ()
name|boolean
name|getVerifyChecksum
parameter_list|()
block|{
return|return
name|this
operator|.
name|verifyChecksum
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getMaxReadaheadLength ()
name|int
name|getMaxReadaheadLength
parameter_list|()
block|{
return|return
name|this
operator|.
name|maxReadaheadLength
return|;
block|}
comment|/**    * Make the replica anchorable.  Normally this can only be done by the    * DataNode.  This method is only for testing.    */
annotation|@
name|VisibleForTesting
DECL|method|forceAnchorable ()
name|void
name|forceAnchorable
parameter_list|()
block|{
name|replica
operator|.
name|getSlot
argument_list|()
operator|.
name|makeAnchorable
argument_list|()
expr_stmt|;
block|}
comment|/**    * Make the replica unanchorable.  Normally this can only be done by the    * DataNode.  This method is only for testing.    */
annotation|@
name|VisibleForTesting
DECL|method|forceUnanchorable ()
name|void
name|forceUnanchorable
parameter_list|()
block|{
name|replica
operator|.
name|getSlot
argument_list|()
operator|.
name|makeUnanchorable
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDataChecksum ()
specifier|public
name|DataChecksum
name|getDataChecksum
parameter_list|()
block|{
return|return
name|checksum
return|;
block|}
annotation|@
name|Override
DECL|method|getNetworkDistance ()
specifier|public
name|int
name|getNetworkDistance
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
end_class

end_unit

