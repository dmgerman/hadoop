begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.protocol
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * Associates a block with the Datanodes that contain its replicas  * and other block metadata (E.g. the file offset associated with this  * block, whether it is corrupt, a location is cached in memory,  * security token, etc).  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|LocatedBlock
specifier|public
class|class
name|LocatedBlock
block|{
comment|/**    * Comparator that ensures that a PROVIDED storage type is greater than any    * other storage type. Any other storage types are considered equal.    */
DECL|class|ProvidedLastComparator
specifier|private
specifier|static
class|class
name|ProvidedLastComparator
implements|implements
name|Comparator
argument_list|<
name|DatanodeInfoWithStorage
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|6441720011443190984L
decl_stmt|;
annotation|@
name|Override
DECL|method|compare (DatanodeInfoWithStorage dns1, DatanodeInfoWithStorage dns2)
specifier|public
name|int
name|compare
parameter_list|(
name|DatanodeInfoWithStorage
name|dns1
parameter_list|,
name|DatanodeInfoWithStorage
name|dns2
parameter_list|)
block|{
if|if
condition|(
name|StorageType
operator|.
name|PROVIDED
operator|.
name|equals
argument_list|(
name|dns1
operator|.
name|getStorageType
argument_list|()
argument_list|)
operator|&&
operator|!
name|StorageType
operator|.
name|PROVIDED
operator|.
name|equals
argument_list|(
name|dns2
operator|.
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|StorageType
operator|.
name|PROVIDED
operator|.
name|equals
argument_list|(
name|dns1
operator|.
name|getStorageType
argument_list|()
argument_list|)
operator|&&
name|StorageType
operator|.
name|PROVIDED
operator|.
name|equals
argument_list|(
name|dns2
operator|.
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// Storage types of dns1 and dns2 are now both provided or not provided;
comment|// thus, are essentially equal for the purpose of this comparator.
return|return
literal|0
return|;
block|}
block|}
DECL|field|b
specifier|private
specifier|final
name|ExtendedBlock
name|b
decl_stmt|;
DECL|field|offset
specifier|private
name|long
name|offset
decl_stmt|;
comment|// offset of the first byte of the block in the file
DECL|field|locs
specifier|private
specifier|final
name|DatanodeInfoWithStorage
index|[]
name|locs
decl_stmt|;
comment|/** Cached storage ID for each replica */
DECL|field|storageIDs
specifier|private
specifier|final
name|String
index|[]
name|storageIDs
decl_stmt|;
comment|/** Cached storage type for each replica, if reported. */
DECL|field|storageTypes
specifier|private
specifier|final
name|StorageType
index|[]
name|storageTypes
decl_stmt|;
comment|// corrupt flag is true if all of the replicas of a block are corrupt.
comment|// else false. If block has few corrupt replicas, they are filtered and
comment|// their locations are not part of this object
DECL|field|corrupt
specifier|private
name|boolean
name|corrupt
decl_stmt|;
DECL|field|blockToken
specifier|private
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
init|=
operator|new
name|Token
argument_list|<>
argument_list|()
decl_stmt|;
comment|// use one instance of the Provided comparator as it uses no state.
DECL|field|providedLastComparator
specifier|private
specifier|static
name|ProvidedLastComparator
name|providedLastComparator
init|=
operator|new
name|ProvidedLastComparator
argument_list|()
decl_stmt|;
comment|/**    * List of cached datanode locations    */
DECL|field|cachedLocs
specifier|private
name|DatanodeInfo
index|[]
name|cachedLocs
decl_stmt|;
comment|// Used when there are no locations
DECL|field|EMPTY_LOCS
specifier|static
specifier|final
name|DatanodeInfoWithStorage
index|[]
name|EMPTY_LOCS
init|=
operator|new
name|DatanodeInfoWithStorage
index|[
literal|0
index|]
decl_stmt|;
DECL|method|LocatedBlock (ExtendedBlock b, DatanodeInfo[] locs)
specifier|public
name|LocatedBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|DatanodeInfo
index|[]
name|locs
parameter_list|)
block|{
comment|// By default, startOffset is unknown(-1) and corrupt is false.
name|this
argument_list|(
name|b
argument_list|,
name|convert
argument_list|(
name|locs
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
name|EMPTY_LOCS
argument_list|)
expr_stmt|;
block|}
DECL|method|LocatedBlock (ExtendedBlock b, DatanodeInfo[] locs, String[] storageIDs, StorageType[] storageTypes)
specifier|public
name|LocatedBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|DatanodeInfo
index|[]
name|locs
parameter_list|,
name|String
index|[]
name|storageIDs
parameter_list|,
name|StorageType
index|[]
name|storageTypes
parameter_list|)
block|{
name|this
argument_list|(
name|b
argument_list|,
name|convert
argument_list|(
name|locs
argument_list|,
name|storageIDs
argument_list|,
name|storageTypes
argument_list|)
argument_list|,
name|storageIDs
argument_list|,
name|storageTypes
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
name|EMPTY_LOCS
argument_list|)
expr_stmt|;
block|}
DECL|method|LocatedBlock (ExtendedBlock b, DatanodeInfo[] locs, String[] storageIDs, StorageType[] storageTypes, long startOffset, boolean corrupt, DatanodeInfo[] cachedLocs)
specifier|public
name|LocatedBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|DatanodeInfo
index|[]
name|locs
parameter_list|,
name|String
index|[]
name|storageIDs
parameter_list|,
name|StorageType
index|[]
name|storageTypes
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|boolean
name|corrupt
parameter_list|,
name|DatanodeInfo
index|[]
name|cachedLocs
parameter_list|)
block|{
name|this
argument_list|(
name|b
argument_list|,
name|convert
argument_list|(
name|locs
argument_list|,
name|storageIDs
argument_list|,
name|storageTypes
argument_list|)
argument_list|,
name|storageIDs
argument_list|,
name|storageTypes
argument_list|,
name|startOffset
argument_list|,
name|corrupt
argument_list|,
literal|null
operator|==
name|cachedLocs
operator|||
literal|0
operator|==
name|cachedLocs
operator|.
name|length
condition|?
name|EMPTY_LOCS
else|:
name|cachedLocs
argument_list|)
expr_stmt|;
block|}
DECL|method|LocatedBlock (ExtendedBlock b, DatanodeInfoWithStorage[] locs, String[] storageIDs, StorageType[] storageTypes, long startOffset, boolean corrupt, DatanodeInfo[] cachedLocs)
specifier|public
name|LocatedBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|DatanodeInfoWithStorage
index|[]
name|locs
parameter_list|,
name|String
index|[]
name|storageIDs
parameter_list|,
name|StorageType
index|[]
name|storageTypes
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|boolean
name|corrupt
parameter_list|,
name|DatanodeInfo
index|[]
name|cachedLocs
parameter_list|)
block|{
name|this
operator|.
name|b
operator|=
name|b
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|startOffset
expr_stmt|;
name|this
operator|.
name|corrupt
operator|=
name|corrupt
expr_stmt|;
name|this
operator|.
name|locs
operator|=
literal|null
operator|==
name|locs
condition|?
name|EMPTY_LOCS
else|:
name|locs
expr_stmt|;
name|this
operator|.
name|storageIDs
operator|=
name|storageIDs
expr_stmt|;
name|this
operator|.
name|storageTypes
operator|=
name|storageTypes
expr_stmt|;
name|this
operator|.
name|cachedLocs
operator|=
literal|null
operator|==
name|cachedLocs
operator|||
literal|0
operator|==
name|cachedLocs
operator|.
name|length
condition|?
name|EMPTY_LOCS
else|:
name|cachedLocs
expr_stmt|;
block|}
DECL|method|convert ( DatanodeInfo[] infos, String[] storageIDs, StorageType[] storageTypes)
specifier|private
specifier|static
name|DatanodeInfoWithStorage
index|[]
name|convert
parameter_list|(
name|DatanodeInfo
index|[]
name|infos
parameter_list|,
name|String
index|[]
name|storageIDs
parameter_list|,
name|StorageType
index|[]
name|storageTypes
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|infos
condition|)
block|{
return|return
name|EMPTY_LOCS
return|;
block|}
name|DatanodeInfoWithStorage
index|[]
name|ret
init|=
operator|new
name|DatanodeInfoWithStorage
index|[
name|infos
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|infos
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
index|[
name|i
index|]
operator|=
operator|new
name|DatanodeInfoWithStorage
argument_list|(
name|infos
index|[
name|i
index|]
argument_list|,
name|storageIDs
operator|!=
literal|null
condition|?
name|storageIDs
index|[
name|i
index|]
else|:
literal|null
argument_list|,
name|storageTypes
operator|!=
literal|null
condition|?
name|storageTypes
index|[
name|i
index|]
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|getBlockToken ()
specifier|public
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|getBlockToken
parameter_list|()
block|{
return|return
name|blockToken
return|;
block|}
DECL|method|setBlockToken (Token<BlockTokenIdentifier> token)
specifier|public
name|void
name|setBlockToken
parameter_list|(
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
name|this
operator|.
name|blockToken
operator|=
name|token
expr_stmt|;
block|}
DECL|method|getBlock ()
specifier|public
name|ExtendedBlock
name|getBlock
parameter_list|()
block|{
return|return
name|b
return|;
block|}
comment|/**    * Returns the locations associated with this block. The returned array is not    * expected to be modified. If it is, caller must immediately invoke    * {@link org.apache.hadoop.hdfs.protocol.LocatedBlock#updateCachedStorageInfo}    * to update the cached Storage ID/Type arrays.    */
DECL|method|getLocations ()
specifier|public
name|DatanodeInfo
index|[]
name|getLocations
parameter_list|()
block|{
return|return
name|locs
return|;
block|}
DECL|method|getStorageTypes ()
specifier|public
name|StorageType
index|[]
name|getStorageTypes
parameter_list|()
block|{
return|return
name|storageTypes
return|;
block|}
DECL|method|getStorageIDs ()
specifier|public
name|String
index|[]
name|getStorageIDs
parameter_list|()
block|{
return|return
name|storageIDs
return|;
block|}
comment|/**    * Updates the cached StorageID and StorageType information. Must be    * called when the locations array is modified.    */
DECL|method|updateCachedStorageInfo ()
specifier|public
name|void
name|updateCachedStorageInfo
parameter_list|()
block|{
if|if
condition|(
name|storageIDs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|storageIDs
index|[
name|i
index|]
operator|=
name|locs
index|[
name|i
index|]
operator|.
name|getStorageID
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|storageTypes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|storageTypes
index|[
name|i
index|]
operator|=
name|locs
index|[
name|i
index|]
operator|.
name|getStorageType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Moves all locations that have {@link StorageType}    * {@code PROVIDED} to the end of the locations array without    * changing the relative ordering of the remaining locations    * Only the first {@code activeLen} locations are considered.    * The caller must immediately invoke {@link    * org.apache.hadoop.hdfs.protocol.LocatedBlock#updateCachedStorageInfo}    * to update the cached Storage ID/Type arrays.    * @param activeLen    */
DECL|method|moveProvidedToEnd (int activeLen)
specifier|public
name|void
name|moveProvidedToEnd
parameter_list|(
name|int
name|activeLen
parameter_list|)
block|{
if|if
condition|(
name|activeLen
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
comment|// as this is a stable sort, for elements that are equal,
comment|// the current order of the elements is maintained
name|Arrays
operator|.
name|sort
argument_list|(
name|locs
argument_list|,
literal|0
argument_list|,
operator|(
name|activeLen
operator|<
name|locs
operator|.
name|length
operator|)
condition|?
name|activeLen
else|:
name|locs
operator|.
name|length
argument_list|,
name|providedLastComparator
argument_list|)
expr_stmt|;
block|}
DECL|method|getStartOffset ()
specifier|public
name|long
name|getStartOffset
parameter_list|()
block|{
return|return
name|offset
return|;
block|}
DECL|method|getBlockSize ()
specifier|public
name|long
name|getBlockSize
parameter_list|()
block|{
return|return
name|b
operator|.
name|getNumBytes
argument_list|()
return|;
block|}
DECL|method|setStartOffset (long value)
specifier|public
name|void
name|setStartOffset
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|offset
operator|=
name|value
expr_stmt|;
block|}
DECL|method|setCorrupt (boolean corrupt)
specifier|public
name|void
name|setCorrupt
parameter_list|(
name|boolean
name|corrupt
parameter_list|)
block|{
name|this
operator|.
name|corrupt
operator|=
name|corrupt
expr_stmt|;
block|}
DECL|method|isCorrupt ()
specifier|public
name|boolean
name|isCorrupt
parameter_list|()
block|{
return|return
name|this
operator|.
name|corrupt
return|;
block|}
comment|/**    * Add a the location of a cached replica of the block.    *    * @param loc of datanode with the cached replica    */
DECL|method|addCachedLoc (DatanodeInfo loc)
specifier|public
name|void
name|addCachedLoc
parameter_list|(
name|DatanodeInfo
name|loc
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|cachedList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|cachedLocs
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedList
operator|.
name|contains
argument_list|(
name|loc
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Try to re-use a DatanodeInfo already in loc
for|for
control|(
name|DatanodeInfoWithStorage
name|di
range|:
name|locs
control|)
block|{
if|if
condition|(
name|loc
operator|.
name|equals
argument_list|(
name|di
argument_list|)
condition|)
block|{
name|cachedList
operator|.
name|add
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|cachedLocs
operator|=
name|cachedList
operator|.
name|toArray
argument_list|(
name|cachedLocs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// Not present in loc, add it and go
name|cachedList
operator|.
name|add
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|cachedLocs
operator|!=
name|EMPTY_LOCS
argument_list|,
literal|"Cached locations should only be added when having a backing"
operator|+
literal|" disk replica!"
argument_list|,
name|loc
argument_list|,
name|locs
operator|.
name|length
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|locs
argument_list|)
argument_list|)
expr_stmt|;
name|cachedLocs
operator|=
name|cachedList
operator|.
name|toArray
argument_list|(
name|cachedLocs
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return Datanodes with a cached block replica    */
DECL|method|getCachedLocations ()
specifier|public
name|DatanodeInfo
index|[]
name|getCachedLocations
parameter_list|()
block|{
return|return
name|cachedLocs
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"{"
operator|+
name|b
operator|+
literal|"; getBlockSize()="
operator|+
name|getBlockSize
argument_list|()
operator|+
literal|"; corrupt="
operator|+
name|corrupt
operator|+
literal|"; offset="
operator|+
name|offset
operator|+
literal|"; locs="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|locs
argument_list|)
operator|+
literal|"}"
return|;
block|}
DECL|method|isStriped ()
specifier|public
name|boolean
name|isStriped
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
DECL|method|getBlockType ()
specifier|public
name|BlockType
name|getBlockType
parameter_list|()
block|{
return|return
name|BlockType
operator|.
name|CONTIGUOUS
return|;
block|}
block|}
end_class

end_unit

