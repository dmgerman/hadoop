begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProviderDelegationTokenExtension
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockStoragePolicySpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CacheFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStreamBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSLinkResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystemLinkResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FsServerDefaults
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FsStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|GlobalStorageStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|GlobalStorageStatistics
operator|.
name|StorageStatisticsProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|ChecksumOpt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|HandleOpt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|QuotaUsage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnsupportedFileSystemException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttrSetFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSOpsCountStatistics
operator|.
name|OpType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|CorruptFileBlockIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|AddErasureCodingPolicyResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CacheDirectiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CacheDirectiveInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CachePoolEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CachePoolInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DirectoryListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|EncryptionZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|ReencryptAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|RollingUpgradeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|SafeModeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsPathHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsLocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|OpenFileEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ZoneReencryptionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RollingUpgradeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotDiffReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshottableDirectoryStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_comment
comment|/****************************************************************  * Implementation of the abstract FileSystem for the DFS system.  * This object is the way end-user code interacts with a Hadoop  * DistributedFileSystem.  *  *****************************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"MapReduce"
block|,
literal|"HBase"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|DistributedFileSystem
specifier|public
class|class
name|DistributedFileSystem
extends|extends
name|FileSystem
block|{
DECL|field|workingDir
specifier|private
name|Path
name|workingDir
decl_stmt|;
DECL|field|uri
specifier|private
name|URI
name|uri
decl_stmt|;
DECL|field|homeDirPrefix
specifier|private
name|String
name|homeDirPrefix
init|=
name|HdfsClientConfigKeys
operator|.
name|DFS_USER_HOME_DIR_PREFIX_DEFAULT
decl_stmt|;
DECL|field|dfs
name|DFSClient
name|dfs
decl_stmt|;
DECL|field|verifyChecksum
specifier|private
name|boolean
name|verifyChecksum
init|=
literal|true
decl_stmt|;
DECL|field|storageStatistics
specifier|private
name|DFSOpsCountStatistics
name|storageStatistics
decl_stmt|;
static|static
block|{
name|HdfsConfiguration
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
DECL|method|DistributedFileSystem ()
specifier|public
name|DistributedFileSystem
parameter_list|()
block|{   }
comment|/**    * Return the protocol scheme for the FileSystem.    *<p/>    *    * @return<code>hdfs</code>    */
annotation|@
name|Override
DECL|method|getScheme ()
specifier|public
name|String
name|getScheme
parameter_list|()
block|{
return|return
name|HdfsConstants
operator|.
name|HDFS_URI_SCHEME
return|;
block|}
annotation|@
name|Override
DECL|method|getUri ()
specifier|public
name|URI
name|getUri
parameter_list|()
block|{
return|return
name|uri
return|;
block|}
annotation|@
name|Override
DECL|method|initialize (URI uri, Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|initialize
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|String
name|host
init|=
name|uri
operator|.
name|getHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incomplete HDFS URI, no host: "
operator|+
name|uri
argument_list|)
throw|;
block|}
name|homeDirPrefix
operator|=
name|conf
operator|.
name|get
argument_list|(
name|HdfsClientConfigKeys
operator|.
name|DFS_USER_HOME_DIR_PREFIX_KEY
argument_list|,
name|HdfsClientConfigKeys
operator|.
name|DFS_USER_HOME_DIR_PREFIX_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|dfs
operator|=
operator|new
name|DFSClient
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|,
name|statistics
argument_list|)
expr_stmt|;
name|this
operator|.
name|uri
operator|=
name|URI
operator|.
name|create
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|uri
operator|.
name|getAuthority
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|workingDir
operator|=
name|getHomeDirectory
argument_list|()
expr_stmt|;
name|storageStatistics
operator|=
operator|(
name|DFSOpsCountStatistics
operator|)
name|GlobalStorageStatistics
operator|.
name|INSTANCE
operator|.
name|put
argument_list|(
name|DFSOpsCountStatistics
operator|.
name|NAME
argument_list|,
operator|new
name|StorageStatisticsProvider
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|StorageStatistics
name|provide
parameter_list|()
block|{
return|return
operator|new
name|DFSOpsCountStatistics
argument_list|()
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getWorkingDirectory ()
specifier|public
name|Path
name|getWorkingDirectory
parameter_list|()
block|{
return|return
name|workingDir
return|;
block|}
annotation|@
name|Override
DECL|method|getDefaultBlockSize ()
specifier|public
name|long
name|getDefaultBlockSize
parameter_list|()
block|{
return|return
name|dfs
operator|.
name|getConf
argument_list|()
operator|.
name|getDefaultBlockSize
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getDefaultReplication ()
specifier|public
name|short
name|getDefaultReplication
parameter_list|()
block|{
return|return
name|dfs
operator|.
name|getConf
argument_list|()
operator|.
name|getDefaultReplication
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|setWorkingDirectory (Path dir)
specifier|public
name|void
name|setWorkingDirectory
parameter_list|(
name|Path
name|dir
parameter_list|)
block|{
name|String
name|result
init|=
name|fixRelativePart
argument_list|(
name|dir
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DFSUtilClient
operator|.
name|isValidName
argument_list|(
name|result
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid DFS directory name "
operator|+
name|result
argument_list|)
throw|;
block|}
name|workingDir
operator|=
name|fixRelativePart
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getHomeDirectory ()
specifier|public
name|Path
name|getHomeDirectory
parameter_list|()
block|{
return|return
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|homeDirPrefix
operator|+
literal|"/"
operator|+
name|dfs
operator|.
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns the hedged read metrics object for this client.    *    * @return object of DFSHedgedReadMetrics    */
DECL|method|getHedgedReadMetrics ()
specifier|public
name|DFSHedgedReadMetrics
name|getHedgedReadMetrics
parameter_list|()
block|{
return|return
name|dfs
operator|.
name|getHedgedReadMetrics
argument_list|()
return|;
block|}
comment|/**    * Checks that the passed URI belongs to this filesystem and returns    * just the path component. Expects a URI with an absolute path.    *    * @param file URI with absolute path    * @return path component of {file}    * @throws IllegalArgumentException if URI does not belong to this DFS    */
DECL|method|getPathName (Path file)
name|String
name|getPathName
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
name|checkPath
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|String
name|result
init|=
name|file
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DFSUtilClient
operator|.
name|isValidName
argument_list|(
name|result
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Pathname "
operator|+
name|result
operator|+
literal|" from "
operator|+
name|file
operator|+
literal|" is not a valid DFS filename."
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|getFileBlockLocations (FileStatus file, long start, long len)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
name|FileStatus
name|file
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|getFileBlockLocations
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
return|;
block|}
comment|/**    * The returned BlockLocation will have different formats for replicated    * and erasure coded file.    * Please refer to    * {@link FileSystem#getFileBlockLocations(FileStatus, long, long)}    * for more details.    */
annotation|@
name|Override
DECL|method|getFileBlockLocations (Path p, final long start, final long len)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
name|Path
name|p
parameter_list|,
specifier|final
name|long
name|start
parameter_list|,
specifier|final
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_FILE_BLOCK_LOCATIONS
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|BlockLocation
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BlockLocation
index|[]
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getBlockLocations
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BlockLocation
index|[]
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getFileBlockLocations
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setVerifyChecksum (boolean verifyChecksum)
specifier|public
name|void
name|setVerifyChecksum
parameter_list|(
name|boolean
name|verifyChecksum
parameter_list|)
block|{
name|this
operator|.
name|verifyChecksum
operator|=
name|verifyChecksum
expr_stmt|;
block|}
comment|/**    * Start the lease recovery of a file    *    * @param f a file    * @return true if the file is already closed    * @throws IOException if an error occurs    */
DECL|method|recoverLease (final Path f)
specifier|public
name|boolean
name|recoverLease
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|recoverLease
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
return|return
name|myDfs
operator|.
name|recoverLease
argument_list|(
name|p
argument_list|)
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot recoverLease through"
operator|+
literal|" a symlink to a non-DistributedFileSystem: "
operator|+
name|f
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|open (Path f, final int bufferSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
name|Path
name|f
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|OPEN
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FSDataInputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FSDataInputStream
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DFSInputStream
name|dfsis
init|=
name|dfs
operator|.
name|open
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|bufferSize
argument_list|,
name|verifyChecksum
argument_list|)
decl_stmt|;
return|return
name|dfs
operator|.
name|createWrappedInputStream
argument_list|(
name|dfsis
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FSDataInputStream
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|open
argument_list|(
name|p
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Opens an FSDataInputStream with the indicated file ID extracted from    * the {@link PathHandle}.    * @param fd Reference to entity in this FileSystem.    * @param bufferSize the size of the buffer to be used.    */
annotation|@
name|Override
DECL|method|open (PathHandle fd, int bufferSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
name|PathHandle
name|fd
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
operator|(
name|fd
operator|instanceof
name|HdfsPathHandle
operator|)
condition|)
block|{
name|fd
operator|=
operator|new
name|HdfsPathHandle
argument_list|(
name|fd
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|HdfsPathHandle
name|id
init|=
operator|(
name|HdfsPathHandle
operator|)
name|fd
decl_stmt|;
return|return
name|open
argument_list|(
name|DFSUtilClient
operator|.
name|makePathFromFileId
argument_list|(
name|id
operator|.
name|getInodeId
argument_list|()
argument_list|)
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
comment|/**    * Create a handle to an HDFS file.    * @param st HdfsFileStatus instance from NameNode    * @param opts Standard handle arguments    * @throws IllegalArgumentException If the FileStatus instance refers to a    * directory, symlink, or another namesystem.    * @throws UnsupportedOperationException If opts are not specified or both    * data and location are not allowed to change.    * @return A handle to the file.    */
annotation|@
name|Override
DECL|method|createPathHandle (FileStatus st, HandleOpt... opts)
specifier|protected
name|PathHandle
name|createPathHandle
parameter_list|(
name|FileStatus
name|st
parameter_list|,
name|HandleOpt
modifier|...
name|opts
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|st
operator|instanceof
name|HdfsFileStatus
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid FileStatus "
operator|+
name|st
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|st
operator|.
name|isDirectory
argument_list|()
operator|||
name|st
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"PathHandle only available for files"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|getUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|.
name|equals
argument_list|(
name|st
operator|.
name|getPath
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Wrong FileSystem: "
operator|+
name|st
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|HandleOpt
operator|.
name|Data
name|data
init|=
name|HandleOpt
operator|.
name|getOpt
argument_list|(
name|HandleOpt
operator|.
name|Data
operator|.
name|class
argument_list|,
name|opts
argument_list|)
operator|.
name|orElse
argument_list|(
name|HandleOpt
operator|.
name|changed
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|HandleOpt
operator|.
name|Location
name|loc
init|=
name|HandleOpt
operator|.
name|getOpt
argument_list|(
name|HandleOpt
operator|.
name|Location
operator|.
name|class
argument_list|,
name|opts
argument_list|)
operator|.
name|orElse
argument_list|(
name|HandleOpt
operator|.
name|moved
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|allowChange
argument_list|()
operator|||
operator|!
name|loc
operator|.
name|allowChange
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported opts "
operator|+
name|Arrays
operator|.
name|stream
argument_list|(
name|opts
argument_list|)
operator|.
name|map
argument_list|(
name|HandleOpt
operator|::
name|toString
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|","
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|HdfsPathHandle
argument_list|(
operator|(
name|HdfsFileStatus
operator|)
name|st
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|append (Path f, final int bufferSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|append
argument_list|(
name|f
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|APPEND
argument_list|)
argument_list|,
name|bufferSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**    * Append to an existing file (optional operation).    *    * @param f the existing file to be appended.    * @param flag Flags for the Append operation. CreateFlag.APPEND is mandatory    *          to be present.    * @param bufferSize the size of the buffer to be used.    * @param progress for reporting progress if it is not null.    * @return Returns instance of {@link FSDataOutputStream}    * @throws IOException    */
DECL|method|append (Path f, final EnumSet<CreateFlag> flag, final int bufferSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|APPEND
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FSDataOutputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FSDataOutputStream
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|append
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|bufferSize
argument_list|,
name|flag
argument_list|,
name|progress
argument_list|,
name|statistics
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FSDataOutputStream
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|append
argument_list|(
name|p
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Append to an existing file (optional operation).    *    * @param f the existing file to be appended.    * @param flag Flags for the Append operation. CreateFlag.APPEND is mandatory    *          to be present.    * @param bufferSize the size of the buffer to be used.    * @param progress for reporting progress if it is not null.    * @param favoredNodes Favored nodes for new blocks    * @return Returns instance of {@link FSDataOutputStream}    * @throws IOException    */
DECL|method|append (Path f, final EnumSet<CreateFlag> flag, final int bufferSize, final Progressable progress, final InetSocketAddress[] favoredNodes)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|,
specifier|final
name|InetSocketAddress
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|APPEND
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FSDataOutputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FSDataOutputStream
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|append
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|bufferSize
argument_list|,
name|flag
argument_list|,
name|progress
argument_list|,
name|statistics
argument_list|,
name|favoredNodes
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FSDataOutputStream
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|append
argument_list|(
name|p
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|create (Path f, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|create
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
name|overwrite
condition|?
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|,
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
else|:
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Same as    * {@link #create(Path, FsPermission, boolean, int, short, long,    * Progressable)} with the addition of favoredNodes that is a hint to    * where the namenode should place the file blocks.    * The favored nodes hint is not persisted in HDFS. Hence it may be honored    * at the creation time only. And with favored nodes, blocks will be pinned    * on the datanodes to prevent balancing move the block. HDFS could move the    * blocks during replication, to move the blocks from favored nodes. A value    * of null means no favored nodes for this create    */
DECL|method|create (final Path f, final FsPermission permission, final boolean overwrite, final int bufferSize, final short replication, final long blockSize, final Progressable progress, final InetSocketAddress[] favoredNodes)
specifier|public
name|HdfsDataOutputStream
name|create
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|boolean
name|overwrite
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|,
specifier|final
name|InetSocketAddress
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|CREATE
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|HdfsDataOutputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|HdfsDataOutputStream
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DFSOutputStream
name|out
init|=
name|dfs
operator|.
name|create
argument_list|(
name|getPathName
argument_list|(
name|f
argument_list|)
argument_list|,
name|permission
argument_list|,
name|overwrite
condition|?
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|,
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
else|:
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
argument_list|,
literal|true
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|bufferSize
argument_list|,
literal|null
argument_list|,
name|favoredNodes
argument_list|)
decl_stmt|;
return|return
name|dfs
operator|.
name|createWrappedOutputStream
argument_list|(
name|out
argument_list|,
name|statistics
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HdfsDataOutputStream
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
return|return
name|myDfs
operator|.
name|create
argument_list|(
name|p
argument_list|,
name|permission
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|favoredNodes
argument_list|)
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot create with"
operator|+
literal|" favoredNodes through a symlink to a non-DistributedFileSystem: "
operator|+
name|f
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|create (final Path f, final FsPermission permission, final EnumSet<CreateFlag> cflags, final int bufferSize, final short replication, final long blockSize, final Progressable progress, final ChecksumOpt checksumOpt)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|cflags
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|,
specifier|final
name|ChecksumOpt
name|checksumOpt
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|CREATE
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FSDataOutputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FSDataOutputStream
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DFSOutputStream
name|dfsos
init|=
name|dfs
operator|.
name|create
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|permission
argument_list|,
name|cflags
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|bufferSize
argument_list|,
name|checksumOpt
argument_list|)
decl_stmt|;
return|return
name|dfs
operator|.
name|createWrappedOutputStream
argument_list|(
name|dfsos
argument_list|,
name|statistics
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FSDataOutputStream
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|create
argument_list|(
name|p
argument_list|,
name|permission
argument_list|,
name|cflags
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|checksumOpt
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Same as    * {@link #create(Path, FsPermission, EnumSet<CreateFlag>, int, short, long,    * Progressable, ChecksumOpt)} with a few additions. First, addition of    * favoredNodes that is a hint to where the namenode should place the file    * blocks. The favored nodes hint is not persisted in HDFS. Hence it may be    * honored at the creation time only. And with favored nodes, blocks will be    * pinned on the datanodes to prevent balancing move the block. HDFS could    * move the blocks during replication, to move the blocks from favored nodes.    * A value of null means no favored nodes for this create.    * The second addition is ecPolicyName. A non-null ecPolicyName specifies an    * explicit erasure coding policy for this file, overriding the inherited    * policy. A null ecPolicyName means the file will inherit its EC policy or    * replication policy from its ancestor (the default).    * ecPolicyName and SHOULD_REPLICATE CreateFlag are mutually exclusive. It's    * invalid to set both SHOULD_REPLICATE and a non-null ecPolicyName.    *    */
DECL|method|create (final Path f, final FsPermission permission, final EnumSet<CreateFlag> flag, final int bufferSize, final short replication, final long blockSize, final Progressable progress, final ChecksumOpt checksumOpt, final InetSocketAddress[] favoredNodes, final String ecPolicyName)
specifier|private
name|HdfsDataOutputStream
name|create
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|,
specifier|final
name|ChecksumOpt
name|checksumOpt
parameter_list|,
specifier|final
name|InetSocketAddress
index|[]
name|favoredNodes
parameter_list|,
specifier|final
name|String
name|ecPolicyName
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|CREATE
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|HdfsDataOutputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|HdfsDataOutputStream
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DFSOutputStream
name|out
init|=
name|dfs
operator|.
name|create
argument_list|(
name|getPathName
argument_list|(
name|f
argument_list|)
argument_list|,
name|permission
argument_list|,
name|flag
argument_list|,
literal|true
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|bufferSize
argument_list|,
name|checksumOpt
argument_list|,
name|favoredNodes
argument_list|,
name|ecPolicyName
argument_list|)
decl_stmt|;
return|return
name|dfs
operator|.
name|createWrappedOutputStream
argument_list|(
name|out
argument_list|,
name|statistics
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HdfsDataOutputStream
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
return|return
name|myDfs
operator|.
name|create
argument_list|(
name|p
argument_list|,
name|permission
argument_list|,
name|flag
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|checksumOpt
argument_list|,
name|favoredNodes
argument_list|,
name|ecPolicyName
argument_list|)
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot create with"
operator|+
literal|" favoredNodes through a symlink to a non-DistributedFileSystem: "
operator|+
name|f
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|primitiveCreate (Path f, FsPermission absolutePermission, EnumSet<CreateFlag> flag, int bufferSize, short replication, long blockSize, Progressable progress, ChecksumOpt checksumOpt)
specifier|protected
name|HdfsDataOutputStream
name|primitiveCreate
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|absolutePermission
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|ChecksumOpt
name|checksumOpt
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|PRIMITIVE_CREATE
argument_list|)
expr_stmt|;
specifier|final
name|DFSOutputStream
name|dfsos
init|=
name|dfs
operator|.
name|primitiveCreate
argument_list|(
name|getPathName
argument_list|(
name|fixRelativePart
argument_list|(
name|f
argument_list|)
argument_list|)
argument_list|,
name|absolutePermission
argument_list|,
name|flag
argument_list|,
literal|true
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|bufferSize
argument_list|,
name|checksumOpt
argument_list|)
decl_stmt|;
return|return
name|dfs
operator|.
name|createWrappedOutputStream
argument_list|(
name|dfsos
argument_list|,
name|statistics
argument_list|)
return|;
block|}
comment|/**    * Similar to {@link #create(Path, FsPermission, EnumSet, int, short, long,    * Progressable, ChecksumOpt, InetSocketAddress[], String)}, it provides a    * HDFS-specific version of {@link #createNonRecursive(Path, FsPermission,    * EnumSet, int, short, long, Progressable)} with a few additions.    *    * @see #create(Path, FsPermission, EnumSet, int, short, long, Progressable,    * ChecksumOpt, InetSocketAddress[], String) for the descriptions of    * additional parameters, i.e., favoredNodes and ecPolicyName.    */
DECL|method|createNonRecursive (final Path f, final FsPermission permission, final EnumSet<CreateFlag> flag, final int bufferSize, final short replication, final long blockSize, final Progressable progress, final ChecksumOpt checksumOpt, final InetSocketAddress[] favoredNodes, final String ecPolicyName)
specifier|private
name|HdfsDataOutputStream
name|createNonRecursive
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|,
specifier|final
name|ChecksumOpt
name|checksumOpt
parameter_list|,
specifier|final
name|InetSocketAddress
index|[]
name|favoredNodes
parameter_list|,
specifier|final
name|String
name|ecPolicyName
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|CREATE
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|HdfsDataOutputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|HdfsDataOutputStream
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DFSOutputStream
name|out
init|=
name|dfs
operator|.
name|create
argument_list|(
name|getPathName
argument_list|(
name|f
argument_list|)
argument_list|,
name|permission
argument_list|,
name|flag
argument_list|,
literal|false
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|bufferSize
argument_list|,
name|checksumOpt
argument_list|,
name|favoredNodes
argument_list|,
name|ecPolicyName
argument_list|)
decl_stmt|;
return|return
name|dfs
operator|.
name|createWrappedOutputStream
argument_list|(
name|out
argument_list|,
name|statistics
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HdfsDataOutputStream
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
return|return
name|myDfs
operator|.
name|createNonRecursive
argument_list|(
name|p
argument_list|,
name|permission
argument_list|,
name|flag
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|checksumOpt
argument_list|,
name|favoredNodes
argument_list|,
name|ecPolicyName
argument_list|)
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot create with"
operator|+
literal|" favoredNodes through a symlink to a non-DistributedFileSystem: "
operator|+
name|f
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Same as create(), except fails if parent directory doesn't already exist.    */
annotation|@
name|Override
DECL|method|createNonRecursive (final Path f, final FsPermission permission, final EnumSet<CreateFlag> flag, final int bufferSize, final short replication, final long blockSize, final Progressable progress)
specifier|public
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|long
name|blockSize
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|CREATE_NON_RECURSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
condition|)
block|{
name|flag
operator|.
name|add
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
expr_stmt|;
block|}
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FSDataOutputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FSDataOutputStream
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DFSOutputStream
name|dfsos
init|=
name|dfs
operator|.
name|create
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|permission
argument_list|,
name|flag
argument_list|,
literal|false
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|bufferSize
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|dfs
operator|.
name|createWrappedOutputStream
argument_list|(
name|dfsos
argument_list|,
name|statistics
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FSDataOutputStream
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|createNonRecursive
argument_list|(
name|p
argument_list|,
name|permission
argument_list|,
name|flag
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setReplication (Path src, final short replication)
specifier|public
name|boolean
name|setReplication
parameter_list|(
name|Path
name|src
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|SET_REPLICATION
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|setReplication
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|replication
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|setReplication
argument_list|(
name|p
argument_list|,
name|replication
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Set the source path to the specified storage policy.    *    * @param src The source path referring to either a directory or a file.    * @param policyName The name of the storage policy.    */
annotation|@
name|Override
DECL|method|setStoragePolicy (final Path src, final String policyName)
specifier|public
name|void
name|setStoragePolicy
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|String
name|policyName
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|SET_STORAGE_POLICY
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setStoragePolicy
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|policyName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setStoragePolicy
argument_list|(
name|p
argument_list|,
name|policyName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|unsetStoragePolicy (final Path src)
specifier|public
name|void
name|unsetStoragePolicy
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|UNSET_STORAGE_POLICY
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|unsetStoragePolicy
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
operator|(
operator|(
name|DistributedFileSystem
operator|)
name|fs
operator|)
operator|.
name|unsetStoragePolicy
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot perform unsetStoragePolicy on a "
operator|+
literal|"non-DistributedFileSystem: "
operator|+
name|src
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getStoragePolicy (Path path)
specifier|public
name|BlockStoragePolicySpi
name|getStoragePolicy
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_STORAGE_POLICY
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|BlockStoragePolicySpi
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BlockStoragePolicySpi
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getClient
argument_list|()
operator|.
name|getStoragePolicy
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BlockStoragePolicySpi
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getStoragePolicy
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getAllStoragePolicies ()
specifier|public
name|Collection
argument_list|<
name|BlockStoragePolicy
argument_list|>
name|getAllStoragePolicies
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|dfs
operator|.
name|getStoragePolicies
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns number of bytes within blocks with future generation stamp. These    * are bytes that will be potentially deleted if we forceExit from safe mode.    *    * @return number of bytes.    */
DECL|method|getBytesWithFutureGenerationStamps ()
specifier|public
name|long
name|getBytesWithFutureGenerationStamps
parameter_list|()
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_BYTES_WITH_FUTURE_GS
argument_list|)
expr_stmt|;
return|return
name|dfs
operator|.
name|getBytesInFutureBlocks
argument_list|()
return|;
block|}
comment|/**    * Deprecated. Prefer {@link FileSystem#getAllStoragePolicies()}    * @throws IOException    */
annotation|@
name|Deprecated
DECL|method|getStoragePolicies ()
specifier|public
name|BlockStoragePolicy
index|[]
name|getStoragePolicies
parameter_list|()
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_STORAGE_POLICIES
argument_list|)
expr_stmt|;
return|return
name|dfs
operator|.
name|getStoragePolicies
argument_list|()
return|;
block|}
comment|/**    * Move blocks from srcs to trg and delete srcs afterwards.    * The file block sizes must be the same.    *    * @param trg existing file to append to    * @param psrcs list of files (same block size, same replication)    * @throws IOException    */
annotation|@
name|Override
DECL|method|concat (Path trg, Path [] psrcs)
specifier|public
name|void
name|concat
parameter_list|(
name|Path
name|trg
parameter_list|,
name|Path
index|[]
name|psrcs
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|CONCAT
argument_list|)
expr_stmt|;
comment|// Make target absolute
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|trg
argument_list|)
decl_stmt|;
comment|// Make all srcs absolute
name|Path
index|[]
name|srcs
init|=
operator|new
name|Path
index|[
name|psrcs
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|psrcs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|srcs
index|[
name|i
index|]
operator|=
name|fixRelativePart
argument_list|(
name|psrcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Try the concat without resolving any links
name|String
index|[]
name|srcsStr
init|=
operator|new
name|String
index|[
name|psrcs
operator|.
name|length
index|]
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|psrcs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|srcsStr
index|[
name|i
index|]
operator|=
name|getPathName
argument_list|(
name|srcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dfs
operator|.
name|concat
argument_list|(
name|getPathName
argument_list|(
name|absF
argument_list|)
argument_list|,
name|srcsStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnresolvedLinkException
name|e
parameter_list|)
block|{
comment|// Exception could be from trg or any src.
comment|// Fully resolve trg and srcs. Fail if any of them are a symlink.
name|FileStatus
name|stat
init|=
name|getFileLinkStatus
argument_list|(
name|absF
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot concat with a symlink target: "
operator|+
name|trg
operator|+
literal|" -> "
operator|+
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|absF
operator|=
name|fixRelativePart
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|psrcs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|stat
operator|=
name|getFileLinkStatus
argument_list|(
name|srcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot concat with a symlink src: "
operator|+
name|psrcs
index|[
name|i
index|]
operator|+
literal|" -> "
operator|+
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|srcs
index|[
name|i
index|]
operator|=
name|fixRelativePart
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Try concat again. Can still race with another symlink.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|psrcs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|srcsStr
index|[
name|i
index|]
operator|=
name|getPathName
argument_list|(
name|srcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dfs
operator|.
name|concat
argument_list|(
name|getPathName
argument_list|(
name|absF
argument_list|)
argument_list|,
name|srcsStr
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Override
DECL|method|rename (Path src, Path dst)
specifier|public
name|boolean
name|rename
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|RENAME
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|absSrc
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|absDst
init|=
name|fixRelativePart
argument_list|(
name|dst
argument_list|)
decl_stmt|;
comment|// Try the rename without resolving first
try|try
block|{
return|return
name|dfs
operator|.
name|rename
argument_list|(
name|getPathName
argument_list|(
name|absSrc
argument_list|)
argument_list|,
name|getPathName
argument_list|(
name|absDst
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnresolvedLinkException
name|e
parameter_list|)
block|{
comment|// Fully resolve the source
specifier|final
name|Path
name|source
init|=
name|getFileLinkStatus
argument_list|(
name|absSrc
argument_list|)
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// Keep trying to resolve the destination
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|rename
argument_list|(
name|getPathName
argument_list|(
name|source
argument_list|)
argument_list|,
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Should just throw an error in FileSystem#checkPath
return|return
name|doCall
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absDst
argument_list|)
return|;
block|}
block|}
comment|/**    * This rename operation is guaranteed to be atomic.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Override
DECL|method|rename (Path src, Path dst, final Options.Rename... options)
specifier|public
name|void
name|rename
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|,
specifier|final
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|RENAME
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|absSrc
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|absDst
init|=
name|fixRelativePart
argument_list|(
name|dst
argument_list|)
decl_stmt|;
comment|// Try the rename without resolving first
try|try
block|{
name|dfs
operator|.
name|rename
argument_list|(
name|getPathName
argument_list|(
name|absSrc
argument_list|)
argument_list|,
name|getPathName
argument_list|(
name|absDst
argument_list|)
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnresolvedLinkException
name|e
parameter_list|)
block|{
comment|// Fully resolve the source
specifier|final
name|Path
name|source
init|=
name|getFileLinkStatus
argument_list|(
name|absSrc
argument_list|)
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// Keep trying to resolve the destination
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|rename
argument_list|(
name|getPathName
argument_list|(
name|source
argument_list|)
argument_list|,
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Should just throw an error in FileSystem#checkPath
return|return
name|doCall
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absDst
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|truncate (Path f, final long newLength)
specifier|public
name|boolean
name|truncate
parameter_list|(
name|Path
name|f
parameter_list|,
specifier|final
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|TRUNCATE
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|truncate
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|newLength
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|truncate
argument_list|(
name|p
argument_list|,
name|newLength
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|delete (Path f, final boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
name|Path
name|f
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|DELETE
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|delete
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|recursive
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|delete
argument_list|(
name|p
argument_list|,
name|recursive
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getContentSummary (Path f)
specifier|public
name|ContentSummary
name|getContentSummary
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_CONTENT_SUMMARY
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|ContentSummary
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ContentSummary
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getContentSummary
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ContentSummary
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getContentSummary
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getQuotaUsage (Path f)
specifier|public
name|QuotaUsage
name|getQuotaUsage
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_QUOTA_USAGE
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|QuotaUsage
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|QuotaUsage
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|dfs
operator|.
name|getQuotaUsage
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|QuotaUsage
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getQuotaUsage
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/** Set a directory's quotas    * @see org.apache.hadoop.hdfs.protocol.ClientProtocol#setQuota(String,    * long, long, StorageType)    */
DECL|method|setQuota (Path src, final long namespaceQuota, final long storagespaceQuota)
specifier|public
name|void
name|setQuota
parameter_list|(
name|Path
name|src
parameter_list|,
specifier|final
name|long
name|namespaceQuota
parameter_list|,
specifier|final
name|long
name|storagespaceQuota
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setQuota
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|namespaceQuota
argument_list|,
name|storagespaceQuota
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
comment|// setQuota is not defined in FileSystem, so we only can resolve
comment|// within this DFS
return|return
name|doCall
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the per type storage quota of a directory.    *    * @param src target directory whose quota is to be modified.    * @param type storage type of the specific storage type quota to be modified.    * @param quota value of the specific storage type quota to be modified.    * Maybe {@link HdfsConstants#QUOTA_RESET} to clear quota by storage type.    */
DECL|method|setQuotaByStorageType (Path src, final StorageType type, final long quota)
specifier|public
name|void
name|setQuotaByStorageType
parameter_list|(
name|Path
name|src
parameter_list|,
specifier|final
name|StorageType
name|type
parameter_list|,
specifier|final
name|long
name|quota
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setQuotaByStorageType
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|type
argument_list|,
name|quota
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
comment|// setQuotaByStorageType is not defined in FileSystem, so we only can
comment|// resolve within this DFS
return|return
name|doCall
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
DECL|method|listStatusInternal (Path p)
specifier|private
name|FileStatus
index|[]
name|listStatusInternal
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|src
init|=
name|getPathName
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|// fetch the first batch of entries in the directory
name|DirectoryListing
name|thisListing
init|=
name|dfs
operator|.
name|listPaths
argument_list|(
name|src
argument_list|,
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisListing
operator|==
literal|null
condition|)
block|{
comment|// the directory does not exist
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File "
operator|+
name|p
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
name|HdfsFileStatus
index|[]
name|partialListing
init|=
name|thisListing
operator|.
name|getPartialListing
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|thisListing
operator|.
name|hasMore
argument_list|()
condition|)
block|{
comment|// got all entries of the directory
name|FileStatus
index|[]
name|stats
init|=
operator|new
name|FileStatus
index|[
name|partialListing
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partialListing
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|stats
index|[
name|i
index|]
operator|=
name|partialListing
index|[
name|i
index|]
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|LIST_STATUS
argument_list|)
expr_stmt|;
return|return
name|stats
return|;
block|}
comment|// The directory size is too big that it needs to fetch more
comment|// estimate the total number of entries in the directory
name|int
name|totalNumEntries
init|=
name|partialListing
operator|.
name|length
operator|+
name|thisListing
operator|.
name|getRemainingEntries
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|listing
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|totalNumEntries
argument_list|)
decl_stmt|;
comment|// add the first batch of entries to the array list
for|for
control|(
name|HdfsFileStatus
name|fileStatus
range|:
name|partialListing
control|)
block|{
name|listing
operator|.
name|add
argument_list|(
name|fileStatus
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|statistics
operator|.
name|incrementLargeReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|LIST_STATUS
argument_list|)
expr_stmt|;
comment|// now fetch more entries
do|do
block|{
name|thisListing
operator|=
name|dfs
operator|.
name|listPaths
argument_list|(
name|src
argument_list|,
name|thisListing
operator|.
name|getLastName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisListing
operator|==
literal|null
condition|)
block|{
comment|// the directory is deleted
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File "
operator|+
name|p
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
name|partialListing
operator|=
name|thisListing
operator|.
name|getPartialListing
argument_list|()
expr_stmt|;
for|for
control|(
name|HdfsFileStatus
name|fileStatus
range|:
name|partialListing
control|)
block|{
name|listing
operator|.
name|add
argument_list|(
name|fileStatus
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|statistics
operator|.
name|incrementLargeReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|LIST_STATUS
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|thisListing
operator|.
name|hasMore
argument_list|()
condition|)
do|;
return|return
name|listing
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|listing
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * List all the entries of a directory    *    * Note that this operation is not atomic for a large directory.    * The entries of a directory may be fetched from NameNode multiple times.    * It only guarantees that  each name occurs once if a directory    * undergoes changes between the calls.    */
annotation|@
name|Override
DECL|method|listStatus (Path p)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FileStatus
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileStatus
index|[]
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listStatusInternal
argument_list|(
name|p
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileStatus
index|[]
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|listStatus
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * The BlockLocation of returned LocatedFileStatus will have different    * formats for replicated and erasure coded file.    * Please refer to    * {@link FileSystem#getFileBlockLocations(FileStatus, long, long)} for    * more details.    */
annotation|@
name|Override
DECL|method|listLocatedStatus (final Path p, final PathFilter filter)
specifier|protected
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listLocatedStatus
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|,
specifier|final
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|DirListingIterator
argument_list|<>
argument_list|(
name|p
argument_list|,
name|filter
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
return|return
operator|(
operator|(
name|DistributedFileSystem
operator|)
name|fs
operator|)
operator|.
name|listLocatedStatus
argument_list|(
name|p
argument_list|,
name|filter
argument_list|)
return|;
block|}
comment|// symlink resolution for this methos does not work cross file systems
comment|// because it is a protected method.
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Link resolution does not work with multiple "
operator|+
literal|"file systems for listLocatedStatus(): "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Returns a remote iterator so that followup calls are made on demand    * while consuming the entries. This reduces memory consumption during    * listing of a large directory.    *    * @param p target path    * @return remote iterator    */
annotation|@
name|Override
DECL|method|listStatusIterator (final Path p)
specifier|public
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|listStatusIterator
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|DirListingIterator
argument_list|<>
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
operator|(
name|DistributedFileSystem
operator|)
name|fs
operator|)
operator|.
name|listStatusIterator
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * This class defines an iterator that returns    * the file status of each file/subdirectory of a directory    *    * if needLocation, status contains block location if it is a file    * throws a RuntimeException with the error as its cause.    *    * @param<T> the type of the file status    */
DECL|class|DirListingIterator
specifier|private
class|class
name|DirListingIterator
parameter_list|<
name|T
extends|extends
name|FileStatus
parameter_list|>
implements|implements
name|RemoteIterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|thisListing
specifier|private
name|DirectoryListing
name|thisListing
decl_stmt|;
DECL|field|i
specifier|private
name|int
name|i
decl_stmt|;
DECL|field|p
specifier|private
name|Path
name|p
decl_stmt|;
DECL|field|src
specifier|private
name|String
name|src
decl_stmt|;
DECL|field|curStat
specifier|private
name|T
name|curStat
init|=
literal|null
decl_stmt|;
DECL|field|filter
specifier|private
name|PathFilter
name|filter
decl_stmt|;
DECL|field|needLocation
specifier|private
name|boolean
name|needLocation
decl_stmt|;
DECL|method|DirListingIterator (Path p, PathFilter filter, boolean needLocation)
specifier|private
name|DirListingIterator
parameter_list|(
name|Path
name|p
parameter_list|,
name|PathFilter
name|filter
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|this
operator|.
name|src
operator|=
name|getPathName
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|needLocation
operator|=
name|needLocation
expr_stmt|;
comment|// fetch the first batch of entries in the directory
name|thisListing
operator|=
name|dfs
operator|.
name|listPaths
argument_list|(
name|src
argument_list|,
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|,
name|needLocation
argument_list|)
expr_stmt|;
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|LIST_LOCATED_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisListing
operator|==
literal|null
condition|)
block|{
comment|// the directory does not exist
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File "
operator|+
name|p
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|DirListingIterator (Path p, boolean needLocation)
specifier|private
name|DirListingIterator
parameter_list|(
name|Path
name|p
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|p
argument_list|,
literal|null
argument_list|,
name|needLocation
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|curStat
operator|==
literal|null
operator|&&
name|hasNextNoFilter
argument_list|()
condition|)
block|{
name|T
name|next
decl_stmt|;
name|HdfsFileStatus
name|fileStat
init|=
name|thisListing
operator|.
name|getPartialListing
argument_list|()
index|[
name|i
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|needLocation
condition|)
block|{
name|next
operator|=
call|(
name|T
call|)
argument_list|(
operator|(
name|HdfsLocatedFileStatus
operator|)
name|fileStat
argument_list|)
operator|.
name|makeQualifiedLocated
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
operator|(
name|T
operator|)
name|fileStat
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|// apply filter if not null
if|if
condition|(
name|filter
operator|==
literal|null
operator|||
name|filter
operator|.
name|accept
argument_list|(
name|next
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|curStat
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
name|curStat
operator|!=
literal|null
return|;
block|}
comment|/** Check if there is a next item before applying the given filter */
DECL|method|hasNextNoFilter ()
specifier|private
name|boolean
name|hasNextNoFilter
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|thisListing
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|i
operator|>=
name|thisListing
operator|.
name|getPartialListing
argument_list|()
operator|.
name|length
operator|&&
name|thisListing
operator|.
name|hasMore
argument_list|()
condition|)
block|{
comment|// current listing is exhausted& fetch a new listing
name|thisListing
operator|=
name|dfs
operator|.
name|listPaths
argument_list|(
name|src
argument_list|,
name|thisListing
operator|.
name|getLastName
argument_list|()
argument_list|,
name|needLocation
argument_list|)
expr_stmt|;
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisListing
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File "
operator|+
name|p
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|<
name|thisListing
operator|.
name|getPartialListing
argument_list|()
operator|.
name|length
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|T
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|T
name|tmp
init|=
name|curStat
decl_stmt|;
name|curStat
operator|=
literal|null
expr_stmt|;
return|return
name|tmp
return|;
block|}
throw|throw
operator|new
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
argument_list|(
literal|"No more entry in "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create a directory, only when the parent directories exist.    *    * See {@link FsPermission#applyUMask(FsPermission)} for details of how    * the permission is applied.    *    * @param f           The path to create    * @param permission  The permission.  See FsPermission#applyUMask for    *                    details about how this is used to calculate the    *                    effective permission.    */
DECL|method|mkdir (Path f, FsPermission permission)
specifier|public
name|boolean
name|mkdir
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|mkdirsInternal
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Create a directory and its parent directories.    *    * See {@link FsPermission#applyUMask(FsPermission)} for details of how    * the permission is applied.    *    * @param f           The path to create    * @param permission  The permission.  See FsPermission#applyUMask for    *                    details about how this is used to calculate the    *                    effective permission.    */
annotation|@
name|Override
DECL|method|mkdirs (Path f, FsPermission permission)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|mkdirsInternal
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|mkdirsInternal (Path f, final FsPermission permission, final boolean createParent)
specifier|private
name|boolean
name|mkdirsInternal
parameter_list|(
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|MKDIRS
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|mkdirs
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|permission
argument_list|,
name|createParent
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
comment|// FileSystem doesn't have a non-recursive mkdir() method
comment|// Best we can do is error out
if|if
condition|(
operator|!
name|createParent
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FileSystem does not support non-recursive"
operator|+
literal|"mkdir"
argument_list|)
throw|;
block|}
return|return
name|fs
operator|.
name|mkdirs
argument_list|(
name|p
argument_list|,
name|permission
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Override
DECL|method|primitiveMkdir (Path f, FsPermission absolutePermission)
specifier|protected
name|boolean
name|primitiveMkdir
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|absolutePermission
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|PRIMITIVE_MKDIR
argument_list|)
expr_stmt|;
return|return
name|dfs
operator|.
name|primitiveMkdir
argument_list|(
name|getPathName
argument_list|(
name|f
argument_list|)
argument_list|,
name|absolutePermission
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|dfs
operator|.
name|closeOutputStreams
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|dfs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DFS["
operator|+
name|dfs
operator|+
literal|"]"
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|getClient ()
specifier|public
name|DFSClient
name|getClient
parameter_list|()
block|{
return|return
name|dfs
return|;
block|}
annotation|@
name|Override
DECL|method|getStatus (Path p)
specifier|public
name|FsStatus
name|getStatus
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_STATUS
argument_list|)
expr_stmt|;
return|return
name|dfs
operator|.
name|getDiskStatus
argument_list|()
return|;
block|}
comment|/**    * Returns count of blocks with no good replicas left. Normally should be    * zero.    *    * @throws IOException    */
DECL|method|getMissingBlocksCount ()
specifier|public
name|long
name|getMissingBlocksCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getMissingBlocksCount
argument_list|()
return|;
block|}
comment|/**    * Returns count of blocks pending on deletion.    *    * @throws IOException    */
DECL|method|getPendingDeletionBlocksCount ()
specifier|public
name|long
name|getPendingDeletionBlocksCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getPendingDeletionBlocksCount
argument_list|()
return|;
block|}
comment|/**    * Returns count of blocks with replication factor 1 and have    * lost the only replica.    *    * @throws IOException    */
DECL|method|getMissingReplOneBlocksCount ()
specifier|public
name|long
name|getMissingReplOneBlocksCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getMissingReplOneBlocksCount
argument_list|()
return|;
block|}
comment|/**    * Returns aggregated count of blocks with less redundancy.    *    * @throws IOException    */
DECL|method|getLowRedundancyBlocksCount ()
specifier|public
name|long
name|getLowRedundancyBlocksCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getLowRedundancyBlocksCount
argument_list|()
return|;
block|}
comment|/**    * Returns count of blocks with at least one replica marked corrupt.    *    * @throws IOException    */
DECL|method|getCorruptBlocksCount ()
specifier|public
name|long
name|getCorruptBlocksCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getCorruptBlocksCount
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|listCorruptFileBlocks (final Path path)
specifier|public
name|RemoteIterator
argument_list|<
name|Path
argument_list|>
name|listCorruptFileBlocks
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|RemoteIterator
argument_list|<
name|Path
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RemoteIterator
argument_list|<
name|Path
argument_list|>
name|doCall
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
operator|new
name|CorruptFileBlockIterator
argument_list|(
name|dfs
argument_list|,
name|path
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RemoteIterator
argument_list|<
name|Path
argument_list|>
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|listCorruptFileBlocks
argument_list|(
name|path
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/** @return datanode statistics. */
DECL|method|getDataNodeStats ()
specifier|public
name|DatanodeInfo
index|[]
name|getDataNodeStats
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getDataNodeStats
argument_list|(
name|DatanodeReportType
operator|.
name|ALL
argument_list|)
return|;
block|}
comment|/** @return datanode statistics for the given type. */
DECL|method|getDataNodeStats (final DatanodeReportType type)
specifier|public
name|DatanodeInfo
index|[]
name|getDataNodeStats
parameter_list|(
specifier|final
name|DatanodeReportType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|datanodeReport
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * Enter, leave or get safe mode.    *    * @see org.apache.hadoop.hdfs.protocol.ClientProtocol#setSafeMode(    *    HdfsConstants.SafeModeAction,boolean)    */
DECL|method|setSafeMode (HdfsConstants.SafeModeAction action)
specifier|public
name|boolean
name|setSafeMode
parameter_list|(
name|HdfsConstants
operator|.
name|SafeModeAction
name|action
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|setSafeMode
argument_list|(
name|action
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Enter, leave or get safe mode.    *    * @param action    *          One of SafeModeAction.ENTER, SafeModeAction.LEAVE and    *          SafeModeAction.GET    * @param isChecked    *          If true check only for Active NNs status, else check first NN's    *          status    * @see org.apache.hadoop.hdfs.protocol.ClientProtocol#setSafeMode(SafeModeAction, boolean)    */
DECL|method|setSafeMode (HdfsConstants.SafeModeAction action, boolean isChecked)
specifier|public
name|boolean
name|setSafeMode
parameter_list|(
name|HdfsConstants
operator|.
name|SafeModeAction
name|action
parameter_list|,
name|boolean
name|isChecked
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|setSafeMode
argument_list|(
name|action
argument_list|,
name|isChecked
argument_list|)
return|;
block|}
comment|/**    * Save namespace image.    *    * @param timeWindow NameNode can ignore this command if the latest    *                   checkpoint was done within the given time period (in    *                   seconds).    * @return true if a new checkpoint has been made    * @see ClientProtocol#saveNamespace(long, long)    */
DECL|method|saveNamespace (long timeWindow, long txGap)
specifier|public
name|boolean
name|saveNamespace
parameter_list|(
name|long
name|timeWindow
parameter_list|,
name|long
name|txGap
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|saveNamespace
argument_list|(
name|timeWindow
argument_list|,
name|txGap
argument_list|)
return|;
block|}
comment|/**    * Save namespace image. NameNode always does the checkpoint.    */
DECL|method|saveNamespace ()
specifier|public
name|void
name|saveNamespace
parameter_list|()
throws|throws
name|IOException
block|{
name|saveNamespace
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rolls the edit log on the active NameNode.    * Requires super-user privileges.    * @see org.apache.hadoop.hdfs.protocol.ClientProtocol#rollEdits()    * @return the transaction ID of the newly created segment    */
DECL|method|rollEdits ()
specifier|public
name|long
name|rollEdits
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|rollEdits
argument_list|()
return|;
block|}
comment|/**    * enable/disable/check restoreFaileStorage    *    * @see org.apache.hadoop.hdfs.protocol.ClientProtocol#restoreFailedStorage(String arg)    */
DECL|method|restoreFailedStorage (String arg)
specifier|public
name|boolean
name|restoreFailedStorage
parameter_list|(
name|String
name|arg
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|restoreFailedStorage
argument_list|(
name|arg
argument_list|)
return|;
block|}
comment|/**    * Refreshes the list of hosts and excluded hosts from the configured    * files.    */
DECL|method|refreshNodes ()
specifier|public
name|void
name|refreshNodes
parameter_list|()
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
block|}
comment|/**    * Finalize previously upgraded files system state.    * @throws IOException    */
DECL|method|finalizeUpgrade ()
specifier|public
name|void
name|finalizeUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|finalizeUpgrade
argument_list|()
expr_stmt|;
block|}
comment|/**    * Rolling upgrade: prepare/finalize/query.    */
DECL|method|rollingUpgrade (RollingUpgradeAction action)
specifier|public
name|RollingUpgradeInfo
name|rollingUpgrade
parameter_list|(
name|RollingUpgradeAction
name|action
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|rollingUpgrade
argument_list|(
name|action
argument_list|)
return|;
block|}
comment|/*    * Requests the namenode to dump data strcutures into specified    * file.    */
DECL|method|metaSave (String pathname)
specifier|public
name|void
name|metaSave
parameter_list|(
name|String
name|pathname
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|metaSave
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getServerDefaults ()
specifier|public
name|FsServerDefaults
name|getServerDefaults
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getServerDefaults
argument_list|()
return|;
block|}
comment|/**    * Returns the stat information about the file.    * @throws FileNotFoundException if the file does not exist.    */
annotation|@
name|Override
DECL|method|getFileStatus (Path f)
specifier|public
name|FileStatus
name|getFileStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_FILE_STATUS
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileStatus
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|fi
init|=
name|dfs
operator|.
name|getFileInfo
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
condition|)
block|{
return|return
name|fi
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|p
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|FileStatus
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getFileStatus
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Override
DECL|method|createSymlink (final Path target, final Path link, final boolean createParent)
specifier|public
name|void
name|createSymlink
parameter_list|(
specifier|final
name|Path
name|target
parameter_list|,
specifier|final
name|Path
name|link
parameter_list|,
specifier|final
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|FileSystem
operator|.
name|areSymlinksEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Symlinks not supported"
argument_list|)
throw|;
block|}
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|CREATE_SYM_LINK
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|link
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|createSymlink
argument_list|(
name|target
operator|.
name|toString
argument_list|()
argument_list|,
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|createSymlink
argument_list|(
name|target
argument_list|,
name|p
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|supportsSymlinks ()
specifier|public
name|boolean
name|supportsSymlinks
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getFileLinkStatus (final Path f)
specifier|public
name|FileStatus
name|getFileLinkStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_FILE_LINK_STATUS
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|FileStatus
name|status
init|=
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileStatus
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|fi
init|=
name|dfs
operator|.
name|getFileLinkInfo
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
condition|)
block|{
return|return
name|fi
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|p
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|FileStatus
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getFileLinkStatus
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
decl_stmt|;
comment|// Fully-qualify the symlink
if|if
condition|(
name|status
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
name|Path
name|targetQual
init|=
name|FSLinkResolver
operator|.
name|qualifySymlinkTarget
argument_list|(
name|this
operator|.
name|getUri
argument_list|()
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
argument_list|,
name|status
operator|.
name|getSymlink
argument_list|()
argument_list|)
decl_stmt|;
name|status
operator|.
name|setSymlink
argument_list|(
name|targetQual
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
annotation|@
name|Override
DECL|method|getLinkTarget (final Path f)
specifier|public
name|Path
name|getLinkTarget
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_LINK_TARGET
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Path
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|HdfsFileStatus
name|fi
init|=
name|dfs
operator|.
name|getFileLinkInfo
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
condition|)
block|{
return|return
name|fi
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|p
argument_list|)
operator|.
name|getSymlink
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Path
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getLinkTarget
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|resolveLink (Path f)
specifier|protected
name|Path
name|resolveLink
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|RESOLVE_LINK
argument_list|)
expr_stmt|;
name|String
name|target
init|=
name|dfs
operator|.
name|getLinkTarget
argument_list|(
name|getPathName
argument_list|(
name|fixRelativePart
argument_list|(
name|f
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|f
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|Path
argument_list|(
name|target
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getFileChecksum (Path f)
specifier|public
name|FileChecksum
name|getFileChecksum
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_FILE_CHECKSUM
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FileChecksum
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileChecksum
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getFileChecksum
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileChecksum
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getFileChecksum
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getFileChecksum (Path f, final long length)
specifier|public
name|FileChecksum
name|getFileChecksum
parameter_list|(
name|Path
name|f
parameter_list|,
specifier|final
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_FILE_CHECKSUM
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FileChecksum
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileChecksum
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getFileChecksum
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileChecksum
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
return|return
name|fs
operator|.
name|getFileChecksum
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedFileSystemException
argument_list|(
literal|"getFileChecksum(Path, long) is not supported by "
operator|+
name|fs
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setPermission (Path p, final FsPermission permission )
specifier|public
name|void
name|setPermission
parameter_list|(
name|Path
name|p
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|SET_PERMISSION
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|p
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setPermission
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|permission
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setPermission
argument_list|(
name|p
argument_list|,
name|permission
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setOwner (Path p, final String username, final String groupname)
specifier|public
name|void
name|setOwner
parameter_list|(
name|Path
name|p
parameter_list|,
specifier|final
name|String
name|username
parameter_list|,
specifier|final
name|String
name|groupname
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|username
operator|==
literal|null
operator|&&
name|groupname
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"username == null&& groupname == null"
argument_list|)
throw|;
block|}
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|SET_OWNER
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|p
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setOwner
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setOwner
argument_list|(
name|p
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setTimes (Path p, final long mtime, final long atime)
specifier|public
name|void
name|setTimes
parameter_list|(
name|Path
name|p
parameter_list|,
specifier|final
name|long
name|mtime
parameter_list|,
specifier|final
name|long
name|atime
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|SET_TIMES
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|p
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setTimes
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setTimes
argument_list|(
name|p
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDefaultPort ()
specifier|protected
name|int
name|getDefaultPort
parameter_list|()
block|{
return|return
name|HdfsClientConfigKeys
operator|.
name|DFS_NAMENODE_RPC_PORT_DEFAULT
return|;
block|}
annotation|@
name|Override
DECL|method|getDelegationToken (String renewer)
specifier|public
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|getDelegationToken
parameter_list|(
name|String
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getDelegationToken
argument_list|(
name|renewer
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|Text
argument_list|(
name|renewer
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Requests the namenode to tell all datanodes to use a new, non-persistent    * bandwidth value for dfs.datanode.balance.bandwidthPerSec.    * The bandwidth parameter is the max number of bytes per second of network    * bandwidth to be used by a datanode during balancing.    *    * @param bandwidth Balancer bandwidth in bytes per second for all datanodes.    * @throws IOException    */
DECL|method|setBalancerBandwidth (long bandwidth)
specifier|public
name|void
name|setBalancerBandwidth
parameter_list|(
name|long
name|bandwidth
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setBalancerBandwidth
argument_list|(
name|bandwidth
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a canonical service name for this file system. If the URI is logical,    * the hostname part of the URI will be returned.    * @return a service string that uniquely identifies this file system.    */
annotation|@
name|Override
DECL|method|getCanonicalServiceName ()
specifier|public
name|String
name|getCanonicalServiceName
parameter_list|()
block|{
return|return
name|dfs
operator|.
name|getCanonicalServiceName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|canonicalizeUri (URI uri)
specifier|protected
name|URI
name|canonicalizeUri
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
if|if
condition|(
name|HAUtilClient
operator|.
name|isLogicalUri
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|uri
argument_list|)
condition|)
block|{
comment|// Don't try to DNS-resolve logical URIs, since the 'authority'
comment|// portion isn't a proper hostname
return|return
name|uri
return|;
block|}
else|else
block|{
return|return
name|NetUtils
operator|.
name|getCanonicalUri
argument_list|(
name|uri
argument_list|,
name|getDefaultPort
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Utility function that returns if the NameNode is in safemode or not. In HA    * mode, this API will return only ActiveNN's safemode status.    *    * @return true if NameNode is in safemode, false otherwise.    * @throws IOException    *           when there is an issue communicating with the NameNode    */
DECL|method|isInSafeMode ()
specifier|public
name|boolean
name|isInSafeMode
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|setSafeMode
argument_list|(
name|SafeModeAction
operator|.
name|SAFEMODE_GET
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** @see HdfsAdmin#allowSnapshot(Path) */
DECL|method|allowSnapshot (final Path path)
specifier|public
name|void
name|allowSnapshot
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|ALLOW_SNAPSHOT
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|allowSnapshot
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|myDfs
operator|.
name|allowSnapshot
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot perform snapshot"
operator|+
literal|" operations on a symlink to a non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/** @see HdfsAdmin#disallowSnapshot(Path) */
DECL|method|disallowSnapshot (final Path path)
specifier|public
name|void
name|disallowSnapshot
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|DISALLOW_SNAPSHOT
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|disallowSnapshot
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|myDfs
operator|.
name|disallowSnapshot
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot perform snapshot"
operator|+
literal|" operations on a symlink to a non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createSnapshot (final Path path, final String snapshotName)
specifier|public
name|Path
name|createSnapshot
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|CREATE_SNAPSHOT
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Path
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Path
argument_list|(
name|dfs
operator|.
name|createSnapshot
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|snapshotName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Path
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
return|return
name|myDfs
operator|.
name|createSnapshot
argument_list|(
name|p
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot perform snapshot"
operator|+
literal|" operations on a symlink to a non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|renameSnapshot (final Path path, final String snapshotOldName, final String snapshotNewName)
specifier|public
name|void
name|renameSnapshot
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|snapshotOldName
parameter_list|,
specifier|final
name|String
name|snapshotNewName
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|RENAME_SNAPSHOT
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|renameSnapshot
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|snapshotOldName
argument_list|,
name|snapshotNewName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|myDfs
operator|.
name|renameSnapshot
argument_list|(
name|p
argument_list|,
name|snapshotOldName
argument_list|,
name|snapshotNewName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot perform snapshot"
operator|+
literal|" operations on a symlink to a non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return All the snapshottable directories    * @throws IOException    */
DECL|method|getSnapshottableDirListing ()
specifier|public
name|SnapshottableDirectoryStatus
index|[]
name|getSnapshottableDirListing
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getSnapshottableDirListing
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|deleteSnapshot (final Path snapshotDir, final String snapshotName)
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
specifier|final
name|Path
name|snapshotDir
parameter_list|,
specifier|final
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|DELETE_SNAPSHOT
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|snapshotDir
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|deleteSnapshot
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|myDfs
operator|.
name|deleteSnapshot
argument_list|(
name|p
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot perform snapshot"
operator|+
literal|" operations on a symlink to a non-DistributedFileSystem: "
operator|+
name|snapshotDir
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the difference between two snapshots, or between a snapshot and the    * current tree of a directory.    *    * @see DFSClient#getSnapshotDiffReport(String, String, String)    */
DECL|method|getSnapshotDiffReport (final Path snapshotDir, final String fromSnapshot, final String toSnapshot)
specifier|public
name|SnapshotDiffReport
name|getSnapshotDiffReport
parameter_list|(
specifier|final
name|Path
name|snapshotDir
parameter_list|,
specifier|final
name|String
name|fromSnapshot
parameter_list|,
specifier|final
name|String
name|toSnapshot
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|snapshotDir
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|SnapshotDiffReport
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SnapshotDiffReport
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getSnapshotDiffReport
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|fromSnapshot
argument_list|,
name|toSnapshot
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SnapshotDiffReport
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|myDfs
operator|.
name|getSnapshotDiffReport
argument_list|(
name|p
argument_list|,
name|fromSnapshot
argument_list|,
name|toSnapshot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot perform snapshot"
operator|+
literal|" operations on a symlink to a non-DistributedFileSystem: "
operator|+
name|snapshotDir
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Get the close status of a file    * @param src The path to the file    *    * @return return true if file is closed    * @throws FileNotFoundException if the file does not exist.    * @throws IOException If an I/O error occurred    */
DECL|method|isFileClosed (final Path src)
specifier|public
name|boolean
name|isFileClosed
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|isFileClosed
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
return|return
name|myDfs
operator|.
name|isFileClosed
argument_list|(
name|p
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot call isFileClosed"
operator|+
literal|" on a symlink to a non-DistributedFileSystem: "
operator|+
name|src
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * @see {@link #addCacheDirective(CacheDirectiveInfo, EnumSet)}    */
DECL|method|addCacheDirective (CacheDirectiveInfo info)
specifier|public
name|long
name|addCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|addCacheDirective
argument_list|(
name|info
argument_list|,
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|CacheFlag
operator|.
name|class
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Add a new CacheDirective.    *    * @param info Information about a directive to add.    * @param flags {@link CacheFlag}s to use for this operation.    * @return the ID of the directive that was created.    * @throws IOException if the directive could not be added    */
DECL|method|addCacheDirective ( CacheDirectiveInfo info, EnumSet<CacheFlag> flags)
specifier|public
name|long
name|addCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|info
parameter_list|,
name|EnumSet
argument_list|<
name|CacheFlag
argument_list|>
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|info
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|getPathName
argument_list|(
name|fixRelativePart
argument_list|(
name|info
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|getWorkingDirectory
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|dfs
operator|.
name|addCacheDirective
argument_list|(
operator|new
name|CacheDirectiveInfo
operator|.
name|Builder
argument_list|(
name|info
argument_list|)
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|/**    * @see {@link #modifyCacheDirective(CacheDirectiveInfo, EnumSet)}    */
DECL|method|modifyCacheDirective (CacheDirectiveInfo info)
specifier|public
name|void
name|modifyCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|modifyCacheDirective
argument_list|(
name|info
argument_list|,
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|CacheFlag
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify a CacheDirective.    *    * @param info Information about the directive to modify. You must set the ID    *          to indicate which CacheDirective you want to modify.    * @param flags {@link CacheFlag}s to use for this operation.    * @throws IOException if the directive could not be modified    */
DECL|method|modifyCacheDirective ( CacheDirectiveInfo info, EnumSet<CacheFlag> flags)
specifier|public
name|void
name|modifyCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|info
parameter_list|,
name|EnumSet
argument_list|<
name|CacheFlag
argument_list|>
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|info
operator|.
name|getPath
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|info
operator|=
operator|new
name|CacheDirectiveInfo
operator|.
name|Builder
argument_list|(
name|info
argument_list|)
operator|.
name|setPath
argument_list|(
operator|new
name|Path
argument_list|(
name|getPathName
argument_list|(
name|fixRelativePart
argument_list|(
name|info
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|getWorkingDirectory
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|dfs
operator|.
name|modifyCacheDirective
argument_list|(
name|info
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove a CacheDirectiveInfo.    *    * @param id identifier of the CacheDirectiveInfo to remove    * @throws IOException if the directive could not be removed    */
DECL|method|removeCacheDirective (long id)
specifier|public
name|void
name|removeCacheDirective
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|removeCacheDirective
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
comment|/**    * List cache directives.  Incrementally fetches results from the server.    *    * @param filter Filter parameters to use when listing the directives, null to    *               list all directives visible to us.    * @return A RemoteIterator which returns CacheDirectiveInfo objects.    */
DECL|method|listCacheDirectives ( CacheDirectiveInfo filter)
specifier|public
name|RemoteIterator
argument_list|<
name|CacheDirectiveEntry
argument_list|>
name|listCacheDirectives
parameter_list|(
name|CacheDirectiveInfo
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
name|filter
operator|=
operator|new
name|CacheDirectiveInfo
operator|.
name|Builder
argument_list|()
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|filter
operator|.
name|getPath
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|filter
operator|=
operator|new
name|CacheDirectiveInfo
operator|.
name|Builder
argument_list|(
name|filter
argument_list|)
operator|.
name|setPath
argument_list|(
operator|new
name|Path
argument_list|(
name|getPathName
argument_list|(
name|fixRelativePart
argument_list|(
name|filter
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
specifier|final
name|RemoteIterator
argument_list|<
name|CacheDirectiveEntry
argument_list|>
name|iter
init|=
name|dfs
operator|.
name|listCacheDirectives
argument_list|(
name|filter
argument_list|)
decl_stmt|;
return|return
operator|new
name|RemoteIterator
argument_list|<
name|CacheDirectiveEntry
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|iter
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|CacheDirectiveEntry
name|next
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Although the paths we get back from the NameNode should always be
comment|// absolute, we call makeQualified to add the scheme and authority of
comment|// this DistributedFilesystem.
name|CacheDirectiveEntry
name|desc
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|CacheDirectiveInfo
name|info
init|=
name|desc
operator|.
name|getInfo
argument_list|()
decl_stmt|;
name|Path
name|p
init|=
name|info
operator|.
name|getPath
argument_list|()
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|getWorkingDirectory
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|CacheDirectiveEntry
argument_list|(
operator|new
name|CacheDirectiveInfo
operator|.
name|Builder
argument_list|(
name|info
argument_list|)
operator|.
name|setPath
argument_list|(
name|p
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
name|desc
operator|.
name|getStats
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Add a cache pool.    *    * @param info    *          The request to add a cache pool.    * @throws IOException    *          If the request could not be completed.    */
DECL|method|addCachePool (CachePoolInfo info)
specifier|public
name|void
name|addCachePool
parameter_list|(
name|CachePoolInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|CachePoolInfo
operator|.
name|validate
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|addCachePool
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing cache pool.    *    * @param info    *          The request to modify a cache pool.    * @throws IOException    *          If the request could not be completed.    */
DECL|method|modifyCachePool (CachePoolInfo info)
specifier|public
name|void
name|modifyCachePool
parameter_list|(
name|CachePoolInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|CachePoolInfo
operator|.
name|validate
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|modifyCachePool
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove a cache pool.    *    * @param poolName    *          Name of the cache pool to remove.    * @throws IOException    *          if the cache pool did not exist, or could not be removed.    */
DECL|method|removeCachePool (String poolName)
specifier|public
name|void
name|removeCachePool
parameter_list|(
name|String
name|poolName
parameter_list|)
throws|throws
name|IOException
block|{
name|CachePoolInfo
operator|.
name|validateName
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|removeCachePool
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
block|}
comment|/**    * List all cache pools.    *    * @return A remote iterator from which you can get CachePoolEntry objects.    *          Requests will be made as needed.    * @throws IOException    *          If there was an error listing cache pools.    */
DECL|method|listCachePools ()
specifier|public
name|RemoteIterator
argument_list|<
name|CachePoolEntry
argument_list|>
name|listCachePools
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|listCachePools
argument_list|()
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
DECL|method|modifyAclEntries (Path path, final List<AclEntry> aclSpec)
specifier|public
name|void
name|modifyAclEntries
parameter_list|(
name|Path
name|path
parameter_list|,
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|MODIFY_ACL_ENTRIES
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|modifyAclEntries
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|modifyAclEntries
argument_list|(
name|p
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
DECL|method|removeAclEntries (Path path, final List<AclEntry> aclSpec)
specifier|public
name|void
name|removeAclEntries
parameter_list|(
name|Path
name|path
parameter_list|,
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|REMOVE_ACL_ENTRIES
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|removeAclEntries
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|removeAclEntries
argument_list|(
name|p
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
DECL|method|removeDefaultAcl (Path path)
specifier|public
name|void
name|removeDefaultAcl
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|REMOVE_DEFAULT_ACL
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|removeDefaultAcl
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|removeDefaultAcl
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
DECL|method|removeAcl (Path path)
specifier|public
name|void
name|removeAcl
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|REMOVE_ACL
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|removeAcl
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|removeAcl
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
DECL|method|setAcl (Path path, final List<AclEntry> aclSpec)
specifier|public
name|void
name|setAcl
parameter_list|(
name|Path
name|path
parameter_list|,
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|SET_ACL
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setAcl
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setAcl
argument_list|(
name|p
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
DECL|method|getAclStatus (Path path)
specifier|public
name|AclStatus
name|getAclStatus
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|AclStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|AclStatus
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getAclStatus
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AclStatus
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getAclStatus
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/* HDFS only */
DECL|method|createEncryptionZone (final Path path, final String keyName)
specifier|public
name|void
name|createEncryptionZone
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|keyName
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|createEncryptionZone
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|keyName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|myDfs
operator|.
name|createEncryptionZone
argument_list|(
name|p
argument_list|,
name|keyName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot call createEncryptionZone"
operator|+
literal|" on a symlink to a non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/* HDFS only */
DECL|method|getEZForPath (final Path path)
specifier|public
name|EncryptionZone
name|getEZForPath
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|EncryptionZone
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|EncryptionZone
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getEZForPath
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|EncryptionZone
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
return|return
name|myDfs
operator|.
name|getEZForPath
argument_list|(
name|p
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot call getEZForPath"
operator|+
literal|" on a symlink to a non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/* HDFS only */
DECL|method|listEncryptionZones ()
specifier|public
name|RemoteIterator
argument_list|<
name|EncryptionZone
argument_list|>
name|listEncryptionZones
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|listEncryptionZones
argument_list|()
return|;
block|}
comment|/* HDFS only */
DECL|method|reencryptEncryptionZone (final Path zone, final ReencryptAction action)
specifier|public
name|void
name|reencryptEncryptionZone
parameter_list|(
specifier|final
name|Path
name|zone
parameter_list|,
specifier|final
name|ReencryptAction
name|action
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|zone
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|reencryptEncryptionZone
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|myDfs
operator|.
name|reencryptEncryptionZone
argument_list|(
name|p
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot call reencryptEncryptionZone"
operator|+
literal|" on a symlink to a non-DistributedFileSystem: "
operator|+
name|zone
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/* HDFS only */
DECL|method|listReencryptionStatus ()
specifier|public
name|RemoteIterator
argument_list|<
name|ZoneReencryptionStatus
argument_list|>
name|listReencryptionStatus
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|listReencryptionStatus
argument_list|()
return|;
block|}
comment|/* HDFS only */
DECL|method|getFileEncryptionInfo (final Path path)
specifier|public
name|FileEncryptionInfo
name|getFileEncryptionInfo
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|FileEncryptionInfo
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileEncryptionInfo
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|HdfsFileStatus
name|fi
init|=
name|dfs
operator|.
name|getFileInfo
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|p
argument_list|)
throw|;
block|}
return|return
name|fi
operator|.
name|getFileEncryptionInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileEncryptionInfo
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
return|return
name|myDfs
operator|.
name|getFileEncryptionInfo
argument_list|(
name|p
argument_list|)
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot call getFileEncryptionInfo"
operator|+
literal|" on a symlink to a non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setXAttr (Path path, final String name, final byte[] value, final EnumSet<XAttrSetFlag> flag)
specifier|public
name|void
name|setXAttr
parameter_list|(
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|XAttrSetFlag
argument_list|>
name|flag
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|SET_XATTR
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setXAttr
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|setXAttr
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getXAttr (Path path, final String name)
specifier|public
name|byte
index|[]
name|getXAttr
parameter_list|(
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementReadOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|GET_XATTR
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getXAttr
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getXAttr
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getXAttrs (Path path)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|getXAttrs
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getXAttrs
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getXAttrs
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getXAttrs (Path path, final List<String> names)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|getXAttrs
parameter_list|(
name|Path
name|path
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getXAttrs
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|names
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|getXAttrs
argument_list|(
name|p
argument_list|,
name|names
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|listXAttrs (Path path)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|listXAttrs
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|listXAttrs
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|listXAttrs
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|removeXAttr (Path path, final String name)
specifier|public
name|void
name|removeXAttr
parameter_list|(
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|statistics
operator|.
name|incrementWriteOps
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|storageStatistics
operator|.
name|incrementOpCounter
argument_list|(
name|OpType
operator|.
name|REMOVE_XATTR
argument_list|)
expr_stmt|;
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|removeXAttr
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|removeXAttr
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|access (Path path, final FsAction mode)
specifier|public
name|void
name|access
parameter_list|(
name|Path
name|path
parameter_list|,
specifier|final
name|FsAction
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|checkAccess
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|access
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|addDelegationTokens ( final String renewer, Credentials credentials)
specifier|public
name|Token
argument_list|<
name|?
argument_list|>
index|[]
name|addDelegationTokens
parameter_list|(
specifier|final
name|String
name|renewer
parameter_list|,
name|Credentials
name|credentials
parameter_list|)
throws|throws
name|IOException
block|{
name|Token
argument_list|<
name|?
argument_list|>
index|[]
name|tokens
init|=
name|super
operator|.
name|addDelegationTokens
argument_list|(
name|renewer
argument_list|,
name|credentials
argument_list|)
decl_stmt|;
name|URI
name|keyProviderUri
init|=
name|dfs
operator|.
name|getKeyProviderUri
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyProviderUri
operator|!=
literal|null
condition|)
block|{
name|KeyProviderDelegationTokenExtension
name|keyProviderDelegationTokenExtension
init|=
name|KeyProviderDelegationTokenExtension
operator|.
name|createKeyProviderDelegationTokenExtension
argument_list|(
name|dfs
operator|.
name|getKeyProvider
argument_list|()
argument_list|)
decl_stmt|;
name|Token
argument_list|<
name|?
argument_list|>
index|[]
name|kpTokens
init|=
name|keyProviderDelegationTokenExtension
operator|.
name|addDelegationTokens
argument_list|(
name|renewer
argument_list|,
name|credentials
argument_list|)
decl_stmt|;
name|credentials
operator|.
name|addSecretKey
argument_list|(
name|dfs
operator|.
name|getKeyProviderMapKey
argument_list|()
argument_list|,
name|DFSUtilClient
operator|.
name|string2Bytes
argument_list|(
name|keyProviderUri
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokens
operator|!=
literal|null
operator|&&
name|kpTokens
operator|!=
literal|null
condition|)
block|{
name|Token
argument_list|<
name|?
argument_list|>
index|[]
name|all
init|=
operator|new
name|Token
argument_list|<
name|?
argument_list|>
index|[
name|tokens
operator|.
name|length
operator|+
name|kpTokens
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tokens
argument_list|,
literal|0
argument_list|,
name|all
argument_list|,
literal|0
argument_list|,
name|tokens
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|kpTokens
argument_list|,
literal|0
argument_list|,
name|all
argument_list|,
name|tokens
operator|.
name|length
argument_list|,
name|kpTokens
operator|.
name|length
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|all
expr_stmt|;
block|}
else|else
block|{
name|tokens
operator|=
operator|(
name|tokens
operator|!=
literal|null
operator|)
condition|?
name|tokens
else|:
name|kpTokens
expr_stmt|;
block|}
block|}
return|return
name|tokens
return|;
block|}
DECL|method|getInotifyEventStream ()
specifier|public
name|DFSInotifyEventInputStream
name|getInotifyEventStream
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getInotifyEventStream
argument_list|()
return|;
block|}
DECL|method|getInotifyEventStream (long lastReadTxid)
specifier|public
name|DFSInotifyEventInputStream
name|getInotifyEventStream
parameter_list|(
name|long
name|lastReadTxid
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getInotifyEventStream
argument_list|(
name|lastReadTxid
argument_list|)
return|;
block|}
comment|/**    * Set the source path to the specified erasure coding policy.    *    * @param path     The directory to set the policy    * @param ecPolicyName The erasure coding policy name.    * @throws IOException    */
DECL|method|setErasureCodingPolicy (final Path path, final String ecPolicyName)
specifier|public
name|void
name|setErasureCodingPolicy
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|,
specifier|final
name|String
name|ecPolicyName
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|setErasureCodingPolicy
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|,
name|ecPolicyName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|myDfs
operator|.
name|setErasureCodingPolicy
argument_list|(
name|p
argument_list|,
name|ecPolicyName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot setErasureCodingPolicy through a symlink to a "
operator|+
literal|"non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get erasure coding policy information for the specified path    *    * @param path The path of the file or directory    * @return Returns the policy information if file or directory on the path    * is erasure coded, null otherwise. Null will be returned if directory or    * file has REPLICATION policy.    * @throws IOException    */
DECL|method|getErasureCodingPolicy (final Path path)
specifier|public
name|ErasureCodingPolicy
name|getErasureCodingPolicy
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileSystemLinkResolver
argument_list|<
name|ErasureCodingPolicy
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ErasureCodingPolicy
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getErasureCodingPolicy
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ErasureCodingPolicy
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
return|return
name|myDfs
operator|.
name|getErasureCodingPolicy
argument_list|(
name|p
argument_list|)
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot getErasureCodingPolicy through a symlink to a "
operator|+
literal|"non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Retrieve all the erasure coding policies supported by this file system,    * including enabled, disabled and removed policies, but excluding    * REPLICATION policy.    *    * @return all erasure coding policies supported by this file system.    * @throws IOException    */
DECL|method|getAllErasureCodingPolicies ()
specifier|public
name|Collection
argument_list|<
name|ErasureCodingPolicy
argument_list|>
name|getAllErasureCodingPolicies
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|dfs
operator|.
name|getErasureCodingPolicies
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Retrieve all the erasure coding codecs and coders supported by this file    * system.    *    * @return all erasure coding codecs and coders supported by this file system.    * @throws IOException    */
DECL|method|getAllErasureCodingCodecs ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getAllErasureCodingCodecs
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|getErasureCodingCodecs
argument_list|()
return|;
block|}
comment|/**    * Add Erasure coding policies to HDFS. For each policy input, schema and    * cellSize are musts, name and id are ignored. They will be automatically    * created and assigned by Namenode once the policy is successfully added,    * and will be returned in the response; policy states will be set to    * DISABLED automatically.    *    * @param policies The user defined ec policy list to add.    * @return Return the response list of adding operations.    * @throws IOException    */
DECL|method|addErasureCodingPolicies ( ErasureCodingPolicy[] policies)
specifier|public
name|AddErasureCodingPolicyResponse
index|[]
name|addErasureCodingPolicies
parameter_list|(
name|ErasureCodingPolicy
index|[]
name|policies
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|addErasureCodingPolicies
argument_list|(
name|policies
argument_list|)
return|;
block|}
comment|/**    * Remove erasure coding policy.    *    * @param ecPolicyName The name of the policy to be removed.    * @throws IOException    */
DECL|method|removeErasureCodingPolicy (String ecPolicyName)
specifier|public
name|void
name|removeErasureCodingPolicy
parameter_list|(
name|String
name|ecPolicyName
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|removeErasureCodingPolicy
argument_list|(
name|ecPolicyName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Enable erasure coding policy.    *    * @param ecPolicyName The name of the policy to be enabled.    * @throws IOException    */
DECL|method|enableErasureCodingPolicy (String ecPolicyName)
specifier|public
name|void
name|enableErasureCodingPolicy
parameter_list|(
name|String
name|ecPolicyName
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|enableErasureCodingPolicy
argument_list|(
name|ecPolicyName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Disable erasure coding policy.    *    * @param ecPolicyName The name of the policy to be disabled.    * @throws IOException    */
DECL|method|disableErasureCodingPolicy (String ecPolicyName)
specifier|public
name|void
name|disableErasureCodingPolicy
parameter_list|(
name|String
name|ecPolicyName
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|disableErasureCodingPolicy
argument_list|(
name|ecPolicyName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unset the erasure coding policy from the source path.    *    * @param path     The directory to unset the policy    * @throws IOException    */
DECL|method|unsetErasureCodingPolicy (final Path path)
specifier|public
name|void
name|unsetErasureCodingPolicy
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
operator|new
name|FileSystemLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|doCall
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|dfs
operator|.
name|unsetErasureCodingPolicy
argument_list|(
name|getPathName
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|instanceof
name|DistributedFileSystem
condition|)
block|{
name|DistributedFileSystem
name|myDfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
name|myDfs
operator|.
name|unsetErasureCodingPolicy
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot unsetErasureCodingPolicy through a symlink to a "
operator|+
literal|"non-DistributedFileSystem: "
operator|+
name|path
operator|+
literal|" -> "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the root directory of Trash for a path in HDFS.    * 1. File in encryption zone returns /ez1/.Trash/username    * 2. File not in encryption zone, or encountered exception when checking    *    the encryption zone of the path, returns /users/username/.Trash    * Caller appends either Current or checkpoint timestamp for trash destination    * @param path the trash root of the path to be determined.    * @return trash root    */
annotation|@
name|Override
DECL|method|getTrashRoot (Path path)
specifier|public
name|Path
name|getTrashRoot
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
operator|(
name|path
operator|==
literal|null
operator|)
operator|||
operator|!
name|dfs
operator|.
name|isHDFSEncryptionEnabled
argument_list|()
condition|)
block|{
return|return
name|super
operator|.
name|getTrashRoot
argument_list|(
name|path
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while checking whether encryption zone is "
operator|+
literal|"supported"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
name|String
name|parentSrc
init|=
name|path
operator|.
name|isRoot
argument_list|()
condition|?
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
else|:
name|path
operator|.
name|getParent
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
name|EncryptionZone
name|ez
init|=
name|dfs
operator|.
name|getEZForPath
argument_list|(
name|parentSrc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ez
operator|!=
literal|null
operator|)
condition|)
block|{
return|return
name|this
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|ez
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileSystem
operator|.
name|TRASH_PREFIX
argument_list|)
argument_list|,
name|dfs
operator|.
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in checking the encryption zone for the "
operator|+
literal|"path "
operator|+
name|parentSrc
operator|+
literal|". "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|getTrashRoot
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**    * Get all the trash roots of HDFS for current user or for all the users.    * 1. File deleted from non-encryption zone /user/username/.Trash    * 2. File deleted from encryption zones    *    e.g., ez1 rooted at /ez1 has its trash root at /ez1/.Trash/$USER    * @param allUsers return trashRoots of all users if true, used by emptier    * @return trash roots of HDFS    */
annotation|@
name|Override
DECL|method|getTrashRoots (boolean allUsers)
specifier|public
name|Collection
argument_list|<
name|FileStatus
argument_list|>
name|getTrashRoots
parameter_list|(
name|boolean
name|allUsers
parameter_list|)
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Get normal trash roots
name|ret
operator|.
name|addAll
argument_list|(
name|super
operator|.
name|getTrashRoots
argument_list|(
name|allUsers
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Get EZ Trash roots
specifier|final
name|RemoteIterator
argument_list|<
name|EncryptionZone
argument_list|>
name|it
init|=
name|dfs
operator|.
name|listEncryptionZones
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Path
name|ezTrashRoot
init|=
operator|new
name|Path
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileSystem
operator|.
name|TRASH_PREFIX
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|ezTrashRoot
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|allUsers
condition|)
block|{
for|for
control|(
name|FileStatus
name|candidate
range|:
name|listStatus
argument_list|(
name|ezTrashRoot
argument_list|)
control|)
block|{
if|if
condition|(
name|exists
argument_list|(
name|candidate
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|Path
name|userTrash
init|=
operator|new
name|Path
argument_list|(
name|ezTrashRoot
argument_list|,
name|dfs
operator|.
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|ret
operator|.
name|add
argument_list|(
name|getFileStatus
argument_list|(
name|userTrash
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|ignored
parameter_list|)
block|{           }
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot get all encrypted trash roots"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|fixRelativePart (Path p)
specifier|protected
name|Path
name|fixRelativePart
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
return|return
name|super
operator|.
name|fixRelativePart
argument_list|(
name|p
argument_list|)
return|;
block|}
DECL|method|getFsStatistics ()
name|Statistics
name|getFsStatistics
parameter_list|()
block|{
return|return
name|statistics
return|;
block|}
DECL|method|getDFSOpsCountStatistics ()
name|DFSOpsCountStatistics
name|getDFSOpsCountStatistics
parameter_list|()
block|{
return|return
name|storageStatistics
return|;
block|}
comment|/**    * HdfsDataOutputStreamBuilder provides the HDFS-specific capabilities to    * write file on HDFS.    */
DECL|class|HdfsDataOutputStreamBuilder
specifier|public
specifier|static
specifier|final
class|class
name|HdfsDataOutputStreamBuilder
extends|extends
name|FSDataOutputStreamBuilder
argument_list|<
name|FSDataOutputStream
argument_list|,
name|HdfsDataOutputStreamBuilder
argument_list|>
block|{
DECL|field|dfs
specifier|private
specifier|final
name|DistributedFileSystem
name|dfs
decl_stmt|;
DECL|field|favoredNodes
specifier|private
name|InetSocketAddress
index|[]
name|favoredNodes
init|=
literal|null
decl_stmt|;
DECL|field|ecPolicyName
specifier|private
name|String
name|ecPolicyName
init|=
literal|null
decl_stmt|;
comment|/**      * Construct a HdfsDataOutputStream builder for a file.      * @param dfs the {@link DistributedFileSystem} instance.      * @param path the path of the file to create / append.      */
DECL|method|HdfsDataOutputStreamBuilder (DistributedFileSystem dfs, Path path)
specifier|private
name|HdfsDataOutputStreamBuilder
parameter_list|(
name|DistributedFileSystem
name|dfs
parameter_list|,
name|Path
name|path
parameter_list|)
block|{
name|super
argument_list|(
name|dfs
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|dfs
operator|=
name|dfs
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getThisBuilder ()
specifier|protected
name|HdfsDataOutputStreamBuilder
name|getThisBuilder
parameter_list|()
block|{
return|return
name|this
return|;
block|}
DECL|method|getFavoredNodes ()
specifier|private
name|InetSocketAddress
index|[]
name|getFavoredNodes
parameter_list|()
block|{
return|return
name|favoredNodes
return|;
block|}
comment|/**      * Set favored DataNodes.      * @param nodes the addresses of the favored DataNodes.      */
DECL|method|favoredNodes ( @onnull final InetSocketAddress[] nodes)
specifier|public
name|HdfsDataOutputStreamBuilder
name|favoredNodes
parameter_list|(
annotation|@
name|Nonnull
specifier|final
name|InetSocketAddress
index|[]
name|nodes
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|favoredNodes
operator|=
name|nodes
operator|.
name|clone
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Force closed blocks to disk.      *      * @see CreateFlag for the details.      */
DECL|method|syncBlock ()
specifier|public
name|HdfsDataOutputStreamBuilder
name|syncBlock
parameter_list|()
block|{
name|getFlags
argument_list|()
operator|.
name|add
argument_list|(
name|CreateFlag
operator|.
name|SYNC_BLOCK
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Create the block on transient storage if possible.      *      * @see CreateFlag for the details.      */
DECL|method|lazyPersist ()
specifier|public
name|HdfsDataOutputStreamBuilder
name|lazyPersist
parameter_list|()
block|{
name|getFlags
argument_list|()
operator|.
name|add
argument_list|(
name|CreateFlag
operator|.
name|LAZY_PERSIST
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Append data to a new block instead of the end of the last partial block.      *      * @see CreateFlag for the details.      */
DECL|method|newBlock ()
specifier|public
name|HdfsDataOutputStreamBuilder
name|newBlock
parameter_list|()
block|{
name|getFlags
argument_list|()
operator|.
name|add
argument_list|(
name|CreateFlag
operator|.
name|NEW_BLOCK
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Advise that a block replica NOT be written to the local DataNode.      *      * @see CreateFlag for the details.      */
DECL|method|noLocalWrite ()
specifier|public
name|HdfsDataOutputStreamBuilder
name|noLocalWrite
parameter_list|()
block|{
name|getFlags
argument_list|()
operator|.
name|add
argument_list|(
name|CreateFlag
operator|.
name|NO_LOCAL_WRITE
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getEcPolicyName ()
name|String
name|getEcPolicyName
parameter_list|()
block|{
return|return
name|ecPolicyName
return|;
block|}
comment|/**      * Enforce the file to be a striped file with erasure coding policy      * 'policyName', no matter what its parent directory's replication      * or erasure coding policy is. Don't call this function and      * enforceReplicate() in the same builder since they have conflict      * of interest.      */
DECL|method|ecPolicyName ( @onnull final String policyName)
specifier|public
name|HdfsDataOutputStreamBuilder
name|ecPolicyName
parameter_list|(
annotation|@
name|Nonnull
specifier|final
name|String
name|policyName
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|policyName
argument_list|)
expr_stmt|;
name|ecPolicyName
operator|=
name|policyName
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|shouldReplicate ()
name|boolean
name|shouldReplicate
parameter_list|()
block|{
return|return
name|getFlags
argument_list|()
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|SHOULD_REPLICATE
argument_list|)
return|;
block|}
comment|/**      * Enforce the file to be a replicated file, no matter what its parent      * directory's replication or erasure coding policy is. Don't call this      * function and setEcPolicyName() in the same builder since they have      * conflict of interest.      */
DECL|method|replicate ()
specifier|public
name|HdfsDataOutputStreamBuilder
name|replicate
parameter_list|()
block|{
name|getFlags
argument_list|()
operator|.
name|add
argument_list|(
name|CreateFlag
operator|.
name|SHOULD_REPLICATE
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|getFlags ()
specifier|protected
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|getFlags
parameter_list|()
block|{
return|return
name|super
operator|.
name|getFlags
argument_list|()
return|;
block|}
comment|/**      * Build HdfsDataOutputStream to write.      *      * @return a fully-initialized OutputStream.      * @throws IOException on I/O errors.      */
annotation|@
name|Override
DECL|method|build ()
specifier|public
name|FSDataOutputStream
name|build
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|getFlags
argument_list|()
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
operator|||
name|getFlags
argument_list|()
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
condition|)
block|{
if|if
condition|(
name|isRecursive
argument_list|()
condition|)
block|{
return|return
name|dfs
operator|.
name|create
argument_list|(
name|getPath
argument_list|()
argument_list|,
name|getPermission
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getBufferSize
argument_list|()
argument_list|,
name|getReplication
argument_list|()
argument_list|,
name|getBlockSize
argument_list|()
argument_list|,
name|getProgress
argument_list|()
argument_list|,
name|getChecksumOpt
argument_list|()
argument_list|,
name|getFavoredNodes
argument_list|()
argument_list|,
name|getEcPolicyName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|dfs
operator|.
name|createNonRecursive
argument_list|(
name|getPath
argument_list|()
argument_list|,
name|getPermission
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getBufferSize
argument_list|()
argument_list|,
name|getReplication
argument_list|()
argument_list|,
name|getBlockSize
argument_list|()
argument_list|,
name|getProgress
argument_list|()
argument_list|,
name|getChecksumOpt
argument_list|()
argument_list|,
name|getFavoredNodes
argument_list|()
argument_list|,
name|getEcPolicyName
argument_list|()
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|getFlags
argument_list|()
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|APPEND
argument_list|)
condition|)
block|{
return|return
name|dfs
operator|.
name|append
argument_list|(
name|getPath
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getBufferSize
argument_list|()
argument_list|,
name|getProgress
argument_list|()
argument_list|,
name|getFavoredNodes
argument_list|()
argument_list|)
return|;
block|}
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Must specify either create or append"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create a HdfsDataOutputStreamBuilder to create a file on DFS.    * Similar to {@link #create(Path)}, file is overwritten by default.    *    * @param path the path of the file to create.    * @return A HdfsDataOutputStreamBuilder for creating a file.    */
annotation|@
name|Override
DECL|method|createFile (Path path)
specifier|public
name|HdfsDataOutputStreamBuilder
name|createFile
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
operator|new
name|HdfsDataOutputStreamBuilder
argument_list|(
name|this
argument_list|,
name|path
argument_list|)
operator|.
name|create
argument_list|()
operator|.
name|overwrite
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**    * Returns a RemoteIterator which can be used to list all open files    * currently managed by the NameNode. For large numbers of open files,    * iterator will fetch the list in batches of configured size.    *<p/>    * Since the list is fetched in batches, it does not represent a    * consistent snapshot of the all open files.    *<p/>    * This method can only be called by HDFS superusers.    */
DECL|method|listOpenFiles ()
specifier|public
name|RemoteIterator
argument_list|<
name|OpenFileEntry
argument_list|>
name|listOpenFiles
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfs
operator|.
name|listOpenFiles
argument_list|()
return|;
block|}
comment|/**    * Create a {@link HdfsDataOutputStreamBuilder} to append a file on DFS.    *    * @param path file path.    * @return A {@link HdfsDataOutputStreamBuilder} for appending a file.    */
annotation|@
name|Override
DECL|method|appendFile (Path path)
specifier|public
name|HdfsDataOutputStreamBuilder
name|appendFile
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
operator|new
name|HdfsDataOutputStreamBuilder
argument_list|(
name|this
argument_list|,
name|path
argument_list|)
operator|.
name|append
argument_list|()
return|;
block|}
block|}
end_class

end_unit

