begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.client.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
operator|.
name|DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|ShortCircuitFdResponse
operator|.
name|USE_RECEIPT_VERIFICATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteArrayDataOutput
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|mutable
operator|.
name|MutableBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|BlockReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|ClientContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|ExtendedBlockId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|RemotePeerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|ReplicaAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|ReplicaAccessorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|DfsClientConf
operator|.
name|ShortCircuitConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
operator|.
name|DomainPeer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
operator|.
name|Peer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|InvalidEncryptionKeyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|BlockOpResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|PBHelperClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|InvalidBlockTokenException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|CachingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|DomainSocketFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ShortCircuitCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ShortCircuitCache
operator|.
name|ShortCircuitReplicaCreator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ShortCircuitReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ShortCircuitReplicaInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ShortCircuitShm
operator|.
name|Slot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ShortCircuitShm
operator|.
name|SlotId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|IOUtilsClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|unix
operator|.
name|DomainSocket
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|PerformanceAdvisory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Tracer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Utility class to create BlockReader implementations.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockReaderFactory
specifier|public
class|class
name|BlockReaderFactory
implements|implements
name|ShortCircuitReplicaCreator
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BlockReaderFactory
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|class|FailureInjector
specifier|public
specifier|static
class|class
name|FailureInjector
block|{
DECL|method|injectRequestFileDescriptorsFailure ()
specifier|public
name|void
name|injectRequestFileDescriptorsFailure
parameter_list|()
throws|throws
name|IOException
block|{
comment|// do nothing
block|}
DECL|method|getSupportsReceiptVerification ()
specifier|public
name|boolean
name|getSupportsReceiptVerification
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|ShortCircuitReplicaCreator
DECL|field|createShortCircuitReplicaInfoCallback
name|createShortCircuitReplicaInfoCallback
init|=
literal|null
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|DfsClientConf
name|conf
decl_stmt|;
comment|/**    * Injects failures into specific operations during unit tests.    */
DECL|field|failureInjector
specifier|private
specifier|static
name|FailureInjector
name|failureInjector
init|=
operator|new
name|FailureInjector
argument_list|()
decl_stmt|;
comment|/**    * The file name, for logging and debugging purposes.    */
DECL|field|fileName
specifier|private
name|String
name|fileName
decl_stmt|;
comment|/**    * The block ID and block pool ID to use.    */
DECL|field|block
specifier|private
name|ExtendedBlock
name|block
decl_stmt|;
comment|/**    * The block token to use for security purposes.    */
DECL|field|token
specifier|private
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|token
decl_stmt|;
comment|/**    * The offset within the block to start reading at.    */
DECL|field|startOffset
specifier|private
name|long
name|startOffset
decl_stmt|;
comment|/**    * If false, we won't try to verify the block checksum.    */
DECL|field|verifyChecksum
specifier|private
name|boolean
name|verifyChecksum
decl_stmt|;
comment|/**    * The name of this client.    */
DECL|field|clientName
specifier|private
name|String
name|clientName
decl_stmt|;
comment|/**    * The DataNode we're talking to.    */
DECL|field|datanode
specifier|private
name|DatanodeInfo
name|datanode
decl_stmt|;
comment|/**    * StorageType of replica on DataNode.    */
DECL|field|storageType
specifier|private
name|StorageType
name|storageType
decl_stmt|;
comment|/**    * If false, we won't try short-circuit local reads.    */
DECL|field|allowShortCircuitLocalReads
specifier|private
name|boolean
name|allowShortCircuitLocalReads
decl_stmt|;
comment|/**    * The ClientContext to use for things like the PeerCache.    */
DECL|field|clientContext
specifier|private
name|ClientContext
name|clientContext
decl_stmt|;
comment|/**    * Number of bytes to read. Must be set to a non-negative value.    */
DECL|field|length
specifier|private
name|long
name|length
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Caching strategy to use when reading the block.    */
DECL|field|cachingStrategy
specifier|private
name|CachingStrategy
name|cachingStrategy
decl_stmt|;
comment|/**    * Socket address to use to connect to peer.    */
DECL|field|inetSocketAddress
specifier|private
name|InetSocketAddress
name|inetSocketAddress
decl_stmt|;
comment|/**    * Remote peer factory to use to create a peer, if needed.    */
DECL|field|remotePeerFactory
specifier|private
name|RemotePeerFactory
name|remotePeerFactory
decl_stmt|;
comment|/**    * UserGroupInformation to use for legacy block reader local objects,    * if needed.    */
DECL|field|userGroupInformation
specifier|private
name|UserGroupInformation
name|userGroupInformation
decl_stmt|;
comment|/**    * Configuration to use for legacy block reader local objects, if needed.    */
DECL|field|configuration
specifier|private
name|Configuration
name|configuration
decl_stmt|;
comment|/**    * The HTrace tracer to use.    */
DECL|field|tracer
specifier|private
name|Tracer
name|tracer
decl_stmt|;
comment|/**    * Information about the domain socket path we should use to connect to the    * local peer-- or null if we haven't examined the local domain socket.    */
DECL|field|pathInfo
specifier|private
name|DomainSocketFactory
operator|.
name|PathInfo
name|pathInfo
decl_stmt|;
comment|/**    * The remaining number of times that we'll try to pull a socket out of the    * cache.    */
DECL|field|remainingCacheTries
specifier|private
name|int
name|remainingCacheTries
decl_stmt|;
DECL|method|BlockReaderFactory (DfsClientConf conf)
specifier|public
name|BlockReaderFactory
parameter_list|(
name|DfsClientConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|remainingCacheTries
operator|=
name|conf
operator|.
name|getNumCachedConnRetry
argument_list|()
expr_stmt|;
block|}
DECL|method|setFileName (String fileName)
specifier|public
name|BlockReaderFactory
name|setFileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBlock (ExtendedBlock block)
specifier|public
name|BlockReaderFactory
name|setBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBlockToken (Token<BlockTokenIdentifier> token)
specifier|public
name|BlockReaderFactory
name|setBlockToken
parameter_list|(
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
name|this
operator|.
name|token
operator|=
name|token
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setStartOffset (long startOffset)
specifier|public
name|BlockReaderFactory
name|setStartOffset
parameter_list|(
name|long
name|startOffset
parameter_list|)
block|{
name|this
operator|.
name|startOffset
operator|=
name|startOffset
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setVerifyChecksum (boolean verifyChecksum)
specifier|public
name|BlockReaderFactory
name|setVerifyChecksum
parameter_list|(
name|boolean
name|verifyChecksum
parameter_list|)
block|{
name|this
operator|.
name|verifyChecksum
operator|=
name|verifyChecksum
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setClientName (String clientName)
specifier|public
name|BlockReaderFactory
name|setClientName
parameter_list|(
name|String
name|clientName
parameter_list|)
block|{
name|this
operator|.
name|clientName
operator|=
name|clientName
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setDatanodeInfo (DatanodeInfo datanode)
specifier|public
name|BlockReaderFactory
name|setDatanodeInfo
parameter_list|(
name|DatanodeInfo
name|datanode
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setStorageType (StorageType storageType)
specifier|public
name|BlockReaderFactory
name|setStorageType
parameter_list|(
name|StorageType
name|storageType
parameter_list|)
block|{
name|this
operator|.
name|storageType
operator|=
name|storageType
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setAllowShortCircuitLocalReads ( boolean allowShortCircuitLocalReads)
specifier|public
name|BlockReaderFactory
name|setAllowShortCircuitLocalReads
parameter_list|(
name|boolean
name|allowShortCircuitLocalReads
parameter_list|)
block|{
name|this
operator|.
name|allowShortCircuitLocalReads
operator|=
name|allowShortCircuitLocalReads
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setClientCacheContext ( ClientContext clientContext)
specifier|public
name|BlockReaderFactory
name|setClientCacheContext
parameter_list|(
name|ClientContext
name|clientContext
parameter_list|)
block|{
name|this
operator|.
name|clientContext
operator|=
name|clientContext
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setLength (long length)
specifier|public
name|BlockReaderFactory
name|setLength
parameter_list|(
name|long
name|length
parameter_list|)
block|{
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setCachingStrategy ( CachingStrategy cachingStrategy)
specifier|public
name|BlockReaderFactory
name|setCachingStrategy
parameter_list|(
name|CachingStrategy
name|cachingStrategy
parameter_list|)
block|{
name|this
operator|.
name|cachingStrategy
operator|=
name|cachingStrategy
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setInetSocketAddress ( InetSocketAddress inetSocketAddress)
specifier|public
name|BlockReaderFactory
name|setInetSocketAddress
parameter_list|(
name|InetSocketAddress
name|inetSocketAddress
parameter_list|)
block|{
name|this
operator|.
name|inetSocketAddress
operator|=
name|inetSocketAddress
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setUserGroupInformation ( UserGroupInformation userGroupInformation)
specifier|public
name|BlockReaderFactory
name|setUserGroupInformation
parameter_list|(
name|UserGroupInformation
name|userGroupInformation
parameter_list|)
block|{
name|this
operator|.
name|userGroupInformation
operator|=
name|userGroupInformation
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setRemotePeerFactory ( RemotePeerFactory remotePeerFactory)
specifier|public
name|BlockReaderFactory
name|setRemotePeerFactory
parameter_list|(
name|RemotePeerFactory
name|remotePeerFactory
parameter_list|)
block|{
name|this
operator|.
name|remotePeerFactory
operator|=
name|remotePeerFactory
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setConfiguration ( Configuration configuration)
specifier|public
name|BlockReaderFactory
name|setConfiguration
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
name|this
operator|.
name|configuration
operator|=
name|configuration
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setTracer (Tracer tracer)
specifier|public
name|BlockReaderFactory
name|setTracer
parameter_list|(
name|Tracer
name|tracer
parameter_list|)
block|{
name|this
operator|.
name|tracer
operator|=
name|tracer
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setFailureInjectorForTesting (FailureInjector injector)
specifier|public
specifier|static
name|void
name|setFailureInjectorForTesting
parameter_list|(
name|FailureInjector
name|injector
parameter_list|)
block|{
name|failureInjector
operator|=
name|injector
expr_stmt|;
block|}
comment|/**    * Build a BlockReader with the given options.    *    * This function will do the best it can to create a block reader that meets    * all of our requirements.  We prefer short-circuit block readers    * (BlockReaderLocal and BlockReaderLocalLegacy) over remote ones, since the    * former avoid the overhead of socket communication.  If short-circuit is    * unavailable, our next fallback is data transfer over UNIX domain sockets,    * if dfs.client.domain.socket.data.traffic has been enabled.  If that doesn't    * work, we will try to create a remote block reader that operates over TCP    * sockets.    *    * There are a few caches that are important here.    *    * The ShortCircuitCache stores file descriptor objects which have been passed    * from the DataNode.    *    * The DomainSocketFactory stores information about UNIX domain socket paths    * that we not been able to use in the past, so that we don't waste time    * retrying them over and over.  (Like all the caches, it does have a timeout,    * though.)    *    * The PeerCache stores peers that we have used in the past.  If we can reuse    * one of these peers, we avoid the overhead of re-opening a socket.  However,    * if the socket has been timed out on the remote end, our attempt to reuse    * the socket may end with an IOException.  For that reason, we limit our    * attempts at socket reuse to dfs.client.cached.conn.retry times.  After    * that, we create new sockets.  This avoids the problem where a thread tries    * to talk to a peer that it hasn't talked to in a while, and has to clean out    * every entry in a socket cache full of stale entries.    *    * @return The new BlockReader.  We will not return null.    *    * @throws InvalidToken    *             If the block token was invalid.    *         InvalidEncryptionKeyException    *             If the encryption key was invalid.    *         Other IOException    *             If there was another problem.    */
DECL|method|build ()
specifier|public
name|BlockReader
name|build
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|length
operator|>=
literal|0
argument_list|,
literal|"Length must be set to a non-negative value"
argument_list|)
expr_stmt|;
name|BlockReader
name|reader
init|=
name|tryToCreateExternalBlockReader
argument_list|()
decl_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
return|return
name|reader
return|;
block|}
specifier|final
name|ShortCircuitConf
name|scConf
init|=
name|conf
operator|.
name|getShortCircuitConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|scConf
operator|.
name|isShortCircuitLocalReads
argument_list|()
operator|&&
name|allowShortCircuitLocalReads
condition|)
block|{
if|if
condition|(
name|clientContext
operator|.
name|getUseLegacyBlockReaderLocal
argument_list|()
condition|)
block|{
name|reader
operator|=
name|getLegacyBlockReaderLocal
argument_list|()
expr_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: returning new legacy block reader local."
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
name|reader
return|;
block|}
block|}
else|else
block|{
name|reader
operator|=
name|getBlockReaderLocal
argument_list|()
expr_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: returning new block reader local."
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
name|reader
return|;
block|}
block|}
block|}
if|if
condition|(
name|scConf
operator|.
name|isDomainSocketDataTraffic
argument_list|()
condition|)
block|{
name|reader
operator|=
name|getRemoteBlockReaderFromDomain
argument_list|()
expr_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: returning new remote block reader using UNIX domain "
operator|+
literal|"socket on {}"
argument_list|,
name|this
argument_list|,
name|pathInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|reader
return|;
block|}
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|DFSInputStream
operator|.
name|tcpReadsDisabledForTesting
argument_list|,
literal|"TCP reads were disabled for testing, but we failed to "
operator|+
literal|"do a non-TCP read."
argument_list|)
expr_stmt|;
return|return
name|getRemoteBlockReaderFromTcp
argument_list|()
return|;
block|}
DECL|method|tryToCreateExternalBlockReader ()
specifier|private
name|BlockReader
name|tryToCreateExternalBlockReader
parameter_list|()
block|{
name|List
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|ReplicaAccessorBuilder
argument_list|>
argument_list|>
name|clses
init|=
name|conf
operator|.
name|getReplicaAccessorBuilderClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
extends|extends
name|ReplicaAccessorBuilder
argument_list|>
name|cls
range|:
name|clses
control|)
block|{
try|try
block|{
name|ByteArrayDataOutput
name|bado
init|=
name|ByteStreams
operator|.
name|newDataOutput
argument_list|()
decl_stmt|;
name|token
operator|.
name|write
argument_list|(
name|bado
argument_list|)
expr_stmt|;
name|byte
name|tokenBytes
index|[]
init|=
name|bado
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|Constructor
argument_list|<
name|?
extends|extends
name|ReplicaAccessorBuilder
argument_list|>
name|ctor
init|=
name|cls
operator|.
name|getConstructor
argument_list|()
decl_stmt|;
name|ReplicaAccessorBuilder
name|builder
init|=
name|ctor
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|long
name|visibleLength
init|=
name|startOffset
operator|+
name|length
decl_stmt|;
name|ReplicaAccessor
name|accessor
init|=
name|builder
operator|.
name|setAllowShortCircuitReads
argument_list|(
name|allowShortCircuitLocalReads
argument_list|)
operator|.
name|setBlock
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
operator|.
name|setGenerationStamp
argument_list|(
name|block
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
operator|.
name|setBlockAccessToken
argument_list|(
name|tokenBytes
argument_list|)
operator|.
name|setClientName
argument_list|(
name|clientName
argument_list|)
operator|.
name|setConfiguration
argument_list|(
name|configuration
argument_list|)
operator|.
name|setFileName
argument_list|(
name|fileName
argument_list|)
operator|.
name|setVerifyChecksum
argument_list|(
name|verifyChecksum
argument_list|)
operator|.
name|setVisibleLength
argument_list|(
name|visibleLength
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|accessor
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: No ReplicaAccessor created by {}"
argument_list|,
name|this
argument_list|,
name|cls
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|new
name|ExternalBlockReader
argument_list|(
name|accessor
argument_list|,
name|visibleLength
argument_list|,
name|startOffset
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to construct new object of type "
operator|+
name|cls
operator|.
name|getName
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get {@link BlockReaderLocalLegacy} for short circuited local reads.    * This block reader implements the path-based style of local reads    * first introduced in HDFS-2246.    */
DECL|method|getLegacyBlockReaderLocal ()
specifier|private
name|BlockReader
name|getLegacyBlockReaderLocal
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: trying to construct BlockReaderLocalLegacy"
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DFSUtilClient
operator|.
name|isLocalAddress
argument_list|(
name|inetSocketAddress
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: can't construct BlockReaderLocalLegacy because the address"
operator|+
literal|"{} is not local"
argument_list|,
name|this
argument_list|,
name|inetSocketAddress
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|clientContext
operator|.
name|getDisableLegacyBlockReaderLocal
argument_list|()
condition|)
block|{
name|PerformanceAdvisory
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: can't construct "
operator|+
literal|"BlockReaderLocalLegacy because "
operator|+
literal|"disableLegacyBlockReaderLocal is set."
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|IOException
name|ioe
decl_stmt|;
try|try
block|{
return|return
name|BlockReaderLocalLegacy
operator|.
name|newBlockReader
argument_list|(
name|conf
argument_list|,
name|userGroupInformation
argument_list|,
name|configuration
argument_list|,
name|fileName
argument_list|,
name|block
argument_list|,
name|token
argument_list|,
name|datanode
argument_list|,
name|startOffset
argument_list|,
name|length
argument_list|,
name|storageType
argument_list|,
name|tracer
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|remoteException
parameter_list|)
block|{
name|ioe
operator|=
name|remoteException
operator|.
name|unwrapRemoteException
argument_list|(
name|InvalidToken
operator|.
name|class
argument_list|,
name|AccessControlException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ioe
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
operator|(
name|ioe
operator|instanceof
name|AccessControlException
operator|)
operator|)
operator|&&
name|isSecurityException
argument_list|(
name|ioe
argument_list|)
condition|)
block|{
comment|// Handle security exceptions.
comment|// We do not handle AccessControlException here, since
comment|// BlockReaderLocalLegacy#newBlockReader uses that exception to indicate
comment|// that the user is not in dfs.block.local-path-access.user, a condition
comment|// which requires us to disable legacy SCR.
throw|throw
name|ioe
throw|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|+
literal|": error creating legacy BlockReaderLocal.  "
operator|+
literal|"Disabling legacy local reads."
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|clientContext
operator|.
name|setDisableLegacyBlockReaderLocal
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
DECL|method|getBlockReaderLocal ()
specifier|private
name|BlockReader
name|getBlockReaderLocal
parameter_list|()
throws|throws
name|InvalidToken
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: trying to construct a BlockReaderLocal for short-circuit "
operator|+
literal|" reads."
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathInfo
operator|==
literal|null
condition|)
block|{
name|pathInfo
operator|=
name|clientContext
operator|.
name|getDomainSocketFactory
argument_list|()
operator|.
name|getPathInfo
argument_list|(
name|inetSocketAddress
argument_list|,
name|conf
operator|.
name|getShortCircuitConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pathInfo
operator|.
name|getPathState
argument_list|()
operator|.
name|getUsableForShortCircuit
argument_list|()
condition|)
block|{
name|PerformanceAdvisory
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: {} is not usable for short circuit; "
operator|+
literal|"giving up on BlockReaderLocal."
argument_list|,
name|this
argument_list|,
name|pathInfo
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ShortCircuitCache
name|cache
init|=
name|clientContext
operator|.
name|getShortCircuitCache
argument_list|()
decl_stmt|;
name|ExtendedBlockId
name|key
init|=
operator|new
name|ExtendedBlockId
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|ShortCircuitReplicaInfo
name|info
init|=
name|cache
operator|.
name|fetchOrCreate
argument_list|(
name|key
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|InvalidToken
name|exc
init|=
name|info
operator|.
name|getInvalidTokenException
argument_list|()
decl_stmt|;
if|if
condition|(
name|exc
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: got InvalidToken exception while trying to construct "
operator|+
literal|"BlockReaderLocal via {}"
argument_list|,
name|this
argument_list|,
name|pathInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|exc
throw|;
block|}
if|if
condition|(
name|info
operator|.
name|getReplica
argument_list|()
operator|==
literal|null
condition|)
block|{
name|PerformanceAdvisory
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: failed to get "
operator|+
literal|"ShortCircuitReplica. Cannot construct "
operator|+
literal|"BlockReaderLocal via {}"
argument_list|,
name|this
argument_list|,
name|pathInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|new
name|BlockReaderLocal
operator|.
name|Builder
argument_list|(
name|conf
operator|.
name|getShortCircuitConf
argument_list|()
argument_list|)
operator|.
name|setFilename
argument_list|(
name|fileName
argument_list|)
operator|.
name|setBlock
argument_list|(
name|block
argument_list|)
operator|.
name|setStartOffset
argument_list|(
name|startOffset
argument_list|)
operator|.
name|setShortCircuitReplica
argument_list|(
name|info
operator|.
name|getReplica
argument_list|()
argument_list|)
operator|.
name|setVerifyChecksum
argument_list|(
name|verifyChecksum
argument_list|)
operator|.
name|setCachingStrategy
argument_list|(
name|cachingStrategy
argument_list|)
operator|.
name|setStorageType
argument_list|(
name|storageType
argument_list|)
operator|.
name|setTracer
argument_list|(
name|tracer
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Fetch a pair of short-circuit block descriptors from a local DataNode.    *    * @return    Null if we could not communicate with the datanode,    *            a new ShortCircuitReplicaInfo object otherwise.    *            ShortCircuitReplicaInfo objects may contain either an    *            InvalidToken exception, or a ShortCircuitReplica object ready to    *            use.    */
annotation|@
name|Override
DECL|method|createShortCircuitReplicaInfo ()
specifier|public
name|ShortCircuitReplicaInfo
name|createShortCircuitReplicaInfo
parameter_list|()
block|{
if|if
condition|(
name|createShortCircuitReplicaInfoCallback
operator|!=
literal|null
condition|)
block|{
name|ShortCircuitReplicaInfo
name|info
init|=
name|createShortCircuitReplicaInfoCallback
operator|.
name|createShortCircuitReplicaInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
return|return
name|info
return|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: trying to create ShortCircuitReplicaInfo."
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|BlockReaderPeer
name|curPeer
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|curPeer
operator|=
name|nextDomainPeer
argument_list|()
expr_stmt|;
if|if
condition|(
name|curPeer
operator|==
literal|null
condition|)
break|break;
if|if
condition|(
name|curPeer
operator|.
name|fromCache
condition|)
name|remainingCacheTries
operator|--
expr_stmt|;
name|DomainPeer
name|peer
init|=
operator|(
name|DomainPeer
operator|)
name|curPeer
operator|.
name|peer
decl_stmt|;
name|Slot
name|slot
init|=
literal|null
decl_stmt|;
name|ShortCircuitCache
name|cache
init|=
name|clientContext
operator|.
name|getShortCircuitCache
argument_list|()
decl_stmt|;
try|try
block|{
name|MutableBoolean
name|usedPeer
init|=
operator|new
name|MutableBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|slot
operator|=
name|cache
operator|.
name|allocShmSlot
argument_list|(
name|datanode
argument_list|,
name|peer
argument_list|,
name|usedPeer
argument_list|,
operator|new
name|ExtendedBlockId
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
argument_list|,
name|clientName
argument_list|)
expr_stmt|;
if|if
condition|(
name|usedPeer
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: allocShmSlot used up our previous socket {}.  "
operator|+
literal|"Allocating a new one..."
argument_list|,
name|this
argument_list|,
name|peer
operator|.
name|getDomainSocket
argument_list|()
argument_list|)
expr_stmt|;
name|curPeer
operator|=
name|nextDomainPeer
argument_list|()
expr_stmt|;
if|if
condition|(
name|curPeer
operator|==
literal|null
condition|)
break|break;
name|peer
operator|=
operator|(
name|DomainPeer
operator|)
name|curPeer
operator|.
name|peer
expr_stmt|;
block|}
name|ShortCircuitReplicaInfo
name|info
init|=
name|requestFileDescriptors
argument_list|(
name|peer
argument_list|,
name|slot
argument_list|)
decl_stmt|;
name|clientContext
operator|.
name|getPeerCache
argument_list|()
operator|.
name|put
argument_list|(
name|datanode
argument_list|,
name|peer
argument_list|)
expr_stmt|;
return|return
name|info
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|!=
literal|null
condition|)
block|{
name|cache
operator|.
name|freeSlot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curPeer
operator|.
name|fromCache
condition|)
block|{
comment|// Handle an I/O error we got when using a cached socket.
comment|// These are considered less serious, because the socket may be stale.
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: closing stale domain peer {}"
argument_list|,
name|this
argument_list|,
name|peer
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|IOUtilsClient
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Handle an I/O error we got when using a newly created socket.
comment|// We temporarily disable the domain socket path for a few minutes in
comment|// this case, to prevent wasting more time on it.
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|+
literal|": I/O error requesting file descriptors.  "
operator|+
literal|"Disabling domain socket "
operator|+
name|peer
operator|.
name|getDomainSocket
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|IOUtilsClient
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|clientContext
operator|.
name|getDomainSocketFactory
argument_list|()
operator|.
name|disableDomainSocketPath
argument_list|(
name|pathInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Request file descriptors from a DomainPeer.    *    * @param peer   The peer to use for communication.    * @param slot   If non-null, the shared memory slot to associate with the    *               new ShortCircuitReplica.    *    * @return  A ShortCircuitReplica object if we could communicate with the    *          datanode; null, otherwise.    * @throws  IOException If we encountered an I/O exception while communicating    *          with the datanode.    */
DECL|method|requestFileDescriptors (DomainPeer peer, Slot slot)
specifier|private
name|ShortCircuitReplicaInfo
name|requestFileDescriptors
parameter_list|(
name|DomainPeer
name|peer
parameter_list|,
name|Slot
name|slot
parameter_list|)
throws|throws
name|IOException
block|{
name|ShortCircuitCache
name|cache
init|=
name|clientContext
operator|.
name|getShortCircuitCache
argument_list|()
decl_stmt|;
specifier|final
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|peer
operator|.
name|getOutputStream
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|SlotId
name|slotId
init|=
name|slot
operator|==
literal|null
condition|?
literal|null
else|:
name|slot
operator|.
name|getSlotId
argument_list|()
decl_stmt|;
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|requestShortCircuitFds
argument_list|(
name|block
argument_list|,
name|token
argument_list|,
name|slotId
argument_list|,
literal|1
argument_list|,
name|failureInjector
operator|.
name|getSupportsReceiptVerification
argument_list|()
argument_list|)
expr_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|peer
operator|.
name|getInputStream
argument_list|()
argument_list|)
decl_stmt|;
name|BlockOpResponseProto
name|resp
init|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|PBHelperClient
operator|.
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
name|DomainSocket
name|sock
init|=
name|peer
operator|.
name|getDomainSocket
argument_list|()
decl_stmt|;
name|failureInjector
operator|.
name|injectRequestFileDescriptorsFailure
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|resp
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|SUCCESS
case|:
name|byte
name|buf
index|[]
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|FileInputStream
index|[]
name|fis
init|=
operator|new
name|FileInputStream
index|[
literal|2
index|]
decl_stmt|;
name|sock
operator|.
name|recvFileInputStreams
argument_list|(
name|fis
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|ShortCircuitReplica
name|replica
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ExtendedBlockId
name|key
init|=
operator|new
name|ExtendedBlockId
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
name|USE_RECEIPT_VERIFICATION
operator|.
name|getNumber
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Sending receipt verification byte for slot {}"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|sock
operator|.
name|getOutputStream
argument_list|()
operator|.
name|write
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|replica
operator|=
operator|new
name|ShortCircuitReplica
argument_list|(
name|key
argument_list|,
name|fis
index|[
literal|0
index|]
argument_list|,
name|fis
index|[
literal|1
index|]
argument_list|,
name|cache
argument_list|,
name|Time
operator|.
name|monotonicNow
argument_list|()
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return
operator|new
name|ShortCircuitReplicaInfo
argument_list|(
name|replica
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// This indicates an error reading from disk, or a format error.  Since
comment|// it's not a socket communication problem, we return null rather than
comment|// throwing an exception.
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|+
literal|": error creating ShortCircuitReplica."
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
name|IOUtilsClient
operator|.
name|cleanup
argument_list|(
name|DFSClient
operator|.
name|LOG
argument_list|,
name|fis
index|[
literal|0
index|]
argument_list|,
name|fis
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|ERROR_UNSUPPORTED
case|:
if|if
condition|(
operator|!
name|resp
operator|.
name|hasShortCircuitAccessVersion
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"short-circuit read access is disabled for "
operator|+
literal|"DataNode "
operator|+
name|datanode
operator|+
literal|".  reason: "
operator|+
name|resp
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|clientContext
operator|.
name|getDomainSocketFactory
argument_list|()
operator|.
name|disableShortCircuitForPath
argument_list|(
name|pathInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"short-circuit read access for the file "
operator|+
name|fileName
operator|+
literal|" is disabled for DataNode "
operator|+
name|datanode
operator|+
literal|".  reason: "
operator|+
name|resp
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
case|case
name|ERROR_ACCESS_TOKEN
case|:
name|String
name|msg
init|=
literal|"access control error while "
operator|+
literal|"attempting to set up short-circuit access to "
operator|+
name|fileName
operator|+
name|resp
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}:{}"
argument_list|,
name|this
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|new
name|ShortCircuitReplicaInfo
argument_list|(
operator|new
name|InvalidToken
argument_list|(
name|msg
argument_list|)
argument_list|)
return|;
default|default:
specifier|final
name|long
name|expiration
init|=
name|clientContext
operator|.
name|getDomainSocketFactory
argument_list|()
operator|.
name|getPathExpireSeconds
argument_list|()
decl_stmt|;
name|String
name|disableMsg
init|=
literal|"disabled temporarily for "
operator|+
name|expiration
operator|+
literal|" seconds"
decl_stmt|;
if|if
condition|(
name|expiration
operator|==
literal|0
condition|)
block|{
name|disableMsg
operator|=
literal|"not disabled"
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}: unknown response code {} while attempting to set up "
operator|+
literal|"short-circuit access. {}. Short-circuit read for "
operator|+
literal|"DataNode {} is {} based on {}."
argument_list|,
name|this
argument_list|,
name|resp
operator|.
name|getStatus
argument_list|()
argument_list|,
name|resp
operator|.
name|getMessage
argument_list|()
argument_list|,
name|datanode
argument_list|,
name|disableMsg
argument_list|,
name|DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY
argument_list|)
expr_stmt|;
name|clientContext
operator|.
name|getDomainSocketFactory
argument_list|()
operator|.
name|disableShortCircuitForPath
argument_list|(
name|pathInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get a BlockReaderRemote that communicates over a UNIX domain socket.    *    * @return The new BlockReader, or null if we failed to create the block    * reader.    *    * @throws InvalidToken    If the block token was invalid.    * Potentially other security-related execptions.    */
DECL|method|getRemoteBlockReaderFromDomain ()
specifier|private
name|BlockReader
name|getRemoteBlockReaderFromDomain
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pathInfo
operator|==
literal|null
condition|)
block|{
name|pathInfo
operator|=
name|clientContext
operator|.
name|getDomainSocketFactory
argument_list|()
operator|.
name|getPathInfo
argument_list|(
name|inetSocketAddress
argument_list|,
name|conf
operator|.
name|getShortCircuitConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pathInfo
operator|.
name|getPathState
argument_list|()
operator|.
name|getUsableForDataTransfer
argument_list|()
condition|)
block|{
name|PerformanceAdvisory
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: not trying to create a "
operator|+
literal|"remote block reader because the UNIX domain socket at {}"
operator|+
literal|" is not usable."
argument_list|,
name|this
argument_list|,
name|pathInfo
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: trying to create a remote block reader from the UNIX domain "
operator|+
literal|"socket at {}"
argument_list|,
name|this
argument_list|,
name|pathInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|BlockReaderPeer
name|curPeer
init|=
name|nextDomainPeer
argument_list|()
decl_stmt|;
if|if
condition|(
name|curPeer
operator|==
literal|null
condition|)
break|break;
if|if
condition|(
name|curPeer
operator|.
name|fromCache
condition|)
name|remainingCacheTries
operator|--
expr_stmt|;
name|DomainPeer
name|peer
init|=
operator|(
name|DomainPeer
operator|)
name|curPeer
operator|.
name|peer
decl_stmt|;
name|BlockReader
name|blockReader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|blockReader
operator|=
name|getRemoteBlockReader
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return
name|blockReader
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|IOUtilsClient
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSecurityException
argument_list|(
name|ioe
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: got security exception while constructing a remote "
operator|+
literal|" block reader from the unix domain socket at {}"
argument_list|,
name|this
argument_list|,
name|pathInfo
operator|.
name|getPath
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
if|if
condition|(
name|curPeer
operator|.
name|fromCache
condition|)
block|{
comment|// Handle an I/O error we got when using a cached peer.  These are
comment|// considered less serious because the underlying socket may be stale.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closed potentially stale domain peer {}"
argument_list|,
name|peer
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Handle an I/O error we got when using a newly created domain peer.
comment|// We temporarily disable the domain socket path for a few minutes in
comment|// this case, to prevent wasting more time on it.
name|LOG
operator|.
name|warn
argument_list|(
literal|"I/O error constructing remote block reader.  Disabling "
operator|+
literal|"domain socket "
operator|+
name|peer
operator|.
name|getDomainSocket
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|clientContext
operator|.
name|getDomainSocketFactory
argument_list|()
operator|.
name|disableDomainSocketPath
argument_list|(
name|pathInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|blockReader
operator|==
literal|null
condition|)
block|{
name|IOUtilsClient
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get a BlockReaderRemote that communicates over a TCP socket.    *    * @return The new BlockReader.  We will not return null, but instead throw    *         an exception if this fails.    *    * @throws InvalidToken    *             If the block token was invalid.    *         InvalidEncryptionKeyException    *             If the encryption key was invalid.    *         Other IOException    *             If there was another problem.    */
DECL|method|getRemoteBlockReaderFromTcp ()
specifier|private
name|BlockReader
name|getRemoteBlockReaderFromTcp
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: trying to create a remote block reader from a TCP socket"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|BlockReader
name|blockReader
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|BlockReaderPeer
name|curPeer
init|=
literal|null
decl_stmt|;
name|Peer
name|peer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|curPeer
operator|=
name|nextTcpPeer
argument_list|()
expr_stmt|;
if|if
condition|(
name|curPeer
operator|.
name|fromCache
condition|)
name|remainingCacheTries
operator|--
expr_stmt|;
name|peer
operator|=
name|curPeer
operator|.
name|peer
expr_stmt|;
name|blockReader
operator|=
name|getRemoteBlockReader
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return
name|blockReader
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|isSecurityException
argument_list|(
name|ioe
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"{}: got security exception while constructing a remote "
operator|+
literal|"block reader from {}"
argument_list|,
name|this
argument_list|,
name|peer
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
if|if
condition|(
operator|(
name|curPeer
operator|!=
literal|null
operator|)
operator|&&
name|curPeer
operator|.
name|fromCache
condition|)
block|{
comment|// Handle an I/O error we got when using a cached peer.  These are
comment|// considered less serious, because the underlying socket may be
comment|// stale.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closed potentially stale remote peer {}"
argument_list|,
name|peer
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Handle an I/O error we got when using a newly created peer.
name|LOG
operator|.
name|warn
argument_list|(
literal|"I/O error constructing remote block reader."
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|blockReader
operator|==
literal|null
condition|)
block|{
name|IOUtilsClient
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|BlockReaderPeer
specifier|public
specifier|static
class|class
name|BlockReaderPeer
block|{
DECL|field|peer
specifier|final
name|Peer
name|peer
decl_stmt|;
DECL|field|fromCache
specifier|final
name|boolean
name|fromCache
decl_stmt|;
DECL|method|BlockReaderPeer (Peer peer, boolean fromCache)
name|BlockReaderPeer
parameter_list|(
name|Peer
name|peer
parameter_list|,
name|boolean
name|fromCache
parameter_list|)
block|{
name|this
operator|.
name|peer
operator|=
name|peer
expr_stmt|;
name|this
operator|.
name|fromCache
operator|=
name|fromCache
expr_stmt|;
block|}
block|}
comment|/**    * Get the next DomainPeer-- either from the cache or by creating it.    *    * @return the next DomainPeer, or null if we could not construct one.    */
DECL|method|nextDomainPeer ()
specifier|private
name|BlockReaderPeer
name|nextDomainPeer
parameter_list|()
block|{
if|if
condition|(
name|remainingCacheTries
operator|>
literal|0
condition|)
block|{
name|Peer
name|peer
init|=
name|clientContext
operator|.
name|getPeerCache
argument_list|()
operator|.
name|get
argument_list|(
name|datanode
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|peer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"nextDomainPeer: reusing existing peer {}"
argument_list|,
name|peer
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlockReaderPeer
argument_list|(
name|peer
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
name|DomainSocket
name|sock
init|=
name|clientContext
operator|.
name|getDomainSocketFactory
argument_list|()
operator|.
name|createSocket
argument_list|(
name|pathInfo
argument_list|,
name|conf
operator|.
name|getSocketTimeout
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sock
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|BlockReaderPeer
argument_list|(
operator|new
name|DomainPeer
argument_list|(
name|sock
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Get the next TCP-based peer-- either from the cache or by creating it.    *    * @return the next Peer, or null if we could not construct one.    *    * @throws IOException  If there was an error while constructing the peer    *                      (such as an InvalidEncryptionKeyException)    */
DECL|method|nextTcpPeer ()
specifier|private
name|BlockReaderPeer
name|nextTcpPeer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|remainingCacheTries
operator|>
literal|0
condition|)
block|{
name|Peer
name|peer
init|=
name|clientContext
operator|.
name|getPeerCache
argument_list|()
operator|.
name|get
argument_list|(
name|datanode
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|peer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"nextTcpPeer: reusing existing peer {}"
argument_list|,
name|peer
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlockReaderPeer
argument_list|(
name|peer
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
try|try
block|{
name|Peer
name|peer
init|=
name|remotePeerFactory
operator|.
name|newConnectedPeer
argument_list|(
name|inetSocketAddress
argument_list|,
name|token
argument_list|,
name|datanode
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"nextTcpPeer: created newConnectedPeer {}"
argument_list|,
name|peer
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlockReaderPeer
argument_list|(
name|peer
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"nextTcpPeer: failed to create newConnectedPeer connected to"
operator|+
literal|"{}"
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Determine if an exception is security-related.    *    * We need to handle these exceptions differently than other IOExceptions.    * They don't indicate a communication problem.  Instead, they mean that there    * is some action the client needs to take, such as refetching block tokens,    * renewing encryption keys, etc.    *    * @param ioe    The exception    * @return       True only if the exception is security-related.    */
DECL|method|isSecurityException (IOException ioe)
specifier|private
specifier|static
name|boolean
name|isSecurityException
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
return|return
operator|(
name|ioe
operator|instanceof
name|InvalidToken
operator|)
operator|||
operator|(
name|ioe
operator|instanceof
name|InvalidEncryptionKeyException
operator|)
operator|||
operator|(
name|ioe
operator|instanceof
name|InvalidBlockTokenException
operator|)
operator|||
operator|(
name|ioe
operator|instanceof
name|AccessControlException
operator|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|getRemoteBlockReader (Peer peer)
specifier|private
name|BlockReader
name|getRemoteBlockReader
parameter_list|(
name|Peer
name|peer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|networkDistance
init|=
name|clientContext
operator|.
name|getNetworkDistance
argument_list|(
name|datanode
argument_list|)
decl_stmt|;
return|return
name|BlockReaderRemote
operator|.
name|newBlockReader
argument_list|(
name|fileName
argument_list|,
name|block
argument_list|,
name|token
argument_list|,
name|startOffset
argument_list|,
name|length
argument_list|,
name|verifyChecksum
argument_list|,
name|clientName
argument_list|,
name|peer
argument_list|,
name|datanode
argument_list|,
name|clientContext
operator|.
name|getPeerCache
argument_list|()
argument_list|,
name|cachingStrategy
argument_list|,
name|tracer
argument_list|,
name|networkDistance
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"BlockReaderFactory(fileName="
operator|+
name|fileName
operator|+
literal|", block="
operator|+
name|block
operator|+
literal|")"
return|;
block|}
comment|/**    * File name to print when accessing a block directly (from servlets)    * @param s Address of the block location    * @param poolId Block pool ID of the block    * @param blockId Block ID of the block    * @return string that has a file name for debug purposes    */
DECL|method|getFileName (final InetSocketAddress s, final String poolId, final long blockId)
specifier|public
specifier|static
name|String
name|getFileName
parameter_list|(
specifier|final
name|InetSocketAddress
name|s
parameter_list|,
specifier|final
name|String
name|poolId
parameter_list|,
specifier|final
name|long
name|blockId
parameter_list|)
block|{
return|return
name|s
operator|.
name|toString
argument_list|()
operator|+
literal|":"
operator|+
name|poolId
operator|+
literal|":"
operator|+
name|blockId
return|;
block|}
block|}
end_class

end_unit

