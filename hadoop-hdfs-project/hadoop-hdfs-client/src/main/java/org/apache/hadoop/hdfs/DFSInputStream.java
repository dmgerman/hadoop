begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedByInterruptException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorCompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ByteBufferPositionedReadable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ByteBufferReadable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ByteBufferUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanSetDropBehind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanSetReadahead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanUnbuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ChecksumException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HasEnhancedByteBufferAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ReadOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StreamCapabilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
operator|.
name|CorruptedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|BlockReaderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|DfsClientConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|InvalidEncryptionKeyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|InvalidBlockTokenException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|CachingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ClientMmap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|IOUtilsClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|ByteBufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RetriableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|IdentityHashStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|IOUtilsClient
operator|.
name|updateReadStatistics
import|;
end_import

begin_comment
comment|/****************************************************************  * DFSInputStream provides bytes from a named file.  It handles  * negotiation of the namenode and various datanodes as necessary.  ****************************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|DFSInputStream
specifier|public
class|class
name|DFSInputStream
extends|extends
name|FSInputStream
implements|implements
name|ByteBufferReadable
implements|,
name|CanSetDropBehind
implements|,
name|CanSetReadahead
implements|,
name|HasEnhancedByteBufferAccess
implements|,
name|CanUnbuffer
implements|,
name|StreamCapabilities
implements|,
name|ByteBufferPositionedReadable
block|{
annotation|@
name|VisibleForTesting
DECL|field|tcpReadsDisabledForTesting
specifier|public
specifier|static
name|boolean
name|tcpReadsDisabledForTesting
init|=
literal|false
decl_stmt|;
DECL|field|hedgedReadOpsLoopNumForTesting
specifier|private
name|long
name|hedgedReadOpsLoopNumForTesting
init|=
literal|0
decl_stmt|;
DECL|field|dfsClient
specifier|protected
specifier|final
name|DFSClient
name|dfsClient
decl_stmt|;
DECL|field|closed
specifier|protected
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|src
specifier|protected
specifier|final
name|String
name|src
decl_stmt|;
DECL|field|verifyChecksum
specifier|protected
specifier|final
name|boolean
name|verifyChecksum
decl_stmt|;
comment|// state by stateful read only:
comment|// (protected by lock on this)
comment|/////
DECL|field|currentNode
specifier|private
name|DatanodeInfo
name|currentNode
init|=
literal|null
decl_stmt|;
DECL|field|currentLocatedBlock
specifier|protected
name|LocatedBlock
name|currentLocatedBlock
init|=
literal|null
decl_stmt|;
DECL|field|pos
specifier|protected
name|long
name|pos
init|=
literal|0
decl_stmt|;
DECL|field|blockEnd
specifier|protected
name|long
name|blockEnd
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|blockReader
specifier|private
name|BlockReader
name|blockReader
init|=
literal|null
decl_stmt|;
comment|////
comment|// state shared by stateful and positional read:
comment|// (protected by lock on infoLock)
comment|////
DECL|field|locatedBlocks
specifier|protected
name|LocatedBlocks
name|locatedBlocks
init|=
literal|null
decl_stmt|;
DECL|field|lastBlockBeingWrittenLength
specifier|private
name|long
name|lastBlockBeingWrittenLength
init|=
literal|0
decl_stmt|;
DECL|field|fileEncryptionInfo
specifier|private
name|FileEncryptionInfo
name|fileEncryptionInfo
init|=
literal|null
decl_stmt|;
DECL|field|cachingStrategy
specifier|protected
name|CachingStrategy
name|cachingStrategy
decl_stmt|;
comment|////
DECL|field|readStatistics
specifier|protected
specifier|final
name|ReadStatistics
name|readStatistics
init|=
operator|new
name|ReadStatistics
argument_list|()
decl_stmt|;
comment|// lock for state shared between read and pread
comment|// Note: Never acquire a lock on<this> with this lock held to avoid deadlocks
comment|//       (it's OK to acquire this lock when the lock on<this> is held)
DECL|field|infoLock
specifier|protected
specifier|final
name|Object
name|infoLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**    * Track the ByteBuffers that we have handed out to readers.    *    * The value type can be either ByteBufferPool or ClientMmap, depending on    * whether we this is a memory-mapped buffer or not.    */
DECL|field|extendedReadBuffers
specifier|private
name|IdentityHashStore
argument_list|<
name|ByteBuffer
argument_list|,
name|Object
argument_list|>
name|extendedReadBuffers
decl_stmt|;
specifier|private
specifier|synchronized
name|IdentityHashStore
argument_list|<
name|ByteBuffer
argument_list|,
name|Object
argument_list|>
DECL|method|getExtendedReadBuffers ()
name|getExtendedReadBuffers
parameter_list|()
block|{
if|if
condition|(
name|extendedReadBuffers
operator|==
literal|null
condition|)
block|{
name|extendedReadBuffers
operator|=
operator|new
name|IdentityHashStore
argument_list|<>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|extendedReadBuffers
return|;
block|}
comment|/**    * This variable tracks the number of failures since the start of the    * most recent user-facing operation. That is to say, it should be reset    * whenever the user makes a call on this stream, and if at any point    * during the retry logic, the failure count exceeds a threshold,    * the errors will be thrown back to the operation.    *    * Specifically this counts the number of times the client has gone    * back to the namenode to get a new list of block locations, and is    * capped at maxBlockAcquireFailures    */
DECL|field|failures
specifier|protected
name|int
name|failures
init|=
literal|0
decl_stmt|;
comment|/* XXX Use of CocurrentHashMap is temp fix. Need to fix    * parallel accesses to DFSInputStream (through ptreads) properly */
DECL|field|deadNodes
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|DatanodeInfo
argument_list|>
name|deadNodes
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|oneByteBuf
specifier|private
name|byte
index|[]
name|oneByteBuf
decl_stmt|;
comment|// used for 'int read()'
DECL|method|addToLocalDeadNodes (DatanodeInfo dnInfo)
specifier|protected
name|void
name|addToLocalDeadNodes
parameter_list|(
name|DatanodeInfo
name|dnInfo
parameter_list|)
block|{
name|deadNodes
operator|.
name|put
argument_list|(
name|dnInfo
argument_list|,
name|dnInfo
argument_list|)
expr_stmt|;
block|}
DECL|method|removeFromLocalDeadNodes (DatanodeInfo dnInfo)
specifier|protected
name|void
name|removeFromLocalDeadNodes
parameter_list|(
name|DatanodeInfo
name|dnInfo
parameter_list|)
block|{
name|deadNodes
operator|.
name|remove
argument_list|(
name|dnInfo
argument_list|)
expr_stmt|;
block|}
DECL|method|getLocalDeadNodes ()
specifier|protected
name|ConcurrentHashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|DatanodeInfo
argument_list|>
name|getLocalDeadNodes
parameter_list|()
block|{
return|return
name|deadNodes
return|;
block|}
DECL|method|clearLocalDeadNodes ()
specifier|private
name|void
name|clearLocalDeadNodes
parameter_list|()
block|{
name|deadNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|getDFSClient ()
specifier|protected
name|DFSClient
name|getDFSClient
parameter_list|()
block|{
return|return
name|dfsClient
return|;
block|}
DECL|method|DFSInputStream (DFSClient dfsClient, String src, boolean verifyChecksum, LocatedBlocks locatedBlocks)
name|DFSInputStream
parameter_list|(
name|DFSClient
name|dfsClient
parameter_list|,
name|String
name|src
parameter_list|,
name|boolean
name|verifyChecksum
parameter_list|,
name|LocatedBlocks
name|locatedBlocks
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|dfsClient
operator|=
name|dfsClient
expr_stmt|;
name|this
operator|.
name|verifyChecksum
operator|=
name|verifyChecksum
expr_stmt|;
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
name|this
operator|.
name|cachingStrategy
operator|=
name|dfsClient
operator|.
name|getDefaultReadCachingStrategy
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|locatedBlocks
operator|=
name|locatedBlocks
expr_stmt|;
name|openInfo
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getlastBlockBeingWrittenLengthForTesting ()
specifier|public
name|long
name|getlastBlockBeingWrittenLengthForTesting
parameter_list|()
block|{
return|return
name|lastBlockBeingWrittenLength
return|;
block|}
comment|/**    * Grab the open-file info from namenode    * @param refreshLocatedBlocks whether to re-fetch locatedblocks    */
DECL|method|openInfo (boolean refreshLocatedBlocks)
name|void
name|openInfo
parameter_list|(
name|boolean
name|refreshLocatedBlocks
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DfsClientConf
name|conf
init|=
name|dfsClient
operator|.
name|getConf
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
name|lastBlockBeingWrittenLength
operator|=
name|fetchLocatedBlocksAndGetLastBlockLength
argument_list|(
name|refreshLocatedBlocks
argument_list|)
expr_stmt|;
name|int
name|retriesForLastBlockLength
init|=
name|conf
operator|.
name|getRetryTimesForGetLastBlockLength
argument_list|()
decl_stmt|;
while|while
condition|(
name|retriesForLastBlockLength
operator|>
literal|0
condition|)
block|{
comment|// Getting last block length as -1 is a special case. When cluster
comment|// restarts, DNs may not report immediately. At this time partial block
comment|// locations will not be available with NN for getting the length. Lets
comment|// retry for 3 times to get the length.
if|if
condition|(
name|lastBlockBeingWrittenLength
operator|==
operator|-
literal|1
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Last block locations not available. "
operator|+
literal|"Datanodes might not have reported blocks completely."
operator|+
literal|" Will retry for "
operator|+
name|retriesForLastBlockLength
operator|+
literal|" times"
argument_list|)
expr_stmt|;
name|waitFor
argument_list|(
name|conf
operator|.
name|getRetryIntervalForGetLastBlockLength
argument_list|()
argument_list|)
expr_stmt|;
name|lastBlockBeingWrittenLength
operator|=
name|fetchLocatedBlocksAndGetLastBlockLength
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|retriesForLastBlockLength
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|lastBlockBeingWrittenLength
operator|==
operator|-
literal|1
operator|&&
name|retriesForLastBlockLength
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not obtain the last block locations."
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|waitFor (int waitTime)
specifier|private
name|void
name|waitFor
parameter_list|(
name|int
name|waitTime
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted while getting the last block length."
argument_list|)
throw|;
block|}
block|}
DECL|method|fetchLocatedBlocksAndGetLastBlockLength (boolean refresh)
specifier|private
name|long
name|fetchLocatedBlocksAndGetLastBlockLength
parameter_list|(
name|boolean
name|refresh
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlocks
name|newInfo
init|=
name|locatedBlocks
decl_stmt|;
if|if
condition|(
name|locatedBlocks
operator|==
literal|null
operator|||
name|refresh
condition|)
block|{
name|newInfo
operator|=
name|dfsClient
operator|.
name|getLocatedBlocks
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"newInfo = {}"
argument_list|,
name|newInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|newInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot open filename "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|locatedBlocks
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|LocatedBlock
argument_list|>
name|oldIter
init|=
name|locatedBlocks
operator|.
name|getLocatedBlocks
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|LocatedBlock
argument_list|>
name|newIter
init|=
name|newInfo
operator|.
name|getLocatedBlocks
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|oldIter
operator|.
name|hasNext
argument_list|()
operator|&&
name|newIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|oldIter
operator|.
name|next
argument_list|()
operator|.
name|getBlock
argument_list|()
operator|.
name|equals
argument_list|(
name|newIter
operator|.
name|next
argument_list|()
operator|.
name|getBlock
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Blocklist for "
operator|+
name|src
operator|+
literal|" has changed!"
argument_list|)
throw|;
block|}
block|}
block|}
name|locatedBlocks
operator|=
name|newInfo
expr_stmt|;
name|long
name|lastBlkBeingWrittenLength
init|=
name|getLastBlockLength
argument_list|()
decl_stmt|;
name|fileEncryptionInfo
operator|=
name|locatedBlocks
operator|.
name|getFileEncryptionInfo
argument_list|()
expr_stmt|;
return|return
name|lastBlkBeingWrittenLength
return|;
block|}
DECL|method|getLastBlockLength ()
specifier|private
name|long
name|getLastBlockLength
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|lastBlockBeingWrittenLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|locatedBlocks
operator|.
name|isLastBlockComplete
argument_list|()
condition|)
block|{
specifier|final
name|LocatedBlock
name|last
init|=
name|locatedBlocks
operator|.
name|getLastLocatedBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|last
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|last
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last
operator|.
name|getBlockSize
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// if the length is zero, then no data has been written to
comment|// datanode. So no need to wait for the locations.
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|final
name|long
name|len
init|=
name|readBlockLength
argument_list|(
name|last
argument_list|)
decl_stmt|;
name|last
operator|.
name|getBlock
argument_list|()
operator|.
name|setNumBytes
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|lastBlockBeingWrittenLength
operator|=
name|len
expr_stmt|;
block|}
block|}
return|return
name|lastBlockBeingWrittenLength
return|;
block|}
comment|/** Read the block length from one of the datanodes. */
DECL|method|readBlockLength (LocatedBlock locatedblock)
specifier|private
name|long
name|readBlockLength
parameter_list|(
name|LocatedBlock
name|locatedblock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|locatedblock
operator|!=
literal|null
operator|:
literal|"LocatedBlock cannot be null"
assert|;
name|int
name|replicaNotFoundCount
init|=
name|locatedblock
operator|.
name|getLocations
argument_list|()
operator|.
name|length
decl_stmt|;
specifier|final
name|DfsClientConf
name|conf
init|=
name|dfsClient
operator|.
name|getConf
argument_list|()
decl_stmt|;
specifier|final
name|int
name|timeout
init|=
name|conf
operator|.
name|getSocketTimeout
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|DatanodeInfo
argument_list|>
name|nodeList
init|=
operator|new
name|LinkedList
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|locatedblock
operator|.
name|getLocations
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|LinkedList
argument_list|<
name|DatanodeInfo
argument_list|>
name|retryList
init|=
operator|new
name|LinkedList
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|isRetry
init|=
literal|false
decl_stmt|;
name|StopWatch
name|sw
init|=
operator|new
name|StopWatch
argument_list|()
decl_stmt|;
while|while
condition|(
name|nodeList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|DatanodeInfo
name|datanode
init|=
name|nodeList
operator|.
name|pop
argument_list|()
decl_stmt|;
name|ClientDatanodeProtocol
name|cdp
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cdp
operator|=
name|DFSUtilClient
operator|.
name|createClientDatanodeProtocolProxy
argument_list|(
name|datanode
argument_list|,
name|dfsClient
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|timeout
argument_list|,
name|conf
operator|.
name|isConnectToDnViaHostname
argument_list|()
argument_list|,
name|locatedblock
argument_list|)
expr_stmt|;
specifier|final
name|long
name|n
init|=
name|cdp
operator|.
name|getReplicaVisibleLength
argument_list|(
name|locatedblock
operator|.
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
return|return
name|n
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|checkInterrupted
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioe
operator|instanceof
name|RemoteException
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|RemoteException
operator|)
name|ioe
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
operator|instanceof
name|ReplicaNotFoundException
condition|)
block|{
comment|// replica is not on the DN. We will treat it as 0 length
comment|// if no one actually has a replica.
name|replicaNotFoundCount
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|RemoteException
operator|)
name|ioe
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
operator|instanceof
name|RetriableException
condition|)
block|{
comment|// add to the list to be retried if necessary.
name|retryList
operator|.
name|add
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
block|}
block|}
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to getReplicaVisibleLength from datanode {}"
operator|+
literal|" for block {}"
argument_list|,
name|datanode
argument_list|,
name|locatedblock
operator|.
name|getBlock
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cdp
operator|!=
literal|null
condition|)
block|{
name|RPC
operator|.
name|stopProxy
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Ran out of nodes, but there are retriable nodes.
if|if
condition|(
name|nodeList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|retryList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|nodeList
operator|.
name|addAll
argument_list|(
name|retryList
argument_list|)
expr_stmt|;
name|retryList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|isRetry
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|isRetry
condition|)
block|{
comment|// start the stop watch if not already running.
if|if
condition|(
operator|!
name|sw
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|sw
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|// delay between retries.
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted while getting the length."
argument_list|)
throw|;
block|}
block|}
comment|// see if we ran out of retry time
if|if
condition|(
name|sw
operator|.
name|isRunning
argument_list|()
operator|&&
name|sw
operator|.
name|now
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|>
name|timeout
condition|)
block|{
break|break;
block|}
block|}
comment|// Namenode told us about these locations, but none know about the replica
comment|// means that we hit the race between pipeline creation start and end.
comment|// we require all 3 because some other exception could have happened
comment|// on a DN that has it.  we want to report that error
if|if
condition|(
name|replicaNotFoundCount
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
throw|throw
operator|new
name|CannotObtainBlockLengthException
argument_list|(
name|locatedblock
argument_list|,
name|src
argument_list|)
throw|;
block|}
DECL|method|getFileLength ()
specifier|public
name|long
name|getFileLength
parameter_list|()
block|{
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
return|return
name|locatedBlocks
operator|==
literal|null
condition|?
literal|0
else|:
name|locatedBlocks
operator|.
name|getFileLength
argument_list|()
operator|+
name|lastBlockBeingWrittenLength
return|;
block|}
block|}
comment|// Short circuit local reads are forbidden for files that are
comment|// under construction.  See HDFS-2757.
DECL|method|shortCircuitForbidden ()
name|boolean
name|shortCircuitForbidden
parameter_list|()
block|{
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
return|return
name|locatedBlocks
operator|.
name|isUnderConstruction
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the datanode from which the stream is currently reading.    */
DECL|method|getCurrentDatanode ()
specifier|public
specifier|synchronized
name|DatanodeInfo
name|getCurrentDatanode
parameter_list|()
block|{
return|return
name|currentNode
return|;
block|}
comment|/**    * Returns the block containing the target position.    */
DECL|method|getCurrentBlock ()
specifier|synchronized
specifier|public
name|ExtendedBlock
name|getCurrentBlock
parameter_list|()
block|{
if|if
condition|(
name|currentLocatedBlock
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|currentLocatedBlock
operator|.
name|getBlock
argument_list|()
return|;
block|}
comment|/**    * Return collection of blocks that has already been located.    */
DECL|method|getAllBlocks ()
specifier|public
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|getAllBlocks
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getBlockRange
argument_list|(
literal|0
argument_list|,
name|getFileLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get block at the specified position.    * Fetch it from the namenode if not cached.    *    * @param offset block corresponding to this offset in file is returned    * @return located block    * @throws IOException    */
DECL|method|getBlockAt (long offset)
specifier|protected
name|LocatedBlock
name|getBlockAt
parameter_list|(
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
assert|assert
operator|(
name|locatedBlocks
operator|!=
literal|null
operator|)
operator|:
literal|"locatedBlocks is null"
assert|;
specifier|final
name|LocatedBlock
name|blk
decl_stmt|;
comment|//check offset
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|getFileLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"offset< 0 || offset>= getFileLength(), offset="
operator|+
name|offset
operator|+
literal|", locatedBlocks="
operator|+
name|locatedBlocks
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>=
name|locatedBlocks
operator|.
name|getFileLength
argument_list|()
condition|)
block|{
comment|// offset to the portion of the last block,
comment|// which is not known to the name-node yet;
comment|// getting the last block
name|blk
operator|=
name|locatedBlocks
operator|.
name|getLastLocatedBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// search cached blocks first
name|blk
operator|=
name|fetchBlockAt
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|blk
return|;
block|}
block|}
comment|/** Fetch a block from namenode and cache it */
DECL|method|fetchBlockAt (long offset)
specifier|protected
name|LocatedBlock
name|fetchBlockAt
parameter_list|(
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fetchBlockAt
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
return|;
comment|// don't use cache
block|}
comment|/** Fetch a block from namenode and cache it */
DECL|method|fetchBlockAt (long offset, long length, boolean useCache)
specifier|private
name|LocatedBlock
name|fetchBlockAt
parameter_list|(
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
name|int
name|targetBlockIdx
init|=
name|locatedBlocks
operator|.
name|findBlock
argument_list|(
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetBlockIdx
operator|<
literal|0
condition|)
block|{
comment|// block is not cached
name|targetBlockIdx
operator|=
name|LocatedBlocks
operator|.
name|getInsertIndex
argument_list|(
name|targetBlockIdx
argument_list|)
expr_stmt|;
name|useCache
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|useCache
condition|)
block|{
comment|// fetch blocks
specifier|final
name|LocatedBlocks
name|newBlocks
init|=
operator|(
name|length
operator|==
literal|0
operator|)
condition|?
name|dfsClient
operator|.
name|getLocatedBlocks
argument_list|(
name|src
argument_list|,
name|offset
argument_list|)
else|:
name|dfsClient
operator|.
name|getLocatedBlocks
argument_list|(
name|src
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|newBlocks
operator|==
literal|null
operator|||
name|newBlocks
operator|.
name|locatedBlockCount
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Could not find target position "
operator|+
name|offset
argument_list|)
throw|;
block|}
comment|// Update the LastLocatedBlock, if offset is for last block.
if|if
condition|(
name|offset
operator|>=
name|locatedBlocks
operator|.
name|getFileLength
argument_list|()
condition|)
block|{
name|locatedBlocks
operator|=
name|newBlocks
expr_stmt|;
name|lastBlockBeingWrittenLength
operator|=
name|getLastBlockLength
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|locatedBlocks
operator|.
name|insertRange
argument_list|(
name|targetBlockIdx
argument_list|,
name|newBlocks
operator|.
name|getLocatedBlocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|locatedBlocks
operator|.
name|get
argument_list|(
name|targetBlockIdx
argument_list|)
return|;
block|}
block|}
comment|/**    * Get blocks in the specified range.    * Fetch them from the namenode if not cached. This function    * will not get a read request beyond the EOF.    * @param offset starting offset in file    * @param length length of data    * @return consequent segment of located blocks    * @throws IOException    */
DECL|method|getBlockRange (long offset, long length)
specifier|private
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|getBlockRange
parameter_list|(
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
comment|// getFileLength(): returns total file length
comment|// locatedBlocks.getFileLength(): returns length of completed blocks
if|if
condition|(
name|offset
operator|>=
name|getFileLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Offset: "
operator|+
name|offset
operator|+
literal|" exceeds file length: "
operator|+
name|getFileLength
argument_list|()
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
specifier|final
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|blocks
decl_stmt|;
specifier|final
name|long
name|lengthOfCompleteBlk
init|=
name|locatedBlocks
operator|.
name|getFileLength
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|readOffsetWithinCompleteBlk
init|=
name|offset
operator|<
name|lengthOfCompleteBlk
decl_stmt|;
specifier|final
name|boolean
name|readLengthPastCompleteBlk
init|=
name|offset
operator|+
name|length
operator|>
name|lengthOfCompleteBlk
decl_stmt|;
if|if
condition|(
name|readOffsetWithinCompleteBlk
condition|)
block|{
comment|//get the blocks of finalized (completed) block range
name|blocks
operator|=
name|getFinalizedBlockRange
argument_list|(
name|offset
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|length
argument_list|,
name|lengthOfCompleteBlk
operator|-
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blocks
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// get the blocks from incomplete block range
if|if
condition|(
name|readLengthPastCompleteBlk
condition|)
block|{
name|blocks
operator|.
name|add
argument_list|(
name|locatedBlocks
operator|.
name|getLastLocatedBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|blocks
return|;
block|}
block|}
comment|/**    * Get blocks in the specified range.    * Includes only the complete blocks.    * Fetch them from the namenode if not cached.    */
DECL|method|getFinalizedBlockRange ( long offset, long length)
specifier|private
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|getFinalizedBlockRange
parameter_list|(
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
assert|assert
operator|(
name|locatedBlocks
operator|!=
literal|null
operator|)
operator|:
literal|"locatedBlocks is null"
assert|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|blockRange
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// search cached blocks first
name|long
name|remaining
init|=
name|length
decl_stmt|;
name|long
name|curOff
init|=
name|offset
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|LocatedBlock
name|blk
init|=
name|fetchBlockAt
argument_list|(
name|curOff
argument_list|,
name|remaining
argument_list|,
literal|true
argument_list|)
decl_stmt|;
assert|assert
name|curOff
operator|>=
name|blk
operator|.
name|getStartOffset
argument_list|()
operator|:
literal|"Block not found"
assert|;
name|blockRange
operator|.
name|add
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|long
name|bytesRead
init|=
name|blk
operator|.
name|getStartOffset
argument_list|()
operator|+
name|blk
operator|.
name|getBlockSize
argument_list|()
operator|-
name|curOff
decl_stmt|;
name|remaining
operator|-=
name|bytesRead
expr_stmt|;
name|curOff
operator|+=
name|bytesRead
expr_stmt|;
block|}
return|return
name|blockRange
return|;
block|}
block|}
comment|/**    * Open a DataInputStream to a DataNode so that it can be read from.    * We get block ID and the IDs of the destinations at startup, from the namenode.    */
DECL|method|blockSeekTo (long target)
specifier|private
specifier|synchronized
name|DatanodeInfo
name|blockSeekTo
parameter_list|(
name|long
name|target
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|target
operator|>=
name|getFileLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Attempted to read past end of file"
argument_list|)
throw|;
block|}
comment|// Will be getting a new BlockReader.
name|closeCurrentBlockReaders
argument_list|()
expr_stmt|;
comment|//
comment|// Connect to best DataNode for desired Block, with potential offset
comment|//
name|DatanodeInfo
name|chosenNode
decl_stmt|;
name|int
name|refetchToken
init|=
literal|1
decl_stmt|;
comment|// only need to get a new access token once
name|int
name|refetchEncryptionKey
init|=
literal|1
decl_stmt|;
comment|// only need to get a new encryption key once
name|boolean
name|connectFailedOnce
init|=
literal|false
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//
comment|// Compute desired block
comment|//
name|LocatedBlock
name|targetBlock
init|=
name|getBlockAt
argument_list|(
name|target
argument_list|)
decl_stmt|;
comment|// update current position
name|this
operator|.
name|pos
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|blockEnd
operator|=
name|targetBlock
operator|.
name|getStartOffset
argument_list|()
operator|+
name|targetBlock
operator|.
name|getBlockSize
argument_list|()
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|currentLocatedBlock
operator|=
name|targetBlock
expr_stmt|;
name|long
name|offsetIntoBlock
init|=
name|target
operator|-
name|targetBlock
operator|.
name|getStartOffset
argument_list|()
decl_stmt|;
name|DNAddrPair
name|retval
init|=
name|chooseDataNode
argument_list|(
name|targetBlock
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|chosenNode
operator|=
name|retval
operator|.
name|info
expr_stmt|;
name|InetSocketAddress
name|targetAddr
init|=
name|retval
operator|.
name|addr
decl_stmt|;
name|StorageType
name|storageType
init|=
name|retval
operator|.
name|storageType
decl_stmt|;
comment|// Latest block if refreshed by chooseDatanode()
name|targetBlock
operator|=
name|retval
operator|.
name|block
expr_stmt|;
try|try
block|{
name|blockReader
operator|=
name|getBlockReader
argument_list|(
name|targetBlock
argument_list|,
name|offsetIntoBlock
argument_list|,
name|targetBlock
operator|.
name|getBlockSize
argument_list|()
operator|-
name|offsetIntoBlock
argument_list|,
name|targetAddr
argument_list|,
name|storageType
argument_list|,
name|chosenNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|connectFailedOnce
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully connected to "
operator|+
name|targetAddr
operator|+
literal|" for "
operator|+
name|targetBlock
operator|.
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|chosenNode
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|checkInterrupted
argument_list|(
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|instanceof
name|InvalidEncryptionKeyException
operator|&&
name|refetchEncryptionKey
operator|>
literal|0
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Will fetch a new encryption key and retry, "
operator|+
literal|"encryption key was invalid when connecting to "
operator|+
name|targetAddr
operator|+
literal|" : "
operator|+
name|ex
argument_list|)
expr_stmt|;
comment|// The encryption key used is invalid.
name|refetchEncryptionKey
operator|--
expr_stmt|;
name|dfsClient
operator|.
name|clearDataEncryptionKey
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|refetchToken
operator|>
literal|0
operator|&&
name|tokenRefetchNeeded
argument_list|(
name|ex
argument_list|,
name|targetAddr
argument_list|)
condition|)
block|{
name|refetchToken
operator|--
expr_stmt|;
name|fetchBlockAt
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|connectFailedOnce
operator|=
literal|true
expr_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to connect to {} for file {} for block "
operator|+
literal|"{}, add to deadNodes and continue. "
argument_list|,
name|targetAddr
argument_list|,
name|src
argument_list|,
name|targetBlock
operator|.
name|getBlock
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// Put chosen node into dead list, continue
name|addToLocalDeadNodes
argument_list|(
name|chosenNode
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|addNodeToDeadNodeDetector
argument_list|(
name|this
argument_list|,
name|chosenNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|checkInterrupted (IOException e)
specifier|private
name|void
name|checkInterrupted
parameter_list|(
name|IOException
name|e
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
operator|&&
operator|(
name|e
operator|instanceof
name|ClosedByInterruptException
operator|||
name|e
operator|instanceof
name|InterruptedIOException
operator|)
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"The reading thread has been interrupted."
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|getBlockReader (LocatedBlock targetBlock, long offsetInBlock, long length, InetSocketAddress targetAddr, StorageType storageType, DatanodeInfo datanode)
specifier|protected
name|BlockReader
name|getBlockReader
parameter_list|(
name|LocatedBlock
name|targetBlock
parameter_list|,
name|long
name|offsetInBlock
parameter_list|,
name|long
name|length
parameter_list|,
name|InetSocketAddress
name|targetAddr
parameter_list|,
name|StorageType
name|storageType
parameter_list|,
name|DatanodeInfo
name|datanode
parameter_list|)
throws|throws
name|IOException
block|{
name|ExtendedBlock
name|blk
init|=
name|targetBlock
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|accessToken
init|=
name|targetBlock
operator|.
name|getBlockToken
argument_list|()
decl_stmt|;
name|CachingStrategy
name|curCachingStrategy
decl_stmt|;
name|boolean
name|shortCircuitForbidden
decl_stmt|;
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
name|curCachingStrategy
operator|=
name|cachingStrategy
expr_stmt|;
name|shortCircuitForbidden
operator|=
name|shortCircuitForbidden
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|BlockReaderFactory
argument_list|(
name|dfsClient
operator|.
name|getConf
argument_list|()
argument_list|)
operator|.
name|setInetSocketAddress
argument_list|(
name|targetAddr
argument_list|)
operator|.
name|setRemotePeerFactory
argument_list|(
name|dfsClient
argument_list|)
operator|.
name|setDatanodeInfo
argument_list|(
name|datanode
argument_list|)
operator|.
name|setStorageType
argument_list|(
name|storageType
argument_list|)
operator|.
name|setFileName
argument_list|(
name|src
argument_list|)
operator|.
name|setBlock
argument_list|(
name|blk
argument_list|)
operator|.
name|setBlockToken
argument_list|(
name|accessToken
argument_list|)
operator|.
name|setStartOffset
argument_list|(
name|offsetInBlock
argument_list|)
operator|.
name|setVerifyChecksum
argument_list|(
name|verifyChecksum
argument_list|)
operator|.
name|setClientName
argument_list|(
name|dfsClient
operator|.
name|clientName
argument_list|)
operator|.
name|setLength
argument_list|(
name|length
argument_list|)
operator|.
name|setCachingStrategy
argument_list|(
name|curCachingStrategy
argument_list|)
operator|.
name|setAllowShortCircuitLocalReads
argument_list|(
operator|!
name|shortCircuitForbidden
argument_list|)
operator|.
name|setClientCacheContext
argument_list|(
name|dfsClient
operator|.
name|getClientContext
argument_list|()
argument_list|)
operator|.
name|setUserGroupInformation
argument_list|(
name|dfsClient
operator|.
name|ugi
argument_list|)
operator|.
name|setConfiguration
argument_list|(
name|dfsClient
operator|.
name|getConfiguration
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Close it down!    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
operator|!
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"DFSInputStream has been closed already"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dfsClient
operator|.
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|extendedReadBuffers
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|extendedReadBuffers
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
specifier|final
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|extendedReadBuffers
operator|.
name|visitAll
argument_list|(
operator|new
name|IdentityHashStore
operator|.
name|Visitor
argument_list|<
name|ByteBuffer
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|private
name|String
name|prefix
init|=
literal|""
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|ByteBuffer
name|k
parameter_list|,
name|Object
name|v
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
operator|.
name|append
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|", "
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"closing file "
operator|+
name|src
operator|+
literal|", but there are still "
operator|+
literal|"unreleased ByteBuffers allocated by read().  "
operator|+
literal|"Please release "
operator|+
name|builder
operator|.
name|toString
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
name|closeCurrentBlockReaders
argument_list|()
expr_stmt|;
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
comment|/**        * If dfsInputStream is closed and datanode is in        * DeadNodeDetector#dfsInputStreamNodes, we need remove the datanode from        * the DeadNodeDetector#dfsInputStreamNodes. Since user should not use        * this dfsInputStream anymore.        */
name|dfsClient
operator|.
name|removeNodeFromDeadNodeDetector
argument_list|(
name|this
argument_list|,
name|locatedBlocks
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|oneByteBuf
operator|==
literal|null
condition|)
block|{
name|oneByteBuf
operator|=
operator|new
name|byte
index|[
literal|1
index|]
expr_stmt|;
block|}
name|int
name|ret
init|=
name|read
argument_list|(
name|oneByteBuf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|ret
operator|<=
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|oneByteBuf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
return|;
block|}
comment|/* This is a used by regular read() and handles ChecksumExceptions.    * name readBuffer() is chosen to imply similarity to readBuffer() in    * ChecksumFileSystem    */
DECL|method|readBuffer (ReaderStrategy reader, int len, CorruptedBlocks corruptedBlocks)
specifier|private
specifier|synchronized
name|int
name|readBuffer
parameter_list|(
name|ReaderStrategy
name|reader
parameter_list|,
name|int
name|len
parameter_list|,
name|CorruptedBlocks
name|corruptedBlocks
parameter_list|)
throws|throws
name|IOException
block|{
name|IOException
name|ioe
decl_stmt|;
comment|/* we retry current node only once. So this is set to true only here.      * Intention is to handle one common case of an error that is not a      * failure on datanode or client : when DataNode closes the connection      * since client is idle. If there are other cases of "non-errors" then      * then a datanode might be retried by setting this to true again.      */
name|boolean
name|retryCurrentNode
init|=
literal|true
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// retry as many times as seekToNewSource allows.
try|try
block|{
return|return
name|reader
operator|.
name|readFromBlock
argument_list|(
name|blockReader
argument_list|,
name|len
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|ce
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Found Checksum error for "
operator|+
name|getCurrentBlock
argument_list|()
operator|+
literal|" from "
operator|+
name|currentNode
operator|+
literal|" at "
operator|+
name|ce
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|ioe
operator|=
name|ce
expr_stmt|;
name|retryCurrentNode
operator|=
literal|false
expr_stmt|;
comment|// we want to remember which block replicas we have tried
name|corruptedBlocks
operator|.
name|addCorruptedBlock
argument_list|(
name|getCurrentBlock
argument_list|()
argument_list|,
name|currentNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|retryCurrentNode
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while reading from "
operator|+
name|getCurrentBlock
argument_list|()
operator|+
literal|" of "
operator|+
name|src
operator|+
literal|" from "
operator|+
name|currentNode
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|ioe
operator|=
name|e
expr_stmt|;
block|}
name|boolean
name|sourceFound
decl_stmt|;
if|if
condition|(
name|retryCurrentNode
condition|)
block|{
comment|/* possibly retry the same node so that transient errors don't          * result in application level failures (e.g. Datanode could have          * closed the connection because the client is idle for too long).          */
name|sourceFound
operator|=
name|seekToBlockSource
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addToLocalDeadNodes
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|addNodeToDeadNodeDetector
argument_list|(
name|this
argument_list|,
name|currentNode
argument_list|)
expr_stmt|;
name|sourceFound
operator|=
name|seekToNewSource
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sourceFound
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
name|retryCurrentNode
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|method|readWithStrategy (ReaderStrategy strategy)
specifier|protected
specifier|synchronized
name|int
name|readWithStrategy
parameter_list|(
name|ReaderStrategy
name|strategy
parameter_list|)
throws|throws
name|IOException
block|{
name|dfsClient
operator|.
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream closed"
argument_list|)
throw|;
block|}
name|int
name|len
init|=
name|strategy
operator|.
name|getTargetLength
argument_list|()
decl_stmt|;
name|CorruptedBlocks
name|corruptedBlocks
init|=
operator|new
name|CorruptedBlocks
argument_list|()
decl_stmt|;
name|failures
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|getFileLength
argument_list|()
condition|)
block|{
name|int
name|retries
init|=
literal|2
decl_stmt|;
while|while
condition|(
name|retries
operator|>
literal|0
condition|)
block|{
try|try
block|{
comment|// currentNode can be left as null if previous read had a checksum
comment|// error on the same block. See HDFS-3067
if|if
condition|(
name|pos
operator|>
name|blockEnd
operator|||
name|currentNode
operator|==
literal|null
condition|)
block|{
name|currentNode
operator|=
name|blockSeekTo
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|int
name|realLen
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
operator|(
name|blockEnd
operator|-
name|pos
operator|+
literal|1L
operator|)
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
if|if
condition|(
name|locatedBlocks
operator|.
name|isLastBlockComplete
argument_list|()
condition|)
block|{
name|realLen
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|realLen
argument_list|,
name|locatedBlocks
operator|.
name|getFileLength
argument_list|()
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|result
init|=
name|readBuffer
argument_list|(
name|strategy
argument_list|,
name|realLen
argument_list|,
name|corruptedBlocks
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
block|{
name|pos
operator|+=
name|result
expr_stmt|;
block|}
else|else
block|{
comment|// got a EOS from reader though we expect more data on it.
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected EOS from the reader"
argument_list|)
throw|;
block|}
name|updateReadStatistics
argument_list|(
name|readStatistics
argument_list|,
name|result
argument_list|,
name|blockReader
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|updateFileSystemReadStats
argument_list|(
name|blockReader
operator|.
name|getNetworkDistance
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|readStatistics
operator|.
name|getBlockType
argument_list|()
operator|==
name|BlockType
operator|.
name|STRIPED
condition|)
block|{
name|dfsClient
operator|.
name|updateFileSystemECReadStats
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|ce
parameter_list|)
block|{
throw|throw
name|ce
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkInterrupted
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|retries
operator|==
literal|1
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"DFS Read"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|blockEnd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|currentNode
operator|!=
literal|null
condition|)
block|{
name|addToLocalDeadNodes
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|addNodeToDeadNodeDetector
argument_list|(
name|this
argument_list|,
name|currentNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|retries
operator|==
literal|0
condition|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
finally|finally
block|{
comment|// Check if need to report block replicas corruption either read
comment|// was successful or ChecksumException occurred.
name|reportCheckSumFailure
argument_list|(
name|corruptedBlocks
argument_list|,
name|getCurrentBlockLocationsLength
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|getCurrentBlockLocationsLength ()
specifier|protected
name|int
name|getCurrentBlockLocationsLength
parameter_list|()
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|currentLocatedBlock
operator|==
literal|null
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Found null currentLocatedBlock. pos={}, "
operator|+
literal|"blockEnd={}, fileLength={}"
argument_list|,
name|pos
argument_list|,
name|blockEnd
argument_list|,
name|getFileLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|currentLocatedBlock
operator|.
name|getLocations
argument_list|()
operator|.
name|length
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
comment|/**    * Read the entire buffer.    */
annotation|@
name|Override
DECL|method|read (@onnull final byte buf[], int off, int len)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
annotation|@
name|Nonnull
specifier|final
name|byte
name|buf
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|validatePositionedReadArgs
argument_list|(
name|pos
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|ReaderStrategy
name|byteArrayReader
init|=
operator|new
name|ByteArrayStrategy
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|readStatistics
argument_list|,
name|dfsClient
argument_list|)
decl_stmt|;
return|return
name|readWithStrategy
argument_list|(
name|byteArrayReader
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|read (final ByteBuffer buf)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
specifier|final
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|ReaderStrategy
name|byteBufferReader
init|=
operator|new
name|ByteBufferStrategy
argument_list|(
name|buf
argument_list|,
name|readStatistics
argument_list|,
name|dfsClient
argument_list|)
decl_stmt|;
return|return
name|readWithStrategy
argument_list|(
name|byteBufferReader
argument_list|)
return|;
block|}
DECL|method|chooseDataNode (LocatedBlock block, Collection<DatanodeInfo> ignoredNodes)
specifier|private
name|DNAddrPair
name|chooseDataNode
parameter_list|(
name|LocatedBlock
name|block
parameter_list|,
name|Collection
argument_list|<
name|DatanodeInfo
argument_list|>
name|ignoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|chooseDataNode
argument_list|(
name|block
argument_list|,
name|ignoredNodes
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Choose datanode to read from.    *    * @param block             Block to choose datanode addr from    * @param ignoredNodes      Ignored nodes inside.    * @param refetchIfRequired Whether to refetch if no nodes to chose    *                          from.    * @return Returns chosen DNAddrPair; Can be null if refetchIfRequired is    * false.    */
DECL|method|chooseDataNode (LocatedBlock block, Collection<DatanodeInfo> ignoredNodes, boolean refetchIfRequired)
specifier|private
name|DNAddrPair
name|chooseDataNode
parameter_list|(
name|LocatedBlock
name|block
parameter_list|,
name|Collection
argument_list|<
name|DatanodeInfo
argument_list|>
name|ignoredNodes
parameter_list|,
name|boolean
name|refetchIfRequired
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|DNAddrPair
name|result
init|=
name|getBestNodeDNAddrPair
argument_list|(
name|block
argument_list|,
name|ignoredNodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|refetchIfRequired
condition|)
block|{
name|block
operator|=
name|refetchLocations
argument_list|(
name|block
argument_list|,
name|ignoredNodes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
DECL|method|refetchLocations (LocatedBlock block, Collection<DatanodeInfo> ignoredNodes)
specifier|private
name|LocatedBlock
name|refetchLocations
parameter_list|(
name|LocatedBlock
name|block
parameter_list|,
name|Collection
argument_list|<
name|DatanodeInfo
argument_list|>
name|ignoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|errMsg
init|=
name|getBestNodeDNAddrPairErrorString
argument_list|(
name|block
operator|.
name|getLocations
argument_list|()
argument_list|,
name|dfsClient
operator|.
name|getDeadNodes
argument_list|(
name|this
argument_list|)
argument_list|,
name|ignoredNodes
argument_list|)
decl_stmt|;
name|String
name|blockInfo
init|=
name|block
operator|.
name|getBlock
argument_list|()
operator|+
literal|" file="
operator|+
name|src
decl_stmt|;
if|if
condition|(
name|failures
operator|>=
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|getMaxBlockAcquireFailures
argument_list|()
condition|)
block|{
name|String
name|description
init|=
literal|"Could not obtain block: "
operator|+
name|blockInfo
decl_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|description
operator|+
name|errMsg
operator|+
literal|". Throwing a BlockMissingException"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|BlockMissingException
argument_list|(
name|src
argument_list|,
name|description
argument_list|,
name|block
operator|.
name|getStartOffset
argument_list|()
argument_list|)
throw|;
block|}
name|DatanodeInfo
index|[]
name|nodes
init|=
name|block
operator|.
name|getLocations
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|null
operator|||
name|nodes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"No node available for "
operator|+
name|blockInfo
argument_list|)
expr_stmt|;
block|}
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Could not obtain "
operator|+
name|block
operator|.
name|getBlock
argument_list|()
operator|+
literal|" from any node: "
operator|+
name|errMsg
operator|+
literal|". Will get new block locations from namenode and retry..."
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Introducing a random factor to the wait time before another retry.
comment|// The wait time is dependent on # of failures and a random factor.
comment|// At the first time of getting a BlockMissingException, the wait time
comment|// is a random number between 0..3000 ms. If the first retry
comment|// still fails, we will wait 3000 ms grace period before the 2nd retry.
comment|// Also at the second retry, the waiting window is expanded to 6000 ms
comment|// alleviating the request rate from the server. Similarly the 3rd retry
comment|// will wait 6000ms grace period before retry and the waiting window is
comment|// expanded to 9000ms.
specifier|final
name|int
name|timeWindow
init|=
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|getTimeWindow
argument_list|()
decl_stmt|;
comment|// grace period for the last round of attempt
name|double
name|waitTime
init|=
name|timeWindow
operator|*
name|failures
operator|+
comment|// expanding time window for each failure
name|timeWindow
operator|*
operator|(
name|failures
operator|+
literal|1
operator|)
operator|*
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextDouble
argument_list|()
decl_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"DFS chooseDataNode: got # "
operator|+
operator|(
name|failures
operator|+
literal|1
operator|)
operator|+
literal|" IOException, will wait for "
operator|+
name|waitTime
operator|+
literal|" msec."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
operator|(
name|long
operator|)
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted while choosing DataNode for read."
argument_list|)
throw|;
block|}
name|clearLocalDeadNodes
argument_list|()
expr_stmt|;
comment|//2nd option is to remove only nodes[blockId]
name|openInfo
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|block
operator|=
name|refreshLocatedBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|failures
operator|++
expr_stmt|;
return|return
name|block
return|;
block|}
comment|/**    * Get the best node from which to stream the data.    * @param block LocatedBlock, containing nodes in priority order.    * @param ignoredNodes Do not choose nodes in this array (may be null)    * @return The DNAddrPair of the best node. Null if no node can be chosen.    */
DECL|method|getBestNodeDNAddrPair (LocatedBlock block, Collection<DatanodeInfo> ignoredNodes)
specifier|protected
name|DNAddrPair
name|getBestNodeDNAddrPair
parameter_list|(
name|LocatedBlock
name|block
parameter_list|,
name|Collection
argument_list|<
name|DatanodeInfo
argument_list|>
name|ignoredNodes
parameter_list|)
block|{
name|DatanodeInfo
index|[]
name|nodes
init|=
name|block
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|StorageType
index|[]
name|storageTypes
init|=
name|block
operator|.
name|getStorageTypes
argument_list|()
decl_stmt|;
name|DatanodeInfo
name|chosenNode
init|=
literal|null
decl_stmt|;
name|StorageType
name|storageType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dfsClient
operator|.
name|getDeadNodes
argument_list|(
name|this
argument_list|)
operator|.
name|containsKey
argument_list|(
name|nodes
index|[
name|i
index|]
argument_list|)
operator|&&
operator|(
name|ignoredNodes
operator|==
literal|null
operator|||
operator|!
name|ignoredNodes
operator|.
name|contains
argument_list|(
name|nodes
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
name|chosenNode
operator|=
name|nodes
index|[
name|i
index|]
expr_stmt|;
comment|// Storage types are ordered to correspond with nodes, so use the same
comment|// index to get storage type.
if|if
condition|(
name|storageTypes
operator|!=
literal|null
operator|&&
name|i
operator|<
name|storageTypes
operator|.
name|length
condition|)
block|{
name|storageType
operator|=
name|storageTypes
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|chosenNode
operator|==
literal|null
condition|)
block|{
name|reportLostBlock
argument_list|(
name|block
argument_list|,
name|ignoredNodes
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|String
name|dnAddr
init|=
name|chosenNode
operator|.
name|getXferAddr
argument_list|(
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|isConnectToDnViaHostname
argument_list|()
argument_list|)
decl_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to datanode {}"
argument_list|,
name|dnAddr
argument_list|)
expr_stmt|;
name|InetSocketAddress
name|targetAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|dnAddr
argument_list|)
decl_stmt|;
return|return
operator|new
name|DNAddrPair
argument_list|(
name|chosenNode
argument_list|,
name|targetAddr
argument_list|,
name|storageType
argument_list|,
name|block
argument_list|)
return|;
block|}
comment|/**    * Warn the user of a lost block    */
DECL|method|reportLostBlock (LocatedBlock lostBlock, Collection<DatanodeInfo> ignoredNodes)
specifier|protected
name|void
name|reportLostBlock
parameter_list|(
name|LocatedBlock
name|lostBlock
parameter_list|,
name|Collection
argument_list|<
name|DatanodeInfo
argument_list|>
name|ignoredNodes
parameter_list|)
block|{
name|DatanodeInfo
index|[]
name|nodes
init|=
name|lostBlock
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"No live nodes contain block "
operator|+
name|lostBlock
operator|.
name|getBlock
argument_list|()
operator|+
literal|" after checking nodes = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|nodes
argument_list|)
operator|+
literal|", ignoredNodes = "
operator|+
name|ignoredNodes
argument_list|)
expr_stmt|;
block|}
DECL|method|getBestNodeDNAddrPairErrorString ( DatanodeInfo nodes[], AbstractMap<DatanodeInfo, DatanodeInfo> deadNodes, Collection<DatanodeInfo> ignoredNodes)
specifier|private
specifier|static
name|String
name|getBestNodeDNAddrPairErrorString
parameter_list|(
name|DatanodeInfo
name|nodes
index|[]
parameter_list|,
name|AbstractMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|DatanodeInfo
argument_list|>
name|deadNodes
parameter_list|,
name|Collection
argument_list|<
name|DatanodeInfo
argument_list|>
name|ignoredNodes
parameter_list|)
block|{
name|StringBuilder
name|errMsgr
init|=
operator|new
name|StringBuilder
argument_list|(
literal|" No live nodes contain current block "
argument_list|)
decl_stmt|;
name|errMsgr
operator|.
name|append
argument_list|(
literal|"Block locations:"
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeInfo
name|datanode
range|:
name|nodes
control|)
block|{
name|errMsgr
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|datanode
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|errMsgr
operator|.
name|append
argument_list|(
literal|" Dead nodes: "
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeInfo
name|datanode
range|:
name|deadNodes
operator|.
name|keySet
argument_list|()
control|)
block|{
name|errMsgr
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|datanode
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignoredNodes
operator|!=
literal|null
condition|)
block|{
name|errMsgr
operator|.
name|append
argument_list|(
literal|" Ignored nodes: "
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeInfo
name|datanode
range|:
name|ignoredNodes
control|)
block|{
name|errMsgr
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|datanode
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|errMsgr
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|fetchBlockByteRange (LocatedBlock block, long start, long end, ByteBuffer buf, CorruptedBlocks corruptedBlocks)
specifier|protected
name|void
name|fetchBlockByteRange
parameter_list|(
name|LocatedBlock
name|block
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|,
name|CorruptedBlocks
name|corruptedBlocks
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|DNAddrPair
name|addressPair
init|=
name|chooseDataNode
argument_list|(
name|block
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Latest block, if refreshed internally
name|block
operator|=
name|addressPair
operator|.
name|block
expr_stmt|;
try|try
block|{
name|actualGetFromOneDataNode
argument_list|(
name|addressPair
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|buf
argument_list|,
name|corruptedBlocks
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkInterrupted
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// check if the read has been interrupted
comment|// Ignore other IOException. Already processed inside the function.
comment|// Loop through to try the next node.
block|}
block|}
block|}
DECL|method|getFromOneDataNode (final DNAddrPair datanode, final LocatedBlock block, final long start, final long end, final ByteBuffer bb, final CorruptedBlocks corruptedBlocks, final int hedgedReadId)
specifier|private
name|Callable
argument_list|<
name|ByteBuffer
argument_list|>
name|getFromOneDataNode
parameter_list|(
specifier|final
name|DNAddrPair
name|datanode
parameter_list|,
specifier|final
name|LocatedBlock
name|block
parameter_list|,
specifier|final
name|long
name|start
parameter_list|,
specifier|final
name|long
name|end
parameter_list|,
specifier|final
name|ByteBuffer
name|bb
parameter_list|,
specifier|final
name|CorruptedBlocks
name|corruptedBlocks
parameter_list|,
specifier|final
name|int
name|hedgedReadId
parameter_list|)
block|{
return|return
operator|new
name|Callable
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|DFSClientFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|sleepBeforeHedgedGet
argument_list|()
expr_stmt|;
name|actualGetFromOneDataNode
argument_list|(
name|datanode
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|bb
argument_list|,
name|corruptedBlocks
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
block|}
return|;
block|}
comment|/**    * Read data from one DataNode.    *    * @param datanode          the datanode from which to read data    * @param startInBlk        the startInBlk offset of the block    * @param endInBlk          the endInBlk offset of the block    * @param buf               the given byte buffer into which the data is read    * @param corruptedBlocks   map recording list of datanodes with corrupted    *                          block replica    */
DECL|method|actualGetFromOneDataNode (final DNAddrPair datanode, final long startInBlk, final long endInBlk, ByteBuffer buf, CorruptedBlocks corruptedBlocks)
name|void
name|actualGetFromOneDataNode
parameter_list|(
specifier|final
name|DNAddrPair
name|datanode
parameter_list|,
specifier|final
name|long
name|startInBlk
parameter_list|,
specifier|final
name|long
name|endInBlk
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|,
name|CorruptedBlocks
name|corruptedBlocks
parameter_list|)
throws|throws
name|IOException
block|{
name|DFSClientFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|startFetchFromDatanode
argument_list|()
expr_stmt|;
name|int
name|refetchToken
init|=
literal|1
decl_stmt|;
comment|// only need to get a new access token once
name|int
name|refetchEncryptionKey
init|=
literal|1
decl_stmt|;
comment|// only need to get a new encryption key once
specifier|final
name|int
name|len
init|=
call|(
name|int
call|)
argument_list|(
name|endInBlk
operator|-
name|startInBlk
operator|+
literal|1
argument_list|)
decl_stmt|;
name|LocatedBlock
name|block
init|=
name|datanode
operator|.
name|block
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|BlockReader
name|reader
init|=
literal|null
decl_stmt|;
try|try
block|{
name|DFSClientFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|fetchFromDatanodeException
argument_list|()
expr_stmt|;
name|reader
operator|=
name|getBlockReader
argument_list|(
name|block
argument_list|,
name|startInBlk
argument_list|,
name|len
argument_list|,
name|datanode
operator|.
name|addr
argument_list|,
name|datanode
operator|.
name|storageType
argument_list|,
name|datanode
operator|.
name|info
argument_list|)
expr_stmt|;
comment|//Behave exactly as the readAll() call
name|ByteBuffer
name|tmp
init|=
name|buf
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|tmp
operator|.
name|limit
argument_list|(
name|tmp
operator|.
name|position
argument_list|()
operator|+
name|len
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|.
name|slice
argument_list|()
expr_stmt|;
name|int
name|nread
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|ret
operator|=
name|reader
operator|.
name|read
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
name|nread
operator|+=
name|ret
expr_stmt|;
block|}
name|buf
operator|.
name|position
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|nread
argument_list|)
expr_stmt|;
name|IOUtilsClient
operator|.
name|updateReadStatistics
argument_list|(
name|readStatistics
argument_list|,
name|nread
argument_list|,
name|reader
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|updateFileSystemReadStats
argument_list|(
name|reader
operator|.
name|getNetworkDistance
argument_list|()
argument_list|,
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|readStatistics
operator|.
name|getBlockType
argument_list|()
operator|==
name|BlockType
operator|.
name|STRIPED
condition|)
block|{
name|dfsClient
operator|.
name|updateFileSystemECReadStats
argument_list|(
name|nread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nread
operator|!=
name|len
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"truncated return from reader.read(): "
operator|+
literal|"excpected "
operator|+
name|len
operator|+
literal|", got "
operator|+
name|nread
argument_list|)
throw|;
block|}
name|DFSClientFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|readFromDatanodeDelay
argument_list|()
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"fetchBlockByteRange(). Got a checksum exception for "
operator|+
name|src
operator|+
literal|" at "
operator|+
name|block
operator|.
name|getBlock
argument_list|()
operator|+
literal|":"
operator|+
name|e
operator|.
name|getPos
argument_list|()
operator|+
literal|" from "
operator|+
name|datanode
operator|.
name|info
decl_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|// we want to remember what we have tried
name|corruptedBlocks
operator|.
name|addCorruptedBlock
argument_list|(
name|block
operator|.
name|getBlock
argument_list|()
argument_list|,
name|datanode
operator|.
name|info
argument_list|)
expr_stmt|;
name|addToLocalDeadNodes
argument_list|(
name|datanode
operator|.
name|info
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkInterrupted
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|InvalidEncryptionKeyException
operator|&&
name|refetchEncryptionKey
operator|>
literal|0
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Will fetch a new encryption key and retry, "
operator|+
literal|"encryption key was invalid when connecting to "
operator|+
name|datanode
operator|.
name|addr
operator|+
literal|" : "
operator|+
name|e
argument_list|)
expr_stmt|;
comment|// The encryption key used is invalid.
name|refetchEncryptionKey
operator|--
expr_stmt|;
name|dfsClient
operator|.
name|clearDataEncryptionKey
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|refetchToken
operator|>
literal|0
operator|&&
name|tokenRefetchNeeded
argument_list|(
name|e
argument_list|,
name|datanode
operator|.
name|addr
argument_list|)
condition|)
block|{
name|refetchToken
operator|--
expr_stmt|;
try|try
block|{
name|fetchBlockAt
argument_list|(
name|block
operator|.
name|getStartOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|fbae
parameter_list|)
block|{
comment|// ignore IOE, since we can retry it later in a loop
block|}
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Failed to connect to "
operator|+
name|datanode
operator|.
name|addr
operator|+
literal|" for file "
operator|+
name|src
operator|+
literal|" for block "
operator|+
name|block
operator|.
name|getBlock
argument_list|()
operator|+
literal|":"
operator|+
name|e
decl_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Connection failure: "
operator|+
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|addToLocalDeadNodes
argument_list|(
name|datanode
operator|.
name|info
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|addNodeToDeadNodeDetector
argument_list|(
name|this
argument_list|,
name|datanode
operator|.
name|info
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// Refresh the block for updated tokens in case of token failures or
comment|// encryption key failures.
name|block
operator|=
name|refreshLocatedBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Refresh cached block locations.    * @param block The currently cached block locations    * @return Refreshed block locations    * @throws IOException    */
DECL|method|refreshLocatedBlock (LocatedBlock block)
specifier|protected
name|LocatedBlock
name|refreshLocatedBlock
parameter_list|(
name|LocatedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockAt
argument_list|(
name|block
operator|.
name|getStartOffset
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Like {@link #fetchBlockByteRange}except we start up a second, parallel,    * 'hedged' read if the first read is taking longer than configured amount of    * time. We then wait on which ever read returns first.    */
DECL|method|hedgedFetchBlockByteRange (LocatedBlock block, long start, long end, ByteBuffer buf, CorruptedBlocks corruptedBlocks)
specifier|private
name|void
name|hedgedFetchBlockByteRange
parameter_list|(
name|LocatedBlock
name|block
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|,
name|CorruptedBlocks
name|corruptedBlocks
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DfsClientConf
name|conf
init|=
name|dfsClient
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Future
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|CompletionService
argument_list|<
name|ByteBuffer
argument_list|>
name|hedgedService
init|=
operator|new
name|ExecutorCompletionService
argument_list|<>
argument_list|(
name|dfsClient
operator|.
name|getHedgedReadsThreadPool
argument_list|()
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|DatanodeInfo
argument_list|>
name|ignored
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ByteBuffer
name|bb
decl_stmt|;
name|int
name|len
init|=
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|start
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|hedgedReadId
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// see HDFS-6591, this metric is used to verify/catch unnecessary loops
name|hedgedReadOpsLoopNumForTesting
operator|++
expr_stmt|;
name|DNAddrPair
name|chosenNode
init|=
literal|null
decl_stmt|;
comment|// there is no request already executing.
if|if
condition|(
name|futures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// chooseDataNode is a commitment. If no node, we go to
comment|// the NN to reget block locations. Only go here on first read.
name|chosenNode
operator|=
name|chooseDataNode
argument_list|(
name|block
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
comment|// Latest block, if refreshed internally
name|block
operator|=
name|chosenNode
operator|.
name|block
expr_stmt|;
name|bb
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|Callable
argument_list|<
name|ByteBuffer
argument_list|>
name|getFromDataNodeCallable
init|=
name|getFromOneDataNode
argument_list|(
name|chosenNode
argument_list|,
name|block
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|bb
argument_list|,
name|corruptedBlocks
argument_list|,
name|hedgedReadId
operator|++
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|ByteBuffer
argument_list|>
name|firstRequest
init|=
name|hedgedService
operator|.
name|submit
argument_list|(
name|getFromDataNodeCallable
argument_list|)
decl_stmt|;
name|futures
operator|.
name|add
argument_list|(
name|firstRequest
argument_list|)
expr_stmt|;
name|Future
argument_list|<
name|ByteBuffer
argument_list|>
name|future
init|=
literal|null
decl_stmt|;
try|try
block|{
name|future
operator|=
name|hedgedService
operator|.
name|poll
argument_list|(
name|conf
operator|.
name|getHedgedReadThresholdMillis
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|future
operator|!=
literal|null
condition|)
block|{
name|ByteBuffer
name|result
init|=
name|future
operator|.
name|get
argument_list|()
decl_stmt|;
name|result
operator|.
name|flip
argument_list|()
expr_stmt|;
name|buf
operator|.
name|put
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waited {}ms to read from {}; spawning hedged "
operator|+
literal|"read"
argument_list|,
name|conf
operator|.
name|getHedgedReadThresholdMillis
argument_list|()
argument_list|,
name|chosenNode
operator|.
name|info
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|getHedgedReadMetrics
argument_list|()
operator|.
name|incHedgedReadOps
argument_list|()
expr_stmt|;
comment|// continue; no need to refresh block locations
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted while waiting for reading task"
argument_list|)
throw|;
block|}
comment|// Ignore this node on next go around.
comment|// If poll timeout and the request still ongoing, don't consider it
comment|// again. If read data failed, don't consider it either.
name|ignored
operator|.
name|add
argument_list|(
name|chosenNode
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We are starting up a 'hedged' read. We have a read already
comment|// ongoing. Call getBestNodeDNAddrPair instead of chooseDataNode.
comment|// If no nodes to do hedged reads against, pass.
name|boolean
name|refetch
init|=
literal|false
decl_stmt|;
try|try
block|{
name|chosenNode
operator|=
name|chooseDataNode
argument_list|(
name|block
argument_list|,
name|ignored
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosenNode
operator|!=
literal|null
condition|)
block|{
comment|// Latest block, if refreshed internally
name|block
operator|=
name|chosenNode
operator|.
name|block
expr_stmt|;
name|bb
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|Callable
argument_list|<
name|ByteBuffer
argument_list|>
name|getFromDataNodeCallable
init|=
name|getFromOneDataNode
argument_list|(
name|chosenNode
argument_list|,
name|block
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|bb
argument_list|,
name|corruptedBlocks
argument_list|,
name|hedgedReadId
operator|++
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|ByteBuffer
argument_list|>
name|oneMoreRequest
init|=
name|hedgedService
operator|.
name|submit
argument_list|(
name|getFromDataNodeCallable
argument_list|)
decl_stmt|;
name|futures
operator|.
name|add
argument_list|(
name|oneMoreRequest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|refetch
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed getting node for hedged read: {}"
argument_list|,
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if not succeeded. Submit callables for each datanode in a loop, wait
comment|// for a fixed interval and get the result from the fastest one.
try|try
block|{
name|ByteBuffer
name|result
init|=
name|getFirstToComplete
argument_list|(
name|hedgedService
argument_list|,
name|futures
argument_list|)
decl_stmt|;
comment|// cancel the rest.
name|cancelAll
argument_list|(
name|futures
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|getHedgedReadMetrics
argument_list|()
operator|.
name|incHedgedReadWins
argument_list|()
expr_stmt|;
name|result
operator|.
name|flip
argument_list|()
expr_stmt|;
name|buf
operator|.
name|put
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// Ignore and retry
block|}
if|if
condition|(
name|refetch
condition|)
block|{
name|refetchLocations
argument_list|(
name|block
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
comment|// We got here if exception. Ignore this node on next go around IFF
comment|// we found a chosenNode to hedge read against.
if|if
condition|(
name|chosenNode
operator|!=
literal|null
operator|&&
name|chosenNode
operator|.
name|info
operator|!=
literal|null
condition|)
block|{
name|ignored
operator|.
name|add
argument_list|(
name|chosenNode
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getHedgedReadOpsLoopNumForTesting ()
specifier|public
name|long
name|getHedgedReadOpsLoopNumForTesting
parameter_list|()
block|{
return|return
name|hedgedReadOpsLoopNumForTesting
return|;
block|}
DECL|method|getFirstToComplete ( CompletionService<ByteBuffer> hedgedService, ArrayList<Future<ByteBuffer>> futures)
specifier|private
name|ByteBuffer
name|getFirstToComplete
parameter_list|(
name|CompletionService
argument_list|<
name|ByteBuffer
argument_list|>
name|hedgedService
parameter_list|,
name|ArrayList
argument_list|<
name|Future
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|>
name|futures
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|futures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|(
literal|"let's retry"
argument_list|)
throw|;
block|}
name|Future
argument_list|<
name|ByteBuffer
argument_list|>
name|future
init|=
literal|null
decl_stmt|;
try|try
block|{
name|future
operator|=
name|hedgedService
operator|.
name|take
argument_list|()
expr_stmt|;
name|ByteBuffer
name|bb
init|=
name|future
operator|.
name|get
argument_list|()
decl_stmt|;
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
decl||
name|CancellationException
name|e
parameter_list|)
block|{
comment|// already logged in the Callable
name|futures
operator|.
name|remove
argument_list|(
name|future
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|InterruptedException
argument_list|(
literal|"let's retry"
argument_list|)
throw|;
block|}
DECL|method|cancelAll (List<Future<ByteBuffer>> futures)
specifier|private
name|void
name|cancelAll
parameter_list|(
name|List
argument_list|<
name|Future
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
for|for
control|(
name|Future
argument_list|<
name|ByteBuffer
argument_list|>
name|future
range|:
name|futures
control|)
block|{
comment|// Unfortunately, hdfs reads do not take kindly to interruption.
comment|// Threads return a variety of interrupted-type exceptions but
comment|// also complaints about invalid pbs -- likely because read
comment|// is interrupted before gets whole pb.  Also verbose WARN
comment|// logging.  So, for now, do not interrupt running read.
name|future
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Should the block access token be refetched on an exception    *    * @param ex Exception received    * @param targetAddr Target datanode address from where exception was received    * @return true if block access token has expired or invalid and it should be    *         refetched    */
DECL|method|tokenRefetchNeeded (IOException ex, InetSocketAddress targetAddr)
specifier|protected
specifier|static
name|boolean
name|tokenRefetchNeeded
parameter_list|(
name|IOException
name|ex
parameter_list|,
name|InetSocketAddress
name|targetAddr
parameter_list|)
block|{
comment|/*      * Get a new access token and retry. Retry is needed in 2 cases. 1)      * When both NN and DN re-started while DFSClient holding a cached      * access token. 2) In the case that NN fails to update its      * access key at pre-set interval (by a wide margin) and      * subsequently restarts. In this case, DN re-registers itself with      * NN and receives a new access key, but DN will delete the old      * access key from its memory since it's considered expired based on      * the estimated expiration date.      */
if|if
condition|(
name|ex
operator|instanceof
name|InvalidBlockTokenException
operator|||
name|ex
operator|instanceof
name|InvalidToken
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Access token was invalid when connecting to {}: {}"
argument_list|,
name|targetAddr
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Read bytes starting from the specified position.    *    * @param position start read from this position    * @param buffer read buffer    * @param offset offset into buffer    * @param length number of bytes to read    *    * @return actual number of bytes read    */
annotation|@
name|Override
DECL|method|read (long position, byte[] buffer, int offset, int length)
specifier|public
name|int
name|read
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|validatePositionedReadArgs
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|ByteBuffer
name|bb
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
return|return
name|pread
argument_list|(
name|position
argument_list|,
name|bb
argument_list|)
return|;
block|}
DECL|method|pread (long position, ByteBuffer buffer)
specifier|private
name|int
name|pread
parameter_list|(
name|long
name|position
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// sanity checks
name|dfsClient
operator|.
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream closed"
argument_list|)
throw|;
block|}
name|failures
operator|=
literal|0
expr_stmt|;
name|long
name|filelen
init|=
name|getFileLength
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|position
operator|<
literal|0
operator|)
operator|||
operator|(
name|position
operator|>=
name|filelen
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|length
init|=
name|buffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|int
name|realLen
init|=
name|length
decl_stmt|;
if|if
condition|(
operator|(
name|position
operator|+
name|length
operator|)
operator|>
name|filelen
condition|)
block|{
name|realLen
operator|=
call|(
name|int
call|)
argument_list|(
name|filelen
operator|-
name|position
argument_list|)
expr_stmt|;
block|}
comment|// determine the block and byte range within the block
comment|// corresponding to position and realLen
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|blockRange
init|=
name|getBlockRange
argument_list|(
name|position
argument_list|,
name|realLen
argument_list|)
decl_stmt|;
name|int
name|remaining
init|=
name|realLen
decl_stmt|;
name|CorruptedBlocks
name|corruptedBlocks
init|=
operator|new
name|CorruptedBlocks
argument_list|()
decl_stmt|;
for|for
control|(
name|LocatedBlock
name|blk
range|:
name|blockRange
control|)
block|{
name|long
name|targetStart
init|=
name|position
operator|-
name|blk
operator|.
name|getStartOffset
argument_list|()
decl_stmt|;
name|int
name|bytesToRead
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|remaining
argument_list|,
name|blk
operator|.
name|getBlockSize
argument_list|()
operator|-
name|targetStart
argument_list|)
decl_stmt|;
name|long
name|targetEnd
init|=
name|targetStart
operator|+
name|bytesToRead
operator|-
literal|1
decl_stmt|;
try|try
block|{
if|if
condition|(
name|dfsClient
operator|.
name|isHedgedReadsEnabled
argument_list|()
operator|&&
operator|!
name|blk
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|hedgedFetchBlockByteRange
argument_list|(
name|blk
argument_list|,
name|targetStart
argument_list|,
name|targetEnd
argument_list|,
name|buffer
argument_list|,
name|corruptedBlocks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fetchBlockByteRange
argument_list|(
name|blk
argument_list|,
name|targetStart
argument_list|,
name|targetEnd
argument_list|,
name|buffer
argument_list|,
name|corruptedBlocks
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// Check and report if any block replicas are corrupted.
comment|// BlockMissingException may be caught if all block replicas are
comment|// corrupted.
name|reportCheckSumFailure
argument_list|(
name|corruptedBlocks
argument_list|,
name|blk
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|remaining
operator|-=
name|bytesToRead
expr_stmt|;
name|position
operator|+=
name|bytesToRead
expr_stmt|;
block|}
assert|assert
name|remaining
operator|==
literal|0
operator|:
literal|"Wrong number of bytes read."
assert|;
return|return
name|realLen
return|;
block|}
comment|/**    * DFSInputStream reports checksum failure.    * For replicated blocks, we have the following logic:    * Case I : client has tried multiple data nodes and at least one of the    * attempts has succeeded. We report the other failures as corrupted block to    * namenode.    * Case II: client has tried out all data nodes, but all failed. We    * only report if the total number of replica is 1. We do not    * report otherwise since this maybe due to the client is a handicapped client    * (who can not read).    *    * For erasure-coded blocks, each block in corruptedBlockMap is an internal    * block in a block group, and there is usually only one DataNode    * corresponding to each internal block. For this case we simply report the    * corrupted blocks to NameNode and ignore the above logic.    *    * @param corruptedBlocks map of corrupted blocks    * @param dataNodeCount number of data nodes who contains the block replicas    */
DECL|method|reportCheckSumFailure (CorruptedBlocks corruptedBlocks, int dataNodeCount, boolean isStriped)
specifier|protected
name|void
name|reportCheckSumFailure
parameter_list|(
name|CorruptedBlocks
name|corruptedBlocks
parameter_list|,
name|int
name|dataNodeCount
parameter_list|,
name|boolean
name|isStriped
parameter_list|)
block|{
name|Map
argument_list|<
name|ExtendedBlock
argument_list|,
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
name|corruptedBlockMap
init|=
name|corruptedBlocks
operator|.
name|getCorruptionMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|corruptedBlockMap
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|reportList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|corruptedBlockMap
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ExtendedBlock
argument_list|,
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
name|entry
range|:
name|corruptedBlockMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ExtendedBlock
name|blk
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|DatanodeInfo
argument_list|>
name|dnSet
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|isStriped
operator|||
operator|(
operator|(
name|dnSet
operator|.
name|size
argument_list|()
operator|<
name|dataNodeCount
operator|)
operator|&&
operator|(
name|dnSet
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|dataNodeCount
operator|==
literal|1
operator|)
operator|&&
operator|(
name|dnSet
operator|.
name|size
argument_list|()
operator|==
name|dataNodeCount
operator|)
operator|)
condition|)
block|{
name|DatanodeInfo
index|[]
name|locs
init|=
operator|new
name|DatanodeInfo
index|[
name|dnSet
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeInfo
name|dn
range|:
name|dnSet
control|)
block|{
name|locs
index|[
name|i
operator|++
index|]
operator|=
name|dn
expr_stmt|;
block|}
name|reportList
operator|.
name|add
argument_list|(
operator|new
name|LocatedBlock
argument_list|(
name|blk
argument_list|,
name|locs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reportList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dfsClient
operator|.
name|reportChecksumFailure
argument_list|(
name|src
argument_list|,
name|reportList
operator|.
name|toArray
argument_list|(
operator|new
name|LocatedBlock
index|[
name|reportList
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|corruptedBlockMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|long
name|curPos
init|=
name|getPos
argument_list|()
decl_stmt|;
name|long
name|fileLen
init|=
name|getFileLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|+
name|curPos
operator|>
name|fileLen
condition|)
block|{
name|n
operator|=
name|fileLen
operator|-
name|curPos
expr_stmt|;
block|}
name|seek
argument_list|(
name|curPos
operator|+
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
return|return
name|n
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
comment|/**    * Seek to a new arbitrary location    */
annotation|@
name|Override
DECL|method|seek (long targetPos)
specifier|public
specifier|synchronized
name|void
name|seek
parameter_list|(
name|long
name|targetPos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|targetPos
operator|>
name|getFileLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Cannot seek after EOF"
argument_list|)
throw|;
block|}
if|if
condition|(
name|targetPos
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Cannot seek to negative offset"
argument_list|)
throw|;
block|}
if|if
condition|(
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream is closed!"
argument_list|)
throw|;
block|}
name|boolean
name|done
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|pos
operator|<=
name|targetPos
operator|&&
name|targetPos
operator|<=
name|blockEnd
condition|)
block|{
comment|//
comment|// If this seek is to a positive position in the current
comment|// block, and this piece of data might already be lying in
comment|// the TCP buffer, then just eat up the intervening data.
comment|//
name|int
name|diff
init|=
call|(
name|int
call|)
argument_list|(
name|targetPos
operator|-
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|<=
name|blockReader
operator|.
name|available
argument_list|()
condition|)
block|{
try|try
block|{
name|pos
operator|+=
name|blockReader
operator|.
name|skip
argument_list|(
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|targetPos
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// The range was already checked. If the block reader returns
comment|// something unexpected instead of throwing an exception, it is
comment|// most likely a bug.
name|String
name|errMsg
init|=
literal|"BlockReader failed to seek to "
operator|+
name|targetPos
operator|+
literal|". Instead, it seeked to "
operator|+
name|pos
operator|+
literal|"."
decl_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|errMsg
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//make following read to retry
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while seek to {} from {} of {} from "
operator|+
literal|"{}"
argument_list|,
name|targetPos
argument_list|,
name|getCurrentBlock
argument_list|()
argument_list|,
name|src
argument_list|,
name|currentNode
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|checkInterrupted
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|pos
operator|=
name|targetPos
expr_stmt|;
name|blockEnd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/**    * Same as {@link #seekToNewSource(long)} except that it does not exclude    * the current datanode and might connect to the same node.    */
DECL|method|seekToBlockSource (long targetPos)
specifier|private
name|boolean
name|seekToBlockSource
parameter_list|(
name|long
name|targetPos
parameter_list|)
throws|throws
name|IOException
block|{
name|currentNode
operator|=
name|blockSeekTo
argument_list|(
name|targetPos
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Seek to given position on a node other than the current node.  If    * a node other than the current node is found, then returns true.    * If another node could not be found, then returns false.    */
annotation|@
name|Override
DECL|method|seekToNewSource (long targetPos)
specifier|public
specifier|synchronized
name|boolean
name|seekToNewSource
parameter_list|(
name|long
name|targetPos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentNode
operator|==
literal|null
condition|)
block|{
return|return
name|seekToBlockSource
argument_list|(
name|targetPos
argument_list|)
return|;
block|}
name|boolean
name|markedDead
init|=
name|dfsClient
operator|.
name|isDeadNode
argument_list|(
name|this
argument_list|,
name|currentNode
argument_list|)
decl_stmt|;
name|addToLocalDeadNodes
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
name|DatanodeInfo
name|oldNode
init|=
name|currentNode
decl_stmt|;
name|DatanodeInfo
name|newNode
init|=
name|blockSeekTo
argument_list|(
name|targetPos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|markedDead
condition|)
block|{
comment|/* remove it from deadNodes. blockSeekTo could have cleared        * deadNodes and added currentNode again. Thats ok. */
name|removeFromLocalDeadNodes
argument_list|(
name|oldNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oldNode
operator|.
name|getDatanodeUuid
argument_list|()
operator|.
name|equals
argument_list|(
name|newNode
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
condition|)
block|{
name|currentNode
operator|=
name|newNode
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    */
annotation|@
name|Override
DECL|method|getPos ()
specifier|public
specifier|synchronized
name|long
name|getPos
parameter_list|()
block|{
return|return
name|pos
return|;
block|}
comment|/** Return the size of the remaining available bytes    * if the size is less than or equal to {@link Integer#MAX_VALUE},    * otherwise, return {@link Integer#MAX_VALUE}.    */
annotation|@
name|Override
DECL|method|available ()
specifier|public
specifier|synchronized
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream closed"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|remaining
init|=
name|getFileLength
argument_list|()
operator|-
name|pos
decl_stmt|;
return|return
name|remaining
operator|<=
name|Integer
operator|.
name|MAX_VALUE
condition|?
operator|(
name|int
operator|)
name|remaining
else|:
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
comment|/**    * We definitely don't support marks    */
annotation|@
name|Override
DECL|method|markSupported ()
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|mark (int readLimit)
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readLimit
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mark/reset not supported"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|read (long position, final ByteBuffer buf)
specifier|public
name|int
name|read
parameter_list|(
name|long
name|position
parameter_list|,
specifier|final
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|pread
argument_list|(
name|position
argument_list|,
name|buf
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|readFully (long position, final ByteBuffer buf)
specifier|public
name|void
name|readFully
parameter_list|(
name|long
name|position
parameter_list|,
specifier|final
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|nread
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|int
name|nbytes
init|=
name|read
argument_list|(
name|position
operator|+
name|nread
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|FSExceptionMessages
operator|.
name|EOF_IN_READ_FULLY
argument_list|)
throw|;
block|}
name|nread
operator|+=
name|nbytes
expr_stmt|;
block|}
block|}
comment|/** Utility class to encapsulate data node info and its address. */
DECL|class|DNAddrPair
specifier|static
specifier|final
class|class
name|DNAddrPair
block|{
DECL|field|info
specifier|final
name|DatanodeInfo
name|info
decl_stmt|;
DECL|field|addr
specifier|final
name|InetSocketAddress
name|addr
decl_stmt|;
DECL|field|storageType
specifier|final
name|StorageType
name|storageType
decl_stmt|;
DECL|field|block
specifier|final
name|LocatedBlock
name|block
decl_stmt|;
DECL|method|DNAddrPair (DatanodeInfo info, InetSocketAddress addr, StorageType storageType, LocatedBlock block)
name|DNAddrPair
parameter_list|(
name|DatanodeInfo
name|info
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|StorageType
name|storageType
parameter_list|,
name|LocatedBlock
name|block
parameter_list|)
block|{
name|this
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|this
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|this
operator|.
name|storageType
operator|=
name|storageType
expr_stmt|;
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
block|}
block|}
comment|/**    * Get statistics about the reads which this DFSInputStream has done.    */
DECL|method|getReadStatistics ()
specifier|public
name|ReadStatistics
name|getReadStatistics
parameter_list|()
block|{
return|return
name|readStatistics
return|;
block|}
comment|/**    * Clear statistics about the reads which this DFSInputStream has done.    */
DECL|method|clearReadStatistics ()
specifier|public
name|void
name|clearReadStatistics
parameter_list|()
block|{
name|readStatistics
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|getFileEncryptionInfo ()
specifier|public
name|FileEncryptionInfo
name|getFileEncryptionInfo
parameter_list|()
block|{
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
return|return
name|fileEncryptionInfo
return|;
block|}
block|}
DECL|method|closeCurrentBlockReaders ()
specifier|protected
name|void
name|closeCurrentBlockReaders
parameter_list|()
block|{
if|if
condition|(
name|blockReader
operator|==
literal|null
condition|)
return|return;
comment|// Close the current block reader so that the new caching settings can
comment|// take effect immediately.
try|try
block|{
name|blockReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"error closing blockReader"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|blockReader
operator|=
literal|null
expr_stmt|;
name|blockEnd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setReadahead (Long readahead)
specifier|public
specifier|synchronized
name|void
name|setReadahead
parameter_list|(
name|Long
name|readahead
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
name|this
operator|.
name|cachingStrategy
operator|=
operator|new
name|CachingStrategy
operator|.
name|Builder
argument_list|(
name|this
operator|.
name|cachingStrategy
argument_list|)
operator|.
name|setReadahead
argument_list|(
name|readahead
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|closeCurrentBlockReaders
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setDropBehind (Boolean dropBehind)
specifier|public
specifier|synchronized
name|void
name|setDropBehind
parameter_list|(
name|Boolean
name|dropBehind
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|infoLock
init|)
block|{
name|this
operator|.
name|cachingStrategy
operator|=
operator|new
name|CachingStrategy
operator|.
name|Builder
argument_list|(
name|this
operator|.
name|cachingStrategy
argument_list|)
operator|.
name|setDropBehind
argument_list|(
name|dropBehind
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|closeCurrentBlockReaders
argument_list|()
expr_stmt|;
block|}
comment|/**    * The immutable empty buffer we return when we reach EOF when doing a    * zero-copy read.    */
DECL|field|EMPTY_BUFFER
specifier|private
specifier|static
specifier|final
name|ByteBuffer
name|EMPTY_BUFFER
init|=
name|ByteBuffer
operator|.
name|allocateDirect
argument_list|(
literal|0
argument_list|)
operator|.
name|asReadOnlyBuffer
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|read (ByteBufferPool bufferPool, int maxLength, EnumSet<ReadOption> opts)
specifier|public
specifier|synchronized
name|ByteBuffer
name|read
parameter_list|(
name|ByteBufferPool
name|bufferPool
parameter_list|,
name|int
name|maxLength
parameter_list|,
name|EnumSet
argument_list|<
name|ReadOption
argument_list|>
name|opts
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnsupportedOperationException
block|{
if|if
condition|(
name|maxLength
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_BUFFER
return|;
block|}
elseif|else
if|if
condition|(
name|maxLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"can't read a negative "
operator|+
literal|"number of bytes."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|blockReader
operator|==
literal|null
operator|)
operator|||
operator|(
name|blockEnd
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|pos
operator|>=
name|getFileLength
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|/*        * If we don't have a blockReader, or the one we have has no more bytes        * left to read, we call seekToBlockSource to get a new blockReader and        * recalculate blockEnd.  Note that we assume we're not at EOF here        * (we check this above).        */
if|if
condition|(
operator|(
operator|!
name|seekToBlockSource
argument_list|(
name|pos
argument_list|)
operator|)
operator|||
operator|(
name|blockReader
operator|==
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failed to allocate new BlockReader "
operator|+
literal|"at position "
operator|+
name|pos
argument_list|)
throw|;
block|}
block|}
name|ByteBuffer
name|buffer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|getShortCircuitConf
argument_list|()
operator|.
name|isShortCircuitMmapEnabled
argument_list|()
condition|)
block|{
name|buffer
operator|=
name|tryReadZeroCopy
argument_list|(
name|maxLength
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buffer
operator|!=
literal|null
condition|)
block|{
return|return
name|buffer
return|;
block|}
name|buffer
operator|=
name|ByteBufferUtil
operator|.
name|fallbackRead
argument_list|(
name|this
argument_list|,
name|bufferPool
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
literal|null
condition|)
block|{
name|getExtendedReadBuffers
argument_list|()
operator|.
name|put
argument_list|(
name|buffer
argument_list|,
name|bufferPool
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
DECL|method|tryReadZeroCopy (int maxLength, EnumSet<ReadOption> opts)
specifier|private
specifier|synchronized
name|ByteBuffer
name|tryReadZeroCopy
parameter_list|(
name|int
name|maxLength
parameter_list|,
name|EnumSet
argument_list|<
name|ReadOption
argument_list|>
name|opts
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Copy 'pos' and 'blockEnd' to local variables to make it easier for the
comment|// JVM to optimize this function.
specifier|final
name|long
name|curPos
init|=
name|pos
decl_stmt|;
specifier|final
name|long
name|curEnd
init|=
name|blockEnd
decl_stmt|;
specifier|final
name|long
name|blockStartInFile
init|=
name|currentLocatedBlock
operator|.
name|getStartOffset
argument_list|()
decl_stmt|;
specifier|final
name|long
name|blockPos
init|=
name|curPos
operator|-
name|blockStartInFile
decl_stmt|;
comment|// Shorten this read if the end of the block is nearby.
name|long
name|length63
decl_stmt|;
if|if
condition|(
operator|(
name|curPos
operator|+
name|maxLength
operator|)
operator|<=
operator|(
name|curEnd
operator|+
literal|1
operator|)
condition|)
block|{
name|length63
operator|=
name|maxLength
expr_stmt|;
block|}
else|else
block|{
name|length63
operator|=
literal|1
operator|+
name|curEnd
operator|-
name|curPos
expr_stmt|;
if|if
condition|(
name|length63
operator|<=
literal|0
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to perform a zero-copy read from offset {}"
operator|+
literal|" of {}; {} bytes left in block. blockPos={}; curPos={};"
operator|+
literal|"curEnd={}"
argument_list|,
name|curPos
argument_list|,
name|src
argument_list|,
name|length63
argument_list|,
name|blockPos
argument_list|,
name|curPos
argument_list|,
name|curEnd
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reducing read length from {} to {} to avoid going "
operator|+
literal|"more than one byte past the end of the block.  blockPos={}; "
operator|+
literal|" curPos={}; curEnd={}"
argument_list|,
name|maxLength
argument_list|,
name|length63
argument_list|,
name|blockPos
argument_list|,
name|curPos
argument_list|,
name|curEnd
argument_list|)
expr_stmt|;
block|}
comment|// Make sure that don't go beyond 31-bit offsets in the MappedByteBuffer.
name|int
name|length
decl_stmt|;
if|if
condition|(
name|blockPos
operator|+
name|length63
operator|<=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|length
operator|=
operator|(
name|int
operator|)
name|length63
expr_stmt|;
block|}
else|else
block|{
name|long
name|length31
init|=
name|Integer
operator|.
name|MAX_VALUE
operator|-
name|blockPos
decl_stmt|;
if|if
condition|(
name|length31
operator|<=
literal|0
condition|)
block|{
comment|// Java ByteBuffers can't be longer than 2 GB, because they use
comment|// 4-byte signed integers to represent capacity, etc.
comment|// So we can't mmap the parts of the block higher than the 2 GB offset.
comment|// FIXME: we could work around this with multiple memory maps.
comment|// See HDFS-5101.
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to perform a zero-copy read from offset {} "
operator|+
literal|" of {}; 31-bit MappedByteBuffer limit exceeded.  blockPos={}, "
operator|+
literal|"curEnd={}"
argument_list|,
name|curPos
argument_list|,
name|src
argument_list|,
name|blockPos
argument_list|,
name|curEnd
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|length
operator|=
operator|(
name|int
operator|)
name|length31
expr_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reducing read length from {} to {} to avoid 31-bit "
operator|+
literal|"limit.  blockPos={}; curPos={}; curEnd={}"
argument_list|,
name|maxLength
argument_list|,
name|length
argument_list|,
name|blockPos
argument_list|,
name|curPos
argument_list|,
name|curEnd
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ClientMmap
name|clientMmap
init|=
name|blockReader
operator|.
name|getClientMmap
argument_list|(
name|opts
argument_list|)
decl_stmt|;
if|if
condition|(
name|clientMmap
operator|==
literal|null
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"unable to perform a zero-copy read from offset {} of"
operator|+
literal|" {}; BlockReader#getClientMmap returned null."
argument_list|,
name|curPos
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|ByteBuffer
name|buffer
decl_stmt|;
try|try
block|{
name|seek
argument_list|(
name|curPos
operator|+
name|length
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|clientMmap
operator|.
name|getMappedByteBuffer
argument_list|()
operator|.
name|asReadOnlyBuffer
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|position
argument_list|(
operator|(
name|int
operator|)
name|blockPos
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|limit
argument_list|(
call|(
name|int
call|)
argument_list|(
name|blockPos
operator|+
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|getExtendedReadBuffers
argument_list|()
operator|.
name|put
argument_list|(
name|buffer
argument_list|,
name|clientMmap
argument_list|)
expr_stmt|;
name|readStatistics
operator|.
name|addZeroCopyBytes
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"readZeroCopy read {} bytes from offset {} via the "
operator|+
literal|"zero-copy read path.  blockEnd = {}"
argument_list|,
name|length
argument_list|,
name|curPos
argument_list|,
name|blockEnd
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|clientMmap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buffer
return|;
block|}
annotation|@
name|Override
DECL|method|releaseBuffer (ByteBuffer buffer)
specifier|public
specifier|synchronized
name|void
name|releaseBuffer
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|==
name|EMPTY_BUFFER
condition|)
return|return;
name|Object
name|val
init|=
name|getExtendedReadBuffers
argument_list|()
operator|.
name|remove
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"tried to release a buffer "
operator|+
literal|"that was not created by this stream, "
operator|+
name|buffer
argument_list|)
throw|;
block|}
if|if
condition|(
name|val
operator|instanceof
name|ClientMmap
condition|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
operator|(
name|ClientMmap
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|instanceof
name|ByteBufferPool
condition|)
block|{
operator|(
operator|(
name|ByteBufferPool
operator|)
name|val
operator|)
operator|.
name|putBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|unbuffer ()
specifier|public
specifier|synchronized
name|void
name|unbuffer
parameter_list|()
block|{
name|closeCurrentBlockReaders
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasCapability (String capability)
specifier|public
name|boolean
name|hasCapability
parameter_list|(
name|String
name|capability
parameter_list|)
block|{
switch|switch
condition|(
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|capability
argument_list|)
condition|)
block|{
case|case
name|StreamCapabilities
operator|.
name|READAHEAD
case|:
case|case
name|StreamCapabilities
operator|.
name|DROPBEHIND
case|:
case|case
name|StreamCapabilities
operator|.
name|UNBUFFER
case|:
case|case
name|StreamCapabilities
operator|.
name|READBYTEBUFFER
case|:
case|case
name|StreamCapabilities
operator|.
name|PREADBYTEBUFFER
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

