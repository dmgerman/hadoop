begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.client.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ReadOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|BlockReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|DfsClientConf
operator|.
name|ShortCircuitConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockLocalPathInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|BlockMetadataHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|shortcircuit
operator|.
name|ClientMmap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|IOUtilsClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DirectBufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Tracer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * BlockReaderLocalLegacy enables local short circuited reads. If the DFS client  * is on the same machine as the datanode, then the client can read files  * directly from the local file system rather than going through the datanode  * for better performance.<br>  *  * This is the legacy implementation based on HDFS-2246, which requires  * permissions on the datanode to be set so that clients can directly access the  * blocks. The new implementation based on HDFS-347 should be preferred on UNIX  * systems where the required native code has been implemented.<br>  *  * {@link BlockReaderLocalLegacy} works as follows:  *<ul>  *<li>The client performing short circuit reads must be configured at the  * datanode.</li>  *<li>The client gets the path to the file where block is stored using  * {@link org.apache.hadoop.hdfs.protocol.ClientDatanodeProtocol#getBlockLocalPathInfo(ExtendedBlock, Token)}  * RPC call</li>  *<li>Client uses kerberos authentication to connect to the datanode over RPC,  * if security is enabled.</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockReaderLocalLegacy
class|class
name|BlockReaderLocalLegacy
implements|implements
name|BlockReader
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BlockReaderLocalLegacy
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//Stores the cache and proxy for a local datanode.
DECL|class|LocalDatanodeInfo
specifier|private
specifier|static
class|class
name|LocalDatanodeInfo
block|{
DECL|field|proxy
specifier|private
name|ClientDatanodeProtocol
name|proxy
init|=
literal|null
decl_stmt|;
DECL|field|cache
specifier|private
specifier|final
name|Map
argument_list|<
name|ExtendedBlock
argument_list|,
name|BlockLocalPathInfo
argument_list|>
name|cache
decl_stmt|;
DECL|method|LocalDatanodeInfo ()
name|LocalDatanodeInfo
parameter_list|()
block|{
specifier|final
name|int
name|cacheSize
init|=
literal|10000
decl_stmt|;
specifier|final
name|float
name|hashTableLoadFactor
init|=
literal|0.75f
decl_stmt|;
name|int
name|hashTableCapacity
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|cacheSize
operator|/
name|hashTableLoadFactor
argument_list|)
operator|+
literal|1
decl_stmt|;
name|cache
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|ExtendedBlock
argument_list|,
name|BlockLocalPathInfo
argument_list|>
argument_list|(
name|hashTableCapacity
argument_list|,
name|hashTableLoadFactor
argument_list|,
literal|true
argument_list|)
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|ExtendedBlock
argument_list|,
name|BlockLocalPathInfo
argument_list|>
name|eldest
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>
name|cacheSize
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|getDatanodeProxy ( UserGroupInformation ugi, final DatanodeInfo node, final Configuration conf, final int socketTimeout, final boolean connectToDnViaHostname)
specifier|private
specifier|synchronized
name|ClientDatanodeProtocol
name|getDatanodeProxy
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
specifier|final
name|DatanodeInfo
name|node
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|int
name|socketTimeout
parameter_list|,
specifier|final
name|boolean
name|connectToDnViaHostname
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|proxy
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|proxy
operator|=
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|ClientDatanodeProtocol
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ClientDatanodeProtocol
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|DFSUtilClient
operator|.
name|createClientDatanodeProtocolProxy
argument_list|(
name|node
argument_list|,
name|conf
argument_list|,
name|socketTimeout
argument_list|,
name|connectToDnViaHostname
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"encountered exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|proxy
return|;
block|}
DECL|method|resetDatanodeProxy ()
specifier|private
specifier|synchronized
name|void
name|resetDatanodeProxy
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|!=
name|proxy
condition|)
block|{
name|RPC
operator|.
name|stopProxy
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
name|proxy
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|getBlockLocalPathInfo (ExtendedBlock b)
specifier|private
name|BlockLocalPathInfo
name|getBlockLocalPathInfo
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
block|{
return|return
name|cache
operator|.
name|get
argument_list|(
name|b
argument_list|)
return|;
block|}
DECL|method|setBlockLocalPathInfo (ExtendedBlock b, BlockLocalPathInfo info)
specifier|private
name|void
name|setBlockLocalPathInfo
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|BlockLocalPathInfo
name|info
parameter_list|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|b
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
DECL|method|removeBlockLocalPathInfo (ExtendedBlock b)
specifier|private
name|void
name|removeBlockLocalPathInfo
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
block|{
name|cache
operator|.
name|remove
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Multiple datanodes could be running on the local machine. Store proxies in
comment|// a map keyed by the ipc port of the datanode.
DECL|field|localDatanodeInfoMap
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|LocalDatanodeInfo
argument_list|>
name|localDatanodeInfoMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|dataIn
specifier|private
specifier|final
name|FileInputStream
name|dataIn
decl_stmt|;
comment|// reader for the data file
DECL|field|checksumIn
specifier|private
specifier|final
name|FileInputStream
name|checksumIn
decl_stmt|;
comment|// reader for the checksum file
comment|/**    * Offset from the most recent chunk boundary at which the next read should    * take place. Is only set to non-zero at construction time, and is    * decremented (usually to 0) by subsequent reads. This avoids having to do a    * checksum read at construction to position the read cursor correctly.    */
DECL|field|offsetFromChunkBoundary
specifier|private
name|int
name|offsetFromChunkBoundary
decl_stmt|;
DECL|field|skipBuf
specifier|private
name|byte
index|[]
name|skipBuf
init|=
literal|null
decl_stmt|;
comment|/**    * Used for checksummed reads that need to be staged before copying to their    * output buffer because they are either a) smaller than the checksum chunk    * size or b) issued by the slower read(byte[]...) path    */
DECL|field|slowReadBuff
specifier|private
name|ByteBuffer
name|slowReadBuff
init|=
literal|null
decl_stmt|;
DECL|field|checksumBuff
specifier|private
name|ByteBuffer
name|checksumBuff
init|=
literal|null
decl_stmt|;
DECL|field|checksum
specifier|private
name|DataChecksum
name|checksum
decl_stmt|;
DECL|field|verifyChecksum
specifier|private
specifier|final
name|boolean
name|verifyChecksum
decl_stmt|;
DECL|field|bufferPool
specifier|private
specifier|static
specifier|final
name|DirectBufferPool
name|bufferPool
init|=
operator|new
name|DirectBufferPool
argument_list|()
decl_stmt|;
DECL|field|bytesPerChecksum
specifier|private
specifier|final
name|int
name|bytesPerChecksum
decl_stmt|;
DECL|field|checksumSize
specifier|private
specifier|final
name|int
name|checksumSize
decl_stmt|;
comment|/** offset in block where reader wants to actually read */
DECL|field|startOffset
specifier|private
name|long
name|startOffset
decl_stmt|;
DECL|field|filename
specifier|private
specifier|final
name|String
name|filename
decl_stmt|;
DECL|field|blockId
specifier|private
name|long
name|blockId
decl_stmt|;
DECL|field|tracer
specifier|private
specifier|final
name|Tracer
name|tracer
decl_stmt|;
comment|/**    * The only way this object can be instantiated.    */
DECL|method|newBlockReader (DfsClientConf conf, UserGroupInformation userGroupInformation, Configuration configuration, String file, ExtendedBlock blk, Token<BlockTokenIdentifier> token, DatanodeInfo node, long startOffset, long length, StorageType storageType, Tracer tracer)
specifier|static
name|BlockReaderLocalLegacy
name|newBlockReader
parameter_list|(
name|DfsClientConf
name|conf
parameter_list|,
name|UserGroupInformation
name|userGroupInformation
parameter_list|,
name|Configuration
name|configuration
parameter_list|,
name|String
name|file
parameter_list|,
name|ExtendedBlock
name|blk
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|token
parameter_list|,
name|DatanodeInfo
name|node
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|long
name|length
parameter_list|,
name|StorageType
name|storageType
parameter_list|,
name|Tracer
name|tracer
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ShortCircuitConf
name|scConf
init|=
name|conf
operator|.
name|getShortCircuitConf
argument_list|()
decl_stmt|;
name|LocalDatanodeInfo
name|localDatanodeInfo
init|=
name|getLocalDatanodeInfo
argument_list|(
name|node
operator|.
name|getIpcPort
argument_list|()
argument_list|)
decl_stmt|;
comment|// check the cache first
name|BlockLocalPathInfo
name|pathinfo
init|=
name|localDatanodeInfo
operator|.
name|getBlockLocalPathInfo
argument_list|(
name|blk
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathinfo
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|userGroupInformation
operator|==
literal|null
condition|)
block|{
name|userGroupInformation
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
block|}
name|pathinfo
operator|=
name|getBlockPathInfo
argument_list|(
name|userGroupInformation
argument_list|,
name|blk
argument_list|,
name|node
argument_list|,
name|configuration
argument_list|,
name|conf
operator|.
name|getSocketTimeout
argument_list|()
argument_list|,
name|token
argument_list|,
name|conf
operator|.
name|isConnectToDnViaHostname
argument_list|()
argument_list|,
name|storageType
argument_list|)
expr_stmt|;
block|}
comment|// check to see if the file exists. It may so happen that the
comment|// HDFS file has been deleted and this block-lookup is occurring
comment|// on behalf of a new HDFS file. This time, the block file could
comment|// be residing in a different portion of the fs.data.dir directory.
comment|// In this case, we remove this entry from the cache. The next
comment|// call to this method will re-populate the cache.
name|FileInputStream
name|dataIn
init|=
literal|null
decl_stmt|;
name|FileInputStream
name|checksumIn
init|=
literal|null
decl_stmt|;
name|BlockReaderLocalLegacy
name|localBlockReader
init|=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|skipChecksumCheck
init|=
name|scConf
operator|.
name|isSkipShortCircuitChecksums
argument_list|()
operator|||
name|storageType
operator|.
name|isTransient
argument_list|()
decl_stmt|;
try|try
block|{
comment|// get a local file system
name|File
name|blkfile
init|=
operator|new
name|File
argument_list|(
name|pathinfo
operator|.
name|getBlockPath
argument_list|()
argument_list|)
decl_stmt|;
name|dataIn
operator|=
operator|new
name|FileInputStream
argument_list|(
name|blkfile
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"New BlockReaderLocalLegacy for file {} of size {} startOffset "
operator|+
literal|"{} length {} short circuit checksum {}"
argument_list|,
name|blkfile
argument_list|,
name|blkfile
operator|.
name|length
argument_list|()
argument_list|,
name|startOffset
argument_list|,
name|length
argument_list|,
operator|!
name|skipChecksumCheck
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skipChecksumCheck
condition|)
block|{
comment|// get the metadata file
name|File
name|metafile
init|=
operator|new
name|File
argument_list|(
name|pathinfo
operator|.
name|getMetaPath
argument_list|()
argument_list|)
decl_stmt|;
name|checksumIn
operator|=
operator|new
name|FileInputStream
argument_list|(
name|metafile
argument_list|)
expr_stmt|;
specifier|final
name|DataChecksum
name|checksum
init|=
name|BlockMetadataHeader
operator|.
name|readDataChecksum
argument_list|(
operator|new
name|DataInputStream
argument_list|(
name|checksumIn
argument_list|)
argument_list|,
name|blk
argument_list|)
decl_stmt|;
name|long
name|firstChunkOffset
init|=
name|startOffset
operator|-
operator|(
name|startOffset
operator|%
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
operator|)
decl_stmt|;
name|localBlockReader
operator|=
operator|new
name|BlockReaderLocalLegacy
argument_list|(
name|scConf
argument_list|,
name|file
argument_list|,
name|blk
argument_list|,
name|startOffset
argument_list|,
name|checksum
argument_list|,
literal|true
argument_list|,
name|dataIn
argument_list|,
name|firstChunkOffset
argument_list|,
name|checksumIn
argument_list|,
name|tracer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|localBlockReader
operator|=
operator|new
name|BlockReaderLocalLegacy
argument_list|(
name|scConf
argument_list|,
name|file
argument_list|,
name|blk
argument_list|,
name|startOffset
argument_list|,
name|dataIn
argument_list|,
name|tracer
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// remove from cache
name|localDatanodeInfo
operator|.
name|removeBlockLocalPathInfo
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"BlockReaderLocalLegacy: Removing "
operator|+
name|blk
operator|+
literal|" from cache because local file "
operator|+
name|pathinfo
operator|.
name|getBlockPath
argument_list|()
operator|+
literal|" could not be opened."
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|localBlockReader
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|dataIn
operator|!=
literal|null
condition|)
block|{
name|dataIn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|checksumIn
operator|!=
literal|null
condition|)
block|{
name|checksumIn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|localBlockReader
return|;
block|}
DECL|method|getLocalDatanodeInfo (int port)
specifier|private
specifier|static
specifier|synchronized
name|LocalDatanodeInfo
name|getLocalDatanodeInfo
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|LocalDatanodeInfo
name|ldInfo
init|=
name|localDatanodeInfoMap
operator|.
name|get
argument_list|(
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
name|ldInfo
operator|==
literal|null
condition|)
block|{
name|ldInfo
operator|=
operator|new
name|LocalDatanodeInfo
argument_list|()
expr_stmt|;
name|localDatanodeInfoMap
operator|.
name|put
argument_list|(
name|port
argument_list|,
name|ldInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|ldInfo
return|;
block|}
DECL|method|getBlockPathInfo (UserGroupInformation ugi, ExtendedBlock blk, DatanodeInfo node, Configuration conf, int timeout, Token<BlockTokenIdentifier> token, boolean connectToDnViaHostname, StorageType storageType)
specifier|private
specifier|static
name|BlockLocalPathInfo
name|getBlockPathInfo
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|ExtendedBlock
name|blk
parameter_list|,
name|DatanodeInfo
name|node
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|int
name|timeout
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|token
parameter_list|,
name|boolean
name|connectToDnViaHostname
parameter_list|,
name|StorageType
name|storageType
parameter_list|)
throws|throws
name|IOException
block|{
name|LocalDatanodeInfo
name|localDatanodeInfo
init|=
name|getLocalDatanodeInfo
argument_list|(
name|node
operator|.
name|getIpcPort
argument_list|()
argument_list|)
decl_stmt|;
name|BlockLocalPathInfo
name|pathinfo
decl_stmt|;
name|ClientDatanodeProtocol
name|proxy
init|=
name|localDatanodeInfo
operator|.
name|getDatanodeProxy
argument_list|(
name|ugi
argument_list|,
name|node
argument_list|,
name|conf
argument_list|,
name|timeout
argument_list|,
name|connectToDnViaHostname
argument_list|)
decl_stmt|;
try|try
block|{
comment|// make RPC to local datanode to find local pathnames of blocks
name|pathinfo
operator|=
name|proxy
operator|.
name|getBlockLocalPathInfo
argument_list|(
name|blk
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|// We can't cache the path information for a replica on transient storage.
comment|// If the replica gets evicted, then it moves to a different path.  Then,
comment|// our next attempt to read from the cached path would fail to find the
comment|// file.  Additionally, the failure would cause us to disable legacy
comment|// short-circuit read for all subsequent use in the ClientContext.  Unlike
comment|// the newer short-circuit read implementation, we have no communication
comment|// channel for the DataNode to notify the client that the path has been
comment|// invalidated.  Therefore, our only option is to skip caching.
if|if
condition|(
name|pathinfo
operator|!=
literal|null
operator|&&
operator|!
name|storageType
operator|.
name|isTransient
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cached location of block {} as {}"
argument_list|,
name|blk
argument_list|,
name|pathinfo
argument_list|)
expr_stmt|;
name|localDatanodeInfo
operator|.
name|setBlockLocalPathInfo
argument_list|(
name|blk
argument_list|,
name|pathinfo
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|localDatanodeInfo
operator|.
name|resetDatanodeProxy
argument_list|()
expr_stmt|;
comment|// Reset proxy on error
throw|throw
name|e
throw|;
block|}
return|return
name|pathinfo
return|;
block|}
DECL|method|getSlowReadBufferNumChunks (int bufferSizeBytes, int bytesPerChecksum)
specifier|private
specifier|static
name|int
name|getSlowReadBufferNumChunks
parameter_list|(
name|int
name|bufferSizeBytes
parameter_list|,
name|int
name|bytesPerChecksum
parameter_list|)
block|{
if|if
condition|(
name|bufferSizeBytes
operator|<
name|bytesPerChecksum
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Configured BlockReaderLocalLegacy "
operator|+
literal|"buffer size ("
operator|+
name|bufferSizeBytes
operator|+
literal|") is not large enough to hold "
operator|+
literal|"a single chunk ("
operator|+
name|bytesPerChecksum
operator|+
literal|"). Please configure "
operator|+
name|HdfsClientConfigKeys
operator|.
name|Read
operator|.
name|ShortCircuit
operator|.
name|BUFFER_SIZE_KEY
operator|+
literal|" appropriately"
argument_list|)
throw|;
block|}
comment|// Round down to nearest chunk size
return|return
name|bufferSizeBytes
operator|/
name|bytesPerChecksum
return|;
block|}
DECL|method|BlockReaderLocalLegacy (ShortCircuitConf conf, String hdfsfile, ExtendedBlock block, long startOffset, FileInputStream dataIn, Tracer tracer)
specifier|private
name|BlockReaderLocalLegacy
parameter_list|(
name|ShortCircuitConf
name|conf
parameter_list|,
name|String
name|hdfsfile
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|FileInputStream
name|dataIn
parameter_list|,
name|Tracer
name|tracer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|hdfsfile
argument_list|,
name|block
argument_list|,
name|startOffset
argument_list|,
name|DataChecksum
operator|.
name|newDataChecksum
argument_list|(
name|DataChecksum
operator|.
name|Type
operator|.
name|NULL
argument_list|,
literal|4
argument_list|)
argument_list|,
literal|false
argument_list|,
name|dataIn
argument_list|,
name|startOffset
argument_list|,
literal|null
argument_list|,
name|tracer
argument_list|)
expr_stmt|;
block|}
DECL|method|BlockReaderLocalLegacy (ShortCircuitConf conf, String hdfsfile, ExtendedBlock block, long startOffset, DataChecksum checksum, boolean verifyChecksum, FileInputStream dataIn, long firstChunkOffset, FileInputStream checksumIn, Tracer tracer)
specifier|private
name|BlockReaderLocalLegacy
parameter_list|(
name|ShortCircuitConf
name|conf
parameter_list|,
name|String
name|hdfsfile
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|DataChecksum
name|checksum
parameter_list|,
name|boolean
name|verifyChecksum
parameter_list|,
name|FileInputStream
name|dataIn
parameter_list|,
name|long
name|firstChunkOffset
parameter_list|,
name|FileInputStream
name|checksumIn
parameter_list|,
name|Tracer
name|tracer
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|filename
operator|=
name|hdfsfile
expr_stmt|;
name|this
operator|.
name|checksum
operator|=
name|checksum
expr_stmt|;
name|this
operator|.
name|verifyChecksum
operator|=
name|verifyChecksum
expr_stmt|;
name|this
operator|.
name|startOffset
operator|=
name|Math
operator|.
name|max
argument_list|(
name|startOffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockId
operator|=
name|block
operator|.
name|getBlockId
argument_list|()
expr_stmt|;
name|bytesPerChecksum
operator|=
name|this
operator|.
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
name|checksumSize
operator|=
name|this
operator|.
name|checksum
operator|.
name|getChecksumSize
argument_list|()
expr_stmt|;
name|this
operator|.
name|dataIn
operator|=
name|dataIn
expr_stmt|;
name|this
operator|.
name|checksumIn
operator|=
name|checksumIn
expr_stmt|;
name|this
operator|.
name|offsetFromChunkBoundary
operator|=
call|(
name|int
call|)
argument_list|(
name|startOffset
operator|-
name|firstChunkOffset
argument_list|)
expr_stmt|;
specifier|final
name|int
name|chunksPerChecksumRead
init|=
name|getSlowReadBufferNumChunks
argument_list|(
name|conf
operator|.
name|getShortCircuitBufferSize
argument_list|()
argument_list|,
name|bytesPerChecksum
argument_list|)
decl_stmt|;
name|slowReadBuff
operator|=
name|bufferPool
operator|.
name|getBuffer
argument_list|(
name|bytesPerChecksum
operator|*
name|chunksPerChecksumRead
argument_list|)
expr_stmt|;
name|checksumBuff
operator|=
name|bufferPool
operator|.
name|getBuffer
argument_list|(
name|checksumSize
operator|*
name|chunksPerChecksumRead
argument_list|)
expr_stmt|;
comment|// Initially the buffers have nothing to read.
name|slowReadBuff
operator|.
name|flip
argument_list|()
expr_stmt|;
name|checksumBuff
operator|.
name|flip
argument_list|()
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Skip both input streams to beginning of the chunk containing
comment|// startOffset
name|IOUtils
operator|.
name|skipFully
argument_list|(
name|dataIn
argument_list|,
name|firstChunkOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksumIn
operator|!=
literal|null
condition|)
block|{
name|long
name|checkSumOffset
init|=
operator|(
name|firstChunkOffset
operator|/
name|bytesPerChecksum
operator|)
operator|*
name|checksumSize
decl_stmt|;
name|IOUtils
operator|.
name|skipFully
argument_list|(
name|checksumIn
argument_list|,
name|checkSumOffset
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|bufferPool
operator|.
name|returnBuffer
argument_list|(
name|slowReadBuff
argument_list|)
expr_stmt|;
name|bufferPool
operator|.
name|returnBuffer
argument_list|(
name|checksumBuff
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|tracer
operator|=
name|tracer
expr_stmt|;
block|}
comment|/**    * Reads bytes into a buffer until EOF or the buffer's limit is reached    */
DECL|method|fillBuffer (FileInputStream stream, ByteBuffer buf)
specifier|private
name|int
name|fillBuffer
parameter_list|(
name|FileInputStream
name|stream
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|TraceScope
name|ignored
init|=
name|tracer
operator|.
name|newScope
argument_list|(
literal|"BlockReaderLocalLegacy#fillBuffer("
operator|+
name|blockId
operator|+
literal|")"
argument_list|)
init|)
block|{
name|int
name|bytesRead
init|=
name|stream
operator|.
name|getChannel
argument_list|()
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|<
literal|0
condition|)
block|{
comment|//EOF
return|return
name|bytesRead
return|;
block|}
while|while
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
name|stream
operator|.
name|getChannel
argument_list|()
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|//EOF
return|return
name|bytesRead
return|;
block|}
name|bytesRead
operator|+=
name|n
expr_stmt|;
block|}
return|return
name|bytesRead
return|;
block|}
block|}
comment|/**    * Utility method used by read(ByteBuffer) to partially copy a ByteBuffer into    * another.    */
DECL|method|writeSlice (ByteBuffer from, ByteBuffer to, int length)
specifier|private
name|void
name|writeSlice
parameter_list|(
name|ByteBuffer
name|from
parameter_list|,
name|ByteBuffer
name|to
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|oldLimit
init|=
name|from
operator|.
name|limit
argument_list|()
decl_stmt|;
name|from
operator|.
name|limit
argument_list|(
name|from
operator|.
name|position
argument_list|()
operator|+
name|length
argument_list|)
expr_stmt|;
try|try
block|{
name|to
operator|.
name|put
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|from
operator|.
name|limit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|read (ByteBuffer buf)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|nRead
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|verifyChecksum
condition|)
block|{
comment|// A 'direct' read actually has three phases. The first drains any
comment|// remaining bytes from the slow read buffer. After this the read is
comment|// guaranteed to be on a checksum chunk boundary. If there are still bytes
comment|// to read, the fast direct path is used for as many remaining bytes as
comment|// possible, up to a multiple of the checksum chunk size. Finally, any
comment|// 'odd' bytes remaining at the end of the read cause another slow read to
comment|// be issued, which involves an extra copy.
comment|// Every 'slow' read tries to fill the slow read buffer in one go for
comment|// efficiency's sake. As described above, all non-checksum-chunk-aligned
comment|// reads will be served from the slower read path.
if|if
condition|(
name|slowReadBuff
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
comment|// There are remaining bytes from a small read available. This usually
comment|// means this read is unaligned, which falls back to the slow path.
name|int
name|fromSlowReadBuff
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|slowReadBuff
operator|.
name|remaining
argument_list|()
argument_list|)
decl_stmt|;
name|writeSlice
argument_list|(
name|slowReadBuff
argument_list|,
name|buf
argument_list|,
name|fromSlowReadBuff
argument_list|)
expr_stmt|;
name|nRead
operator|+=
name|fromSlowReadBuff
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>=
name|bytesPerChecksum
operator|&&
name|offsetFromChunkBoundary
operator|==
literal|0
condition|)
block|{
comment|// Since we have drained the 'small read' buffer, we are guaranteed to
comment|// be chunk-aligned
name|int
name|len
init|=
name|buf
operator|.
name|remaining
argument_list|()
operator|-
operator|(
name|buf
operator|.
name|remaining
argument_list|()
operator|%
name|bytesPerChecksum
operator|)
decl_stmt|;
comment|// There's only enough checksum buffer space available to checksum one
comment|// entire slow read buffer. This saves keeping the number of checksum
comment|// chunks around.
name|len
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|slowReadBuff
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|oldlimit
init|=
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|len
argument_list|)
expr_stmt|;
name|int
name|readResult
init|=
literal|0
decl_stmt|;
try|try
block|{
name|readResult
operator|=
name|doByteBufferRead
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|buf
operator|.
name|limit
argument_list|(
name|oldlimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readResult
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|nRead
return|;
block|}
else|else
block|{
name|nRead
operator|+=
name|readResult
expr_stmt|;
name|buf
operator|.
name|position
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|readResult
argument_list|)
expr_stmt|;
block|}
block|}
comment|// offsetFromChunkBoundary> 0 => unaligned read, use slow path to read
comment|// until chunk boundary
if|if
condition|(
operator|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>
literal|0
operator|&&
name|buf
operator|.
name|remaining
argument_list|()
operator|<
name|bytesPerChecksum
operator|)
operator|||
name|offsetFromChunkBoundary
operator|>
literal|0
condition|)
block|{
name|int
name|toRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|bytesPerChecksum
operator|-
name|offsetFromChunkBoundary
argument_list|)
decl_stmt|;
name|int
name|readResult
init|=
name|fillSlowReadBuffer
argument_list|(
name|toRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|readResult
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|nRead
return|;
block|}
else|else
block|{
name|int
name|fromSlowReadBuff
init|=
name|Math
operator|.
name|min
argument_list|(
name|readResult
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|)
decl_stmt|;
name|writeSlice
argument_list|(
name|slowReadBuff
argument_list|,
name|buf
argument_list|,
name|fromSlowReadBuff
argument_list|)
expr_stmt|;
name|nRead
operator|+=
name|fromSlowReadBuff
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Non-checksummed reads are much easier; we can just fill the buffer
comment|// directly.
name|nRead
operator|=
name|doByteBufferRead
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRead
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|position
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|nRead
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nRead
return|;
block|}
comment|/**    * Tries to read as many bytes as possible into supplied buffer, checksumming    * each chunk if needed.    *    *<b>Preconditions:</b>    *<ul>    *<li>    * If checksumming is enabled, buf.remaining must be a multiple of    * bytesPerChecksum. Note that this is not a requirement for clients of    * read(ByteBuffer) - in the case of non-checksum-sized read requests,    * read(ByteBuffer) will substitute a suitably sized buffer to pass to this    * method.    *</li>    *</ul>    *<b>Postconditions:</b>    *<ul>    *<li>buf.limit and buf.mark are unchanged.</li>    *<li>buf.position += min(offsetFromChunkBoundary, totalBytesRead) - so the    * requested bytes can be read straight from the buffer</li>    *</ul>    *    * @param buf    *          byte buffer to write bytes to. If checksums are not required, buf    *          can have any number of bytes remaining, otherwise there must be a    *          multiple of the checksum chunk size remaining.    * @return<tt>max(min(totalBytesRead, len) - offsetFromChunkBoundary, 0)</tt>    *         that is, the the number of useful bytes (up to the amount    *         requested) readable from the buffer by the client.    */
DECL|method|doByteBufferRead (ByteBuffer buf)
specifier|private
specifier|synchronized
name|int
name|doByteBufferRead
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|verifyChecksum
condition|)
block|{
assert|assert
name|buf
operator|.
name|remaining
argument_list|()
operator|%
name|bytesPerChecksum
operator|==
literal|0
assert|;
block|}
name|int
name|dataRead
decl_stmt|;
name|int
name|oldpos
init|=
name|buf
operator|.
name|position
argument_list|()
decl_stmt|;
comment|// Read as much as we can into the buffer.
name|dataRead
operator|=
name|fillBuffer
argument_list|(
name|dataIn
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataRead
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|verifyChecksum
condition|)
block|{
name|ByteBuffer
name|toChecksum
init|=
name|buf
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|toChecksum
operator|.
name|position
argument_list|(
name|oldpos
argument_list|)
expr_stmt|;
name|toChecksum
operator|.
name|limit
argument_list|(
name|oldpos
operator|+
name|dataRead
argument_list|)
expr_stmt|;
name|checksumBuff
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Equivalent to
comment|// (int)Math.ceil(toChecksum.remaining() * 1.0 / bytesPerChecksum );
name|int
name|numChunks
init|=
operator|(
name|toChecksum
operator|.
name|remaining
argument_list|()
operator|+
name|bytesPerChecksum
operator|-
literal|1
operator|)
operator|/
name|bytesPerChecksum
decl_stmt|;
name|checksumBuff
operator|.
name|limit
argument_list|(
name|checksumSize
operator|*
name|numChunks
argument_list|)
expr_stmt|;
name|fillBuffer
argument_list|(
name|checksumIn
argument_list|,
name|checksumBuff
argument_list|)
expr_stmt|;
name|checksumBuff
operator|.
name|flip
argument_list|()
expr_stmt|;
name|checksum
operator|.
name|verifyChunkedSums
argument_list|(
name|toChecksum
argument_list|,
name|checksumBuff
argument_list|,
name|filename
argument_list|,
name|this
operator|.
name|startOffset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dataRead
operator|>=
literal|0
condition|)
block|{
name|buf
operator|.
name|position
argument_list|(
name|oldpos
operator|+
name|Math
operator|.
name|min
argument_list|(
name|offsetFromChunkBoundary
argument_list|,
name|dataRead
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dataRead
operator|<
name|offsetFromChunkBoundary
condition|)
block|{
comment|// yikes, didn't even get enough bytes to honour offset. This can happen
comment|// even if we are verifying checksums if we are at EOF.
name|offsetFromChunkBoundary
operator|-=
name|dataRead
expr_stmt|;
name|dataRead
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dataRead
operator|-=
name|offsetFromChunkBoundary
expr_stmt|;
name|offsetFromChunkBoundary
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|dataRead
return|;
block|}
comment|/**    * Ensures that up to len bytes are available and checksummed in the slow read    * buffer. The number of bytes available to read is returned. If the buffer is    * not already empty, the number of remaining bytes is returned and no actual    * read happens.    *    * @param len    *          the maximum number of bytes to make available. After len bytes    *          are read, the underlying bytestream<b>must</b> be at a checksum    *          boundary, or EOF. That is, (len + currentPosition) %    *          bytesPerChecksum == 0.    * @return the number of bytes available to read, or -1 if EOF.    */
DECL|method|fillSlowReadBuffer (int len)
specifier|private
specifier|synchronized
name|int
name|fillSlowReadBuffer
parameter_list|(
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|nRead
decl_stmt|;
if|if
condition|(
name|slowReadBuff
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
comment|// Already got data, good to go.
name|nRead
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|slowReadBuff
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Round a complete read of len bytes (plus any implicit offset) to the
comment|// next chunk boundary, since we try and read in multiples of a chunk
name|int
name|nextChunk
init|=
name|len
operator|+
name|offsetFromChunkBoundary
operator|+
operator|(
name|bytesPerChecksum
operator|-
operator|(
operator|(
name|len
operator|+
name|offsetFromChunkBoundary
operator|)
operator|%
name|bytesPerChecksum
operator|)
operator|)
decl_stmt|;
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|nextChunk
argument_list|,
name|slowReadBuff
operator|.
name|capacity
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|limit
operator|%
name|bytesPerChecksum
operator|==
literal|0
assert|;
name|slowReadBuff
operator|.
name|clear
argument_list|()
expr_stmt|;
name|slowReadBuff
operator|.
name|limit
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|nRead
operator|=
name|doByteBufferRead
argument_list|(
name|slowReadBuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRead
operator|>
literal|0
condition|)
block|{
comment|// So that next time we call slowReadBuff.hasRemaining(), we don't get a
comment|// false positive.
name|slowReadBuff
operator|.
name|limit
argument_list|(
name|nRead
operator|+
name|slowReadBuff
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nRead
return|;
block|}
annotation|@
name|Override
DECL|method|read (byte[] buf, int off, int len)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"read off {} len {}"
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verifyChecksum
condition|)
block|{
return|return
name|dataIn
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
name|int
name|nRead
init|=
name|fillSlowReadBuffer
argument_list|(
name|slowReadBuff
operator|.
name|capacity
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nRead
operator|>
literal|0
condition|)
block|{
comment|// Possible that buffer is filled with a larger read than we need, since
comment|// we tried to read as much as possible at once
name|nRead
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|nRead
argument_list|)
expr_stmt|;
name|slowReadBuff
operator|.
name|get
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|nRead
argument_list|)
expr_stmt|;
block|}
return|return
name|nRead
return|;
block|}
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
specifier|synchronized
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"skip {}"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|verifyChecksum
condition|)
block|{
return|return
name|dataIn
operator|.
name|skip
argument_list|(
name|n
argument_list|)
return|;
block|}
comment|// caller made sure newPosition is not beyond EOF.
name|int
name|remaining
init|=
name|slowReadBuff
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|int
name|position
init|=
name|slowReadBuff
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|newPosition
init|=
name|position
operator|+
operator|(
name|int
operator|)
name|n
decl_stmt|;
comment|// if the new offset is already read into dataBuff, just reposition
if|if
condition|(
name|n
operator|<=
name|remaining
condition|)
block|{
assert|assert
name|offsetFromChunkBoundary
operator|==
literal|0
assert|;
name|slowReadBuff
operator|.
name|position
argument_list|(
name|newPosition
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
comment|// for small gap, read through to keep the data/checksum in sync
if|if
condition|(
name|n
operator|-
name|remaining
operator|<=
name|bytesPerChecksum
condition|)
block|{
name|slowReadBuff
operator|.
name|position
argument_list|(
name|position
operator|+
name|remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipBuf
operator|==
literal|null
condition|)
block|{
name|skipBuf
operator|=
operator|new
name|byte
index|[
name|bytesPerChecksum
index|]
expr_stmt|;
block|}
name|int
name|ret
init|=
name|read
argument_list|(
name|skipBuf
argument_list|,
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
name|n
operator|-
name|remaining
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|remaining
operator|+
name|ret
operator|)
return|;
block|}
comment|// optimize for big gap: discard the current buffer, skip to
comment|// the beginning of the appropriate checksum chunk and then
comment|// read to the middle of that chunk to be in sync with checksums.
comment|// We can't use this.offsetFromChunkBoundary because we need to know how
comment|// many bytes of the offset were really read. Calling read(..) with a
comment|// positive this.offsetFromChunkBoundary causes that many bytes to get
comment|// silently skipped.
name|int
name|myOffsetFromChunkBoundary
init|=
name|newPosition
operator|%
name|bytesPerChecksum
decl_stmt|;
name|long
name|toskip
init|=
name|n
operator|-
name|remaining
operator|-
name|myOffsetFromChunkBoundary
decl_stmt|;
name|slowReadBuff
operator|.
name|position
argument_list|(
name|slowReadBuff
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
name|checksumBuff
operator|.
name|position
argument_list|(
name|checksumBuff
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|skipFully
argument_list|(
name|dataIn
argument_list|,
name|toskip
argument_list|)
expr_stmt|;
name|long
name|checkSumOffset
init|=
operator|(
name|toskip
operator|/
name|bytesPerChecksum
operator|)
operator|*
name|checksumSize
decl_stmt|;
name|IOUtils
operator|.
name|skipFully
argument_list|(
name|checksumIn
argument_list|,
name|checkSumOffset
argument_list|)
expr_stmt|;
comment|// read into the middle of the chunk
if|if
condition|(
name|skipBuf
operator|==
literal|null
condition|)
block|{
name|skipBuf
operator|=
operator|new
name|byte
index|[
name|bytesPerChecksum
index|]
expr_stmt|;
block|}
assert|assert
name|skipBuf
operator|.
name|length
operator|==
name|bytesPerChecksum
assert|;
assert|assert
name|myOffsetFromChunkBoundary
operator|<
name|bytesPerChecksum
assert|;
name|int
name|ret
init|=
name|read
argument_list|(
name|skipBuf
argument_list|,
literal|0
argument_list|,
name|myOffsetFromChunkBoundary
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|// EOS
return|return
operator|(
name|toskip
operator|+
name|remaining
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|toskip
operator|+
name|remaining
operator|+
name|ret
operator|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOUtilsClient
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|dataIn
argument_list|,
name|checksumIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|slowReadBuff
operator|!=
literal|null
condition|)
block|{
name|bufferPool
operator|.
name|returnBuffer
argument_list|(
name|slowReadBuff
argument_list|)
expr_stmt|;
name|slowReadBuff
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|checksumBuff
operator|!=
literal|null
condition|)
block|{
name|bufferPool
operator|.
name|returnBuffer
argument_list|(
name|checksumBuff
argument_list|)
expr_stmt|;
name|checksumBuff
operator|=
literal|null
expr_stmt|;
block|}
name|startOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|checksum
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readAll (byte[] buf, int offset, int len)
specifier|public
name|int
name|readAll
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|BlockReaderUtil
operator|.
name|readAll
argument_list|(
name|this
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|readFully (byte[] buf, int off, int len)
specifier|public
name|void
name|readFully
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockReaderUtil
operator|.
name|readFully
argument_list|(
name|this
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
name|int
name|available
parameter_list|()
block|{
comment|// We never do network I/O in BlockReaderLocalLegacy.
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
DECL|method|isShortCircuit ()
specifier|public
name|boolean
name|isShortCircuit
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getClientMmap (EnumSet<ReadOption> opts)
specifier|public
name|ClientMmap
name|getClientMmap
parameter_list|(
name|EnumSet
argument_list|<
name|ReadOption
argument_list|>
name|opts
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getDataChecksum ()
specifier|public
name|DataChecksum
name|getDataChecksum
parameter_list|()
block|{
return|return
name|checksum
return|;
block|}
annotation|@
name|Override
DECL|method|getNetworkDistance ()
specifier|public
name|int
name|getNetworkDistance
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
end_class

end_unit

