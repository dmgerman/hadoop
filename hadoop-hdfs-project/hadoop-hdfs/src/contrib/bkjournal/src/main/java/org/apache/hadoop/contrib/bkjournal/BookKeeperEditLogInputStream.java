begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.contrib.bkjournal
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|contrib
operator|.
name|bkjournal
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|EditLogInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bookkeeper
operator|.
name|client
operator|.
name|LedgerHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bookkeeper
operator|.
name|client
operator|.
name|LedgerEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bookkeeper
operator|.
name|client
operator|.
name|BKException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_comment
comment|/**  * Input stream which reads from a BookKeeper ledger.  */
end_comment

begin_class
DECL|class|BookKeeperEditLogInputStream
class|class
name|BookKeeperEditLogInputStream
extends|extends
name|EditLogInputStream
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BookKeeperEditLogInputStream
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|firstTxId
specifier|private
specifier|final
name|long
name|firstTxId
decl_stmt|;
DECL|field|lastTxId
specifier|private
specifier|final
name|long
name|lastTxId
decl_stmt|;
DECL|field|logVersion
specifier|private
specifier|final
name|int
name|logVersion
decl_stmt|;
DECL|field|inProgress
specifier|private
specifier|final
name|boolean
name|inProgress
decl_stmt|;
DECL|field|lh
specifier|private
specifier|final
name|LedgerHandle
name|lh
decl_stmt|;
DECL|field|reader
specifier|private
specifier|final
name|FSEditLogOp
operator|.
name|Reader
name|reader
decl_stmt|;
DECL|field|tracker
specifier|private
specifier|final
name|FSEditLogLoader
operator|.
name|PositionTrackingInputStream
name|tracker
decl_stmt|;
comment|/**    * Construct BookKeeper edit log input stream.    * Starts reading from the first entry of the ledger.    */
DECL|method|BookKeeperEditLogInputStream (final LedgerHandle lh, final EditLogLedgerMetadata metadata)
name|BookKeeperEditLogInputStream
parameter_list|(
specifier|final
name|LedgerHandle
name|lh
parameter_list|,
specifier|final
name|EditLogLedgerMetadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|lh
argument_list|,
name|metadata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct BookKeeper edit log input stream.     * Starts reading from firstBookKeeperEntry. This allows the stream    * to take a shortcut during recovery, as it doesn't have to read    * every edit log transaction to find out what the last one is.    */
DECL|method|BookKeeperEditLogInputStream (LedgerHandle lh, EditLogLedgerMetadata metadata, long firstBookKeeperEntry)
name|BookKeeperEditLogInputStream
parameter_list|(
name|LedgerHandle
name|lh
parameter_list|,
name|EditLogLedgerMetadata
name|metadata
parameter_list|,
name|long
name|firstBookKeeperEntry
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|lh
operator|=
name|lh
expr_stmt|;
name|this
operator|.
name|firstTxId
operator|=
name|metadata
operator|.
name|getFirstTxId
argument_list|()
expr_stmt|;
name|this
operator|.
name|lastTxId
operator|=
name|metadata
operator|.
name|getLastTxId
argument_list|()
expr_stmt|;
name|this
operator|.
name|logVersion
operator|=
name|metadata
operator|.
name|getDataLayoutVersion
argument_list|()
expr_stmt|;
name|this
operator|.
name|inProgress
operator|=
name|metadata
operator|.
name|isInProgress
argument_list|()
expr_stmt|;
if|if
condition|(
name|firstBookKeeperEntry
argument_list|<
literal|0
operator|||
name|firstBookKeeperEntry
argument_list|>
name|lh
operator|.
name|getLastAddConfirmed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid first bk entry to read: "
operator|+
name|firstBookKeeperEntry
operator|+
literal|", LAC: "
operator|+
name|lh
operator|.
name|getLastAddConfirmed
argument_list|()
argument_list|)
throw|;
block|}
name|BufferedInputStream
name|bin
init|=
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|LedgerInputStream
argument_list|(
name|lh
argument_list|,
name|firstBookKeeperEntry
argument_list|)
argument_list|)
decl_stmt|;
name|tracker
operator|=
operator|new
name|FSEditLogLoader
operator|.
name|PositionTrackingInputStream
argument_list|(
name|bin
argument_list|)
expr_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|tracker
argument_list|)
decl_stmt|;
name|reader
operator|=
name|FSEditLogOp
operator|.
name|Reader
operator|.
name|create
argument_list|(
name|in
argument_list|,
name|tracker
argument_list|,
name|logVersion
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFirstTxId ()
specifier|public
name|long
name|getFirstTxId
parameter_list|()
block|{
return|return
name|firstTxId
return|;
block|}
annotation|@
name|Override
DECL|method|getLastTxId ()
specifier|public
name|long
name|getLastTxId
parameter_list|()
block|{
return|return
name|lastTxId
return|;
block|}
annotation|@
name|Override
DECL|method|getVersion (boolean verifyVersion)
specifier|public
name|int
name|getVersion
parameter_list|(
name|boolean
name|verifyVersion
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|logVersion
return|;
block|}
annotation|@
name|Override
DECL|method|nextOp ()
specifier|protected
name|FSEditLogOp
name|nextOp
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|readOp
argument_list|(
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|lh
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BKException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Exception closing ledger"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted closing ledger"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getPosition ()
specifier|public
name|long
name|getPosition
parameter_list|()
block|{
return|return
name|tracker
operator|.
name|getPos
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|length ()
specifier|public
name|long
name|length
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|lh
operator|.
name|getLength
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"BookKeeperLedger[ledgerId=%d,firstTxId=%d,lastTxId=%d]"
argument_list|,
name|lh
operator|.
name|getId
argument_list|()
argument_list|,
name|firstTxId
argument_list|,
name|lastTxId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isInProgress ()
specifier|public
name|boolean
name|isInProgress
parameter_list|()
block|{
return|return
name|inProgress
return|;
block|}
comment|/**    * Skip forward to specified transaction id.    * Currently we do this by just iterating forward.    * If this proves to be too expensive, this can be reimplemented    * with a binary search over bk entries    */
DECL|method|skipTo (long txId)
specifier|public
name|void
name|skipTo
parameter_list|(
name|long
name|txId
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|numToSkip
init|=
name|getFirstTxId
argument_list|()
operator|-
name|txId
decl_stmt|;
name|FSEditLogOp
name|op
init|=
literal|null
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numToSkip
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|readOp
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|!=
literal|null
operator|&&
name|op
operator|.
name|getTransactionId
argument_list|()
operator|!=
name|txId
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupt stream, expected txid "
operator|+
operator|(
name|txId
operator|-
literal|1
operator|)
operator|+
literal|", got "
operator|+
name|op
operator|.
name|getTransactionId
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|(
literal|"BookKeeperEditLogInputStream {"
operator|+
name|this
operator|.
name|getName
argument_list|()
operator|+
literal|"}"
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|setMaxOpSize (int maxOpSize)
specifier|public
name|void
name|setMaxOpSize
parameter_list|(
name|int
name|maxOpSize
parameter_list|)
block|{
name|reader
operator|.
name|setMaxOpSize
argument_list|(
name|maxOpSize
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isLocalLog ()
specifier|public
name|boolean
name|isLocalLog
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Input stream implementation which can be used by     * FSEditLogOp.Reader    */
DECL|class|LedgerInputStream
specifier|private
specifier|static
class|class
name|LedgerInputStream
extends|extends
name|InputStream
block|{
DECL|field|readEntries
specifier|private
name|long
name|readEntries
decl_stmt|;
DECL|field|entryStream
specifier|private
name|InputStream
name|entryStream
init|=
literal|null
decl_stmt|;
DECL|field|lh
specifier|private
specifier|final
name|LedgerHandle
name|lh
decl_stmt|;
DECL|field|maxEntry
specifier|private
specifier|final
name|long
name|maxEntry
decl_stmt|;
comment|/**      * Construct ledger input stream      * @param lh the ledger handle to read from      * @param firstBookKeeperEntry ledger entry to start reading from      */
DECL|method|LedgerInputStream (LedgerHandle lh, long firstBookKeeperEntry)
name|LedgerInputStream
parameter_list|(
name|LedgerHandle
name|lh
parameter_list|,
name|long
name|firstBookKeeperEntry
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|lh
operator|=
name|lh
expr_stmt|;
name|readEntries
operator|=
name|firstBookKeeperEntry
expr_stmt|;
name|maxEntry
operator|=
name|lh
operator|.
name|getLastAddConfirmed
argument_list|()
expr_stmt|;
block|}
comment|/**      * Get input stream representing next entry in the      * ledger.      * @return input stream, or null if no more entries      */
DECL|method|nextStream ()
specifier|private
name|InputStream
name|nextStream
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|readEntries
operator|>
name|maxEntry
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Enumeration
argument_list|<
name|LedgerEntry
argument_list|>
name|entries
init|=
name|lh
operator|.
name|readEntries
argument_list|(
name|readEntries
argument_list|,
name|readEntries
argument_list|)
decl_stmt|;
name|readEntries
operator|++
expr_stmt|;
if|if
condition|(
name|entries
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|LedgerEntry
name|e
init|=
name|entries
operator|.
name|nextElement
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|entries
operator|.
name|hasMoreElements
argument_list|()
assert|;
return|return
name|e
operator|.
name|getEntryInputStream
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|BKException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error reading entries from bookkeeper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted reading entries from bookkeeper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|b
index|[
literal|0
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|read (byte[] b, int off, int len)
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|int
name|read
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|entryStream
operator|==
literal|null
condition|)
block|{
name|entryStream
operator|=
name|nextStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|entryStream
operator|==
literal|null
condition|)
block|{
return|return
name|read
return|;
block|}
block|}
while|while
condition|(
name|read
operator|<
name|len
condition|)
block|{
name|int
name|thisread
init|=
name|entryStream
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|read
argument_list|,
operator|(
name|len
operator|-
name|read
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisread
operator|==
operator|-
literal|1
condition|)
block|{
name|entryStream
operator|=
name|nextStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|entryStream
operator|==
literal|null
condition|)
block|{
return|return
name|read
return|;
block|}
block|}
else|else
block|{
name|read
operator|+=
name|thisread
expr_stmt|;
block|}
block|}
return|return
name|read
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

