begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LightWeightHashSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LightWeightLinkedSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_comment
comment|/**  * This class implements the logic to track decommissioning and entering  * maintenance nodes, ensure all their blocks are adequately replicated  * before they are moved to the decommissioned or maintenance state.  *  * This monitor avoids flooding the replication queue with all pending blocks  * and instead feeds them to the queue as the prior set complete replication.  *  * HDFS-14854 contains details about the overall design of this class.  *  */
end_comment

begin_class
DECL|class|DatanodeAdminBackoffMonitor
specifier|public
class|class
name|DatanodeAdminBackoffMonitor
extends|extends
name|DatanodeAdminMonitorBase
implements|implements
name|DatanodeAdminMonitorInterface
block|{
comment|/**    * Map containing the DECOMMISSION_INPROGRESS or ENTERING_MAINTENANCE    * datanodes that are being tracked so they can be be marked as    * DECOMMISSIONED or IN_MAINTENANCE. Even after the node is marked as    * IN_MAINTENANCE, the node remains in the map until    * maintenance expires checked during a monitor tick.    *<p/>    * This holds a set of references to the under-replicated blocks on the DN    * at the time the DN is added to the map, i.e. the blocks that are    * preventing the node from being marked as decommissioned. During a monitor    * tick, this list is pruned as blocks becomes replicated.    *<p/>    * Note also that the reference to the list of under-replicated blocks    * will be null on initial add    *<p/>    * However, this map can become out-of-date since it is not updated by block    * reports or other events. Before being finally marking as decommissioned,    * another check is done with the actual block map.    */
specifier|private
name|HashMap
argument_list|<
name|DatanodeDescriptor
argument_list|,
name|HashMap
argument_list|<
name|BlockInfo
argument_list|,
name|Integer
argument_list|>
argument_list|>
DECL|field|outOfServiceNodeBlocks
name|outOfServiceNodeBlocks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Any nodes where decommission or maintenance has been cancelled are added    * to this queue for later processing.    */
DECL|field|cancelledNodes
specifier|private
specifier|final
name|Queue
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|cancelledNodes
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * The numbe of blocks to process when moving blocks to pendingReplication    * before releasing and reclaiming the namenode lock.    */
DECL|field|blocksPerLock
specifier|private
name|int
name|blocksPerLock
decl_stmt|;
comment|/**    * The number of blocks that have been checked on this tick.    */
DECL|field|numBlocksChecked
specifier|private
name|int
name|numBlocksChecked
init|=
literal|0
decl_stmt|;
comment|/**    * The maximum number of blocks to hold in PendingRep at any time.    */
DECL|field|pendingRepLimit
specifier|private
name|int
name|pendingRepLimit
decl_stmt|;
comment|/**    * The list of blocks which have been placed onto the replication queue    * and are waiting to be sufficiently replicated.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|DatanodeDescriptor
argument_list|,
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
DECL|field|pendingRep
name|pendingRep
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DatanodeAdminBackoffMonitor
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|DatanodeAdminBackoffMonitor ()
name|DatanodeAdminBackoffMonitor
parameter_list|()
block|{   }
annotation|@
name|Override
DECL|method|processConf ()
specifier|protected
name|void
name|processConf
parameter_list|()
block|{
name|this
operator|.
name|pendingRepLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_LIMIT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|pendingRepLimit
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} is set to an invalid value, it must be greater than "
operator|+
literal|"zero. Defaulting to {}"
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_LIMIT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|pendingRepLimit
operator|=
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_LIMIT_DEFAULT
expr_stmt|;
block|}
name|this
operator|.
name|blocksPerLock
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_BLOCKS_PER_LOCK
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_BLOCKS_PER_LOCK_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksPerLock
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} is set to an invalid value, it must be greater than "
operator|+
literal|"zero. Defaulting to {}"
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_BLOCKS_PER_LOCK
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_BLOCKS_PER_LOCK_DEFAULT
argument_list|)
expr_stmt|;
name|blocksPerLock
operator|=
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_BACKOFF_MONITOR_PENDING_BLOCKS_PER_LOCK_DEFAULT
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized the Backoff Decommission and Maintenance Monitor"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Queue a node to be removed from tracking. This method must be called    * under the namenode write lock.    * @param dn The datanode to stop tracking for decommission.    */
annotation|@
name|Override
DECL|method|stopTrackingNode (DatanodeDescriptor dn)
specifier|public
name|void
name|stopTrackingNode
parameter_list|(
name|DatanodeDescriptor
name|dn
parameter_list|)
block|{
name|pendingNodes
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|cancelledNodes
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getTrackedNodeCount ()
specifier|public
name|int
name|getTrackedNodeCount
parameter_list|()
block|{
return|return
name|outOfServiceNodeBlocks
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getNumNodesChecked ()
specifier|public
name|int
name|getNumNodesChecked
parameter_list|()
block|{
comment|// We always check all nodes on each tick
return|return
name|outOfServiceNodeBlocks
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DatanodeAdminMonitorV2 is running."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Namesystem is not running, skipping "
operator|+
literal|"decommissioning/maintenance checks."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Reset the checked count at beginning of each iteration
name|numBlocksChecked
operator|=
literal|0
expr_stmt|;
comment|// Check decommission or maintenance progress.
try|try
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|/**          * Other threads can modify the pendingNode list and the cancelled          * node list, so we must process them under the NN write lock to          * prevent any concurrent modifications.          *          * Always process the cancelled list before the pending list, as          * it is possible for a node to be cancelled, and then quickly added          * back again. If we process these the other way around, the added          * node will be removed from tracking by the pending cancel.          */
name|processCancelledNodes
argument_list|()
expr_stmt|;
name|processPendingNodes
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|// After processing the above, various parts of the check() method will
comment|// take and drop the read / write lock as needed. Aside from the
comment|// cancelled and pending lists, nothing outside of the monitor thread
comment|// modifies anything inside this class, so many things can be done
comment|// without any lock.
name|check
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DatanodeAdminMonitor caught exception when processing node."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numBlocksChecked
operator|+
name|outOfServiceNodeBlocks
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Checked {} blocks this tick. {} nodes are now "
operator|+
literal|"in maintenance or transitioning state. {} nodes pending. {} "
operator|+
literal|"nodes waiting to be cancelled."
argument_list|,
name|numBlocksChecked
argument_list|,
name|outOfServiceNodeBlocks
operator|.
name|size
argument_list|()
argument_list|,
name|pendingNodes
operator|.
name|size
argument_list|()
argument_list|,
name|cancelledNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Move any pending nodes into outOfServiceNodeBlocks to initiate the    * decommission or maintenance mode process.    *    * This method must be executed under the namenode write lock to prevent    * the pendingNodes list from being modified externally.    */
DECL|method|processPendingNodes ()
specifier|private
name|void
name|processPendingNodes
parameter_list|()
block|{
while|while
condition|(
operator|!
name|pendingNodes
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|maxConcurrentTrackedNodes
operator|==
literal|0
operator|||
name|outOfServiceNodeBlocks
operator|.
name|size
argument_list|()
operator|<
name|maxConcurrentTrackedNodes
operator|)
condition|)
block|{
name|outOfServiceNodeBlocks
operator|.
name|put
argument_list|(
name|pendingNodes
operator|.
name|poll
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Process any nodes which have had their decommission or maintenance mode    * cancelled by an administrator.    *    * This method must be executed under the    * write lock to prevent the cancelledNodes list being modified externally.    */
DECL|method|processCancelledNodes ()
specifier|private
name|void
name|processCancelledNodes
parameter_list|()
block|{
while|while
condition|(
operator|!
name|cancelledNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|DatanodeDescriptor
name|dn
init|=
name|cancelledNodes
operator|.
name|poll
argument_list|()
decl_stmt|;
name|outOfServiceNodeBlocks
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|pendingRep
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method performs each of the steps to track a node from    * decommissioning or entering maintenance to the end state.    *    * First, any newly added nodes are scanned.    *    * Then any expired maintenance nodes are handled.    *    * Next the pendingRep map is scanned and all blocks which are now    * sufficiently replicated are removed    *    * Then new blocks are moved to pendingRep    *    * Finally we check if any nodes have completed the replication process and    * if so move them to their final states.    *    * This methods which this method calls will take and release the namenode    * read and write lock several times.    *    */
DECL|method|check ()
specifier|private
name|void
name|check
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|toRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|outOfServiceNodeBlocks
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// No nodes currently being tracked so simply return
return|return;
block|}
comment|// Check if there are any pending nodes to process, ie those where the
comment|// storage has not been scanned yet. For all which are pending, scan
comment|// the storage and load the under-replicated block list into
comment|// outOfServiceNodeBlocks. As this does not modify any external structures
comment|// it can be done under the namenode *read* lock, and the lock can be
comment|// dropped between each storage on each node.
comment|//
comment|// TODO - This is an expensive call, depending on how many nodes are
comment|//        to be processed, but it requires only the read lock and it will
comment|//        be dropped and re-taken frequently. We may want to throttle this
comment|//        to process only a few nodes per iteration.
name|outOfServiceNodeBlocks
operator|.
name|keySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|n
lambda|->
name|outOfServiceNodeBlocks
operator|.
name|get
argument_list|(
name|n
argument_list|)
operator|==
literal|null
argument_list|)
operator|.
name|forEach
argument_list|(
name|n
lambda|->
name|scanDatanodeStorage
argument_list|(
name|n
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|processMaintenanceNodes
argument_list|()
expr_stmt|;
comment|// First check the pending replication list and remove any blocks
comment|// which are now replicated OK. This list is constrained in size so this
comment|// call should not be overly expensive.
name|processPendingReplication
argument_list|()
expr_stmt|;
comment|// Now move a limited number of blocks to pending
name|moveBlocksToPending
argument_list|()
expr_stmt|;
comment|// Check if any nodes have reached zero blocks and also update the stats
comment|// exposed via JMX for all nodes still being processed.
name|checkForCompletedNodes
argument_list|(
name|toRemove
argument_list|)
expr_stmt|;
comment|// Finally move the nodes to their final state if they are ready.
name|processCompletedNodes
argument_list|(
name|toRemove
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks for any nodes which are in maintenance and if maintenance has    * expired, the node will be moved back to in_service (or dead) as required.    */
DECL|method|processMaintenanceNodes ()
specifier|private
name|void
name|processMaintenanceNodes
parameter_list|()
block|{
comment|// Check for any maintenance state nodes which need to be expired
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|outOfServiceNodeBlocks
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|dn
operator|.
name|isMaintenance
argument_list|()
operator|&&
name|dn
operator|.
name|maintenanceExpired
argument_list|()
condition|)
block|{
comment|// If maintenance expires, stop tracking it. This can be an
comment|// expensive call, as it may need to invalidate blocks. Therefore
comment|// we can yield and retake the write lock after each node
comment|//
comment|// The call to stopMaintenance makes a call to stopTrackingNode()
comment|// which added the node to the cancelled list. Therefore expired
comment|// maintenance nodes do not need to be added to the toRemove list.
name|dnAdmin
operator|.
name|stopMaintenance
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Loop over all nodes in the passed toRemove list and move the node to    * the required end state. This will also remove any entries from    * outOfServiceNodeBlocks and pendingRep for the node if required.    *    * @param toRemove The list of nodes to process for completion.    */
DECL|method|processCompletedNodes (List<DatanodeDescriptor> toRemove)
specifier|private
name|void
name|processCompletedNodes
parameter_list|(
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|toRemove
parameter_list|)
block|{
if|if
condition|(
name|toRemove
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// If there are no nodes to process simply return and avoid
comment|// taking the write lock at all.
return|return;
block|}
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|toRemove
control|)
block|{
specifier|final
name|boolean
name|isHealthy
init|=
name|blockManager
operator|.
name|isNodeHealthyForDecommissionOrMaintenance
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|isHealthy
condition|)
block|{
if|if
condition|(
name|dn
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
name|dnAdmin
operator|.
name|setDecommissioned
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|outOfServiceNodeBlocks
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|pendingRep
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn
operator|.
name|isEnteringMaintenance
argument_list|()
condition|)
block|{
comment|// IN_MAINTENANCE node remains in the outOfServiceNodeBlocks to
comment|// to track maintenance expiration.
name|dnAdmin
operator|.
name|setInMaintenance
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|pendingRep
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn
operator|.
name|isInService
argument_list|()
condition|)
block|{
comment|// Decom / maint was cancelled and the node is yet to be processed
comment|// from cancelledNodes
name|LOG
operator|.
name|info
argument_list|(
literal|"Node {} completed decommission and maintenance "
operator|+
literal|"but has been moved back to in service"
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|pendingRep
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|outOfServiceNodeBlocks
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|// Should not happen
name|LOG
operator|.
name|error
argument_list|(
literal|"Node {} is in an unexpected state {} and has been "
operator|+
literal|"removed from tracking for decommission or maintenance"
argument_list|,
name|dn
argument_list|,
name|dn
operator|.
name|getAdminState
argument_list|()
argument_list|)
expr_stmt|;
name|pendingRep
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|outOfServiceNodeBlocks
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Node {} is sufficiently replicated and healthy, "
operator|+
literal|"marked as {}."
argument_list|,
name|dn
argument_list|,
name|dn
operator|.
name|getAdminState
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Node {} isn't healthy."
operator|+
literal|" It needs to replicate {} more blocks."
operator|+
literal|" {} is still in progress."
argument_list|,
name|dn
argument_list|,
name|getPendingCountForNode
argument_list|(
name|dn
argument_list|)
argument_list|,
name|dn
operator|.
name|getAdminState
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Loop over all nodes and check for any which have zero unprocessed or    * pending blocks. If the node has zero blocks pending, the storage is    * rescanned to ensure no transient blocks were missed on the first pass.    *    * If, after rescan the number of blocks pending replication is zero, the    * node is added to the passed removeList which will later be processed to    * complete the decommission or entering maintenance process.    *    * @param removeList Nodes which have zero pending blocks are added to this    *                   list.    */
DECL|method|checkForCompletedNodes (List<DatanodeDescriptor> removeList)
specifier|private
name|void
name|checkForCompletedNodes
parameter_list|(
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|removeList
parameter_list|)
block|{
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|outOfServiceNodeBlocks
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// If the node is already in maintenance, we don't need to perform
comment|// any further checks on it.
if|if
condition|(
name|dn
operator|.
name|isInMaintenance
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node {} is currently in maintenance"
argument_list|,
name|dn
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|dn
operator|.
name|isInService
argument_list|()
condition|)
block|{
comment|// A node could be inService if decom or maint has been cancelled, but
comment|// the cancelled list is yet to be processed. We don't need to check
comment|// inService nodes here
name|int
name|outstandingBlocks
init|=
name|getPendingCountForNode
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|outstandingBlocks
operator|==
literal|0
condition|)
block|{
name|scanDatanodeStorage
argument_list|(
name|dn
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|outstandingBlocks
operator|=
name|getPendingCountForNode
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Node {} has {} blocks yet to process"
argument_list|,
name|dn
argument_list|,
name|outstandingBlocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|outstandingBlocks
operator|==
literal|0
condition|)
block|{
name|removeList
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Returns the number of block pending for the given node by adding those    * blocks in pendingRep and outOfServiceNodeBlocks.    *    * @param dn The datanode to return the count for    * @return The total block count, or zero if none are pending    */
DECL|method|getPendingCountForNode (DatanodeDescriptor dn)
specifier|private
name|int
name|getPendingCountForNode
parameter_list|(
name|DatanodeDescriptor
name|dn
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|HashMap
argument_list|<
name|BlockInfo
argument_list|,
name|Integer
argument_list|>
name|blocks
init|=
name|outOfServiceNodeBlocks
operator|.
name|get
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|!=
literal|null
condition|)
block|{
name|count
operator|+=
name|blocks
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|BlockInfo
argument_list|>
name|pendingBlocks
init|=
name|pendingRep
operator|.
name|get
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|pendingBlocks
operator|!=
literal|null
condition|)
block|{
name|count
operator|+=
name|pendingBlocks
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Iterate across all nodes in outOfServiceNodeBlocks which have blocks yet    * to be processed.    *    * The block is removed from outOfServiceNodeBlocks and if it needs    * replication it is added to the pendingRep map and also to the    * BlockManager replication queue.    *    * Any block that does not need replication is discarded.    *    * The method will return when there are the pendingRep map has    * pendingRepLimit blocks or there are no further blocks to process.    */
DECL|method|moveBlocksToPending ()
specifier|private
name|void
name|moveBlocksToPending
parameter_list|()
block|{
name|int
name|blocksProcessed
init|=
literal|0
decl_stmt|;
name|int
name|pendingCount
init|=
name|getPendingCount
argument_list|()
decl_stmt|;
name|int
name|yetToBeProcessed
init|=
name|getYetToBeProcessedCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|pendingCount
operator|==
literal|0
operator|&&
name|yetToBeProcessed
operator|==
literal|0
condition|)
block|{
comment|// There are no blocks to process so just return
name|LOG
operator|.
name|debug
argument_list|(
literal|"There are no pending or blocks yet to be processed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|repQueueSize
init|=
name|blockManager
operator|.
name|getLowRedundancyBlocksCount
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"There are {} blocks pending replication and the limit is "
operator|+
literal|"{}. A further {} blocks are waiting to be processed. "
operator|+
literal|"The replication queue currently has {} blocks"
argument_list|,
name|pendingCount
argument_list|,
name|pendingRepLimit
argument_list|,
name|yetToBeProcessed
argument_list|,
name|repQueueSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pendingCount
operator|>=
name|pendingRepLimit
condition|)
block|{
comment|// Only add more blocks to the replication queue if we don't already
comment|// have too many pending
return|return;
block|}
comment|// Create a "Block Iterator" for each node decommissioning or entering
comment|// maintenance. These iterators will be used "round robined" to add blocks
comment|// to the replication queue and PendingRep
name|HashMap
argument_list|<
name|DatanodeDescriptor
argument_list|,
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|iterators
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|DatanodeDescriptor
argument_list|,
name|HashMap
argument_list|<
name|BlockInfo
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|e
range|:
name|outOfServiceNodeBlocks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|iterators
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Now loop until we fill the pendingRep map with pendingRepLimit blocks
comment|// or run out of blocks to add.
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodeIter
init|=
name|Iterables
operator|.
name|cycle
argument_list|(
name|iterators
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|nodeIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// Cycle through each node with blocks which still need processed
name|DatanodeDescriptor
name|dn
init|=
name|nodeIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|blockIt
init|=
name|iterators
operator|.
name|get
argument_list|(
name|dn
argument_list|)
decl_stmt|;
while|while
condition|(
name|blockIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// Process the blocks for the node until we find one that needs
comment|// replication
if|if
condition|(
name|blocksProcessed
operator|>=
name|blocksPerLock
condition|)
block|{
name|blocksProcessed
operator|=
literal|0
expr_stmt|;
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
block|}
name|blocksProcessed
operator|++
expr_stmt|;
if|if
condition|(
name|nextBlockAddedToPending
argument_list|(
name|blockIt
argument_list|,
name|dn
argument_list|)
condition|)
block|{
comment|// Exit the inner "block" loop so an iterator for the next datanode
comment|// is used for the next block.
name|pendingCount
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|blockIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// remove the iterator as there are no blocks left in it
name|nodeIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pendingCount
operator|>=
name|pendingRepLimit
condition|)
block|{
comment|// We have scheduled the limit of blocks for replication, so do
comment|// not add any more
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} blocks are now pending replication"
argument_list|,
name|pendingCount
argument_list|)
expr_stmt|;
block|}
comment|/**    * Takes and removes the next block from the given iterator and checks if it    * needs additional replicas. If it does, it will be scheduled for    * reconstruction and added to the pendingRep map.    * @param it The iterator to take the next block from    * @param dn The datanodeDescriptor the iterator applies to    * @return True if the block needs replication, otherwise false    */
DECL|method|nextBlockAddedToPending (Iterator<BlockInfo> it, DatanodeDescriptor dn)
specifier|private
name|boolean
name|nextBlockAddedToPending
parameter_list|(
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|it
parameter_list|,
name|DatanodeDescriptor
name|dn
parameter_list|)
block|{
name|BlockInfo
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|numBlocksChecked
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isBlockReplicatedOk
argument_list|(
name|dn
argument_list|,
name|block
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|pendingRep
operator|.
name|computeIfAbsent
argument_list|(
name|dn
argument_list|,
name|k
lambda|->
operator|new
name|LinkedList
argument_list|<>
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|getPendingCount ()
specifier|private
name|int
name|getPendingCount
parameter_list|()
block|{
if|if
condition|(
name|pendingRep
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|pendingRep
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|a
lambda|->
name|a
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|reduce
argument_list|(
literal|0
argument_list|,
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
lambda|->
name|a
operator|+
name|b
argument_list|)
return|;
block|}
DECL|method|getYetToBeProcessedCount ()
specifier|private
name|int
name|getYetToBeProcessedCount
parameter_list|()
block|{
if|if
condition|(
name|outOfServiceNodeBlocks
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|outOfServiceNodeBlocks
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|a
lambda|->
name|a
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|reduce
argument_list|(
literal|0
argument_list|,
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
lambda|->
name|a
operator|+
name|b
argument_list|)
return|;
block|}
comment|/**    * Scan all the blocks held on a datanodes. For a node being decommissioned    * we assume that the majority of blocks on the node will need to have new    * replicas made, and therefore we do not check if they are under replicated    * here and instead add them to the list of blocks to track.    *    * For a node being moved into maintenance, we assume most blocks will be    * replicated OK and hence we do check their under-replicated status here,    * hopefully reducing the number of blocks to track.    *    * On a re-scan (initalScan = false) we assume the node has been processed    * already, and hence there should be few under-replicated blocks, so we    * check the under-replicated status before adding the blocks to the    * tracking list.    *    * This means that for a node being decomission there should be a large    * number of blocks to process later but for maintenance, a smaller number.    *    * As this method does not schedule any blocks for reconstuction, this    * scan can be performed under the namenode readlock, and the lock is    * dropped and reaquired for each storage on the DN.    *    * @param dn - The datanode to process    * @param initialScan - True is this is the first time scanning the node    *                    or false if it is a rescan.    */
DECL|method|scanDatanodeStorage (DatanodeDescriptor dn, Boolean initialScan)
specifier|private
name|void
name|scanDatanodeStorage
parameter_list|(
name|DatanodeDescriptor
name|dn
parameter_list|,
name|Boolean
name|initialScan
parameter_list|)
block|{
name|HashMap
argument_list|<
name|BlockInfo
argument_list|,
name|Integer
argument_list|>
name|blockList
init|=
name|outOfServiceNodeBlocks
operator|.
name|get
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockList
operator|==
literal|null
condition|)
block|{
name|blockList
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|outOfServiceNodeBlocks
operator|.
name|put
argument_list|(
name|dn
argument_list|,
name|blockList
argument_list|)
expr_stmt|;
block|}
name|DatanodeStorageInfo
index|[]
name|storage
decl_stmt|;
name|namesystem
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|storage
operator|=
name|dn
operator|.
name|getStorageInfos
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|DatanodeStorageInfo
name|s
range|:
name|storage
control|)
block|{
name|namesystem
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// As the lock is dropped and re-taken between each storage, we need
comment|// to check the storage is still present before processing it, as it
comment|// may have been removed.
if|if
condition|(
name|dn
operator|.
name|getStorageInfo
argument_list|(
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|it
init|=
name|s
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockInfo
name|b
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|initialScan
operator|||
name|dn
operator|.
name|isEnteringMaintenance
argument_list|()
condition|)
block|{
comment|// this is a rescan, so most blocks should be replicated now,
comment|// or this node is going into maintenance. On a healthy
comment|// cluster using racks or upgrade domain, a node should be
comment|// able to go into maintenance without replicating many blocks
comment|// so we will check them immediately.
if|if
condition|(
operator|!
name|isBlockReplicatedOk
argument_list|(
name|dn
argument_list|,
name|b
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|blockList
operator|.
name|put
argument_list|(
name|b
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|blockList
operator|.
name|put
argument_list|(
name|b
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|numBlocksChecked
operator|++
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Process the list of pendingReplication Blocks. These are the blocks    * which have been moved from outOfServiceNodeBlocks, confirmed to be    * under-replicated and were added to the blockManager replication    * queue.    *    * Any blocks which have been confirmed to be replicated sufficiently are    * removed from the list.    *    * The datanode stats are also updated in this method, updating the total    * pending block count, the number of blocks in PendingRep which are in    * open files and the number of blocks in PendingRep which are only on    * out of service nodes.    *    * As this method makes changes to the replication queue, it acquires the    * namenode write lock while it runs.    */
DECL|method|processPendingReplication ()
specifier|private
name|void
name|processPendingReplication
parameter_list|()
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|DatanodeDescriptor
argument_list|,
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
argument_list|>
name|entIt
init|=
name|pendingRep
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|entIt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|DatanodeDescriptor
argument_list|,
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|entry
init|=
name|entIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|DatanodeDescriptor
name|dn
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BlockInfo
argument_list|>
name|blocks
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
block|{
comment|// should not be able to happen
name|entIt
operator|.
name|remove
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|blockIt
init|=
name|blocks
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|BlockStats
name|suspectBlocks
init|=
operator|new
name|BlockStats
argument_list|()
decl_stmt|;
while|while
condition|(
name|blockIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockInfo
name|b
init|=
name|blockIt
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|isBlockReplicatedOk
argument_list|(
name|dn
argument_list|,
name|b
argument_list|,
literal|true
argument_list|,
name|suspectBlocks
argument_list|)
condition|)
block|{
name|blockIt
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|numBlocksChecked
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|blocks
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|entIt
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|// Update metrics for this datanode.
name|dn
operator|.
name|getLeavingServiceStatus
argument_list|()
operator|.
name|set
argument_list|(
name|suspectBlocks
operator|.
name|getOpenFileCount
argument_list|()
argument_list|,
name|suspectBlocks
operator|.
name|getOpenFiles
argument_list|()
argument_list|,
name|getPendingCountForNode
argument_list|(
name|dn
argument_list|)
argument_list|,
name|suspectBlocks
operator|.
name|getOutOfServiceBlockCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Checks if a block is sufficiently replicated and optionally schedules    * it for reconstruction if it is not.    *    * If a BlockStats object is passed, this method will also update it if the    * block is part of an open file or only on outOfService nodes.    *    * @param datanode The datanode the block belongs to    * @param block The block to check    * @param scheduleReconStruction Whether to add the block to the replication    *                               queue if it is not sufficiently replicated.    *                               Passing true will add it to the replication    *                               queue, and false will not.    * @param suspectBlocks If non-null check if the block is part of an open    *                      file or only on out of service nodes and update the    *                      passed object accordingly.    * @return    */
DECL|method|isBlockReplicatedOk (DatanodeDescriptor datanode, BlockInfo block, Boolean scheduleReconStruction, BlockStats suspectBlocks)
specifier|private
name|boolean
name|isBlockReplicatedOk
parameter_list|(
name|DatanodeDescriptor
name|datanode
parameter_list|,
name|BlockInfo
name|block
parameter_list|,
name|Boolean
name|scheduleReconStruction
parameter_list|,
name|BlockStats
name|suspectBlocks
parameter_list|)
block|{
if|if
condition|(
name|blockManager
operator|.
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Removing unknown block {}"
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|long
name|bcId
init|=
name|block
operator|.
name|getBlockCollectionId
argument_list|()
decl_stmt|;
if|if
condition|(
name|bcId
operator|==
name|INodeId
operator|.
name|INVALID_INODE_ID
condition|)
block|{
comment|// Orphan block, will be invalidated eventually. Skip.
return|return
literal|false
return|;
block|}
specifier|final
name|BlockCollection
name|bc
init|=
name|blockManager
operator|.
name|getBlockCollection
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|final
name|NumberReplicas
name|num
init|=
name|blockManager
operator|.
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|final
name|int
name|liveReplicas
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
comment|// Schedule low redundancy blocks for reconstruction
comment|// if not already pending.
name|boolean
name|isDecommission
init|=
name|datanode
operator|.
name|isDecommissionInProgress
argument_list|()
decl_stmt|;
name|boolean
name|isMaintenance
init|=
name|datanode
operator|.
name|isEnteringMaintenance
argument_list|()
decl_stmt|;
name|boolean
name|neededReconstruction
init|=
name|isDecommission
condition|?
name|blockManager
operator|.
name|isNeededReconstruction
argument_list|(
name|block
argument_list|,
name|num
argument_list|)
else|:
name|blockManager
operator|.
name|isNeededReconstructionForMaintenance
argument_list|(
name|block
argument_list|,
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|neededReconstruction
operator|&&
name|scheduleReconStruction
condition|)
block|{
if|if
condition|(
operator|!
name|blockManager
operator|.
name|neededReconstruction
operator|.
name|contains
argument_list|(
name|block
argument_list|)
operator|&&
name|blockManager
operator|.
name|pendingReconstruction
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
operator|==
literal|0
operator|&&
name|blockManager
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
comment|// Process these blocks only when active NN is out of safe mode.
name|blockManager
operator|.
name|neededReconstruction
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|liveReplicas
argument_list|,
name|num
operator|.
name|readOnlyReplicas
argument_list|()
argument_list|,
name|num
operator|.
name|outOfServiceReplicas
argument_list|()
argument_list|,
name|blockManager
operator|.
name|getExpectedRedundancyNum
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|suspectBlocks
operator|!=
literal|null
condition|)
block|{
comment|// Only if we pass a BlockStats object should we do these
comment|// checks, as they should only be checked when processing PendingRep.
if|if
condition|(
name|bc
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|INode
name|ucFile
init|=
name|namesystem
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|getInode
argument_list|(
name|bc
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ucFile
operator|instanceof
name|INodeFile
operator|)
operator|||
operator|!
name|ucFile
operator|.
name|asFile
argument_list|()
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"File {} is not under construction. Skipping add to "
operator|+
literal|"low redundancy open files!"
argument_list|,
name|ucFile
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|suspectBlocks
operator|.
name|addOpenFile
argument_list|(
name|ucFile
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|liveReplicas
operator|==
literal|0
operator|)
operator|&&
operator|(
name|num
operator|.
name|outOfServiceReplicas
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|suspectBlocks
operator|.
name|incrementOutOfServiceBlocks
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Even if the block is without sufficient redundancy,
comment|// it might not block decommission/maintenance if it
comment|// has sufficient redundancy.
if|if
condition|(
name|dnAdmin
operator|.
name|isSufficient
argument_list|(
name|block
argument_list|,
name|bc
argument_list|,
name|num
argument_list|,
name|isDecommission
argument_list|,
name|isMaintenance
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|class|BlockStats
specifier|static
class|class
name|BlockStats
block|{
DECL|field|openFiles
specifier|private
name|LightWeightHashSet
argument_list|<
name|Long
argument_list|>
name|openFiles
init|=
operator|new
name|LightWeightLinkedSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|openFileBlockCount
specifier|private
name|int
name|openFileBlockCount
init|=
literal|0
decl_stmt|;
DECL|field|outOfServiceBlockCount
specifier|private
name|int
name|outOfServiceBlockCount
init|=
literal|0
decl_stmt|;
DECL|method|addOpenFile (long id)
specifier|public
name|void
name|addOpenFile
parameter_list|(
name|long
name|id
parameter_list|)
block|{
comment|// Several blocks can be part of the same file so track how
comment|// many adds we get, as the same file could be added several times
comment|// for different blocks.
name|openFileBlockCount
operator|++
expr_stmt|;
name|openFiles
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
DECL|method|incrementOutOfServiceBlocks ()
specifier|public
name|void
name|incrementOutOfServiceBlocks
parameter_list|()
block|{
name|outOfServiceBlockCount
operator|++
expr_stmt|;
block|}
DECL|method|getOpenFiles ()
specifier|public
name|LightWeightHashSet
argument_list|<
name|Long
argument_list|>
name|getOpenFiles
parameter_list|()
block|{
return|return
name|openFiles
return|;
block|}
DECL|method|getOpenFileCount ()
specifier|public
name|int
name|getOpenFileCount
parameter_list|()
block|{
return|return
name|openFileBlockCount
return|;
block|}
DECL|method|getOutOfServiceBlockCount ()
specifier|public
name|int
name|getOutOfServiceBlockCount
parameter_list|()
block|{
return|return
name|outOfServiceBlockCount
return|;
block|}
block|}
block|}
end_class

end_unit

