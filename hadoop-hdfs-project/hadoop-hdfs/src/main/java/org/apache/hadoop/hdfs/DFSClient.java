begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_KEY_PREFIX
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_CACHE_DROP_BEHIND_READS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_CACHE_DROP_BEHIND_WRITES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_CACHE_READAHEAD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_CONTEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_CONTEXT_DEFAULT
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|GeneralSecurityException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SynchronousQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|net
operator|.
name|SocketFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CipherSuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CryptoCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CryptoInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CryptoOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CryptoProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProvider
operator|.
name|KeyVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProviderCryptoExtension
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProviderCryptoExtension
operator|.
name|EncryptedKeyVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockStorageLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CacheFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FsServerDefaults
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FsStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HdfsBlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|InvalidPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|MD5MD5CRC32CastagnoliFileChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|MD5MD5CRC32FileChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|MD5MD5CRC32GzipFileChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|ChecksumOpt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|VolumeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttrSetFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|DfsClientConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|impl
operator|.
name|LeaseRenewer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
operator|.
name|Peer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
operator|.
name|TcpPeerServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|AclException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CacheDirectiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CacheDirectiveInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CacheDirectiveIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CachePoolEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CachePoolInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CachePoolIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|CorruptFileBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DSQuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DirectoryListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ECInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ECZoneInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|EncryptionZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|EncryptionZoneIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsBlocksMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|RollingUpgradeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|SafeModeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LastBlockWithStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|NSQuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaByStorageTypeExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RollingUpgradeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotAccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotDiffReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshottableDirectoryStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnresolvedPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|DataTransferProtoUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|IOStreamPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Op
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|ReplaceDatanodeOnFailure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|TrustedChannelResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|sasl
operator|.
name|DataEncryptionKeyFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|sasl
operator|.
name|DataTransferSaslUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|sasl
operator|.
name|SaslDataTransferClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|BlockOpResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|OpBlockChecksumResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|PBHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|DataEncryptionKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|InvalidBlockTokenException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|CachingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|SafeModeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataOutputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|EnumSetWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|ECSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|LossyRetryInvocationHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenRenewer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tracing
operator|.
name|SpanReceiverHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tracing
operator|.
name|TraceUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Sampler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|SamplerBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|net
operator|.
name|InetAddresses
import|;
end_import

begin_comment
comment|/********************************************************  * DFSClient can connect to a Hadoop Filesystem and   * perform basic file tasks.  It uses the ClientProtocol  * to communicate with a NameNode daemon, and connects   * directly to DataNodes to read/write block data.  *  * Hadoop DFS users should obtain an instance of   * DistributedFileSystem, which uses DFSClient to handle  * filesystem tasks.  *  ********************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|DFSClient
specifier|public
class|class
name|DFSClient
implements|implements
name|java
operator|.
name|io
operator|.
name|Closeable
implements|,
name|RemotePeerFactory
implements|,
name|DataEncryptionKeyFactory
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DFSClient
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SERVER_DEFAULTS_VALIDITY_PERIOD
specifier|public
specifier|static
specifier|final
name|long
name|SERVER_DEFAULTS_VALIDITY_PERIOD
init|=
literal|60
operator|*
literal|60
operator|*
literal|1000L
decl_stmt|;
comment|// 1 hour
DECL|field|TCP_WINDOW_SIZE
specifier|static
specifier|final
name|int
name|TCP_WINDOW_SIZE
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
comment|// 128 KB
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|dfsClientConf
specifier|private
specifier|final
name|DfsClientConf
name|dfsClientConf
decl_stmt|;
DECL|field|namenode
specifier|final
name|ClientProtocol
name|namenode
decl_stmt|;
comment|/* The service used for delegation tokens */
DECL|field|dtService
specifier|private
name|Text
name|dtService
decl_stmt|;
DECL|field|ugi
specifier|final
name|UserGroupInformation
name|ugi
decl_stmt|;
DECL|field|clientRunning
specifier|volatile
name|boolean
name|clientRunning
init|=
literal|true
decl_stmt|;
DECL|field|lastLeaseRenewal
specifier|volatile
name|long
name|lastLeaseRenewal
decl_stmt|;
DECL|field|serverDefaults
specifier|private
specifier|volatile
name|FsServerDefaults
name|serverDefaults
decl_stmt|;
DECL|field|serverDefaultsLastUpdate
specifier|private
specifier|volatile
name|long
name|serverDefaultsLastUpdate
decl_stmt|;
DECL|field|clientName
specifier|final
name|String
name|clientName
decl_stmt|;
DECL|field|socketFactory
specifier|final
name|SocketFactory
name|socketFactory
decl_stmt|;
DECL|field|dtpReplaceDatanodeOnFailure
specifier|final
name|ReplaceDatanodeOnFailure
name|dtpReplaceDatanodeOnFailure
decl_stmt|;
DECL|field|stats
specifier|final
name|FileSystem
operator|.
name|Statistics
name|stats
decl_stmt|;
DECL|field|authority
specifier|private
specifier|final
name|String
name|authority
decl_stmt|;
DECL|field|r
specifier|private
specifier|final
name|Random
name|r
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|localInterfaceAddrs
specifier|private
name|SocketAddress
index|[]
name|localInterfaceAddrs
decl_stmt|;
DECL|field|encryptionKey
specifier|private
name|DataEncryptionKey
name|encryptionKey
decl_stmt|;
DECL|field|saslClient
specifier|final
name|SaslDataTransferClient
name|saslClient
decl_stmt|;
DECL|field|defaultReadCachingStrategy
specifier|private
specifier|final
name|CachingStrategy
name|defaultReadCachingStrategy
decl_stmt|;
DECL|field|defaultWriteCachingStrategy
specifier|private
specifier|final
name|CachingStrategy
name|defaultWriteCachingStrategy
decl_stmt|;
DECL|field|clientContext
specifier|private
specifier|final
name|ClientContext
name|clientContext
decl_stmt|;
DECL|field|HEDGED_READ_METRIC
specifier|private
specifier|static
specifier|final
name|DFSHedgedReadMetrics
name|HEDGED_READ_METRIC
init|=
operator|new
name|DFSHedgedReadMetrics
argument_list|()
decl_stmt|;
DECL|field|HEDGED_READ_THREAD_POOL
specifier|private
specifier|static
name|ThreadPoolExecutor
name|HEDGED_READ_THREAD_POOL
decl_stmt|;
DECL|field|STRIPED_READ_THREAD_POOL
specifier|private
specifier|static
specifier|volatile
name|ThreadPoolExecutor
name|STRIPED_READ_THREAD_POOL
decl_stmt|;
DECL|field|traceSampler
specifier|private
specifier|final
name|Sampler
argument_list|<
name|?
argument_list|>
name|traceSampler
decl_stmt|;
DECL|field|smallBufferSize
specifier|private
specifier|final
name|int
name|smallBufferSize
decl_stmt|;
DECL|method|getConf ()
specifier|public
name|DfsClientConf
name|getConf
parameter_list|()
block|{
return|return
name|dfsClientConf
return|;
block|}
DECL|method|getConfiguration ()
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/**    * A map from file names to {@link DFSOutputStream} objects    * that are currently being written by this client.    * Note that a file can only be written by a single client.    */
DECL|field|filesBeingWritten
specifier|private
specifier|final
name|Map
argument_list|<
name|Long
argument_list|,
name|DFSOutputStream
argument_list|>
name|filesBeingWritten
init|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|DFSOutputStream
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Same as this(NameNode.getAddress(conf), conf);    * @see #DFSClient(InetSocketAddress, Configuration)    * @deprecated Deprecated at 0.21    */
annotation|@
name|Deprecated
DECL|method|DFSClient (Configuration conf)
specifier|public
name|DFSClient
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|NameNode
operator|.
name|getAddress
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|DFSClient (InetSocketAddress address, Configuration conf)
specifier|public
name|DFSClient
parameter_list|(
name|InetSocketAddress
name|address
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|NameNode
operator|.
name|getUri
argument_list|(
name|address
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Same as this(nameNodeUri, conf, null);    * @see #DFSClient(URI, Configuration, FileSystem.Statistics)    */
DECL|method|DFSClient (URI nameNodeUri, Configuration conf )
specifier|public
name|DFSClient
parameter_list|(
name|URI
name|nameNodeUri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|nameNodeUri
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Same as this(nameNodeUri, null, conf, stats);    * @see #DFSClient(URI, ClientProtocol, Configuration, FileSystem.Statistics)     */
DECL|method|DFSClient (URI nameNodeUri, Configuration conf, FileSystem.Statistics stats)
specifier|public
name|DFSClient
parameter_list|(
name|URI
name|nameNodeUri
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|FileSystem
operator|.
name|Statistics
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|nameNodeUri
argument_list|,
literal|null
argument_list|,
name|conf
argument_list|,
name|stats
argument_list|)
expr_stmt|;
block|}
comment|/**     * Create a new DFSClient connected to the given nameNodeUri or rpcNamenode.    * If HA is enabled and a positive value is set for     * {@link DFSConfigKeys#DFS_CLIENT_TEST_DROP_NAMENODE_RESPONSE_NUM_KEY} in the    * configuration, the DFSClient will use {@link LossyRetryInvocationHandler}    * as its RetryInvocationHandler. Otherwise one of nameNodeUri or rpcNamenode     * must be null.    */
annotation|@
name|VisibleForTesting
DECL|method|DFSClient (URI nameNodeUri, ClientProtocol rpcNamenode, Configuration conf, FileSystem.Statistics stats)
specifier|public
name|DFSClient
parameter_list|(
name|URI
name|nameNodeUri
parameter_list|,
name|ClientProtocol
name|rpcNamenode
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|FileSystem
operator|.
name|Statistics
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
name|SpanReceiverHost
operator|.
name|get
argument_list|(
name|conf
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_HTRACE_PREFIX
argument_list|)
expr_stmt|;
name|traceSampler
operator|=
operator|new
name|SamplerBuilder
argument_list|(
name|TraceUtils
operator|.
name|wrapHadoopConf
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_HTRACE_PREFIX
argument_list|,
name|conf
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
comment|// Copy only the required DFSClient configuration
name|this
operator|.
name|dfsClientConf
operator|=
operator|new
name|DfsClientConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|stats
operator|=
name|stats
expr_stmt|;
name|this
operator|.
name|socketFactory
operator|=
name|NetUtils
operator|.
name|getSocketFactory
argument_list|(
name|conf
argument_list|,
name|ClientProtocol
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|dtpReplaceDatanodeOnFailure
operator|=
name|ReplaceDatanodeOnFailure
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|smallBufferSize
operator|=
name|DFSUtil
operator|.
name|getSmallBufferSize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
name|this
operator|.
name|authority
operator|=
name|nameNodeUri
operator|==
literal|null
condition|?
literal|"null"
else|:
name|nameNodeUri
operator|.
name|getAuthority
argument_list|()
expr_stmt|;
name|this
operator|.
name|clientName
operator|=
literal|"DFSClient_"
operator|+
name|dfsClientConf
operator|.
name|getTaskId
argument_list|()
operator|+
literal|"_"
operator|+
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
operator|+
literal|"_"
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getId
argument_list|()
expr_stmt|;
name|int
name|numResponseToDrop
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_TEST_DROP_NAMENODE_RESPONSE_NUM_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_TEST_DROP_NAMENODE_RESPONSE_NUM_DEFAULT
argument_list|)
decl_stmt|;
name|NameNodeProxies
operator|.
name|ProxyAndInfo
argument_list|<
name|ClientProtocol
argument_list|>
name|proxyInfo
init|=
literal|null
decl_stmt|;
name|AtomicBoolean
name|nnFallbackToSimpleAuth
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|numResponseToDrop
operator|>
literal|0
condition|)
block|{
comment|// This case is used for testing.
name|LOG
operator|.
name|warn
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_TEST_DROP_NAMENODE_RESPONSE_NUM_KEY
operator|+
literal|" is set to "
operator|+
name|numResponseToDrop
operator|+
literal|", this hacked client will proactively drop responses"
argument_list|)
expr_stmt|;
name|proxyInfo
operator|=
name|NameNodeProxies
operator|.
name|createProxyWithLossyRetryHandler
argument_list|(
name|conf
argument_list|,
name|nameNodeUri
argument_list|,
name|ClientProtocol
operator|.
name|class
argument_list|,
name|numResponseToDrop
argument_list|,
name|nnFallbackToSimpleAuth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proxyInfo
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|dtService
operator|=
name|proxyInfo
operator|.
name|getDelegationTokenService
argument_list|()
expr_stmt|;
name|this
operator|.
name|namenode
operator|=
name|proxyInfo
operator|.
name|getProxy
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rpcNamenode
operator|!=
literal|null
condition|)
block|{
comment|// This case is used for testing.
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|nameNodeUri
operator|==
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|namenode
operator|=
name|rpcNamenode
expr_stmt|;
name|dtService
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|noRetries
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_TEST_NO_PROXY_RETRIES
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_TEST_NO_PROXY_RETRIES_DEFAULT
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|nameNodeUri
operator|!=
literal|null
argument_list|,
literal|"null URI"
argument_list|)
expr_stmt|;
name|proxyInfo
operator|=
name|NameNodeProxies
operator|.
name|createProxy
argument_list|(
name|conf
argument_list|,
name|nameNodeUri
argument_list|,
name|ClientProtocol
operator|.
name|class
argument_list|,
name|nnFallbackToSimpleAuth
argument_list|,
operator|!
name|noRetries
argument_list|)
expr_stmt|;
name|this
operator|.
name|dtService
operator|=
name|proxyInfo
operator|.
name|getDelegationTokenService
argument_list|()
expr_stmt|;
name|this
operator|.
name|namenode
operator|=
name|proxyInfo
operator|.
name|getProxy
argument_list|()
expr_stmt|;
block|}
name|String
name|localInterfaces
index|[]
init|=
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_LOCAL_INTERFACES
argument_list|)
decl_stmt|;
name|localInterfaceAddrs
operator|=
name|getLocalInterfaceAddrs
argument_list|(
name|localInterfaces
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
literal|0
operator|!=
name|localInterfaces
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using local interfaces ["
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|localInterfaces
argument_list|)
operator|+
literal|"] with addresses ["
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|join
argument_list|(
name|localInterfaceAddrs
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|Boolean
name|readDropBehind
init|=
operator|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_CLIENT_CACHE_DROP_BEHIND_READS
argument_list|)
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_CLIENT_CACHE_DROP_BEHIND_READS
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Long
name|readahead
init|=
operator|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_CLIENT_CACHE_READAHEAD
argument_list|)
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_CLIENT_CACHE_READAHEAD
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Boolean
name|writeDropBehind
init|=
operator|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_CLIENT_CACHE_DROP_BEHIND_WRITES
argument_list|)
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_CLIENT_CACHE_DROP_BEHIND_WRITES
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|this
operator|.
name|defaultReadCachingStrategy
operator|=
operator|new
name|CachingStrategy
argument_list|(
name|readDropBehind
argument_list|,
name|readahead
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultWriteCachingStrategy
operator|=
operator|new
name|CachingStrategy
argument_list|(
name|writeDropBehind
argument_list|,
name|readahead
argument_list|)
expr_stmt|;
name|this
operator|.
name|clientContext
operator|=
name|ClientContext
operator|.
name|get
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_CLIENT_CONTEXT
argument_list|,
name|DFS_CLIENT_CONTEXT_DEFAULT
argument_list|)
argument_list|,
name|dfsClientConf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfsClientConf
operator|.
name|getHedgedReadThreadpoolSize
argument_list|()
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|initThreadsNumForHedgedReads
argument_list|(
name|dfsClientConf
operator|.
name|getHedgedReadThreadpoolSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numThreads
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_STRIPED_READ_THREADPOOL_MAX_SIZE
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_STRIPED_READ_THREADPOOL_MAX_DEFAULT_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|numThreads
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The value of "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_STRIPED_READ_THREADPOOL_MAX_SIZE
operator|+
literal|" must be greater than 0. The current setting is "
operator|+
name|numThreads
operator|+
literal|". Reset it to the default value "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_STRIPED_READ_THREADPOOL_MAX_DEFAULT_SIZE
argument_list|)
expr_stmt|;
name|numThreads
operator|=
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_STRIPED_READ_THREADPOOL_MAX_DEFAULT_SIZE
expr_stmt|;
block|}
name|this
operator|.
name|initThreadsNumForStripedReads
argument_list|(
name|numThreads
argument_list|)
expr_stmt|;
name|this
operator|.
name|saslClient
operator|=
operator|new
name|SaslDataTransferClient
argument_list|(
name|conf
argument_list|,
name|DataTransferSaslUtil
operator|.
name|getSaslPropertiesResolver
argument_list|(
name|conf
argument_list|)
argument_list|,
name|TrustedChannelResolver
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
argument_list|,
name|nnFallbackToSimpleAuth
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the socket addresses to use with each configured    * local interface. Local interfaces may be specified by IP    * address, IP address range using CIDR notation, interface    * name (e.g. eth0) or sub-interface name (e.g. eth0:0).    * The socket addresses consist of the IPs for the interfaces    * and the ephemeral port (port 0). If an IP, IP range, or    * interface name matches an interface with sub-interfaces    * only the IP of the interface is used. Sub-interfaces can    * be used by specifying them explicitly (by IP or name).    *     * @return SocketAddresses for the configured local interfaces,    *    or an empty array if none are configured    * @throws UnknownHostException if a given interface name is invalid    */
DECL|method|getLocalInterfaceAddrs ( String interfaceNames[])
specifier|private
specifier|static
name|SocketAddress
index|[]
name|getLocalInterfaceAddrs
parameter_list|(
name|String
name|interfaceNames
index|[]
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|List
argument_list|<
name|SocketAddress
argument_list|>
name|localAddrs
init|=
operator|new
name|ArrayList
argument_list|<
name|SocketAddress
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|interfaceName
range|:
name|interfaceNames
control|)
block|{
if|if
condition|(
name|InetAddresses
operator|.
name|isInetAddress
argument_list|(
name|interfaceName
argument_list|)
condition|)
block|{
name|localAddrs
operator|.
name|add
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|interfaceName
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NetUtils
operator|.
name|isValidSubnet
argument_list|(
name|interfaceName
argument_list|)
condition|)
block|{
for|for
control|(
name|InetAddress
name|addr
range|:
name|NetUtils
operator|.
name|getIPs
argument_list|(
name|interfaceName
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|localAddrs
operator|.
name|add
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|String
name|ip
range|:
name|DNS
operator|.
name|getIPs
argument_list|(
name|interfaceName
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|localAddrs
operator|.
name|add
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|localAddrs
operator|.
name|toArray
argument_list|(
operator|new
name|SocketAddress
index|[
name|localAddrs
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Select one of the configured local interfaces at random. We use a random    * interface because other policies like round-robin are less effective    * given that we cache connections to datanodes.    *    * @return one of the local interface addresses at random, or null if no    *    local interfaces are configured    */
DECL|method|getRandomLocalInterfaceAddr ()
name|SocketAddress
name|getRandomLocalInterfaceAddr
parameter_list|()
block|{
if|if
condition|(
name|localInterfaceAddrs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|idx
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|localInterfaceAddrs
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|SocketAddress
name|addr
init|=
name|localInterfaceAddrs
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using local interface "
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
comment|/**    * Return the timeout that clients should use when writing to datanodes.    * @param numNodes the number of nodes in the pipeline.    */
DECL|method|getDatanodeWriteTimeout (int numNodes)
name|int
name|getDatanodeWriteTimeout
parameter_list|(
name|int
name|numNodes
parameter_list|)
block|{
specifier|final
name|int
name|t
init|=
name|dfsClientConf
operator|.
name|getDatanodeSocketWriteTimeout
argument_list|()
decl_stmt|;
return|return
name|t
operator|>
literal|0
condition|?
name|t
operator|+
name|HdfsServerConstants
operator|.
name|WRITE_TIMEOUT_EXTENSION
operator|*
name|numNodes
else|:
literal|0
return|;
block|}
DECL|method|getDatanodeReadTimeout (int numNodes)
name|int
name|getDatanodeReadTimeout
parameter_list|(
name|int
name|numNodes
parameter_list|)
block|{
specifier|final
name|int
name|t
init|=
name|dfsClientConf
operator|.
name|getSocketTimeout
argument_list|()
decl_stmt|;
return|return
name|t
operator|>
literal|0
condition|?
name|HdfsServerConstants
operator|.
name|READ_TIMEOUT_EXTENSION
operator|*
name|numNodes
operator|+
name|t
else|:
literal|0
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getClientName ()
specifier|public
name|String
name|getClientName
parameter_list|()
block|{
return|return
name|clientName
return|;
block|}
DECL|method|checkOpen ()
name|void
name|checkOpen
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|clientRunning
condition|)
block|{
name|IOException
name|result
init|=
operator|new
name|IOException
argument_list|(
literal|"Filesystem closed"
argument_list|)
decl_stmt|;
throw|throw
name|result
throw|;
block|}
block|}
comment|/** Return the lease renewer instance. The renewer thread won't start    *  until the first output stream is created. The same instance will    *  be returned until all output streams are closed.    */
DECL|method|getLeaseRenewer ()
specifier|public
name|LeaseRenewer
name|getLeaseRenewer
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|LeaseRenewer
operator|.
name|getInstance
argument_list|(
name|authority
argument_list|,
name|ugi
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/** Get a lease and start automatic renewal */
DECL|method|beginFileLease (final long inodeId, final DFSOutputStream out)
specifier|private
name|void
name|beginFileLease
parameter_list|(
specifier|final
name|long
name|inodeId
parameter_list|,
specifier|final
name|DFSOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|getLeaseRenewer
argument_list|()
operator|.
name|put
argument_list|(
name|inodeId
argument_list|,
name|out
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/** Stop renewal of lease for the file. */
DECL|method|endFileLease (final long inodeId)
name|void
name|endFileLease
parameter_list|(
specifier|final
name|long
name|inodeId
parameter_list|)
throws|throws
name|IOException
block|{
name|getLeaseRenewer
argument_list|()
operator|.
name|closeFile
argument_list|(
name|inodeId
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/** Put a file. Only called from LeaseRenewer, where proper locking is    *  enforced to consistently update its local dfsclients array and     *  client's filesBeingWritten map.    */
DECL|method|putFileBeingWritten (final long inodeId, final DFSOutputStream out)
specifier|public
name|void
name|putFileBeingWritten
parameter_list|(
specifier|final
name|long
name|inodeId
parameter_list|,
specifier|final
name|DFSOutputStream
name|out
parameter_list|)
block|{
synchronized|synchronized
init|(
name|filesBeingWritten
init|)
block|{
name|filesBeingWritten
operator|.
name|put
argument_list|(
name|inodeId
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|// update the last lease renewal time only when there was no
comment|// writes. once there is one write stream open, the lease renewer
comment|// thread keeps it updated well with in anyone's expiration time.
if|if
condition|(
name|lastLeaseRenewal
operator|==
literal|0
condition|)
block|{
name|updateLastLeaseRenewal
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Remove a file. Only called from LeaseRenewer. */
DECL|method|removeFileBeingWritten (final long inodeId)
specifier|public
name|void
name|removeFileBeingWritten
parameter_list|(
specifier|final
name|long
name|inodeId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|filesBeingWritten
init|)
block|{
name|filesBeingWritten
operator|.
name|remove
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesBeingWritten
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lastLeaseRenewal
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/** Is file-being-written map empty? */
DECL|method|isFilesBeingWrittenEmpty ()
specifier|public
name|boolean
name|isFilesBeingWrittenEmpty
parameter_list|()
block|{
synchronized|synchronized
init|(
name|filesBeingWritten
init|)
block|{
return|return
name|filesBeingWritten
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
comment|/** @return true if the client is running */
DECL|method|isClientRunning ()
specifier|public
name|boolean
name|isClientRunning
parameter_list|()
block|{
return|return
name|clientRunning
return|;
block|}
DECL|method|getLastLeaseRenewal ()
name|long
name|getLastLeaseRenewal
parameter_list|()
block|{
return|return
name|lastLeaseRenewal
return|;
block|}
DECL|method|updateLastLeaseRenewal ()
name|void
name|updateLastLeaseRenewal
parameter_list|()
block|{
synchronized|synchronized
init|(
name|filesBeingWritten
init|)
block|{
if|if
condition|(
name|filesBeingWritten
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|lastLeaseRenewal
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Renew leases.    * @return true if lease was renewed. May return false if this    * client has been closed or has no files open.    **/
DECL|method|renewLease ()
specifier|public
name|boolean
name|renewLease
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|clientRunning
operator|&&
operator|!
name|isFilesBeingWrittenEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|namenode
operator|.
name|renewLease
argument_list|(
name|clientName
argument_list|)
expr_stmt|;
name|updateLastLeaseRenewal
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Abort if the lease has already expired.
specifier|final
name|long
name|elapsed
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|getLastLeaseRenewal
argument_list|()
decl_stmt|;
if|if
condition|(
name|elapsed
operator|>
name|HdfsServerConstants
operator|.
name|LEASE_HARDLIMIT_PERIOD
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to renew lease for "
operator|+
name|clientName
operator|+
literal|" for "
operator|+
operator|(
name|elapsed
operator|/
literal|1000
operator|)
operator|+
literal|" seconds (>= hard-limit ="
operator|+
operator|(
name|HdfsServerConstants
operator|.
name|LEASE_HARDLIMIT_PERIOD
operator|/
literal|1000
operator|)
operator|+
literal|" seconds.) "
operator|+
literal|"Closing all files being written ..."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|closeAllFilesBeingWritten
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Let the lease renewer handle it and retry.
throw|throw
name|e
throw|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Close connections the Namenode.    */
DECL|method|closeConnectionToNamenode ()
name|void
name|closeConnectionToNamenode
parameter_list|()
block|{
name|RPC
operator|.
name|stopProxy
argument_list|(
name|namenode
argument_list|)
expr_stmt|;
block|}
comment|/** Abort and release resources held.  Ignore all errors. */
DECL|method|abort ()
specifier|public
name|void
name|abort
parameter_list|()
block|{
name|clientRunning
operator|=
literal|false
expr_stmt|;
name|closeAllFilesBeingWritten
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
comment|// remove reference to this client and stop the renewer,
comment|// if there is no more clients under the renewer.
name|getLeaseRenewer
argument_list|()
operator|.
name|closeClient
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception occurred while aborting the client "
operator|+
name|ioe
argument_list|)
expr_stmt|;
block|}
name|closeConnectionToNamenode
argument_list|()
expr_stmt|;
block|}
comment|/** Close/abort all files being written. */
DECL|method|closeAllFilesBeingWritten (final boolean abort)
specifier|private
name|void
name|closeAllFilesBeingWritten
parameter_list|(
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|long
name|inodeId
decl_stmt|;
specifier|final
name|DFSOutputStream
name|out
decl_stmt|;
synchronized|synchronized
init|(
name|filesBeingWritten
init|)
block|{
if|if
condition|(
name|filesBeingWritten
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|inodeId
operator|=
name|filesBeingWritten
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
name|out
operator|=
name|filesBeingWritten
operator|.
name|remove
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|abort
condition|)
block|{
name|out
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to "
operator|+
operator|(
name|abort
condition|?
literal|"abort"
else|:
literal|"close"
operator|)
operator|+
literal|" inode "
operator|+
name|inodeId
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Close the file system, abandoning all of the leases and files being    * created and close connections to the namenode.    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|clientRunning
condition|)
block|{
name|closeAllFilesBeingWritten
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|clientRunning
operator|=
literal|false
expr_stmt|;
name|getLeaseRenewer
argument_list|()
operator|.
name|closeClient
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// close connections to the namenode
name|closeConnectionToNamenode
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Close all open streams, abandoning all of the leases and files being    * created.    * @param abort whether streams should be gracefully closed    */
DECL|method|closeOutputStreams (boolean abort)
specifier|public
name|void
name|closeOutputStreams
parameter_list|(
name|boolean
name|abort
parameter_list|)
block|{
if|if
condition|(
name|clientRunning
condition|)
block|{
name|closeAllFilesBeingWritten
argument_list|(
name|abort
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @see ClientProtocol#getPreferredBlockSize(String)    */
DECL|method|getBlockSize (String f)
specifier|public
name|long
name|getBlockSize
parameter_list|(
name|String
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getBlockSize"
argument_list|,
name|f
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getPreferredBlockSize
argument_list|(
name|f
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem getting block size"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get server default values for a number of configuration params.    * @see ClientProtocol#getServerDefaults()    */
DECL|method|getServerDefaults ()
specifier|public
name|FsServerDefaults
name|getServerDefaults
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|serverDefaults
operator|==
literal|null
operator|)
operator|||
operator|(
name|now
operator|-
name|serverDefaultsLastUpdate
operator|>
name|SERVER_DEFAULTS_VALIDITY_PERIOD
operator|)
condition|)
block|{
name|serverDefaults
operator|=
name|namenode
operator|.
name|getServerDefaults
argument_list|()
expr_stmt|;
name|serverDefaultsLastUpdate
operator|=
name|now
expr_stmt|;
block|}
assert|assert
name|serverDefaults
operator|!=
literal|null
assert|;
return|return
name|serverDefaults
return|;
block|}
comment|/**    * Get a canonical token service name for this client's tokens.  Null should    * be returned if the client is not using tokens.    * @return the token service for the client    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|}
argument_list|)
DECL|method|getCanonicalServiceName ()
specifier|public
name|String
name|getCanonicalServiceName
parameter_list|()
block|{
return|return
operator|(
name|dtService
operator|!=
literal|null
operator|)
condition|?
name|dtService
operator|.
name|toString
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**    * @see ClientProtocol#getDelegationToken(Text)    */
DECL|method|getDelegationToken (Text renewer)
specifier|public
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|getDelegationToken
parameter_list|(
name|Text
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|dtService
operator|!=
literal|null
assert|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"getDelegationToken"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
init|=
name|namenode
operator|.
name|getDelegationToken
argument_list|(
name|renewer
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|token
operator|.
name|setService
argument_list|(
name|this
operator|.
name|dtService
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created "
operator|+
name|DelegationTokenIdentifier
operator|.
name|stringifyToken
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot get delegation token from "
operator|+
name|renewer
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Renew a delegation token    * @param token the token to renew    * @return the new expiration time    * @throws InvalidToken    * @throws IOException    * @deprecated Use Token.renew instead.    */
annotation|@
name|Deprecated
DECL|method|renewDelegationToken (Token<DelegationTokenIdentifier> token)
specifier|public
name|long
name|renewDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|InvalidToken
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Renewing "
operator|+
name|DelegationTokenIdentifier
operator|.
name|stringifyToken
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|token
operator|.
name|renew
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"caught interrupted"
argument_list|,
name|ie
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|InvalidToken
operator|.
name|class
argument_list|,
name|AccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
block|}
DECL|field|localAddrMap
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|localAddrMap
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|isLocalAddress (InetSocketAddress targetAddr)
specifier|public
specifier|static
name|boolean
name|isLocalAddress
parameter_list|(
name|InetSocketAddress
name|targetAddr
parameter_list|)
block|{
name|InetAddress
name|addr
init|=
name|targetAddr
operator|.
name|getAddress
argument_list|()
decl_stmt|;
name|Boolean
name|cached
init|=
name|localAddrMap
operator|.
name|get
argument_list|(
name|addr
operator|.
name|getHostAddress
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Address "
operator|+
name|targetAddr
operator|+
operator|(
name|cached
condition|?
literal|" is local"
else|:
literal|" is not local"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cached
return|;
block|}
name|boolean
name|local
init|=
name|NetUtils
operator|.
name|isLocalAddress
argument_list|(
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Address "
operator|+
name|targetAddr
operator|+
operator|(
name|local
condition|?
literal|" is local"
else|:
literal|" is not local"
operator|)
argument_list|)
expr_stmt|;
block|}
name|localAddrMap
operator|.
name|put
argument_list|(
name|addr
operator|.
name|getHostAddress
argument_list|()
argument_list|,
name|local
argument_list|)
expr_stmt|;
return|return
name|local
return|;
block|}
comment|/**    * Cancel a delegation token    * @param token the token to cancel    * @throws InvalidToken    * @throws IOException    * @deprecated Use Token.cancel instead.    */
annotation|@
name|Deprecated
DECL|method|cancelDelegationToken (Token<DelegationTokenIdentifier> token)
specifier|public
name|void
name|cancelDelegationToken
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|InvalidToken
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cancelling "
operator|+
name|DelegationTokenIdentifier
operator|.
name|stringifyToken
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|token
operator|.
name|cancel
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"caught interrupted"
argument_list|,
name|ie
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|InvalidToken
operator|.
name|class
argument_list|,
name|AccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|Renewer
specifier|public
specifier|static
class|class
name|Renewer
extends|extends
name|TokenRenewer
block|{
static|static
block|{
comment|//Ensure that HDFS Configuration files are loaded before trying to use
comment|// the renewer.
name|HdfsConfiguration
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|handleKind (Text kind)
specifier|public
name|boolean
name|handleKind
parameter_list|(
name|Text
name|kind
parameter_list|)
block|{
return|return
name|DelegationTokenIdentifier
operator|.
name|HDFS_DELEGATION_KIND
operator|.
name|equals
argument_list|(
name|kind
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|renew (Token<?> token, Configuration conf)
specifier|public
name|long
name|renew
parameter_list|(
name|Token
argument_list|<
name|?
argument_list|>
name|token
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|delToken
init|=
operator|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
operator|)
name|token
decl_stmt|;
name|ClientProtocol
name|nn
init|=
name|getNNProxy
argument_list|(
name|delToken
argument_list|,
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|nn
operator|.
name|renewDelegationToken
argument_list|(
name|delToken
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|InvalidToken
operator|.
name|class
argument_list|,
name|AccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|cancel (Token<?> token, Configuration conf)
specifier|public
name|void
name|cancel
parameter_list|(
name|Token
argument_list|<
name|?
argument_list|>
name|token
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|delToken
init|=
operator|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
operator|)
name|token
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cancelling "
operator|+
name|DelegationTokenIdentifier
operator|.
name|stringifyToken
argument_list|(
name|delToken
argument_list|)
argument_list|)
expr_stmt|;
name|ClientProtocol
name|nn
init|=
name|getNNProxy
argument_list|(
name|delToken
argument_list|,
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
name|nn
operator|.
name|cancelDelegationToken
argument_list|(
name|delToken
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|InvalidToken
operator|.
name|class
argument_list|,
name|AccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
block|}
DECL|method|getNNProxy ( Token<DelegationTokenIdentifier> token, Configuration conf)
specifier|private
specifier|static
name|ClientProtocol
name|getNNProxy
parameter_list|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
name|token
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|URI
name|uri
init|=
name|HAUtilClient
operator|.
name|getServiceUriFromToken
argument_list|(
name|HdfsConstants
operator|.
name|HDFS_URI_SCHEME
argument_list|,
name|token
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAUtilClient
operator|.
name|isTokenForLogicalUri
argument_list|(
name|token
argument_list|)
operator|&&
operator|!
name|HAUtilClient
operator|.
name|isLogicalUri
argument_list|(
name|conf
argument_list|,
name|uri
argument_list|)
condition|)
block|{
comment|// If the token is for a logical nameservice, but the configuration
comment|// we have disagrees about that, we can't actually renew it.
comment|// This can be the case in MR, for example, if the RM doesn't
comment|// have all of the HA clusters configured in its configuration.
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to map logical nameservice URI '"
operator|+
name|uri
operator|+
literal|"' to a NameNode. Local configuration does not have "
operator|+
literal|"a failover proxy provider configured."
argument_list|)
throw|;
block|}
name|NameNodeProxies
operator|.
name|ProxyAndInfo
argument_list|<
name|ClientProtocol
argument_list|>
name|info
init|=
name|NameNodeProxies
operator|.
name|createProxy
argument_list|(
name|conf
argument_list|,
name|uri
argument_list|,
name|ClientProtocol
operator|.
name|class
argument_list|)
decl_stmt|;
assert|assert
name|info
operator|.
name|getDelegationTokenService
argument_list|()
operator|.
name|equals
argument_list|(
name|token
operator|.
name|getService
argument_list|()
argument_list|)
operator|:
literal|"Returned service '"
operator|+
name|info
operator|.
name|getDelegationTokenService
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"' doesn't match expected service '"
operator|+
name|token
operator|.
name|getService
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"'"
assert|;
return|return
name|info
operator|.
name|getProxy
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isManaged (Token<?> token)
specifier|public
name|boolean
name|isManaged
parameter_list|(
name|Token
argument_list|<
name|?
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Report corrupt blocks that were discovered by the client.    * @see ClientProtocol#reportBadBlocks(LocatedBlock[])    */
DECL|method|reportBadBlocks (LocatedBlock[] blocks)
specifier|public
name|void
name|reportBadBlocks
parameter_list|(
name|LocatedBlock
index|[]
name|blocks
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|namenode
operator|.
name|reportBadBlocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
DECL|method|getLocatedBlocks (String src, long start)
specifier|public
name|LocatedBlocks
name|getLocatedBlocks
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|start
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getLocatedBlocks
argument_list|(
name|src
argument_list|,
name|start
argument_list|,
name|dfsClientConf
operator|.
name|getPrefetchSize
argument_list|()
argument_list|)
return|;
block|}
comment|/*    * This is just a wrapper around callGetBlockLocations, but non-static so that    * we can stub it out for tests.    */
annotation|@
name|VisibleForTesting
DECL|method|getLocatedBlocks (String src, long start, long length)
specifier|public
name|LocatedBlocks
name|getLocatedBlocks
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getBlockLocations"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|callGetBlockLocations
argument_list|(
name|namenode
argument_list|,
name|src
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @see ClientProtocol#getBlockLocations(String, long, long)    */
DECL|method|callGetBlockLocations (ClientProtocol namenode, String src, long start, long length)
specifier|static
name|LocatedBlocks
name|callGetBlockLocations
parameter_list|(
name|ClientProtocol
name|namenode
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|namenode
operator|.
name|getBlockLocations
argument_list|(
name|src
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
block|}
comment|/**    * Recover a file's lease    * @param src a file's path    * @return true if the file is already closed    * @throws IOException    */
DECL|method|recoverLease (String src)
name|boolean
name|recoverLease
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"recoverLease"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|recoverLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|AccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get block location info about file    *     * getBlockLocations() returns a list of hostnames that store     * data for a specific file region.  It returns a set of hostnames    * for every block within the indicated region.    *    * This function is very useful when writing code that considers    * data-placement when performing operations.  For example, the    * MapReduce system tries to schedule tasks on the same machines    * as the data-block the task processes.     */
DECL|method|getBlockLocations (String src, long start, long length)
specifier|public
name|BlockLocation
index|[]
name|getBlockLocations
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getBlockLocations"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|LocatedBlocks
name|blocks
init|=
name|getLocatedBlocks
argument_list|(
name|src
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|BlockLocation
index|[]
name|locations
init|=
name|DFSUtilClient
operator|.
name|locatedBlocks2Locations
argument_list|(
name|blocks
argument_list|)
decl_stmt|;
name|HdfsBlockLocation
index|[]
name|hdfsLocations
init|=
operator|new
name|HdfsBlockLocation
index|[
name|locations
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|hdfsLocations
index|[
name|i
index|]
operator|=
operator|new
name|HdfsBlockLocation
argument_list|(
name|locations
index|[
name|i
index|]
argument_list|,
name|blocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|hdfsLocations
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get block location information about a list of {@link HdfsBlockLocation}.    * Used by {@link DistributedFileSystem#getFileBlockStorageLocations(List)} to    * get {@link BlockStorageLocation}s for blocks returned by    * {@link DistributedFileSystem#getFileBlockLocations(org.apache.hadoop.fs.FileStatus, long, long)}    * .    *     * This is done by making a round of RPCs to the associated datanodes, asking    * the volume of each block replica. The returned array of    * {@link BlockStorageLocation} expose this information as a    * {@link VolumeId}.    *     * @param blockLocations    *          target blocks on which to query volume location information    * @return volumeBlockLocations original block array augmented with additional    *         volume location information for each replica.    */
DECL|method|getBlockStorageLocations ( List<BlockLocation> blockLocations)
specifier|public
name|BlockStorageLocation
index|[]
name|getBlockStorageLocations
parameter_list|(
name|List
argument_list|<
name|BlockLocation
argument_list|>
name|blockLocations
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnsupportedOperationException
throws|,
name|InvalidBlockTokenException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getConf
argument_list|()
operator|.
name|isHdfsBlocksMetadataEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Datanode-side support for "
operator|+
literal|"getVolumeBlockLocations() must also be enabled in the client "
operator|+
literal|"configuration."
argument_list|)
throw|;
block|}
comment|// Downcast blockLocations and fetch out required LocatedBlock(s)
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|blocks
init|=
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockLocation
name|loc
range|:
name|blockLocations
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|loc
operator|instanceof
name|HdfsBlockLocation
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"DFSClient#getVolumeBlockLocations "
operator|+
literal|"expected to be passed HdfsBlockLocations"
argument_list|)
throw|;
block|}
name|HdfsBlockLocation
name|hdfsLoc
init|=
operator|(
name|HdfsBlockLocation
operator|)
name|loc
decl_stmt|;
name|blocks
operator|.
name|add
argument_list|(
name|hdfsLoc
operator|.
name|getLocatedBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Re-group the LocatedBlocks to be grouped by datanodes, with the values
comment|// a list of the LocatedBlocks on the datanode.
name|Map
argument_list|<
name|DatanodeInfo
argument_list|,
name|List
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|>
name|datanodeBlocks
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|DatanodeInfo
argument_list|,
name|List
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|LocatedBlock
name|b
range|:
name|blocks
control|)
block|{
for|for
control|(
name|DatanodeInfo
name|info
range|:
name|b
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|datanodeBlocks
operator|.
name|containsKey
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|datanodeBlocks
operator|.
name|put
argument_list|(
name|info
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|l
init|=
name|datanodeBlocks
operator|.
name|get
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|l
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Make RPCs to the datanodes to get volume locations for its replicas
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"getBlockStorageLocations"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|DatanodeInfo
argument_list|,
name|HdfsBlocksMetadata
argument_list|>
name|metadatas
decl_stmt|;
try|try
block|{
name|metadatas
operator|=
name|BlockStorageLocationUtil
operator|.
name|queryDatanodesForHdfsBlocksMetadata
argument_list|(
name|conf
argument_list|,
name|datanodeBlocks
argument_list|,
name|getConf
argument_list|()
operator|.
name|getFileBlockStorageLocationsNumThreads
argument_list|()
argument_list|,
name|getConf
argument_list|()
operator|.
name|getFileBlockStorageLocationsTimeoutMs
argument_list|()
argument_list|,
name|getConf
argument_list|()
operator|.
name|isConnectToDnViaHostname
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"metadata returned: "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|withKeyValueSeparator
argument_list|(
literal|"="
argument_list|)
operator|.
name|join
argument_list|(
name|metadatas
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Regroup the returned VolumeId metadata to again be grouped by
comment|// LocatedBlock rather than by datanode
name|Map
argument_list|<
name|LocatedBlock
argument_list|,
name|List
argument_list|<
name|VolumeId
argument_list|>
argument_list|>
name|blockVolumeIds
init|=
name|BlockStorageLocationUtil
operator|.
name|associateVolumeIdsWithBlocks
argument_list|(
name|blocks
argument_list|,
name|metadatas
argument_list|)
decl_stmt|;
comment|// Combine original BlockLocations with new VolumeId information
name|BlockStorageLocation
index|[]
name|volumeBlockLocations
init|=
name|BlockStorageLocationUtil
operator|.
name|convertToVolumeBlockLocations
argument_list|(
name|blocks
argument_list|,
name|blockVolumeIds
argument_list|)
decl_stmt|;
return|return
name|volumeBlockLocations
return|;
block|}
comment|/**    * Decrypts a EDEK by consulting the KeyProvider.    */
DECL|method|decryptEncryptedDataEncryptionKey (FileEncryptionInfo feInfo)
specifier|private
name|KeyVersion
name|decryptEncryptedDataEncryptionKey
parameter_list|(
name|FileEncryptionInfo
name|feInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"decryptEDEK"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|KeyProvider
name|provider
init|=
name|getKeyProvider
argument_list|()
decl_stmt|;
if|if
condition|(
name|provider
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No KeyProvider is configured, cannot access"
operator|+
literal|" an encrypted file"
argument_list|)
throw|;
block|}
name|EncryptedKeyVersion
name|ekv
init|=
name|EncryptedKeyVersion
operator|.
name|createForDecryption
argument_list|(
name|feInfo
operator|.
name|getKeyName
argument_list|()
argument_list|,
name|feInfo
operator|.
name|getEzKeyVersionName
argument_list|()
argument_list|,
name|feInfo
operator|.
name|getIV
argument_list|()
argument_list|,
name|feInfo
operator|.
name|getEncryptedDataEncryptionKey
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|KeyProviderCryptoExtension
name|cryptoProvider
init|=
name|KeyProviderCryptoExtension
operator|.
name|createKeyProviderCryptoExtension
argument_list|(
name|provider
argument_list|)
decl_stmt|;
return|return
name|cryptoProvider
operator|.
name|decryptEncryptedKey
argument_list|(
name|ekv
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Obtain the crypto protocol version from the provided FileEncryptionInfo,    * checking to see if this version is supported by.    *    * @param feInfo FileEncryptionInfo    * @return CryptoProtocolVersion from the feInfo    * @throws IOException if the protocol version is unsupported.    */
DECL|method|getCryptoProtocolVersion (FileEncryptionInfo feInfo)
specifier|private
specifier|static
name|CryptoProtocolVersion
name|getCryptoProtocolVersion
parameter_list|(
name|FileEncryptionInfo
name|feInfo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|CryptoProtocolVersion
name|version
init|=
name|feInfo
operator|.
name|getCryptoProtocolVersion
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|CryptoProtocolVersion
operator|.
name|supports
argument_list|(
name|version
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Client does not support specified "
operator|+
literal|"CryptoProtocolVersion "
operator|+
name|version
operator|.
name|getDescription
argument_list|()
operator|+
literal|" version "
operator|+
literal|"number"
operator|+
name|version
operator|.
name|getVersion
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|version
return|;
block|}
comment|/**    * Obtain a CryptoCodec based on the CipherSuite set in a FileEncryptionInfo    * and the available CryptoCodecs configured in the Configuration.    *    * @param conf   Configuration    * @param feInfo FileEncryptionInfo    * @return CryptoCodec    * @throws IOException if no suitable CryptoCodec for the CipherSuite is    *                     available.    */
DECL|method|getCryptoCodec (Configuration conf, FileEncryptionInfo feInfo)
specifier|private
specifier|static
name|CryptoCodec
name|getCryptoCodec
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileEncryptionInfo
name|feInfo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|CipherSuite
name|suite
init|=
name|feInfo
operator|.
name|getCipherSuite
argument_list|()
decl_stmt|;
if|if
condition|(
name|suite
operator|.
name|equals
argument_list|(
name|CipherSuite
operator|.
name|UNKNOWN
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NameNode specified unknown CipherSuite with ID "
operator|+
name|suite
operator|.
name|getUnknownValue
argument_list|()
operator|+
literal|", cannot instantiate CryptoCodec."
argument_list|)
throw|;
block|}
specifier|final
name|CryptoCodec
name|codec
init|=
name|CryptoCodec
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
name|suite
argument_list|)
decl_stmt|;
if|if
condition|(
name|codec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownCipherSuiteException
argument_list|(
literal|"No configuration found for the cipher suite "
operator|+
name|suite
operator|.
name|getConfigSuffix
argument_list|()
operator|+
literal|" prefixed with "
operator|+
name|HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_KEY_PREFIX
operator|+
literal|". Please see the example configuration "
operator|+
literal|"hadoop.security.crypto.codec.classes.EXAMPLECIPHERSUITE "
operator|+
literal|"at core-default.xml for details."
argument_list|)
throw|;
block|}
return|return
name|codec
return|;
block|}
comment|/**    * Wraps the stream in a CryptoInputStream if the underlying file is    * encrypted.    */
DECL|method|createWrappedInputStream (DFSInputStream dfsis)
specifier|public
name|HdfsDataInputStream
name|createWrappedInputStream
parameter_list|(
name|DFSInputStream
name|dfsis
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileEncryptionInfo
name|feInfo
init|=
name|dfsis
operator|.
name|getFileEncryptionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|feInfo
operator|!=
literal|null
condition|)
block|{
comment|// File is encrypted, wrap the stream in a crypto stream.
comment|// Currently only one version, so no special logic based on the version #
name|getCryptoProtocolVersion
argument_list|(
name|feInfo
argument_list|)
expr_stmt|;
specifier|final
name|CryptoCodec
name|codec
init|=
name|getCryptoCodec
argument_list|(
name|conf
argument_list|,
name|feInfo
argument_list|)
decl_stmt|;
specifier|final
name|KeyVersion
name|decrypted
init|=
name|decryptEncryptedDataEncryptionKey
argument_list|(
name|feInfo
argument_list|)
decl_stmt|;
specifier|final
name|CryptoInputStream
name|cryptoIn
init|=
operator|new
name|CryptoInputStream
argument_list|(
name|dfsis
argument_list|,
name|codec
argument_list|,
name|decrypted
operator|.
name|getMaterial
argument_list|()
argument_list|,
name|feInfo
operator|.
name|getIV
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|HdfsDataInputStream
argument_list|(
name|cryptoIn
argument_list|)
return|;
block|}
else|else
block|{
comment|// No FileEncryptionInfo so no encryption.
return|return
operator|new
name|HdfsDataInputStream
argument_list|(
name|dfsis
argument_list|)
return|;
block|}
block|}
comment|/**    * Wraps the stream in a CryptoOutputStream if the underlying file is    * encrypted.    */
DECL|method|createWrappedOutputStream (DFSOutputStream dfsos, FileSystem.Statistics statistics)
specifier|public
name|HdfsDataOutputStream
name|createWrappedOutputStream
parameter_list|(
name|DFSOutputStream
name|dfsos
parameter_list|,
name|FileSystem
operator|.
name|Statistics
name|statistics
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWrappedOutputStream
argument_list|(
name|dfsos
argument_list|,
name|statistics
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Wraps the stream in a CryptoOutputStream if the underlying file is    * encrypted.    */
DECL|method|createWrappedOutputStream (DFSOutputStream dfsos, FileSystem.Statistics statistics, long startPos)
specifier|public
name|HdfsDataOutputStream
name|createWrappedOutputStream
parameter_list|(
name|DFSOutputStream
name|dfsos
parameter_list|,
name|FileSystem
operator|.
name|Statistics
name|statistics
parameter_list|,
name|long
name|startPos
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileEncryptionInfo
name|feInfo
init|=
name|dfsos
operator|.
name|getFileEncryptionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|feInfo
operator|!=
literal|null
condition|)
block|{
comment|// File is encrypted, wrap the stream in a crypto stream.
comment|// Currently only one version, so no special logic based on the version #
name|getCryptoProtocolVersion
argument_list|(
name|feInfo
argument_list|)
expr_stmt|;
specifier|final
name|CryptoCodec
name|codec
init|=
name|getCryptoCodec
argument_list|(
name|conf
argument_list|,
name|feInfo
argument_list|)
decl_stmt|;
name|KeyVersion
name|decrypted
init|=
name|decryptEncryptedDataEncryptionKey
argument_list|(
name|feInfo
argument_list|)
decl_stmt|;
specifier|final
name|CryptoOutputStream
name|cryptoOut
init|=
operator|new
name|CryptoOutputStream
argument_list|(
name|dfsos
argument_list|,
name|codec
argument_list|,
name|decrypted
operator|.
name|getMaterial
argument_list|()
argument_list|,
name|feInfo
operator|.
name|getIV
argument_list|()
argument_list|,
name|startPos
argument_list|)
decl_stmt|;
return|return
operator|new
name|HdfsDataOutputStream
argument_list|(
name|cryptoOut
argument_list|,
name|statistics
argument_list|,
name|startPos
argument_list|)
return|;
block|}
else|else
block|{
comment|// No FileEncryptionInfo present so no encryption.
return|return
operator|new
name|HdfsDataOutputStream
argument_list|(
name|dfsos
argument_list|,
name|statistics
argument_list|,
name|startPos
argument_list|)
return|;
block|}
block|}
DECL|method|open (String src)
specifier|public
name|DFSInputStream
name|open
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|open
argument_list|(
name|src
argument_list|,
name|dfsClientConf
operator|.
name|getIoBufferSize
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Create an input stream that obtains a nodelist from the    * namenode, and then reads from all the right places.  Creates    * inner subclass of InputStream that does the right out-of-band    * work.    * @deprecated Use {@link #open(String, int, boolean)} instead.    */
annotation|@
name|Deprecated
DECL|method|open (String src, int buffersize, boolean verifyChecksum, FileSystem.Statistics stats)
specifier|public
name|DFSInputStream
name|open
parameter_list|(
name|String
name|src
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|boolean
name|verifyChecksum
parameter_list|,
name|FileSystem
operator|.
name|Statistics
name|stats
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|open
argument_list|(
name|src
argument_list|,
name|buffersize
argument_list|,
name|verifyChecksum
argument_list|)
return|;
block|}
comment|/**    * Create an input stream that obtains a nodelist from the    * namenode, and then reads from all the right places.  Creates    * inner subclass of InputStream that does the right out-of-band    * work.    */
DECL|method|open (String src, int buffersize, boolean verifyChecksum)
specifier|public
name|DFSInputStream
name|open
parameter_list|(
name|String
name|src
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|boolean
name|verifyChecksum
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
comment|//    Get block info from namenode
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"newDFSInputStream"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
operator|new
name|DFSInputStream
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|verifyChecksum
argument_list|)
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the namenode associated with this DFSClient object    * @return the namenode associated with this DFSClient object    */
DECL|method|getNamenode ()
specifier|public
name|ClientProtocol
name|getNamenode
parameter_list|()
block|{
return|return
name|namenode
return|;
block|}
comment|/**    * Call {@link #create(String, boolean, short, long, Progressable)} with    * default<code>replication</code> and<code>blockSize<code> and null<code>    * progress</code>.    */
DECL|method|create (String src, boolean overwrite)
specifier|public
name|OutputStream
name|create
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|src
argument_list|,
name|overwrite
argument_list|,
name|dfsClientConf
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|dfsClientConf
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Call {@link #create(String, boolean, short, long, Progressable)} with    * default<code>replication</code> and<code>blockSize<code>.    */
DECL|method|create (String src, boolean overwrite, Progressable progress)
specifier|public
name|OutputStream
name|create
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|src
argument_list|,
name|overwrite
argument_list|,
name|dfsClientConf
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|dfsClientConf
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**    * Call {@link #create(String, boolean, short, long, Progressable)} with    * null<code>progress</code>.    */
DECL|method|create (String src, boolean overwrite, short replication, long blockSize)
specifier|public
name|OutputStream
name|create
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|src
argument_list|,
name|overwrite
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Call {@link #create(String, boolean, short, long, Progressable, int)}    * with default bufferSize.    */
DECL|method|create (String src, boolean overwrite, short replication, long blockSize, Progressable progress)
specifier|public
name|OutputStream
name|create
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|src
argument_list|,
name|overwrite
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|dfsClientConf
operator|.
name|getIoBufferSize
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Call {@link #create(String, FsPermission, EnumSet, short, long,     * Progressable, int, ChecksumOpt)} with default<code>permission</code>    * {@link FsPermission#getFileDefault()}.    *     * @param src File name    * @param overwrite overwrite an existing file if true    * @param replication replication factor for the file    * @param blockSize maximum block size    * @param progress interface for reporting client progress    * @param buffersize underlying buffersize    *     * @return output stream    */
DECL|method|create (String src, boolean overwrite, short replication, long blockSize, Progressable progress, int buffersize)
specifier|public
name|OutputStream
name|create
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|int
name|buffersize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|src
argument_list|,
name|FsPermission
operator|.
name|getFileDefault
argument_list|()
argument_list|,
name|overwrite
condition|?
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|,
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
else|:
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|buffersize
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Call {@link #create(String, FsPermission, EnumSet, boolean, short,     * long, Progressable, int, ChecksumOpt)} with<code>createParent</code>    *  set to true.    */
DECL|method|create (String src, FsPermission permission, EnumSet<CreateFlag> flag, short replication, long blockSize, Progressable progress, int buffersize, ChecksumOpt checksumOpt)
specifier|public
name|DFSOutputStream
name|create
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|ChecksumOpt
name|checksumOpt
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|src
argument_list|,
name|permission
argument_list|,
name|flag
argument_list|,
literal|true
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|buffersize
argument_list|,
name|checksumOpt
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Create a new dfs file with the specified block replication     * with write-progress reporting and return an output stream for writing    * into the file.      *     * @param src File name    * @param permission The permission of the directory being created.    *          If null, use default permission {@link FsPermission#getFileDefault()}    * @param flag indicates create a new file or create/overwrite an    *          existing file or append to an existing file    * @param createParent create missing parent directory if true    * @param replication block replication    * @param blockSize maximum block size    * @param progress interface for reporting client progress    * @param buffersize underlying buffer size     * @param checksumOpt checksum options    *     * @return output stream    *    * @see ClientProtocol#create for detailed description of exceptions thrown    */
DECL|method|create (String src, FsPermission permission, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize, Progressable progress, int buffersize, ChecksumOpt checksumOpt)
specifier|public
name|DFSOutputStream
name|create
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|ChecksumOpt
name|checksumOpt
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|src
argument_list|,
name|permission
argument_list|,
name|flag
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|buffersize
argument_list|,
name|checksumOpt
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|applyUMask (FsPermission permission)
specifier|private
name|FsPermission
name|applyUMask
parameter_list|(
name|FsPermission
name|permission
parameter_list|)
block|{
if|if
condition|(
name|permission
operator|==
literal|null
condition|)
block|{
name|permission
operator|=
name|FsPermission
operator|.
name|getFileDefault
argument_list|()
expr_stmt|;
block|}
return|return
name|permission
operator|.
name|applyUMask
argument_list|(
name|dfsClientConf
operator|.
name|getUMask
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Same as {@link #create(String, FsPermission, EnumSet, boolean, short, long,    * Progressable, int, ChecksumOpt)} with the addition of favoredNodes that is    * a hint to where the namenode should place the file blocks.    * The favored nodes hint is not persisted in HDFS. Hence it may be honored    * at the creation time only. HDFS could move the blocks during balancing or    * replication, to move the blocks from favored nodes. A value of null means    * no favored nodes for this create    */
DECL|method|create (String src, FsPermission permission, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize, Progressable progress, int buffersize, ChecksumOpt checksumOpt, InetSocketAddress[] favoredNodes)
specifier|public
name|DFSOutputStream
name|create
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|ChecksumOpt
name|checksumOpt
parameter_list|,
name|InetSocketAddress
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
specifier|final
name|FsPermission
name|masked
init|=
name|applyUMask
argument_list|(
name|permission
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|src
operator|+
literal|": masked="
operator|+
name|masked
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DFSOutputStream
name|result
init|=
name|DFSOutputStream
operator|.
name|newStreamForCreate
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|masked
argument_list|,
name|flag
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|buffersize
argument_list|,
name|dfsClientConf
operator|.
name|createChecksum
argument_list|(
name|checksumOpt
argument_list|)
argument_list|,
name|getFavoredNodesStr
argument_list|(
name|favoredNodes
argument_list|)
argument_list|)
decl_stmt|;
name|beginFileLease
argument_list|(
name|result
operator|.
name|getFileId
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|getFavoredNodesStr (InetSocketAddress[] favoredNodes)
specifier|private
name|String
index|[]
name|getFavoredNodesStr
parameter_list|(
name|InetSocketAddress
index|[]
name|favoredNodes
parameter_list|)
block|{
name|String
index|[]
name|favoredNodeStrs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|favoredNodes
operator|!=
literal|null
condition|)
block|{
name|favoredNodeStrs
operator|=
operator|new
name|String
index|[
name|favoredNodes
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|favoredNodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|favoredNodeStrs
index|[
name|i
index|]
operator|=
name|favoredNodes
index|[
name|i
index|]
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|favoredNodes
index|[
name|i
index|]
operator|.
name|getPort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|favoredNodeStrs
return|;
block|}
comment|/**    * Append to an existing file if {@link CreateFlag#APPEND} is present    */
DECL|method|primitiveAppend (String src, EnumSet<CreateFlag> flag, int buffersize, Progressable progress)
specifier|private
name|DFSOutputStream
name|primitiveAppend
parameter_list|(
name|String
name|src
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|APPEND
argument_list|)
condition|)
block|{
name|HdfsFileStatus
name|stat
init|=
name|getFileInfo
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
comment|// No file to append to
comment|// New file needs to be created if create option is present
if|if
condition|(
operator|!
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"failed to append to non-existent file "
operator|+
name|src
operator|+
literal|" on client "
operator|+
name|clientName
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
return|return
name|callAppend
argument_list|(
name|src
argument_list|,
name|buffersize
argument_list|,
name|flag
argument_list|,
name|progress
argument_list|,
literal|null
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Same as {{@link #create(String, FsPermission, EnumSet, short, long,    *  Progressable, int, ChecksumOpt)} except that the permission    *  is absolute (ie has already been masked with umask.    */
DECL|method|primitiveCreate (String src, FsPermission absPermission, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize, Progressable progress, int buffersize, ChecksumOpt checksumOpt)
specifier|public
name|DFSOutputStream
name|primitiveCreate
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|absPermission
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|ChecksumOpt
name|checksumOpt
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|CreateFlag
operator|.
name|validate
argument_list|(
name|flag
argument_list|)
expr_stmt|;
name|DFSOutputStream
name|result
init|=
name|primitiveAppend
argument_list|(
name|src
argument_list|,
name|flag
argument_list|,
name|buffersize
argument_list|,
name|progress
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|DataChecksum
name|checksum
init|=
name|dfsClientConf
operator|.
name|createChecksum
argument_list|(
name|checksumOpt
argument_list|)
decl_stmt|;
name|result
operator|=
name|DFSOutputStream
operator|.
name|newStreamForCreate
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|absPermission
argument_list|,
name|flag
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|buffersize
argument_list|,
name|checksum
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|beginFileLease
argument_list|(
name|result
operator|.
name|getFileId
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Creates a symbolic link.    *     * @see ClientProtocol#createSymlink(String, String,FsPermission, boolean)     */
DECL|method|createSymlink (String target, String link, boolean createParent)
specifier|public
name|void
name|createSymlink
parameter_list|(
name|String
name|target
parameter_list|,
name|String
name|link
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"createSymlink"
argument_list|,
name|target
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|FsPermission
name|dirPerm
init|=
name|applyUMask
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|namenode
operator|.
name|createSymlink
argument_list|(
name|target
argument_list|,
name|link
argument_list|,
name|dirPerm
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileAlreadyExistsException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|ParentNotDirectoryException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|DSQuotaExceededException
operator|.
name|class
argument_list|,
name|QuotaByStorageTypeExceededException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Resolve the *first* symlink, if any, in the path.    *     * @see ClientProtocol#getLinkTarget(String)    */
DECL|method|getLinkTarget (String path)
specifier|public
name|String
name|getLinkTarget
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getLinkTarget"
argument_list|,
name|path
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getLinkTarget
argument_list|(
name|path
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Method to get stream returned by append call */
DECL|method|callAppend (String src, int buffersize, EnumSet<CreateFlag> flag, Progressable progress, String[] favoredNodes)
specifier|private
name|DFSOutputStream
name|callAppend
parameter_list|(
name|String
name|src
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|String
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|CreateFlag
operator|.
name|validateForAppend
argument_list|(
name|flag
argument_list|)
expr_stmt|;
try|try
block|{
name|LastBlockWithStatus
name|blkWithStatus
init|=
name|namenode
operator|.
name|append
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
operator|new
name|EnumSetWritable
argument_list|<>
argument_list|(
name|flag
argument_list|,
name|CreateFlag
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|DFSOutputStream
operator|.
name|newStreamForAppend
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|flag
argument_list|,
name|buffersize
argument_list|,
name|progress
argument_list|,
name|blkWithStatus
operator|.
name|getLastBlock
argument_list|()
argument_list|,
name|blkWithStatus
operator|.
name|getFileStatus
argument_list|()
argument_list|,
name|dfsClientConf
operator|.
name|createChecksum
argument_list|(
literal|null
argument_list|)
argument_list|,
name|favoredNodes
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|DSQuotaExceededException
operator|.
name|class
argument_list|,
name|QuotaByStorageTypeExceededException
operator|.
name|class
argument_list|,
name|UnsupportedOperationException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
block|}
comment|/**    * Append to an existing HDFS file.      *     * @param src file name    * @param buffersize buffer size    * @param flag indicates whether to append data to a new block instead of    *             the last block    * @param progress for reporting write-progress; null is acceptable.    * @param statistics file system statistics; null is acceptable.    * @return an output stream for writing into the file    *     * @see ClientProtocol#append(String, String, EnumSetWritable)    */
DECL|method|append (final String src, final int buffersize, EnumSet<CreateFlag> flag, final Progressable progress, final FileSystem.Statistics statistics)
specifier|public
name|HdfsDataOutputStream
name|append
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|int
name|buffersize
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|,
specifier|final
name|FileSystem
operator|.
name|Statistics
name|statistics
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DFSOutputStream
name|out
init|=
name|append
argument_list|(
name|src
argument_list|,
name|buffersize
argument_list|,
name|flag
argument_list|,
literal|null
argument_list|,
name|progress
argument_list|)
decl_stmt|;
return|return
name|createWrappedOutputStream
argument_list|(
name|out
argument_list|,
name|statistics
argument_list|,
name|out
operator|.
name|getInitialLen
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Append to an existing HDFS file.    *     * @param src file name    * @param buffersize buffer size    * @param flag indicates whether to append data to a new block instead of the    *          last block    * @param progress for reporting write-progress; null is acceptable.    * @param statistics file system statistics; null is acceptable.    * @param favoredNodes FavoredNodes for new blocks    * @return an output stream for writing into the file    * @see ClientProtocol#append(String, String, EnumSetWritable)    */
DECL|method|append (final String src, final int buffersize, EnumSet<CreateFlag> flag, final Progressable progress, final FileSystem.Statistics statistics, final InetSocketAddress[] favoredNodes)
specifier|public
name|HdfsDataOutputStream
name|append
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|int
name|buffersize
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
specifier|final
name|Progressable
name|progress
parameter_list|,
specifier|final
name|FileSystem
operator|.
name|Statistics
name|statistics
parameter_list|,
specifier|final
name|InetSocketAddress
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DFSOutputStream
name|out
init|=
name|append
argument_list|(
name|src
argument_list|,
name|buffersize
argument_list|,
name|flag
argument_list|,
name|getFavoredNodesStr
argument_list|(
name|favoredNodes
argument_list|)
argument_list|,
name|progress
argument_list|)
decl_stmt|;
return|return
name|createWrappedOutputStream
argument_list|(
name|out
argument_list|,
name|statistics
argument_list|,
name|out
operator|.
name|getInitialLen
argument_list|()
argument_list|)
return|;
block|}
DECL|method|append (String src, int buffersize, EnumSet<CreateFlag> flag, String[] favoredNodes, Progressable progress)
specifier|private
name|DFSOutputStream
name|append
parameter_list|(
name|String
name|src
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|String
index|[]
name|favoredNodes
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
specifier|final
name|DFSOutputStream
name|result
init|=
name|callAppend
argument_list|(
name|src
argument_list|,
name|buffersize
argument_list|,
name|flag
argument_list|,
name|progress
argument_list|,
name|favoredNodes
argument_list|)
decl_stmt|;
name|beginFileLease
argument_list|(
name|result
operator|.
name|getFileId
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Set replication for an existing file.    * @param src file name    * @param replication replication to set the file to    *     * @see ClientProtocol#setReplication(String, short)    */
DECL|method|setReplication (String src, short replication)
specifier|public
name|boolean
name|setReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"setReplication"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|setReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|DSQuotaExceededException
operator|.
name|class
argument_list|,
name|QuotaByStorageTypeExceededException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Set storage policy for an existing file/directory    * @param src file/directory name    * @param policyName name of the storage policy    */
DECL|method|setStoragePolicy (String src, String policyName)
specifier|public
name|void
name|setStoragePolicy
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|policyName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"setStoragePolicy"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|setStoragePolicy
argument_list|(
name|src
argument_list|,
name|policyName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @return All the existing storage policies    */
DECL|method|getStoragePolicies ()
specifier|public
name|BlockStoragePolicy
index|[]
name|getStoragePolicies
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"getStoragePolicies"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getStoragePolicies
argument_list|()
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Rename file or directory.    * @see ClientProtocol#rename(String, String)    * @deprecated Use {@link #rename(String, String, Options.Rename...)} instead.    */
annotation|@
name|Deprecated
DECL|method|rename (String src, String dst)
specifier|public
name|boolean
name|rename
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getSrcDstTraceScope
argument_list|(
literal|"rename"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|rename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|DSQuotaExceededException
operator|.
name|class
argument_list|,
name|QuotaByStorageTypeExceededException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Move blocks from src to trg and delete src    * See {@link ClientProtocol#concat}.    */
DECL|method|concat (String trg, String [] srcs)
specifier|public
name|void
name|concat
parameter_list|(
name|String
name|trg
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"concat"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|concat
argument_list|(
name|trg
argument_list|,
name|srcs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Rename file or directory.    * @see ClientProtocol#rename2(String, String, Options.Rename...)    */
DECL|method|rename (String src, String dst, Options.Rename... options)
specifier|public
name|void
name|rename
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getSrcDstTraceScope
argument_list|(
literal|"rename2"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|rename2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|DSQuotaExceededException
operator|.
name|class
argument_list|,
name|QuotaByStorageTypeExceededException
operator|.
name|class
argument_list|,
name|FileAlreadyExistsException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|ParentNotDirectoryException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Truncate a file to an indicated size    * See {@link ClientProtocol#truncate}.    */
DECL|method|truncate (String src, long newLength)
specifier|public
name|boolean
name|truncate
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|newLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Cannot truncate to a negative file size: "
operator|+
name|newLength
operator|+
literal|"."
argument_list|)
throw|;
block|}
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"truncate"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|truncate
argument_list|(
name|src
argument_list|,
name|newLength
argument_list|,
name|clientName
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Delete file or directory.    * See {@link ClientProtocol#delete(String, boolean)}.     */
annotation|@
name|Deprecated
DECL|method|delete (String src)
specifier|public
name|boolean
name|delete
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
return|return
name|delete
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * delete file or directory.    * delete contents of the directory if non empty and recursive     * set to true    *    * @see ClientProtocol#delete(String, boolean)    */
DECL|method|delete (String src, boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"delete"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|delete
argument_list|(
name|src
argument_list|,
name|recursive
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Implemented using getFileInfo(src)    */
DECL|method|exists (String src)
specifier|public
name|boolean
name|exists
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
return|return
name|getFileInfo
argument_list|(
name|src
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Get a partial listing of the indicated directory    * No block locations need to be fetched    */
DECL|method|listPaths (String src, byte[] startAfter)
specifier|public
name|DirectoryListing
name|listPaths
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listPaths
argument_list|(
name|src
argument_list|,
name|startAfter
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Get a partial listing of the indicated directory    *    * Recommend to use HdfsFileStatus.EMPTY_NAME as startAfter    * if the application wants to fetch a listing starting from    * the first entry in the directory    *    * @see ClientProtocol#getListing(String, byte[], boolean)    */
DECL|method|listPaths (String src, byte[] startAfter, boolean needLocation)
specifier|public
name|DirectoryListing
name|listPaths
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"listPaths"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getListing
argument_list|(
name|src
argument_list|,
name|startAfter
argument_list|,
name|needLocation
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the file info for a specific file or directory.    * @param src The string representation of the path to the file    * @return object containing information regarding the file    *         or null if file not found    *             * @see ClientProtocol#getFileInfo(String) for description of exceptions    */
DECL|method|getFileInfo (String src)
specifier|public
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getFileInfo"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getFileInfo
argument_list|(
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Close status of a file    * @return true if file is already closed    */
DECL|method|isFileClosed (String src)
specifier|public
name|boolean
name|isFileClosed
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"isFileClosed"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|isFileClosed
argument_list|(
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the file info for a specific file or directory. If src    * refers to a symlink then the FileStatus of the link is returned.    * @param src path to a file or directory.    *     * For description of exceptions thrown     * @see ClientProtocol#getFileLinkInfo(String)    */
DECL|method|getFileLinkInfo (String src)
specifier|public
name|HdfsFileStatus
name|getFileLinkInfo
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getFileLinkInfo"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getFileLinkInfo
argument_list|(
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|clearDataEncryptionKey ()
specifier|public
name|void
name|clearDataEncryptionKey
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Clearing encryption key"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|encryptionKey
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * @return true if data sent between this client and DNs should be encrypted,    *         false otherwise.    * @throws IOException in the event of error communicating with the NN    */
DECL|method|shouldEncryptData ()
name|boolean
name|shouldEncryptData
parameter_list|()
throws|throws
name|IOException
block|{
name|FsServerDefaults
name|d
init|=
name|getServerDefaults
argument_list|()
decl_stmt|;
return|return
name|d
operator|==
literal|null
condition|?
literal|false
else|:
name|d
operator|.
name|getEncryptDataTransfer
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|newDataEncryptionKey ()
specifier|public
name|DataEncryptionKey
name|newDataEncryptionKey
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|shouldEncryptData
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|encryptionKey
operator|==
literal|null
operator|||
name|encryptionKey
operator|.
name|expiryDate
operator|<
name|Time
operator|.
name|now
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting new encryption token from NN"
argument_list|)
expr_stmt|;
name|encryptionKey
operator|=
name|namenode
operator|.
name|getDataEncryptionKey
argument_list|()
expr_stmt|;
block|}
return|return
name|encryptionKey
return|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get the checksum of the whole file of a range of the file. Note that the    * range always starts from the beginning of the file.    * @param src The file path    * @param length the length of the range, i.e., the range is [0, length]    * @return The checksum     * @see DistributedFileSystem#getFileChecksum(Path)    */
DECL|method|getFileChecksum (String src, long length)
specifier|public
name|MD5MD5CRC32FileChecksum
name|getFileChecksum
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|length
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|//get block locations for the file range
name|LocatedBlocks
name|blockLocations
init|=
name|callGetBlockLocations
argument_list|(
name|namenode
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|blockLocations
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|blockLocations
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Fail to get checksum, since file "
operator|+
name|src
operator|+
literal|" is under construction."
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|locatedblocks
init|=
name|blockLocations
operator|.
name|getLocatedBlocks
argument_list|()
decl_stmt|;
specifier|final
name|DataOutputBuffer
name|md5out
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
name|int
name|bytesPerCRC
init|=
operator|-
literal|1
decl_stmt|;
name|DataChecksum
operator|.
name|Type
name|crcType
init|=
name|DataChecksum
operator|.
name|Type
operator|.
name|DEFAULT
decl_stmt|;
name|long
name|crcPerBlock
init|=
literal|0
decl_stmt|;
name|boolean
name|refetchBlocks
init|=
literal|false
decl_stmt|;
name|int
name|lastRetriedIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|// get block checksum for each block
name|long
name|remaining
init|=
name|length
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|contains
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR_SEPARATOR
argument_list|)
condition|)
block|{
name|remaining
operator|=
name|Math
operator|.
name|min
argument_list|(
name|length
argument_list|,
name|blockLocations
operator|.
name|getFileLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
argument_list|<
name|locatedblocks
operator|.
name|size
operator|(
operator|)
operator|&&
name|remaining
argument_list|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|refetchBlocks
condition|)
block|{
comment|// refetch to get fresh tokens
name|blockLocations
operator|=
name|callGetBlockLocations
argument_list|(
name|namenode
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|blockLocations
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|blockLocations
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Fail to get checksum, since file "
operator|+
name|src
operator|+
literal|" is under construction."
argument_list|)
throw|;
block|}
name|locatedblocks
operator|=
name|blockLocations
operator|.
name|getLocatedBlocks
argument_list|()
expr_stmt|;
name|refetchBlocks
operator|=
literal|false
expr_stmt|;
block|}
name|LocatedBlock
name|lb
init|=
name|locatedblocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|ExtendedBlock
name|block
init|=
name|lb
operator|.
name|getBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|remaining
operator|<
name|block
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
name|block
operator|.
name|setNumBytes
argument_list|(
name|remaining
argument_list|)
expr_stmt|;
block|}
name|remaining
operator|-=
name|block
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
specifier|final
name|DatanodeInfo
index|[]
name|datanodes
init|=
name|lb
operator|.
name|getLocations
argument_list|()
decl_stmt|;
comment|//try each datanode location of the block
specifier|final
name|int
name|timeout
init|=
literal|3000
operator|*
name|datanodes
operator|.
name|length
operator|+
name|dfsClientConf
operator|.
name|getSocketTimeout
argument_list|()
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
operator|!
name|done
operator|&&
name|j
operator|<
name|datanodes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//connect to a datanode
name|IOStreamPair
name|pair
init|=
name|connectToDN
argument_list|(
name|datanodes
index|[
name|j
index|]
argument_list|,
name|timeout
argument_list|,
name|lb
argument_list|)
decl_stmt|;
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|pair
operator|.
name|out
argument_list|,
name|smallBufferSize
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
name|pair
operator|.
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"write to "
operator|+
name|datanodes
index|[
name|j
index|]
operator|+
literal|": "
operator|+
name|Op
operator|.
name|BLOCK_CHECKSUM
operator|+
literal|", block="
operator|+
name|block
argument_list|)
expr_stmt|;
block|}
comment|// get block MD5
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|blockChecksum
argument_list|(
name|block
argument_list|,
name|lb
operator|.
name|getBlockToken
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|BlockOpResponseProto
name|reply
init|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|PBHelper
operator|.
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|logInfo
init|=
literal|"for block "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|datanodes
index|[
name|j
index|]
decl_stmt|;
name|DataTransferProtoUtil
operator|.
name|checkBlockOpStatus
argument_list|(
name|reply
argument_list|,
name|logInfo
argument_list|)
expr_stmt|;
name|OpBlockChecksumResponseProto
name|checksumData
init|=
name|reply
operator|.
name|getChecksumResponse
argument_list|()
decl_stmt|;
comment|//read byte-per-checksum
specifier|final
name|int
name|bpc
init|=
name|checksumData
operator|.
name|getBytesPerCrc
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|//first block
name|bytesPerCRC
operator|=
name|bpc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bpc
operator|!=
name|bytesPerCRC
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Byte-per-checksum not matched: bpc="
operator|+
name|bpc
operator|+
literal|" but bytesPerCRC="
operator|+
name|bytesPerCRC
argument_list|)
throw|;
block|}
comment|//read crc-per-block
specifier|final
name|long
name|cpb
init|=
name|checksumData
operator|.
name|getCrcPerBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|locatedblocks
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|crcPerBlock
operator|=
name|cpb
expr_stmt|;
block|}
comment|//read md5
specifier|final
name|MD5Hash
name|md5
init|=
operator|new
name|MD5Hash
argument_list|(
name|checksumData
operator|.
name|getMd5
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|md5
operator|.
name|write
argument_list|(
name|md5out
argument_list|)
expr_stmt|;
comment|// read crc-type
specifier|final
name|DataChecksum
operator|.
name|Type
name|ct
decl_stmt|;
if|if
condition|(
name|checksumData
operator|.
name|hasCrcType
argument_list|()
condition|)
block|{
name|ct
operator|=
name|PBHelper
operator|.
name|convert
argument_list|(
name|checksumData
operator|.
name|getCrcType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Retrieving checksum from an earlier-version DataNode: "
operator|+
literal|"inferring checksum by reading first byte"
argument_list|)
expr_stmt|;
name|ct
operator|=
name|inferChecksumTypeByReading
argument_list|(
name|lb
argument_list|,
name|datanodes
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|// first block
name|crcType
operator|=
name|ct
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crcType
operator|!=
name|DataChecksum
operator|.
name|Type
operator|.
name|MIXED
operator|&&
name|crcType
operator|!=
name|ct
condition|)
block|{
comment|// if crc types are mixed in a file
name|crcType
operator|=
name|DataChecksum
operator|.
name|Type
operator|.
name|MIXED
expr_stmt|;
block|}
name|done
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"set bytesPerCRC="
operator|+
name|bytesPerCRC
operator|+
literal|", crcPerBlock="
operator|+
name|crcPerBlock
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"got reply from "
operator|+
name|datanodes
index|[
name|j
index|]
operator|+
literal|": md5="
operator|+
name|md5
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvalidBlockTokenException
name|ibte
parameter_list|)
block|{
if|if
condition|(
name|i
operator|>
name|lastRetriedIndex
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got access token error in response to OP_BLOCK_CHECKSUM "
operator|+
literal|"for file "
operator|+
name|src
operator|+
literal|" for block "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|datanodes
index|[
name|j
index|]
operator|+
literal|". Will retry the block once."
argument_list|)
expr_stmt|;
block|}
name|lastRetriedIndex
operator|=
name|i
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
comment|// actually it's not done; but we'll retry
name|i
operator|--
expr_stmt|;
comment|// repeat at i-th block
name|refetchBlocks
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"src="
operator|+
name|src
operator|+
literal|", datanodes["
operator|+
name|j
operator|+
literal|"]="
operator|+
name|datanodes
index|[
name|j
index|]
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Fail to get block MD5 for "
operator|+
name|block
argument_list|)
throw|;
block|}
block|}
comment|//compute file MD5
specifier|final
name|MD5Hash
name|fileMD5
init|=
name|MD5Hash
operator|.
name|digest
argument_list|(
name|md5out
operator|.
name|getData
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|crcType
condition|)
block|{
case|case
name|CRC32
case|:
return|return
operator|new
name|MD5MD5CRC32GzipFileChecksum
argument_list|(
name|bytesPerCRC
argument_list|,
name|crcPerBlock
argument_list|,
name|fileMD5
argument_list|)
return|;
case|case
name|CRC32C
case|:
return|return
operator|new
name|MD5MD5CRC32CastagnoliFileChecksum
argument_list|(
name|bytesPerCRC
argument_list|,
name|crcPerBlock
argument_list|,
name|fileMD5
argument_list|)
return|;
default|default:
comment|// If there is no block allocated for the file,
comment|// return one with the magic entry that matches what previous
comment|// hdfs versions return.
if|if
condition|(
name|locatedblocks
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|MD5MD5CRC32GzipFileChecksum
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|fileMD5
argument_list|)
return|;
block|}
comment|// we should never get here since the validity was checked
comment|// when getCrcType() was called above.
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Connect to the given datanode's datantrasfer port, and return    * the resulting IOStreamPair. This includes encryption wrapping, etc.    */
DECL|method|connectToDN (DatanodeInfo dn, int timeout, LocatedBlock lb)
specifier|private
name|IOStreamPair
name|connectToDN
parameter_list|(
name|DatanodeInfo
name|dn
parameter_list|,
name|int
name|timeout
parameter_list|,
name|LocatedBlock
name|lb
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|Socket
name|sock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|sock
operator|=
name|socketFactory
operator|.
name|createSocket
argument_list|()
expr_stmt|;
name|String
name|dnAddr
init|=
name|dn
operator|.
name|getXferAddr
argument_list|(
name|getConf
argument_list|()
operator|.
name|isConnectToDnViaHostname
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to datanode "
operator|+
name|dnAddr
argument_list|)
expr_stmt|;
block|}
name|NetUtils
operator|.
name|connect
argument_list|(
name|sock
argument_list|,
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|dnAddr
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|sock
operator|.
name|setSoTimeout
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|OutputStream
name|unbufOut
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|sock
argument_list|)
decl_stmt|;
name|InputStream
name|unbufIn
init|=
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|sock
argument_list|)
decl_stmt|;
name|IOStreamPair
name|ret
init|=
name|saslClient
operator|.
name|newSocketSend
argument_list|(
name|sock
argument_list|,
name|unbufOut
argument_list|,
name|unbufIn
argument_list|,
name|this
argument_list|,
name|lb
operator|.
name|getBlockToken
argument_list|()
argument_list|,
name|dn
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|ret
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Infer the checksum type for a replica by sending an OP_READ_BLOCK    * for the first byte of that replica. This is used for compatibility    * with older HDFS versions which did not include the checksum type in    * OpBlockChecksumResponseProto.    *    * @param lb the located block    * @param dn the connected datanode    * @return the inferred checksum type    * @throws IOException if an error occurs    */
DECL|method|inferChecksumTypeByReading (LocatedBlock lb, DatanodeInfo dn)
specifier|private
name|Type
name|inferChecksumTypeByReading
parameter_list|(
name|LocatedBlock
name|lb
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
throws|throws
name|IOException
block|{
name|IOStreamPair
name|pair
init|=
name|connectToDN
argument_list|(
name|dn
argument_list|,
name|dfsClientConf
operator|.
name|getSocketTimeout
argument_list|()
argument_list|,
name|lb
argument_list|)
decl_stmt|;
try|try
block|{
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|pair
operator|.
name|out
argument_list|,
name|smallBufferSize
argument_list|)
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|pair
operator|.
name|in
argument_list|)
decl_stmt|;
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|readBlock
argument_list|(
name|lb
operator|.
name|getBlock
argument_list|()
argument_list|,
name|lb
operator|.
name|getBlockToken
argument_list|()
argument_list|,
name|clientName
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
name|CachingStrategy
operator|.
name|newDefaultStrategy
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|BlockOpResponseProto
name|reply
init|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|PBHelper
operator|.
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|logInfo
init|=
literal|"trying to read "
operator|+
name|lb
operator|.
name|getBlock
argument_list|()
operator|+
literal|" from datanode "
operator|+
name|dn
decl_stmt|;
name|DataTransferProtoUtil
operator|.
name|checkBlockOpStatus
argument_list|(
name|reply
argument_list|,
name|logInfo
argument_list|)
expr_stmt|;
return|return
name|PBHelper
operator|.
name|convert
argument_list|(
name|reply
operator|.
name|getReadOpChecksumInfo
argument_list|()
operator|.
name|getChecksum
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|pair
operator|.
name|in
argument_list|,
name|pair
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set permissions to a file or directory.    * @param src path name.    * @param permission permission to set to    *     * @see ClientProtocol#setPermission(String, FsPermission)    */
DECL|method|setPermission (String src, FsPermission permission)
specifier|public
name|void
name|setPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"setPermission"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|setPermission
argument_list|(
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Set file or directory owner.    * @param src path name.    * @param username user id.    * @param groupname user group.    *     * @see ClientProtocol#setOwner(String, String, String)    */
DECL|method|setOwner (String src, String username, String groupname)
specifier|public
name|void
name|setOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"setOwner"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|setOwner
argument_list|(
name|src
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|callGetStats ()
specifier|private
name|long
index|[]
name|callGetStats
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"getStats"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getStats
argument_list|()
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @see ClientProtocol#getStats()    */
DECL|method|getDiskStatus ()
specifier|public
name|FsStatus
name|getDiskStatus
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|rawNums
index|[]
init|=
name|callGetStats
argument_list|()
decl_stmt|;
return|return
operator|new
name|FsStatus
argument_list|(
name|rawNums
index|[
literal|0
index|]
argument_list|,
name|rawNums
index|[
literal|1
index|]
argument_list|,
name|rawNums
index|[
literal|2
index|]
argument_list|)
return|;
block|}
comment|/**    * Returns count of blocks with no good replicas left. Normally should be     * zero.    * @throws IOException    */
DECL|method|getMissingBlocksCount ()
specifier|public
name|long
name|getMissingBlocksCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|callGetStats
argument_list|()
index|[
name|ClientProtocol
operator|.
name|GET_STATS_MISSING_BLOCKS_IDX
index|]
return|;
block|}
comment|/**    * Returns count of blocks with replication factor 1 and have    * lost the only replica.    * @throws IOException    */
DECL|method|getMissingReplOneBlocksCount ()
specifier|public
name|long
name|getMissingReplOneBlocksCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|callGetStats
argument_list|()
index|[
name|ClientProtocol
operator|.
name|GET_STATS_MISSING_REPL_ONE_BLOCKS_IDX
index|]
return|;
block|}
comment|/**    * Returns count of blocks with one of more replica missing.    * @throws IOException    */
DECL|method|getUnderReplicatedBlocksCount ()
specifier|public
name|long
name|getUnderReplicatedBlocksCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|callGetStats
argument_list|()
index|[
name|ClientProtocol
operator|.
name|GET_STATS_UNDER_REPLICATED_IDX
index|]
return|;
block|}
comment|/**    * Returns count of blocks with at least one replica marked corrupt.     * @throws IOException    */
DECL|method|getCorruptBlocksCount ()
specifier|public
name|long
name|getCorruptBlocksCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|callGetStats
argument_list|()
index|[
name|ClientProtocol
operator|.
name|GET_STATS_CORRUPT_BLOCKS_IDX
index|]
return|;
block|}
comment|/**    * @return a list in which each entry describes a corrupt file/block    * @throws IOException    */
DECL|method|listCorruptFileBlocks (String path, String cookie)
specifier|public
name|CorruptFileBlocks
name|listCorruptFileBlocks
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|cookie
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"listCorruptFileBlocks"
argument_list|,
name|path
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|listCorruptFileBlocks
argument_list|(
name|path
argument_list|,
name|cookie
argument_list|)
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|datanodeReport (DatanodeReportType type)
specifier|public
name|DatanodeInfo
index|[]
name|datanodeReport
parameter_list|(
name|DatanodeReportType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"datanodeReport"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getDatanodeReport
argument_list|(
name|type
argument_list|)
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getDatanodeStorageReport ( DatanodeReportType type)
specifier|public
name|DatanodeStorageReport
index|[]
name|getDatanodeStorageReport
parameter_list|(
name|DatanodeReportType
name|type
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"datanodeStorageReport"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getDatanodeStorageReport
argument_list|(
name|type
argument_list|)
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Enter, leave or get safe mode.    *     * @see ClientProtocol#setSafeMode(HdfsConstants.SafeModeAction,boolean)    */
DECL|method|setSafeMode (SafeModeAction action)
specifier|public
name|boolean
name|setSafeMode
parameter_list|(
name|SafeModeAction
name|action
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
return|return
name|setSafeMode
argument_list|(
name|action
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Enter, leave or get safe mode.    *     * @param action    *          One of SafeModeAction.GET, SafeModeAction.ENTER and    *          SafeModeActiob.LEAVE    * @param isChecked    *          If true, then check only active namenode's safemode status, else    *          check first namenode's status.    * @see ClientProtocol#setSafeMode(HdfsConstants.SafeModeAction, boolean)    */
DECL|method|setSafeMode (SafeModeAction action, boolean isChecked)
specifier|public
name|boolean
name|setSafeMode
parameter_list|(
name|SafeModeAction
name|action
parameter_list|,
name|boolean
name|isChecked
parameter_list|)
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"setSafeMode"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|setSafeMode
argument_list|(
name|action
argument_list|,
name|isChecked
argument_list|)
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create one snapshot.    *     * @param snapshotRoot The directory where the snapshot is to be taken    * @param snapshotName Name of the snapshot    * @return the snapshot path.    * @see ClientProtocol#createSnapshot(String, String)    */
DECL|method|createSnapshot (String snapshotRoot, String snapshotName)
specifier|public
name|String
name|createSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|,
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"createSnapshot"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|createSnapshot
argument_list|(
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Delete a snapshot of a snapshottable directory.    *     * @param snapshotRoot The snapshottable directory that the     *                    to-be-deleted snapshot belongs to    * @param snapshotName The name of the to-be-deleted snapshot    * @throws IOException    * @see ClientProtocol#deleteSnapshot(String, String)    */
DECL|method|deleteSnapshot (String snapshotRoot, String snapshotName)
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|,
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"deleteSnapshot"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|deleteSnapshot
argument_list|(
name|snapshotRoot
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Rename a snapshot.    * @param snapshotDir The directory path where the snapshot was taken    * @param snapshotOldName Old name of the snapshot    * @param snapshotNewName New name of the snapshot    * @throws IOException    * @see ClientProtocol#renameSnapshot(String, String, String)    */
DECL|method|renameSnapshot (String snapshotDir, String snapshotOldName, String snapshotNewName)
specifier|public
name|void
name|renameSnapshot
parameter_list|(
name|String
name|snapshotDir
parameter_list|,
name|String
name|snapshotOldName
parameter_list|,
name|String
name|snapshotNewName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"renameSnapshot"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|renameSnapshot
argument_list|(
name|snapshotDir
argument_list|,
name|snapshotOldName
argument_list|,
name|snapshotNewName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get all the current snapshottable directories.    * @return All the current snapshottable directories    * @throws IOException    * @see ClientProtocol#getSnapshottableDirListing()    */
DECL|method|getSnapshottableDirListing ()
specifier|public
name|SnapshottableDirectoryStatus
index|[]
name|getSnapshottableDirListing
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"getSnapshottableDirListing"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getSnapshottableDirListing
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Allow snapshot on a directory.    *     * @see ClientProtocol#allowSnapshot(String snapshotRoot)    */
DECL|method|allowSnapshot (String snapshotRoot)
specifier|public
name|void
name|allowSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"allowSnapshot"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|allowSnapshot
argument_list|(
name|snapshotRoot
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Disallow snapshot on a directory.    *     * @see ClientProtocol#disallowSnapshot(String snapshotRoot)    */
DECL|method|disallowSnapshot (String snapshotRoot)
specifier|public
name|void
name|disallowSnapshot
parameter_list|(
name|String
name|snapshotRoot
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"disallowSnapshot"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|disallowSnapshot
argument_list|(
name|snapshotRoot
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the difference between two snapshots, or between a snapshot and the    * current tree of a directory.    * @see ClientProtocol#getSnapshotDiffReport(String, String, String)    */
DECL|method|getSnapshotDiffReport (String snapshotDir, String fromSnapshot, String toSnapshot)
specifier|public
name|SnapshotDiffReport
name|getSnapshotDiffReport
parameter_list|(
name|String
name|snapshotDir
parameter_list|,
name|String
name|fromSnapshot
parameter_list|,
name|String
name|toSnapshot
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"getSnapshotDiffReport"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getSnapshotDiffReport
argument_list|(
name|snapshotDir
argument_list|,
name|fromSnapshot
argument_list|,
name|toSnapshot
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addCacheDirective ( CacheDirectiveInfo info, EnumSet<CacheFlag> flags)
specifier|public
name|long
name|addCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|info
parameter_list|,
name|EnumSet
argument_list|<
name|CacheFlag
argument_list|>
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"addCacheDirective"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|addCacheDirective
argument_list|(
name|info
argument_list|,
name|flags
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|modifyCacheDirective ( CacheDirectiveInfo info, EnumSet<CacheFlag> flags)
specifier|public
name|void
name|modifyCacheDirective
parameter_list|(
name|CacheDirectiveInfo
name|info
parameter_list|,
name|EnumSet
argument_list|<
name|CacheFlag
argument_list|>
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"modifyCacheDirective"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|modifyCacheDirective
argument_list|(
name|info
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeCacheDirective (long id)
specifier|public
name|void
name|removeCacheDirective
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"removeCacheDirective"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|removeCacheDirective
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|listCacheDirectives ( CacheDirectiveInfo filter)
specifier|public
name|RemoteIterator
argument_list|<
name|CacheDirectiveEntry
argument_list|>
name|listCacheDirectives
parameter_list|(
name|CacheDirectiveInfo
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
return|return
operator|new
name|CacheDirectiveIterator
argument_list|(
name|namenode
argument_list|,
name|filter
argument_list|,
name|traceSampler
argument_list|)
return|;
block|}
DECL|method|addCachePool (CachePoolInfo info)
specifier|public
name|void
name|addCachePool
parameter_list|(
name|CachePoolInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"addCachePool"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|addCachePool
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|modifyCachePool (CachePoolInfo info)
specifier|public
name|void
name|modifyCachePool
parameter_list|(
name|CachePoolInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"modifyCachePool"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|modifyCachePool
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeCachePool (String poolName)
specifier|public
name|void
name|removeCachePool
parameter_list|(
name|String
name|poolName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"removeCachePool"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|removeCachePool
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|listCachePools ()
specifier|public
name|RemoteIterator
argument_list|<
name|CachePoolEntry
argument_list|>
name|listCachePools
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
return|return
operator|new
name|CachePoolIterator
argument_list|(
name|namenode
argument_list|,
name|traceSampler
argument_list|)
return|;
block|}
comment|/**    * Save namespace image.    *     * @see ClientProtocol#saveNamespace(long, long)    */
DECL|method|saveNamespace (long timeWindow, long txGap)
name|boolean
name|saveNamespace
parameter_list|(
name|long
name|timeWindow
parameter_list|,
name|long
name|txGap
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"saveNamespace"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|saveNamespace
argument_list|(
name|timeWindow
argument_list|,
name|txGap
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Rolls the edit log on the active NameNode.    * @return the txid of the new log segment     *    * @see ClientProtocol#rollEdits()    */
DECL|method|rollEdits ()
name|long
name|rollEdits
parameter_list|()
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"rollEdits"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|rollEdits
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getPreviousBlock (long fileId)
name|ExtendedBlock
name|getPreviousBlock
parameter_list|(
name|long
name|fileId
parameter_list|)
block|{
return|return
name|filesBeingWritten
operator|.
name|get
argument_list|(
name|fileId
argument_list|)
operator|.
name|getBlock
argument_list|()
return|;
block|}
comment|/**    * enable/disable restore failed storage.    *     * @see ClientProtocol#restoreFailedStorage(String arg)    */
DECL|method|restoreFailedStorage (String arg)
name|boolean
name|restoreFailedStorage
parameter_list|(
name|String
name|arg
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"restoreFailedStorage"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|restoreFailedStorage
argument_list|(
name|arg
argument_list|)
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Refresh the hosts and exclude files.  (Rereads them.)    * See {@link ClientProtocol#refreshNodes()}     * for more details.    *     * @see ClientProtocol#refreshNodes()    */
DECL|method|refreshNodes ()
specifier|public
name|void
name|refreshNodes
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"refreshNodes"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|refreshNodes
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Dumps DFS data structures into specified file.    *     * @see ClientProtocol#metaSave(String)    */
DECL|method|metaSave (String pathname)
specifier|public
name|void
name|metaSave
parameter_list|(
name|String
name|pathname
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"metaSave"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|metaSave
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Requests the namenode to tell all datanodes to use a new, non-persistent    * bandwidth value for dfs.balance.bandwidthPerSec.    * See {@link ClientProtocol#setBalancerBandwidth(long)}     * for more details.    *     * @see ClientProtocol#setBalancerBandwidth(long)    */
DECL|method|setBalancerBandwidth (long bandwidth)
specifier|public
name|void
name|setBalancerBandwidth
parameter_list|(
name|long
name|bandwidth
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"setBalancerBandwidth"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|setBalancerBandwidth
argument_list|(
name|bandwidth
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @see ClientProtocol#finalizeUpgrade()    */
DECL|method|finalizeUpgrade ()
specifier|public
name|void
name|finalizeUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"finalizeUpgrade"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|finalizeUpgrade
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|rollingUpgrade (RollingUpgradeAction action)
name|RollingUpgradeInfo
name|rollingUpgrade
parameter_list|(
name|RollingUpgradeAction
name|action
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"rollingUpgrade"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|rollingUpgrade
argument_list|(
name|action
argument_list|)
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    */
annotation|@
name|Deprecated
DECL|method|mkdirs (String src)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|mkdirs
argument_list|(
name|src
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Create a directory (or hierarchy of directories) with the given    * name and permission.    *    * @param src The path of the directory being created    * @param permission The permission of the directory being created.    * If permission == null, use {@link FsPermission#getDefault()}.    * @param createParent create missing parent directory if true    *     * @return True if the operation success.    *     * @see ClientProtocol#mkdirs(String, FsPermission, boolean)    */
DECL|method|mkdirs (String src, FsPermission permission, boolean createParent)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FsPermission
name|masked
init|=
name|applyUMask
argument_list|(
name|permission
argument_list|)
decl_stmt|;
return|return
name|primitiveMkdir
argument_list|(
name|src
argument_list|,
name|masked
argument_list|,
name|createParent
argument_list|)
return|;
block|}
comment|/**    * Same {{@link #mkdirs(String, FsPermission, boolean)} except    * that the permissions has already been masked against umask.    */
DECL|method|primitiveMkdir (String src, FsPermission absPermission)
specifier|public
name|boolean
name|primitiveMkdir
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|absPermission
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|primitiveMkdir
argument_list|(
name|src
argument_list|,
name|absPermission
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Same {{@link #mkdirs(String, FsPermission, boolean)} except    * that the permissions has already been masked against umask.    */
DECL|method|primitiveMkdir (String src, FsPermission absPermission, boolean createParent)
specifier|public
name|boolean
name|primitiveMkdir
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|absPermission
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|absPermission
operator|==
literal|null
condition|)
block|{
name|absPermission
operator|=
name|applyUMask
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|src
operator|+
literal|": masked="
operator|+
name|absPermission
argument_list|)
expr_stmt|;
block|}
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"mkdir"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|mkdirs
argument_list|(
name|src
argument_list|,
name|absPermission
argument_list|,
name|createParent
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|InvalidPathException
operator|.
name|class
argument_list|,
name|FileAlreadyExistsException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|ParentNotDirectoryException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|DSQuotaExceededException
operator|.
name|class
argument_list|,
name|QuotaByStorageTypeExceededException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get {@link ContentSummary} rooted at the specified directory.    * @param src The string representation of the path    *     * @see ClientProtocol#getContentSummary(String)    */
DECL|method|getContentSummary (String src)
name|ContentSummary
name|getContentSummary
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getContentSummary"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getContentSummary
argument_list|(
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Sets or resets quotas for a directory.    * @see ClientProtocol#setQuota(String, long, long, StorageType)    */
DECL|method|setQuota (String src, long namespaceQuota, long storagespaceQuota)
name|void
name|setQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|namespaceQuota
parameter_list|,
name|long
name|storagespaceQuota
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
comment|// sanity check
if|if
condition|(
operator|(
name|namespaceQuota
operator|<=
literal|0
operator|&&
name|namespaceQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
operator|&&
name|namespaceQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_RESET
operator|)
operator|||
operator|(
name|storagespaceQuota
operator|<=
literal|0
operator|&&
name|storagespaceQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
operator|&&
name|storagespaceQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_RESET
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid values for quota : "
operator|+
name|namespaceQuota
operator|+
literal|" and "
operator|+
name|storagespaceQuota
argument_list|)
throw|;
block|}
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"setQuota"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Pass null as storage type for traditional namespace/storagespace quota.
name|namenode
operator|.
name|setQuota
argument_list|(
name|src
argument_list|,
name|namespaceQuota
argument_list|,
name|storagespaceQuota
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|DSQuotaExceededException
operator|.
name|class
argument_list|,
name|QuotaByStorageTypeExceededException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Sets or resets quotas by storage type for a directory.    * @see ClientProtocol#setQuota(String, long, long, StorageType)    */
DECL|method|setQuotaByStorageType (String src, StorageType type, long quota)
name|void
name|setQuotaByStorageType
parameter_list|(
name|String
name|src
parameter_list|,
name|StorageType
name|type
parameter_list|,
name|long
name|quota
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|quota
operator|<=
literal|0
operator|&&
name|quota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
operator|&&
name|quota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_RESET
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid values for quota :"
operator|+
name|quota
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid storage type(null)"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|type
operator|.
name|supportTypeQuota
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Don't support Quota for storage type : "
operator|+
name|type
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"setQuotaByStorageType"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|setQuota
argument_list|(
name|src
argument_list|,
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
argument_list|,
name|quota
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|QuotaByStorageTypeExceededException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * set the modification and access time of a file    *     * @see ClientProtocol#setTimes(String, long, long)    */
DECL|method|setTimes (String src, long mtime, long atime)
specifier|public
name|void
name|setTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"setTimes"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|setTimes
argument_list|(
name|src
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @deprecated use {@link HdfsDataInputStream} instead.    */
annotation|@
name|Deprecated
DECL|class|DFSDataInputStream
specifier|public
specifier|static
class|class
name|DFSDataInputStream
extends|extends
name|HdfsDataInputStream
block|{
DECL|method|DFSDataInputStream (DFSInputStream in)
specifier|public
name|DFSDataInputStream
parameter_list|(
name|DFSInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|reportChecksumFailure (String file, ExtendedBlock blk, DatanodeInfo dn)
name|void
name|reportChecksumFailure
parameter_list|(
name|String
name|file
parameter_list|,
name|ExtendedBlock
name|blk
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
block|{
name|DatanodeInfo
index|[]
name|dnArr
init|=
block|{
name|dn
block|}
decl_stmt|;
name|LocatedBlock
index|[]
name|lblocks
init|=
block|{
operator|new
name|LocatedBlock
argument_list|(
name|blk
argument_list|,
name|dnArr
argument_list|)
block|}
decl_stmt|;
name|reportChecksumFailure
argument_list|(
name|file
argument_list|,
name|lblocks
argument_list|)
expr_stmt|;
block|}
comment|// just reports checksum failure and ignores any exception during the report.
DECL|method|reportChecksumFailure (String file, LocatedBlock lblocks[])
name|void
name|reportChecksumFailure
parameter_list|(
name|String
name|file
parameter_list|,
name|LocatedBlock
name|lblocks
index|[]
parameter_list|)
block|{
try|try
block|{
name|reportBadBlocks
argument_list|(
name|lblocks
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found corruption while reading "
operator|+
name|file
operator|+
literal|". Error repairing corrupt blocks. Bad blocks remain."
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"[clientName="
operator|+
name|clientName
operator|+
literal|", ugi="
operator|+
name|ugi
operator|+
literal|"]"
return|;
block|}
DECL|method|getDefaultReadCachingStrategy ()
specifier|public
name|CachingStrategy
name|getDefaultReadCachingStrategy
parameter_list|()
block|{
return|return
name|defaultReadCachingStrategy
return|;
block|}
DECL|method|getDefaultWriteCachingStrategy ()
specifier|public
name|CachingStrategy
name|getDefaultWriteCachingStrategy
parameter_list|()
block|{
return|return
name|defaultWriteCachingStrategy
return|;
block|}
DECL|method|getClientContext ()
specifier|public
name|ClientContext
name|getClientContext
parameter_list|()
block|{
return|return
name|clientContext
return|;
block|}
DECL|method|modifyAclEntries (String src, List<AclEntry> aclSpec)
specifier|public
name|void
name|modifyAclEntries
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"modifyAclEntries"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|modifyAclEntries
argument_list|(
name|src
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|AclException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeAclEntries (String src, List<AclEntry> aclSpec)
specifier|public
name|void
name|removeAclEntries
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"removeAclEntries"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|removeAclEntries
argument_list|(
name|src
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|AclException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeDefaultAcl (String src)
specifier|public
name|void
name|removeDefaultAcl
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"removeDefaultAcl"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|removeDefaultAcl
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|AclException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeAcl (String src)
specifier|public
name|void
name|removeAcl
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"removeAcl"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|removeAcl
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|AclException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setAcl (String src, List<AclEntry> aclSpec)
specifier|public
name|void
name|setAcl
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"setAcl"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|setAcl
argument_list|(
name|src
argument_list|,
name|aclSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|AclException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getAclStatus (String src)
specifier|public
name|AclStatus
name|getAclStatus
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getAclStatus"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getAclStatus
argument_list|(
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|AclException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createEncryptionZone (String src, String keyName)
specifier|public
name|void
name|createEncryptionZone
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|keyName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"createEncryptionZone"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|createEncryptionZone
argument_list|(
name|src
argument_list|,
name|keyName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getEZForPath (String src)
specifier|public
name|EncryptionZone
name|getEZForPath
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getEZForPath"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getEZForPath
argument_list|(
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|listEncryptionZones ()
specifier|public
name|RemoteIterator
argument_list|<
name|EncryptionZone
argument_list|>
name|listEncryptionZones
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
return|return
operator|new
name|EncryptionZoneIterator
argument_list|(
name|namenode
argument_list|,
name|traceSampler
argument_list|)
return|;
block|}
DECL|method|createErasureCodingZone (String src, ECSchema schema)
specifier|public
name|void
name|createErasureCodingZone
parameter_list|(
name|String
name|src
parameter_list|,
name|ECSchema
name|schema
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"createErasureCodingZone"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|createErasureCodingZone
argument_list|(
name|src
argument_list|,
name|schema
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setXAttr (String src, String name, byte[] value, EnumSet<XAttrSetFlag> flag)
specifier|public
name|void
name|setXAttr
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|name
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|EnumSet
argument_list|<
name|XAttrSetFlag
argument_list|>
name|flag
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"setXAttr"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|setXAttr
argument_list|(
name|src
argument_list|,
name|XAttrHelper
operator|.
name|buildXAttr
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getXAttr (String src, String name)
specifier|public
name|byte
index|[]
name|getXAttr
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getXAttr"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
init|=
name|XAttrHelper
operator|.
name|buildXAttrAsList
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|result
init|=
name|namenode
operator|.
name|getXAttrs
argument_list|(
name|src
argument_list|,
name|xAttrs
argument_list|)
decl_stmt|;
return|return
name|XAttrHelper
operator|.
name|getFirstXAttrValue
argument_list|(
name|result
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getXAttrs (String src)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|getXAttrs
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getXAttrs"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|XAttrHelper
operator|.
name|buildXAttrMap
argument_list|(
name|namenode
operator|.
name|getXAttrs
argument_list|(
name|src
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getXAttrs (String src, List<String> names)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|getXAttrs
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getXAttrs"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|XAttrHelper
operator|.
name|buildXAttrMap
argument_list|(
name|namenode
operator|.
name|getXAttrs
argument_list|(
name|src
argument_list|,
name|XAttrHelper
operator|.
name|buildXAttrs
argument_list|(
name|names
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|listXAttrs (String src)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|listXAttrs
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"listXAttrs"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|xattrs
init|=
name|XAttrHelper
operator|.
name|buildXAttrMap
argument_list|(
name|namenode
operator|.
name|listXAttrs
argument_list|(
name|src
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|xattrs
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeXAttr (String src, String name)
specifier|public
name|void
name|removeXAttr
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"removeXAttr"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|removeXAttr
argument_list|(
name|src
argument_list|,
name|XAttrHelper
operator|.
name|buildXAttr
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|checkAccess (String src, FsAction mode)
specifier|public
name|void
name|checkAccess
parameter_list|(
name|String
name|src
parameter_list|,
name|FsAction
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"checkAccess"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|namenode
operator|.
name|checkAccess
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getErasureCodingInfo (String src)
specifier|public
name|ECInfo
name|getErasureCodingInfo
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|getPathTraceScope
argument_list|(
literal|"getErasureCodingInfo"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getErasureCodingInfo
argument_list|(
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getECSchemas ()
specifier|public
name|ECSchema
index|[]
name|getECSchemas
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"getECSchemas"
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getECSchemas
argument_list|()
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getInotifyEventStream ()
specifier|public
name|DFSInotifyEventInputStream
name|getInotifyEventStream
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
return|return
operator|new
name|DFSInotifyEventInputStream
argument_list|(
name|traceSampler
argument_list|,
name|namenode
argument_list|)
return|;
block|}
DECL|method|getInotifyEventStream (long lastReadTxid)
specifier|public
name|DFSInotifyEventInputStream
name|getInotifyEventStream
parameter_list|(
name|long
name|lastReadTxid
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
return|return
operator|new
name|DFSInotifyEventInputStream
argument_list|(
name|traceSampler
argument_list|,
name|namenode
argument_list|,
name|lastReadTxid
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// RemotePeerFactory
DECL|method|newConnectedPeer (InetSocketAddress addr, Token<BlockTokenIdentifier> blockToken, DatanodeID datanodeId)
specifier|public
name|Peer
name|newConnectedPeer
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
parameter_list|,
name|DatanodeID
name|datanodeId
parameter_list|)
throws|throws
name|IOException
block|{
name|Peer
name|peer
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|Socket
name|sock
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|socketTimeout
init|=
name|dfsClientConf
operator|.
name|getSocketTimeout
argument_list|()
decl_stmt|;
try|try
block|{
name|sock
operator|=
name|socketFactory
operator|.
name|createSocket
argument_list|()
expr_stmt|;
name|NetUtils
operator|.
name|connect
argument_list|(
name|sock
argument_list|,
name|addr
argument_list|,
name|getRandomLocalInterfaceAddr
argument_list|()
argument_list|,
name|socketTimeout
argument_list|)
expr_stmt|;
name|peer
operator|=
name|TcpPeerServer
operator|.
name|peerFromSocketAndKey
argument_list|(
name|saslClient
argument_list|,
name|sock
argument_list|,
name|this
argument_list|,
name|blockToken
argument_list|,
name|datanodeId
argument_list|)
expr_stmt|;
name|peer
operator|.
name|setReadTimeout
argument_list|(
name|socketTimeout
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|peer
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Create hedged reads thread pool, HEDGED_READ_THREAD_POOL, if    * it does not already exist.    * @param num Number of threads for hedged reads thread pool.    * If zero, skip hedged reads thread pool creation.    */
DECL|method|initThreadsNumForHedgedReads (int num)
specifier|private
specifier|synchronized
name|void
name|initThreadsNumForHedgedReads
parameter_list|(
name|int
name|num
parameter_list|)
block|{
if|if
condition|(
name|num
operator|<=
literal|0
operator|||
name|HEDGED_READ_THREAD_POOL
operator|!=
literal|null
condition|)
return|return;
name|HEDGED_READ_THREAD_POOL
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|1
argument_list|,
name|num
argument_list|,
literal|60
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|Daemon
operator|.
name|DaemonFactory
argument_list|()
block|{
specifier|private
specifier|final
name|AtomicInteger
name|threadIndex
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|t
init|=
name|super
operator|.
name|newThread
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"hedgedRead-"
operator|+
name|threadIndex
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
argument_list|,
operator|new
name|ThreadPoolExecutor
operator|.
name|CallerRunsPolicy
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|rejectedExecution
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|ThreadPoolExecutor
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Execution rejected, Executing in current thread"
argument_list|)
expr_stmt|;
name|HEDGED_READ_METRIC
operator|.
name|incHedgedReadOpsInCurThread
argument_list|()
expr_stmt|;
comment|// will run in the current thread
name|super
operator|.
name|rejectedExecution
argument_list|(
name|runnable
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|HEDGED_READ_THREAD_POOL
operator|.
name|allowCoreThreadTimeOut
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using hedged reads; pool threads="
operator|+
name|num
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create thread pool for parallel reading in striped layout,    * STRIPED_READ_THREAD_POOL, if it does not already exist.    * @param num Number of threads for striped reads thread pool.    */
DECL|method|initThreadsNumForStripedReads (int num)
specifier|private
name|void
name|initThreadsNumForStripedReads
parameter_list|(
name|int
name|num
parameter_list|)
block|{
assert|assert
name|num
operator|>
literal|0
assert|;
if|if
condition|(
name|STRIPED_READ_THREAD_POOL
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|DFSClient
operator|.
name|class
init|)
block|{
if|if
condition|(
name|STRIPED_READ_THREAD_POOL
operator|==
literal|null
condition|)
block|{
name|STRIPED_READ_THREAD_POOL
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|1
argument_list|,
name|num
argument_list|,
literal|60
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|Daemon
operator|.
name|DaemonFactory
argument_list|()
block|{
specifier|private
specifier|final
name|AtomicInteger
name|threadIndex
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|t
init|=
name|super
operator|.
name|newThread
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"stripedRead-"
operator|+
name|threadIndex
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
argument_list|,
operator|new
name|ThreadPoolExecutor
operator|.
name|CallerRunsPolicy
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|rejectedExecution
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|ThreadPoolExecutor
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Execution for striped reading rejected, "
operator|+
literal|"Executing in current thread"
argument_list|)
expr_stmt|;
comment|// will run in the current thread
name|super
operator|.
name|rejectedExecution
argument_list|(
name|runnable
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|STRIPED_READ_THREAD_POOL
operator|.
name|allowCoreThreadTimeOut
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getHedgedReadsThreadPool ()
name|ThreadPoolExecutor
name|getHedgedReadsThreadPool
parameter_list|()
block|{
return|return
name|HEDGED_READ_THREAD_POOL
return|;
block|}
DECL|method|getStripedReadsThreadPool ()
name|ThreadPoolExecutor
name|getStripedReadsThreadPool
parameter_list|()
block|{
return|return
name|STRIPED_READ_THREAD_POOL
return|;
block|}
DECL|method|isHedgedReadsEnabled ()
name|boolean
name|isHedgedReadsEnabled
parameter_list|()
block|{
return|return
operator|(
name|HEDGED_READ_THREAD_POOL
operator|!=
literal|null
operator|)
operator|&&
name|HEDGED_READ_THREAD_POOL
operator|.
name|getMaximumPoolSize
argument_list|()
operator|>
literal|0
return|;
block|}
DECL|method|getHedgedReadMetrics ()
name|DFSHedgedReadMetrics
name|getHedgedReadMetrics
parameter_list|()
block|{
return|return
name|HEDGED_READ_METRIC
return|;
block|}
DECL|method|getKeyProvider ()
specifier|public
name|KeyProvider
name|getKeyProvider
parameter_list|()
block|{
return|return
name|clientContext
operator|.
name|getKeyProviderCache
argument_list|()
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setKeyProvider (KeyProvider provider)
specifier|public
name|void
name|setKeyProvider
parameter_list|(
name|KeyProvider
name|provider
parameter_list|)
block|{
try|try
block|{
name|clientContext
operator|.
name|getKeyProviderCache
argument_list|()
operator|.
name|setKeyProvider
argument_list|(
name|conf
argument_list|,
name|provider
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not set KeyProvider !!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Probe for encryption enabled on this filesystem.    * See {@link DFSUtil#isHDFSEncryptionEnabled(Configuration)}    * @return true if encryption is enabled    */
DECL|method|isHDFSEncryptionEnabled ()
specifier|public
name|boolean
name|isHDFSEncryptionEnabled
parameter_list|()
block|{
return|return
name|DFSUtil
operator|.
name|isHDFSEncryptionEnabled
argument_list|(
name|this
operator|.
name|conf
argument_list|)
return|;
block|}
comment|/**    * Returns the SaslDataTransferClient configured for this DFSClient.    *    * @return SaslDataTransferClient configured for this DFSClient    */
DECL|method|getSaslDataTransferClient ()
specifier|public
name|SaslDataTransferClient
name|getSaslDataTransferClient
parameter_list|()
block|{
return|return
name|saslClient
return|;
block|}
DECL|field|PATH
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|PATH
init|=
literal|"path"
operator|.
name|getBytes
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
decl_stmt|;
DECL|method|getPathTraceScope (String description, String path)
name|TraceScope
name|getPathTraceScope
parameter_list|(
name|String
name|description
parameter_list|,
name|String
name|path
parameter_list|)
block|{
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
name|description
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
name|Span
name|span
init|=
name|scope
operator|.
name|getSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|span
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|span
operator|.
name|addKVAnnotation
argument_list|(
name|PATH
argument_list|,
name|path
operator|.
name|getBytes
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|scope
return|;
block|}
DECL|field|SRC
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|SRC
init|=
literal|"src"
operator|.
name|getBytes
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|DST
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|DST
init|=
literal|"dst"
operator|.
name|getBytes
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
decl_stmt|;
DECL|method|getSrcDstTraceScope (String description, String src, String dst)
name|TraceScope
name|getSrcDstTraceScope
parameter_list|(
name|String
name|description
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
block|{
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
name|description
argument_list|,
name|traceSampler
argument_list|)
decl_stmt|;
name|Span
name|span
init|=
name|scope
operator|.
name|getSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|span
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
name|span
operator|.
name|addKVAnnotation
argument_list|(
name|SRC
argument_list|,
name|src
operator|.
name|getBytes
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|!=
literal|null
condition|)
block|{
name|span
operator|.
name|addKVAnnotation
argument_list|(
name|DST
argument_list|,
name|dst
operator|.
name|getBytes
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|scope
return|;
block|}
comment|/**    * Get the erasure coding zone information for the specified path    *     * @param src path to get the information for    * @return Returns the zone information if path is in EC Zone, null otherwise    * @throws IOException    */
DECL|method|getErasureCodingZoneInfo (String src)
specifier|public
name|ECZoneInfo
name|getErasureCodingZoneInfo
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|namenode
operator|.
name|getErasureCodingZoneInfo
argument_list|(
name|src
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|AccessControlException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

