begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.cblock.storage
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|storage
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|exception
operator|.
name|CBlockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|meta
operator|.
name|ContainerDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|meta
operator|.
name|VolumeDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|meta
operator|.
name|VolumeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|proto
operator|.
name|MountVolumeResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|util
operator|.
name|KeyUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|OzoneConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|protocol
operator|.
name|proto
operator|.
name|OzoneProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|scm
operator|.
name|client
operator|.
name|ScmClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|Pipeline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * This class maintains the key space of CBlock, more specifically, the  * volume to container mapping. The core data structure  * is a map from users to their volumes info, where volume info is a handler  * to a volume, containing information for IO on that volume and a storage  * client responsible for talking to the SCM.  */
end_comment

begin_class
DECL|class|StorageManager
specifier|public
class|class
name|StorageManager
block|{
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StorageManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|storageClient
specifier|private
specifier|final
name|ScmClient
name|storageClient
decl_stmt|;
DECL|field|numThreads
specifier|private
specifier|final
name|int
name|numThreads
decl_stmt|;
DECL|field|MAX_THREADS
specifier|private
specifier|static
specifier|final
name|int
name|MAX_THREADS
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
operator|*
literal|2
decl_stmt|;
DECL|field|MAX_QUEUE_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|MAX_QUEUE_CAPACITY
init|=
literal|1024
decl_stmt|;
comment|/**    * We will NOT have the situation where same kv pair getting    * processed, but it is possible to have multiple kv pair being    * processed at same time.    *    * So using just ConcurrentHashMap should be sufficient    *    * Again since currently same user accessing from multiple places    * is not allowed, no need to consider concurrency of volume map    * within one user    */
specifier|private
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|VolumeDescriptor
argument_list|>
argument_list|>
DECL|field|user2VolumeMap
name|user2VolumeMap
decl_stmt|;
comment|// size of an underlying container.
comment|// TODO : assuming all containers are of the same size
DECL|field|containerSizeB
specifier|private
name|long
name|containerSizeB
decl_stmt|;
DECL|method|StorageManager (ScmClient storageClient, OzoneConfiguration ozoneConfig)
specifier|public
name|StorageManager
parameter_list|(
name|ScmClient
name|storageClient
parameter_list|,
name|OzoneConfiguration
name|ozoneConfig
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|storageClient
operator|=
name|storageClient
expr_stmt|;
name|this
operator|.
name|user2VolumeMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|containerSizeB
operator|=
name|storageClient
operator|.
name|getContainerSize
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|numThreads
operator|=
name|ozoneConfig
operator|.
name|getInt
argument_list|(
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_MANAGER_POOL_SIZE
argument_list|,
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_MANAGER_POOL_SIZE_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * This call will put the volume into in-memory map.    *    * more specifically, make the volume discoverable on jSCSI server    * and keep it's reference in-memory for look up.    * @param userName the user name of the volume.    * @param volumeName the name of the volume,    * @param volume a {@link VolumeDescriptor} object encapsulating the    *               information about the volume.    */
DECL|method|makeVolumeReady (String userName, String volumeName, VolumeDescriptor volume)
specifier|private
name|void
name|makeVolumeReady
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
name|volumeName
parameter_list|,
name|VolumeDescriptor
name|volume
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|VolumeDescriptor
argument_list|>
name|userVolumes
decl_stmt|;
if|if
condition|(
name|user2VolumeMap
operator|.
name|containsKey
argument_list|(
name|userName
argument_list|)
condition|)
block|{
name|userVolumes
operator|=
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|userVolumes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|user2VolumeMap
operator|.
name|put
argument_list|(
name|userName
argument_list|,
name|userVolumes
argument_list|)
expr_stmt|;
block|}
name|userVolumes
operator|.
name|put
argument_list|(
name|volumeName
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called by CBlockManager to add volumes read from persistent store into    * memory, need to contact SCM to setup the reference to the containers given    * their id.    *    * Only for failover process where container meta info is read from    * persistent store, and containers themselves are alive.    *    * TODO : Currently, this method is not being called as failover process    * is not implemented yet.    *    * @param volumeDescriptor a {@link VolumeDescriptor} object encapsulating    *                         the information about a volume.    * @throws IOException when adding the volume failed. e.g. volume already    * exist, or no more container available.    */
DECL|method|addVolume (VolumeDescriptor volumeDescriptor)
specifier|public
specifier|synchronized
name|void
name|addVolume
parameter_list|(
name|VolumeDescriptor
name|volumeDescriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|userName
init|=
name|volumeDescriptor
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|String
name|volumeName
init|=
name|volumeDescriptor
operator|.
name|getVolumeName
argument_list|()
decl_stmt|;
name|LOGGER
operator|.
name|info
argument_list|(
literal|"addVolume:"
operator|+
name|userName
operator|+
literal|":"
operator|+
name|volumeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|user2VolumeMap
operator|.
name|containsKey
argument_list|(
name|userName
argument_list|)
operator|&&
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|containsKey
argument_list|(
name|volumeName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CBlockException
argument_list|(
literal|"Volume already exist for "
operator|+
name|userName
operator|+
literal|":"
operator|+
name|volumeName
argument_list|)
throw|;
block|}
comment|// the container ids are read from levelDB, setting up the
comment|// container handlers here.
name|String
index|[]
name|containerIds
init|=
name|volumeDescriptor
operator|.
name|getContainerIDs
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|containerId
range|:
name|containerIds
control|)
block|{
try|try
block|{
name|Pipeline
name|pipeline
init|=
name|storageClient
operator|.
name|getContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|ContainerDescriptor
name|containerDescriptor
init|=
operator|new
name|ContainerDescriptor
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|containerDescriptor
operator|.
name|setPipeline
argument_list|(
name|pipeline
argument_list|)
expr_stmt|;
name|volumeDescriptor
operator|.
name|addContainer
argument_list|(
name|containerDescriptor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Getting container failed! Container:{} error:{}"
argument_list|,
name|containerId
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|// now ready to put into in-memory map.
name|makeVolumeReady
argument_list|(
name|userName
argument_list|,
name|volumeName
argument_list|,
name|volumeDescriptor
argument_list|)
expr_stmt|;
block|}
DECL|class|CreateContainerTask
specifier|private
class|class
name|CreateContainerTask
implements|implements
name|Runnable
block|{
DECL|field|volume
specifier|private
specifier|final
name|VolumeDescriptor
name|volume
decl_stmt|;
DECL|field|containerIdx
specifier|private
specifier|final
name|int
name|containerIdx
decl_stmt|;
DECL|field|containerIds
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|String
argument_list|>
name|containerIds
decl_stmt|;
DECL|field|numFailed
specifier|private
specifier|final
name|AtomicInteger
name|numFailed
decl_stmt|;
DECL|method|CreateContainerTask (VolumeDescriptor volume, int containerIdx, ArrayList<String> containerIds, AtomicInteger numFailed)
name|CreateContainerTask
parameter_list|(
name|VolumeDescriptor
name|volume
parameter_list|,
name|int
name|containerIdx
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|containerIds
parameter_list|,
name|AtomicInteger
name|numFailed
parameter_list|)
block|{
name|this
operator|.
name|volume
operator|=
name|volume
expr_stmt|;
name|this
operator|.
name|containerIdx
operator|=
name|containerIdx
expr_stmt|;
name|this
operator|.
name|containerIds
operator|=
name|containerIds
expr_stmt|;
name|this
operator|.
name|numFailed
operator|=
name|numFailed
expr_stmt|;
block|}
comment|/**      * When an object implementing interface<code>Runnable</code> is used      * to create a thread, starting the thread causes the object's      *<code>run</code> method to be called in that separately executing      * thread.      *<p>      * The general contract of the method<code>run</code> is that it may      * take any action whatsoever.      *      * @see Thread#run()      */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|ContainerDescriptor
name|container
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Pipeline
name|pipeline
init|=
name|storageClient
operator|.
name|createContainer
argument_list|(
name|OzoneProtos
operator|.
name|ReplicationType
operator|.
name|STAND_ALONE
argument_list|,
name|OzoneProtos
operator|.
name|ReplicationFactor
operator|.
name|ONE
argument_list|,
name|KeyUtil
operator|.
name|getContainerName
argument_list|(
name|volume
operator|.
name|getUserName
argument_list|()
argument_list|,
name|volume
operator|.
name|getVolumeName
argument_list|()
argument_list|,
name|containerIdx
argument_list|)
argument_list|)
decl_stmt|;
name|container
operator|=
operator|new
name|ContainerDescriptor
argument_list|(
name|pipeline
operator|.
name|getContainerName
argument_list|()
argument_list|)
expr_stmt|;
name|container
operator|.
name|setPipeline
argument_list|(
name|pipeline
argument_list|)
expr_stmt|;
name|container
operator|.
name|setContainerIndex
argument_list|(
name|containerIdx
argument_list|)
expr_stmt|;
name|volume
operator|.
name|addContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
name|containerIds
operator|.
name|set
argument_list|(
name|containerIdx
argument_list|,
name|container
operator|.
name|getContainerID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|numFailed
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|container
operator|!=
literal|null
condition|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Error creating container Container:{}:"
operator|+
literal|" index:{} error:{}"
argument_list|,
name|container
operator|.
name|getContainerID
argument_list|()
argument_list|,
name|containerIdx
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|createVolumeContainers (VolumeDescriptor volume)
specifier|private
name|boolean
name|createVolumeContainers
parameter_list|(
name|VolumeDescriptor
name|volume
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|containerIds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ThreadPoolExecutor
name|executor
init|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|numThreads
argument_list|,
name|MAX_THREADS
argument_list|,
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|ArrayBlockingQueue
argument_list|<>
argument_list|(
name|MAX_QUEUE_CAPACITY
argument_list|)
argument_list|,
operator|new
name|ThreadPoolExecutor
operator|.
name|CallerRunsPolicy
argument_list|()
argument_list|)
decl_stmt|;
name|AtomicInteger
name|numFailedCreates
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|allocatedSize
init|=
literal|0
decl_stmt|;
name|int
name|containerIdx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|allocatedSize
operator|<
name|volume
operator|.
name|getVolumeSize
argument_list|()
condition|)
block|{
comment|// adding null to allocate space in ArrayList
name|containerIds
operator|.
name|add
argument_list|(
name|containerIdx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|Runnable
name|task
init|=
operator|new
name|CreateContainerTask
argument_list|(
name|volume
argument_list|,
name|containerIdx
argument_list|,
name|containerIds
argument_list|,
name|numFailedCreates
argument_list|)
decl_stmt|;
name|executor
operator|.
name|submit
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|allocatedSize
operator|+=
name|containerSizeB
expr_stmt|;
name|containerIdx
operator|+=
literal|1
expr_stmt|;
block|}
comment|// issue the command and then wait for it to finish
name|executor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
name|executor
operator|.
name|awaitTermination
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Error creating volume:{} error:{}"
argument_list|,
name|volume
operator|.
name|getVolumeName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|executor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|volume
operator|.
name|setContainerIDs
argument_list|(
name|containerIds
argument_list|)
expr_stmt|;
return|return
name|numFailedCreates
operator|.
name|get
argument_list|()
operator|==
literal|0
return|;
block|}
DECL|method|deleteContainer (String containerID, boolean force)
specifier|private
name|void
name|deleteContainer
parameter_list|(
name|String
name|containerID
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
try|try
block|{
name|Pipeline
name|pipeline
init|=
name|storageClient
operator|.
name|getContainer
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
name|storageClient
operator|.
name|deleteContainer
argument_list|(
name|pipeline
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Error deleting container Container:{} error:{}"
argument_list|,
name|containerID
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|deleteVolumeContainers (List<String> containers, boolean force)
specifier|private
name|void
name|deleteVolumeContainers
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|containers
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|CBlockException
block|{
name|ThreadPoolExecutor
name|executor
init|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|numThreads
argument_list|,
name|MAX_THREADS
argument_list|,
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|ArrayBlockingQueue
argument_list|<>
argument_list|(
name|MAX_QUEUE_CAPACITY
argument_list|)
argument_list|,
operator|new
name|ThreadPoolExecutor
operator|.
name|CallerRunsPolicy
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|deleteContainer
range|:
name|containers
control|)
block|{
if|if
condition|(
name|deleteContainer
operator|!=
literal|null
condition|)
block|{
name|Runnable
name|task
init|=
parameter_list|()
lambda|->
name|deleteContainer
argument_list|(
name|deleteContainer
argument_list|,
name|force
argument_list|)
decl_stmt|;
name|executor
operator|.
name|submit
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
comment|// issue the command and then wait for it to finish
name|executor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
name|executor
operator|.
name|awaitTermination
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|error
argument_list|(
literal|"Error deleting containers error:{}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|executor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Called by CBlock server when creating a fresh volume. The core    * logic is adding needed information into in-memory meta data.    *    * @param userName the user name of the volume.    * @param volumeName the name of the volume.    * @param volumeSize the size of the volume.    * @param blockSize the block size of the volume.    * @throws CBlockException when the volume can not be created.    */
DECL|method|createVolume (String userName, String volumeName, long volumeSize, int blockSize)
specifier|public
specifier|synchronized
name|void
name|createVolume
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
name|volumeName
parameter_list|,
name|long
name|volumeSize
parameter_list|,
name|int
name|blockSize
parameter_list|)
throws|throws
name|CBlockException
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"createVolume:"
operator|+
name|userName
operator|+
literal|":"
operator|+
name|volumeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|user2VolumeMap
operator|.
name|containsKey
argument_list|(
name|userName
argument_list|)
operator|&&
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|containsKey
argument_list|(
name|volumeName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CBlockException
argument_list|(
literal|"Volume already exist for "
operator|+
name|userName
operator|+
literal|":"
operator|+
name|volumeName
argument_list|)
throw|;
block|}
if|if
condition|(
name|volumeSize
operator|<
name|blockSize
condition|)
block|{
throw|throw
operator|new
name|CBlockException
argument_list|(
literal|"Volume size smaller than block size? "
operator|+
literal|"volume size:"
operator|+
name|volumeSize
operator|+
literal|" block size:"
operator|+
name|blockSize
argument_list|)
throw|;
block|}
name|VolumeDescriptor
name|volume
init|=
operator|new
name|VolumeDescriptor
argument_list|(
name|userName
argument_list|,
name|volumeName
argument_list|,
name|volumeSize
argument_list|,
name|blockSize
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
name|createVolumeContainers
argument_list|(
name|volume
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// cleanup the containers and throw the exception
name|deleteVolumeContainers
argument_list|(
name|volume
operator|.
name|getContainerIDsList
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CBlockException
argument_list|(
literal|"Error when creating volume:"
operator|+
name|volumeName
argument_list|)
throw|;
block|}
name|makeVolumeReady
argument_list|(
name|userName
argument_list|,
name|volumeName
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called by CBlock server to delete a specific volume. Mainly    * to check whether it can be deleted, and remove it from in-memory meta    * data.    *    * @param userName the user name of the volume.    * @param volumeName the name of the volume.    * @param force if set to false, only delete volume it is empty, otherwise    *              throw exception. if set to true, delete regardless.    * @throws CBlockException when the volume can not be deleted.    */
DECL|method|deleteVolume (String userName, String volumeName, boolean force)
specifier|public
specifier|synchronized
name|void
name|deleteVolume
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
name|volumeName
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|CBlockException
block|{
if|if
condition|(
operator|!
name|user2VolumeMap
operator|.
name|containsKey
argument_list|(
name|userName
argument_list|)
operator|||
operator|!
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|containsKey
argument_list|(
name|volumeName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CBlockException
argument_list|(
literal|"Deleting non-exist volume "
operator|+
name|userName
operator|+
literal|":"
operator|+
name|volumeName
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|get
argument_list|(
name|volumeName
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CBlockException
argument_list|(
literal|"Deleting a non-empty volume without force!"
argument_list|)
throw|;
block|}
name|VolumeDescriptor
name|volume
init|=
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|remove
argument_list|(
name|volumeName
argument_list|)
decl_stmt|;
name|deleteVolumeContainers
argument_list|(
name|volume
operator|.
name|getContainerIDsList
argument_list|()
argument_list|,
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|user2VolumeMap
operator|.
name|remove
argument_list|(
name|userName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called by CBlock server to get information of a specific volume.    *    * @param userName the user name of the volume.    * @param volumeName the name of the volume.    * @return a {@link VolumeInfo} object encapsulating the information of the    * volume.    * @throws CBlockException when the information can not be retrieved.    */
DECL|method|infoVolume (String userName, String volumeName)
specifier|public
specifier|synchronized
name|VolumeInfo
name|infoVolume
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
name|volumeName
parameter_list|)
throws|throws
name|CBlockException
block|{
if|if
condition|(
operator|!
name|user2VolumeMap
operator|.
name|containsKey
argument_list|(
name|userName
argument_list|)
operator|||
operator|!
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|containsKey
argument_list|(
name|volumeName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CBlockException
argument_list|(
literal|"Getting info for non-exist volume "
operator|+
name|userName
operator|+
literal|":"
operator|+
name|volumeName
argument_list|)
throw|;
block|}
return|return
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|get
argument_list|(
name|volumeName
argument_list|)
operator|.
name|getInfo
argument_list|()
return|;
block|}
comment|/**    * Called by CBlock server to check whether the given volume can be    * mounted, i.e. whether it can be found in the meta data.    *    * return a {@link MountVolumeResponse} with isValid flag to indicate    * whether the volume can be mounted or not.    *    * @param userName the user name of the volume.    * @param volumeName the name of the volume    * @return a {@link MountVolumeResponse} object encapsulating whether the    * volume is valid, and if yes, the requried information for client to    * read/write the volume.    */
DECL|method|isVolumeValid ( String userName, String volumeName)
specifier|public
specifier|synchronized
name|MountVolumeResponse
name|isVolumeValid
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
name|volumeName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|user2VolumeMap
operator|.
name|containsKey
argument_list|(
name|userName
argument_list|)
operator|||
operator|!
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|containsKey
argument_list|(
name|volumeName
argument_list|)
condition|)
block|{
comment|// in the case of invalid volume, no need to set any value other than
comment|// isValid flag.
return|return
operator|new
name|MountVolumeResponse
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
name|VolumeDescriptor
name|volume
init|=
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|get
argument_list|(
name|volumeName
argument_list|)
decl_stmt|;
return|return
operator|new
name|MountVolumeResponse
argument_list|(
literal|true
argument_list|,
name|userName
argument_list|,
name|volumeName
argument_list|,
name|volume
operator|.
name|getVolumeSize
argument_list|()
argument_list|,
name|volume
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|volume
operator|.
name|getContainerPipelines
argument_list|()
argument_list|,
name|volume
operator|.
name|getPipelines
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Called by CBlock manager to list all volumes.    *    * @param userName the userName whose volume to be listed, if set to null,    *                 all volumes will be listed.    * @return a list of {@link VolumeDescriptor} representing all volumes    * requested.    */
DECL|method|getAllVolume (String userName)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|VolumeDescriptor
argument_list|>
name|getAllVolume
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|VolumeDescriptor
argument_list|>
name|allVolumes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|userName
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|VolumeDescriptor
argument_list|>
argument_list|>
name|entry
range|:
name|user2VolumeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|allVolumes
operator|.
name|addAll
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|user2VolumeMap
operator|.
name|containsKey
argument_list|(
name|userName
argument_list|)
condition|)
block|{
name|allVolumes
operator|.
name|addAll
argument_list|(
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|allVolumes
return|;
block|}
comment|/**    * Only for testing the behavior of create/delete volumes.    */
annotation|@
name|VisibleForTesting
DECL|method|getVolume (String userName, String volumeName)
specifier|public
name|VolumeDescriptor
name|getVolume
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
name|volumeName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|user2VolumeMap
operator|.
name|containsKey
argument_list|(
name|userName
argument_list|)
operator|||
operator|!
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|containsKey
argument_list|(
name|volumeName
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|user2VolumeMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
operator|.
name|get
argument_list|(
name|volumeName
argument_list|)
return|;
block|}
block|}
end_class

end_unit

