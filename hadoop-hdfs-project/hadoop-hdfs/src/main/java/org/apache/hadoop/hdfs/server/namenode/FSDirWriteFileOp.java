begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoContiguous
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoContiguousUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NodeBase
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_class
DECL|class|FSDirWriteFileOp
class|class
name|FSDirWriteFileOp
block|{
DECL|method|FSDirWriteFileOp ()
specifier|private
name|FSDirWriteFileOp
parameter_list|()
block|{}
DECL|method|unprotectedRemoveBlock ( FSDirectory fsd, String path, INodesInPath iip, INodeFile fileNode, Block block)
specifier|static
name|boolean
name|unprotectedRemoveBlock
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|path
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|INodeFile
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
comment|// modify file-> block and blocksMap
comment|// fileNode should be under construction
name|BlockInfoContiguousUnderConstruction
name|uc
init|=
name|fileNode
operator|.
name|removeLastBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|uc
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|fsd
operator|.
name|getBlockManager
argument_list|()
operator|.
name|removeBlockFromMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.removeBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is removed from the file system"
argument_list|)
expr_stmt|;
block|}
comment|// update space consumed
name|fsd
operator|.
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
operator|-
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|,
name|fileNode
operator|.
name|getPreferredBlockReplication
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Persist the block list for the inode.    */
DECL|method|persistBlocks ( FSDirectory fsd, String path, INodeFile file, boolean logRetryCache)
specifier|static
name|void
name|persistBlocks
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
block|{
assert|assert
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|file
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|fsd
operator|.
name|getEditLog
argument_list|()
operator|.
name|logUpdateBlocks
argument_list|(
name|path
argument_list|,
name|file
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"persistBlocks: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|" blocks is persisted to"
operator|+
literal|" the file system"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|abandonBlock ( FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId, String src, String holder)
specifier|static
name|void
name|abandonBlock
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|FSPermissionChecker
name|pc
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|src
operator|=
name|fsd
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
specifier|final
name|INode
name|inode
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
if|if
condition|(
name|fileId
operator|==
name|HdfsConstants
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|iip
operator|=
name|fsd
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|inode
operator|=
name|iip
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|=
name|fsd
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
name|iip
operator|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
name|src
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
block|}
name|FSNamesystem
name|fsn
init|=
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
decl_stmt|;
specifier|final
name|INodeFile
name|file
init|=
name|fsn
operator|.
name|checkLease
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|file
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|Block
name|localBlock
init|=
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|fsd
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Remove the block from the pending creates list
if|if
condition|(
operator|!
name|unprotectedRemoveBlock
argument_list|(
name|fsd
argument_list|,
name|src
argument_list|,
name|iip
argument_list|,
name|file
argument_list|,
name|localBlock
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
finally|finally
block|{
name|fsd
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|persistBlocks
argument_list|(
name|fsd
argument_list|,
name|src
argument_list|,
name|file
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|checkBlock (FSNamesystem fsn, ExtendedBlock block)
specifier|static
name|void
name|checkBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|bpId
init|=
name|fsn
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
operator|!
name|bpId
operator|.
name|equals
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected BlockPoolId "
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" - expected "
operator|+
name|bpId
argument_list|)
throw|;
block|}
block|}
comment|/**    * Part I of getAdditionalBlock().    * Analyze the state of the file under read lock to determine if the client    * can add a new block, detect potential retries, lease mismatches,    * and minimal replication of the penultimate block.    *    * Generate target DataNode locations for the new block,    * but do not create the new block yet.    */
DECL|method|validateAddBlock ( FSNamesystem fsn, FSPermissionChecker pc, String src, long fileId, String clientName, ExtendedBlock previous, LocatedBlock[] onRetryBlock)
specifier|static
name|ValidateAddBlockResult
name|validateAddBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|FSPermissionChecker
name|pc
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|LocatedBlock
index|[]
name|onRetryBlock
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|blockSize
decl_stmt|;
specifier|final
name|int
name|replication
decl_stmt|;
specifier|final
name|byte
name|storagePolicyID
decl_stmt|;
name|String
name|clientMachine
decl_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|src
operator|=
name|fsn
operator|.
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
name|FileState
name|fileState
init|=
name|analyzeFileState
argument_list|(
name|fsn
argument_list|,
name|src
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|onRetryBlock
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|pendingFile
init|=
name|fileState
operator|.
name|inode
decl_stmt|;
comment|// Check if the penultimate block is minimally replicated
if|if
condition|(
operator|!
name|fsn
operator|.
name|checkFileProgress
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NotReplicatedYetException
argument_list|(
literal|"Not replicated yet: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|onRetryBlock
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
name|onRetryBlock
index|[
literal|0
index|]
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// This is a retry. No need to generate new locations.
comment|// Use the last block if it has locations.
return|return
literal|null
return|;
block|}
if|if
condition|(
name|pendingFile
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|>=
name|fsn
operator|.
name|maxBlocksPerFile
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File has reached the limit on maximum number of"
operator|+
literal|" blocks ("
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_BLOCKS_PER_FILE_KEY
operator|+
literal|"): "
operator|+
name|pendingFile
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|">= "
operator|+
name|fsn
operator|.
name|maxBlocksPerFile
argument_list|)
throw|;
block|}
name|blockSize
operator|=
name|pendingFile
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
name|clientMachine
operator|=
name|pendingFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientMachine
argument_list|()
expr_stmt|;
name|replication
operator|=
name|pendingFile
operator|.
name|getFileReplication
argument_list|()
expr_stmt|;
name|storagePolicyID
operator|=
name|pendingFile
operator|.
name|getStoragePolicyID
argument_list|()
expr_stmt|;
return|return
operator|new
name|ValidateAddBlockResult
argument_list|(
name|blockSize
argument_list|,
name|replication
argument_list|,
name|storagePolicyID
argument_list|,
name|clientMachine
argument_list|)
return|;
block|}
DECL|method|makeLocatedBlock (FSNamesystem fsn, Block blk, DatanodeStorageInfo[] locs, long offset)
specifier|static
name|LocatedBlock
name|makeLocatedBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|Block
name|blk
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|locs
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlock
name|lBlk
init|=
name|BlockManager
operator|.
name|newLocatedBlock
argument_list|(
name|fsn
operator|.
name|getExtendedBlock
argument_list|(
name|blk
argument_list|)
argument_list|,
name|locs
argument_list|,
name|offset
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|fsn
operator|.
name|getBlockManager
argument_list|()
operator|.
name|setBlockToken
argument_list|(
name|lBlk
argument_list|,
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
expr_stmt|;
return|return
name|lBlk
return|;
block|}
comment|/**    * Part II of getAdditionalBlock().    * Should repeat the same analysis of the file state as in Part 1,    * but under the write lock.    * If the conditions still hold, then allocate a new block with    * the new targets, add it to the INode and to the BlocksMap.    */
DECL|method|storeAllocatedBlock (FSNamesystem fsn, String src, long fileId, String clientName, ExtendedBlock previous, DatanodeStorageInfo[] targets)
specifier|static
name|LocatedBlock
name|storeAllocatedBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|offset
decl_stmt|;
comment|// Run the full analysis again, since things could have changed
comment|// while chooseTarget() was executing.
name|LocatedBlock
index|[]
name|onRetryBlock
init|=
operator|new
name|LocatedBlock
index|[
literal|1
index|]
decl_stmt|;
name|FileState
name|fileState
init|=
name|analyzeFileState
argument_list|(
name|fsn
argument_list|,
name|src
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|onRetryBlock
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|pendingFile
init|=
name|fileState
operator|.
name|inode
decl_stmt|;
name|src
operator|=
name|fileState
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|onRetryBlock
index|[
literal|0
index|]
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|onRetryBlock
index|[
literal|0
index|]
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// This is a retry. Just return the last block if having locations.
return|return
name|onRetryBlock
index|[
literal|0
index|]
return|;
block|}
else|else
block|{
comment|// add new chosen targets to already allocated block and return
name|BlockInfoContiguous
name|lastBlockInFile
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
operator|(
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|lastBlockInFile
operator|)
operator|.
name|setExpectedLocations
argument_list|(
name|targets
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pendingFile
operator|.
name|computeFileSize
argument_list|()
expr_stmt|;
return|return
name|makeLocatedBlock
argument_list|(
name|fsn
argument_list|,
name|lastBlockInFile
argument_list|,
name|targets
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
comment|// commit the last block and complete it if it has minimum replicas
name|fsn
operator|.
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|fileState
operator|.
name|iip
argument_list|,
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|previous
argument_list|)
argument_list|)
expr_stmt|;
comment|// allocate new block, record block locations in INode.
name|Block
name|newBlock
init|=
name|fsn
operator|.
name|createNewBlock
argument_list|()
decl_stmt|;
name|INodesInPath
name|inodesInPath
init|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|pendingFile
argument_list|)
decl_stmt|;
name|saveAllocatedBlock
argument_list|(
name|fsn
argument_list|,
name|src
argument_list|,
name|inodesInPath
argument_list|,
name|newBlock
argument_list|,
name|targets
argument_list|)
expr_stmt|;
name|persistNewBlock
argument_list|(
name|fsn
argument_list|,
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pendingFile
operator|.
name|computeFileSize
argument_list|()
expr_stmt|;
comment|// Return located block
return|return
name|makeLocatedBlock
argument_list|(
name|fsn
argument_list|,
name|newBlock
argument_list|,
name|targets
argument_list|,
name|offset
argument_list|)
return|;
block|}
DECL|method|chooseTargetForNewBlock ( BlockManager bm, String src, DatanodeInfo[] excludedNodes, String[] favoredNodes, ValidateAddBlockResult r)
specifier|static
name|DatanodeStorageInfo
index|[]
name|chooseTargetForNewBlock
parameter_list|(
name|BlockManager
name|bm
parameter_list|,
name|String
name|src
parameter_list|,
name|DatanodeInfo
index|[]
name|excludedNodes
parameter_list|,
name|String
index|[]
name|favoredNodes
parameter_list|,
name|ValidateAddBlockResult
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|Node
name|clientNode
init|=
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeByHost
argument_list|(
name|r
operator|.
name|clientMachine
argument_list|)
decl_stmt|;
if|if
condition|(
name|clientNode
operator|==
literal|null
condition|)
block|{
name|clientNode
operator|=
name|getClientNode
argument_list|(
name|bm
argument_list|,
name|r
operator|.
name|clientMachine
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodesSet
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|excludedNodes
operator|!=
literal|null
condition|)
block|{
name|excludedNodesSet
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|excludedNodes
operator|.
name|length
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|excludedNodesSet
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|favoredNodesList
init|=
operator|(
name|favoredNodes
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|favoredNodes
argument_list|)
decl_stmt|;
comment|// choose targets for the new block to be allocated.
return|return
name|bm
operator|.
name|chooseTarget4NewBlock
argument_list|(
name|src
argument_list|,
name|r
operator|.
name|replication
argument_list|,
name|clientNode
argument_list|,
name|excludedNodesSet
argument_list|,
name|r
operator|.
name|blockSize
argument_list|,
name|favoredNodesList
argument_list|,
name|r
operator|.
name|storagePolicyID
argument_list|)
return|;
block|}
comment|/**    * Resolve clientmachine address to get a network location path    */
DECL|method|getClientNode (BlockManager bm, String clientMachine)
specifier|static
name|Node
name|getClientNode
parameter_list|(
name|BlockManager
name|bm
parameter_list|,
name|String
name|clientMachine
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|hosts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|hosts
operator|.
name|add
argument_list|(
name|clientMachine
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rName
init|=
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|resolveNetworkLocation
argument_list|(
name|hosts
argument_list|)
decl_stmt|;
name|Node
name|clientNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rName
operator|!=
literal|null
condition|)
block|{
comment|// Able to resolve clientMachine mapping.
comment|// Create a temp node to findout the rack local nodes
name|clientNode
operator|=
operator|new
name|NodeBase
argument_list|(
name|rName
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|+
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
operator|+
name|clientMachine
argument_list|)
expr_stmt|;
block|}
return|return
name|clientNode
return|;
block|}
comment|/**    * Add a block to the file. Returns a reference to the added block.    */
DECL|method|addBlock ( FSDirectory fsd, String path, INodesInPath inodesInPath, Block block, DatanodeStorageInfo[] targets)
specifier|private
specifier|static
name|BlockInfoContiguous
name|addBlock
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|path
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|Block
name|block
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
throws|throws
name|IOException
block|{
name|fsd
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodeFile
name|fileINode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
comment|// check quota limits and updated space consumed
name|fsd
operator|.
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
literal|0
argument_list|,
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|,
name|fileINode
operator|.
name|getPreferredBlockReplication
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// associate new last block for the file
name|BlockInfoContiguousUnderConstruction
name|blockInfo
init|=
operator|new
name|BlockInfoContiguousUnderConstruction
argument_list|(
name|block
argument_list|,
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|,
name|HdfsServerConstants
operator|.
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|fsd
operator|.
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|fileINode
argument_list|)
expr_stmt|;
name|fileINode
operator|.
name|addBlock
argument_list|(
name|blockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.addBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is added to the in-memory "
operator|+
literal|"file system"
argument_list|)
expr_stmt|;
block|}
return|return
name|blockInfo
return|;
block|}
finally|finally
block|{
name|fsd
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|analyzeFileState ( FSNamesystem fsn, String src, long fileId, String clientName, ExtendedBlock previous, LocatedBlock[] onRetryBlock)
specifier|private
specifier|static
name|FileState
name|analyzeFileState
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|LocatedBlock
index|[]
name|onRetryBlock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsn
operator|.
name|hasReadLock
argument_list|()
assert|;
name|checkBlock
argument_list|(
name|fsn
argument_list|,
name|previous
argument_list|)
expr_stmt|;
name|onRetryBlock
index|[
literal|0
index|]
operator|=
literal|null
expr_stmt|;
name|fsn
operator|.
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot add block to "
operator|+
name|src
argument_list|)
expr_stmt|;
comment|// have we exceeded the configured limit of fs objects.
name|fsn
operator|.
name|checkFsObjectLimit
argument_list|()
expr_stmt|;
name|Block
name|previousBlock
init|=
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|previous
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
if|if
condition|(
name|fileId
operator|==
name|HdfsConstants
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|iip
operator|=
name|fsn
operator|.
name|dir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|inode
operator|=
name|iip
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Newer clients pass the inode ID, so we can just get the inode
comment|// directly.
name|inode
operator|=
name|fsn
operator|.
name|dir
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
name|iip
operator|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
name|src
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|INodeFile
name|file
init|=
name|fsn
operator|.
name|checkLease
argument_list|(
name|src
argument_list|,
name|clientName
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|BlockInfoContiguous
name|lastBlockInFile
init|=
name|file
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|previousBlock
argument_list|,
name|lastBlockInFile
argument_list|)
condition|)
block|{
comment|// The block that the client claims is the current last block
comment|// doesn't match up with what we think is the last block. There are
comment|// four possibilities:
comment|// 1) This is the first block allocation of an append() pipeline
comment|//    which started appending exactly at or exceeding the block boundary.
comment|//    In this case, the client isn't passed the previous block,
comment|//    so it makes the allocateBlock() call with previous=null.
comment|//    We can distinguish this since the last block of the file
comment|//    will be exactly a full block.
comment|// 2) This is a retry from a client that missed the response of a
comment|//    prior getAdditionalBlock() call, perhaps because of a network
comment|//    timeout, or because of an HA failover. In that case, we know
comment|//    by the fact that the client is re-issuing the RPC that it
comment|//    never began to write to the old block. Hence it is safe to
comment|//    to return the existing block.
comment|// 3) This is an entirely bogus request/bug -- we should error out
comment|//    rather than potentially appending a new block with an empty
comment|//    one in the middle, etc
comment|// 4) This is a retry from a client that timed out while
comment|//    the prior getAdditionalBlock() is still being processed,
comment|//    currently working on chooseTarget().
comment|//    There are no means to distinguish between the first and
comment|//    the second attempts in Part I, because the first one hasn't
comment|//    changed the namesystem state yet.
comment|//    We run this analysis again in Part II where case 4 is impossible.
name|BlockInfoContiguous
name|penultimateBlock
init|=
name|file
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|==
literal|null
operator|&&
name|lastBlockInFile
operator|!=
literal|null
operator|&&
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|>=
name|file
operator|.
name|getPreferredBlockSize
argument_list|()
operator|&&
name|lastBlockInFile
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|// Case 1
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.allocateBlock: handling block allocation"
operator|+
literal|" writing to a file with a complete previous block: src="
operator|+
name|src
operator|+
literal|" lastBlock="
operator|+
name|lastBlockInFile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|penultimateBlock
argument_list|,
name|previousBlock
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Request looked like a retry to allocate block "
operator|+
name|lastBlockInFile
operator|+
literal|" but it already contains "
operator|+
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
comment|// Case 2
comment|// Return the last block.
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* allocateBlock: caught retry for "
operator|+
literal|"allocation of a new block in "
operator|+
name|src
operator|+
literal|". Returning previously"
operator|+
literal|" allocated block "
operator|+
name|lastBlockInFile
argument_list|)
expr_stmt|;
name|long
name|offset
init|=
name|file
operator|.
name|computeFileSize
argument_list|()
decl_stmt|;
name|BlockInfoContiguousUnderConstruction
name|lastBlockUC
init|=
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|lastBlockInFile
decl_stmt|;
name|onRetryBlock
index|[
literal|0
index|]
operator|=
name|makeLocatedBlock
argument_list|(
name|fsn
argument_list|,
name|lastBlockInFile
argument_list|,
name|lastBlockUC
operator|.
name|getExpectedStorageLocations
argument_list|()
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|new
name|FileState
argument_list|(
name|file
argument_list|,
name|src
argument_list|,
name|iip
argument_list|)
return|;
block|}
else|else
block|{
comment|// Case 3
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot allocate block in "
operator|+
name|src
operator|+
literal|": "
operator|+
literal|"passed 'previous' block "
operator|+
name|previous
operator|+
literal|" does not match actual "
operator|+
literal|"last block in file "
operator|+
name|lastBlockInFile
argument_list|)
throw|;
block|}
block|}
return|return
operator|new
name|FileState
argument_list|(
name|file
argument_list|,
name|src
argument_list|,
name|iip
argument_list|)
return|;
block|}
DECL|method|completeFile (FSNamesystem fsn, FSPermissionChecker pc, final String srcArg, String holder, ExtendedBlock last, long fileId)
specifier|static
name|boolean
name|completeFile
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|FSPermissionChecker
name|pc
parameter_list|,
specifier|final
name|String
name|srcArg
parameter_list|,
name|String
name|holder
parameter_list|,
name|ExtendedBlock
name|last
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.completeFile: "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
argument_list|)
expr_stmt|;
block|}
name|checkBlock
argument_list|(
name|fsn
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|FSDirectory
operator|.
name|getPathComponentsForReservedPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|src
operator|=
name|fsn
operator|.
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|pathComponents
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
name|completeFileInternal
argument_list|(
name|fsn
argument_list|,
name|src
argument_list|,
name|holder
argument_list|,
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|last
argument_list|)
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* completeFile: "
operator|+
name|srcArg
operator|+
literal|" is closed by "
operator|+
name|holder
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
DECL|method|completeFileInternal ( FSNamesystem fsn, String src, String holder, Block last, long fileId)
specifier|private
specifier|static
name|boolean
name|completeFileInternal
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|,
name|Block
name|last
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsn
operator|.
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeFile
name|pendingFile
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
name|INode
name|inode
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|fileId
operator|==
name|HdfsConstants
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|iip
operator|=
name|fsn
operator|.
name|dir
operator|.
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|inode
operator|=
name|iip
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|=
name|fsn
operator|.
name|dir
operator|.
name|getInode
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
name|iip
operator|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
name|src
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
block|}
name|pendingFile
operator|=
name|fsn
operator|.
name|checkLease
argument_list|(
name|src
argument_list|,
name|holder
argument_list|,
name|inode
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseExpiredException
name|lee
parameter_list|)
block|{
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|.
name|isFile
argument_list|()
operator|&&
operator|!
name|inode
operator|.
name|asFile
argument_list|()
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
comment|// This could be a retry RPC - i.e the client tried to close
comment|// the file, but missed the RPC response. Thus, it is trying
comment|// again to close the file. If the file still exists and
comment|// the client's view of the last block matches the actual
comment|// last block, then we'll treat it as a successful close.
comment|// See HDFS-3031.
specifier|final
name|Block
name|realLastBlock
init|=
name|inode
operator|.
name|asFile
argument_list|()
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|last
argument_list|,
name|realLastBlock
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* completeFile: "
operator|+
literal|"request from "
operator|+
name|holder
operator|+
literal|" to complete inode "
operator|+
name|fileId
operator|+
literal|"("
operator|+
name|src
operator|+
literal|") which is already closed. But, it appears to be "
operator|+
literal|"an RPC retry. Returning success"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
throw|throw
name|lee
throw|;
block|}
comment|// Check the state of the penultimate block. It should be completed
comment|// before attempting to complete the last one.
if|if
condition|(
operator|!
name|fsn
operator|.
name|checkFileProgress
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// commit the last block and complete it if it has minimum replicas
name|fsn
operator|.
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|iip
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsn
operator|.
name|checkFileProgress
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|fsn
operator|.
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Persist the new block (the last block of the given file).    */
DECL|method|persistNewBlock ( FSNamesystem fsn, String path, INodeFile file)
specifier|private
specifier|static
name|void
name|persistNewBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|file
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|fsn
operator|.
name|getEditLog
argument_list|()
operator|.
name|logAddBlock
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"persistNewBlock: "
operator|+
name|path
operator|+
literal|" with new block "
operator|+
name|file
operator|.
name|getLastBlock
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|", current total block count is "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Save allocated block at the given pending filename    *    * @param fsn FSNamesystem    * @param src path to the file    * @param inodesInPath representing each of the components of src.    *                     The last INode is the INode for {@code src} file.    * @param newBlock newly allocated block to be save    * @param targets target datanodes where replicas of the new block is placed    * @throws QuotaExceededException If addition of block exceeds space quota    */
DECL|method|saveAllocatedBlock ( FSNamesystem fsn, String src, INodesInPath inodesInPath, Block newBlock, DatanodeStorageInfo[] targets)
specifier|private
specifier|static
name|void
name|saveAllocatedBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|String
name|src
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|Block
name|newBlock
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsn
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|BlockInfoContiguous
name|b
init|=
name|addBlock
argument_list|(
name|fsn
operator|.
name|dir
argument_list|,
name|src
argument_list|,
name|inodesInPath
argument_list|,
name|newBlock
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* allocate "
operator|+
name|b
operator|+
literal|" for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|DatanodeStorageInfo
operator|.
name|incrementBlocksScheduled
argument_list|(
name|targets
argument_list|)
expr_stmt|;
block|}
DECL|class|FileState
specifier|private
specifier|static
class|class
name|FileState
block|{
DECL|field|inode
specifier|final
name|INodeFile
name|inode
decl_stmt|;
DECL|field|path
specifier|final
name|String
name|path
decl_stmt|;
DECL|field|iip
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
DECL|method|FileState (INodeFile inode, String fullPath, INodesInPath iip)
name|FileState
parameter_list|(
name|INodeFile
name|inode
parameter_list|,
name|String
name|fullPath
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
block|{
name|this
operator|.
name|inode
operator|=
name|inode
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|fullPath
expr_stmt|;
name|this
operator|.
name|iip
operator|=
name|iip
expr_stmt|;
block|}
block|}
DECL|class|ValidateAddBlockResult
specifier|static
class|class
name|ValidateAddBlockResult
block|{
DECL|field|blockSize
specifier|final
name|long
name|blockSize
decl_stmt|;
DECL|field|replication
specifier|final
name|int
name|replication
decl_stmt|;
DECL|field|storagePolicyID
specifier|final
name|byte
name|storagePolicyID
decl_stmt|;
DECL|field|clientMachine
specifier|final
name|String
name|clientMachine
decl_stmt|;
DECL|method|ValidateAddBlockResult ( long blockSize, int replication, byte storagePolicyID, String clientMachine)
name|ValidateAddBlockResult
parameter_list|(
name|long
name|blockSize
parameter_list|,
name|int
name|replication
parameter_list|,
name|byte
name|storagePolicyID
parameter_list|,
name|String
name|clientMachine
parameter_list|)
block|{
name|this
operator|.
name|blockSize
operator|=
name|blockSize
expr_stmt|;
name|this
operator|.
name|replication
operator|=
name|replication
expr_stmt|;
name|this
operator|.
name|storagePolicyID
operator|=
name|storagePolicyID
expr_stmt|;
name|this
operator|.
name|clientMachine
operator|=
name|clientMachine
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

