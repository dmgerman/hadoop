begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|AddBlockFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoContiguous
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoStriped
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockUnderConstructionFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSDirectory
operator|.
name|DirOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NodeBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ChunkedArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
operator|.
name|CURRENT_STATE_ID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_class
DECL|class|FSDirWriteFileOp
class|class
name|FSDirWriteFileOp
block|{
DECL|method|FSDirWriteFileOp ()
specifier|private
name|FSDirWriteFileOp
parameter_list|()
block|{}
DECL|method|unprotectedRemoveBlock ( FSDirectory fsd, String path, INodesInPath iip, INodeFile fileNode, Block block)
specifier|static
name|boolean
name|unprotectedRemoveBlock
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|path
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|INodeFile
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
comment|// modify file-> block and blocksMap
comment|// fileNode should be under construction
name|BlockInfo
name|uc
init|=
name|fileNode
operator|.
name|removeLastBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|uc
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|uc
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|DatanodeStorageInfo
operator|.
name|decrementBlocksScheduled
argument_list|(
name|uc
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|getExpectedStorageLocations
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fsd
operator|.
name|getBlockManager
argument_list|()
operator|.
name|removeBlockFromMap
argument_list|(
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.removeBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is removed from the file system"
argument_list|)
expr_stmt|;
block|}
comment|// update space consumed
name|fsd
operator|.
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
operator|-
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|,
name|fileNode
operator|.
name|getPreferredBlockReplication
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Persist the block list for the inode.    */
DECL|method|persistBlocks ( FSDirectory fsd, String path, INodeFile file, boolean logRetryCache)
specifier|static
name|void
name|persistBlocks
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
block|{
assert|assert
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|file
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|fsd
operator|.
name|getEditLog
argument_list|()
operator|.
name|logUpdateBlocks
argument_list|(
name|path
argument_list|,
name|file
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"persistBlocks: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|" blocks is persisted to"
operator|+
literal|" the file system"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|abandonBlock ( FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId, String src, String holder)
specifier|static
name|void
name|abandonBlock
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|FSPermissionChecker
name|pc
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|holder
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|INodesInPath
name|iip
init|=
name|fsd
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|src
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|FSNamesystem
name|fsn
init|=
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
decl_stmt|;
specifier|final
name|INodeFile
name|file
init|=
name|fsn
operator|.
name|checkLease
argument_list|(
name|iip
argument_list|,
name|holder
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|file
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|isStriped
argument_list|()
condition|)
block|{
return|return;
comment|// do not abandon block for striped file
block|}
name|Block
name|localBlock
init|=
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|fsd
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Remove the block from the pending creates list
if|if
condition|(
operator|!
name|unprotectedRemoveBlock
argument_list|(
name|fsd
argument_list|,
name|src
argument_list|,
name|iip
argument_list|,
name|file
argument_list|,
name|localBlock
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
finally|finally
block|{
name|fsd
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|persistBlocks
argument_list|(
name|fsd
argument_list|,
name|src
argument_list|,
name|file
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|checkBlock (FSNamesystem fsn, ExtendedBlock block)
specifier|static
name|void
name|checkBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|bpId
init|=
name|fsn
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
operator|!
name|bpId
operator|.
name|equals
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected BlockPoolId "
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" - expected "
operator|+
name|bpId
argument_list|)
throw|;
block|}
block|}
comment|/**    * Part I of getAdditionalBlock().    * Analyze the state of the file under read lock to determine if the client    * can add a new block, detect potential retries, lease mismatches,    * and minimal replication of the penultimate block.    *    * Generate target DataNode locations for the new block,    * but do not create the new block yet.    */
DECL|method|validateAddBlock ( FSNamesystem fsn, FSPermissionChecker pc, String src, long fileId, String clientName, ExtendedBlock previous, LocatedBlock[] onRetryBlock)
specifier|static
name|ValidateAddBlockResult
name|validateAddBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|FSPermissionChecker
name|pc
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|LocatedBlock
index|[]
name|onRetryBlock
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|blockSize
decl_stmt|;
specifier|final
name|short
name|numTargets
decl_stmt|;
specifier|final
name|byte
name|storagePolicyID
decl_stmt|;
name|String
name|clientMachine
decl_stmt|;
specifier|final
name|boolean
name|isStriped
decl_stmt|;
name|INodesInPath
name|iip
init|=
name|fsn
operator|.
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|FileState
name|fileState
init|=
name|analyzeFileState
argument_list|(
name|fsn
argument_list|,
name|iip
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|onRetryBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|onRetryBlock
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
name|onRetryBlock
index|[
literal|0
index|]
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// This is a retry. No need to generate new locations.
comment|// Use the last block if it has locations.
return|return
literal|null
return|;
block|}
specifier|final
name|INodeFile
name|pendingFile
init|=
name|fileState
operator|.
name|inode
decl_stmt|;
if|if
condition|(
operator|!
name|fsn
operator|.
name|checkFileProgress
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NotReplicatedYetException
argument_list|(
literal|"Not replicated yet: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|pendingFile
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|>=
name|fsn
operator|.
name|maxBlocksPerFile
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File has reached the limit on maximum number of"
operator|+
literal|" blocks ("
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_BLOCKS_PER_FILE_KEY
operator|+
literal|"): "
operator|+
name|pendingFile
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|">= "
operator|+
name|fsn
operator|.
name|maxBlocksPerFile
argument_list|)
throw|;
block|}
name|blockSize
operator|=
name|pendingFile
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
name|clientMachine
operator|=
name|pendingFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientMachine
argument_list|()
expr_stmt|;
name|isStriped
operator|=
name|pendingFile
operator|.
name|isStriped
argument_list|()
expr_stmt|;
name|ErasureCodingPolicy
name|ecPolicy
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isStriped
condition|)
block|{
name|ecPolicy
operator|=
name|FSDirErasureCodingOp
operator|.
name|getErasureCodingPolicy
argument_list|(
name|fsn
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|numTargets
operator|=
call|(
name|short
call|)
argument_list|(
name|ecPolicy
operator|.
name|getSchema
argument_list|()
operator|.
name|getNumDataUnits
argument_list|()
operator|+
name|ecPolicy
operator|.
name|getSchema
argument_list|()
operator|.
name|getNumParityUnits
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numTargets
operator|=
name|pendingFile
operator|.
name|getFileReplication
argument_list|()
expr_stmt|;
block|}
name|storagePolicyID
operator|=
name|pendingFile
operator|.
name|getStoragePolicyID
argument_list|()
expr_stmt|;
return|return
operator|new
name|ValidateAddBlockResult
argument_list|(
name|blockSize
argument_list|,
name|numTargets
argument_list|,
name|storagePolicyID
argument_list|,
name|clientMachine
argument_list|,
name|isStriped
argument_list|)
return|;
block|}
DECL|method|makeLocatedBlock (FSNamesystem fsn, BlockInfo blk, DatanodeStorageInfo[] locs, long offset)
specifier|static
name|LocatedBlock
name|makeLocatedBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|BlockInfo
name|blk
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|locs
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|LocatedBlock
name|lBlk
init|=
name|BlockManager
operator|.
name|newLocatedBlock
argument_list|(
name|fsn
operator|.
name|getExtendedBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|blk
argument_list|)
argument_list|)
argument_list|,
name|blk
argument_list|,
name|locs
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|fsn
operator|.
name|getBlockManager
argument_list|()
operator|.
name|setBlockToken
argument_list|(
name|lBlk
argument_list|,
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
expr_stmt|;
return|return
name|lBlk
return|;
block|}
comment|/**    * Part II of getAdditionalBlock().    * Should repeat the same analysis of the file state as in Part 1,    * but under the write lock.    * If the conditions still hold, then allocate a new block with    * the new targets, add it to the INode and to the BlocksMap.    */
DECL|method|storeAllocatedBlock (FSNamesystem fsn, String src, long fileId, String clientName, ExtendedBlock previous, DatanodeStorageInfo[] targets)
specifier|static
name|LocatedBlock
name|storeAllocatedBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|offset
decl_stmt|;
comment|// Run the full analysis again, since things could have changed
comment|// while chooseTarget() was executing.
name|LocatedBlock
index|[]
name|onRetryBlock
init|=
operator|new
name|LocatedBlock
index|[
literal|1
index|]
decl_stmt|;
name|INodesInPath
name|iip
init|=
name|fsn
operator|.
name|dir
operator|.
name|resolvePath
argument_list|(
literal|null
argument_list|,
name|src
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|FileState
name|fileState
init|=
name|analyzeFileState
argument_list|(
name|fsn
argument_list|,
name|iip
argument_list|,
name|fileId
argument_list|,
name|clientName
argument_list|,
name|previous
argument_list|,
name|onRetryBlock
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|pendingFile
init|=
name|fileState
operator|.
name|inode
decl_stmt|;
name|src
operator|=
name|fileState
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|onRetryBlock
index|[
literal|0
index|]
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|onRetryBlock
index|[
literal|0
index|]
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// This is a retry. Just return the last block if having locations.
return|return
name|onRetryBlock
index|[
literal|0
index|]
return|;
block|}
else|else
block|{
comment|// add new chosen targets to already allocated block and return
name|BlockInfo
name|lastBlockInFile
init|=
name|pendingFile
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
name|lastBlockInFile
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|setExpectedLocations
argument_list|(
name|lastBlockInFile
argument_list|,
name|targets
argument_list|,
name|pendingFile
operator|.
name|isStriped
argument_list|()
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pendingFile
operator|.
name|computeFileSize
argument_list|()
expr_stmt|;
return|return
name|makeLocatedBlock
argument_list|(
name|fsn
argument_list|,
name|lastBlockInFile
argument_list|,
name|targets
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
comment|// commit the last block and complete it if it has minimum replicas
name|fsn
operator|.
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|fileState
operator|.
name|iip
argument_list|,
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|previous
argument_list|)
argument_list|)
expr_stmt|;
comment|// allocate new block, record block locations in INode.
specifier|final
name|boolean
name|isStriped
init|=
name|pendingFile
operator|.
name|isStriped
argument_list|()
decl_stmt|;
comment|// allocate new block, record block locations in INode.
name|Block
name|newBlock
init|=
name|fsn
operator|.
name|createNewBlock
argument_list|(
name|isStriped
argument_list|)
decl_stmt|;
name|INodesInPath
name|inodesInPath
init|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|pendingFile
argument_list|)
decl_stmt|;
name|saveAllocatedBlock
argument_list|(
name|fsn
argument_list|,
name|src
argument_list|,
name|inodesInPath
argument_list|,
name|newBlock
argument_list|,
name|targets
argument_list|,
name|isStriped
argument_list|)
expr_stmt|;
name|persistNewBlock
argument_list|(
name|fsn
argument_list|,
name|src
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pendingFile
operator|.
name|computeFileSize
argument_list|()
expr_stmt|;
comment|// Return located block
return|return
name|makeLocatedBlock
argument_list|(
name|fsn
argument_list|,
name|fsn
operator|.
name|getStoredBlock
argument_list|(
name|newBlock
argument_list|)
argument_list|,
name|targets
argument_list|,
name|offset
argument_list|)
return|;
block|}
DECL|method|chooseTargetForNewBlock ( BlockManager bm, String src, DatanodeInfo[] excludedNodes, String[] favoredNodes, EnumSet<AddBlockFlag> flags, ValidateAddBlockResult r)
specifier|static
name|DatanodeStorageInfo
index|[]
name|chooseTargetForNewBlock
parameter_list|(
name|BlockManager
name|bm
parameter_list|,
name|String
name|src
parameter_list|,
name|DatanodeInfo
index|[]
name|excludedNodes
parameter_list|,
name|String
index|[]
name|favoredNodes
parameter_list|,
name|EnumSet
argument_list|<
name|AddBlockFlag
argument_list|>
name|flags
parameter_list|,
name|ValidateAddBlockResult
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|Node
name|clientNode
init|=
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanodeByHost
argument_list|(
name|r
operator|.
name|clientMachine
argument_list|)
decl_stmt|;
if|if
condition|(
name|clientNode
operator|==
literal|null
condition|)
block|{
name|clientNode
operator|=
name|getClientNode
argument_list|(
name|bm
argument_list|,
name|r
operator|.
name|clientMachine
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodesSet
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|excludedNodes
operator|!=
literal|null
condition|)
block|{
name|excludedNodesSet
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|excludedNodes
operator|.
name|length
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|excludedNodesSet
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|favoredNodesList
init|=
operator|(
name|favoredNodes
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|favoredNodes
argument_list|)
decl_stmt|;
comment|// choose targets for the new block to be allocated.
return|return
name|bm
operator|.
name|chooseTarget4NewBlock
argument_list|(
name|src
argument_list|,
name|r
operator|.
name|numTargets
argument_list|,
name|clientNode
argument_list|,
name|excludedNodesSet
argument_list|,
name|r
operator|.
name|blockSize
argument_list|,
name|favoredNodesList
argument_list|,
name|r
operator|.
name|storagePolicyID
argument_list|,
name|r
operator|.
name|isStriped
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|/**    * Resolve clientmachine address to get a network location path    */
DECL|method|getClientNode (BlockManager bm, String clientMachine)
specifier|static
name|Node
name|getClientNode
parameter_list|(
name|BlockManager
name|bm
parameter_list|,
name|String
name|clientMachine
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|hosts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|hosts
operator|.
name|add
argument_list|(
name|clientMachine
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rName
init|=
name|bm
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|resolveNetworkLocation
argument_list|(
name|hosts
argument_list|)
decl_stmt|;
name|Node
name|clientNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rName
operator|!=
literal|null
condition|)
block|{
comment|// Able to resolve clientMachine mapping.
comment|// Create a temp node to findout the rack local nodes
name|clientNode
operator|=
operator|new
name|NodeBase
argument_list|(
name|rName
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|+
name|NodeBase
operator|.
name|PATH_SEPARATOR_STR
operator|+
name|clientMachine
argument_list|)
expr_stmt|;
block|}
return|return
name|clientNode
return|;
block|}
DECL|method|resolvePathForStartFile (FSDirectory dir, FSPermissionChecker pc, String src, EnumSet<CreateFlag> flag, boolean createParent)
specifier|static
name|INodesInPath
name|resolvePathForStartFile
parameter_list|(
name|FSDirectory
name|dir
parameter_list|,
name|FSPermissionChecker
name|pc
parameter_list|,
name|String
name|src
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
name|INodesInPath
name|iip
init|=
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|DirOp
operator|.
name|CREATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|isPermissionEnabled
argument_list|()
condition|)
block|{
name|dir
operator|.
name|checkAncestorAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
comment|// Verify that the destination does not exist as a directory already.
if|if
condition|(
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|iip
operator|.
name|getPath
argument_list|()
operator|+
literal|" already exists as a directory"
argument_list|)
throw|;
block|}
comment|// Verifies it's indeed a file and perms allow overwrite
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|inode
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|.
name|isPermissionEnabled
argument_list|()
operator|&&
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
condition|)
block|{
name|dir
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|createParent
condition|)
block|{
name|dir
operator|.
name|verifyParentDir
argument_list|(
name|iip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Can't overwrite non-existent "
operator|+
name|src
argument_list|)
throw|;
block|}
block|}
return|return
name|iip
return|;
block|}
comment|/**    * Create a new file or overwrite an existing file<br>    *    * Once the file is create the client then allocates a new block with the next    * call using {@link ClientProtocol#addBlock}.    *<p>    * For description of parameters and exceptions thrown see    * {@link ClientProtocol#create}    */
DECL|method|startFile ( FSNamesystem fsn, INodesInPath iip, PermissionStatus permissions, String holder, String clientMachine, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize, FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks, boolean logRetryEntry)
specifier|static
name|HdfsFileStatus
name|startFile
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|String
name|holder
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|FileEncryptionInfo
name|feInfo
parameter_list|,
name|INode
operator|.
name|BlocksMapUpdateInfo
name|toRemoveBlocks
parameter_list|,
name|boolean
name|logRetryEntry
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsn
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|boolean
name|overwrite
init|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
decl_stmt|;
name|boolean
name|isLazyPersist
init|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|LAZY_PERSIST
argument_list|)
decl_stmt|;
specifier|final
name|String
name|src
init|=
name|iip
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|FSDirectory
name|fsd
init|=
name|fsn
operator|.
name|getFSDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
name|iip
operator|.
name|getLastINode
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|overwrite
condition|)
block|{
name|List
argument_list|<
name|INode
argument_list|>
name|toRemoveINodes
init|=
operator|new
name|ChunkedArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|toRemoveUCFiles
init|=
operator|new
name|ChunkedArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|ret
init|=
name|FSDirDeleteOp
operator|.
name|delete
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
name|toRemoveBlocks
argument_list|,
name|toRemoveINodes
argument_list|,
name|toRemoveUCFiles
argument_list|,
name|now
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|iip
operator|=
name|INodesInPath
operator|.
name|replace
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|FSDirDeleteOp
operator|.
name|incrDeletedFileCount
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|fsn
operator|.
name|removeLeasesAndINodes
argument_list|(
name|toRemoveUCFiles
argument_list|,
name|toRemoveINodes
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If lease soft limit time is expired, recover the lease
name|fsn
operator|.
name|recoverLeaseInternal
argument_list|(
name|FSNamesystem
operator|.
name|RecoverLeaseOp
operator|.
name|CREATE_FILE
argument_list|,
name|iip
argument_list|,
name|src
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|,
literal|false
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|src
operator|+
literal|" for client "
operator|+
name|clientMachine
operator|+
literal|" already exists"
argument_list|)
throw|;
block|}
block|}
name|fsn
operator|.
name|checkFsObjectLimit
argument_list|()
expr_stmt|;
name|INodeFile
name|newNode
init|=
literal|null
decl_stmt|;
name|INodesInPath
name|parent
init|=
name|FSDirMkdirOp
operator|.
name|createAncestorDirectories
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
name|permissions
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|iip
operator|=
name|addFile
argument_list|(
name|fsd
argument_list|,
name|parent
argument_list|,
name|iip
operator|.
name|getLastLocalName
argument_list|()
argument_list|,
name|permissions
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|holder
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
name|newNode
operator|=
name|iip
operator|!=
literal|null
condition|?
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|newNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to add "
operator|+
name|src
operator|+
literal|" to namespace"
argument_list|)
throw|;
block|}
name|fsn
operator|.
name|leaseManager
operator|.
name|addLease
argument_list|(
name|newNode
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientName
argument_list|()
argument_list|,
name|newNode
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|feInfo
operator|!=
literal|null
condition|)
block|{
name|FSDirEncryptionZoneOp
operator|.
name|setFileEncryptionInfo
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
name|feInfo
argument_list|)
expr_stmt|;
block|}
name|setNewINodeStoragePolicy
argument_list|(
name|fsd
operator|.
name|getBlockManager
argument_list|()
argument_list|,
name|iip
argument_list|,
name|isLazyPersist
argument_list|)
expr_stmt|;
name|fsd
operator|.
name|getEditLog
argument_list|()
operator|.
name|logOpenFile
argument_list|(
name|src
argument_list|,
name|newNode
argument_list|,
name|overwrite
argument_list|,
name|logRetryEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.startFile: added "
operator|+
name|src
operator|+
literal|" inode "
operator|+
name|newNode
operator|.
name|getId
argument_list|()
operator|+
literal|" "
operator|+
name|holder
argument_list|)
expr_stmt|;
block|}
return|return
name|FSDirStatAndListingOp
operator|.
name|getFileInfo
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|)
return|;
block|}
DECL|method|addFileForEditLog ( FSDirectory fsd, long id, INodesInPath existing, byte[] localName, PermissionStatus permissions, List<AclEntry> aclEntries, List<XAttr> xAttrs, short replication, long modificationTime, long atime, long preferredBlockSize, boolean underConstruction, String clientName, String clientMachine, byte storagePolicyId)
specifier|static
name|INodeFile
name|addFileForEditLog
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|long
name|id
parameter_list|,
name|INodesInPath
name|existing
parameter_list|,
name|byte
index|[]
name|localName
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclEntries
parameter_list|,
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|modificationTime
parameter_list|,
name|long
name|atime
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|boolean
name|underConstruction
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|byte
name|storagePolicyId
parameter_list|)
block|{
specifier|final
name|INodeFile
name|newNode
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|existing
argument_list|)
expr_stmt|;
assert|assert
name|fsd
operator|.
name|hasWriteLock
argument_list|()
assert|;
try|try
block|{
comment|// check if the file has an EC policy
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|FSDirErasureCodingOp
operator|.
name|getErasureCodingPolicy
argument_list|(
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
argument_list|,
name|existing
argument_list|)
decl_stmt|;
if|if
condition|(
name|ecPolicy
operator|!=
literal|null
condition|)
block|{
name|replication
operator|=
name|ecPolicy
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|underConstruction
condition|)
block|{
name|newNode
operator|=
name|newINodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|modificationTime
argument_list|,
name|modificationTime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|storagePolicyId
argument_list|,
name|ecPolicy
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|toUnderConstruction
argument_list|(
name|clientName
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNode
operator|=
name|newINodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|modificationTime
argument_list|,
name|atime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|storagePolicyId
argument_list|,
name|ecPolicy
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
name|newNode
operator|.
name|setLocalName
argument_list|(
name|localName
argument_list|)
expr_stmt|;
name|INodesInPath
name|iip
init|=
name|fsd
operator|.
name|addINode
argument_list|(
name|existing
argument_list|,
name|newNode
argument_list|,
name|permissions
operator|.
name|getPermission
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|iip
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|aclEntries
operator|!=
literal|null
condition|)
block|{
name|AclStorage
operator|.
name|updateINodeAcl
argument_list|(
name|newNode
argument_list|,
name|aclEntries
argument_list|,
name|CURRENT_STATE_ID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xAttrs
operator|!=
literal|null
condition|)
block|{
name|XAttrStorage
operator|.
name|updateINodeXAttrs
argument_list|(
name|newNode
argument_list|,
name|xAttrs
argument_list|,
name|CURRENT_STATE_ID
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedAddFile: exception when add "
operator|+
name|existing
operator|.
name|getPath
argument_list|()
operator|+
literal|" to the file system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|FSLimitException
operator|.
name|MaxDirectoryItemsExceededException
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"Please increase "
operator|+
literal|"dfs.namenode.fs-limits.max-directory-items and make it "
operator|+
literal|"consistent across all NameNodes."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Add a block to the file. Returns a reference to the added block.    */
DECL|method|addBlock (FSDirectory fsd, String path, INodesInPath inodesInPath, Block block, DatanodeStorageInfo[] targets, boolean isStriped)
specifier|private
specifier|static
name|BlockInfo
name|addBlock
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|path
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|Block
name|block
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|,
name|boolean
name|isStriped
parameter_list|)
throws|throws
name|IOException
block|{
name|fsd
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodeFile
name|fileINode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
comment|// associate new last block for the file
specifier|final
name|BlockInfo
name|blockInfo
decl_stmt|;
if|if
condition|(
name|isStriped
condition|)
block|{
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|FSDirErasureCodingOp
operator|.
name|getErasureCodingPolicy
argument_list|(
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
argument_list|,
name|inodesInPath
argument_list|)
decl_stmt|;
name|short
name|numDataUnits
init|=
operator|(
name|short
operator|)
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|short
name|numParityUnits
init|=
operator|(
name|short
operator|)
name|ecPolicy
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
name|short
name|numLocations
init|=
call|(
name|short
call|)
argument_list|(
name|numDataUnits
operator|+
name|numParityUnits
argument_list|)
decl_stmt|;
comment|// check quota limits and updated space consumed
name|fsd
operator|.
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
literal|0
argument_list|,
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|,
name|numLocations
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|blockInfo
operator|=
operator|new
name|BlockInfoStriped
argument_list|(
name|block
argument_list|,
name|ecPolicy
argument_list|)
expr_stmt|;
name|blockInfo
operator|.
name|convertToBlockUnderConstruction
argument_list|(
name|HdfsServerConstants
operator|.
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
argument_list|,
name|targets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// check quota limits and updated space consumed
name|fsd
operator|.
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
literal|0
argument_list|,
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|,
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|short
name|numLocations
init|=
name|fileINode
operator|.
name|getFileReplication
argument_list|()
decl_stmt|;
name|blockInfo
operator|=
operator|new
name|BlockInfoContiguous
argument_list|(
name|block
argument_list|,
name|numLocations
argument_list|)
expr_stmt|;
name|blockInfo
operator|.
name|convertToBlockUnderConstruction
argument_list|(
name|HdfsServerConstants
operator|.
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
argument_list|,
name|targets
argument_list|)
expr_stmt|;
block|}
name|fsd
operator|.
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|fileINode
argument_list|)
expr_stmt|;
name|fileINode
operator|.
name|addBlock
argument_list|(
name|blockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.addBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is added to the in-memory "
operator|+
literal|"file system"
argument_list|)
expr_stmt|;
block|}
return|return
name|blockInfo
return|;
block|}
finally|finally
block|{
name|fsd
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Add the given filename to the fs.    * @return the new INodesInPath instance that contains the new INode    */
DECL|method|addFile ( FSDirectory fsd, INodesInPath existing, byte[] localName, PermissionStatus permissions, short replication, long preferredBlockSize, String clientName, String clientMachine)
specifier|private
specifier|static
name|INodesInPath
name|addFile
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|INodesInPath
name|existing
parameter_list|,
name|byte
index|[]
name|localName
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|existing
argument_list|)
expr_stmt|;
name|long
name|modTime
init|=
name|now
argument_list|()
decl_stmt|;
name|INodesInPath
name|newiip
decl_stmt|;
name|fsd
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|FSDirErasureCodingOp
operator|.
name|getErasureCodingPolicy
argument_list|(
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
argument_list|,
name|existing
argument_list|)
decl_stmt|;
if|if
condition|(
name|ecPolicy
operator|!=
literal|null
condition|)
block|{
name|replication
operator|=
name|ecPolicy
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
name|INodeFile
name|newNode
init|=
name|newINodeFile
argument_list|(
name|fsd
operator|.
name|allocateNewInodeId
argument_list|()
argument_list|,
name|permissions
argument_list|,
name|modTime
argument_list|,
name|modTime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|ecPolicy
operator|!=
literal|null
argument_list|)
decl_stmt|;
name|newNode
operator|.
name|setLocalName
argument_list|(
name|localName
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|toUnderConstruction
argument_list|(
name|clientName
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
name|newiip
operator|=
name|fsd
operator|.
name|addINode
argument_list|(
name|existing
argument_list|,
name|newNode
argument_list|,
name|permissions
operator|.
name|getPermission
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|fsd
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|newiip
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* addFile: failed to add "
operator|+
name|existing
operator|.
name|getPath
argument_list|()
operator|+
literal|"/"
operator|+
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|localName
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* addFile: "
operator|+
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|localName
argument_list|)
operator|+
literal|" is added"
argument_list|)
expr_stmt|;
block|}
return|return
name|newiip
return|;
block|}
DECL|method|analyzeFileState ( FSNamesystem fsn, INodesInPath iip, long fileId, String clientName, ExtendedBlock previous, LocatedBlock[] onRetryBlock)
specifier|private
specifier|static
name|FileState
name|analyzeFileState
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|long
name|fileId
parameter_list|,
name|String
name|clientName
parameter_list|,
name|ExtendedBlock
name|previous
parameter_list|,
name|LocatedBlock
index|[]
name|onRetryBlock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsn
operator|.
name|hasReadLock
argument_list|()
assert|;
name|String
name|src
init|=
name|iip
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|checkBlock
argument_list|(
name|fsn
argument_list|,
name|previous
argument_list|)
expr_stmt|;
name|onRetryBlock
index|[
literal|0
index|]
operator|=
literal|null
expr_stmt|;
name|fsn
operator|.
name|checkNameNodeSafeMode
argument_list|(
literal|"Cannot add block to "
operator|+
name|src
argument_list|)
expr_stmt|;
comment|// have we exceeded the configured limit of fs objects.
name|fsn
operator|.
name|checkFsObjectLimit
argument_list|()
expr_stmt|;
name|Block
name|previousBlock
init|=
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|previous
argument_list|)
decl_stmt|;
specifier|final
name|INodeFile
name|file
init|=
name|fsn
operator|.
name|checkLease
argument_list|(
name|iip
argument_list|,
name|clientName
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
name|BlockInfo
name|lastBlockInFile
init|=
name|file
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|previousBlock
argument_list|,
name|lastBlockInFile
argument_list|)
condition|)
block|{
comment|// The block that the client claims is the current last block
comment|// doesn't match up with what we think is the last block. There are
comment|// four possibilities:
comment|// 1) This is the first block allocation of an append() pipeline
comment|//    which started appending exactly at or exceeding the block boundary.
comment|//    In this case, the client isn't passed the previous block,
comment|//    so it makes the allocateBlock() call with previous=null.
comment|//    We can distinguish this since the last block of the file
comment|//    will be exactly a full block.
comment|// 2) This is a retry from a client that missed the response of a
comment|//    prior getAdditionalBlock() call, perhaps because of a network
comment|//    timeout, or because of an HA failover. In that case, we know
comment|//    by the fact that the client is re-issuing the RPC that it
comment|//    never began to write to the old block. Hence it is safe to
comment|//    to return the existing block.
comment|// 3) This is an entirely bogus request/bug -- we should error out
comment|//    rather than potentially appending a new block with an empty
comment|//    one in the middle, etc
comment|// 4) This is a retry from a client that timed out while
comment|//    the prior getAdditionalBlock() is still being processed,
comment|//    currently working on chooseTarget().
comment|//    There are no means to distinguish between the first and
comment|//    the second attempts in Part I, because the first one hasn't
comment|//    changed the namesystem state yet.
comment|//    We run this analysis again in Part II where case 4 is impossible.
name|BlockInfo
name|penultimateBlock
init|=
name|file
operator|.
name|getPenultimateBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|==
literal|null
operator|&&
name|lastBlockInFile
operator|!=
literal|null
operator|&&
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|>=
name|file
operator|.
name|getPreferredBlockSize
argument_list|()
operator|&&
name|lastBlockInFile
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|// Case 1
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.allocateBlock: handling block allocation"
operator|+
literal|" writing to a file with a complete previous block: src="
operator|+
name|src
operator|+
literal|" lastBlock="
operator|+
name|lastBlockInFile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|penultimateBlock
argument_list|,
name|previousBlock
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Request looked like a retry to allocate block "
operator|+
name|lastBlockInFile
operator|+
literal|" but it already contains "
operator|+
name|lastBlockInFile
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
comment|// Case 2
comment|// Return the last block.
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* allocateBlock: caught retry for "
operator|+
literal|"allocation of a new block in "
operator|+
name|src
operator|+
literal|". Returning previously"
operator|+
literal|" allocated block "
operator|+
name|lastBlockInFile
argument_list|)
expr_stmt|;
name|long
name|offset
init|=
name|file
operator|.
name|computeFileSize
argument_list|()
decl_stmt|;
name|BlockUnderConstructionFeature
name|uc
init|=
name|lastBlockInFile
operator|.
name|getUnderConstructionFeature
argument_list|()
decl_stmt|;
name|onRetryBlock
index|[
literal|0
index|]
operator|=
name|makeLocatedBlock
argument_list|(
name|fsn
argument_list|,
name|lastBlockInFile
argument_list|,
name|uc
operator|.
name|getExpectedStorageLocations
argument_list|()
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|new
name|FileState
argument_list|(
name|file
argument_list|,
name|src
argument_list|,
name|iip
argument_list|)
return|;
block|}
else|else
block|{
comment|// Case 3
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot allocate block in "
operator|+
name|src
operator|+
literal|": "
operator|+
literal|"passed 'previous' block "
operator|+
name|previous
operator|+
literal|" does not match actual "
operator|+
literal|"last block in file "
operator|+
name|lastBlockInFile
argument_list|)
throw|;
block|}
block|}
return|return
operator|new
name|FileState
argument_list|(
name|file
argument_list|,
name|src
argument_list|,
name|iip
argument_list|)
return|;
block|}
DECL|method|completeFile (FSNamesystem fsn, FSPermissionChecker pc, final String srcArg, String holder, ExtendedBlock last, long fileId)
specifier|static
name|boolean
name|completeFile
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|FSPermissionChecker
name|pc
parameter_list|,
specifier|final
name|String
name|srcArg
parameter_list|,
name|String
name|holder
parameter_list|,
name|ExtendedBlock
name|last
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|src
init|=
name|srcArg
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* NameSystem.completeFile: "
operator|+
name|src
operator|+
literal|" for "
operator|+
name|holder
argument_list|)
expr_stmt|;
block|}
name|checkBlock
argument_list|(
name|fsn
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|INodesInPath
name|iip
init|=
name|fsn
operator|.
name|dir
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|fileId
argument_list|)
decl_stmt|;
return|return
name|completeFileInternal
argument_list|(
name|fsn
argument_list|,
name|iip
argument_list|,
name|holder
argument_list|,
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|last
argument_list|)
argument_list|,
name|fileId
argument_list|)
return|;
block|}
DECL|method|completeFileInternal ( FSNamesystem fsn, INodesInPath iip, String holder, Block last, long fileId)
specifier|private
specifier|static
name|boolean
name|completeFileInternal
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|String
name|holder
parameter_list|,
name|Block
name|last
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsn
operator|.
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|String
name|src
init|=
name|iip
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|INodeFile
name|pendingFile
decl_stmt|;
name|INode
name|inode
init|=
literal|null
decl_stmt|;
try|try
block|{
name|inode
operator|=
name|iip
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
name|pendingFile
operator|=
name|fsn
operator|.
name|checkLease
argument_list|(
name|iip
argument_list|,
name|holder
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseExpiredException
name|lee
parameter_list|)
block|{
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|.
name|isFile
argument_list|()
operator|&&
operator|!
name|inode
operator|.
name|asFile
argument_list|()
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
comment|// This could be a retry RPC - i.e the client tried to close
comment|// the file, but missed the RPC response. Thus, it is trying
comment|// again to close the file. If the file still exists and
comment|// the client's view of the last block matches the actual
comment|// last block, then we'll treat it as a successful close.
comment|// See HDFS-3031.
specifier|final
name|Block
name|realLastBlock
init|=
name|inode
operator|.
name|asFile
argument_list|()
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|last
argument_list|,
name|realLastBlock
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* completeFile: "
operator|+
literal|"request from "
operator|+
name|holder
operator|+
literal|" to complete inode "
operator|+
name|fileId
operator|+
literal|"("
operator|+
name|src
operator|+
literal|") which is already closed. But, it appears to be "
operator|+
literal|"an RPC retry. Returning success"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
throw|throw
name|lee
throw|;
block|}
comment|// Check the state of the penultimate block. It should be completed
comment|// before attempting to complete the last one.
if|if
condition|(
operator|!
name|fsn
operator|.
name|checkFileProgress
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// commit the last block and complete it if it has minimum replicas
name|fsn
operator|.
name|commitOrCompleteLastBlock
argument_list|(
name|pendingFile
argument_list|,
name|iip
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsn
operator|.
name|checkFileProgress
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|fsn
operator|.
name|addCommittedBlocksToPending
argument_list|(
name|pendingFile
argument_list|)
expr_stmt|;
name|fsn
operator|.
name|finalizeINodeFileUnderConstruction
argument_list|(
name|src
argument_list|,
name|pendingFile
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|newINodeFile ( long id, PermissionStatus permissions, long mtime, long atime, short replication, long preferredBlockSize, byte storagePolicyId, boolean isStriped)
specifier|private
specifier|static
name|INodeFile
name|newINodeFile
parameter_list|(
name|long
name|id
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|byte
name|storagePolicyId
parameter_list|,
name|boolean
name|isStriped
parameter_list|)
block|{
return|return
operator|new
name|INodeFile
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|permissions
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|BlockInfo
operator|.
name|EMPTY_ARRAY
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|storagePolicyId
argument_list|,
name|isStriped
argument_list|)
return|;
block|}
DECL|method|newINodeFile (long id, PermissionStatus permissions, long mtime, long atime, short replication, long preferredBlockSize, boolean isStriped)
specifier|private
specifier|static
name|INodeFile
name|newINodeFile
parameter_list|(
name|long
name|id
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|boolean
name|isStriped
parameter_list|)
block|{
return|return
name|newINodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
name|isStriped
argument_list|)
return|;
block|}
comment|/**    * Persist the new block (the last block of the given file).    */
DECL|method|persistNewBlock ( FSNamesystem fsn, String path, INodeFile file)
specifier|private
specifier|static
name|void
name|persistNewBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|file
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|fsn
operator|.
name|getEditLog
argument_list|()
operator|.
name|logAddBlock
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"persistNewBlock: "
operator|+
name|path
operator|+
literal|" with new block "
operator|+
name|file
operator|.
name|getLastBlock
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|", current total block count is "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Save allocated block at the given pending filename    *    * @param fsn FSNamesystem    * @param src path to the file    * @param inodesInPath representing each of the components of src.    *                     The last INode is the INode for {@code src} file.    * @param newBlock newly allocated block to be save    * @param targets target datanodes where replicas of the new block is placed    * @throws QuotaExceededException If addition of block exceeds space quota    */
DECL|method|saveAllocatedBlock (FSNamesystem fsn, String src, INodesInPath inodesInPath, Block newBlock, DatanodeStorageInfo[] targets, boolean isStriped)
specifier|private
specifier|static
name|void
name|saveAllocatedBlock
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|String
name|src
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|Block
name|newBlock
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|,
name|boolean
name|isStriped
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsn
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|BlockInfo
name|b
init|=
name|addBlock
argument_list|(
name|fsn
operator|.
name|dir
argument_list|,
name|src
argument_list|,
name|inodesInPath
argument_list|,
name|newBlock
argument_list|,
name|targets
argument_list|,
name|isStriped
argument_list|)
decl_stmt|;
name|logAllocatedBlock
argument_list|(
name|src
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|DatanodeStorageInfo
operator|.
name|incrementBlocksScheduled
argument_list|(
name|targets
argument_list|)
expr_stmt|;
block|}
DECL|method|logAllocatedBlock (String src, BlockInfo b)
specifier|private
specifier|static
name|void
name|logAllocatedBlock
parameter_list|(
name|String
name|src
parameter_list|,
name|BlockInfo
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|150
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"BLOCK* allocate "
argument_list|)
expr_stmt|;
name|b
operator|.
name|appendStringTo
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|BlockUnderConstructionFeature
name|uc
init|=
name|b
operator|.
name|getUnderConstructionFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|null
condition|)
block|{
name|uc
operator|.
name|appendUCPartsConcise
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|" for "
operator|+
name|src
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setNewINodeStoragePolicy (BlockManager bm, INodesInPath iip, boolean isLazyPersist)
specifier|private
specifier|static
name|void
name|setNewINodeStoragePolicy
parameter_list|(
name|BlockManager
name|bm
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|boolean
name|isLazyPersist
parameter_list|)
throws|throws
name|IOException
block|{
name|INodeFile
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|isLazyPersist
condition|)
block|{
name|BlockStoragePolicy
name|lpPolicy
init|=
name|bm
operator|.
name|getStoragePolicy
argument_list|(
literal|"LAZY_PERSIST"
argument_list|)
decl_stmt|;
comment|// Set LAZY_PERSIST storage policy if the flag was passed to
comment|// CreateFile.
if|if
condition|(
name|lpPolicy
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"The LAZY_PERSIST storage policy has been disabled "
operator|+
literal|"by the administrator."
argument_list|)
throw|;
block|}
name|inode
operator|.
name|setStoragePolicyID
argument_list|(
name|lpPolicy
operator|.
name|getId
argument_list|()
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BlockStoragePolicy
name|effectivePolicy
init|=
name|bm
operator|.
name|getStoragePolicy
argument_list|(
name|inode
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|effectivePolicy
operator|!=
literal|null
operator|&&
name|effectivePolicy
operator|.
name|isCopyOnCreateFile
argument_list|()
condition|)
block|{
comment|// Copy effective policy from ancestor directory to current file.
name|inode
operator|.
name|setStoragePolicyID
argument_list|(
name|effectivePolicy
operator|.
name|getId
argument_list|()
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|FileState
specifier|private
specifier|static
class|class
name|FileState
block|{
DECL|field|inode
specifier|final
name|INodeFile
name|inode
decl_stmt|;
DECL|field|path
specifier|final
name|String
name|path
decl_stmt|;
DECL|field|iip
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
DECL|method|FileState (INodeFile inode, String fullPath, INodesInPath iip)
name|FileState
parameter_list|(
name|INodeFile
name|inode
parameter_list|,
name|String
name|fullPath
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
block|{
name|this
operator|.
name|inode
operator|=
name|inode
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|fullPath
expr_stmt|;
name|this
operator|.
name|iip
operator|=
name|iip
expr_stmt|;
block|}
block|}
DECL|class|ValidateAddBlockResult
specifier|static
class|class
name|ValidateAddBlockResult
block|{
DECL|field|blockSize
specifier|final
name|long
name|blockSize
decl_stmt|;
DECL|field|numTargets
specifier|final
name|int
name|numTargets
decl_stmt|;
DECL|field|storagePolicyID
specifier|final
name|byte
name|storagePolicyID
decl_stmt|;
DECL|field|clientMachine
specifier|final
name|String
name|clientMachine
decl_stmt|;
DECL|field|isStriped
specifier|final
name|boolean
name|isStriped
decl_stmt|;
DECL|method|ValidateAddBlockResult ( long blockSize, int numTargets, byte storagePolicyID, String clientMachine, boolean isStriped)
name|ValidateAddBlockResult
parameter_list|(
name|long
name|blockSize
parameter_list|,
name|int
name|numTargets
parameter_list|,
name|byte
name|storagePolicyID
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|boolean
name|isStriped
parameter_list|)
block|{
name|this
operator|.
name|blockSize
operator|=
name|blockSize
expr_stmt|;
name|this
operator|.
name|numTargets
operator|=
name|numTargets
expr_stmt|;
name|this
operator|.
name|storagePolicyID
operator|=
name|storagePolicyID
expr_stmt|;
name|this
operator|.
name|clientMachine
operator|=
name|clientMachine
expr_stmt|;
name|this
operator|.
name|isStriped
operator|=
name|isStriped
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

