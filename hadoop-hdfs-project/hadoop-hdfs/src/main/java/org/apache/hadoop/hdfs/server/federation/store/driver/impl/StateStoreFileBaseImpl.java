begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.federation.store.driver.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|driver
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreUtils
operator|.
name|filterMultiple
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreUtils
operator|.
name|getRecordClass
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|StateStoreUnavailableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|driver
operator|.
name|StateStoreDriver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|BaseRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|QueryResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * {@link StateStoreDriver} implementation based on a local file.  */
end_comment

begin_class
DECL|class|StateStoreFileBaseImpl
specifier|public
specifier|abstract
class|class
name|StateStoreFileBaseImpl
extends|extends
name|StateStoreSerializableImpl
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StateStoreFileBaseImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** If it is initialized. */
DECL|field|initialized
specifier|private
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
comment|/** Name of the file containing the data. */
DECL|field|DATA_FILE_NAME
specifier|private
specifier|static
specifier|final
name|String
name|DATA_FILE_NAME
init|=
literal|"records.data"
decl_stmt|;
comment|/**    * Lock reading records.    *    * @param clazz Class of the record.    */
DECL|method|lockRecordRead (Class<T> clazz)
specifier|protected
specifier|abstract
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|void
name|lockRecordRead
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
function_decl|;
comment|/**    * Unlock reading records.    *    * @param clazz Class of the record.    */
DECL|method|unlockRecordRead ( Class<T> clazz)
specifier|protected
specifier|abstract
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|void
name|unlockRecordRead
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
function_decl|;
comment|/**    * Lock writing records.    *    * @param clazz Class of the record.    */
DECL|method|lockRecordWrite ( Class<T> clazz)
specifier|protected
specifier|abstract
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|void
name|lockRecordWrite
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
function_decl|;
comment|/**    * Unlock writing records.    *    * @param clazz Class of the record.    */
DECL|method|unlockRecordWrite ( Class<T> clazz)
specifier|protected
specifier|abstract
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|void
name|unlockRecordWrite
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
function_decl|;
comment|/**    * Get the reader for the file system.    *    * @param clazz Class of the record.    */
DECL|method|getReader ( Class<T> clazz, String sub)
specifier|protected
specifier|abstract
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|BufferedReader
name|getReader
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|String
name|sub
parameter_list|)
function_decl|;
comment|/**    * Get the writer for the file system.    *    * @param clazz Class of the record.    */
DECL|method|getWriter ( Class<T> clazz, String sub)
specifier|protected
specifier|abstract
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|BufferedWriter
name|getWriter
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|String
name|sub
parameter_list|)
function_decl|;
comment|/**    * Check if a path exists.    *    * @param path Path to check.    * @return If the path exists.    */
DECL|method|exists (String path)
specifier|protected
specifier|abstract
name|boolean
name|exists
parameter_list|(
name|String
name|path
parameter_list|)
function_decl|;
comment|/**    * Make a directory.    *    * @param path Path of the directory to create.    * @return If the directory was created.    */
DECL|method|mkdir (String path)
specifier|protected
specifier|abstract
name|boolean
name|mkdir
parameter_list|(
name|String
name|path
parameter_list|)
function_decl|;
comment|/**    * Get root directory.    *    * @return Root directory.    */
DECL|method|getRootDir ()
specifier|protected
specifier|abstract
name|String
name|getRootDir
parameter_list|()
function_decl|;
comment|/**    * Set the driver as initialized.    *    * @param ini If the driver is initialized.    */
DECL|method|setInitialized (boolean ini)
specifier|public
name|void
name|setInitialized
parameter_list|(
name|boolean
name|ini
parameter_list|)
block|{
name|this
operator|.
name|initialized
operator|=
name|ini
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|initDriver ()
specifier|public
name|boolean
name|initDriver
parameter_list|()
block|{
name|String
name|rootDir
init|=
name|getRootDir
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|rootDir
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid root directory, unable to initialize driver."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Check root path
if|if
condition|(
operator|!
name|exists
argument_list|(
name|rootDir
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mkdir
argument_list|(
name|rootDir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot create State Store root directory {}"
argument_list|,
name|rootDir
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot initialize filesystem using root directory {}"
argument_list|,
name|rootDir
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|setInitialized
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|initRecordStorage ( String className, Class<T> recordClass)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|boolean
name|initRecordStorage
parameter_list|(
name|String
name|className
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|recordClass
parameter_list|)
block|{
name|String
name|dataDirPath
init|=
name|getRootDir
argument_list|()
operator|+
literal|"/"
operator|+
name|className
decl_stmt|;
try|try
block|{
comment|// Create data directories for files
if|if
condition|(
operator|!
name|exists
argument_list|(
name|dataDirPath
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} data directory doesn't exist, creating it"
argument_list|,
name|dataDirPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mkdir
argument_list|(
name|dataDirPath
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot create data directory {}"
argument_list|,
name|dataDirPath
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|String
name|dataFilePath
init|=
name|dataDirPath
operator|+
literal|"/"
operator|+
name|DATA_FILE_NAME
decl_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|dataFilePath
argument_list|)
condition|)
block|{
comment|// Create empty file
name|List
argument_list|<
name|T
argument_list|>
name|emtpyList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|writeAll
argument_list|(
name|emtpyList
argument_list|,
name|recordClass
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot create data file {}"
argument_list|,
name|dataFilePath
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot create data directory {}"
argument_list|,
name|dataDirPath
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Read all lines from a file and deserialize into the desired record type.    *    * @param reader Open handle for the file.    * @param clazz Record class to create.    * @param includeDates True if dateModified/dateCreated are serialized.    * @return List of records.    * @throws IOException    */
DECL|method|getAllFile ( BufferedReader reader, Class<T> clazz, boolean includeDates)
specifier|private
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|getAllFile
parameter_list|(
name|BufferedReader
name|reader
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|boolean
name|includeDates
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|T
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|line
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
operator|&&
name|line
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|T
name|record
init|=
name|newRecord
argument_list|(
name|line
argument_list|,
name|clazz
argument_list|,
name|includeDates
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|record
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot parse line in data source file: {}"
argument_list|,
name|line
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|get (Class<T> clazz)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|QueryResult
argument_list|<
name|T
argument_list|>
name|get
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|get
argument_list|(
name|clazz
argument_list|,
operator|(
name|String
operator|)
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get (Class<T> clazz, String sub)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|QueryResult
argument_list|<
name|T
argument_list|>
name|get
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|String
name|sub
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyDriverReady
argument_list|()
expr_stmt|;
name|BufferedReader
name|reader
init|=
literal|null
decl_stmt|;
name|lockRecordRead
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
try|try
block|{
name|reader
operator|=
name|getReader
argument_list|(
name|clazz
argument_list|,
name|sub
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|data
init|=
name|getAllFile
argument_list|(
name|reader
argument_list|,
name|clazz
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|QueryResult
argument_list|<
name|T
argument_list|>
argument_list|(
name|data
argument_list|,
name|getTime
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot fetch records {}"
argument_list|,
name|clazz
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot read from data store "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed closing file"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|unlockRecordRead
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Overwrite the existing data with a new data set.    *    * @param records List of records to write.    * @param writer BufferedWriter stream to write to.    * @return If the records were succesfully written.    */
DECL|method|writeAllFile ( Collection<T> records, BufferedWriter writer)
specifier|private
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|boolean
name|writeAllFile
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|records
parameter_list|,
name|BufferedWriter
name|writer
parameter_list|)
block|{
try|try
block|{
for|for
control|(
name|BaseRecord
name|record
range|:
name|records
control|)
block|{
try|try
block|{
name|String
name|data
init|=
name|serializeString
argument_list|(
name|record
argument_list|)
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|writer
operator|.
name|newLine
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot write record {} to file"
argument_list|,
name|record
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
name|writer
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot commit records to file"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Overwrite the existing data with a new data set. Replaces all records in    * the data store for this record class. If all records in the data store are    * not successfully committed, this function must return false and leave the    * data store unchanged.    *    * @param records List of records to write. All records must be of type    *                recordClass.    * @param recordClass Class of record to replace.    * @return true if all operations were successful, false otherwise.    * @throws StateStoreUnavailableException    */
DECL|method|writeAll ( Collection<T> records, Class<T> recordClass)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|boolean
name|writeAll
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|records
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|recordClass
parameter_list|)
throws|throws
name|StateStoreUnavailableException
block|{
name|verifyDriverReady
argument_list|()
expr_stmt|;
name|lockRecordWrite
argument_list|(
name|recordClass
argument_list|)
expr_stmt|;
name|BufferedWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|getWriter
argument_list|(
name|recordClass
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|writeAllFile
argument_list|(
name|records
argument_list|,
name|writer
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot add records to file for {}"
argument_list|,
name|recordClass
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot close writer for {}"
argument_list|,
name|recordClass
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|unlockRecordWrite
argument_list|(
name|recordClass
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the data file name.    *    * @return Data file name.    */
DECL|method|getDataFileName ()
specifier|protected
name|String
name|getDataFileName
parameter_list|()
block|{
return|return
name|DATA_FILE_NAME
return|;
block|}
annotation|@
name|Override
DECL|method|isDriverReady ()
specifier|public
name|boolean
name|isDriverReady
parameter_list|()
block|{
return|return
name|this
operator|.
name|initialized
return|;
block|}
annotation|@
name|Override
DECL|method|putAll ( List<T> records, boolean allowUpdate, boolean errorIfExists)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|boolean
name|putAll
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|records
parameter_list|,
name|boolean
name|allowUpdate
parameter_list|,
name|boolean
name|errorIfExists
parameter_list|)
throws|throws
name|StateStoreUnavailableException
block|{
name|verifyDriverReady
argument_list|()
expr_stmt|;
if|if
condition|(
name|records
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
init|=
operator|(
name|Class
argument_list|<
name|T
argument_list|>
operator|)
name|getRecordClass
argument_list|(
name|records
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
name|QueryResult
argument_list|<
name|T
argument_list|>
name|result
decl_stmt|;
try|try
block|{
name|result
operator|=
name|get
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
name|Map
argument_list|<
name|Object
argument_list|,
name|T
argument_list|>
name|writeList
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Write all of the existing records
for|for
control|(
name|T
name|existingRecord
range|:
name|result
operator|.
name|getRecords
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|existingRecord
operator|.
name|getPrimaryKey
argument_list|()
decl_stmt|;
name|writeList
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|existingRecord
argument_list|)
expr_stmt|;
block|}
comment|// Add inserts and updates, overwrite any existing values
for|for
control|(
name|T
name|updatedRecord
range|:
name|records
control|)
block|{
try|try
block|{
name|updatedRecord
operator|.
name|validate
argument_list|()
expr_stmt|;
name|String
name|key
init|=
name|updatedRecord
operator|.
name|getPrimaryKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|writeList
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|&&
name|allowUpdate
condition|)
block|{
comment|// Update
name|writeList
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|updatedRecord
argument_list|)
expr_stmt|;
comment|// Update the mod time stamp. Many backends will use their
comment|// own timestamp for the mod time.
name|updatedRecord
operator|.
name|setDateModified
argument_list|(
name|this
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|writeList
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// Insert
comment|// Create/Mod timestamps are already initialized
name|writeList
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|updatedRecord
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errorIfExists
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Attempt to insert record {} that already exists"
argument_list|,
name|updatedRecord
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot write invalid record to State Store"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// Write all
name|boolean
name|status
init|=
name|writeAll
argument_list|(
name|writeList
operator|.
name|values
argument_list|()
argument_list|,
name|clazz
argument_list|)
decl_stmt|;
return|return
name|status
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Class<T> clazz, Query<T> query)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|int
name|remove
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|Query
argument_list|<
name|T
argument_list|>
name|query
parameter_list|)
throws|throws
name|StateStoreUnavailableException
block|{
name|verifyDriverReady
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|removed
init|=
literal|0
decl_stmt|;
comment|// Get the current records
try|try
block|{
specifier|final
name|QueryResult
argument_list|<
name|T
argument_list|>
name|result
init|=
name|get
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|existingRecords
init|=
name|result
operator|.
name|getRecords
argument_list|()
decl_stmt|;
comment|// Write all of the existing records except those to be removed
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|recordsToRemove
init|=
name|filterMultiple
argument_list|(
name|query
argument_list|,
name|existingRecords
argument_list|)
decl_stmt|;
name|removed
operator|=
name|recordsToRemove
operator|.
name|size
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|newRecords
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|record
range|:
name|existingRecords
control|)
block|{
if|if
condition|(
operator|!
name|recordsToRemove
operator|.
name|contains
argument_list|(
name|record
argument_list|)
condition|)
block|{
name|newRecords
operator|.
name|add
argument_list|(
name|record
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|writeAll
argument_list|(
name|newRecords
argument_list|,
name|clazz
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot remove record "
operator|+
name|clazz
operator|+
literal|" query "
operator|+
name|query
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot remove records {} query {}"
argument_list|,
name|clazz
argument_list|,
name|query
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Class<T> clazz)
specifier|public
parameter_list|<
name|T
extends|extends
name|BaseRecord
parameter_list|>
name|boolean
name|removeAll
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|StateStoreUnavailableException
block|{
name|verifyDriverReady
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|emptyList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|status
init|=
name|writeAll
argument_list|(
name|emptyList
argument_list|,
name|clazz
argument_list|)
decl_stmt|;
return|return
name|status
return|;
block|}
block|}
end_class

end_unit

