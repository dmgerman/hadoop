begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.tools.offlineImageViewer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|tools
operator|.
name|offlineImageViewer
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|text
operator|.
name|StringEscapeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatPBINode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatProtobuf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageFormatProtobuf
operator|.
name|SectionName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|FileSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|INodeSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FsImageProto
operator|.
name|INodeSection
operator|.
name|INode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|SerialNumberManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LimitInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fusesource
operator|.
name|leveldbjni
operator|.
name|JniDBFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|DB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|WriteBatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * This class reads the protobuf-based fsimage and generates text output  * for each inode to {@link PBImageTextWriter#out}. The sub-class can override  * {@link getEntry()} to generate formatted string for each inode.  *  * Since protobuf-based fsimage does not guarantee the order of inodes and  * directories, PBImageTextWriter runs two-phase scans:  *  *<ol>  *<li>The first phase, PBImageTextWriter scans the INode sections to reads the  *   filename of each directory. It also scans the INode_Dir sections to loads  *   the relationships between a directory and its children. It uses these metadata  *   to build FS namespace and stored in {@link MetadataMap}</li>  *<li>The second phase, PBImageTextWriter re-scans the INode sections. For each  *   inode, it looks up the path of the parent directory in the {@link MetadataMap},  *   and generate output.</li>  *</ol>  *  * Two various of {@link MetadataMap} are provided. {@link InMemoryMetadataDB}  * stores all metadata in memory (O(n) memory) while  * {@link LevelDBMetadataMap} stores metadata in LevelDB on disk (O(1) memory).  * User can choose between them based on the time/space tradeoffs.  */
end_comment

begin_class
DECL|class|PBImageTextWriter
specifier|abstract
class|class
name|PBImageTextWriter
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|PBImageTextWriter
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_DELIMITER
specifier|static
specifier|final
name|String
name|DEFAULT_DELIMITER
init|=
literal|"\t"
decl_stmt|;
DECL|field|CRLF
specifier|static
specifier|final
name|String
name|CRLF
init|=
name|StringUtils
operator|.
name|CR
operator|+
name|StringUtils
operator|.
name|LF
decl_stmt|;
comment|/**    * This metadata map is used to construct the namespace before generating    * text outputs.    *    * It contains two mapping relationships:    *<p>    *<li>It maps each inode (inode Id) to its parent directory (inode Id).</li>    *<li>It maps each directory from its inode Id.</li>    *</p>    */
DECL|interface|MetadataMap
specifier|private
specifier|static
interface|interface
name|MetadataMap
extends|extends
name|Closeable
block|{
comment|/**      * Associate an inode with its parent directory.      */
DECL|method|putDirChild (long parentId, long childId)
specifier|public
name|void
name|putDirChild
parameter_list|(
name|long
name|parentId
parameter_list|,
name|long
name|childId
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Associate a directory with its inode Id.      */
DECL|method|putDir (INode dir)
specifier|public
name|void
name|putDir
parameter_list|(
name|INode
name|dir
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Get the full path of the parent directory for the given inode. */
DECL|method|getParentPath (long inode)
specifier|public
name|String
name|getParentPath
parameter_list|(
name|long
name|inode
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Synchronize metadata to persistent storage, if possible */
DECL|method|sync ()
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Returns the name of inode. */
DECL|method|getName (long id)
name|String
name|getName
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Returns the id of the parent's inode, if mentioned in      * INodeDirectorySection, throws IgnoreSnapshotException otherwise.      */
DECL|method|getParentId (long id)
name|long
name|getParentId
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * Maintain all the metadata in memory.    */
DECL|class|InMemoryMetadataDB
specifier|private
specifier|static
class|class
name|InMemoryMetadataDB
implements|implements
name|MetadataMap
block|{
comment|/**      * Represent a directory in memory.      */
DECL|class|Dir
specifier|private
specifier|static
class|class
name|Dir
block|{
DECL|field|inode
specifier|private
specifier|final
name|long
name|inode
decl_stmt|;
DECL|field|parent
specifier|private
name|Dir
name|parent
init|=
literal|null
decl_stmt|;
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|path
specifier|private
name|String
name|path
init|=
literal|null
decl_stmt|;
comment|// cached full path of the directory.
DECL|method|Dir (long inode, String name)
name|Dir
parameter_list|(
name|long
name|inode
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|inode
operator|=
name|inode
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
DECL|method|setParent (Dir parent)
specifier|private
name|void
name|setParent
parameter_list|(
name|Dir
name|parent
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|this
operator|.
name|parent
operator|==
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
comment|/**        * Returns the full path of this directory.        */
DECL|method|getPath ()
name|String
name|getPath
parameter_list|()
throws|throws
name|IgnoreSnapshotException
block|{
if|if
condition|(
name|this
operator|.
name|parent
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|inode
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|)
block|{
return|return
literal|"/"
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not root inode with id {} having no parent."
argument_list|,
name|inode
argument_list|)
expr_stmt|;
block|}
throw|throw
name|PBImageTextWriter
operator|.
name|createIgnoredSnapshotException
argument_list|(
name|inode
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|path
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|path
operator|=
operator|new
name|Path
argument_list|(
name|parent
operator|.
name|getPath
argument_list|()
argument_list|,
name|name
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"/"
else|:
name|name
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|path
return|;
block|}
DECL|method|getName ()
name|String
name|getName
parameter_list|()
throws|throws
name|IgnoreSnapshotException
block|{
return|return
name|name
return|;
block|}
DECL|method|getId ()
name|long
name|getId
parameter_list|()
block|{
return|return
name|inode
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|instanceof
name|Dir
operator|&&
name|inode
operator|==
operator|(
operator|(
name|Dir
operator|)
name|o
operator|)
operator|.
name|inode
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|inode
argument_list|)
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
comment|/**      * If the Dir entry does not exist (i.e. the inode was not contained in      * INodeSection) we still create a Dir entry which throws exceptions      * for calls other than getId().      * We can make sure this way, the getId and getParentId calls will      * always succeed if we have the information.      */
DECL|class|CorruptedDir
specifier|private
specifier|static
class|class
name|CorruptedDir
extends|extends
name|Dir
block|{
DECL|method|CorruptedDir (long inode)
name|CorruptedDir
parameter_list|(
name|long
name|inode
parameter_list|)
block|{
name|super
argument_list|(
name|inode
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getPath ()
name|String
name|getPath
parameter_list|()
throws|throws
name|IgnoreSnapshotException
block|{
throw|throw
name|PBImageTextWriter
operator|.
name|createIgnoredSnapshotException
argument_list|(
name|getId
argument_list|()
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|getName ()
name|String
name|getName
parameter_list|()
throws|throws
name|IgnoreSnapshotException
block|{
throw|throw
name|PBImageTextWriter
operator|.
name|createIgnoredSnapshotException
argument_list|(
name|getId
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/** INode Id to Dir object mapping */
DECL|field|dirMap
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|Dir
argument_list|>
name|dirMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Children to parent directory INode ID mapping. */
DECL|field|dirChildMap
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|Dir
argument_list|>
name|dirChildMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|InMemoryMetadataDB ()
name|InMemoryMetadataDB
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{     }
DECL|method|getOrCreateCorrupted (long id)
specifier|private
name|Dir
name|getOrCreateCorrupted
parameter_list|(
name|long
name|id
parameter_list|)
block|{
name|Dir
name|dir
init|=
name|dirMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|==
literal|null
condition|)
block|{
name|dir
operator|=
operator|new
name|CorruptedDir
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|dirMap
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
return|return
name|dir
return|;
block|}
annotation|@
name|Override
DECL|method|putDirChild (long parentId, long childId)
specifier|public
name|void
name|putDirChild
parameter_list|(
name|long
name|parentId
parameter_list|,
name|long
name|childId
parameter_list|)
block|{
name|Dir
name|parent
init|=
name|getOrCreateCorrupted
argument_list|(
name|parentId
argument_list|)
decl_stmt|;
name|Dir
name|child
init|=
name|getOrCreateCorrupted
argument_list|(
name|childId
argument_list|)
decl_stmt|;
name|child
operator|.
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|dirChildMap
operator|.
name|containsKey
argument_list|(
name|childId
argument_list|)
argument_list|)
expr_stmt|;
name|dirChildMap
operator|.
name|put
argument_list|(
name|childId
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|putDir (INode p)
specifier|public
name|void
name|putDir
parameter_list|(
name|INode
name|p
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|dirMap
operator|.
name|containsKey
argument_list|(
name|p
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Dir
name|dir
init|=
operator|new
name|Dir
argument_list|(
name|p
operator|.
name|getId
argument_list|()
argument_list|,
name|p
operator|.
name|getName
argument_list|()
operator|.
name|toStringUtf8
argument_list|()
argument_list|)
decl_stmt|;
name|dirMap
operator|.
name|put
argument_list|(
name|p
operator|.
name|getId
argument_list|()
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getParentPath (long inode)
specifier|public
name|String
name|getParentPath
parameter_list|(
name|long
name|inode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inode
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|)
block|{
return|return
literal|"/"
return|;
block|}
name|Dir
name|parent
init|=
name|dirChildMap
operator|.
name|get
argument_list|(
name|inode
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|// The inode is an INodeReference, which is generated from snapshot.
comment|// For delimited oiv tool, no need to print out metadata in snapshots.
throw|throw
name|PBImageTextWriter
operator|.
name|createIgnoredSnapshotException
argument_list|(
name|inode
argument_list|)
throw|;
block|}
return|return
name|parent
operator|.
name|getPath
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|sync ()
specifier|public
name|void
name|sync
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|getName (long id)
specifier|public
name|String
name|getName
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IgnoreSnapshotException
block|{
name|Dir
name|dir
init|=
name|dirMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
return|return
name|dir
operator|.
name|getName
argument_list|()
return|;
block|}
throw|throw
name|PBImageTextWriter
operator|.
name|createIgnoredSnapshotException
argument_list|(
name|id
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|getParentId (long id)
specifier|public
name|long
name|getParentId
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IgnoreSnapshotException
block|{
name|Dir
name|parentDir
init|=
name|dirChildMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentDir
operator|!=
literal|null
condition|)
block|{
return|return
name|parentDir
operator|.
name|getId
argument_list|()
return|;
block|}
throw|throw
name|PBImageTextWriter
operator|.
name|createIgnoredSnapshotException
argument_list|(
name|id
argument_list|)
throw|;
block|}
block|}
comment|/**    * A MetadataMap that stores metadata in LevelDB.    */
DECL|class|LevelDBMetadataMap
specifier|private
specifier|static
class|class
name|LevelDBMetadataMap
implements|implements
name|MetadataMap
block|{
comment|/**      * Store metadata in LevelDB.      */
DECL|class|LevelDBStore
specifier|private
specifier|static
class|class
name|LevelDBStore
implements|implements
name|Closeable
block|{
DECL|field|db
specifier|private
name|DB
name|db
init|=
literal|null
decl_stmt|;
DECL|field|batch
specifier|private
name|WriteBatch
name|batch
init|=
literal|null
decl_stmt|;
DECL|field|writeCount
specifier|private
name|int
name|writeCount
init|=
literal|0
decl_stmt|;
DECL|field|BATCH_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BATCH_SIZE
init|=
literal|1024
decl_stmt|;
DECL|method|LevelDBStore (final File dbPath)
name|LevelDBStore
parameter_list|(
specifier|final
name|File
name|dbPath
parameter_list|)
throws|throws
name|IOException
block|{
name|Options
name|options
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|options
operator|.
name|createIfMissing
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|options
operator|.
name|errorIfExists
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|db
operator|=
name|JniDBFactory
operator|.
name|factory
operator|.
name|open
argument_list|(
name|dbPath
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|batch
operator|=
name|db
operator|.
name|createWriteBatch
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|batch
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|batch
argument_list|)
expr_stmt|;
name|batch
operator|=
literal|null
expr_stmt|;
block|}
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|db
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|put (byte[] key, byte[] value)
specifier|public
name|void
name|put
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|batch
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeCount
operator|++
expr_stmt|;
if|if
condition|(
name|writeCount
operator|>=
name|BATCH_SIZE
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|get (byte[] key)
specifier|public
name|byte
index|[]
name|get
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|db
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|sync ()
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|db
operator|.
name|write
argument_list|(
name|batch
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|batch
operator|.
name|close
argument_list|()
expr_stmt|;
name|batch
operator|=
literal|null
expr_stmt|;
block|}
name|batch
operator|=
name|db
operator|.
name|createWriteBatch
argument_list|()
expr_stmt|;
name|writeCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**      * A LRU cache for directory path strings.      *      * The key of this LRU cache is the inode of a directory.      */
DECL|class|DirPathCache
specifier|private
specifier|static
class|class
name|DirPathCache
extends|extends
name|LinkedHashMap
argument_list|<
name|Long
argument_list|,
name|String
argument_list|>
block|{
DECL|field|CAPACITY
specifier|private
specifier|final
specifier|static
name|int
name|CAPACITY
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
DECL|method|DirPathCache ()
name|DirPathCache
parameter_list|()
block|{
name|super
argument_list|(
name|CAPACITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeEldestEntry (Map.Entry<Long, String> entry)
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|String
argument_list|>
name|entry
parameter_list|)
block|{
return|return
name|super
operator|.
name|size
argument_list|()
operator|>
name|CAPACITY
return|;
block|}
block|}
comment|/** Map the child inode to the parent directory inode. */
DECL|field|dirChildMap
specifier|private
name|LevelDBStore
name|dirChildMap
init|=
literal|null
decl_stmt|;
comment|/** Directory entry map */
DECL|field|dirMap
specifier|private
name|LevelDBStore
name|dirMap
init|=
literal|null
decl_stmt|;
DECL|field|dirPathCache
specifier|private
name|DirPathCache
name|dirPathCache
init|=
operator|new
name|DirPathCache
argument_list|()
decl_stmt|;
DECL|method|LevelDBMetadataMap (String baseDir)
name|LevelDBMetadataMap
parameter_list|(
name|String
name|baseDir
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|dbDir
init|=
operator|new
name|File
argument_list|(
name|baseDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbDir
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Folder "
operator|+
name|dbDir
operator|+
literal|" already exists! Delete "
operator|+
literal|"manually or provide another (not existing) directory!"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|dbDir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to mkdir on "
operator|+
name|dbDir
argument_list|)
throw|;
block|}
try|try
block|{
name|dirChildMap
operator|=
operator|new
name|LevelDBStore
argument_list|(
operator|new
name|File
argument_list|(
name|dbDir
argument_list|,
literal|"dirChildMap"
argument_list|)
argument_list|)
expr_stmt|;
name|dirMap
operator|=
operator|new
name|LevelDBStore
argument_list|(
operator|new
name|File
argument_list|(
name|dbDir
argument_list|,
literal|"dirMap"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to open LevelDBs"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|dirChildMap
argument_list|,
name|dirMap
argument_list|)
expr_stmt|;
name|dirChildMap
operator|=
literal|null
expr_stmt|;
name|dirMap
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|toBytes (long value)
specifier|private
specifier|static
name|byte
index|[]
name|toBytes
parameter_list|(
name|long
name|value
parameter_list|)
block|{
return|return
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|8
argument_list|)
operator|.
name|putLong
argument_list|(
name|value
argument_list|)
operator|.
name|array
argument_list|()
return|;
block|}
DECL|method|toBytes (String value)
specifier|private
specifier|static
name|byte
index|[]
name|toBytes
parameter_list|(
name|String
name|value
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
return|return
name|value
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
return|;
block|}
DECL|method|toLong (byte[] bytes)
specifier|private
specifier|static
name|long
name|toLong
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|bytes
operator|.
name|length
operator|==
literal|8
argument_list|)
expr_stmt|;
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|bytes
argument_list|)
operator|.
name|getLong
argument_list|()
return|;
block|}
DECL|method|toString (byte[] bytes)
specifier|private
specifier|static
name|String
name|toString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
literal|"UTF-8"
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|putDirChild (long parentId, long childId)
specifier|public
name|void
name|putDirChild
parameter_list|(
name|long
name|parentId
parameter_list|,
name|long
name|childId
parameter_list|)
throws|throws
name|IOException
block|{
name|dirChildMap
operator|.
name|put
argument_list|(
name|toBytes
argument_list|(
name|childId
argument_list|)
argument_list|,
name|toBytes
argument_list|(
name|parentId
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|putDir (INode dir)
specifier|public
name|void
name|putDir
parameter_list|(
name|INode
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|dir
operator|.
name|hasDirectory
argument_list|()
argument_list|,
literal|"INode %s (%s) is not a directory."
argument_list|,
name|dir
operator|.
name|getId
argument_list|()
argument_list|,
name|dir
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|dirMap
operator|.
name|put
argument_list|(
name|toBytes
argument_list|(
name|dir
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|,
name|toBytes
argument_list|(
name|dir
operator|.
name|getName
argument_list|()
operator|.
name|toStringUtf8
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getFromDirChildMap (long inode)
specifier|private
name|long
name|getFromDirChildMap
parameter_list|(
name|long
name|inode
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|bytes
init|=
name|dirChildMap
operator|.
name|get
argument_list|(
name|toBytes
argument_list|(
name|inode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
comment|// The inode is an INodeReference, which is generated from snapshot.
comment|// For delimited oiv tool, no need to print out metadata in snapshots.
throw|throw
name|PBImageTextWriter
operator|.
name|createIgnoredSnapshotException
argument_list|(
name|inode
argument_list|)
throw|;
block|}
if|if
condition|(
name|bytes
operator|.
name|length
operator|!=
literal|8
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"bytes array length error. Actual length is "
operator|+
name|bytes
operator|.
name|length
argument_list|)
throw|;
block|}
return|return
name|toLong
argument_list|(
name|bytes
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getParentPath (long inode)
specifier|public
name|String
name|getParentPath
parameter_list|(
name|long
name|inode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inode
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|)
block|{
return|return
literal|"/"
return|;
block|}
name|long
name|parent
init|=
name|getFromDirChildMap
argument_list|(
name|inode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dirPathCache
operator|.
name|containsKey
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
name|dirMap
operator|.
name|get
argument_list|(
name|toBytes
argument_list|(
name|parent
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
name|INodeId
operator|.
name|ROOT_INODE_ID
operator|&&
name|bytes
operator|==
literal|null
condition|)
block|{
comment|// The parent is an INodeReference, which is generated from snapshot.
comment|// For delimited oiv tool, no need to print out metadata in snapshots.
throw|throw
name|PBImageTextWriter
operator|.
name|createIgnoredSnapshotException
argument_list|(
name|inode
argument_list|)
throw|;
block|}
name|String
name|parentName
init|=
name|toString
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|String
name|parentPath
init|=
operator|new
name|Path
argument_list|(
name|getParentPath
argument_list|(
name|parent
argument_list|)
argument_list|,
name|parentName
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"/"
else|:
name|parentName
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|dirPathCache
operator|.
name|put
argument_list|(
name|parent
argument_list|,
name|parentPath
argument_list|)
expr_stmt|;
block|}
return|return
name|dirPathCache
operator|.
name|get
argument_list|(
name|parent
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|sync ()
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
name|dirChildMap
operator|.
name|sync
argument_list|()
expr_stmt|;
name|dirMap
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName (long id)
specifier|public
name|String
name|getName
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|bytes
init|=
name|dirMap
operator|.
name|get
argument_list|(
name|toBytes
argument_list|(
name|id
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|null
condition|)
block|{
return|return
name|toString
argument_list|(
name|bytes
argument_list|)
return|;
block|}
throw|throw
name|PBImageTextWriter
operator|.
name|createIgnoredSnapshotException
argument_list|(
name|id
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|getParentId (long id)
specifier|public
name|long
name|getParentId
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFromDirChildMap
argument_list|(
name|id
argument_list|)
return|;
block|}
block|}
DECL|field|stringTable
specifier|private
name|SerialNumberManager
operator|.
name|StringTable
name|stringTable
decl_stmt|;
DECL|field|out
specifier|private
name|PrintStream
name|out
decl_stmt|;
DECL|field|metadataMap
specifier|private
name|MetadataMap
name|metadataMap
init|=
literal|null
decl_stmt|;
DECL|field|delimiter
specifier|private
name|String
name|delimiter
decl_stmt|;
comment|/**    * Construct a PB FsImage writer to generate text file.    * @param out the writer to output text information of fsimage.    * @param tempPath the path to store metadata. If it is empty, store metadata    *                 in memory instead.    */
DECL|method|PBImageTextWriter (PrintStream out, String delimiter, String tempPath)
name|PBImageTextWriter
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|String
name|delimiter
parameter_list|,
name|String
name|tempPath
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|this
operator|.
name|delimiter
operator|=
name|delimiter
expr_stmt|;
if|if
condition|(
name|tempPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|metadataMap
operator|=
operator|new
name|InMemoryMetadataDB
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|metadataMap
operator|=
operator|new
name|LevelDBMetadataMap
argument_list|(
name|tempPath
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|metadataMap
argument_list|)
expr_stmt|;
block|}
DECL|method|append (StringBuffer buffer, int field)
name|void
name|append
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|,
name|int
name|field
parameter_list|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
DECL|method|append (StringBuffer buffer, long field)
name|void
name|append
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|,
name|long
name|field
parameter_list|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
DECL|method|append (StringBuffer buffer, String field)
name|void
name|append
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|,
name|String
name|field
parameter_list|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
name|String
name|escapedField
init|=
name|StringEscapeUtils
operator|.
name|escapeCsv
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|escapedField
operator|.
name|contains
argument_list|(
name|CRLF
argument_list|)
condition|)
block|{
name|escapedField
operator|=
name|escapedField
operator|.
name|replace
argument_list|(
name|CRLF
argument_list|,
literal|"%x0D%x0A"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|escapedField
operator|.
name|contains
argument_list|(
name|StringUtils
operator|.
name|LF
argument_list|)
condition|)
block|{
name|escapedField
operator|=
name|escapedField
operator|.
name|replace
argument_list|(
name|StringUtils
operator|.
name|LF
argument_list|,
literal|"%x0A"
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
name|escapedField
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get text output for the given inode.    * @param parent the path of parent directory    * @param inode the INode object to output.    */
DECL|method|getEntry (String parent, INode inode)
specifier|abstract
specifier|protected
name|String
name|getEntry
parameter_list|(
name|String
name|parent
parameter_list|,
name|INode
name|inode
parameter_list|)
function_decl|;
comment|/**    * Get text output for the header line.    */
DECL|method|getHeader ()
specifier|abstract
specifier|protected
name|String
name|getHeader
parameter_list|()
function_decl|;
comment|/**    * Method called at the end of output() phase after all the inodes    * with known parentPath has been printed out. Can be used to print    * additional data depending on the written inodes.    */
DECL|method|afterOutput ()
specifier|abstract
specifier|protected
name|void
name|afterOutput
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|visit (RandomAccessFile file)
specifier|public
name|void
name|visit
parameter_list|(
name|RandomAccessFile
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|FSImageUtil
operator|.
name|checkFileFormat
argument_list|(
name|file
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unrecognized FSImage"
argument_list|)
throw|;
block|}
name|FileSummary
name|summary
init|=
name|FSImageUtil
operator|.
name|loadSummary
argument_list|(
name|file
argument_list|)
decl_stmt|;
try|try
init|(
name|FileInputStream
name|fin
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
operator|.
name|getFD
argument_list|()
argument_list|)
init|)
block|{
name|InputStream
name|is
decl_stmt|;
name|ArrayList
argument_list|<
name|FileSummary
operator|.
name|Section
argument_list|>
name|sections
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|summary
operator|.
name|getSectionsList
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sections
argument_list|,
operator|new
name|Comparator
argument_list|<
name|FileSummary
operator|.
name|Section
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|FsImageProto
operator|.
name|FileSummary
operator|.
name|Section
name|s1
parameter_list|,
name|FsImageProto
operator|.
name|FileSummary
operator|.
name|Section
name|s2
parameter_list|)
block|{
name|FSImageFormatProtobuf
operator|.
name|SectionName
name|n1
init|=
name|FSImageFormatProtobuf
operator|.
name|SectionName
operator|.
name|fromString
argument_list|(
name|s1
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|FSImageFormatProtobuf
operator|.
name|SectionName
name|n2
init|=
name|FSImageFormatProtobuf
operator|.
name|SectionName
operator|.
name|fromString
argument_list|(
name|s2
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|n1
operator|==
literal|null
condition|)
block|{
return|return
name|n2
operator|==
literal|null
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n2
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|n1
operator|.
name|ordinal
argument_list|()
operator|-
name|n2
operator|.
name|ordinal
argument_list|()
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|ImmutableList
argument_list|<
name|Long
argument_list|>
name|refIdList
init|=
literal|null
decl_stmt|;
for|for
control|(
name|FileSummary
operator|.
name|Section
name|section
range|:
name|sections
control|)
block|{
name|fin
operator|.
name|getChannel
argument_list|()
operator|.
name|position
argument_list|(
name|section
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
name|is
operator|=
name|FSImageUtil
operator|.
name|wrapInputStreamForCompression
argument_list|(
name|conf
argument_list|,
name|summary
operator|.
name|getCodec
argument_list|()
argument_list|,
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|LimitInputStream
argument_list|(
name|fin
argument_list|,
name|section
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SectionName
operator|.
name|fromString
argument_list|(
name|section
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
case|case
name|STRING_TABLE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Loading string table"
argument_list|)
expr_stmt|;
name|stringTable
operator|=
name|FSImageLoader
operator|.
name|loadStringTable
argument_list|(
name|is
argument_list|)
expr_stmt|;
break|break;
case|case
name|INODE_REFERENCE
case|:
comment|// Load INodeReference so that all INodes can be processed.
comment|// Snapshots are not handled and will just be ignored for now.
name|LOG
operator|.
name|info
argument_list|(
literal|"Loading inode references"
argument_list|)
expr_stmt|;
name|refIdList
operator|=
name|FSImageLoader
operator|.
name|loadINodeReferenceSection
argument_list|(
name|is
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|loadDirectories
argument_list|(
name|fin
argument_list|,
name|sections
argument_list|,
name|summary
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|loadINodeDirSection
argument_list|(
name|fin
argument_list|,
name|sections
argument_list|,
name|summary
argument_list|,
name|conf
argument_list|,
name|refIdList
argument_list|)
expr_stmt|;
name|metadataMap
operator|.
name|sync
argument_list|()
expr_stmt|;
name|output
argument_list|(
name|conf
argument_list|,
name|summary
argument_list|,
name|fin
argument_list|,
name|sections
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|putDirChildToMetadataMap (long parentId, long childId)
name|void
name|putDirChildToMetadataMap
parameter_list|(
name|long
name|parentId
parameter_list|,
name|long
name|childId
parameter_list|)
throws|throws
name|IOException
block|{
name|metadataMap
operator|.
name|putDirChild
argument_list|(
name|parentId
argument_list|,
name|childId
argument_list|)
expr_stmt|;
block|}
DECL|method|getNodeName (long id)
name|String
name|getNodeName
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|metadataMap
operator|.
name|getName
argument_list|(
name|id
argument_list|)
return|;
block|}
DECL|method|getParentId (long id)
name|long
name|getParentId
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|metadataMap
operator|.
name|getParentId
argument_list|(
name|id
argument_list|)
return|;
block|}
DECL|method|output (Configuration conf, FileSummary summary, FileInputStream fin, ArrayList<FileSummary.Section> sections)
specifier|private
name|void
name|output
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileSummary
name|summary
parameter_list|,
name|FileInputStream
name|fin
parameter_list|,
name|ArrayList
argument_list|<
name|FileSummary
operator|.
name|Section
argument_list|>
name|sections
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|is
decl_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
name|getHeader
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|FileSummary
operator|.
name|Section
name|section
range|:
name|sections
control|)
block|{
if|if
condition|(
name|SectionName
operator|.
name|fromString
argument_list|(
name|section
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
name|SectionName
operator|.
name|INODE
condition|)
block|{
name|fin
operator|.
name|getChannel
argument_list|()
operator|.
name|position
argument_list|(
name|section
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
name|is
operator|=
name|FSImageUtil
operator|.
name|wrapInputStreamForCompression
argument_list|(
name|conf
argument_list|,
name|summary
operator|.
name|getCodec
argument_list|()
argument_list|,
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|LimitInputStream
argument_list|(
name|fin
argument_list|,
name|section
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|outputINodes
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
name|afterOutput
argument_list|()
expr_stmt|;
name|long
name|timeTaken
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Time to output inodes: {}ms"
argument_list|,
name|timeTaken
argument_list|)
expr_stmt|;
block|}
DECL|method|getPermission (long perm)
specifier|protected
name|PermissionStatus
name|getPermission
parameter_list|(
name|long
name|perm
parameter_list|)
block|{
return|return
name|FSImageFormatPBINode
operator|.
name|Loader
operator|.
name|loadPermission
argument_list|(
name|perm
argument_list|,
name|stringTable
argument_list|)
return|;
block|}
comment|/** Load the directories in the INode section. */
DECL|method|loadDirectories ( FileInputStream fin, List<FileSummary.Section> sections, FileSummary summary, Configuration conf)
specifier|private
name|void
name|loadDirectories
parameter_list|(
name|FileInputStream
name|fin
parameter_list|,
name|List
argument_list|<
name|FileSummary
operator|.
name|Section
argument_list|>
name|sections
parameter_list|,
name|FileSummary
name|summary
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Loading directories"
argument_list|)
expr_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
for|for
control|(
name|FileSummary
operator|.
name|Section
name|section
range|:
name|sections
control|)
block|{
if|if
condition|(
name|SectionName
operator|.
name|fromString
argument_list|(
name|section
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
name|SectionName
operator|.
name|INODE
condition|)
block|{
name|fin
operator|.
name|getChannel
argument_list|()
operator|.
name|position
argument_list|(
name|section
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
name|InputStream
name|is
init|=
name|FSImageUtil
operator|.
name|wrapInputStreamForCompression
argument_list|(
name|conf
argument_list|,
name|summary
operator|.
name|getCodec
argument_list|()
argument_list|,
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|LimitInputStream
argument_list|(
name|fin
argument_list|,
name|section
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|loadDirectoriesInINodeSection
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|timeTaken
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished loading directories in {}ms"
argument_list|,
name|timeTaken
argument_list|)
expr_stmt|;
block|}
DECL|method|loadINodeDirSection ( FileInputStream fin, List<FileSummary.Section> sections, FileSummary summary, Configuration conf, List<Long> refIdList)
specifier|private
name|void
name|loadINodeDirSection
parameter_list|(
name|FileInputStream
name|fin
parameter_list|,
name|List
argument_list|<
name|FileSummary
operator|.
name|Section
argument_list|>
name|sections
parameter_list|,
name|FileSummary
name|summary
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|refIdList
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Loading INode directory section."
argument_list|)
expr_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
for|for
control|(
name|FileSummary
operator|.
name|Section
name|section
range|:
name|sections
control|)
block|{
if|if
condition|(
name|SectionName
operator|.
name|fromString
argument_list|(
name|section
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
name|SectionName
operator|.
name|INODE_DIR
condition|)
block|{
name|fin
operator|.
name|getChannel
argument_list|()
operator|.
name|position
argument_list|(
name|section
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
name|InputStream
name|is
init|=
name|FSImageUtil
operator|.
name|wrapInputStreamForCompression
argument_list|(
name|conf
argument_list|,
name|summary
operator|.
name|getCodec
argument_list|()
argument_list|,
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|LimitInputStream
argument_list|(
name|fin
argument_list|,
name|section
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|buildNamespace
argument_list|(
name|is
argument_list|,
name|refIdList
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|timeTaken
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished loading INode directory section in {}ms"
argument_list|,
name|timeTaken
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks the inode (saves if directory), and counts them. Can be overridden    * if additional steps are taken when iterating through INodeSection.    */
DECL|method|checkNode (INode p, AtomicInteger numDirs)
specifier|protected
name|void
name|checkNode
parameter_list|(
name|INode
name|p
parameter_list|,
name|AtomicInteger
name|numDirs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|p
operator|.
name|hasDirectory
argument_list|()
condition|)
block|{
name|metadataMap
operator|.
name|putDir
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|numDirs
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Load the filenames of the directories from the INode section.    */
DECL|method|loadDirectoriesInINodeSection (InputStream in)
specifier|private
name|void
name|loadDirectoriesInINodeSection
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|INodeSection
name|s
init|=
name|INodeSection
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Loading directories in INode section."
argument_list|)
expr_stmt|;
name|AtomicInteger
name|numDirs
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|getNumInodes
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|INode
name|p
init|=
name|INode
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|i
operator|%
literal|10000
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanned {} inodes."
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|checkNode
argument_list|(
name|p
argument_list|,
name|numDirs
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Found {} directories in INode section."
argument_list|,
name|numDirs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Scan the INodeDirectory section to construct the namespace.    */
DECL|method|buildNamespace (InputStream in, List<Long> refIdList)
specifier|protected
name|void
name|buildNamespace
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|refIdList
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|FsImageProto
operator|.
name|INodeDirectorySection
operator|.
name|DirEntry
name|e
init|=
name|FsImageProto
operator|.
name|INodeDirectorySection
operator|.
name|DirEntry
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|count
operator|%
literal|10000
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanned {} directories."
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|long
name|parentId
init|=
name|e
operator|.
name|getParent
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|e
operator|.
name|getChildrenCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|long
name|childId
init|=
name|e
operator|.
name|getChildren
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|metadataMap
operator|.
name|putDirChild
argument_list|(
name|parentId
argument_list|,
name|childId
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|e
operator|.
name|getChildrenCount
argument_list|()
init|;
name|i
operator|<
name|e
operator|.
name|getChildrenCount
argument_list|()
operator|+
name|e
operator|.
name|getRefChildrenCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|refId
init|=
name|e
operator|.
name|getRefChildren
argument_list|(
name|i
operator|-
name|e
operator|.
name|getChildrenCount
argument_list|()
argument_list|)
decl_stmt|;
name|metadataMap
operator|.
name|putDirChild
argument_list|(
name|parentId
argument_list|,
name|refIdList
operator|.
name|get
argument_list|(
name|refId
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanned {} INode directories to build namespace."
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
DECL|method|printIfNotEmpty (String line)
name|void
name|printIfNotEmpty
parameter_list|(
name|String
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|outputINodes (InputStream in)
specifier|private
name|void
name|outputINodes
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|INodeSection
name|s
init|=
name|INodeSection
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Found {} INodes in the INode section"
argument_list|,
name|s
operator|.
name|getNumInodes
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|ignored
init|=
literal|0
decl_stmt|;
name|long
name|ignoredSnapshots
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|getNumInodes
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|INode
name|p
init|=
name|INode
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|parentPath
init|=
name|metadataMap
operator|.
name|getParentPath
argument_list|(
name|p
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|printIfNotEmpty
argument_list|(
name|getEntry
argument_list|(
name|parentPath
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|ignored
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ioe
operator|instanceof
name|IgnoreSnapshotException
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception caught, ignoring node:{}"
argument_list|,
name|p
operator|.
name|getId
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ignoredSnapshots
operator|++
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception caught, ignoring node:{}."
argument_list|,
name|p
operator|.
name|getId
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|i
operator|%
literal|100000
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Outputted {} INodes."
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ignored
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignored {} nodes, including {} in snapshots. Please turn on"
operator|+
literal|" debug log for details"
argument_list|,
name|ignored
argument_list|,
name|ignoredSnapshots
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Outputted {} INodes."
argument_list|,
name|s
operator|.
name|getNumInodes
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|createIgnoredSnapshotException ( long inode)
specifier|private
specifier|static
name|IgnoreSnapshotException
name|createIgnoredSnapshotException
parameter_list|(
name|long
name|inode
parameter_list|)
block|{
comment|// Ignore snapshots - we want the output similar to -ls -R.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No snapshot name found for inode {}"
argument_list|,
name|inode
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|IgnoreSnapshotException
argument_list|()
return|;
block|}
block|}
end_class

end_unit

