begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode.erasurecode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|erasurecode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorCompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SynchronousQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|BlockReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSPacket
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|RemoteBlockReader2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
operator|.
name|Peer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|BlockConstructionStage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|IOStreamPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PacketHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|sasl
operator|.
name|DataEncryptionKeyFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|CachingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockECRecoveryCommand
operator|.
name|BlockECRecoveryInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|StripedBlockUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|StripedBlockUtil
operator|.
name|StripingChunkReadResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|CodecUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|rawcoder
operator|.
name|RawErasureDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|StripedBlockUtil
operator|.
name|convertIndex4Decode
import|;
end_import

begin_comment
comment|/**  * ErasureCodingWorker handles the erasure coding recovery work commands. These  * commands would be issued from Namenode as part of Datanode's heart beat  * response. BPOfferService delegates the work to this class for handling EC  * commands.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|ErasureCodingWorker
specifier|public
specifier|final
class|class
name|ErasureCodingWorker
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|STRIPED_BLK_RECOVERY_THREAD_POOL
specifier|private
name|ThreadPoolExecutor
name|STRIPED_BLK_RECOVERY_THREAD_POOL
decl_stmt|;
DECL|field|STRIPED_READ_THREAD_POOL
specifier|private
name|ThreadPoolExecutor
name|STRIPED_READ_THREAD_POOL
decl_stmt|;
DECL|field|STRIPED_READ_TIMEOUT_MILLIS
specifier|private
specifier|final
name|int
name|STRIPED_READ_TIMEOUT_MILLIS
decl_stmt|;
DECL|field|STRIPED_READ_BUFFER_SIZE
specifier|private
specifier|final
name|int
name|STRIPED_READ_BUFFER_SIZE
decl_stmt|;
DECL|method|ErasureCodingWorker (Configuration conf, DataNode datanode)
specifier|public
name|ErasureCodingWorker
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|DataNode
name|datanode
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|STRIPED_READ_TIMEOUT_MILLIS
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STRIPED_READ_TIMEOUT_MILLIS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STRIPED_READ_TIMEOUT_MILLIS_DEFAULT
argument_list|)
expr_stmt|;
name|initializeStripedReadThreadPool
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STRIPED_READ_THREADS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STRIPED_READ_THREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|STRIPED_READ_BUFFER_SIZE
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STRIPED_READ_BUFFER_SIZE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STRIPED_READ_BUFFER_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|initializeStripedBlkRecoveryThreadPool
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STRIPED_BLK_RECOVERY_THREADS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STRIPED_BLK_RECOVERY_THREADS_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|newDecoder (int numDataUnits, int numParityUnits)
specifier|private
name|RawErasureDecoder
name|newDecoder
parameter_list|(
name|int
name|numDataUnits
parameter_list|,
name|int
name|numParityUnits
parameter_list|)
block|{
return|return
name|CodecUtil
operator|.
name|createRSRawDecoder
argument_list|(
name|conf
argument_list|,
name|numDataUnits
argument_list|,
name|numParityUnits
argument_list|)
return|;
block|}
DECL|method|initializeStripedReadThreadPool (int num)
specifier|private
name|void
name|initializeStripedReadThreadPool
parameter_list|(
name|int
name|num
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using striped reads; pool threads="
operator|+
name|num
argument_list|)
expr_stmt|;
block|}
name|STRIPED_READ_THREAD_POOL
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|1
argument_list|,
name|num
argument_list|,
literal|60
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|Daemon
operator|.
name|DaemonFactory
argument_list|()
block|{
specifier|private
specifier|final
name|AtomicInteger
name|threadIndex
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|t
init|=
name|super
operator|.
name|newThread
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"stripedRead-"
operator|+
name|threadIndex
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
argument_list|,
operator|new
name|ThreadPoolExecutor
operator|.
name|CallerRunsPolicy
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|rejectedExecution
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|ThreadPoolExecutor
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Execution for striped reading rejected, "
operator|+
literal|"Executing in current thread"
argument_list|)
expr_stmt|;
comment|// will run in the current thread
name|super
operator|.
name|rejectedExecution
argument_list|(
name|runnable
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|STRIPED_READ_THREAD_POOL
operator|.
name|allowCoreThreadTimeOut
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|initializeStripedBlkRecoveryThreadPool (int num)
specifier|private
name|void
name|initializeStripedBlkRecoveryThreadPool
parameter_list|(
name|int
name|num
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using striped block recovery; pool threads="
operator|+
name|num
argument_list|)
expr_stmt|;
block|}
name|STRIPED_BLK_RECOVERY_THREAD_POOL
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|2
argument_list|,
name|num
argument_list|,
literal|60
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|Daemon
operator|.
name|DaemonFactory
argument_list|()
block|{
specifier|private
specifier|final
name|AtomicInteger
name|threadIdx
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|t
init|=
name|super
operator|.
name|newThread
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"stripedBlockRecovery-"
operator|+
name|threadIdx
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|STRIPED_BLK_RECOVERY_THREAD_POOL
operator|.
name|allowCoreThreadTimeOut
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handles the Erasure Coding recovery work commands.    *     * @param ecTasks    *          BlockECRecoveryInfo    */
DECL|method|processErasureCodingTasks (Collection<BlockECRecoveryInfo> ecTasks)
specifier|public
name|void
name|processErasureCodingTasks
parameter_list|(
name|Collection
argument_list|<
name|BlockECRecoveryInfo
argument_list|>
name|ecTasks
parameter_list|)
block|{
for|for
control|(
name|BlockECRecoveryInfo
name|recoveryInfo
range|:
name|ecTasks
control|)
block|{
try|try
block|{
name|STRIPED_BLK_RECOVERY_THREAD_POOL
operator|.
name|submit
argument_list|(
operator|new
name|ReconstructAndTransferBlock
argument_list|(
name|recoveryInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to recover striped block "
operator|+
name|recoveryInfo
operator|.
name|getExtendedBlock
argument_list|()
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * ReconstructAndTransferBlock recover one or more missed striped block in the    * striped block group, the minimum number of live striped blocks should be    * no less than data block number.    *     * |<- Striped Block Group -> |    *  blk_0      blk_1       blk_2(*)   blk_3   ...<- A striped block group    *    |          |           |          |      *    v          v           v          v     * +------+   +------+   +------+   +------+    * |cell_0|   |cell_1|   |cell_2|   |cell_3|  ...        * +------+   +------+   +------+   +------+         * |cell_4|   |cell_5|   |cell_6|   |cell_7|  ...    * +------+   +------+   +------+   +------+    * |cell_8|   |cell_9|   |cell10|   |cell11|  ...    * +------+   +------+   +------+   +------+    *  ...         ...       ...         ...    *      *     * We use following steps to recover striped block group, in each round, we    * recover<code>bufferSize</code> data until finish, the     *<code>bufferSize</code> is configurable and may be less or larger than     * cell size:    * step1: read<code>bufferSize</code> data from minimum number of sources     *        required by recovery.    * step2: decode data for targets.    * step3: transfer data to targets.    *     * In step1, try to read<code>bufferSize</code> data from minimum number    * of sources , if there is corrupt or stale sources, read from new source    * will be scheduled. The best sources are remembered for next round and     * may be updated in each round.    *     * In step2, typically if source blocks we read are all data blocks, we     * need to call encode, and if there is one parity block, we need to call    * decode. Notice we only read once and recover all missed striped block     * if they are more than one.    *     * In step3, send the recovered data to targets by constructing packet     * and send them directly. Same as continuous block replication, we     * don't check the packet ack. Since the datanode doing the recovery work    * are one of the source datanodes, so the recovered data are sent     * remotely.    *     * There are some points we can do further improvements in next phase:    * 1. we can read the block file directly on the local datanode,     *    currently we use remote block reader. (Notice short-circuit is not    *    a good choice, see inline comments).    * 2. We need to check the packet ack for EC recovery? Since EC recovery    *    is more expensive than continuous block replication, it needs to     *    read from several other datanodes, should we make sure the     *    recovered result received by targets?     */
DECL|class|ReconstructAndTransferBlock
specifier|private
class|class
name|ReconstructAndTransferBlock
implements|implements
name|Runnable
block|{
DECL|field|dataBlkNum
specifier|private
specifier|final
name|int
name|dataBlkNum
decl_stmt|;
DECL|field|parityBlkNum
specifier|private
specifier|final
name|int
name|parityBlkNum
decl_stmt|;
DECL|field|cellSize
specifier|private
specifier|final
name|int
name|cellSize
decl_stmt|;
DECL|field|decoder
specifier|private
name|RawErasureDecoder
name|decoder
decl_stmt|;
comment|// Striped read buffer size
DECL|field|bufferSize
specifier|private
name|int
name|bufferSize
decl_stmt|;
DECL|field|blockGroup
specifier|private
specifier|final
name|ExtendedBlock
name|blockGroup
decl_stmt|;
DECL|field|minRequiredSources
specifier|private
specifier|final
name|int
name|minRequiredSources
decl_stmt|;
comment|// position in striped internal block
DECL|field|positionInBlock
specifier|private
name|long
name|positionInBlock
decl_stmt|;
comment|// sources
DECL|field|liveIndices
specifier|private
specifier|final
name|short
index|[]
name|liveIndices
decl_stmt|;
DECL|field|sources
specifier|private
specifier|final
name|DatanodeInfo
index|[]
name|sources
decl_stmt|;
DECL|field|stripedReaders
specifier|private
specifier|final
name|List
argument_list|<
name|StripedReader
argument_list|>
name|stripedReaders
decl_stmt|;
comment|// The buffers and indices for striped blocks whose length is 0
DECL|field|zeroStripeBuffers
specifier|private
name|ByteBuffer
index|[]
name|zeroStripeBuffers
decl_stmt|;
DECL|field|zeroStripeIndices
specifier|private
name|short
index|[]
name|zeroStripeIndices
decl_stmt|;
comment|// targets
DECL|field|targets
specifier|private
specifier|final
name|DatanodeInfo
index|[]
name|targets
decl_stmt|;
DECL|field|targetStorageTypes
specifier|private
specifier|final
name|StorageType
index|[]
name|targetStorageTypes
decl_stmt|;
DECL|field|targetIndices
specifier|private
specifier|final
name|short
index|[]
name|targetIndices
decl_stmt|;
DECL|field|targetBuffers
specifier|private
specifier|final
name|ByteBuffer
index|[]
name|targetBuffers
decl_stmt|;
DECL|field|targetSockets
specifier|private
specifier|final
name|Socket
index|[]
name|targetSockets
decl_stmt|;
DECL|field|targetOutputStreams
specifier|private
specifier|final
name|DataOutputStream
index|[]
name|targetOutputStreams
decl_stmt|;
DECL|field|targetInputStreams
specifier|private
specifier|final
name|DataInputStream
index|[]
name|targetInputStreams
decl_stmt|;
DECL|field|blockOffset4Targets
specifier|private
specifier|final
name|long
index|[]
name|blockOffset4Targets
decl_stmt|;
DECL|field|seqNo4Targets
specifier|private
specifier|final
name|long
index|[]
name|seqNo4Targets
decl_stmt|;
DECL|field|WRITE_PACKET_SIZE
specifier|private
specifier|final
specifier|static
name|int
name|WRITE_PACKET_SIZE
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
DECL|field|checksum
specifier|private
name|DataChecksum
name|checksum
decl_stmt|;
DECL|field|maxChunksPerPacket
specifier|private
name|int
name|maxChunksPerPacket
decl_stmt|;
DECL|field|packetBuf
specifier|private
name|byte
index|[]
name|packetBuf
decl_stmt|;
DECL|field|checksumBuf
specifier|private
name|byte
index|[]
name|checksumBuf
decl_stmt|;
DECL|field|bytesPerChecksum
specifier|private
name|int
name|bytesPerChecksum
decl_stmt|;
DECL|field|checksumSize
specifier|private
name|int
name|checksumSize
decl_stmt|;
DECL|field|cachingStrategy
specifier|private
specifier|final
name|CachingStrategy
name|cachingStrategy
decl_stmt|;
DECL|field|futures
specifier|private
specifier|final
name|Map
argument_list|<
name|Future
argument_list|<
name|Void
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|futures
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|readService
specifier|private
specifier|final
name|CompletionService
argument_list|<
name|Void
argument_list|>
name|readService
init|=
operator|new
name|ExecutorCompletionService
argument_list|<>
argument_list|(
name|STRIPED_READ_THREAD_POOL
argument_list|)
decl_stmt|;
DECL|method|ReconstructAndTransferBlock (BlockECRecoveryInfo recoveryInfo)
name|ReconstructAndTransferBlock
parameter_list|(
name|BlockECRecoveryInfo
name|recoveryInfo
parameter_list|)
block|{
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|recoveryInfo
operator|.
name|getErasureCodingPolicy
argument_list|()
decl_stmt|;
name|dataBlkNum
operator|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
expr_stmt|;
name|parityBlkNum
operator|=
name|ecPolicy
operator|.
name|getNumParityUnits
argument_list|()
expr_stmt|;
name|cellSize
operator|=
name|ecPolicy
operator|.
name|getCellSize
argument_list|()
expr_stmt|;
name|blockGroup
operator|=
name|recoveryInfo
operator|.
name|getExtendedBlock
argument_list|()
expr_stmt|;
specifier|final
name|int
name|cellsNum
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|blockGroup
operator|.
name|getNumBytes
argument_list|()
operator|-
literal|1
operator|)
operator|/
name|cellSize
operator|+
literal|1
argument_list|)
decl_stmt|;
name|minRequiredSources
operator|=
name|Math
operator|.
name|min
argument_list|(
name|cellsNum
argument_list|,
name|dataBlkNum
argument_list|)
expr_stmt|;
name|liveIndices
operator|=
name|recoveryInfo
operator|.
name|getLiveBlockIndices
argument_list|()
expr_stmt|;
name|sources
operator|=
name|recoveryInfo
operator|.
name|getSourceDnInfos
argument_list|()
expr_stmt|;
name|stripedReaders
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|sources
operator|.
name|length
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|liveIndices
operator|.
name|length
operator|>=
name|minRequiredSources
argument_list|,
literal|"No enough live striped blocks."
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|liveIndices
operator|.
name|length
operator|==
name|sources
operator|.
name|length
argument_list|,
literal|"liveBlockIndices and source dns should match"
argument_list|)
expr_stmt|;
if|if
condition|(
name|minRequiredSources
operator|<
name|dataBlkNum
condition|)
block|{
name|zeroStripeBuffers
operator|=
operator|new
name|ByteBuffer
index|[
name|dataBlkNum
operator|-
name|minRequiredSources
index|]
expr_stmt|;
name|zeroStripeIndices
operator|=
operator|new
name|short
index|[
name|dataBlkNum
operator|-
name|minRequiredSources
index|]
expr_stmt|;
block|}
name|targets
operator|=
name|recoveryInfo
operator|.
name|getTargetDnInfos
argument_list|()
expr_stmt|;
name|targetStorageTypes
operator|=
name|recoveryInfo
operator|.
name|getTargetStorageTypes
argument_list|()
expr_stmt|;
name|targetIndices
operator|=
operator|new
name|short
index|[
name|targets
operator|.
name|length
index|]
expr_stmt|;
name|targetBuffers
operator|=
operator|new
name|ByteBuffer
index|[
name|targets
operator|.
name|length
index|]
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|targetIndices
operator|.
name|length
operator|<=
name|parityBlkNum
argument_list|,
literal|"Too much missed striped blocks."
argument_list|)
expr_stmt|;
name|targetSockets
operator|=
operator|new
name|Socket
index|[
name|targets
operator|.
name|length
index|]
expr_stmt|;
name|targetOutputStreams
operator|=
operator|new
name|DataOutputStream
index|[
name|targets
operator|.
name|length
index|]
expr_stmt|;
name|targetInputStreams
operator|=
operator|new
name|DataInputStream
index|[
name|targets
operator|.
name|length
index|]
expr_stmt|;
name|blockOffset4Targets
operator|=
operator|new
name|long
index|[
name|targets
operator|.
name|length
index|]
expr_stmt|;
name|seqNo4Targets
operator|=
operator|new
name|long
index|[
name|targets
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|blockOffset4Targets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|seqNo4Targets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|getTargetIndices
argument_list|()
expr_stmt|;
name|cachingStrategy
operator|=
name|CachingStrategy
operator|.
name|newDefaultStrategy
argument_list|()
expr_stmt|;
block|}
DECL|method|allocateBuffer (int length)
specifier|private
name|ByteBuffer
name|allocateBuffer
parameter_list|(
name|int
name|length
parameter_list|)
block|{
return|return
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|length
argument_list|)
return|;
block|}
DECL|method|getBlock (ExtendedBlock blockGroup, int i)
specifier|private
name|ExtendedBlock
name|getBlock
parameter_list|(
name|ExtendedBlock
name|blockGroup
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|StripedBlockUtil
operator|.
name|constructInternalBlock
argument_list|(
name|blockGroup
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|i
argument_list|)
return|;
block|}
DECL|method|getBlockLen (ExtendedBlock blockGroup, int i)
specifier|private
name|long
name|getBlockLen
parameter_list|(
name|ExtendedBlock
name|blockGroup
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|StripedBlockUtil
operator|.
name|getInternalBlockLength
argument_list|(
name|blockGroup
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/**      * StripedReader is used to read from one source DN, it contains a block      * reader, buffer and striped block index.      * Only allocate StripedReader once for one source, and the StripedReader      * has the same array order with sources. Typically we only need to allocate      * minimum number (minRequiredSources) of StripedReader, and allocate      * new for new source DN if some existing DN invalid or slow.      * If some source DN is corrupt, set the corresponding blockReader to       * null and will never read from it again.      *        * @param i the array index of sources      * @param offsetInBlock offset for the internal block      * @return StripedReader      */
DECL|method|addStripedReader (int i, long offsetInBlock)
specifier|private
name|StripedReader
name|addStripedReader
parameter_list|(
name|int
name|i
parameter_list|,
name|long
name|offsetInBlock
parameter_list|)
block|{
name|StripedReader
name|reader
init|=
operator|new
name|StripedReader
argument_list|(
name|liveIndices
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|stripedReaders
operator|.
name|add
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|BlockReader
name|blockReader
init|=
name|newBlockReader
argument_list|(
name|getBlock
argument_list|(
name|blockGroup
argument_list|,
name|liveIndices
index|[
name|i
index|]
argument_list|)
argument_list|,
name|offsetInBlock
argument_list|,
name|sources
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockReader
operator|!=
literal|null
condition|)
block|{
name|initChecksumAndBufferSizeIfNeeded
argument_list|(
name|blockReader
argument_list|)
expr_stmt|;
name|reader
operator|.
name|blockReader
operator|=
name|blockReader
expr_stmt|;
block|}
name|reader
operator|.
name|buffer
operator|=
name|allocateBuffer
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
return|return
name|reader
return|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|datanode
operator|.
name|incrementXmitsInProgress
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Store the array indices of source DNs we have read successfully.
comment|// In each iteration of read, the success list may be updated if
comment|// some source DN is corrupted or slow. And use the updated success
comment|// list of DNs for next iteration read.
name|int
index|[]
name|success
init|=
operator|new
name|int
index|[
name|minRequiredSources
index|]
decl_stmt|;
name|int
name|nsuccess
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sources
operator|.
name|length
operator|&&
name|nsuccess
operator|<
name|minRequiredSources
condition|;
name|i
operator|++
control|)
block|{
name|StripedReader
name|reader
init|=
name|addStripedReader
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|blockReader
operator|!=
literal|null
condition|)
block|{
name|success
index|[
name|nsuccess
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nsuccess
operator|<
name|minRequiredSources
condition|)
block|{
name|String
name|error
init|=
literal|"Can't find minimum sources required by "
operator|+
literal|"recovery, block id: "
operator|+
name|blockGroup
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
name|zeroStripeBuffers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zeroStripeBuffers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|zeroStripeBuffers
index|[
name|i
index|]
operator|=
name|allocateBuffer
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|targetBuffers
index|[
name|i
index|]
operator|=
name|allocateBuffer
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
block|}
name|checksumSize
operator|=
name|checksum
operator|.
name|getChecksumSize
argument_list|()
expr_stmt|;
name|int
name|chunkSize
init|=
name|bytesPerChecksum
operator|+
name|checksumSize
decl_stmt|;
name|maxChunksPerPacket
operator|=
name|Math
operator|.
name|max
argument_list|(
operator|(
name|WRITE_PACKET_SIZE
operator|-
name|PacketHeader
operator|.
name|PKT_MAX_HEADER_LEN
operator|)
operator|/
name|chunkSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|int
name|maxPacketSize
init|=
name|chunkSize
operator|*
name|maxChunksPerPacket
operator|+
name|PacketHeader
operator|.
name|PKT_MAX_HEADER_LEN
decl_stmt|;
name|packetBuf
operator|=
operator|new
name|byte
index|[
name|maxPacketSize
index|]
expr_stmt|;
name|checksumBuf
operator|=
operator|new
name|byte
index|[
name|checksumSize
operator|*
operator|(
name|bufferSize
operator|/
name|bytesPerChecksum
operator|)
index|]
expr_stmt|;
comment|// targetsStatus store whether some target is success, it will record
comment|// any failed target once, if some target failed (invalid DN or transfer
comment|// failed), will not transfer data to it any more.
name|boolean
index|[]
name|targetsStatus
init|=
operator|new
name|boolean
index|[
name|targets
operator|.
name|length
index|]
decl_stmt|;
if|if
condition|(
name|initTargetStreams
argument_list|(
name|targetsStatus
argument_list|)
operator|==
literal|0
condition|)
block|{
name|String
name|error
init|=
literal|"All targets are failed."
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
name|long
name|firstStripedBlockLength
init|=
name|getBlockLen
argument_list|(
name|blockGroup
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|positionInBlock
operator|<
name|firstStripedBlockLength
condition|)
block|{
name|int
name|toRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|bufferSize
argument_list|,
call|(
name|int
call|)
argument_list|(
name|firstStripedBlockLength
operator|-
name|positionInBlock
argument_list|)
argument_list|)
decl_stmt|;
comment|// step1: read from minimum source DNs required for reconstruction.
comment|//   The returned success list is the source DNs we do real read from
name|success
operator|=
name|readMinimumStripedData4Recovery
argument_list|(
name|success
argument_list|)
expr_stmt|;
comment|// step2: decode to reconstruct targets
name|long
name|remaining
init|=
name|firstStripedBlockLength
operator|-
name|positionInBlock
decl_stmt|;
name|int
name|toRecoverLen
init|=
name|remaining
operator|<
name|bufferSize
condition|?
operator|(
name|int
operator|)
name|remaining
else|:
name|bufferSize
decl_stmt|;
name|recoverTargets
argument_list|(
name|success
argument_list|,
name|targetsStatus
argument_list|,
name|toRecoverLen
argument_list|)
expr_stmt|;
comment|// step3: transfer data
if|if
condition|(
name|transferData2Targets
argument_list|(
name|targetsStatus
argument_list|)
operator|==
literal|0
condition|)
block|{
name|String
name|error
init|=
literal|"Transfer failed for all targets."
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
name|clearBuffers
argument_list|()
expr_stmt|;
name|positionInBlock
operator|+=
name|toRead
expr_stmt|;
block|}
name|endTargetBlocks
argument_list|(
name|targetsStatus
argument_list|)
expr_stmt|;
comment|// Currently we don't check the acks for packets, this is similar as
comment|// block replication.
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to recover striped block: "
operator|+
name|blockGroup
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|datanode
operator|.
name|decrementXmitsInProgress
argument_list|()
expr_stmt|;
comment|// close block readers
for|for
control|(
name|StripedReader
name|stripedReader
range|:
name|stripedReaders
control|)
block|{
name|closeBlockReader
argument_list|(
name|stripedReader
operator|.
name|blockReader
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|targetOutputStreams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|targetInputStreams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|targetSockets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// init checksum from block reader
DECL|method|initChecksumAndBufferSizeIfNeeded (BlockReader blockReader)
specifier|private
name|void
name|initChecksumAndBufferSizeIfNeeded
parameter_list|(
name|BlockReader
name|blockReader
parameter_list|)
block|{
if|if
condition|(
name|checksum
operator|==
literal|null
condition|)
block|{
name|checksum
operator|=
name|blockReader
operator|.
name|getDataChecksum
argument_list|()
expr_stmt|;
name|bytesPerChecksum
operator|=
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
comment|// The bufferSize is flat to divide bytesPerChecksum
name|int
name|readBufferSize
init|=
name|STRIPED_READ_BUFFER_SIZE
decl_stmt|;
name|bufferSize
operator|=
name|readBufferSize
operator|<
name|bytesPerChecksum
condition|?
name|bytesPerChecksum
else|:
name|readBufferSize
operator|-
name|readBufferSize
operator|%
name|bytesPerChecksum
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|blockReader
operator|.
name|getDataChecksum
argument_list|()
operator|.
name|equals
argument_list|(
name|checksum
argument_list|)
assert|;
block|}
block|}
DECL|method|getTargetIndices ()
specifier|private
name|void
name|getTargetIndices
parameter_list|()
block|{
name|BitSet
name|bitset
init|=
operator|new
name|BitSet
argument_list|(
name|dataBlkNum
operator|+
name|parityBlkNum
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sources
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bitset
operator|.
name|set
argument_list|(
name|liveIndices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataBlkNum
operator|+
name|parityBlkNum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bitset
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|getBlockLen
argument_list|(
name|blockGroup
argument_list|,
name|i
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|<
name|targets
operator|.
name|length
condition|)
block|{
name|targetIndices
index|[
name|m
operator|++
index|]
operator|=
operator|(
name|short
operator|)
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|zeroStripeIndices
index|[
name|k
operator|++
index|]
operator|=
operator|(
name|short
operator|)
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|getReadLength (int index)
specifier|private
name|long
name|getReadLength
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|long
name|blockLen
init|=
name|getBlockLen
argument_list|(
name|blockGroup
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|long
name|remaining
init|=
name|blockLen
operator|-
name|positionInBlock
decl_stmt|;
return|return
name|remaining
operator|>
name|bufferSize
condition|?
name|bufferSize
else|:
name|remaining
return|;
block|}
comment|/**      * Read from minimum source DNs required for reconstruction in the iteration.      * First try the success list which we think they are the best DNs      * If source DN is corrupt or slow, try to read some other source DN,       * and will update the success list.       *       * Remember the updated success list and return it for following       * operations and next iteration read.      *       * @param success the initial success list of source DNs we think best      * @return updated success list of source DNs we do real read      * @throws IOException      */
DECL|method|readMinimumStripedData4Recovery (final int[] success)
specifier|private
name|int
index|[]
name|readMinimumStripedData4Recovery
parameter_list|(
specifier|final
name|int
index|[]
name|success
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|nsuccess
init|=
literal|0
decl_stmt|;
name|int
index|[]
name|newSuccess
init|=
operator|new
name|int
index|[
name|minRequiredSources
index|]
decl_stmt|;
name|BitSet
name|used
init|=
operator|new
name|BitSet
argument_list|(
name|sources
operator|.
name|length
argument_list|)
decl_stmt|;
comment|/*        * Read from minimum source DNs required, the success list contains        * source DNs which we think best.        */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|minRequiredSources
condition|;
name|i
operator|++
control|)
block|{
name|StripedReader
name|reader
init|=
name|stripedReaders
operator|.
name|get
argument_list|(
name|success
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|getReadLength
argument_list|(
name|liveIndices
index|[
name|success
index|[
name|i
index|]
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|Callable
argument_list|<
name|Void
argument_list|>
name|readCallable
init|=
name|readFromBlock
argument_list|(
name|reader
operator|.
name|blockReader
argument_list|,
name|reader
operator|.
name|buffer
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|Void
argument_list|>
name|f
init|=
name|readService
operator|.
name|submit
argument_list|(
name|readCallable
argument_list|)
decl_stmt|;
name|futures
operator|.
name|put
argument_list|(
name|f
argument_list|,
name|success
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the read length is 0, we don't need to do real read
name|reader
operator|.
name|buffer
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newSuccess
index|[
name|nsuccess
operator|++
index|]
operator|=
name|success
index|[
name|i
index|]
expr_stmt|;
block|}
name|used
operator|.
name|set
argument_list|(
name|success
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|futures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|StripingChunkReadResult
name|result
init|=
name|StripedBlockUtil
operator|.
name|getNextCompletedStripedRead
argument_list|(
name|readService
argument_list|,
name|futures
argument_list|,
name|STRIPED_READ_TIMEOUT_MILLIS
argument_list|)
decl_stmt|;
name|int
name|resultIndex
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|state
operator|==
name|StripingChunkReadResult
operator|.
name|SUCCESSFUL
condition|)
block|{
name|resultIndex
operator|=
name|result
operator|.
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|state
operator|==
name|StripingChunkReadResult
operator|.
name|FAILED
condition|)
block|{
comment|// If read failed for some source DN, we should not use it anymore
comment|// and schedule read from another source DN.
name|StripedReader
name|failedReader
init|=
name|stripedReaders
operator|.
name|get
argument_list|(
name|result
operator|.
name|index
argument_list|)
decl_stmt|;
name|closeBlockReader
argument_list|(
name|failedReader
operator|.
name|blockReader
argument_list|)
expr_stmt|;
name|failedReader
operator|.
name|blockReader
operator|=
literal|null
expr_stmt|;
name|resultIndex
operator|=
name|scheduleNewRead
argument_list|(
name|used
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|state
operator|==
name|StripingChunkReadResult
operator|.
name|TIMEOUT
condition|)
block|{
comment|// If timeout, we also schedule a new read.
name|resultIndex
operator|=
name|scheduleNewRead
argument_list|(
name|used
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resultIndex
operator|>=
literal|0
condition|)
block|{
name|newSuccess
index|[
name|nsuccess
operator|++
index|]
operator|=
name|resultIndex
expr_stmt|;
if|if
condition|(
name|nsuccess
operator|>=
name|minRequiredSources
condition|)
block|{
comment|// cancel remaining reads if we read successfully from minimum
comment|// number of source DNs required by reconstruction.
name|cancelReads
argument_list|(
name|futures
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|futures
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Read data interrupted."
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nsuccess
operator|<
name|minRequiredSources
condition|)
block|{
name|String
name|error
init|=
literal|"Can't read data from minimum number of sources "
operator|+
literal|"required by reconstruction, block id: "
operator|+
name|blockGroup
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
return|return
name|newSuccess
return|;
block|}
DECL|method|paddingBufferToLen (ByteBuffer buffer, int len)
specifier|private
name|void
name|paddingBufferToLen
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|toPadding
init|=
name|len
operator|-
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toPadding
condition|;
name|i
operator|++
control|)
block|{
name|buffer
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Initialize decoder
DECL|method|initDecoderIfNecessary ()
specifier|private
name|void
name|initDecoderIfNecessary
parameter_list|()
block|{
if|if
condition|(
name|decoder
operator|==
literal|null
condition|)
block|{
name|decoder
operator|=
name|newDecoder
argument_list|(
name|dataBlkNum
argument_list|,
name|parityBlkNum
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getErasedIndices (boolean[] targetsStatus)
specifier|private
name|int
index|[]
name|getErasedIndices
parameter_list|(
name|boolean
index|[]
name|targetsStatus
parameter_list|)
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
name|targets
operator|.
name|length
index|]
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|targetsStatus
index|[
name|i
index|]
condition|)
block|{
name|result
index|[
name|m
operator|++
index|]
operator|=
name|convertIndex4Decode
argument_list|(
name|targetIndices
index|[
name|i
index|]
argument_list|,
name|dataBlkNum
argument_list|,
name|parityBlkNum
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
return|;
block|}
DECL|method|recoverTargets (int[] success, boolean[] targetsStatus, int toRecoverLen)
specifier|private
name|void
name|recoverTargets
parameter_list|(
name|int
index|[]
name|success
parameter_list|,
name|boolean
index|[]
name|targetsStatus
parameter_list|,
name|int
name|toRecoverLen
parameter_list|)
block|{
name|initDecoderIfNecessary
argument_list|()
expr_stmt|;
name|ByteBuffer
index|[]
name|inputs
init|=
operator|new
name|ByteBuffer
index|[
name|dataBlkNum
operator|+
name|parityBlkNum
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|success
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|StripedReader
name|reader
init|=
name|stripedReaders
operator|.
name|get
argument_list|(
name|success
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|ByteBuffer
name|buffer
init|=
name|reader
operator|.
name|buffer
decl_stmt|;
name|paddingBufferToLen
argument_list|(
name|buffer
argument_list|,
name|toRecoverLen
argument_list|)
expr_stmt|;
name|inputs
index|[
name|convertIndex4Decode
argument_list|(
name|reader
operator|.
name|index
argument_list|,
name|dataBlkNum
argument_list|,
name|parityBlkNum
argument_list|)
index|]
operator|=
operator|(
name|ByteBuffer
operator|)
name|buffer
operator|.
name|flip
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|.
name|length
operator|<
name|dataBlkNum
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zeroStripeBuffers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ByteBuffer
name|buffer
init|=
name|zeroStripeBuffers
index|[
name|i
index|]
decl_stmt|;
name|paddingBufferToLen
argument_list|(
name|buffer
argument_list|,
name|toRecoverLen
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|convertIndex4Decode
argument_list|(
name|zeroStripeIndices
index|[
name|i
index|]
argument_list|,
name|dataBlkNum
argument_list|,
name|parityBlkNum
argument_list|)
decl_stmt|;
name|inputs
index|[
name|index
index|]
operator|=
operator|(
name|ByteBuffer
operator|)
name|buffer
operator|.
name|flip
argument_list|()
expr_stmt|;
block|}
block|}
name|int
index|[]
name|erasedIndices
init|=
name|getErasedIndices
argument_list|(
name|targetsStatus
argument_list|)
decl_stmt|;
name|ByteBuffer
index|[]
name|outputs
init|=
operator|new
name|ByteBuffer
index|[
name|erasedIndices
operator|.
name|length
index|]
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetBuffers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|targetsStatus
index|[
name|i
index|]
condition|)
block|{
name|outputs
index|[
name|m
operator|++
index|]
operator|=
name|targetBuffers
index|[
name|i
index|]
expr_stmt|;
name|outputs
index|[
name|i
index|]
operator|.
name|limit
argument_list|(
name|toRecoverLen
argument_list|)
expr_stmt|;
block|}
block|}
name|decoder
operator|.
name|decode
argument_list|(
name|inputs
argument_list|,
name|erasedIndices
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|targetsStatus
index|[
name|i
index|]
condition|)
block|{
name|long
name|blockLen
init|=
name|getBlockLen
argument_list|(
name|blockGroup
argument_list|,
name|targetIndices
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|long
name|remaining
init|=
name|blockLen
operator|-
name|positionInBlock
decl_stmt|;
if|if
condition|(
name|remaining
operator|<
literal|0
condition|)
block|{
name|targetBuffers
index|[
name|i
index|]
operator|.
name|limit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remaining
operator|<
name|toRecoverLen
condition|)
block|{
name|targetBuffers
index|[
name|i
index|]
operator|.
name|limit
argument_list|(
operator|(
name|int
operator|)
name|remaining
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Schedule a read from some new source DN if some DN is corrupted      * or slow, this is called from the read iteration.      * Initially we may only have<code>minRequiredSources</code> number of       * StripedReader.      * If the position is at the end of target block, don't need to do       * real read, and return the array index of source DN, otherwise -1.      *       * @param used the used source DNs in this iteration.      * @return the array index of source DN if don't need to do real read.      */
DECL|method|scheduleNewRead (BitSet used)
specifier|private
name|int
name|scheduleNewRead
parameter_list|(
name|BitSet
name|used
parameter_list|)
block|{
name|StripedReader
name|reader
init|=
literal|null
decl_stmt|;
comment|// step1: initially we may only have<code>minRequiredSources</code>
comment|// number of StripedReader, and there may be some source DNs we never
comment|// read before, so will try to create StripedReader for one new source DN
comment|// and try to read from it. If found, go to step 3.
name|int
name|m
init|=
name|stripedReaders
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|reader
operator|==
literal|null
operator|&&
name|m
operator|<
name|sources
operator|.
name|length
condition|)
block|{
name|reader
operator|=
name|addStripedReader
argument_list|(
name|m
argument_list|,
name|positionInBlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|getReadLength
argument_list|(
name|liveIndices
index|[
name|m
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|blockReader
operator|==
literal|null
condition|)
block|{
name|reader
operator|=
literal|null
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|used
operator|.
name|set
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
block|}
comment|// step2: if there is no new source DN we can use, try to find a source
comment|// DN we ever read from but because some reason, e.g., slow, it
comment|// is not in the success DN list at the begin of this iteration, so
comment|// we have not tried it in this iteration. Now we have a chance to
comment|// revisit it again.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|reader
operator|==
literal|null
operator|&&
name|i
operator|<
name|stripedReaders
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|used
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|StripedReader
name|r
init|=
name|stripedReaders
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|getReadLength
argument_list|(
name|liveIndices
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|closeBlockReader
argument_list|(
name|r
operator|.
name|blockReader
argument_list|)
expr_stmt|;
name|r
operator|.
name|blockReader
operator|=
name|newBlockReader
argument_list|(
name|getBlock
argument_list|(
name|blockGroup
argument_list|,
name|liveIndices
index|[
name|i
index|]
argument_list|)
argument_list|,
name|positionInBlock
argument_list|,
name|sources
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|blockReader
operator|!=
literal|null
condition|)
block|{
name|m
operator|=
name|i
expr_stmt|;
name|reader
operator|=
name|r
expr_stmt|;
block|}
block|}
else|else
block|{
name|used
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|r
operator|.
name|buffer
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
block|}
comment|// step3: schedule if find a correct source DN and need to do real read.
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|Callable
argument_list|<
name|Void
argument_list|>
name|readCallable
init|=
name|readFromBlock
argument_list|(
name|reader
operator|.
name|blockReader
argument_list|,
name|reader
operator|.
name|buffer
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|Void
argument_list|>
name|f
init|=
name|readService
operator|.
name|submit
argument_list|(
name|readCallable
argument_list|)
decl_stmt|;
name|futures
operator|.
name|put
argument_list|(
name|f
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|used
operator|.
name|set
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// cancel all reads.
DECL|method|cancelReads (Collection<Future<Void>> futures)
specifier|private
name|void
name|cancelReads
parameter_list|(
name|Collection
argument_list|<
name|Future
argument_list|<
name|Void
argument_list|>
argument_list|>
name|futures
parameter_list|)
block|{
for|for
control|(
name|Future
argument_list|<
name|Void
argument_list|>
name|future
range|:
name|futures
control|)
block|{
name|future
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|readFromBlock (final BlockReader reader, final ByteBuffer buf)
specifier|private
name|Callable
argument_list|<
name|Void
argument_list|>
name|readFromBlock
parameter_list|(
specifier|final
name|BlockReader
name|reader
parameter_list|,
specifier|final
name|ByteBuffer
name|buf
parameter_list|)
block|{
return|return
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|actualReadFromBlock
argument_list|(
name|reader
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
return|;
block|}
comment|/**      * Read bytes from block      */
DECL|method|actualReadFromBlock (BlockReader reader, ByteBuffer buf)
specifier|private
name|void
name|actualReadFromBlock
parameter_list|(
name|BlockReader
name|reader
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
init|=
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|len
condition|)
block|{
name|int
name|nread
init|=
name|reader
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
name|n
operator|+=
name|nread
expr_stmt|;
block|}
block|}
comment|// close block reader
DECL|method|closeBlockReader (BlockReader blockReader)
specifier|private
name|void
name|closeBlockReader
parameter_list|(
name|BlockReader
name|blockReader
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|blockReader
operator|!=
literal|null
condition|)
block|{
name|blockReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
DECL|method|getSocketAddress4Transfer (DatanodeInfo dnInfo)
specifier|private
name|InetSocketAddress
name|getSocketAddress4Transfer
parameter_list|(
name|DatanodeInfo
name|dnInfo
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|dnInfo
operator|.
name|getXferAddr
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getConnectToDnViaHostname
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|newBlockReader (final ExtendedBlock block, long offsetInBlock, DatanodeInfo dnInfo)
specifier|private
name|BlockReader
name|newBlockReader
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|,
name|long
name|offsetInBlock
parameter_list|,
name|DatanodeInfo
name|dnInfo
parameter_list|)
block|{
if|if
condition|(
name|offsetInBlock
operator|>=
name|block
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
name|InetSocketAddress
name|dnAddr
init|=
name|getSocketAddress4Transfer
argument_list|(
name|dnInfo
argument_list|)
decl_stmt|;
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
init|=
name|datanode
operator|.
name|getBlockAccessToken
argument_list|(
name|block
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|READ
argument_list|)
argument_list|)
decl_stmt|;
comment|/*          * This can be further improved if the replica is local, then we can          * read directly from DN and need to check the replica is FINALIZED          * state, notice we should not use short-circuit local read which          * requires config for domain-socket in UNIX or legacy config in Windows.          *          * TODO: add proper tracer          */
return|return
name|RemoteBlockReader2
operator|.
name|newBlockReader
argument_list|(
literal|"dummy"
argument_list|,
name|block
argument_list|,
name|blockToken
argument_list|,
name|offsetInBlock
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
operator|-
name|offsetInBlock
argument_list|,
literal|true
argument_list|,
literal|""
argument_list|,
name|newConnectedPeer
argument_list|(
name|block
argument_list|,
name|dnAddr
argument_list|,
name|blockToken
argument_list|,
name|dnInfo
argument_list|)
argument_list|,
name|dnInfo
argument_list|,
literal|null
argument_list|,
name|cachingStrategy
argument_list|,
name|datanode
operator|.
name|getTracer
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
DECL|method|newConnectedPeer (ExtendedBlock b, InetSocketAddress addr, Token<BlockTokenIdentifier> blockToken, DatanodeID datanodeId)
specifier|private
name|Peer
name|newConnectedPeer
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
parameter_list|,
name|DatanodeID
name|datanodeId
parameter_list|)
throws|throws
name|IOException
block|{
name|Peer
name|peer
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|Socket
name|sock
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|socketTimeout
init|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getSocketTimeout
argument_list|()
decl_stmt|;
try|try
block|{
name|sock
operator|=
name|NetUtils
operator|.
name|getDefaultSocketFactory
argument_list|(
name|conf
argument_list|)
operator|.
name|createSocket
argument_list|()
expr_stmt|;
name|NetUtils
operator|.
name|connect
argument_list|(
name|sock
argument_list|,
name|addr
argument_list|,
name|socketTimeout
argument_list|)
expr_stmt|;
name|peer
operator|=
name|DFSUtilClient
operator|.
name|peerFromSocketAndKey
argument_list|(
name|datanode
operator|.
name|getSaslClient
argument_list|()
argument_list|,
name|sock
argument_list|,
name|datanode
operator|.
name|getDataEncryptionKeyFactoryForBlock
argument_list|(
name|b
argument_list|)
argument_list|,
name|blockToken
argument_list|,
name|datanodeId
argument_list|)
expr_stmt|;
name|peer
operator|.
name|setReadTimeout
argument_list|(
name|socketTimeout
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|peer
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Send data to targets      */
DECL|method|transferData2Targets (boolean[] targetsStatus)
specifier|private
name|int
name|transferData2Targets
parameter_list|(
name|boolean
index|[]
name|targetsStatus
parameter_list|)
block|{
name|int
name|nsuccess
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|targetsStatus
index|[
name|i
index|]
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|ByteBuffer
name|buffer
init|=
name|targetBuffers
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|buffer
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|checksum
operator|.
name|calculateChunkedSums
argument_list|(
name|buffer
operator|.
name|array
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|remaining
argument_list|()
argument_list|,
name|checksumBuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|ckOff
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
name|DFSPacket
name|packet
init|=
operator|new
name|DFSPacket
argument_list|(
name|packetBuf
argument_list|,
name|maxChunksPerPacket
argument_list|,
name|blockOffset4Targets
index|[
name|i
index|]
argument_list|,
name|seqNo4Targets
index|[
name|i
index|]
operator|++
argument_list|,
name|checksumSize
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|maxBytesToPacket
init|=
name|maxChunksPerPacket
operator|*
name|bytesPerChecksum
decl_stmt|;
name|int
name|toWrite
init|=
name|buffer
operator|.
name|remaining
argument_list|()
operator|>
name|maxBytesToPacket
condition|?
name|maxBytesToPacket
else|:
name|buffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|int
name|ckLen
init|=
operator|(
operator|(
name|toWrite
operator|-
literal|1
operator|)
operator|/
name|bytesPerChecksum
operator|+
literal|1
operator|)
operator|*
name|checksumSize
decl_stmt|;
name|packet
operator|.
name|writeChecksum
argument_list|(
name|checksumBuf
argument_list|,
name|ckOff
argument_list|,
name|ckLen
argument_list|)
expr_stmt|;
name|ckOff
operator|+=
name|ckLen
expr_stmt|;
name|packet
operator|.
name|writeData
argument_list|(
name|buffer
argument_list|,
name|toWrite
argument_list|)
expr_stmt|;
comment|// Send packet
name|packet
operator|.
name|writeTo
argument_list|(
name|targetOutputStreams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|blockOffset4Targets
index|[
name|i
index|]
operator|+=
name|toWrite
expr_stmt|;
name|nsuccess
operator|++
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|targetsStatus
index|[
name|i
index|]
operator|=
name|success
expr_stmt|;
block|}
block|}
return|return
name|nsuccess
return|;
block|}
comment|/**      * clear all buffers      */
DECL|method|clearBuffers ()
specifier|private
name|void
name|clearBuffers
parameter_list|()
block|{
for|for
control|(
name|StripedReader
name|stripedReader
range|:
name|stripedReaders
control|)
block|{
if|if
condition|(
name|stripedReader
operator|.
name|buffer
operator|!=
literal|null
condition|)
block|{
name|stripedReader
operator|.
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zeroStripeBuffers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zeroStripeBuffers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|zeroStripeBuffers
index|[
name|i
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetBuffers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|targetBuffers
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|cleanBuffer
argument_list|(
name|targetBuffers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|cleanBuffer (ByteBuffer buffer)
specifier|private
name|ByteBuffer
name|cleanBuffer
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|buffer
operator|.
name|array
argument_list|()
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ByteBuffer
operator|)
name|buffer
operator|.
name|clear
argument_list|()
return|;
block|}
comment|// send an empty packet to mark the end of the block
DECL|method|endTargetBlocks (boolean[] targetsStatus)
specifier|private
name|void
name|endTargetBlocks
parameter_list|(
name|boolean
index|[]
name|targetsStatus
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|targetsStatus
index|[
name|i
index|]
condition|)
block|{
try|try
block|{
name|DFSPacket
name|packet
init|=
operator|new
name|DFSPacket
argument_list|(
name|packetBuf
argument_list|,
literal|0
argument_list|,
name|blockOffset4Targets
index|[
name|i
index|]
argument_list|,
name|seqNo4Targets
index|[
name|i
index|]
operator|++
argument_list|,
name|checksumSize
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|packet
operator|.
name|writeTo
argument_list|(
name|targetOutputStreams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|targetOutputStreams
index|[
name|i
index|]
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Initialize  output/input streams for transferring data to target      * and send create block request.       */
DECL|method|initTargetStreams (boolean[] targetsStatus)
specifier|private
name|int
name|initTargetStreams
parameter_list|(
name|boolean
index|[]
name|targetsStatus
parameter_list|)
block|{
name|int
name|nsuccess
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Socket
name|socket
init|=
literal|null
decl_stmt|;
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|InetSocketAddress
name|targetAddr
init|=
name|getSocketAddress4Transfer
argument_list|(
name|targets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|socket
operator|=
name|datanode
operator|.
name|newSocket
argument_list|()
expr_stmt|;
name|NetUtils
operator|.
name|connect
argument_list|(
name|socket
argument_list|,
name|targetAddr
argument_list|,
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getSocketTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|socket
operator|.
name|setSoTimeout
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getSocketTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|ExtendedBlock
name|block
init|=
name|getBlock
argument_list|(
name|blockGroup
argument_list|,
name|targetIndices
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
init|=
name|datanode
operator|.
name|getBlockAccessToken
argument_list|(
name|block
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|writeTimeout
init|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getSocketWriteTimeout
argument_list|()
decl_stmt|;
name|OutputStream
name|unbufOut
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|socket
argument_list|,
name|writeTimeout
argument_list|)
decl_stmt|;
name|InputStream
name|unbufIn
init|=
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|socket
argument_list|)
decl_stmt|;
name|DataEncryptionKeyFactory
name|keyFactory
init|=
name|datanode
operator|.
name|getDataEncryptionKeyFactoryForBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|IOStreamPair
name|saslStreams
init|=
name|datanode
operator|.
name|getSaslClient
argument_list|()
operator|.
name|socketSend
argument_list|(
name|socket
argument_list|,
name|unbufOut
argument_list|,
name|unbufIn
argument_list|,
name|keyFactory
argument_list|,
name|blockToken
argument_list|,
name|targets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|unbufOut
operator|=
name|saslStreams
operator|.
name|out
expr_stmt|;
name|unbufIn
operator|=
name|saslStreams
operator|.
name|in
expr_stmt|;
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|unbufOut
argument_list|,
name|DFSUtilClient
operator|.
name|getSmallBufferSize
argument_list|(
name|conf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
name|unbufIn
argument_list|)
expr_stmt|;
name|DatanodeInfo
name|source
init|=
operator|new
name|DatanodeInfo
argument_list|(
name|datanode
operator|.
name|getDatanodeId
argument_list|()
argument_list|)
decl_stmt|;
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|writeBlock
argument_list|(
name|block
argument_list|,
name|targetStorageTypes
index|[
name|i
index|]
argument_list|,
name|blockToken
argument_list|,
literal|""
argument_list|,
operator|new
name|DatanodeInfo
index|[]
block|{
name|targets
index|[
name|i
index|]
block|}
argument_list|,
operator|new
name|StorageType
index|[]
block|{
name|targetStorageTypes
index|[
name|i
index|]
block|}
argument_list|,
name|source
argument_list|,
name|BlockConstructionStage
operator|.
name|PIPELINE_SETUP_CREATE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|checksum
argument_list|,
name|cachingStrategy
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|targetSockets
index|[
name|i
index|]
operator|=
name|socket
expr_stmt|;
name|targetOutputStreams
index|[
name|i
index|]
operator|=
name|out
expr_stmt|;
name|targetInputStreams
index|[
name|i
index|]
operator|=
name|in
expr_stmt|;
name|nsuccess
operator|++
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|socket
argument_list|)
expr_stmt|;
block|}
block|}
name|targetsStatus
index|[
name|i
index|]
operator|=
name|success
expr_stmt|;
block|}
return|return
name|nsuccess
return|;
block|}
block|}
DECL|class|StripedReader
specifier|private
specifier|static
class|class
name|StripedReader
block|{
DECL|field|index
specifier|private
specifier|final
name|short
name|index
decl_stmt|;
comment|// internal block index
DECL|field|blockReader
specifier|private
name|BlockReader
name|blockReader
decl_stmt|;
DECL|field|buffer
specifier|private
name|ByteBuffer
name|buffer
decl_stmt|;
DECL|method|StripedReader (short index)
specifier|private
name|StripedReader
parameter_list|(
name|short
name|index
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

