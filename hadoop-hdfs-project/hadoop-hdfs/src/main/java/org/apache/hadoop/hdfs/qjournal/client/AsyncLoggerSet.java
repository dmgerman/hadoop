begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.qjournal.client
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|protocol
operator|.
name|QJournalProtocolProtos
operator|.
name|GetEditLogManifestResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|protocol
operator|.
name|QJournalProtocolProtos
operator|.
name|GetJournalStateResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|protocol
operator|.
name|QJournalProtocolProtos
operator|.
name|NewEpochResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|protocol
operator|.
name|QJournalProtocolProtos
operator|.
name|PrepareRecoveryResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|qjournal
operator|.
name|protocol
operator|.
name|QJournalProtocolProtos
operator|.
name|SegmentStateProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|RemoteEditLogManifest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_comment
comment|/**  * Wrapper around a set of Loggers, taking care of fanning out  * calls to the underlying loggers and constructing corresponding  * {@link QuorumCall} instances.  */
end_comment

begin_class
DECL|class|AsyncLoggerSet
class|class
name|AsyncLoggerSet
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AsyncLoggerSet
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NEWEPOCH_TIMEOUT_MS
specifier|private
specifier|static
specifier|final
name|int
name|NEWEPOCH_TIMEOUT_MS
init|=
literal|10000
decl_stmt|;
DECL|field|loggers
specifier|private
specifier|final
name|List
argument_list|<
name|AsyncLogger
argument_list|>
name|loggers
decl_stmt|;
DECL|field|INVALID_EPOCH
specifier|private
specifier|static
specifier|final
name|long
name|INVALID_EPOCH
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|myEpoch
specifier|private
name|long
name|myEpoch
init|=
name|INVALID_EPOCH
decl_stmt|;
DECL|method|AsyncLoggerSet (List<AsyncLogger> loggers)
specifier|public
name|AsyncLoggerSet
parameter_list|(
name|List
argument_list|<
name|AsyncLogger
argument_list|>
name|loggers
parameter_list|)
block|{
name|this
operator|.
name|loggers
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|loggers
argument_list|)
expr_stmt|;
block|}
comment|/**    * Fence any previous writers, and obtain a unique epoch number    * for write-access to the journal nodes.    *    * @param nsInfo the expected namespace information. If the remote    * node does not match with this namespace, the request will be rejected.    * @return the new, unique epoch number    * @throws IOException    */
DECL|method|createNewUniqueEpoch ( NamespaceInfo nsInfo)
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|NewEpochResponseProto
argument_list|>
name|createNewUniqueEpoch
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|myEpoch
operator|==
operator|-
literal|1
argument_list|,
literal|"epoch already created: epoch="
operator|+
name|myEpoch
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|GetJournalStateResponseProto
argument_list|>
name|lastPromises
init|=
name|waitForWriteQuorum
argument_list|(
name|getJournalState
argument_list|()
argument_list|,
name|NEWEPOCH_TIMEOUT_MS
argument_list|)
decl_stmt|;
name|long
name|maxPromised
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
for|for
control|(
name|GetJournalStateResponseProto
name|resp
range|:
name|lastPromises
operator|.
name|values
argument_list|()
control|)
block|{
name|maxPromised
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxPromised
argument_list|,
name|resp
operator|.
name|getLastPromisedEpoch
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|maxPromised
operator|>=
literal|0
assert|;
name|long
name|myEpoch
init|=
name|maxPromised
operator|+
literal|1
decl_stmt|;
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|NewEpochResponseProto
argument_list|>
name|resps
init|=
name|waitForWriteQuorum
argument_list|(
name|newEpoch
argument_list|(
name|nsInfo
argument_list|,
name|myEpoch
argument_list|)
argument_list|,
name|NEWEPOCH_TIMEOUT_MS
argument_list|)
decl_stmt|;
name|this
operator|.
name|myEpoch
operator|=
name|myEpoch
expr_stmt|;
name|setEpoch
argument_list|(
name|myEpoch
argument_list|)
expr_stmt|;
return|return
name|resps
return|;
block|}
DECL|method|setEpoch (long e)
specifier|private
name|void
name|setEpoch
parameter_list|(
name|long
name|e
parameter_list|)
block|{
for|for
control|(
name|AsyncLogger
name|l
range|:
name|loggers
control|)
block|{
name|l
operator|.
name|setEpoch
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return the epoch number for this writer. This may only be called after    * a successful call to {@link #createNewUniqueEpoch(NamespaceInfo)}.    */
DECL|method|getEpoch ()
name|long
name|getEpoch
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|myEpoch
operator|!=
name|INVALID_EPOCH
argument_list|,
literal|"No epoch created yet"
argument_list|)
expr_stmt|;
return|return
name|myEpoch
return|;
block|}
comment|/**    * Close all of the underlying loggers.    */
DECL|method|close ()
name|void
name|close
parameter_list|()
block|{
for|for
control|(
name|AsyncLogger
name|logger
range|:
name|loggers
control|)
block|{
name|logger
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Wait for a quorum of loggers to respond to the given call. If a quorum    * can't be achieved, throws a QuorumException.    * @param q the quorum call    * @param timeoutMs the number of millis to wait    * @return a map of successful results    * @throws QuorumException if a quorum doesn't respond with success    * @throws IOException if the thread is interrupted or times out    */
DECL|method|waitForWriteQuorum (QuorumCall<AsyncLogger, V> q, int timeoutMs)
parameter_list|<
name|V
parameter_list|>
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|V
argument_list|>
name|waitForWriteQuorum
parameter_list|(
name|QuorumCall
argument_list|<
name|AsyncLogger
argument_list|,
name|V
argument_list|>
name|q
parameter_list|,
name|int
name|timeoutMs
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|majority
init|=
name|getMajoritySize
argument_list|()
decl_stmt|;
try|try
block|{
name|q
operator|.
name|waitFor
argument_list|(
name|loggers
operator|.
name|size
argument_list|()
argument_list|,
comment|// either all respond
name|majority
argument_list|,
comment|// or we get a majority successes
name|majority
argument_list|,
comment|// or we get a majority failures,
name|timeoutMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted waiting for quorum results"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Timed out waiting "
operator|+
name|timeoutMs
operator|+
literal|" for write quorum"
argument_list|)
throw|;
block|}
if|if
condition|(
name|q
operator|.
name|countSuccesses
argument_list|()
operator|<
name|majority
condition|)
block|{
name|q
operator|.
name|rethrowException
argument_list|(
literal|"Got too many exceptions to achieve quorum size "
operator|+
name|getMajorityString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|q
operator|.
name|getResults
argument_list|()
return|;
block|}
comment|/**    * @return the number of nodes which are required to obtain a quorum.    */
DECL|method|getMajoritySize ()
name|int
name|getMajoritySize
parameter_list|()
block|{
return|return
name|loggers
operator|.
name|size
argument_list|()
operator|/
literal|2
operator|+
literal|1
return|;
block|}
comment|/**    * @return a textual description of the majority size (eg "2/3" or "3/5")    */
DECL|method|getMajorityString ()
name|String
name|getMajorityString
parameter_list|()
block|{
return|return
name|getMajoritySize
argument_list|()
operator|+
literal|"/"
operator|+
name|loggers
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * @return the number of loggers behind this set    */
DECL|method|size ()
name|int
name|size
parameter_list|()
block|{
return|return
name|loggers
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * @return the (mutable) list of loggers, for use in tests to    * set up spies    */
annotation|@
name|VisibleForTesting
DECL|method|getLoggersForTests ()
name|List
argument_list|<
name|AsyncLogger
argument_list|>
name|getLoggersForTests
parameter_list|()
block|{
return|return
name|loggers
return|;
block|}
comment|///////////////////////////////////////////////////////////////////////////
comment|// The rest of this file is simply boilerplate wrappers which fan-out the
comment|// various IPC calls to the underlying AsyncLoggers and wrap the result
comment|// in a QuorumCall.
comment|///////////////////////////////////////////////////////////////////////////
DECL|method|getJournalState ()
specifier|private
name|QuorumCall
argument_list|<
name|AsyncLogger
argument_list|,
name|GetJournalStateResponseProto
argument_list|>
name|getJournalState
parameter_list|()
block|{
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|ListenableFuture
argument_list|<
name|GetJournalStateResponseProto
argument_list|>
argument_list|>
name|calls
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|AsyncLogger
name|logger
range|:
name|loggers
control|)
block|{
name|calls
operator|.
name|put
argument_list|(
name|logger
argument_list|,
name|logger
operator|.
name|getJournalState
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|QuorumCall
operator|.
name|create
argument_list|(
name|calls
argument_list|)
return|;
block|}
DECL|method|newEpoch ( NamespaceInfo nsInfo, long epoch)
specifier|private
name|QuorumCall
argument_list|<
name|AsyncLogger
argument_list|,
name|NewEpochResponseProto
argument_list|>
name|newEpoch
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|,
name|long
name|epoch
parameter_list|)
block|{
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|ListenableFuture
argument_list|<
name|NewEpochResponseProto
argument_list|>
argument_list|>
name|calls
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|AsyncLogger
name|logger
range|:
name|loggers
control|)
block|{
name|calls
operator|.
name|put
argument_list|(
name|logger
argument_list|,
name|logger
operator|.
name|newEpoch
argument_list|(
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|QuorumCall
operator|.
name|create
argument_list|(
name|calls
argument_list|)
return|;
block|}
DECL|method|startLogSegment ( long txid)
specifier|public
name|QuorumCall
argument_list|<
name|AsyncLogger
argument_list|,
name|Void
argument_list|>
name|startLogSegment
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
argument_list|>
name|calls
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|AsyncLogger
name|logger
range|:
name|loggers
control|)
block|{
name|calls
operator|.
name|put
argument_list|(
name|logger
argument_list|,
name|logger
operator|.
name|startLogSegment
argument_list|(
name|txid
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|QuorumCall
operator|.
name|create
argument_list|(
name|calls
argument_list|)
return|;
block|}
DECL|method|finalizeLogSegment (long firstTxId, long lastTxId)
specifier|public
name|QuorumCall
argument_list|<
name|AsyncLogger
argument_list|,
name|Void
argument_list|>
name|finalizeLogSegment
parameter_list|(
name|long
name|firstTxId
parameter_list|,
name|long
name|lastTxId
parameter_list|)
block|{
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
argument_list|>
name|calls
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|AsyncLogger
name|logger
range|:
name|loggers
control|)
block|{
name|calls
operator|.
name|put
argument_list|(
name|logger
argument_list|,
name|logger
operator|.
name|finalizeLogSegment
argument_list|(
name|firstTxId
argument_list|,
name|lastTxId
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|QuorumCall
operator|.
name|create
argument_list|(
name|calls
argument_list|)
return|;
block|}
DECL|method|sendEdits ( long firstTxnId, int numTxns, byte[] data)
specifier|public
name|QuorumCall
argument_list|<
name|AsyncLogger
argument_list|,
name|Void
argument_list|>
name|sendEdits
parameter_list|(
name|long
name|firstTxnId
parameter_list|,
name|int
name|numTxns
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
argument_list|>
name|calls
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|AsyncLogger
name|logger
range|:
name|loggers
control|)
block|{
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|future
init|=
name|logger
operator|.
name|sendEdits
argument_list|(
name|firstTxnId
argument_list|,
name|numTxns
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|calls
operator|.
name|put
argument_list|(
name|logger
argument_list|,
name|future
argument_list|)
expr_stmt|;
block|}
return|return
name|QuorumCall
operator|.
name|create
argument_list|(
name|calls
argument_list|)
return|;
block|}
specifier|public
name|QuorumCall
argument_list|<
name|AsyncLogger
argument_list|,
name|RemoteEditLogManifest
argument_list|>
DECL|method|getEditLogManifest (long fromTxnId)
name|getEditLogManifest
parameter_list|(
name|long
name|fromTxnId
parameter_list|)
block|{
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|ListenableFuture
argument_list|<
name|RemoteEditLogManifest
argument_list|>
argument_list|>
name|calls
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|AsyncLogger
name|logger
range|:
name|loggers
control|)
block|{
name|ListenableFuture
argument_list|<
name|RemoteEditLogManifest
argument_list|>
name|future
init|=
name|logger
operator|.
name|getEditLogManifest
argument_list|(
name|fromTxnId
argument_list|)
decl_stmt|;
name|calls
operator|.
name|put
argument_list|(
name|logger
argument_list|,
name|future
argument_list|)
expr_stmt|;
block|}
return|return
name|QuorumCall
operator|.
name|create
argument_list|(
name|calls
argument_list|)
return|;
block|}
name|QuorumCall
argument_list|<
name|AsyncLogger
argument_list|,
name|PrepareRecoveryResponseProto
argument_list|>
DECL|method|prepareRecovery (long segmentTxId)
name|prepareRecovery
parameter_list|(
name|long
name|segmentTxId
parameter_list|)
block|{
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|ListenableFuture
argument_list|<
name|PrepareRecoveryResponseProto
argument_list|>
argument_list|>
name|calls
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|AsyncLogger
name|logger
range|:
name|loggers
control|)
block|{
name|ListenableFuture
argument_list|<
name|PrepareRecoveryResponseProto
argument_list|>
name|future
init|=
name|logger
operator|.
name|prepareRecovery
argument_list|(
name|segmentTxId
argument_list|)
decl_stmt|;
name|calls
operator|.
name|put
argument_list|(
name|logger
argument_list|,
name|future
argument_list|)
expr_stmt|;
block|}
return|return
name|QuorumCall
operator|.
name|create
argument_list|(
name|calls
argument_list|)
return|;
block|}
name|QuorumCall
argument_list|<
name|AsyncLogger
argument_list|,
name|Void
argument_list|>
DECL|method|acceptRecovery (SegmentStateProto log, URL fromURL)
name|acceptRecovery
parameter_list|(
name|SegmentStateProto
name|log
parameter_list|,
name|URL
name|fromURL
parameter_list|)
block|{
name|Map
argument_list|<
name|AsyncLogger
argument_list|,
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
argument_list|>
name|calls
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|AsyncLogger
name|logger
range|:
name|loggers
control|)
block|{
name|ListenableFuture
argument_list|<
name|Void
argument_list|>
name|future
init|=
name|logger
operator|.
name|acceptRecovery
argument_list|(
name|log
argument_list|,
name|fromURL
argument_list|)
decl_stmt|;
name|calls
operator|.
name|put
argument_list|(
name|logger
argument_list|,
name|future
argument_list|)
expr_stmt|;
block|}
return|return
name|QuorumCall
operator|.
name|create
argument_list|(
name|calls
argument_list|)
return|;
block|}
block|}
end_class

end_unit

