begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_ADMIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_HTTPS_NEED_AUTH_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_ADDRESS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_PERMISSION_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_PERMISSION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DIRECTORYSCAN_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DNS_INTERFACE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DNS_INTERFACE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DNS_NAMESERVER_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DNS_NAMESERVER_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_HANDLER_COUNT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_HANDLER_COUNT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_HOST_NAME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_HTTPS_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_HTTP_ADDRESS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_HTTP_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_IPC_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_KEYTAB_FILE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_MAX_LOCKED_MEMORY_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_PLUGINS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SCAN_PERIOD_HOURS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SCAN_PERIOD_HOURS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STARTUP_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_USER_NAME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HTTPS_ENABLE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|terminate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedByInterruptException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HDFSPolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
operator|.
name|DomainPeerServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
operator|.
name|TcpPeerServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockLocalPathInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsBlocksMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|BlockConstructionStage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|DataTransferEncryptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|DataTransferProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|IOStreamPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|ClientDatanodeProtocolProtos
operator|.
name|ClientDatanodeProtocolService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|DNTransferAckProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|InterDatanodeProtocolProtos
operator|.
name|InterDatanodeProtocolService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|ClientDatanodeProtocolPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|ClientDatanodeProtocolServerSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|DatanodeProtocolClientSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|InterDatanodeProtocolPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|InterDatanodeProtocolServerSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|InterDatanodeProtocolTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|PBHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockPoolTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
operator|.
name|AccessMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|ExportedBlockKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|InvalidBlockTokenException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|JspHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|StorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|SecureDataNodeStarter
operator|.
name|SecureResources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsDatasetSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|metrics
operator|.
name|DataNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|web
operator|.
name|resources
operator|.
name|DatanodeWebHdfsMethods
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FileChecksumServlets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|StreamFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|InterDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReplicaRecoveryInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|WebHdfsFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|resources
operator|.
name|Param
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|http
operator|.
name|HttpServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|ReadaheadPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|ProtobufRpcEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|unix
operator|.
name|DomainSocket
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|AuthenticationMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskErrorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskOutOfSpaceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|GenericOptionsParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|JvmPauseMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ServicePlugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|util
operator|.
name|ajax
operator|.
name|JSON
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingService
import|;
end_import

begin_comment
comment|/**********************************************************  * DataNode is a class (and program) that stores a set of  * blocks for a DFS deployment.  A single deployment can  * have one or many DataNodes.  Each DataNode communicates  * regularly with a single NameNode.  It also communicates  * with client code and other DataNodes from time to time.  *  * DataNodes store a series of named blocks.  The DataNode  * allows client code to read these blocks, or to write new  * block data.  The DataNode may also, in response to instructions  * from its NameNode, delete blocks or copy blocks to/from other  * DataNodes.  *  * The DataNode maintains just one critical table:  *   block-> stream of bytes (of BLOCK_SIZE or less)  *  * This info is stored on a local disk.  The DataNode  * reports the table's contents to the NameNode upon startup  * and every so often afterwards.  *  * DataNodes spend their lives in an endless loop of asking  * the NameNode for something to do.  A NameNode cannot connect  * to a DataNode directly; a NameNode simply returns values from  * functions invoked by a DataNode.  *  * DataNodes maintain an open server socket so that client code   * or other DataNodes can read/write data.  The host/port for  * this server is reported to the NameNode, which then sends that  * information to clients or other DataNodes that might be interested.  *  **********************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|DataNode
specifier|public
class|class
name|DataNode
extends|extends
name|Configured
implements|implements
name|InterDatanodeProtocol
implements|,
name|ClientDatanodeProtocol
implements|,
name|DataNodeMXBean
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DataNode
operator|.
name|class
argument_list|)
decl_stmt|;
static|static
block|{
name|HdfsConfiguration
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
DECL|field|DN_CLIENTTRACE_FORMAT
specifier|public
specifier|static
specifier|final
name|String
name|DN_CLIENTTRACE_FORMAT
init|=
literal|"src: %s"
operator|+
comment|// src IP
literal|", dest: %s"
operator|+
comment|// dst IP
literal|", bytes: %s"
operator|+
comment|// byte count
literal|", op: %s"
operator|+
comment|// operation
literal|", cliID: %s"
operator|+
comment|// DFSClient id
literal|", offset: %s"
operator|+
comment|// offset
literal|", srvID: %s"
operator|+
comment|// DatanodeRegistration
literal|", blockid: %s"
operator|+
comment|// block id
literal|", duration: %s"
decl_stmt|;
comment|// duration time
DECL|field|ClientTraceLog
specifier|static
specifier|final
name|Log
name|ClientTraceLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DataNode
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".clienttrace"
argument_list|)
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"Usage: java DataNode [-rollback | -regular]"
decl_stmt|;
DECL|field|CURRENT_BLOCK_FORMAT_VERSION
specifier|static
specifier|final
name|int
name|CURRENT_BLOCK_FORMAT_VERSION
init|=
literal|1
decl_stmt|;
comment|/**    * Use {@link NetUtils#createSocketAddr(String)} instead.    */
annotation|@
name|Deprecated
DECL|method|createSocketAddr (String target)
specifier|public
specifier|static
name|InetSocketAddress
name|createSocketAddr
parameter_list|(
name|String
name|target
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|target
argument_list|)
return|;
block|}
DECL|field|shouldRun
specifier|volatile
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
DECL|field|blockPoolManager
specifier|private
name|BlockPoolManager
name|blockPoolManager
decl_stmt|;
DECL|field|data
specifier|volatile
name|FsDatasetSpi
argument_list|<
name|?
extends|extends
name|FsVolumeSpi
argument_list|>
name|data
init|=
literal|null
decl_stmt|;
DECL|field|clusterId
specifier|private
name|String
name|clusterId
init|=
literal|null
decl_stmt|;
DECL|field|EMPTY_DEL_HINT
specifier|public
specifier|final
specifier|static
name|String
name|EMPTY_DEL_HINT
init|=
literal|""
decl_stmt|;
DECL|field|xmitsInProgress
name|AtomicInteger
name|xmitsInProgress
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|dataXceiverServer
name|Daemon
name|dataXceiverServer
init|=
literal|null
decl_stmt|;
DECL|field|localDataXceiverServer
name|Daemon
name|localDataXceiverServer
init|=
literal|null
decl_stmt|;
DECL|field|threadGroup
name|ThreadGroup
name|threadGroup
init|=
literal|null
decl_stmt|;
DECL|field|dnConf
specifier|private
name|DNConf
name|dnConf
decl_stmt|;
DECL|field|heartbeatsDisabledForTests
specifier|private
specifier|volatile
name|boolean
name|heartbeatsDisabledForTests
init|=
literal|false
decl_stmt|;
DECL|field|storage
specifier|private
name|DataStorage
name|storage
init|=
literal|null
decl_stmt|;
DECL|field|infoServer
specifier|private
name|HttpServer
name|infoServer
init|=
literal|null
decl_stmt|;
DECL|field|metrics
name|DataNodeMetrics
name|metrics
decl_stmt|;
DECL|field|streamingAddr
specifier|private
name|InetSocketAddress
name|streamingAddr
decl_stmt|;
DECL|field|hostName
specifier|private
name|String
name|hostName
decl_stmt|;
DECL|field|id
specifier|private
name|DatanodeID
name|id
decl_stmt|;
DECL|field|fileDescriptorPassingDisabledReason
specifier|final
specifier|private
name|String
name|fileDescriptorPassingDisabledReason
decl_stmt|;
DECL|field|isBlockTokenEnabled
name|boolean
name|isBlockTokenEnabled
decl_stmt|;
DECL|field|blockPoolTokenSecretManager
name|BlockPoolTokenSecretManager
name|blockPoolTokenSecretManager
decl_stmt|;
DECL|field|hasAnyBlockPoolRegistered
specifier|private
name|boolean
name|hasAnyBlockPoolRegistered
init|=
literal|false
decl_stmt|;
DECL|field|blockScanner
specifier|volatile
name|DataBlockScanner
name|blockScanner
init|=
literal|null
decl_stmt|;
DECL|field|directoryScanner
specifier|private
name|DirectoryScanner
name|directoryScanner
init|=
literal|null
decl_stmt|;
comment|/** Activated plug-ins. */
DECL|field|plugins
specifier|private
name|List
argument_list|<
name|ServicePlugin
argument_list|>
name|plugins
decl_stmt|;
comment|// For InterDataNodeProtocol
DECL|field|ipcServer
specifier|public
name|RPC
operator|.
name|Server
name|ipcServer
decl_stmt|;
DECL|field|pauseMonitor
specifier|private
name|JvmPauseMonitor
name|pauseMonitor
decl_stmt|;
DECL|field|secureResources
specifier|private
name|SecureResources
name|secureResources
init|=
literal|null
decl_stmt|;
DECL|field|dataDirs
specifier|private
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|usersWithLocalPathAccess
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|usersWithLocalPathAccess
decl_stmt|;
DECL|field|connectToDnViaHostname
specifier|private
name|boolean
name|connectToDnViaHostname
decl_stmt|;
DECL|field|readaheadPool
name|ReadaheadPool
name|readaheadPool
decl_stmt|;
DECL|field|getHdfsBlockLocationsEnabled
specifier|private
specifier|final
name|boolean
name|getHdfsBlockLocationsEnabled
decl_stmt|;
comment|/**    * Create the DataNode given a configuration and an array of dataDirs.    * 'dataDirs' is where the blocks are stored.    */
DECL|method|DataNode (final Configuration conf, final AbstractList<File> dataDirs)
name|DataNode
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|dataDirs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create the DataNode given a configuration, an array of dataDirs,    * and a namenode proxy    */
DECL|method|DataNode (final Configuration conf, final AbstractList<File> dataDirs, final SecureResources resources)
name|DataNode
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
parameter_list|,
specifier|final
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|usersWithLocalPathAccess
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_LOCAL_PATH_ACCESS_USER_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectToDnViaHostname
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_USE_DN_HOSTNAME
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_USE_DN_HOSTNAME_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|getHdfsBlockLocationsEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HDFS_BLOCKS_METADATA_ENABLED
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_HDFS_BLOCKS_METADATA_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
comment|// Determine whether we should try to pass file descriptors to clients.
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_READ_SHORTCIRCUIT_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_READ_SHORTCIRCUIT_DEFAULT
argument_list|)
condition|)
block|{
name|String
name|reason
init|=
name|DomainSocket
operator|.
name|getLoadingFailureReason
argument_list|()
decl_stmt|;
if|if
condition|(
name|reason
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"File descriptor passing is disabled because "
operator|+
name|reason
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileDescriptorPassingDisabledReason
operator|=
name|reason
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"File descriptor passing is enabled."
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileDescriptorPassingDisabledReason
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|fileDescriptorPassingDisabledReason
operator|=
literal|"File descriptor passing was not configured."
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|.
name|fileDescriptorPassingDisabledReason
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|hostName
operator|=
name|getHostName
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Configured hostname is "
operator|+
name|hostName
argument_list|)
expr_stmt|;
name|startDataNode
argument_list|(
name|conf
argument_list|,
name|dataDirs
argument_list|,
name|resources
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|shutdown
argument_list|()
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
block|}
DECL|method|setClusterId (final String nsCid, final String bpid )
specifier|private
specifier|synchronized
name|void
name|setClusterId
parameter_list|(
specifier|final
name|String
name|nsCid
parameter_list|,
specifier|final
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|clusterId
operator|!=
literal|null
operator|&&
operator|!
name|clusterId
operator|.
name|equals
argument_list|(
name|nsCid
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cluster IDs not matched: dn cid="
operator|+
name|clusterId
operator|+
literal|" but ns cid="
operator|+
name|nsCid
operator|+
literal|"; bpid="
operator|+
name|bpid
argument_list|)
throw|;
block|}
comment|// else
name|clusterId
operator|=
name|nsCid
expr_stmt|;
block|}
comment|/**    * Returns the hostname for this datanode. If the hostname is not    * explicitly configured in the given config, then it is determined    * via the DNS class.    *    * @param config    * @return the hostname (NB: may not be a FQDN)    * @throws UnknownHostException if the dfs.datanode.dns.interface    *    option is used and the hostname can not be determined    */
DECL|method|getHostName (Configuration config)
specifier|private
specifier|static
name|String
name|getHostName
parameter_list|(
name|Configuration
name|config
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|String
name|name
init|=
name|config
operator|.
name|get
argument_list|(
name|DFS_DATANODE_HOST_NAME_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|name
operator|=
name|DNS
operator|.
name|getDefaultHost
argument_list|(
name|config
operator|.
name|get
argument_list|(
name|DFS_DATANODE_DNS_INTERFACE_KEY
argument_list|,
name|DFS_DATANODE_DNS_INTERFACE_DEFAULT
argument_list|)
argument_list|,
name|config
operator|.
name|get
argument_list|(
name|DFS_DATANODE_DNS_NAMESERVER_KEY
argument_list|,
name|DFS_DATANODE_DNS_NAMESERVER_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
DECL|method|startInfoServer (Configuration conf)
specifier|private
name|void
name|startInfoServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// create a servlet to serve full-file content
name|InetSocketAddress
name|infoSocAddr
init|=
name|DataNode
operator|.
name|getInfoAddr
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|infoHost
init|=
name|infoSocAddr
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|int
name|tmpInfoPort
init|=
name|infoSocAddr
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|this
operator|.
name|infoServer
operator|=
operator|(
name|secureResources
operator|==
literal|null
operator|)
condition|?
operator|new
name|HttpServer
argument_list|(
literal|"datanode"
argument_list|,
name|infoHost
argument_list|,
name|tmpInfoPort
argument_list|,
name|tmpInfoPort
operator|==
literal|0
argument_list|,
name|conf
argument_list|,
operator|new
name|AccessControlList
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_ADMIN
argument_list|,
literal|" "
argument_list|)
argument_list|)
argument_list|)
else|:
operator|new
name|HttpServer
argument_list|(
literal|"datanode"
argument_list|,
name|infoHost
argument_list|,
name|tmpInfoPort
argument_list|,
name|tmpInfoPort
operator|==
literal|0
argument_list|,
name|conf
argument_list|,
operator|new
name|AccessControlList
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_ADMIN
argument_list|,
literal|" "
argument_list|)
argument_list|)
argument_list|,
name|secureResources
operator|.
name|getListener
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opened info server at "
operator|+
name|infoHost
operator|+
literal|":"
operator|+
name|tmpInfoPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_HTTPS_ENABLE_KEY
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|boolean
name|needClientAuth
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_CLIENT_HTTPS_NEED_AUTH_KEY
argument_list|,
name|DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT
argument_list|)
decl_stmt|;
name|InetSocketAddress
name|secInfoSocAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_DATANODE_HTTPS_ADDRESS_KEY
argument_list|,
name|infoHost
operator|+
literal|":"
operator|+
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Configuration
name|sslConf
init|=
operator|new
name|HdfsConfiguration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|sslConf
operator|.
name|addResource
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY
argument_list|,
literal|"ssl-server.xml"
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|addSslListener
argument_list|(
name|secInfoSocAddr
argument_list|,
name|sslConf
argument_list|,
name|needClientAuth
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Datanode listening for SSL on "
operator|+
name|secInfoSocAddr
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|infoServer
operator|.
name|addInternalServlet
argument_list|(
literal|null
argument_list|,
literal|"/streamFile/*"
argument_list|,
name|StreamFile
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|addInternalServlet
argument_list|(
literal|null
argument_list|,
literal|"/getFileChecksum/*"
argument_list|,
name|FileChecksumServlets
operator|.
name|GetServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"datanode"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|JspHelper
operator|.
name|CURRENT_CONF
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|null
argument_list|,
literal|"/blockScannerReport"
argument_list|,
name|DataBlockScanner
operator|.
name|Servlet
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|WebHdfsFileSystem
operator|.
name|isEnabled
argument_list|(
name|conf
argument_list|,
name|LOG
argument_list|)
condition|)
block|{
name|infoServer
operator|.
name|addJerseyResourcePackage
argument_list|(
name|DatanodeWebHdfsMethods
operator|.
name|class
operator|.
name|getPackage
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|";"
operator|+
name|Param
operator|.
name|class
operator|.
name|getPackage
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|WebHdfsFileSystem
operator|.
name|PATH_PREFIX
operator|+
literal|"/*"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|startPlugins (Configuration conf)
specifier|private
name|void
name|startPlugins
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|plugins
operator|=
name|conf
operator|.
name|getInstances
argument_list|(
name|DFS_DATANODE_PLUGINS_KEY
argument_list|,
name|ServicePlugin
operator|.
name|class
argument_list|)
expr_stmt|;
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|start
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Started plug-in "
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" could not be started"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|initIpcServer (Configuration conf)
specifier|private
name|void
name|initIpcServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|InetSocketAddress
name|ipcAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_DATANODE_IPC_ADDRESS_KEY
argument_list|)
argument_list|)
decl_stmt|;
comment|// Add all the RPC protocols that the Datanode implements
name|RPC
operator|.
name|setProtocolEngine
argument_list|(
name|conf
argument_list|,
name|ClientDatanodeProtocolPB
operator|.
name|class
argument_list|,
name|ProtobufRpcEngine
operator|.
name|class
argument_list|)
expr_stmt|;
name|ClientDatanodeProtocolServerSideTranslatorPB
name|clientDatanodeProtocolXlator
init|=
operator|new
name|ClientDatanodeProtocolServerSideTranslatorPB
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|BlockingService
name|service
init|=
name|ClientDatanodeProtocolService
operator|.
name|newReflectiveBlockingService
argument_list|(
name|clientDatanodeProtocolXlator
argument_list|)
decl_stmt|;
name|ipcServer
operator|=
operator|new
name|RPC
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|setProtocol
argument_list|(
name|ClientDatanodeProtocolPB
operator|.
name|class
argument_list|)
operator|.
name|setInstance
argument_list|(
name|service
argument_list|)
operator|.
name|setBindAddress
argument_list|(
name|ipcAddr
operator|.
name|getHostName
argument_list|()
argument_list|)
operator|.
name|setPort
argument_list|(
name|ipcAddr
operator|.
name|getPort
argument_list|()
argument_list|)
operator|.
name|setNumHandlers
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_DATANODE_HANDLER_COUNT_KEY
argument_list|,
name|DFS_DATANODE_HANDLER_COUNT_DEFAULT
argument_list|)
argument_list|)
operator|.
name|setVerbose
argument_list|(
literal|false
argument_list|)
operator|.
name|setSecretManager
argument_list|(
name|blockPoolTokenSecretManager
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|InterDatanodeProtocolServerSideTranslatorPB
name|interDatanodeProtocolXlator
init|=
operator|new
name|InterDatanodeProtocolServerSideTranslatorPB
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|service
operator|=
name|InterDatanodeProtocolService
operator|.
name|newReflectiveBlockingService
argument_list|(
name|interDatanodeProtocolXlator
argument_list|)
expr_stmt|;
name|DFSUtil
operator|.
name|addPBProtocol
argument_list|(
name|conf
argument_list|,
name|InterDatanodeProtocolPB
operator|.
name|class
argument_list|,
name|service
argument_list|,
name|ipcServer
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opened IPC server at "
operator|+
name|ipcServer
operator|.
name|getListenerAddress
argument_list|()
argument_list|)
expr_stmt|;
comment|// set service-level authorization security policy
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|ipcServer
operator|.
name|refreshServiceAcl
argument_list|(
name|conf
argument_list|,
operator|new
name|HDFSPolicyProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Initialize the datanode's periodic scanners:  *     {@link DataBlockScanner}  *     {@link DirectoryScanner}  * They report results on a per-blockpool basis but do their scanning   * on a per-Volume basis to minimize competition for disk iops.  *   * @param conf - Configuration has the run intervals and other   *               parameters for these periodic scanners  */
DECL|method|initPeriodicScanners (Configuration conf)
specifier|private
name|void
name|initPeriodicScanners
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|initDataBlockScanner
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initDirectoryScanner
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|shutdownPeriodicScanners ()
specifier|private
name|void
name|shutdownPeriodicScanners
parameter_list|()
block|{
name|shutdownDirectoryScanner
argument_list|()
expr_stmt|;
name|shutdownDataBlockScanner
argument_list|()
expr_stmt|;
block|}
comment|/**    * See {@link DataBlockScanner}    */
DECL|method|initDataBlockScanner (Configuration conf)
specifier|private
specifier|synchronized
name|void
name|initDataBlockScanner
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|reason
init|=
literal|null
decl_stmt|;
assert|assert
name|data
operator|!=
literal|null
assert|;
if|if
condition|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_DATANODE_SCAN_PERIOD_HOURS_KEY
argument_list|,
name|DFS_DATANODE_SCAN_PERIOD_HOURS_DEFAULT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|reason
operator|=
literal|"verification is turned off by configuration"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"SimulatedFSDataset"
operator|.
name|equals
argument_list|(
name|data
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
condition|)
block|{
name|reason
operator|=
literal|"verifcation is not supported by SimulatedFSDataset"
expr_stmt|;
block|}
if|if
condition|(
name|reason
operator|==
literal|null
condition|)
block|{
name|blockScanner
operator|=
operator|new
name|DataBlockScanner
argument_list|(
name|this
argument_list|,
name|data
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|blockScanner
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Periodic Block Verification scan disabled because "
operator|+
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shutdownDataBlockScanner ()
specifier|private
name|void
name|shutdownDataBlockScanner
parameter_list|()
block|{
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * See {@link DirectoryScanner}    */
DECL|method|initDirectoryScanner (Configuration conf)
specifier|private
specifier|synchronized
name|void
name|initDirectoryScanner
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|directoryScanner
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|reason
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY
argument_list|,
name|DFS_DATANODE_DIRECTORYSCAN_INTERVAL_DEFAULT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|reason
operator|=
literal|"verification is turned off by configuration"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"SimulatedFSDataset"
operator|.
name|equals
argument_list|(
name|data
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
condition|)
block|{
name|reason
operator|=
literal|"verifcation is not supported by SimulatedFSDataset"
expr_stmt|;
block|}
if|if
condition|(
name|reason
operator|==
literal|null
condition|)
block|{
name|directoryScanner
operator|=
operator|new
name|DirectoryScanner
argument_list|(
name|data
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|directoryScanner
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Periodic Directory Tree Verification scan is disabled because "
operator|+
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shutdownDirectoryScanner ()
specifier|private
specifier|synchronized
name|void
name|shutdownDirectoryScanner
parameter_list|()
block|{
if|if
condition|(
name|directoryScanner
operator|!=
literal|null
condition|)
block|{
name|directoryScanner
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|initDataXceiver (Configuration conf)
specifier|private
name|void
name|initDataXceiver
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// find free port or use privileged port provided
name|TcpPeerServer
name|tcpPeerServer
decl_stmt|;
if|if
condition|(
name|secureResources
operator|!=
literal|null
condition|)
block|{
name|tcpPeerServer
operator|=
operator|new
name|TcpPeerServer
argument_list|(
name|secureResources
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcpPeerServer
operator|=
operator|new
name|TcpPeerServer
argument_list|(
name|dnConf
operator|.
name|socketWriteTimeout
argument_list|,
name|DataNode
operator|.
name|getStreamingAddr
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tcpPeerServer
operator|.
name|setReceiveBufferSize
argument_list|(
name|HdfsConstants
operator|.
name|DEFAULT_DATA_SOCKET_SIZE
argument_list|)
expr_stmt|;
name|streamingAddr
operator|=
name|tcpPeerServer
operator|.
name|getStreamingAddr
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opened streaming server at "
operator|+
name|streamingAddr
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadGroup
operator|=
operator|new
name|ThreadGroup
argument_list|(
literal|"dataXceiverServer"
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataXceiverServer
operator|=
operator|new
name|Daemon
argument_list|(
name|threadGroup
argument_list|,
operator|new
name|DataXceiverServer
argument_list|(
name|tcpPeerServer
argument_list|,
name|conf
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadGroup
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// auto destroy when empty
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_READ_SHORTCIRCUIT_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_READ_SHORTCIRCUIT_DEFAULT
argument_list|)
operator|||
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_DOMAIN_SOCKET_DATA_TRAFFIC
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_DOMAIN_SOCKET_DATA_TRAFFIC_DEFAULT
argument_list|)
condition|)
block|{
name|DomainPeerServer
name|domainPeerServer
init|=
name|getDomainPeerServer
argument_list|(
name|conf
argument_list|,
name|streamingAddr
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|domainPeerServer
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|localDataXceiverServer
operator|=
operator|new
name|Daemon
argument_list|(
name|threadGroup
argument_list|,
operator|new
name|DataXceiverServer
argument_list|(
name|domainPeerServer
argument_list|,
name|conf
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Listening on UNIX domain socket: "
operator|+
name|domainPeerServer
operator|.
name|getBindPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getDomainPeerServer (Configuration conf, int port)
specifier|static
name|DomainPeerServer
name|getDomainPeerServer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|int
name|port
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|domainSocketPath
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DOMAIN_SOCKET_PATH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DOMAIN_SOCKET_PATH_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|domainSocketPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_READ_SHORTCIRCUIT_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_READ_SHORTCIRCUIT_DEFAULT
argument_list|)
operator|&&
operator|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_USE_LEGACY_BLOCKREADERLOCAL
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_USE_LEGACY_BLOCKREADERLOCAL_DEFAULT
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Although short-circuit local reads are configured, "
operator|+
literal|"they are disabled because you didn't configure "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_DOMAIN_SOCKET_PATH_KEY
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
if|if
condition|(
name|DomainSocket
operator|.
name|getLoadingFailureReason
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Although a UNIX domain socket "
operator|+
literal|"path is configured as "
operator|+
name|domainSocketPath
operator|+
literal|", we cannot "
operator|+
literal|"start a localDataXceiverServer because "
operator|+
name|DomainSocket
operator|.
name|getLoadingFailureReason
argument_list|()
argument_list|)
throw|;
block|}
name|DomainPeerServer
name|domainPeerServer
init|=
operator|new
name|DomainPeerServer
argument_list|(
name|domainSocketPath
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|domainPeerServer
operator|.
name|setReceiveBufferSize
argument_list|(
name|HdfsConstants
operator|.
name|DEFAULT_DATA_SOCKET_SIZE
argument_list|)
expr_stmt|;
return|return
name|domainPeerServer
return|;
block|}
comment|// calls specific to BP
DECL|method|notifyNamenodeReceivedBlock (ExtendedBlock block, String delHint)
specifier|protected
name|void
name|notifyNamenodeReceivedBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|delHint
parameter_list|)
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|!=
literal|null
condition|)
block|{
name|bpos
operator|.
name|notifyNamenodeReceivedBlock
argument_list|(
name|block
argument_list|,
name|delHint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot find BPOfferService for reporting block received for bpid="
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// calls specific to BP
DECL|method|notifyNamenodeReceivingBlock (ExtendedBlock block)
specifier|protected
name|void
name|notifyNamenodeReceivingBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|!=
literal|null
condition|)
block|{
name|bpos
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot find BPOfferService for reporting block receiving for bpid="
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Notify the corresponding namenode to delete the block. */
DECL|method|notifyNamenodeDeletedBlock (ExtendedBlock block)
specifier|public
name|void
name|notifyNamenodeDeletedBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|!=
literal|null
condition|)
block|{
name|bpos
operator|.
name|notifyNamenodeDeletedBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot find BPOfferService for reporting block deleted for bpid="
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Report a bad block which is hosted on the local DN.    */
DECL|method|reportBadBlocks (ExtendedBlock block)
specifier|public
name|void
name|reportBadBlocks
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|getBPOSForBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|bpos
operator|.
name|reportBadBlocks
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/**    * Report a bad block on another DN (eg if we received a corrupt replica    * from a remote host).    * @param srcDataNode the DN hosting the bad block    * @param block the block itself    */
DECL|method|reportRemoteBadBlock (DatanodeInfo srcDataNode, ExtendedBlock block)
specifier|public
name|void
name|reportRemoteBadBlock
parameter_list|(
name|DatanodeInfo
name|srcDataNode
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|getBPOSForBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|bpos
operator|.
name|reportRemoteBadBlock
argument_list|(
name|srcDataNode
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/**    * Try to send an error report to the NNs associated with the given    * block pool.    * @param bpid the block pool ID    * @param errCode error code to send    * @param errMsg textual message to send    */
DECL|method|trySendErrorReport (String bpid, int errCode, String errMsg)
name|void
name|trySendErrorReport
parameter_list|(
name|String
name|bpid
parameter_list|,
name|int
name|errCode
parameter_list|,
name|String
name|errMsg
parameter_list|)
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad block pool: "
operator|+
name|bpid
argument_list|)
throw|;
block|}
name|bpos
operator|.
name|trySendErrorReport
argument_list|(
name|errCode
argument_list|,
name|errMsg
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the BPOfferService instance corresponding to the given block.    * @param block    * @return the BPOS    * @throws IOException if no such BPOS can be found    */
DECL|method|getBPOSForBlock (ExtendedBlock block)
specifier|private
name|BPOfferService
name|getBPOSForBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot locate OfferService thread for bp="
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|bpos
return|;
block|}
comment|// used only for testing
DECL|method|setHeartbeatsDisabledForTests ( boolean heartbeatsDisabledForTests)
name|void
name|setHeartbeatsDisabledForTests
parameter_list|(
name|boolean
name|heartbeatsDisabledForTests
parameter_list|)
block|{
name|this
operator|.
name|heartbeatsDisabledForTests
operator|=
name|heartbeatsDisabledForTests
expr_stmt|;
block|}
DECL|method|areHeartbeatsDisabledForTests ()
name|boolean
name|areHeartbeatsDisabledForTests
parameter_list|()
block|{
return|return
name|this
operator|.
name|heartbeatsDisabledForTests
return|;
block|}
comment|/**    * This method starts the data node with the specified conf.    *     * @param conf - the configuration    *  if conf's CONFIG_PROPERTY_SIMULATED property is set    *  then a simulated storage based data node is created.    *     * @param dataDirs - only for a non-simulated storage data node    * @throws IOException    */
DECL|method|startDataNode (Configuration conf, AbstractList<File> dataDirs, SecureResources resources )
name|void
name|startDataNode
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
parameter_list|,
comment|// DatanodeProtocol namenode,
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|&&
name|resources
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"ignore.secure.ports.for.testing"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot start secure cluster without "
operator|+
literal|"privileged resources."
argument_list|)
throw|;
block|}
block|}
comment|// settings global for all BPs in the Data Node
name|this
operator|.
name|secureResources
operator|=
name|resources
expr_stmt|;
name|this
operator|.
name|dataDirs
operator|=
name|dataDirs
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|dnConf
operator|=
operator|new
name|DNConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnConf
operator|.
name|maxLockedMemory
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|NativeIO
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Cannot start datanode because the configured max locked memory"
operator|+
literal|" size (%s) is greater than zero and native code is not available."
argument_list|,
name|DFS_DATANODE_MAX_LOCKED_MEMORY_KEY
argument_list|)
argument_list|)
throw|;
block|}
name|long
name|ulimit
init|=
name|NativeIO
operator|.
name|POSIX
operator|.
name|getMemlockLimit
argument_list|()
decl_stmt|;
if|if
condition|(
name|dnConf
operator|.
name|maxLockedMemory
operator|>
name|ulimit
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Cannot start datanode because the configured max locked memory"
operator|+
literal|" size (%s) of %d bytes is less than the datanode's available"
operator|+
literal|" RLIMIT_MEMLOCK ulimit of %d bytes."
argument_list|,
name|DFS_DATANODE_MAX_LOCKED_MEMORY_KEY
argument_list|,
name|dnConf
operator|.
name|maxLockedMemory
argument_list|,
name|ulimit
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|storage
operator|=
operator|new
name|DataStorage
argument_list|()
expr_stmt|;
comment|// global DN settings
name|registerMXBean
argument_list|()
expr_stmt|;
name|initDataXceiver
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|startInfoServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pauseMonitor
operator|=
operator|new
name|JvmPauseMonitor
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pauseMonitor
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// BlockPoolTokenSecretManager is required to create ipc server.
name|this
operator|.
name|blockPoolTokenSecretManager
operator|=
operator|new
name|BlockPoolTokenSecretManager
argument_list|()
expr_stmt|;
name|initIpcServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|metrics
operator|=
name|DataNodeMetrics
operator|.
name|create
argument_list|(
name|conf
argument_list|,
name|getDisplayName
argument_list|()
argument_list|)
expr_stmt|;
name|blockPoolManager
operator|=
operator|new
name|BlockPoolManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|blockPoolManager
operator|.
name|refreshNamenodes
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Create the ReadaheadPool from the DataNode context so we can
comment|// exit without having to explicitly shutdown its thread pool.
name|readaheadPool
operator|=
name|ReadaheadPool
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
comment|/**    * Create a DatanodeRegistration for a specific block pool.    * @param nsInfo the namespace info from the first part of the NN handshake    */
DECL|method|createBPRegistration (NamespaceInfo nsInfo)
name|DatanodeRegistration
name|createBPRegistration
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|)
block|{
name|StorageInfo
name|storageInfo
init|=
name|storage
operator|.
name|getBPStorage
argument_list|(
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageInfo
operator|==
literal|null
condition|)
block|{
comment|// it's null in the case of SimulatedDataSet
name|storageInfo
operator|=
operator|new
name|StorageInfo
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
block|}
name|DatanodeID
name|dnId
init|=
operator|new
name|DatanodeID
argument_list|(
name|streamingAddr
operator|.
name|getAddress
argument_list|()
operator|.
name|getHostAddress
argument_list|()
argument_list|,
name|hostName
argument_list|,
name|getStorageId
argument_list|()
argument_list|,
name|getXferPort
argument_list|()
argument_list|,
name|getInfoPort
argument_list|()
argument_list|,
name|getIpcPort
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|DatanodeRegistration
argument_list|(
name|dnId
argument_list|,
name|storageInfo
argument_list|,
operator|new
name|ExportedBlockKeys
argument_list|()
argument_list|,
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Check that the registration returned from a NameNode is consistent    * with the information in the storage. If the storage is fresh/unformatted,    * sets the storage ID based on this registration.    * Also updates the block pool's state in the secret manager.    */
DECL|method|bpRegistrationSucceeded (DatanodeRegistration bpRegistration, String blockPoolId)
specifier|synchronized
name|void
name|bpRegistrationSucceeded
parameter_list|(
name|DatanodeRegistration
name|bpRegistration
parameter_list|,
name|String
name|blockPoolId
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Set the ID if we haven't already
if|if
condition|(
literal|null
operator|==
name|id
condition|)
block|{
name|id
operator|=
name|bpRegistration
expr_stmt|;
block|}
if|if
condition|(
name|storage
operator|.
name|getStorageID
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|// This is a fresh datanode, persist the NN-provided storage ID
name|storage
operator|.
name|setStorageID
argument_list|(
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
name|storage
operator|.
name|writeAll
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"New storage id "
operator|+
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
operator|+
literal|" is assigned to data-node "
operator|+
name|bpRegistration
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|storage
operator|.
name|getStorageID
argument_list|()
operator|.
name|equals
argument_list|(
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent storage IDs. Name-node returned "
operator|+
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
operator|+
literal|". Expecting "
operator|+
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|)
throw|;
block|}
name|registerBlockPoolWithSecretManager
argument_list|(
name|bpRegistration
argument_list|,
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
comment|/**    * After the block pool has contacted the NN, registers that block pool    * with the secret manager, updating it with the secrets provided by the NN.    * @param bpRegistration    * @param blockPoolId    * @throws IOException    */
DECL|method|registerBlockPoolWithSecretManager ( DatanodeRegistration bpRegistration, String blockPoolId)
specifier|private
specifier|synchronized
name|void
name|registerBlockPoolWithSecretManager
parameter_list|(
name|DatanodeRegistration
name|bpRegistration
parameter_list|,
name|String
name|blockPoolId
parameter_list|)
throws|throws
name|IOException
block|{
name|ExportedBlockKeys
name|keys
init|=
name|bpRegistration
operator|.
name|getExportedKeys
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasAnyBlockPoolRegistered
condition|)
block|{
name|hasAnyBlockPoolRegistered
operator|=
literal|true
expr_stmt|;
name|isBlockTokenEnabled
operator|=
name|keys
operator|.
name|isBlockTokenEnabled
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isBlockTokenEnabled
operator|!=
name|keys
operator|.
name|isBlockTokenEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Inconsistent configuration of block access"
operator|+
literal|" tokens. Either all block pools must be configured to use block"
operator|+
literal|" tokens, or none may be."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|isBlockTokenEnabled
condition|)
return|return;
if|if
condition|(
operator|!
name|blockPoolTokenSecretManager
operator|.
name|isBlockPoolRegistered
argument_list|(
name|blockPoolId
argument_list|)
condition|)
block|{
name|long
name|blockKeyUpdateInterval
init|=
name|keys
operator|.
name|getKeyUpdateInterval
argument_list|()
decl_stmt|;
name|long
name|blockTokenLifetime
init|=
name|keys
operator|.
name|getTokenLifetime
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Block token params received from NN: for block pool "
operator|+
name|blockPoolId
operator|+
literal|" keyUpdateInterval="
operator|+
name|blockKeyUpdateInterval
operator|/
operator|(
literal|60
operator|*
literal|1000
operator|)
operator|+
literal|" min(s), tokenLifetime="
operator|+
name|blockTokenLifetime
operator|/
operator|(
literal|60
operator|*
literal|1000
operator|)
operator|+
literal|" min(s)"
argument_list|)
expr_stmt|;
specifier|final
name|BlockTokenSecretManager
name|secretMgr
init|=
operator|new
name|BlockTokenSecretManager
argument_list|(
literal|0
argument_list|,
name|blockTokenLifetime
argument_list|,
name|blockPoolId
argument_list|,
name|dnConf
operator|.
name|encryptionAlgorithm
argument_list|)
decl_stmt|;
name|blockPoolTokenSecretManager
operator|.
name|addBlockPool
argument_list|(
name|blockPoolId
argument_list|,
name|secretMgr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove the given block pool from the block scanner, dataset, and storage.    */
DECL|method|shutdownBlockPool (BPOfferService bpos)
name|void
name|shutdownBlockPool
parameter_list|(
name|BPOfferService
name|bpos
parameter_list|)
block|{
name|blockPoolManager
operator|.
name|remove
argument_list|(
name|bpos
argument_list|)
expr_stmt|;
name|String
name|bpId
init|=
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|removeBlockPool
argument_list|(
name|bpId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|data
operator|.
name|shutdownBlockPool
argument_list|(
name|bpId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|storage
operator|!=
literal|null
condition|)
block|{
name|storage
operator|.
name|removeBlockPoolStorage
argument_list|(
name|bpId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * One of the Block Pools has successfully connected to its NN.    * This initializes the local storage for that block pool,    * checks consistency of the NN's cluster ID, etc.    *     * If this is the first block pool to register, this also initializes    * the datanode-scoped storage.    *     * @param nsInfo the handshake response from the NN.    * @throws IOException if the NN is inconsistent with the local storage.    */
DECL|method|initBlockPool (BPOfferService bpos)
name|void
name|initBlockPool
parameter_list|(
name|BPOfferService
name|bpos
parameter_list|)
throws|throws
name|IOException
block|{
name|NamespaceInfo
name|nsInfo
init|=
name|bpos
operator|.
name|getNamespaceInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|nsInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NamespaceInfo not found: Block pool "
operator|+
name|bpos
operator|+
literal|" should have retrieved namespace info before initBlockPool."
argument_list|)
throw|;
block|}
comment|// Register the new block pool with the BP manager.
name|blockPoolManager
operator|.
name|addBlockPool
argument_list|(
name|bpos
argument_list|)
expr_stmt|;
name|setClusterId
argument_list|(
name|nsInfo
operator|.
name|clusterID
argument_list|,
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
comment|// In the case that this is the first block pool to connect, initialize
comment|// the dataset, block scanners, etc.
name|initStorage
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
name|initPeriodicScanners
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|data
operator|.
name|addBlockPool
argument_list|(
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|getAllBpOs ()
name|BPOfferService
index|[]
name|getAllBpOs
parameter_list|()
block|{
return|return
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
return|;
block|}
DECL|method|getBpOsCount ()
name|int
name|getBpOsCount
parameter_list|()
block|{
return|return
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
operator|.
name|length
return|;
block|}
comment|/**    * Initializes the {@link #data}. The initialization is done only once, when    * handshake with the the first namenode is completed.    */
DECL|method|initStorage (final NamespaceInfo nsInfo)
specifier|private
name|void
name|initStorage
parameter_list|(
specifier|final
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FsDatasetSpi
operator|.
name|Factory
argument_list|<
name|?
extends|extends
name|FsDatasetSpi
argument_list|<
name|?
argument_list|>
argument_list|>
name|factory
init|=
name|FsDatasetSpi
operator|.
name|Factory
operator|.
name|getFactory
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|factory
operator|.
name|isSimulated
argument_list|()
condition|)
block|{
specifier|final
name|StartupOption
name|startOpt
init|=
name|getStartupOption
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Startup option not set."
argument_list|)
throw|;
block|}
specifier|final
name|String
name|bpid
init|=
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
decl_stmt|;
comment|//read storage info, lock data dirs and transition fs state if necessary
name|storage
operator|.
name|recoverTransitionRead
argument_list|(
name|this
argument_list|,
name|bpid
argument_list|,
name|nsInfo
argument_list|,
name|dataDirs
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
specifier|final
name|StorageInfo
name|bpStorage
init|=
name|storage
operator|.
name|getBPStorage
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up storage: nsid="
operator|+
name|bpStorage
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|";bpid="
operator|+
name|bpid
operator|+
literal|";lv="
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|";nsInfo="
operator|+
name|nsInfo
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|data
operator|=
name|factory
operator|.
name|newInstance
argument_list|(
name|this
argument_list|,
name|storage
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Determine the http server's effective addr    */
DECL|method|getInfoAddr (Configuration conf)
specifier|public
specifier|static
name|InetSocketAddress
name|getInfoAddr
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_DATANODE_HTTP_ADDRESS_KEY
argument_list|,
name|DFS_DATANODE_HTTP_ADDRESS_DEFAULT
argument_list|)
argument_list|)
return|;
block|}
DECL|method|registerMXBean ()
specifier|private
name|void
name|registerMXBean
parameter_list|()
block|{
name|MBeans
operator|.
name|register
argument_list|(
literal|"DataNode"
argument_list|,
literal|"DataNodeInfo"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getXferPort ()
specifier|public
name|int
name|getXferPort
parameter_list|()
block|{
return|return
name|streamingAddr
operator|.
name|getPort
argument_list|()
return|;
block|}
DECL|method|getStorageId ()
name|String
name|getStorageId
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getStorageID
argument_list|()
return|;
block|}
comment|/**    * @return name useful for logging    */
DECL|method|getDisplayName ()
specifier|public
name|String
name|getDisplayName
parameter_list|()
block|{
comment|// NB: our DatanodeID may not be set yet
return|return
name|hostName
operator|+
literal|":"
operator|+
name|getXferPort
argument_list|()
return|;
block|}
comment|/**    * NB: The datanode can perform data transfer on the streaming    * address however clients are given the IPC IP address for data    * transfer, and that may be a different address.    *     * @return socket address for data transfer    */
DECL|method|getXferAddress ()
specifier|public
name|InetSocketAddress
name|getXferAddress
parameter_list|()
block|{
return|return
name|streamingAddr
return|;
block|}
comment|/**    * @return the datanode's IPC port    */
DECL|method|getIpcPort ()
specifier|public
name|int
name|getIpcPort
parameter_list|()
block|{
return|return
name|ipcServer
operator|.
name|getListenerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
return|;
block|}
comment|/**    * get BP registration by blockPool id    * @param bpid    * @return BP registration object    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|getDNRegistrationForBP (String bpid)
specifier|public
name|DatanodeRegistration
name|getDNRegistrationForBP
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
operator|||
name|bpos
operator|.
name|bpRegistration
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot find BPOfferService for bpid="
operator|+
name|bpid
argument_list|)
throw|;
block|}
return|return
name|bpos
operator|.
name|bpRegistration
return|;
block|}
comment|/**    * Creates either NIO or regular depending on socketWriteTimeout.    */
DECL|method|newSocket ()
specifier|protected
name|Socket
name|newSocket
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|dnConf
operator|.
name|socketWriteTimeout
operator|>
literal|0
operator|)
condition|?
name|SocketChannel
operator|.
name|open
argument_list|()
operator|.
name|socket
argument_list|()
else|:
operator|new
name|Socket
argument_list|()
return|;
block|}
comment|/**    * Connect to the NN. This is separated out for easier testing.    */
DECL|method|connectToNN ( InetSocketAddress nnAddr)
name|DatanodeProtocolClientSideTranslatorPB
name|connectToNN
parameter_list|(
name|InetSocketAddress
name|nnAddr
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|DatanodeProtocolClientSideTranslatorPB
argument_list|(
name|nnAddr
argument_list|,
name|conf
argument_list|)
return|;
block|}
DECL|method|createInterDataNodeProtocolProxy ( DatanodeID datanodeid, final Configuration conf, final int socketTimeout, final boolean connectToDnViaHostname)
specifier|public
specifier|static
name|InterDatanodeProtocol
name|createInterDataNodeProtocolProxy
parameter_list|(
name|DatanodeID
name|datanodeid
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|int
name|socketTimeout
parameter_list|,
specifier|final
name|boolean
name|connectToDnViaHostname
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|dnAddr
init|=
name|datanodeid
operator|.
name|getIpcAddr
argument_list|(
name|connectToDnViaHostname
argument_list|)
decl_stmt|;
specifier|final
name|InetSocketAddress
name|addr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|dnAddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to datanode "
operator|+
name|dnAddr
operator|+
literal|" addr="
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
specifier|final
name|UserGroupInformation
name|loginUgi
init|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|loginUgi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|InterDatanodeProtocol
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|InterDatanodeProtocol
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|InterDatanodeProtocolTranslatorPB
argument_list|(
name|addr
argument_list|,
name|loginUgi
argument_list|,
name|conf
argument_list|,
name|NetUtils
operator|.
name|getDefaultSocketFactory
argument_list|(
name|conf
argument_list|)
argument_list|,
name|socketTimeout
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|getMetrics ()
name|DataNodeMetrics
name|getMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
DECL|method|setNewStorageID (DatanodeID dnId)
specifier|public
specifier|static
name|void
name|setNewStorageID
parameter_list|(
name|DatanodeID
name|dnId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Datanode is "
operator|+
name|dnId
argument_list|)
expr_stmt|;
name|dnId
operator|.
name|setStorageID
argument_list|(
name|createNewStorageId
argument_list|(
name|dnId
operator|.
name|getXferPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return a unique storage ID of form "DS-randInt-ipaddr-port-timestamp"    */
DECL|method|createNewStorageId (int port)
specifier|static
name|String
name|createNewStorageId
parameter_list|(
name|int
name|port
parameter_list|)
block|{
comment|// It is unlikely that we will create a non-unique storage ID
comment|// for the following reasons:
comment|// a) SecureRandom is a cryptographically strong random number generator
comment|// b) IP addresses will likely differ on different hosts
comment|// c) DataNode xfer ports will differ on the same host
comment|// d) StorageIDs will likely be generated at different times (in ms)
comment|// A conflict requires that all four conditions are violated.
comment|// NB: The format of this string can be changed in the future without
comment|// requiring that old SotrageIDs be updated.
name|String
name|ip
init|=
literal|"unknownIP"
decl_stmt|;
try|try
block|{
name|ip
operator|=
name|DNS
operator|.
name|getDefaultIP
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|ignored
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find an IP address for the \"default\" inteface."
argument_list|)
expr_stmt|;
block|}
name|int
name|rand
init|=
name|DFSUtil
operator|.
name|getSecureRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
return|return
literal|"DS-"
operator|+
name|rand
operator|+
literal|"-"
operator|+
name|ip
operator|+
literal|"-"
operator|+
name|port
operator|+
literal|"-"
operator|+
name|Time
operator|.
name|now
argument_list|()
return|;
block|}
comment|/** Ensure the authentication method is kerberos */
DECL|method|checkKerberosAuthMethod (String msg)
specifier|private
name|void
name|checkKerberosAuthMethod
parameter_list|(
name|String
name|msg
parameter_list|)
throws|throws
name|IOException
block|{
comment|// User invoking the call must be same as the datanode user
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getAuthenticationMethod
argument_list|()
operator|!=
name|AuthenticationMethod
operator|.
name|KERBEROS
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Error in "
operator|+
name|msg
operator|+
literal|"Only kerberos based authentication is allowed."
argument_list|)
throw|;
block|}
block|}
DECL|method|checkBlockLocalPathAccess ()
specifier|private
name|void
name|checkBlockLocalPathAccess
parameter_list|()
throws|throws
name|IOException
block|{
name|checkKerberosAuthMethod
argument_list|(
literal|"getBlockLocalPathInfo()"
argument_list|)
expr_stmt|;
name|String
name|currentUser
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|usersWithLocalPathAccess
operator|.
name|contains
argument_list|(
name|currentUser
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Can't continue with getBlockLocalPathInfo() "
operator|+
literal|"authorization. The user "
operator|+
name|currentUser
operator|+
literal|" is not allowed to call getBlockLocalPathInfo"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getBlockLocalPathInfo (ExtendedBlock block, Token<BlockTokenIdentifier> token)
specifier|public
name|BlockLocalPathInfo
name|getBlockLocalPathInfo
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|checkBlockLocalPathAccess
argument_list|()
expr_stmt|;
name|checkBlockToken
argument_list|(
name|block
argument_list|,
name|token
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|READ
argument_list|)
expr_stmt|;
name|BlockLocalPathInfo
name|info
init|=
name|data
operator|.
name|getBlockLocalPathInfo
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"getBlockLocalPathInfo successful block="
operator|+
name|block
operator|+
literal|" blockfile "
operator|+
name|info
operator|.
name|getBlockPath
argument_list|()
operator|+
literal|" metafile "
operator|+
name|info
operator|.
name|getMetaPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"getBlockLocalPathInfo for block="
operator|+
name|block
operator|+
literal|" returning null"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|metrics
operator|.
name|incrBlocksGetLocalPathInfo
argument_list|()
expr_stmt|;
return|return
name|info
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
literal|"HDFS"
argument_list|)
DECL|class|ShortCircuitFdsUnsupportedException
specifier|static
specifier|public
class|class
name|ShortCircuitFdsUnsupportedException
extends|extends
name|IOException
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|method|ShortCircuitFdsUnsupportedException (String msg)
specifier|public
name|ShortCircuitFdsUnsupportedException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
literal|"HDFS"
argument_list|)
DECL|class|ShortCircuitFdsVersionException
specifier|static
specifier|public
class|class
name|ShortCircuitFdsVersionException
extends|extends
name|IOException
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|method|ShortCircuitFdsVersionException (String msg)
specifier|public
name|ShortCircuitFdsVersionException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|requestShortCircuitFdsForRead (final ExtendedBlock blk, final Token<BlockTokenIdentifier> token, int maxVersion)
name|FileInputStream
index|[]
name|requestShortCircuitFdsForRead
parameter_list|(
specifier|final
name|ExtendedBlock
name|blk
parameter_list|,
specifier|final
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|token
parameter_list|,
name|int
name|maxVersion
parameter_list|)
throws|throws
name|ShortCircuitFdsUnsupportedException
throws|,
name|ShortCircuitFdsVersionException
throws|,
name|IOException
block|{
if|if
condition|(
name|fileDescriptorPassingDisabledReason
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ShortCircuitFdsUnsupportedException
argument_list|(
name|fileDescriptorPassingDisabledReason
argument_list|)
throw|;
block|}
name|checkBlockToken
argument_list|(
name|blk
argument_list|,
name|token
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|READ
argument_list|)
expr_stmt|;
name|int
name|blkVersion
init|=
name|CURRENT_BLOCK_FORMAT_VERSION
decl_stmt|;
if|if
condition|(
name|maxVersion
operator|<
name|blkVersion
condition|)
block|{
throw|throw
operator|new
name|ShortCircuitFdsVersionException
argument_list|(
literal|"Your client is too old "
operator|+
literal|"to read this block!  Its format version is "
operator|+
name|blkVersion
operator|+
literal|", but the highest format version you can read is "
operator|+
name|maxVersion
argument_list|)
throw|;
block|}
name|metrics
operator|.
name|incrBlocksGetLocalPathInfo
argument_list|()
expr_stmt|;
name|FileInputStream
name|fis
index|[]
init|=
operator|new
name|FileInputStream
index|[
literal|2
index|]
decl_stmt|;
try|try
block|{
name|fis
index|[
literal|0
index|]
operator|=
operator|(
name|FileInputStream
operator|)
name|data
operator|.
name|getBlockInputStream
argument_list|(
name|blk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fis
index|[
literal|1
index|]
operator|=
operator|(
name|FileInputStream
operator|)
name|data
operator|.
name|getMetaDataInputStream
argument_list|(
name|blk
argument_list|)
operator|.
name|getWrappedStream
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"requestShortCircuitFdsForRead failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ShortCircuitFdsUnsupportedException
argument_list|(
literal|"This DataNode's "
operator|+
literal|"FsDatasetSpi does not support short-circuit local reads"
argument_list|)
throw|;
block|}
return|return
name|fis
return|;
block|}
annotation|@
name|Override
DECL|method|getHdfsBlocksMetadata (List<ExtendedBlock> blocks, List<Token<BlockTokenIdentifier>> tokens)
specifier|public
name|HdfsBlocksMetadata
name|getHdfsBlocksMetadata
parameter_list|(
name|List
argument_list|<
name|ExtendedBlock
argument_list|>
name|blocks
parameter_list|,
name|List
argument_list|<
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|>
name|tokens
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnsupportedOperationException
block|{
if|if
condition|(
operator|!
name|getHdfsBlockLocationsEnabled
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Datanode#getHdfsBlocksMetadata "
operator|+
literal|" is not enabled in datanode config"
argument_list|)
throw|;
block|}
if|if
condition|(
name|blocks
operator|.
name|size
argument_list|()
operator|!=
name|tokens
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Differing number of blocks and tokens"
argument_list|)
throw|;
block|}
comment|// Check access for each block
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|checkBlockToken
argument_list|(
name|blocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|tokens
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|READ
argument_list|)
expr_stmt|;
block|}
return|return
name|data
operator|.
name|getHdfsBlocksMetadata
argument_list|(
name|blocks
argument_list|)
return|;
block|}
DECL|method|checkBlockToken (ExtendedBlock block, Token<BlockTokenIdentifier> token, AccessMode accessMode)
specifier|private
name|void
name|checkBlockToken
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|token
parameter_list|,
name|AccessMode
name|accessMode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isBlockTokenEnabled
operator|&&
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|BlockTokenIdentifier
name|id
init|=
operator|new
name|BlockTokenIdentifier
argument_list|()
decl_stmt|;
name|ByteArrayInputStream
name|buf
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|token
operator|.
name|getIdentifier
argument_list|()
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|id
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got: "
operator|+
name|id
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|blockPoolTokenSecretManager
operator|.
name|checkAccess
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|block
argument_list|,
name|accessMode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Shut down this instance of the datanode.    * Returns only after shutdown is complete.    * This method can only be called by the offerService thread.    * Otherwise, deadlock might occur.    */
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|plugins
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|stop
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopped plug-in "
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" could not be stopped"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// We need to make a copy of the original blockPoolManager#offerServices to
comment|// make sure blockPoolManager#shutDownAll() can still access all the
comment|// BPOfferServices, since after setting DataNode#shouldRun to false the
comment|// offerServices may be modified.
name|BPOfferService
index|[]
name|bposArray
init|=
name|this
operator|.
name|blockPoolManager
operator|==
literal|null
condition|?
literal|null
else|:
name|this
operator|.
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
decl_stmt|;
name|this
operator|.
name|shouldRun
operator|=
literal|false
expr_stmt|;
name|shutdownPeriodicScanners
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoServer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception shutting down DataNode"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ipcServer
operator|!=
literal|null
condition|)
block|{
name|ipcServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pauseMonitor
operator|!=
literal|null
condition|)
block|{
name|pauseMonitor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dataXceiverServer
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|DataXceiverServer
operator|)
name|this
operator|.
name|dataXceiverServer
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|kill
argument_list|()
expr_stmt|;
name|this
operator|.
name|dataXceiverServer
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|localDataXceiverServer
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|DataXceiverServer
operator|)
name|this
operator|.
name|localDataXceiverServer
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|kill
argument_list|()
expr_stmt|;
name|this
operator|.
name|localDataXceiverServer
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|// wait for all data receiver threads to exit
if|if
condition|(
name|this
operator|.
name|threadGroup
operator|!=
literal|null
condition|)
block|{
name|int
name|sleepMs
init|=
literal|2
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|this
operator|.
name|threadGroup
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for threadgroup to exit, active threads is "
operator|+
name|this
operator|.
name|threadGroup
operator|.
name|activeCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|threadGroup
operator|.
name|activeCount
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
name|sleepMs
operator|=
name|sleepMs
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
comment|// exponential backoff
if|if
condition|(
name|sleepMs
operator|>
literal|1000
condition|)
block|{
name|sleepMs
operator|=
literal|1000
expr_stmt|;
block|}
block|}
name|this
operator|.
name|threadGroup
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|dataXceiverServer
operator|!=
literal|null
condition|)
block|{
comment|// wait for dataXceiverServer to terminate
try|try
block|{
name|this
operator|.
name|dataXceiverServer
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{       }
block|}
if|if
condition|(
name|this
operator|.
name|localDataXceiverServer
operator|!=
literal|null
condition|)
block|{
comment|// wait for localDataXceiverServer to terminate
try|try
block|{
name|this
operator|.
name|localDataXceiverServer
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{       }
block|}
if|if
condition|(
name|blockPoolManager
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|blockPoolManager
operator|.
name|shutDownAll
argument_list|(
name|bposArray
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received exception in BlockPoolManager#shutDownAll: "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|storage
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|storage
operator|.
name|unlockAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when unlocking storage: "
operator|+
name|ie
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|data
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Check if there is no space in disk     *  @param e that caused this checkDiskError call    **/
DECL|method|checkDiskError (Exception e )
specifier|protected
name|void
name|checkDiskError
parameter_list|(
name|Exception
name|e
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"checkDiskError: exception: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SocketException
operator|||
name|e
operator|instanceof
name|SocketTimeoutException
operator|||
name|e
operator|instanceof
name|ClosedByInterruptException
operator|||
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"An established connection was aborted"
argument_list|)
operator|||
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"Broken pipe"
argument_list|)
operator|||
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"Connection reset"
argument_list|)
operator|||
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"java.nio.channels.SocketChannel"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Not checking disk as checkDiskError was called on a network"
operator|+
literal|" related exception"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"No space left on device"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DiskOutOfSpaceException
argument_list|(
literal|"No space left on device"
argument_list|)
throw|;
block|}
else|else
block|{
name|checkDiskError
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    *  Check if there is a disk failure and if so, handle the error    */
DECL|method|checkDiskError ()
specifier|public
name|void
name|checkDiskError
parameter_list|()
block|{
try|try
block|{
name|data
operator|.
name|checkDataDir
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DiskErrorException
name|de
parameter_list|)
block|{
name|handleDiskError
argument_list|(
name|de
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|handleDiskError (String errMsgr)
specifier|private
name|void
name|handleDiskError
parameter_list|(
name|String
name|errMsgr
parameter_list|)
block|{
specifier|final
name|boolean
name|hasEnoughResources
init|=
name|data
operator|.
name|hasEnoughResource
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"DataNode.handleDiskError: Keep Running: "
operator|+
name|hasEnoughResources
argument_list|)
expr_stmt|;
comment|// If we have enough active valid volumes then we do not want to
comment|// shutdown the DN completely.
name|int
name|dpError
init|=
name|hasEnoughResources
condition|?
name|DatanodeProtocol
operator|.
name|DISK_ERROR
else|:
name|DatanodeProtocol
operator|.
name|FATAL_DISK_ERROR
decl_stmt|;
name|metrics
operator|.
name|incrVolumeFailures
argument_list|()
expr_stmt|;
comment|//inform NameNodes
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
name|bpos
operator|.
name|trySendErrorReport
argument_list|(
name|dpError
argument_list|,
name|errMsgr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasEnoughResources
condition|)
block|{
name|scheduleAllBlockReport
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
comment|// do not shutdown
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"DataNode is shutting down: "
operator|+
name|errMsgr
argument_list|)
expr_stmt|;
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Number of concurrent xceivers per node. */
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getXceiverCount ()
specifier|public
name|int
name|getXceiverCount
parameter_list|()
block|{
return|return
name|threadGroup
operator|==
literal|null
condition|?
literal|0
else|:
name|threadGroup
operator|.
name|activeCount
argument_list|()
return|;
block|}
DECL|method|getXmitsInProgress ()
name|int
name|getXmitsInProgress
parameter_list|()
block|{
return|return
name|xmitsInProgress
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|transferBlock (ExtendedBlock block, DatanodeInfo xferTargets[])
specifier|private
name|void
name|transferBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|DatanodeInfo
name|xferTargets
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|getBPOSForBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|DatanodeRegistration
name|bpReg
init|=
name|getDNRegistrationForBP
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|isValidBlock
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|// block does not exist or is under-construction
name|String
name|errStr
init|=
literal|"Can't send invalid block "
operator|+
name|block
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|errStr
argument_list|)
expr_stmt|;
name|bpos
operator|.
name|trySendErrorReport
argument_list|(
name|DatanodeProtocol
operator|.
name|INVALID_BLOCK
argument_list|,
name|errStr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Check if NN recorded length matches on-disk length
name|long
name|onDiskLength
init|=
name|data
operator|.
name|getLength
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|getNumBytes
argument_list|()
operator|>
name|onDiskLength
condition|)
block|{
comment|// Shorter on-disk len indicates corruption so report NN the corrupt block
name|bpos
operator|.
name|reportBadBlocks
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can't replicate block "
operator|+
name|block
operator|+
literal|" because on-disk length "
operator|+
name|onDiskLength
operator|+
literal|" is shorter than NameNode recorded length "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|numTargets
init|=
name|xferTargets
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|numTargets
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|xfersBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTargets
condition|;
name|i
operator|++
control|)
block|{
name|xfersBuilder
operator|.
name|append
argument_list|(
name|xferTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfersBuilder
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|bpReg
operator|+
literal|" Starting thread to transfer "
operator|+
name|block
operator|+
literal|" to "
operator|+
name|xfersBuilder
argument_list|)
expr_stmt|;
block|}
operator|new
name|Daemon
argument_list|(
operator|new
name|DataTransfer
argument_list|(
name|xferTargets
argument_list|,
name|block
argument_list|,
name|BlockConstructionStage
operator|.
name|PIPELINE_SETUP_CREATE
argument_list|,
literal|""
argument_list|)
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|transferBlocks (String poolId, Block blocks[], DatanodeInfo xferTargets[][])
name|void
name|transferBlocks
parameter_list|(
name|String
name|poolId
parameter_list|,
name|Block
name|blocks
index|[]
parameter_list|,
name|DatanodeInfo
name|xferTargets
index|[]
index|[]
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|transferBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|poolId
argument_list|,
name|blocks
index|[
name|i
index|]
argument_list|)
argument_list|,
name|xferTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to transfer block "
operator|+
name|blocks
index|[
name|i
index|]
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* ********************************************************************   Protocol when a client reads data from Datanode (Cur Ver: 9):      Client's Request :   =================          Processed in DataXceiver:      +----------------------------------------------+      | Common Header   | 1 byte OP == OP_READ_BLOCK |      +----------------------------------------------+            Processed in readBlock() :      +-------------------------------------------------------------------------+      | 8 byte Block ID | 8 byte genstamp | 8 byte start offset | 8 byte length |      +-------------------------------------------------------------------------+      |   vInt length   |<DFSClient id> |      +-----------------------------------+            Client sends optional response only at the end of receiving data.           DataNode Response :   ===================         In readBlock() :     If there is an error while initializing BlockSender :        +---------------------------+        | 2 byte OP_STATUS_ERROR    | and connection will be closed.        +---------------------------+     Otherwise        +---------------------------+        | 2 byte OP_STATUS_SUCCESS  |        +---------------------------+             Actual data, sent by BlockSender.sendBlock() :            ChecksumHeader :       +--------------------------------------------------+       | 1 byte CHECKSUM_TYPE | 4 byte BYTES_PER_CHECKSUM |       +--------------------------------------------------+       Followed by actual data in the form of PACKETS:        +------------------------------------+       | Sequence of data PACKETs ....      |       +------------------------------------+          A "PACKET" is defined further below.          The client reads data until it receives a packet with      "LastPacketInBlock" set to true or with a zero length. It then replies     to DataNode with one of the status codes:     - CHECKSUM_OK:    All the chunk checksums have been verified     - SUCCESS:        Data received; checksums not verified     - ERROR_CHECKSUM: (Currently not used) Detected invalid checksums        +---------------+       | 2 byte Status |       +---------------+          The DataNode expects all well behaved clients to send the 2 byte     status code. And if the the client doesn't, the DN will close the     connection. So the status code is optional in the sense that it     does not affect the correctness of the data. (And the client can     always reconnect.)          PACKET : Contains a packet header, checksum and data. Amount of data     ======== carried is set by BUFFER_SIZE.            +-----------------------------------------------------+       | 4 byte packet length (excluding packet header)      |       +-----------------------------------------------------+       | 8 byte offset in the block | 8 byte sequence number |       +-----------------------------------------------------+       | 1 byte isLastPacketInBlock                          |       +-----------------------------------------------------+       | 4 byte Length of actual data                        |       +-----------------------------------------------------+       | x byte checksum data. x is defined below            |       +-----------------------------------------------------+       | actual data ......                                  |       +-----------------------------------------------------+              x = (length of data + BYTE_PER_CHECKSUM - 1)/BYTES_PER_CHECKSUM *           CHECKSUM_SIZE                  CHECKSUM_SIZE depends on CHECKSUM_TYPE (usually, 4 for CRC32)              The above packet format is used while writing data to DFS also.       Not all the fields might be used while reading.         ************************************************************************ */
comment|/**    * Used for transferring a block of data.  This class    * sends a piece of data to another DataNode.    */
DECL|class|DataTransfer
specifier|private
class|class
name|DataTransfer
implements|implements
name|Runnable
block|{
DECL|field|targets
specifier|final
name|DatanodeInfo
index|[]
name|targets
decl_stmt|;
DECL|field|b
specifier|final
name|ExtendedBlock
name|b
decl_stmt|;
DECL|field|stage
specifier|final
name|BlockConstructionStage
name|stage
decl_stmt|;
DECL|field|bpReg
specifier|final
specifier|private
name|DatanodeRegistration
name|bpReg
decl_stmt|;
DECL|field|clientname
specifier|final
name|String
name|clientname
decl_stmt|;
DECL|field|cachingStrategy
specifier|final
name|CachingStrategy
name|cachingStrategy
decl_stmt|;
comment|/**      * Connect to the first item in the target list.  Pass along the       * entire target list, the block, and the data.      */
DECL|method|DataTransfer (DatanodeInfo targets[], ExtendedBlock b, BlockConstructionStage stage, final String clientname)
name|DataTransfer
parameter_list|(
name|DatanodeInfo
name|targets
index|[]
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|,
name|BlockConstructionStage
name|stage
parameter_list|,
specifier|final
name|String
name|clientname
parameter_list|)
block|{
if|if
condition|(
name|DataTransferProtocol
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DataTransferProtocol
operator|.
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
operator|+
name|b
operator|+
literal|" (numBytes="
operator|+
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|")"
operator|+
literal|", stage="
operator|+
name|stage
operator|+
literal|", clientname="
operator|+
name|clientname
operator|+
literal|", targests="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|targets
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|targets
operator|=
name|targets
expr_stmt|;
name|this
operator|.
name|b
operator|=
name|b
expr_stmt|;
name|this
operator|.
name|stage
operator|=
name|stage
expr_stmt|;
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|bpReg
operator|=
name|bpos
operator|.
name|bpRegistration
expr_stmt|;
name|this
operator|.
name|clientname
operator|=
name|clientname
expr_stmt|;
name|this
operator|.
name|cachingStrategy
operator|=
operator|new
name|CachingStrategy
argument_list|(
literal|true
argument_list|,
name|getDnConf
argument_list|()
operator|.
name|readaheadLength
argument_list|)
expr_stmt|;
block|}
comment|/**      * Do the deed, write the bytes      */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|xmitsInProgress
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
name|Socket
name|sock
init|=
literal|null
decl_stmt|;
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
name|BlockSender
name|blockSender
init|=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|isClient
init|=
name|clientname
operator|.
name|length
argument_list|()
operator|>
literal|0
decl_stmt|;
try|try
block|{
specifier|final
name|String
name|dnAddr
init|=
name|targets
index|[
literal|0
index|]
operator|.
name|getXferAddr
argument_list|(
name|connectToDnViaHostname
argument_list|)
decl_stmt|;
name|InetSocketAddress
name|curTarget
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|dnAddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to datanode "
operator|+
name|dnAddr
argument_list|)
expr_stmt|;
block|}
name|sock
operator|=
name|newSocket
argument_list|()
expr_stmt|;
name|NetUtils
operator|.
name|connect
argument_list|(
name|sock
argument_list|,
name|curTarget
argument_list|,
name|dnConf
operator|.
name|socketTimeout
argument_list|)
expr_stmt|;
name|sock
operator|.
name|setSoTimeout
argument_list|(
name|targets
operator|.
name|length
operator|*
name|dnConf
operator|.
name|socketTimeout
argument_list|)
expr_stmt|;
name|long
name|writeTimeout
init|=
name|dnConf
operator|.
name|socketWriteTimeout
operator|+
name|HdfsServerConstants
operator|.
name|WRITE_TIMEOUT_EXTENSION
operator|*
operator|(
name|targets
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
name|OutputStream
name|unbufOut
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|sock
argument_list|,
name|writeTimeout
argument_list|)
decl_stmt|;
name|InputStream
name|unbufIn
init|=
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|sock
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnConf
operator|.
name|encryptDataTransfer
condition|)
block|{
name|IOStreamPair
name|encryptedStreams
init|=
name|DataTransferEncryptor
operator|.
name|getEncryptedStreams
argument_list|(
name|unbufOut
argument_list|,
name|unbufIn
argument_list|,
name|blockPoolTokenSecretManager
operator|.
name|generateDataEncryptionKey
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|unbufOut
operator|=
name|encryptedStreams
operator|.
name|out
expr_stmt|;
name|unbufIn
operator|=
name|encryptedStreams
operator|.
name|in
expr_stmt|;
block|}
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|unbufOut
argument_list|,
name|HdfsConstants
operator|.
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
name|unbufIn
argument_list|)
expr_stmt|;
name|blockSender
operator|=
operator|new
name|BlockSender
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|DataNode
operator|.
name|this
argument_list|,
literal|null
argument_list|,
name|cachingStrategy
argument_list|)
expr_stmt|;
name|DatanodeInfo
name|srcNode
init|=
operator|new
name|DatanodeInfo
argument_list|(
name|bpReg
argument_list|)
decl_stmt|;
comment|//
comment|// Header info
comment|//
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|accessToken
init|=
name|BlockTokenSecretManager
operator|.
name|DUMMY_TOKEN
decl_stmt|;
if|if
condition|(
name|isBlockTokenEnabled
condition|)
block|{
name|accessToken
operator|=
name|blockPoolTokenSecretManager
operator|.
name|generateToken
argument_list|(
name|b
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|writeBlock
argument_list|(
name|b
argument_list|,
name|accessToken
argument_list|,
name|clientname
argument_list|,
name|targets
argument_list|,
name|srcNode
argument_list|,
name|stage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|blockSender
operator|.
name|getChecksum
argument_list|()
argument_list|,
name|cachingStrategy
argument_list|)
expr_stmt|;
comment|// send data& checksum
name|blockSender
operator|.
name|sendBlock
argument_list|(
name|out
argument_list|,
name|unbufOut
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// no response necessary
name|LOG
operator|.
name|info
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": Transmitted "
operator|+
name|b
operator|+
literal|" (numBytes="
operator|+
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|") to "
operator|+
name|curTarget
argument_list|)
expr_stmt|;
comment|// read ack
if|if
condition|(
name|isClient
condition|)
block|{
name|DNTransferAckProto
name|closeAck
init|=
name|DNTransferAckProto
operator|.
name|parseFrom
argument_list|(
name|PBHelper
operator|.
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": close-ack="
operator|+
name|closeAck
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closeAck
operator|.
name|getStatus
argument_list|()
operator|!=
name|Status
operator|.
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|closeAck
operator|.
name|getStatus
argument_list|()
operator|==
name|Status
operator|.
name|ERROR_ACCESS_TOKEN
condition|)
block|{
throw|throw
operator|new
name|InvalidBlockTokenException
argument_list|(
literal|"Got access token error for connect ack, targets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|targets
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Bad connect ack, targets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|targets
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|bpReg
operator|+
literal|":Failed to transfer "
operator|+
name|b
operator|+
literal|" to "
operator|+
name|targets
index|[
literal|0
index|]
operator|+
literal|" got "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|// check if there are any disk problem
try|try
block|{
name|checkDiskError
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DataNode.checkDiskError failed in run() with: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|xmitsInProgress
operator|.
name|getAndDecrement
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|blockSender
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * After a block becomes finalized, a datanode increases metric counter,    * notifies namenode, and adds it to the block scanner    * @param block    * @param delHint    */
DECL|method|closeBlock (ExtendedBlock block, String delHint)
name|void
name|closeBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|delHint
parameter_list|)
block|{
name|metrics
operator|.
name|incrBlocksWritten
argument_list|()
expr_stmt|;
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|!=
literal|null
condition|)
block|{
name|bpos
operator|.
name|notifyNamenodeReceivedBlock
argument_list|(
name|block
argument_list|,
name|delHint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot find BPOfferService for reporting block received for bpid="
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|addBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Start a single datanode daemon and wait for it to finish.    *  If this thread is specifically interrupted, it will stop waiting.    */
DECL|method|runDatanodeDaemon ()
specifier|public
name|void
name|runDatanodeDaemon
parameter_list|()
throws|throws
name|IOException
block|{
name|blockPoolManager
operator|.
name|startAll
argument_list|()
expr_stmt|;
comment|// start dataXceiveServer
name|dataXceiverServer
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|localDataXceiverServer
operator|!=
literal|null
condition|)
block|{
name|localDataXceiverServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|ipcServer
operator|.
name|start
argument_list|()
expr_stmt|;
name|startPlugins
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * A data node is considered to be up if one of the bp services is up    */
DECL|method|isDatanodeUp ()
specifier|public
name|boolean
name|isDatanodeUp
parameter_list|()
block|{
for|for
control|(
name|BPOfferService
name|bp
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
if|if
condition|(
name|bp
operator|.
name|isAlive
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Instantiate a single datanode object. This must be run by invoking    *  {@link DataNode#runDatanodeDaemon()} subsequently.     */
DECL|method|instantiateDataNode (String args[], Configuration conf)
specifier|public
specifier|static
name|DataNode
name|instantiateDataNode
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|instantiateDataNode
argument_list|(
name|args
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Instantiate a single datanode object, along with its secure resources.     * This must be run by invoking{@link DataNode#runDatanodeDaemon()}     * subsequently.     */
DECL|method|instantiateDataNode (String args [], Configuration conf, SecureResources resources)
specifier|public
specifier|static
name|DataNode
name|instantiateDataNode
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
name|conf
operator|=
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
comment|// parse generic hadoop options
name|GenericOptionsParser
name|hParser
init|=
operator|new
name|GenericOptionsParser
argument_list|(
name|conf
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|args
operator|=
name|hParser
operator|.
name|getRemainingArgs
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parseArguments
argument_list|(
name|args
argument_list|,
name|conf
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Collection
argument_list|<
name|URI
argument_list|>
name|dataDirs
init|=
name|getStorageDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_DATANODE_KEYTAB_FILE_KEY
argument_list|,
name|DFS_DATANODE_USER_NAME_KEY
argument_list|)
expr_stmt|;
return|return
name|makeInstance
argument_list|(
name|dataDirs
argument_list|,
name|conf
argument_list|,
name|resources
argument_list|)
return|;
block|}
DECL|method|getStorageDirs (Configuration conf)
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getStorageDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|DFS_DATANODE_DATA_DIR_KEY
argument_list|)
decl_stmt|;
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
comment|/** Instantiate& Start a single datanode daemon and wait for it to finish.    *  If this thread is specifically interrupted, it will stop waiting.    */
DECL|method|createDataNode (String args[], Configuration conf)
specifier|public
specifier|static
name|DataNode
name|createDataNode
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createDataNode
argument_list|(
name|args
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Instantiate& Start a single datanode daemon and wait for it to finish.    *  If this thread is specifically interrupted, it will stop waiting.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|createDataNode (String args[], Configuration conf, SecureResources resources)
specifier|public
specifier|static
name|DataNode
name|createDataNode
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
name|DataNode
name|dn
init|=
name|instantiateDataNode
argument_list|(
name|args
argument_list|,
name|conf
argument_list|,
name|resources
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|!=
literal|null
condition|)
block|{
name|dn
operator|.
name|runDatanodeDaemon
argument_list|()
expr_stmt|;
block|}
return|return
name|dn
return|;
block|}
DECL|method|join ()
name|void
name|join
parameter_list|()
block|{
while|while
condition|(
name|shouldRun
condition|)
block|{
try|try
block|{
name|blockPoolManager
operator|.
name|joinAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
operator|!=
literal|null
operator|&&
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received exception in Datanode#join: "
operator|+
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Small wrapper around the DiskChecker class that provides means to mock
comment|// DiskChecker static methods and unittest DataNode#getDataDirsFromURIs.
DECL|class|DataNodeDiskChecker
specifier|static
class|class
name|DataNodeDiskChecker
block|{
DECL|field|expectedPermission
specifier|private
name|FsPermission
name|expectedPermission
decl_stmt|;
DECL|method|DataNodeDiskChecker (FsPermission expectedPermission)
specifier|public
name|DataNodeDiskChecker
parameter_list|(
name|FsPermission
name|expectedPermission
parameter_list|)
block|{
name|this
operator|.
name|expectedPermission
operator|=
name|expectedPermission
expr_stmt|;
block|}
DECL|method|checkDir (LocalFileSystem localFS, Path path)
specifier|public
name|void
name|checkDir
parameter_list|(
name|LocalFileSystem
name|localFS
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|DiskErrorException
throws|,
name|IOException
block|{
name|DiskChecker
operator|.
name|checkDir
argument_list|(
name|localFS
argument_list|,
name|path
argument_list|,
name|expectedPermission
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Make an instance of DataNode after ensuring that at least one of the    * given data directories (and their parent directories, if necessary)    * can be created.    * @param dataDirs List of directories, where the new DataNode instance should    * keep its files.    * @param conf Configuration instance to use.    * @param resources Secure resources needed to run under Kerberos    * @return DataNode instance for given list of data dirs and conf, or null if    * no directory from this directory list can be created.    * @throws IOException    */
DECL|method|makeInstance (Collection<URI> dataDirs, Configuration conf, SecureResources resources)
specifier|static
name|DataNode
name|makeInstance
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|dataDirs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
name|LocalFileSystem
name|localFS
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FsPermission
name|permission
init|=
operator|new
name|FsPermission
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_DATANODE_DATA_DIR_PERMISSION_KEY
argument_list|,
name|DFS_DATANODE_DATA_DIR_PERMISSION_DEFAULT
argument_list|)
argument_list|)
decl_stmt|;
name|DataNodeDiskChecker
name|dataNodeDiskChecker
init|=
operator|new
name|DataNodeDiskChecker
argument_list|(
name|permission
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|File
argument_list|>
name|dirs
init|=
name|getDataDirsFromURIs
argument_list|(
name|dataDirs
argument_list|,
name|localFS
argument_list|,
name|dataNodeDiskChecker
argument_list|)
decl_stmt|;
name|DefaultMetricsSystem
operator|.
name|initialize
argument_list|(
literal|"DataNode"
argument_list|)
expr_stmt|;
assert|assert
name|dirs
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|:
literal|"number of data directories should be> 0"
assert|;
return|return
operator|new
name|DataNode
argument_list|(
name|conf
argument_list|,
name|dirs
argument_list|,
name|resources
argument_list|)
return|;
block|}
comment|// DataNode ctor expects AbstractList instead of List or Collection...
DECL|method|getDataDirsFromURIs (Collection<URI> dataDirs, LocalFileSystem localFS, DataNodeDiskChecker dataNodeDiskChecker)
specifier|static
name|ArrayList
argument_list|<
name|File
argument_list|>
name|getDataDirsFromURIs
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|dataDirs
parameter_list|,
name|LocalFileSystem
name|localFS
parameter_list|,
name|DataNodeDiskChecker
name|dataNodeDiskChecker
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|invalidDirs
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|URI
name|dirURI
range|:
name|dataDirs
control|)
block|{
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equalsIgnoreCase
argument_list|(
name|dirURI
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unsupported URI schema in "
operator|+
name|dirURI
operator|+
literal|". Ignoring ..."
argument_list|)
expr_stmt|;
name|invalidDirs
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
operator|.
name|append
argument_list|(
name|dirURI
argument_list|)
operator|.
name|append
argument_list|(
literal|"\" "
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// drop any (illegal) authority in the URI for backwards compatibility
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|dirURI
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|dataNodeDiskChecker
operator|.
name|checkDir
argument_list|(
name|localFS
argument_list|,
operator|new
name|Path
argument_list|(
name|dir
operator|.
name|toURI
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dirs
operator|.
name|add
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid "
operator|+
name|DFS_DATANODE_DATA_DIR_KEY
operator|+
literal|" "
operator|+
name|dir
operator|+
literal|" : "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|invalidDirs
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
operator|.
name|append
argument_list|(
name|dir
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\" "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dirs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All directories in "
operator|+
name|DFS_DATANODE_DATA_DIR_KEY
operator|+
literal|" are invalid: "
operator|+
name|invalidDirs
argument_list|)
throw|;
block|}
return|return
name|dirs
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DataNode{data="
operator|+
name|data
operator|+
literal|", localName='"
operator|+
name|getDisplayName
argument_list|()
operator|+
literal|"', storageID='"
operator|+
name|getStorageId
argument_list|()
operator|+
literal|"', xmitsInProgress="
operator|+
name|xmitsInProgress
operator|.
name|get
argument_list|()
operator|+
literal|"}"
return|;
block|}
DECL|method|printUsage (PrintStream out)
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|USAGE
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse and verify command line arguments and set configuration parameters.    *    * @return false if passed argements are incorrect    */
DECL|method|parseArguments (String args[], Configuration conf)
specifier|private
specifier|static
name|boolean
name|parseArguments
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|argsLen
init|=
operator|(
name|args
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|args
operator|.
name|length
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|StartupOption
operator|.
name|REGULAR
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argsLen
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cmd
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
literal|"-r"
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
operator|||
literal|"--rack"
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"-r, --rack arguments are not supported anymore. RackID "
operator|+
literal|"resolution is handled by the NameNode."
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-rollback"
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|ROLLBACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-regular"
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|REGULAR
expr_stmt|;
block|}
else|else
return|return
literal|false
return|;
block|}
name|setStartupOption
argument_list|(
name|conf
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|setStartupOption (Configuration conf, StartupOption opt)
specifier|private
specifier|static
name|void
name|setStartupOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|StartupOption
name|opt
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|DFS_DATANODE_STARTUP_KEY
argument_list|,
name|opt
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getStartupOption (Configuration conf)
specifier|static
name|StartupOption
name|getStartupOption
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|StartupOption
operator|.
name|valueOf
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_DATANODE_STARTUP_KEY
argument_list|,
name|StartupOption
operator|.
name|REGULAR
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * This methods  arranges for the data node to send     * the block report at the next heartbeat.    */
DECL|method|scheduleAllBlockReport (long delay)
specifier|public
name|void
name|scheduleAllBlockReport
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
name|bpos
operator|.
name|scheduleBlockReport
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method is used for testing.     * Examples are adding and deleting blocks directly.    * The most common usage will be when the data node's storage is simulated.    *     * @return the fsdataset that stores the blocks    */
DECL|method|getFSDataset ()
name|FsDatasetSpi
argument_list|<
name|?
argument_list|>
name|getFSDataset
parameter_list|()
block|{
return|return
name|data
return|;
block|}
comment|/** @return the block scanner. */
DECL|method|getBlockScanner ()
specifier|public
name|DataBlockScanner
name|getBlockScanner
parameter_list|()
block|{
return|return
name|blockScanner
return|;
block|}
DECL|method|secureMain (String args[], SecureResources resources)
specifier|public
specifier|static
name|void
name|secureMain
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|SecureResources
name|resources
parameter_list|)
block|{
try|try
block|{
name|StringUtils
operator|.
name|startupShutdownMessage
argument_list|(
name|DataNode
operator|.
name|class
argument_list|,
name|args
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|DataNode
name|datanode
init|=
name|createDataNode
argument_list|(
name|args
argument_list|,
literal|null
argument_list|,
name|resources
argument_list|)
decl_stmt|;
if|if
condition|(
name|datanode
operator|!=
literal|null
condition|)
name|datanode
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Exception in secureMain"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// We need to terminate the process here because either shutdown was called
comment|// or some disk related conditions like volumes tolerated or volumes required
comment|// condition was not met. Also, In secure mode, control will go to Jsvc
comment|// and Datanode process hangs if it does not exit.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exiting Datanode"
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|main (String args[])
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
name|args
index|[]
parameter_list|)
block|{
if|if
condition|(
name|DFSUtil
operator|.
name|parseHelpArgument
argument_list|(
name|args
argument_list|,
name|DataNode
operator|.
name|USAGE
argument_list|,
name|System
operator|.
name|out
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|secureMain
argument_list|(
name|args
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|recoverBlocks ( final String who, final Collection<RecoveringBlock> blocks)
specifier|public
name|Daemon
name|recoverBlocks
parameter_list|(
specifier|final
name|String
name|who
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|RecoveringBlock
argument_list|>
name|blocks
parameter_list|)
block|{
name|Daemon
name|d
init|=
operator|new
name|Daemon
argument_list|(
name|threadGroup
argument_list|,
operator|new
name|Runnable
argument_list|()
block|{
comment|/** Recover a list of blocks. It is run by the primary datanode. */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
name|RecoveringBlock
name|b
range|:
name|blocks
control|)
block|{
try|try
block|{
name|logRecoverBlock
argument_list|(
name|who
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|recoverBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"recoverBlocks FAILED: "
operator|+
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
decl_stmt|;
name|d
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|d
return|;
block|}
comment|// InterDataNodeProtocol implementation
annotation|@
name|Override
comment|// InterDatanodeProtocol
DECL|method|initReplicaRecovery (RecoveringBlock rBlock)
specifier|public
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|data
operator|.
name|initReplicaRecovery
argument_list|(
name|rBlock
argument_list|)
return|;
block|}
comment|/**    * Convenience method, which unwraps RemoteException.    * @throws IOException not a RemoteException.    */
DECL|method|callInitReplicaRecovery ( InterDatanodeProtocol datanode, RecoveringBlock rBlock)
specifier|private
specifier|static
name|ReplicaRecoveryInfo
name|callInitReplicaRecovery
parameter_list|(
name|InterDatanodeProtocol
name|datanode
parameter_list|,
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|datanode
operator|.
name|initReplicaRecovery
argument_list|(
name|rBlock
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Update replica with the new generation stamp and length.      */
annotation|@
name|Override
comment|// InterDatanodeProtocol
DECL|method|updateReplicaUnderRecovery (final ExtendedBlock oldBlock, final long recoveryId, final long newLength)
specifier|public
name|String
name|updateReplicaUnderRecovery
parameter_list|(
specifier|final
name|ExtendedBlock
name|oldBlock
parameter_list|,
specifier|final
name|long
name|recoveryId
parameter_list|,
specifier|final
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|storageID
init|=
name|data
operator|.
name|updateReplicaUnderRecovery
argument_list|(
name|oldBlock
argument_list|,
name|recoveryId
argument_list|,
name|newLength
argument_list|)
decl_stmt|;
comment|// Notify the namenode of the updated block info. This is important
comment|// for HA, since otherwise the standby node may lose track of the
comment|// block locations until the next block report.
name|ExtendedBlock
name|newBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|oldBlock
argument_list|)
decl_stmt|;
name|newBlock
operator|.
name|setGenerationStamp
argument_list|(
name|recoveryId
argument_list|)
expr_stmt|;
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|newLength
argument_list|)
expr_stmt|;
name|notifyNamenodeReceivedBlock
argument_list|(
name|newBlock
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|storageID
return|;
block|}
comment|/** A convenient class used in block recovery */
DECL|class|BlockRecord
specifier|static
class|class
name|BlockRecord
block|{
DECL|field|id
specifier|final
name|DatanodeID
name|id
decl_stmt|;
DECL|field|datanode
specifier|final
name|InterDatanodeProtocol
name|datanode
decl_stmt|;
DECL|field|rInfo
specifier|final
name|ReplicaRecoveryInfo
name|rInfo
decl_stmt|;
DECL|field|storageID
specifier|private
name|String
name|storageID
decl_stmt|;
DECL|method|BlockRecord (DatanodeID id, InterDatanodeProtocol datanode, ReplicaRecoveryInfo rInfo)
name|BlockRecord
parameter_list|(
name|DatanodeID
name|id
parameter_list|,
name|InterDatanodeProtocol
name|datanode
parameter_list|,
name|ReplicaRecoveryInfo
name|rInfo
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|rInfo
operator|=
name|rInfo
expr_stmt|;
block|}
DECL|method|updateReplicaUnderRecovery (String bpid, long recoveryId, long newLength )
name|void
name|updateReplicaUnderRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ExtendedBlock
name|b
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|rInfo
argument_list|)
decl_stmt|;
name|storageID
operator|=
name|datanode
operator|.
name|updateReplicaUnderRecovery
argument_list|(
name|b
argument_list|,
name|recoveryId
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"block:"
operator|+
name|rInfo
operator|+
literal|" node:"
operator|+
name|id
return|;
block|}
block|}
comment|/** Recover a block */
DECL|method|recoverBlock (RecoveringBlock rBlock)
specifier|private
name|void
name|recoverBlock
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
name|ExtendedBlock
name|block
init|=
name|rBlock
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|String
name|blookPoolId
init|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|DatanodeID
index|[]
name|datanodeids
init|=
name|rBlock
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|syncList
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockRecord
argument_list|>
argument_list|(
name|datanodeids
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|errorCount
init|=
literal|0
decl_stmt|;
comment|//check generation stamps
for|for
control|(
name|DatanodeID
name|id
range|:
name|datanodeids
control|)
block|{
try|try
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|blookPoolId
argument_list|)
decl_stmt|;
name|DatanodeRegistration
name|bpReg
init|=
name|bpos
operator|.
name|bpRegistration
decl_stmt|;
name|InterDatanodeProtocol
name|datanode
init|=
name|bpReg
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|?
name|this
else|:
name|DataNode
operator|.
name|createInterDataNodeProtocolProxy
argument_list|(
name|id
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|dnConf
operator|.
name|socketTimeout
argument_list|,
name|dnConf
operator|.
name|connectToDnViaHostname
argument_list|)
decl_stmt|;
name|ReplicaRecoveryInfo
name|info
init|=
name|callInitReplicaRecovery
argument_list|(
name|datanode
argument_list|,
name|rBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getGenerationStamp
argument_list|()
operator|>=
name|block
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|info
operator|.
name|getNumBytes
argument_list|()
operator|>
literal|0
condition|)
block|{
name|syncList
operator|.
name|add
argument_list|(
operator|new
name|BlockRecord
argument_list|(
name|id
argument_list|,
name|datanode
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RecoveryInProgressException
name|ripE
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Recovery for replica "
operator|+
name|block
operator|+
literal|" on data-node "
operator|+
name|id
operator|+
literal|" is already in progress. Recovery id = "
operator|+
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
operator|+
literal|" is aborted."
argument_list|,
name|ripE
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
operator|++
name|errorCount
expr_stmt|;
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to obtain replica info for block (="
operator|+
name|block
operator|+
literal|") from datanode (="
operator|+
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errorCount
operator|==
name|datanodeids
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All datanodes failed: block="
operator|+
name|block
operator|+
literal|", datanodeids="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|datanodeids
argument_list|)
argument_list|)
throw|;
block|}
name|syncBlock
argument_list|(
name|rBlock
argument_list|,
name|syncList
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the NameNode corresponding to the given block pool.    *    * @param bpid Block pool Id    * @return Namenode corresponding to the bpid    * @throws IOException if unable to get the corresponding NameNode    */
DECL|method|getActiveNamenodeForBP (String bpid)
specifier|public
name|DatanodeProtocolClientSideTranslatorPB
name|getActiveNamenodeForBP
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No block pool offer service for bpid="
operator|+
name|bpid
argument_list|)
throw|;
block|}
name|DatanodeProtocolClientSideTranslatorPB
name|activeNN
init|=
name|bpos
operator|.
name|getActiveNN
argument_list|()
decl_stmt|;
if|if
condition|(
name|activeNN
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block pool "
operator|+
name|bpid
operator|+
literal|" has not recognized an active NN"
argument_list|)
throw|;
block|}
return|return
name|activeNN
return|;
block|}
comment|/** Block synchronization */
DECL|method|syncBlock (RecoveringBlock rBlock, List<BlockRecord> syncList)
name|void
name|syncBlock
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|,
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|syncList
parameter_list|)
throws|throws
name|IOException
block|{
name|ExtendedBlock
name|block
init|=
name|rBlock
operator|.
name|getBlock
argument_list|()
decl_stmt|;
specifier|final
name|String
name|bpid
init|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|DatanodeProtocolClientSideTranslatorPB
name|nn
init|=
name|getActiveNamenodeForBP
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|recoveryId
init|=
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"block="
operator|+
name|block
operator|+
literal|", (length="
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|"), syncList="
operator|+
name|syncList
argument_list|)
expr_stmt|;
block|}
comment|// syncList.isEmpty() means that all data-nodes do not have the block
comment|// or their replicas have 0 length.
comment|// The block can be deleted.
if|if
condition|(
name|syncList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|nn
operator|.
name|commitBlockSynchronization
argument_list|(
name|block
argument_list|,
name|recoveryId
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|DatanodeID
operator|.
name|EMPTY_ARRAY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Calculate the best available replica state.
name|ReplicaState
name|bestState
init|=
name|ReplicaState
operator|.
name|RWR
decl_stmt|;
name|long
name|finalizedLength
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
assert|assert
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|>
literal|0
operator|:
literal|"zero length replica"
assert|;
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|.
name|getValue
argument_list|()
operator|<
name|bestState
operator|.
name|getValue
argument_list|()
condition|)
name|bestState
operator|=
name|rState
expr_stmt|;
if|if
condition|(
name|rState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
if|if
condition|(
name|finalizedLength
operator|>
literal|0
operator|&&
name|finalizedLength
operator|!=
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent size of finalized replicas. "
operator|+
literal|"Replica "
operator|+
name|r
operator|.
name|rInfo
operator|+
literal|" expected size: "
operator|+
name|finalizedLength
argument_list|)
throw|;
name|finalizedLength
operator|=
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Calculate list of nodes that will participate in the recovery
comment|// and the new block size
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|participatingList
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockRecord
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|ExtendedBlock
name|newBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|recoveryId
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|bestState
condition|)
block|{
case|case
name|FINALIZED
case|:
assert|assert
name|finalizedLength
operator|>
literal|0
operator|:
literal|"finalizedLength is not positive"
assert|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|||
name|rState
operator|==
name|ReplicaState
operator|.
name|RBW
operator|&&
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|==
name|finalizedLength
condition|)
name|participatingList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|finalizedLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|RBW
case|:
case|case
name|RWR
case|:
name|long
name|minLength
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|==
name|bestState
condition|)
block|{
name|minLength
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minLength
argument_list|,
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|participatingList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|minLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUR
case|:
case|case
name|TEMPORARY
case|:
assert|assert
literal|false
operator|:
literal|"bad replica state: "
operator|+
name|bestState
assert|;
block|}
name|List
argument_list|<
name|DatanodeID
argument_list|>
name|failedList
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeID
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|successList
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockRecord
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|participatingList
control|)
block|{
try|try
block|{
name|r
operator|.
name|updateReplicaUnderRecovery
argument_list|(
name|bpid
argument_list|,
name|recoveryId
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|successList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to updateBlock (newblock="
operator|+
name|newBlock
operator|+
literal|", datanode="
operator|+
name|r
operator|.
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|failedList
operator|.
name|add
argument_list|(
name|r
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If any of the data-nodes failed, the recovery fails, because
comment|// we never know the actual state of the replica on failed data-nodes.
comment|// The recovery should be started over.
if|if
condition|(
operator|!
name|failedList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeID
name|id
range|:
name|failedList
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"\n  "
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot recover "
operator|+
name|block
operator|+
literal|", the following "
operator|+
name|failedList
operator|.
name|size
argument_list|()
operator|+
literal|" data-nodes failed {"
operator|+
name|b
operator|+
literal|"\n}"
argument_list|)
throw|;
block|}
comment|// Notify the name-node about successfully recovered replicas.
specifier|final
name|DatanodeID
index|[]
name|datanodes
init|=
operator|new
name|DatanodeID
index|[
name|successList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|String
index|[]
name|storages
init|=
operator|new
name|String
index|[
name|datanodes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|datanodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|BlockRecord
name|r
init|=
name|successList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|datanodes
index|[
name|i
index|]
operator|=
name|r
operator|.
name|id
expr_stmt|;
name|storages
index|[
name|i
index|]
operator|=
name|r
operator|.
name|storageID
expr_stmt|;
block|}
name|nn
operator|.
name|commitBlockSynchronization
argument_list|(
name|block
argument_list|,
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|datanodes
argument_list|,
name|storages
argument_list|)
expr_stmt|;
block|}
DECL|method|logRecoverBlock (String who, RecoveringBlock rb)
specifier|private
specifier|static
name|void
name|logRecoverBlock
parameter_list|(
name|String
name|who
parameter_list|,
name|RecoveringBlock
name|rb
parameter_list|)
block|{
name|ExtendedBlock
name|block
init|=
name|rb
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|DatanodeInfo
index|[]
name|targets
init|=
name|rb
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|who
operator|+
literal|" calls recoverBlock("
operator|+
name|block
operator|+
literal|", targets=["
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|targets
argument_list|)
operator|+
literal|"]"
operator|+
literal|", newGenerationStamp="
operator|+
name|rb
operator|.
name|getNewGenerationStamp
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// ClientDataNodeProtocol
DECL|method|getReplicaVisibleLength (final ExtendedBlock block)
specifier|public
name|long
name|getReplicaVisibleLength
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|checkWriteAccess
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|data
operator|.
name|getReplicaVisibleLength
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|checkWriteAccess (final ExtendedBlock block)
specifier|private
name|void
name|checkWriteAccess
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isBlockTokenEnabled
condition|)
block|{
name|Set
argument_list|<
name|TokenIdentifier
argument_list|>
name|tokenIds
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getTokenIdentifiers
argument_list|()
decl_stmt|;
if|if
condition|(
name|tokenIds
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't continue since none or more than one "
operator|+
literal|"BlockTokenIdentifier is found."
argument_list|)
throw|;
block|}
for|for
control|(
name|TokenIdentifier
name|tokenId
range|:
name|tokenIds
control|)
block|{
name|BlockTokenIdentifier
name|id
init|=
operator|(
name|BlockTokenIdentifier
operator|)
name|tokenId
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got: "
operator|+
name|id
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|blockPoolTokenSecretManager
operator|.
name|checkAccess
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|block
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|READ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Transfer a replica to the datanode targets.    * @param b the block to transfer.    *          The corresponding replica must be an RBW or a Finalized.    *          Its GS and numBytes will be set to    *          the stored GS and the visible length.     * @param targets    * @param client    */
DECL|method|transferReplicaForPipelineRecovery (final ExtendedBlock b, final DatanodeInfo[] targets, final String client)
name|void
name|transferReplicaForPipelineRecovery
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|targets
parameter_list|,
specifier|final
name|String
name|client
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|storedGS
decl_stmt|;
specifier|final
name|long
name|visible
decl_stmt|;
specifier|final
name|BlockConstructionStage
name|stage
decl_stmt|;
comment|//get replica information
synchronized|synchronized
init|(
name|data
init|)
block|{
name|Block
name|storedBlock
init|=
name|data
operator|.
name|getStoredBlock
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|storedBlock
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|b
operator|+
literal|" not found in datanode."
argument_list|)
throw|;
block|}
name|storedGS
operator|=
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
expr_stmt|;
if|if
condition|(
name|storedGS
operator|<
name|b
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|storedGS
operator|+
literal|" = storedGS< b.getGenerationStamp(), b="
operator|+
name|b
argument_list|)
throw|;
block|}
comment|// Update the genstamp with storedGS
name|b
operator|.
name|setGenerationStamp
argument_list|(
name|storedGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|isValidRbw
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|stage
operator|=
name|BlockConstructionStage
operator|.
name|TRANSFER_RBW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|.
name|isValidBlock
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|stage
operator|=
name|BlockConstructionStage
operator|.
name|TRANSFER_FINALIZED
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|String
name|r
init|=
name|data
operator|.
name|getReplicaString
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|b
operator|+
literal|" is neither a RBW nor a Finalized, r="
operator|+
name|r
argument_list|)
throw|;
block|}
name|visible
operator|=
name|data
operator|.
name|getReplicaVisibleLength
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|//set visible length
name|b
operator|.
name|setNumBytes
argument_list|(
name|visible
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|.
name|length
operator|>
literal|0
condition|)
block|{
operator|new
name|DataTransfer
argument_list|(
name|targets
argument_list|,
name|b
argument_list|,
name|stage
argument_list|,
name|client
argument_list|)
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Finalize a pending upgrade in response to DNA_FINALIZE.    * @param blockPoolId the block pool to finalize    */
DECL|method|finalizeUpgradeForPool (String blockPoolId)
name|void
name|finalizeUpgradeForPool
parameter_list|(
name|String
name|blockPoolId
parameter_list|)
throws|throws
name|IOException
block|{
name|storage
operator|.
name|finalizeUpgrade
argument_list|(
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
DECL|method|getStreamingAddr (Configuration conf)
specifier|static
name|InetSocketAddress
name|getStreamingAddr
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_DATANODE_ADDRESS_KEY
argument_list|,
name|DFS_DATANODE_ADDRESS_DEFAULT
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getVersion ()
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getVersion
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getRpcPort ()
specifier|public
name|String
name|getRpcPort
parameter_list|()
block|{
name|InetSocketAddress
name|ipcAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|this
operator|.
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|DFS_DATANODE_IPC_ADDRESS_KEY
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|ipcAddr
operator|.
name|getPort
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getHttpPort ()
specifier|public
name|String
name|getHttpPort
parameter_list|()
block|{
return|return
name|this
operator|.
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
literal|"dfs.datanode.info.port"
argument_list|)
return|;
block|}
comment|/**    * @return the datanode's http port    */
DECL|method|getInfoPort ()
specifier|public
name|int
name|getInfoPort
parameter_list|()
block|{
return|return
name|infoServer
operator|.
name|getPort
argument_list|()
return|;
block|}
comment|/**    * Returned information is a JSON representation of a map with     * name node host name as the key and block pool Id as the value.    * Note that, if there are multiple NNs in an NA nameservice,    * a given block pool may be represented twice.    */
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getNamenodeAddresses ()
specifier|public
name|String
name|getNamenodeAddresses
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
if|if
condition|(
name|bpos
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|BPServiceActor
name|actor
range|:
name|bpos
operator|.
name|getBPServiceActors
argument_list|()
control|)
block|{
name|info
operator|.
name|put
argument_list|(
name|actor
operator|.
name|getNNSocketAddress
argument_list|()
operator|.
name|getHostName
argument_list|()
argument_list|,
name|bpos
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
comment|/**    * Returned information is a JSON representation of a map with     * volume name as the key and value is a map of volume attribute     * keys to its values    */
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getVolumeInfo ()
specifier|public
name|String
name|getVolumeInfo
parameter_list|()
block|{
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|data
operator|.
name|getVolumeInfoMap
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getClusterId ()
specifier|public
specifier|synchronized
name|String
name|getClusterId
parameter_list|()
block|{
return|return
name|clusterId
return|;
block|}
DECL|method|refreshNamenodes (Configuration conf)
specifier|public
name|void
name|refreshNamenodes
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|blockPoolManager
operator|.
name|refreshNamenodes
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// ClientDatanodeProtocol
DECL|method|refreshNamenodes ()
specifier|public
name|void
name|refreshNamenodes
parameter_list|()
throws|throws
name|IOException
block|{
name|conf
operator|=
operator|new
name|Configuration
argument_list|()
expr_stmt|;
name|refreshNamenodes
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// ClientDatanodeProtocol
DECL|method|deleteBlockPool (String blockPoolId, boolean force)
specifier|public
name|void
name|deleteBlockPool
parameter_list|(
name|String
name|blockPoolId
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"deleteBlockPool command received for block pool "
operator|+
name|blockPoolId
operator|+
literal|", force="
operator|+
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockPoolManager
operator|.
name|get
argument_list|(
name|blockPoolId
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The block pool "
operator|+
name|blockPoolId
operator|+
literal|" is still running, cannot be deleted."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The block pool is still running. First do a refreshNamenodes to "
operator|+
literal|"shutdown the block pool service"
argument_list|)
throw|;
block|}
name|data
operator|.
name|deleteBlockPool
argument_list|(
name|blockPoolId
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param addr rpc address of the namenode    * @return true if the datanode is connected to a NameNode at the    * given address    */
DECL|method|isConnectedToNN (InetSocketAddress addr)
specifier|public
name|boolean
name|isConnectedToNN
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|)
block|{
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|getAllBpOs
argument_list|()
control|)
block|{
for|for
control|(
name|BPServiceActor
name|bpsa
range|:
name|bpos
operator|.
name|getBPServiceActors
argument_list|()
control|)
block|{
if|if
condition|(
name|addr
operator|.
name|equals
argument_list|(
name|bpsa
operator|.
name|getNNSocketAddress
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|bpsa
operator|.
name|isAlive
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @param bpid block pool Id    * @return true - if BPOfferService thread is alive    */
DECL|method|isBPServiceAlive (String bpid)
specifier|public
name|boolean
name|isBPServiceAlive
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|BPOfferService
name|bp
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
return|return
name|bp
operator|!=
literal|null
condition|?
name|bp
operator|.
name|isAlive
argument_list|()
else|:
literal|false
return|;
block|}
comment|/**    * A datanode is considered to be fully started if all the BP threads are    * alive and all the block pools are initialized.    *     * @return true - if the data node is fully started    */
DECL|method|isDatanodeFullyStarted ()
specifier|public
name|boolean
name|isDatanodeFullyStarted
parameter_list|()
block|{
for|for
control|(
name|BPOfferService
name|bp
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|bp
operator|.
name|isInitialized
argument_list|()
operator|||
operator|!
name|bp
operator|.
name|isAlive
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getDatanodeId ()
specifier|public
name|DatanodeID
name|getDatanodeId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|clearAllBlockSecretKeys ()
specifier|public
name|void
name|clearAllBlockSecretKeys
parameter_list|()
block|{
name|blockPoolTokenSecretManager
operator|.
name|clearAllKeysForTesting
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get current value of the max balancer bandwidth in bytes per second.    *    * @return bandwidth Blanacer bandwidth in bytes per second for this datanode.    */
DECL|method|getBalancerBandwidth ()
specifier|public
name|Long
name|getBalancerBandwidth
parameter_list|()
block|{
name|DataXceiverServer
name|dxcs
init|=
operator|(
name|DataXceiverServer
operator|)
name|this
operator|.
name|dataXceiverServer
operator|.
name|getRunnable
argument_list|()
decl_stmt|;
return|return
name|dxcs
operator|.
name|balanceThrottler
operator|.
name|getBandwidth
argument_list|()
return|;
block|}
DECL|method|getDnConf ()
specifier|public
name|DNConf
name|getDnConf
parameter_list|()
block|{
return|return
name|dnConf
return|;
block|}
DECL|method|shouldRun ()
name|boolean
name|shouldRun
parameter_list|()
block|{
return|return
name|shouldRun
return|;
block|}
block|}
end_class

end_unit

