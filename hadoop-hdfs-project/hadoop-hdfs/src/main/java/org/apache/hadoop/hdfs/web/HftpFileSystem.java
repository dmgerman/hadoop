begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.web
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|DelegationTokenRenewer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|MD5MD5CRC32FileChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|JspHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|tools
operator|.
name|DelegationTokenFetcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ServletUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|Attributes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|XMLReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|helpers
operator|.
name|DefaultHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|helpers
operator|.
name|XMLReaderFactory
import|;
end_import

begin_comment
comment|/**  * An implementation of a protocol for accessing filesystems over HTTP.  * The following implementation provides a limited, read-only interface  * to a filesystem over HTTP.  * @see org.apache.hadoop.hdfs.server.namenode.ListPathsServlet  * @see org.apache.hadoop.hdfs.server.namenode.FileDataServlet  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|HftpFileSystem
specifier|public
class|class
name|HftpFileSystem
extends|extends
name|FileSystem
implements|implements
name|DelegationTokenRenewer
operator|.
name|Renewable
implements|,
name|TokenAspect
operator|.
name|TokenManagementDelegator
block|{
DECL|field|SCHEME
specifier|public
specifier|static
specifier|final
name|String
name|SCHEME
init|=
literal|"hftp"
decl_stmt|;
static|static
block|{
name|HttpURLConnection
operator|.
name|setFollowRedirects
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|field|connectionFactory
name|URLConnectionFactory
name|connectionFactory
decl_stmt|;
DECL|field|TOKEN_KIND
specifier|public
specifier|static
specifier|final
name|Text
name|TOKEN_KIND
init|=
operator|new
name|Text
argument_list|(
literal|"HFTP delegation"
argument_list|)
decl_stmt|;
DECL|field|ugi
specifier|protected
name|UserGroupInformation
name|ugi
decl_stmt|;
DECL|field|hftpURI
specifier|private
name|URI
name|hftpURI
decl_stmt|;
DECL|field|nnUri
specifier|protected
name|URI
name|nnUri
decl_stmt|;
DECL|field|HFTP_TIMEZONE
specifier|public
specifier|static
specifier|final
name|String
name|HFTP_TIMEZONE
init|=
literal|"UTC"
decl_stmt|;
DECL|field|HFTP_DATE_FORMAT
specifier|public
specifier|static
specifier|final
name|String
name|HFTP_DATE_FORMAT
init|=
literal|"yyyy-MM-dd'T'HH:mm:ssZ"
decl_stmt|;
DECL|field|tokenAspect
specifier|protected
name|TokenAspect
argument_list|<
name|HftpFileSystem
argument_list|>
name|tokenAspect
decl_stmt|;
DECL|field|delegationToken
specifier|private
name|Token
argument_list|<
name|?
argument_list|>
name|delegationToken
decl_stmt|;
DECL|field|renewToken
specifier|private
name|Token
argument_list|<
name|?
argument_list|>
name|renewToken
decl_stmt|;
annotation|@
name|Override
DECL|method|getCanonicalUri ()
specifier|public
name|URI
name|getCanonicalUri
parameter_list|()
block|{
return|return
name|super
operator|.
name|getCanonicalUri
argument_list|()
return|;
block|}
DECL|method|getDateFormat ()
specifier|public
specifier|static
specifier|final
name|SimpleDateFormat
name|getDateFormat
parameter_list|()
block|{
specifier|final
name|SimpleDateFormat
name|df
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|HFTP_DATE_FORMAT
argument_list|)
decl_stmt|;
name|df
operator|.
name|setTimeZone
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|HFTP_TIMEZONE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|df
return|;
block|}
DECL|field|df
specifier|protected
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|SimpleDateFormat
argument_list|>
name|df
init|=
operator|new
name|ThreadLocal
argument_list|<
name|SimpleDateFormat
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|SimpleDateFormat
name|initialValue
parameter_list|()
block|{
return|return
name|getDateFormat
argument_list|()
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|Override
DECL|method|getDefaultPort ()
specifier|protected
name|int
name|getDefaultPort
parameter_list|()
block|{
return|return
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HTTP_PORT_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HTTP_PORT_DEFAULT
argument_list|)
return|;
block|}
comment|/**    *  We generate the address with one of the following ports, in    *  order of preference.    *  1. Port from the hftp URI e.g. hftp://namenode:4000/ will return 4000.    *  2. Port configured via DFS_NAMENODE_HTTP_PORT_KEY    *  3. DFS_NAMENODE_HTTP_PORT_DEFAULT i.e. 50070.    *    * @param uri    * @return    */
DECL|method|getNamenodeAddr (URI uri)
specifier|protected
name|InetSocketAddress
name|getNamenodeAddr
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
comment|// use authority so user supplied uri can override port
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|uri
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|getDefaultPort
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getNamenodeUri (URI uri)
specifier|protected
name|URI
name|getNamenodeUri
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
return|return
name|DFSUtil
operator|.
name|createUri
argument_list|(
name|getUnderlyingProtocol
argument_list|()
argument_list|,
name|getNamenodeAddr
argument_list|(
name|uri
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * See the documentation of {@Link #getNamenodeAddr(URI)} for the logic    * behind selecting the canonical service name.    * @return    */
annotation|@
name|Override
DECL|method|getCanonicalServiceName ()
specifier|public
name|String
name|getCanonicalServiceName
parameter_list|()
block|{
return|return
name|SecurityUtil
operator|.
name|buildTokenService
argument_list|(
name|nnUri
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|canonicalizeUri (URI uri)
specifier|protected
name|URI
name|canonicalizeUri
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|getCanonicalUri
argument_list|(
name|uri
argument_list|,
name|getDefaultPort
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return the protocol scheme for the FileSystem.    *<p/>    *    * @return<code>hftp</code>    */
annotation|@
name|Override
DECL|method|getScheme ()
specifier|public
name|String
name|getScheme
parameter_list|()
block|{
return|return
name|SCHEME
return|;
block|}
comment|/**    * Initialize connectionFactory and tokenAspect. This function is intended to    * be overridden by HsFtpFileSystem.    */
DECL|method|initTokenAspect (Configuration conf)
specifier|protected
name|void
name|initTokenAspect
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|tokenAspect
operator|=
operator|new
name|TokenAspect
argument_list|<
name|HftpFileSystem
argument_list|>
argument_list|(
name|this
argument_list|,
name|TOKEN_KIND
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|initialize (final URI name, final Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
specifier|final
name|URI
name|name
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|initialize
argument_list|(
name|name
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectionFactory
operator|=
name|URLConnectionFactory
operator|.
name|newDefaultURLConnectionFactory
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
name|this
operator|.
name|nnUri
operator|=
name|getNamenodeUri
argument_list|(
name|name
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|hftpURI
operator|=
operator|new
name|URI
argument_list|(
name|name
operator|.
name|getScheme
argument_list|()
argument_list|,
name|name
operator|.
name|getAuthority
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|initTokenAspect
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|tokenAspect
operator|.
name|initDelegationToken
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getRenewToken ()
specifier|public
name|Token
argument_list|<
name|?
argument_list|>
name|getRenewToken
parameter_list|()
block|{
return|return
name|renewToken
return|;
block|}
comment|/**    * Return the underlying protocol that is used to talk to the namenode.    */
DECL|method|getUnderlyingProtocol ()
specifier|protected
name|String
name|getUnderlyingProtocol
parameter_list|()
block|{
return|return
literal|"http"
return|;
block|}
annotation|@
name|Override
DECL|method|setDelegationToken (Token<T> token)
specifier|public
specifier|synchronized
parameter_list|<
name|T
extends|extends
name|TokenIdentifier
parameter_list|>
name|void
name|setDelegationToken
parameter_list|(
name|Token
argument_list|<
name|T
argument_list|>
name|token
parameter_list|)
block|{
comment|/**      * XXX The kind of the token has been changed by DelegationTokenFetcher. We      * use the token for renewal, since the reflection utilities needs the value      * of the kind field to correctly renew the token.      *      * For other operations, however, the client has to send a      * HDFS_DELEGATION_KIND token over the wire so that it can talk to Hadoop      * 0.20.203 clusters. Later releases fix this problem. See HDFS-5440 for      * more details.      */
name|renewToken
operator|=
name|token
expr_stmt|;
name|delegationToken
operator|=
operator|new
name|Token
argument_list|<
name|T
argument_list|>
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|delegationToken
operator|.
name|setKind
argument_list|(
name|DelegationTokenIdentifier
operator|.
name|HDFS_DELEGATION_KIND
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDelegationToken (final String renewer)
specifier|public
specifier|synchronized
name|Token
argument_list|<
name|?
argument_list|>
name|getDelegationToken
parameter_list|(
specifier|final
name|String
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// Renew TGT if needed
name|UserGroupInformation
name|connectUgi
init|=
name|ugi
operator|.
name|getRealUser
argument_list|()
decl_stmt|;
specifier|final
name|String
name|proxyUser
init|=
name|connectUgi
operator|==
literal|null
condition|?
literal|null
else|:
name|ugi
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
if|if
condition|(
name|connectUgi
operator|==
literal|null
condition|)
block|{
name|connectUgi
operator|=
name|ugi
expr_stmt|;
block|}
return|return
name|connectUgi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Token
argument_list|<
name|?
argument_list|>
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|Credentials
name|c
decl_stmt|;
try|try
block|{
name|c
operator|=
name|DelegationTokenFetcher
operator|.
name|getDTfromRemote
argument_list|(
name|connectionFactory
argument_list|,
name|nnUri
argument_list|,
name|renewer
argument_list|,
name|proxyUser
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ConnectException
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't connect to "
operator|+
name|nnUri
operator|+
literal|", assuming security is disabled"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception getting delegation token"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
for|for
control|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|t
range|:
name|c
operator|.
name|getAllTokens
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got dt for "
operator|+
name|getUri
argument_list|()
operator|+
literal|";t.service="
operator|+
name|t
operator|.
name|getService
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
block|)
empty_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
end_class

begin_function
annotation|@
name|Override
DECL|method|getUri ()
specifier|public
name|URI
name|getUri
parameter_list|()
block|{
return|return
name|hftpURI
return|;
block|}
end_function

begin_comment
comment|/**    * Return a URL pointing to given path on the namenode.    *    * @param path to obtain the URL for    * @param query string to append to the path    * @return namenode URL referring to the given path    * @throws IOException on error constructing the URL    */
end_comment

begin_function
DECL|method|getNamenodeURL (String path, String query)
specifier|protected
name|URL
name|getNamenodeURL
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|query
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|URL
name|url
init|=
operator|new
name|URL
argument_list|(
name|getUnderlyingProtocol
argument_list|()
argument_list|,
name|nnUri
operator|.
name|getHost
argument_list|()
argument_list|,
name|nnUri
operator|.
name|getPort
argument_list|()
argument_list|,
name|path
operator|+
literal|'?'
operator|+
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"url="
operator|+
name|url
argument_list|)
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
end_function

begin_comment
comment|/**    * Get encoded UGI parameter string for a URL.    *    * @return user_shortname,group1,group2...    */
end_comment

begin_function
DECL|method|getEncodedUgiParameter ()
specifier|private
name|String
name|getEncodedUgiParameter
parameter_list|()
block|{
name|StringBuilder
name|ugiParameter
init|=
operator|new
name|StringBuilder
argument_list|(
name|ServletUtil
operator|.
name|encodeQueryValue
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|g
range|:
name|ugi
operator|.
name|getGroupNames
argument_list|()
control|)
block|{
name|ugiParameter
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|ugiParameter
operator|.
name|append
argument_list|(
name|ServletUtil
operator|.
name|encodeQueryValue
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ugiParameter
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Open an HTTP connection to the namenode to read file data and metadata.    * @param path The path component of the URL    * @param query The query component of the URL    */
end_comment

begin_function
DECL|method|openConnection (String path, String query)
specifier|protected
name|HttpURLConnection
name|openConnection
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|query
parameter_list|)
throws|throws
name|IOException
block|{
name|query
operator|=
name|addDelegationTokenParam
argument_list|(
name|query
argument_list|)
expr_stmt|;
specifier|final
name|URL
name|url
init|=
name|getNamenodeURL
argument_list|(
name|path
argument_list|,
name|query
argument_list|)
decl_stmt|;
specifier|final
name|HttpURLConnection
name|connection
decl_stmt|;
name|connection
operator|=
operator|(
name|HttpURLConnection
operator|)
name|connectionFactory
operator|.
name|openConnection
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setRequestMethod
argument_list|(
literal|"GET"
argument_list|)
expr_stmt|;
name|connection
operator|.
name|connect
argument_list|()
expr_stmt|;
return|return
name|connection
return|;
block|}
end_function

begin_function
DECL|method|addDelegationTokenParam (String query)
specifier|protected
name|String
name|addDelegationTokenParam
parameter_list|(
name|String
name|query
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|tokenString
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|tokenAspect
operator|.
name|ensureTokenInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|delegationToken
operator|!=
literal|null
condition|)
block|{
name|tokenString
operator|=
name|delegationToken
operator|.
name|encodeToUrlString
argument_list|()
expr_stmt|;
return|return
operator|(
name|query
operator|+
name|JspHelper
operator|.
name|getDelegationTokenUrlParam
argument_list|(
name|tokenString
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
name|query
return|;
block|}
end_function

begin_class
DECL|class|RangeHeaderUrlOpener
specifier|static
class|class
name|RangeHeaderUrlOpener
extends|extends
name|ByteRangeInputStream
operator|.
name|URLOpener
block|{
DECL|field|connectionFactory
name|URLConnectionFactory
name|connectionFactory
init|=
name|URLConnectionFactory
operator|.
name|DEFAULT_SYSTEM_CONNECTION_FACTORY
decl_stmt|;
DECL|method|RangeHeaderUrlOpener (final URL url)
name|RangeHeaderUrlOpener
parameter_list|(
specifier|final
name|URL
name|url
parameter_list|)
block|{
name|super
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
DECL|method|openConnection ()
specifier|protected
name|HttpURLConnection
name|openConnection
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|HttpURLConnection
operator|)
name|connectionFactory
operator|.
name|openConnection
argument_list|(
name|url
argument_list|)
return|;
block|}
comment|/** Use HTTP Range header for specifying offset. */
annotation|@
name|Override
DECL|method|connect (final long offset, final boolean resolved)
specifier|protected
name|HttpURLConnection
name|connect
parameter_list|(
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|boolean
name|resolved
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|HttpURLConnection
name|conn
init|=
name|openConnection
argument_list|()
decl_stmt|;
name|conn
operator|.
name|setRequestMethod
argument_list|(
literal|"GET"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0L
condition|)
block|{
name|conn
operator|.
name|setRequestProperty
argument_list|(
literal|"Range"
argument_list|,
literal|"bytes="
operator|+
name|offset
operator|+
literal|"-"
argument_list|)
expr_stmt|;
block|}
name|conn
operator|.
name|connect
argument_list|()
expr_stmt|;
comment|//Expects HTTP_OK or HTTP_PARTIAL response codes.
specifier|final
name|int
name|code
init|=
name|conn
operator|.
name|getResponseCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0L
operator|&&
name|code
operator|!=
name|HttpURLConnection
operator|.
name|HTTP_PARTIAL
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"HTTP_PARTIAL expected, received "
operator|+
name|code
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|0L
operator|&&
name|code
operator|!=
name|HttpURLConnection
operator|.
name|HTTP_OK
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"HTTP_OK expected, received "
operator|+
name|code
argument_list|)
throw|;
block|}
return|return
name|conn
return|;
block|}
block|}
end_class

begin_class
DECL|class|RangeHeaderInputStream
specifier|static
class|class
name|RangeHeaderInputStream
extends|extends
name|ByteRangeInputStream
block|{
DECL|method|RangeHeaderInputStream (RangeHeaderUrlOpener o, RangeHeaderUrlOpener r)
name|RangeHeaderInputStream
parameter_list|(
name|RangeHeaderUrlOpener
name|o
parameter_list|,
name|RangeHeaderUrlOpener
name|r
parameter_list|)
block|{
name|super
argument_list|(
name|o
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
DECL|method|RangeHeaderInputStream (final URL url)
name|RangeHeaderInputStream
parameter_list|(
specifier|final
name|URL
name|url
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|RangeHeaderUrlOpener
argument_list|(
name|url
argument_list|)
argument_list|,
operator|new
name|RangeHeaderUrlOpener
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getResolvedUrl (final HttpURLConnection connection)
specifier|protected
name|URL
name|getResolvedUrl
parameter_list|(
specifier|final
name|HttpURLConnection
name|connection
parameter_list|)
block|{
return|return
name|connection
operator|.
name|getURL
argument_list|()
return|;
block|}
block|}
end_class

begin_function
annotation|@
name|Override
DECL|method|open (Path f, int buffersize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|buffersize
parameter_list|)
throws|throws
name|IOException
block|{
name|f
operator|=
name|f
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|getWorkingDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|path
init|=
literal|"/data"
operator|+
name|ServletUtil
operator|.
name|encodePath
argument_list|(
name|f
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|query
init|=
name|addDelegationTokenParam
argument_list|(
literal|"ugi="
operator|+
name|getEncodedUgiParameter
argument_list|()
argument_list|)
decl_stmt|;
name|URL
name|u
init|=
name|getNamenodeURL
argument_list|(
name|path
argument_list|,
name|query
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSDataInputStream
argument_list|(
operator|new
name|RangeHeaderInputStream
argument_list|(
name|u
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
name|tokenAspect
operator|.
name|removeRenewAction
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Class to parse and store a listing reply from the server. */
end_comment

begin_class
DECL|class|LsParser
class|class
name|LsParser
extends|extends
name|DefaultHandler
block|{
DECL|field|fslist
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|fslist
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|startElement (String ns, String localname, String qname, Attributes attrs)
specifier|public
name|void
name|startElement
parameter_list|(
name|String
name|ns
parameter_list|,
name|String
name|localname
parameter_list|,
name|String
name|qname
parameter_list|,
name|Attributes
name|attrs
parameter_list|)
throws|throws
name|SAXException
block|{
if|if
condition|(
literal|"listing"
operator|.
name|equals
argument_list|(
name|qname
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|qname
argument_list|)
operator|&&
operator|!
literal|"directory"
operator|.
name|equals
argument_list|(
name|qname
argument_list|)
condition|)
block|{
if|if
condition|(
name|RemoteException
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|.
name|equals
argument_list|(
name|qname
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
name|RemoteException
operator|.
name|valueOf
argument_list|(
name|attrs
argument_list|)
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|SAXException
argument_list|(
literal|"Unrecognized entry: "
operator|+
name|qname
argument_list|)
throw|;
block|}
name|long
name|modif
decl_stmt|;
name|long
name|atime
init|=
literal|0
decl_stmt|;
try|try
block|{
specifier|final
name|SimpleDateFormat
name|ldf
init|=
name|df
operator|.
name|get
argument_list|()
decl_stmt|;
name|modif
operator|=
name|ldf
operator|.
name|parse
argument_list|(
name|attrs
operator|.
name|getValue
argument_list|(
literal|"modified"
argument_list|)
argument_list|)
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|String
name|astr
init|=
name|attrs
operator|.
name|getValue
argument_list|(
literal|"accesstime"
argument_list|)
decl_stmt|;
if|if
condition|(
name|astr
operator|!=
literal|null
condition|)
block|{
name|atime
operator|=
name|ldf
operator|.
name|parse
argument_list|(
name|astr
argument_list|)
operator|.
name|getTime
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|FileStatus
name|fs
init|=
literal|"file"
operator|.
name|equals
argument_list|(
name|qname
argument_list|)
condition|?
operator|new
name|FileStatus
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|attrs
operator|.
name|getValue
argument_list|(
literal|"size"
argument_list|)
argument_list|)
operator|.
name|longValue
argument_list|()
argument_list|,
literal|false
argument_list|,
name|Short
operator|.
name|valueOf
argument_list|(
name|attrs
operator|.
name|getValue
argument_list|(
literal|"replication"
argument_list|)
argument_list|)
operator|.
name|shortValue
argument_list|()
argument_list|,
name|Long
operator|.
name|valueOf
argument_list|(
name|attrs
operator|.
name|getValue
argument_list|(
literal|"blocksize"
argument_list|)
argument_list|)
operator|.
name|longValue
argument_list|()
argument_list|,
name|modif
argument_list|,
name|atime
argument_list|,
name|FsPermission
operator|.
name|valueOf
argument_list|(
name|attrs
operator|.
name|getValue
argument_list|(
literal|"permission"
argument_list|)
argument_list|)
argument_list|,
name|attrs
operator|.
name|getValue
argument_list|(
literal|"owner"
argument_list|)
argument_list|,
name|attrs
operator|.
name|getValue
argument_list|(
literal|"group"
argument_list|)
argument_list|,
name|HftpFileSystem
operator|.
name|this
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|getUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|attrs
operator|.
name|getValue
argument_list|(
literal|"path"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
else|:
operator|new
name|FileStatus
argument_list|(
literal|0L
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
literal|0L
argument_list|,
name|modif
argument_list|,
name|atime
argument_list|,
name|FsPermission
operator|.
name|valueOf
argument_list|(
name|attrs
operator|.
name|getValue
argument_list|(
literal|"permission"
argument_list|)
argument_list|)
argument_list|,
name|attrs
operator|.
name|getValue
argument_list|(
literal|"owner"
argument_list|)
argument_list|,
name|attrs
operator|.
name|getValue
argument_list|(
literal|"group"
argument_list|)
argument_list|,
name|HftpFileSystem
operator|.
name|this
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|getUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|attrs
operator|.
name|getValue
argument_list|(
literal|"path"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|fslist
operator|.
name|add
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchList (String path, boolean recur)
specifier|private
name|void
name|fetchList
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|recur
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|XMLReader
name|xr
init|=
name|XMLReaderFactory
operator|.
name|createXMLReader
argument_list|()
decl_stmt|;
name|xr
operator|.
name|setContentHandler
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|HttpURLConnection
name|connection
init|=
name|openConnection
argument_list|(
literal|"/listPaths"
operator|+
name|ServletUtil
operator|.
name|encodePath
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"ugi="
operator|+
name|getEncodedUgiParameter
argument_list|()
operator|+
operator|(
name|recur
condition|?
literal|"&recursive=yes"
else|:
literal|""
operator|)
argument_list|)
decl_stmt|;
name|InputStream
name|resp
init|=
name|connection
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
name|xr
operator|.
name|parse
argument_list|(
operator|new
name|InputSource
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
specifier|final
name|Exception
name|embedded
init|=
name|e
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|embedded
operator|!=
literal|null
operator|&&
name|embedded
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|embedded
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"invalid xml directory content"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|getFileStatus (Path f)
specifier|public
name|FileStatus
name|getFileStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|fetchList
argument_list|(
name|f
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|fslist
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|f
argument_list|)
throw|;
block|}
return|return
name|fslist
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
DECL|method|listStatus (Path f, boolean recur)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|recur
parameter_list|)
throws|throws
name|IOException
block|{
name|fetchList
argument_list|(
name|f
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|recur
argument_list|)
expr_stmt|;
if|if
condition|(
name|fslist
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|(
name|fslist
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
name|fslist
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|isDirectory
argument_list|()
operator|)
condition|)
block|{
name|fslist
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|fslist
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
literal|0
index|]
argument_list|)
return|;
block|}
DECL|method|listStatus (Path f)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listStatus
argument_list|(
name|f
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
end_class

begin_function
annotation|@
name|Override
DECL|method|listStatus (Path f)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|LsParser
name|lsparser
init|=
operator|new
name|LsParser
argument_list|()
decl_stmt|;
return|return
name|lsparser
operator|.
name|listStatus
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|getFileStatus (Path f)
specifier|public
name|FileStatus
name|getFileStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|LsParser
name|lsparser
init|=
operator|new
name|LsParser
argument_list|()
decl_stmt|;
return|return
name|lsparser
operator|.
name|getFileStatus
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|ChecksumParser
specifier|private
class|class
name|ChecksumParser
extends|extends
name|DefaultHandler
block|{
DECL|field|filechecksum
specifier|private
name|FileChecksum
name|filechecksum
decl_stmt|;
annotation|@
name|Override
DECL|method|startElement (String ns, String localname, String qname, Attributes attrs)
specifier|public
name|void
name|startElement
parameter_list|(
name|String
name|ns
parameter_list|,
name|String
name|localname
parameter_list|,
name|String
name|qname
parameter_list|,
name|Attributes
name|attrs
parameter_list|)
throws|throws
name|SAXException
block|{
if|if
condition|(
operator|!
name|MD5MD5CRC32FileChecksum
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|qname
argument_list|)
condition|)
block|{
if|if
condition|(
name|RemoteException
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|.
name|equals
argument_list|(
name|qname
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
name|RemoteException
operator|.
name|valueOf
argument_list|(
name|attrs
argument_list|)
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|SAXException
argument_list|(
literal|"Unrecognized entry: "
operator|+
name|qname
argument_list|)
throw|;
block|}
name|filechecksum
operator|=
name|MD5MD5CRC32FileChecksum
operator|.
name|valueOf
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
DECL|method|getFileChecksum (String f)
specifier|private
name|FileChecksum
name|getFileChecksum
parameter_list|(
name|String
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|HttpURLConnection
name|connection
init|=
name|openConnection
argument_list|(
literal|"/fileChecksum"
operator|+
name|ServletUtil
operator|.
name|encodePath
argument_list|(
name|f
argument_list|)
argument_list|,
literal|"ugi="
operator|+
name|getEncodedUgiParameter
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|XMLReader
name|xr
init|=
name|XMLReaderFactory
operator|.
name|createXMLReader
argument_list|()
decl_stmt|;
name|xr
operator|.
name|setContentHandler
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|xr
operator|.
name|parse
argument_list|(
operator|new
name|InputSource
argument_list|(
name|connection
operator|.
name|getInputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
specifier|final
name|Exception
name|embedded
init|=
name|e
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|embedded
operator|!=
literal|null
operator|&&
name|embedded
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|embedded
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"invalid xml directory content"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|connection
operator|.
name|disconnect
argument_list|()
expr_stmt|;
block|}
return|return
name|filechecksum
return|;
block|}
block|}
end_class

begin_function
annotation|@
name|Override
DECL|method|getFileChecksum (Path f)
specifier|public
name|FileChecksum
name|getFileChecksum
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|s
init|=
name|makeQualified
argument_list|(
name|f
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
return|return
operator|new
name|ChecksumParser
argument_list|()
operator|.
name|getFileChecksum
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|getWorkingDirectory ()
specifier|public
name|Path
name|getWorkingDirectory
parameter_list|()
block|{
return|return
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|setWorkingDirectory (Path f)
specifier|public
name|void
name|setWorkingDirectory
parameter_list|(
name|Path
name|f
parameter_list|)
block|{ }
end_function

begin_comment
comment|/** This optional operation is not yet supported. */
end_comment

begin_function
annotation|@
name|Override
DECL|method|append (Path f, int bufferSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not supported"
argument_list|)
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|create (Path f, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not supported"
argument_list|)
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|rename (Path src, Path dst)
specifier|public
name|boolean
name|rename
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not supported"
argument_list|)
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|delete (Path f, boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not supported"
argument_list|)
throw|;
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|mkdirs (Path f, FsPermission permission)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not supported"
argument_list|)
throw|;
block|}
end_function

begin_comment
comment|/**    * A parser for parsing {@link ContentSummary} xml.    */
end_comment

begin_class
DECL|class|ContentSummaryParser
specifier|private
class|class
name|ContentSummaryParser
extends|extends
name|DefaultHandler
block|{
DECL|field|contentsummary
specifier|private
name|ContentSummary
name|contentsummary
decl_stmt|;
annotation|@
name|Override
DECL|method|startElement (String ns, String localname, String qname, Attributes attrs)
specifier|public
name|void
name|startElement
parameter_list|(
name|String
name|ns
parameter_list|,
name|String
name|localname
parameter_list|,
name|String
name|qname
parameter_list|,
name|Attributes
name|attrs
parameter_list|)
throws|throws
name|SAXException
block|{
if|if
condition|(
operator|!
name|ContentSummary
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|qname
argument_list|)
condition|)
block|{
if|if
condition|(
name|RemoteException
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|.
name|equals
argument_list|(
name|qname
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
name|RemoteException
operator|.
name|valueOf
argument_list|(
name|attrs
argument_list|)
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|SAXException
argument_list|(
literal|"Unrecognized entry: "
operator|+
name|qname
argument_list|)
throw|;
block|}
name|contentsummary
operator|=
name|toContentSummary
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
comment|/**      * Connect to the name node and get content summary.      * @param path The path      * @return The content summary for the path.      * @throws IOException      */
DECL|method|getContentSummary (String path)
specifier|private
name|ContentSummary
name|getContentSummary
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|HttpURLConnection
name|connection
init|=
name|openConnection
argument_list|(
literal|"/contentSummary"
operator|+
name|ServletUtil
operator|.
name|encodePath
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"ugi="
operator|+
name|getEncodedUgiParameter
argument_list|()
argument_list|)
decl_stmt|;
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
name|in
operator|=
name|connection
operator|.
name|getInputStream
argument_list|()
expr_stmt|;
specifier|final
name|XMLReader
name|xr
init|=
name|XMLReaderFactory
operator|.
name|createXMLReader
argument_list|()
decl_stmt|;
name|xr
operator|.
name|setContentHandler
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|xr
operator|.
name|parse
argument_list|(
operator|new
name|InputSource
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|//the server may not support getContentSummary
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|saxe
parameter_list|)
block|{
specifier|final
name|Exception
name|embedded
init|=
name|saxe
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|embedded
operator|!=
literal|null
operator|&&
name|embedded
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|embedded
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid xml format"
argument_list|,
name|saxe
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|connection
operator|.
name|disconnect
argument_list|()
expr_stmt|;
block|}
return|return
name|contentsummary
return|;
block|}
block|}
end_class

begin_comment
comment|/** Return the object represented in the attributes. */
end_comment

begin_function
DECL|method|toContentSummary (Attributes attrs )
specifier|private
specifier|static
name|ContentSummary
name|toContentSummary
parameter_list|(
name|Attributes
name|attrs
parameter_list|)
throws|throws
name|SAXException
block|{
specifier|final
name|String
name|length
init|=
name|attrs
operator|.
name|getValue
argument_list|(
literal|"length"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|fileCount
init|=
name|attrs
operator|.
name|getValue
argument_list|(
literal|"fileCount"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|directoryCount
init|=
name|attrs
operator|.
name|getValue
argument_list|(
literal|"directoryCount"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|quota
init|=
name|attrs
operator|.
name|getValue
argument_list|(
literal|"quota"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|spaceConsumed
init|=
name|attrs
operator|.
name|getValue
argument_list|(
literal|"spaceConsumed"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|spaceQuota
init|=
name|attrs
operator|.
name|getValue
argument_list|(
literal|"spaceQuota"
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|null
operator|||
name|fileCount
operator|==
literal|null
operator|||
name|directoryCount
operator|==
literal|null
operator|||
name|quota
operator|==
literal|null
operator|||
name|spaceConsumed
operator|==
literal|null
operator|||
name|spaceQuota
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
return|return
operator|new
name|ContentSummary
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|length
argument_list|)
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|fileCount
argument_list|)
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|directoryCount
argument_list|)
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|quota
argument_list|)
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|spaceConsumed
argument_list|)
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|spaceQuota
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
literal|"Invalid attributes: length="
operator|+
name|length
operator|+
literal|", fileCount="
operator|+
name|fileCount
operator|+
literal|", directoryCount="
operator|+
name|directoryCount
operator|+
literal|", quota="
operator|+
name|quota
operator|+
literal|", spaceConsumed="
operator|+
name|spaceConsumed
operator|+
literal|", spaceQuota="
operator|+
name|spaceQuota
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
DECL|method|getContentSummary (Path f)
specifier|public
name|ContentSummary
name|getContentSummary
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|s
init|=
name|makeQualified
argument_list|(
name|f
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|ContentSummary
name|cs
init|=
operator|new
name|ContentSummaryParser
argument_list|()
operator|.
name|getContentSummary
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
name|cs
operator|!=
literal|null
condition|?
name|cs
else|:
name|super
operator|.
name|getContentSummary
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|renewDelegationToken (final Token<?> token)
specifier|public
name|long
name|renewDelegationToken
parameter_list|(
specifier|final
name|Token
argument_list|<
name|?
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
comment|// update the kerberos credentials, if they are coming from a keytab
name|UserGroupInformation
name|connectUgi
init|=
name|ugi
operator|.
name|getRealUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|connectUgi
operator|==
literal|null
condition|)
block|{
name|connectUgi
operator|=
name|ugi
expr_stmt|;
block|}
try|try
block|{
return|return
name|connectUgi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Long
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|InetSocketAddress
name|serviceAddr
init|=
name|SecurityUtil
operator|.
name|getTokenServiceAddr
argument_list|(
name|token
argument_list|)
decl_stmt|;
return|return
name|DelegationTokenFetcher
operator|.
name|renewDelegationToken
argument_list|(
name|connectionFactory
argument_list|,
name|DFSUtil
operator|.
name|createUri
argument_list|(
name|getUnderlyingProtocol
argument_list|()
argument_list|,
name|serviceAddr
argument_list|)
argument_list|,
operator|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
operator|)
name|token
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|cancelDelegationToken (final Token<?> token)
specifier|public
name|void
name|cancelDelegationToken
parameter_list|(
specifier|final
name|Token
argument_list|<
name|?
argument_list|>
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|connectUgi
init|=
name|ugi
operator|.
name|getRealUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|connectUgi
operator|==
literal|null
condition|)
block|{
name|connectUgi
operator|=
name|ugi
expr_stmt|;
block|}
try|try
block|{
name|connectUgi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|InetSocketAddress
name|serviceAddr
init|=
name|SecurityUtil
operator|.
name|getTokenServiceAddr
argument_list|(
name|token
argument_list|)
decl_stmt|;
name|DelegationTokenFetcher
operator|.
name|cancelDelegationToken
argument_list|(
name|connectionFactory
argument_list|,
name|DFSUtil
operator|.
name|createUri
argument_list|(
name|getUnderlyingProtocol
argument_list|()
argument_list|,
name|serviceAddr
argument_list|)
argument_list|,
operator|(
name|Token
argument_list|<
name|DelegationTokenIdentifier
argument_list|>
operator|)
name|token
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
end_function

unit|}
end_unit

