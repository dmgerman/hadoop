begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|terminate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|Namesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LightWeightHashSet
import|;
end_import

begin_comment
comment|/**  * Periodically computes new replication work. This consists of two tasks:  *   * 1) Assigning blocks in the neededCacheBlocks to datanodes where they will be  * cached. This moves them to the pendingCacheBlocks list.  *   * 2) Placing caching tasks in pendingCacheBlocks that have timed out  * back into neededCacheBlocks for reassignment.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|}
argument_list|)
DECL|class|CacheReplicationMonitor
class|class
name|CacheReplicationMonitor
implements|implements
name|Runnable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CacheReplicationMonitor
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|blockLog
specifier|private
specifier|static
specifier|final
name|Log
name|blockLog
init|=
name|NameNode
operator|.
name|blockStateChangeLog
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|Namesystem
name|namesystem
decl_stmt|;
DECL|field|blockManager
specifier|private
specifier|final
name|BlockManager
name|blockManager
decl_stmt|;
DECL|field|datanodeManager
specifier|private
specifier|final
name|DatanodeManager
name|datanodeManager
decl_stmt|;
DECL|field|cacheReplManager
specifier|private
specifier|final
name|CacheReplicationManager
name|cacheReplManager
decl_stmt|;
DECL|field|blocksToUncache
specifier|private
specifier|final
name|UncacheBlocks
name|blocksToUncache
decl_stmt|;
DECL|field|neededCacheBlocks
specifier|private
specifier|final
name|LightWeightHashSet
argument_list|<
name|Block
argument_list|>
name|neededCacheBlocks
decl_stmt|;
DECL|field|pendingCacheBlocks
specifier|private
specifier|final
name|PendingReplicationBlocks
name|pendingCacheBlocks
decl_stmt|;
comment|/**    * Re-check period for computing cache replication work    */
DECL|field|cacheReplicationRecheckInterval
specifier|private
specifier|final
name|long
name|cacheReplicationRecheckInterval
decl_stmt|;
DECL|method|CacheReplicationMonitor (Namesystem namesystem, BlockManager blockManager, DatanodeManager datanodeManager, CacheReplicationManager cacheReplManager, UncacheBlocks blocksToUncache, LightWeightHashSet<Block> neededCacheBlocks, PendingReplicationBlocks pendingCacheBlocks, Configuration conf)
specifier|public
name|CacheReplicationMonitor
parameter_list|(
name|Namesystem
name|namesystem
parameter_list|,
name|BlockManager
name|blockManager
parameter_list|,
name|DatanodeManager
name|datanodeManager
parameter_list|,
name|CacheReplicationManager
name|cacheReplManager
parameter_list|,
name|UncacheBlocks
name|blocksToUncache
parameter_list|,
name|LightWeightHashSet
argument_list|<
name|Block
argument_list|>
name|neededCacheBlocks
parameter_list|,
name|PendingReplicationBlocks
name|pendingCacheBlocks
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
name|this
operator|.
name|blockManager
operator|=
name|blockManager
expr_stmt|;
name|this
operator|.
name|datanodeManager
operator|=
name|datanodeManager
expr_stmt|;
name|this
operator|.
name|cacheReplManager
operator|=
name|cacheReplManager
expr_stmt|;
name|this
operator|.
name|blocksToUncache
operator|=
name|blocksToUncache
expr_stmt|;
name|this
operator|.
name|neededCacheBlocks
operator|=
name|neededCacheBlocks
expr_stmt|;
name|this
operator|.
name|pendingCacheBlocks
operator|=
name|pendingCacheBlocks
expr_stmt|;
name|this
operator|.
name|cacheReplicationRecheckInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT
argument_list|)
operator|*
literal|1000L
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"CacheReplicationMonitor is starting"
argument_list|)
expr_stmt|;
while|while
condition|(
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
try|try
block|{
name|computeCachingWork
argument_list|()
expr_stmt|;
name|processPendingCachingWork
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|cacheReplicationRecheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping CacheReplicationMonitor."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|instanceof
name|InterruptedException
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"CacheReplicationMonitor received an exception"
operator|+
literal|" while shutting down."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|LOG
operator|.
name|fatal
argument_list|(
literal|"ReplicationMonitor thread received Runtime exception. "
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Assigns under-cached blocks to new datanodes.    */
DECL|method|computeCachingWork ()
specifier|private
name|void
name|computeCachingWork
parameter_list|()
block|{
name|List
argument_list|<
name|Block
argument_list|>
name|blocksToCache
init|=
literal|null
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|neededCacheBlocks
init|)
block|{
name|blocksToCache
operator|=
name|neededCacheBlocks
operator|.
name|pollAll
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|computeCachingWorkForBlocks
argument_list|(
name|blocksToCache
argument_list|)
expr_stmt|;
name|computeUncacheWork
argument_list|()
expr_stmt|;
block|}
DECL|method|computeCachingWorkForBlocks (List<Block> blocksToCache)
specifier|private
name|void
name|computeCachingWorkForBlocks
parameter_list|(
name|List
argument_list|<
name|Block
argument_list|>
name|blocksToCache
parameter_list|)
block|{
name|int
name|requiredRepl
decl_stmt|,
name|effectiveRepl
decl_stmt|,
name|additionalRepl
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|cachedNodes
decl_stmt|,
name|storedNodes
decl_stmt|,
name|targets
decl_stmt|;
specifier|final
name|HashMap
argument_list|<
name|Block
argument_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|>
name|work
init|=
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|neededCacheBlocks
init|)
block|{
for|for
control|(
name|Block
name|block
range|:
name|blocksToCache
control|)
block|{
comment|// Required number of cached replicas
name|requiredRepl
operator|=
name|cacheReplManager
operator|.
name|getCacheReplication
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// Replicas that are safely cached
name|cachedNodes
operator|=
name|cacheReplManager
operator|.
name|getSafeReplicas
argument_list|(
name|cacheReplManager
operator|.
name|cachedBlocksMap
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|// Replicas that are safely stored on disk
name|storedNodes
operator|=
name|cacheReplManager
operator|.
name|getSafeReplicas
argument_list|(
name|blockManager
operator|.
name|blocksMap
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|// "effective" replication factor which includes pending
comment|// replication work
name|effectiveRepl
operator|=
name|cachedNodes
operator|.
name|size
argument_list|()
operator|+
name|pendingCacheBlocks
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|effectiveRepl
operator|>=
name|requiredRepl
condition|)
block|{
name|neededCacheBlocks
operator|.
name|remove
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* Removing "
operator|+
name|block
operator|+
literal|" from neededCacheBlocks as it has enough cached replicas"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Choose some replicas to cache if needed
name|additionalRepl
operator|=
name|requiredRepl
operator|-
name|effectiveRepl
expr_stmt|;
name|targets
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|(
name|storedNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Only target replicas that aren't already cached.
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|storedNodes
control|)
block|{
if|if
condition|(
operator|!
name|cachedNodes
operator|.
name|contains
argument_list|(
name|dn
argument_list|)
condition|)
block|{
name|targets
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|targets
operator|.
name|size
argument_list|()
operator|<
name|additionalRepl
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block "
operator|+
name|block
operator|+
literal|" cannot be cached on additional"
operator|+
literal|" nodes because there are no more available datanodes"
operator|+
literal|" with the block on disk."
argument_list|)
expr_stmt|;
block|}
block|}
name|targets
operator|=
name|CacheReplicationPolicy
operator|.
name|chooseTargetsToCache
argument_list|(
name|block
argument_list|,
name|targets
argument_list|,
name|additionalRepl
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|.
name|size
argument_list|()
operator|<
name|additionalRepl
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block "
operator|+
name|block
operator|+
literal|" cannot be cached on additional"
operator|+
literal|" nodes because there is not sufficient cache space on"
operator|+
literal|" available target datanodes."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Continue if we couldn't get more cache targets
if|if
condition|(
name|targets
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|// Update datanodes and blocks that were scheduled for caching
name|work
operator|.
name|put
argument_list|(
name|block
argument_list|,
name|targets
argument_list|)
expr_stmt|;
comment|// Schedule caching on the targets
for|for
control|(
name|DatanodeDescriptor
name|target
range|:
name|targets
control|)
block|{
name|target
operator|.
name|addBlockToBeCached
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|// Add block to the pending queue
name|pendingCacheBlocks
operator|.
name|increment
argument_list|(
name|block
argument_list|,
name|targets
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeDescriptor
index|[]
block|{}
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* block "
operator|+
name|block
operator|+
literal|" is moved from neededCacheBlocks to pendingCacheBlocks"
argument_list|)
expr_stmt|;
block|}
comment|// Remove from needed queue if it will be fully replicated
if|if
condition|(
name|effectiveRepl
operator|+
name|targets
operator|.
name|size
argument_list|()
operator|>=
name|requiredRepl
condition|)
block|{
name|neededCacheBlocks
operator|.
name|remove
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
comment|// log which blocks have been scheduled for replication
for|for
control|(
name|Entry
argument_list|<
name|Block
argument_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|>
name|item
range|:
name|work
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Block
name|block
init|=
name|item
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
init|=
name|item
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|StringBuilder
name|targetList
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"datanode(s)"
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|nodes
control|)
block|{
name|targetList
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|targetList
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* ask "
operator|+
name|targetList
operator|+
literal|" to cache "
operator|+
name|block
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blockLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* neededCacheBlocks = "
operator|+
name|neededCacheBlocks
operator|.
name|size
argument_list|()
operator|+
literal|" pendingCacheBlocks = "
operator|+
name|pendingCacheBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Reassign pending caching work that has timed out    */
DECL|method|processPendingCachingWork ()
specifier|private
name|void
name|processPendingCachingWork
parameter_list|()
block|{
name|Block
index|[]
name|timedOutItems
init|=
name|pendingCacheBlocks
operator|.
name|getTimedOutBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|timedOutItems
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|timedOutItems
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Block
name|block
init|=
name|timedOutItems
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|short
name|numCached
init|=
name|cacheReplManager
operator|.
name|getNumCached
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|final
name|short
name|cacheReplication
init|=
name|cacheReplManager
operator|.
name|getCacheReplication
argument_list|(
name|block
argument_list|)
decl_stmt|;
comment|// Needs to be cached if under-replicated
if|if
condition|(
name|numCached
operator|<
name|cacheReplication
condition|)
block|{
synchronized|synchronized
init|(
name|neededCacheBlocks
init|)
block|{
name|neededCacheBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Schedule blocks for uncaching at datanodes    * @return total number of block for deletion    */
DECL|method|computeUncacheWork ()
name|int
name|computeUncacheWork
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|blocksToUncache
operator|.
name|getStorageIDs
argument_list|()
decl_stmt|;
name|int
name|blockCnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|node
range|:
name|nodes
control|)
block|{
name|blockCnt
operator|+=
name|uncachingWorkForOneNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|blockCnt
return|;
block|}
comment|/**    * Gets the list of blocks scheduled for uncaching at a datanode and    * schedules them for uncaching.    *     * @return number of blocks scheduled for removal    */
DECL|method|uncachingWorkForOneNode (String nodeId)
specifier|private
name|int
name|uncachingWorkForOneNode
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Block
argument_list|>
name|toInvalidate
decl_stmt|;
specifier|final
name|DatanodeDescriptor
name|dn
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// get blocks to invalidate for the nodeId
assert|assert
name|nodeId
operator|!=
literal|null
assert|;
name|dn
operator|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|==
literal|null
condition|)
block|{
name|blocksToUncache
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|toInvalidate
operator|=
name|blocksToUncache
operator|.
name|invalidateWork
argument_list|(
name|nodeId
argument_list|,
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|toInvalidate
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* "
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": ask "
operator|+
name|dn
operator|+
literal|" to uncache "
operator|+
name|toInvalidate
argument_list|)
expr_stmt|;
block|}
return|return
name|toInvalidate
operator|.
name|size
argument_list|()
return|;
block|}
block|}
end_class

end_unit

