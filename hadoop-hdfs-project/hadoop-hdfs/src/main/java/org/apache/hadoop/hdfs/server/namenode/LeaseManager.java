begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoContiguous
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * LeaseManager does the lease housekeeping for writing on files.     * This class also provides useful static methods for lease recovery.  *   * Lease Recovery Algorithm  * 1) Namenode retrieves lease information  * 2) For each file f in the lease, consider the last block b of f  * 2.1) Get the datanodes which contains b  * 2.2) Assign one of the datanodes as the primary datanode p   * 2.3) p obtains a new generation stamp from the namenode  * 2.4) p gets the block info from each datanode  * 2.5) p computes the minimum block length  * 2.6) p updates the datanodes, which have a valid generation stamp,  *      with the new generation stamp and the minimum block length   * 2.7) p acknowledges the namenode the update results   * 2.8) Namenode updates the BlockInfo  * 2.9) Namenode removes f from the lease  *      and removes the lease once all files have been removed  * 2.10) Namenode commit changes to edit log  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|LeaseManager
specifier|public
class|class
name|LeaseManager
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|LeaseManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|fsnamesystem
specifier|private
specifier|final
name|FSNamesystem
name|fsnamesystem
decl_stmt|;
DECL|field|softLimit
specifier|private
name|long
name|softLimit
init|=
name|HdfsConstants
operator|.
name|LEASE_SOFTLIMIT_PERIOD
decl_stmt|;
DECL|field|hardLimit
specifier|private
name|long
name|hardLimit
init|=
name|HdfsConstants
operator|.
name|LEASE_HARDLIMIT_PERIOD
decl_stmt|;
comment|//
comment|// Used for handling lock-leases
comment|// Mapping: leaseHolder -> Lease
comment|//
DECL|field|leases
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|leases
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
argument_list|()
decl_stmt|;
comment|// Set of: Lease
DECL|field|sortedLeases
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|Lease
argument_list|>
name|sortedLeases
init|=
operator|new
name|TreeSet
argument_list|<
name|Lease
argument_list|>
argument_list|()
decl_stmt|;
comment|//
comment|// Map path names to leases. It is protected by the sortedLeases lock.
comment|// The map stores pathnames in lexicographical order.
comment|//
DECL|field|sortedLeasesByPath
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|sortedLeasesByPath
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|lmthread
specifier|private
name|Daemon
name|lmthread
decl_stmt|;
DECL|field|shouldRunMonitor
specifier|private
specifier|volatile
name|boolean
name|shouldRunMonitor
decl_stmt|;
DECL|method|LeaseManager (FSNamesystem fsnamesystem)
name|LeaseManager
parameter_list|(
name|FSNamesystem
name|fsnamesystem
parameter_list|)
block|{
name|this
operator|.
name|fsnamesystem
operator|=
name|fsnamesystem
expr_stmt|;
block|}
DECL|method|getLease (String holder)
name|Lease
name|getLease
parameter_list|(
name|String
name|holder
parameter_list|)
block|{
return|return
name|leases
operator|.
name|get
argument_list|(
name|holder
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNumSortedLeases ()
name|int
name|getNumSortedLeases
parameter_list|()
block|{
return|return
name|sortedLeases
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * This method iterates through all the leases and counts the number of blocks    * which are not COMPLETE. The FSNamesystem read lock MUST be held before    * calling this method.    * @return    */
DECL|method|getNumUnderConstructionBlocks ()
specifier|synchronized
name|long
name|getNumUnderConstructionBlocks
parameter_list|()
block|{
assert|assert
name|this
operator|.
name|fsnamesystem
operator|.
name|hasReadLock
argument_list|()
operator|:
literal|"The FSNamesystem read lock wasn't"
operator|+
literal|"acquired before counting under construction blocks"
assert|;
name|long
name|numUCBlocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Lease
name|lease
range|:
name|sortedLeases
control|)
block|{
for|for
control|(
name|String
name|path
range|:
name|lease
operator|.
name|getPaths
argument_list|()
control|)
block|{
specifier|final
name|INodeFile
name|cons
decl_stmt|;
try|try
block|{
name|cons
operator|=
name|this
operator|.
name|fsnamesystem
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|getINode
argument_list|(
name|path
argument_list|)
operator|.
name|asFile
argument_list|()
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|cons
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnresolvedLinkException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Lease files should reside on this FS"
argument_list|)
throw|;
block|}
name|BlockInfoContiguous
index|[]
name|blocks
init|=
name|cons
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|BlockInfoContiguous
name|b
range|:
name|blocks
control|)
block|{
if|if
condition|(
operator|!
name|b
operator|.
name|isComplete
argument_list|()
condition|)
name|numUCBlocks
operator|++
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of blocks under construction: "
operator|+
name|numUCBlocks
argument_list|)
expr_stmt|;
return|return
name|numUCBlocks
return|;
block|}
comment|/** @return the lease containing src */
DECL|method|getLeaseByPath (String src)
specifier|public
name|Lease
name|getLeaseByPath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|sortedLeasesByPath
operator|.
name|get
argument_list|(
name|src
argument_list|)
return|;
block|}
comment|/** @return the number of leases currently in the system */
DECL|method|countLease ()
specifier|public
specifier|synchronized
name|int
name|countLease
parameter_list|()
block|{
return|return
name|sortedLeases
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** @return the number of paths contained in all leases */
DECL|method|countPath ()
specifier|synchronized
name|int
name|countPath
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Lease
name|lease
range|:
name|sortedLeases
control|)
block|{
name|count
operator|+=
name|lease
operator|.
name|getPaths
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Adds (or re-adds) the lease for the specified file.    */
DECL|method|addLease (String holder, String src)
specifier|synchronized
name|Lease
name|addLease
parameter_list|(
name|String
name|holder
parameter_list|,
name|String
name|src
parameter_list|)
block|{
name|Lease
name|lease
init|=
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
if|if
condition|(
name|lease
operator|==
literal|null
condition|)
block|{
name|lease
operator|=
operator|new
name|Lease
argument_list|(
name|holder
argument_list|)
expr_stmt|;
name|leases
operator|.
name|put
argument_list|(
name|holder
argument_list|,
name|lease
argument_list|)
expr_stmt|;
name|sortedLeases
operator|.
name|add
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|renewLease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
name|sortedLeasesByPath
operator|.
name|put
argument_list|(
name|src
argument_list|,
name|lease
argument_list|)
expr_stmt|;
name|lease
operator|.
name|paths
operator|.
name|add
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return
name|lease
return|;
block|}
comment|/**    * Remove the specified lease and src.    */
DECL|method|removeLease (Lease lease, String src)
specifier|synchronized
name|void
name|removeLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|)
block|{
name|sortedLeasesByPath
operator|.
name|remove
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|.
name|removePath
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|src
operator|+
literal|" not found in lease.paths (="
operator|+
name|lease
operator|.
name|paths
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|lease
operator|.
name|hasPath
argument_list|()
condition|)
block|{
name|leases
operator|.
name|remove
argument_list|(
name|lease
operator|.
name|holder
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sortedLeases
operator|.
name|remove
argument_list|(
name|lease
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|lease
operator|+
literal|" not found in sortedLeases"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove the lease for the specified holder and src    */
DECL|method|removeLease (String holder, String src)
specifier|synchronized
name|void
name|removeLease
parameter_list|(
name|String
name|holder
parameter_list|,
name|String
name|src
parameter_list|)
block|{
name|Lease
name|lease
init|=
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|removeLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing non-existent lease! holder="
operator|+
name|holder
operator|+
literal|" src="
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeAllLeases ()
specifier|synchronized
name|void
name|removeAllLeases
parameter_list|()
block|{
name|sortedLeases
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sortedLeasesByPath
operator|.
name|clear
argument_list|()
expr_stmt|;
name|leases
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Reassign lease for file src to the new holder.    */
DECL|method|reassignLease (Lease lease, String src, String newHolder)
specifier|synchronized
name|Lease
name|reassignLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|)
block|{
assert|assert
name|newHolder
operator|!=
literal|null
operator|:
literal|"new lease holder is null"
assert|;
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|removeLease
argument_list|(
name|lease
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
return|return
name|addLease
argument_list|(
name|newHolder
argument_list|,
name|src
argument_list|)
return|;
block|}
comment|/**    * Renew the lease(s) held by the given client    */
DECL|method|renewLease (String holder)
specifier|synchronized
name|void
name|renewLease
parameter_list|(
name|String
name|holder
parameter_list|)
block|{
name|renewLease
argument_list|(
name|getLease
argument_list|(
name|holder
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|renewLease (Lease lease)
specifier|synchronized
name|void
name|renewLease
parameter_list|(
name|Lease
name|lease
parameter_list|)
block|{
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|sortedLeases
operator|.
name|remove
argument_list|(
name|lease
argument_list|)
expr_stmt|;
name|lease
operator|.
name|renew
argument_list|()
expr_stmt|;
name|sortedLeases
operator|.
name|add
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Renew all of the currently open leases.    */
DECL|method|renewAllLeases ()
specifier|synchronized
name|void
name|renewAllLeases
parameter_list|()
block|{
for|for
control|(
name|Lease
name|l
range|:
name|leases
operator|.
name|values
argument_list|()
control|)
block|{
name|renewLease
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
comment|/************************************************************    * A Lease governs all the locks held by a single client.    * For each client there's a corresponding lease, whose    * timestamp is updated when the client periodically    * checks in.  If the client dies and allows its lease to    * expire, all the corresponding locks can be released.    *************************************************************/
DECL|class|Lease
class|class
name|Lease
implements|implements
name|Comparable
argument_list|<
name|Lease
argument_list|>
block|{
DECL|field|holder
specifier|private
specifier|final
name|String
name|holder
decl_stmt|;
DECL|field|lastUpdate
specifier|private
name|long
name|lastUpdate
decl_stmt|;
DECL|field|paths
specifier|private
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|paths
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Only LeaseManager object can create a lease */
DECL|method|Lease (String holder)
specifier|private
name|Lease
parameter_list|(
name|String
name|holder
parameter_list|)
block|{
name|this
operator|.
name|holder
operator|=
name|holder
expr_stmt|;
name|renew
argument_list|()
expr_stmt|;
block|}
comment|/** Only LeaseManager object can renew a lease */
DECL|method|renew ()
specifier|private
name|void
name|renew
parameter_list|()
block|{
name|this
operator|.
name|lastUpdate
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
comment|/** @return true if the Hard Limit Timer has expired */
DECL|method|expiredHardLimit ()
specifier|public
name|boolean
name|expiredHardLimit
parameter_list|()
block|{
return|return
name|monotonicNow
argument_list|()
operator|-
name|lastUpdate
operator|>
name|hardLimit
return|;
block|}
comment|/** @return true if the Soft Limit Timer has expired */
DECL|method|expiredSoftLimit ()
specifier|public
name|boolean
name|expiredSoftLimit
parameter_list|()
block|{
return|return
name|monotonicNow
argument_list|()
operator|-
name|lastUpdate
operator|>
name|softLimit
return|;
block|}
comment|/** Does this lease contain any path? */
DECL|method|hasPath ()
name|boolean
name|hasPath
parameter_list|()
block|{
return|return
operator|!
name|paths
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|removePath (String src)
name|boolean
name|removePath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|paths
operator|.
name|remove
argument_list|(
name|src
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[Lease.  Holder: "
operator|+
name|holder
operator|+
literal|", pendingcreates: "
operator|+
name|paths
operator|.
name|size
argument_list|()
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|compareTo (Lease o)
specifier|public
name|int
name|compareTo
parameter_list|(
name|Lease
name|o
parameter_list|)
block|{
name|Lease
name|l1
init|=
name|this
decl_stmt|;
name|Lease
name|l2
init|=
name|o
decl_stmt|;
name|long
name|lu1
init|=
name|l1
operator|.
name|lastUpdate
decl_stmt|;
name|long
name|lu2
init|=
name|l2
operator|.
name|lastUpdate
decl_stmt|;
if|if
condition|(
name|lu1
operator|<
name|lu2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|lu1
operator|>
name|lu2
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
name|l1
operator|.
name|holder
operator|.
name|compareTo
argument_list|(
name|l2
operator|.
name|holder
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Lease
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Lease
name|obj
init|=
operator|(
name|Lease
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|lastUpdate
operator|==
name|obj
operator|.
name|lastUpdate
operator|&&
name|holder
operator|.
name|equals
argument_list|(
name|obj
operator|.
name|holder
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|holder
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|getPaths ()
name|Collection
argument_list|<
name|String
argument_list|>
name|getPaths
parameter_list|()
block|{
return|return
name|paths
return|;
block|}
DECL|method|getHolder ()
name|String
name|getHolder
parameter_list|()
block|{
return|return
name|holder
return|;
block|}
DECL|method|replacePath (String oldpath, String newpath)
name|void
name|replacePath
parameter_list|(
name|String
name|oldpath
parameter_list|,
name|String
name|newpath
parameter_list|)
block|{
name|paths
operator|.
name|remove
argument_list|(
name|oldpath
argument_list|)
expr_stmt|;
name|paths
operator|.
name|add
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getLastUpdate ()
name|long
name|getLastUpdate
parameter_list|()
block|{
return|return
name|lastUpdate
return|;
block|}
block|}
DECL|method|changeLease (String src, String dst)
specifier|synchronized
name|void
name|changeLease
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".changelease: "
operator|+
literal|" src="
operator|+
name|src
operator|+
literal|", dest="
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|len
init|=
name|src
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|entry
range|:
name|findLeaseWithPrefixPath
argument_list|(
name|src
argument_list|,
name|sortedLeasesByPath
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|oldpath
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|Lease
name|lease
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// replace stem of src with new destination
specifier|final
name|String
name|newpath
init|=
name|dst
operator|+
name|oldpath
operator|.
name|substring
argument_list|(
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"changeLease: replacing "
operator|+
name|oldpath
operator|+
literal|" with "
operator|+
name|newpath
argument_list|)
expr_stmt|;
block|}
name|lease
operator|.
name|replacePath
argument_list|(
name|oldpath
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
name|sortedLeasesByPath
operator|.
name|remove
argument_list|(
name|oldpath
argument_list|)
expr_stmt|;
name|sortedLeasesByPath
operator|.
name|put
argument_list|(
name|newpath
argument_list|,
name|lease
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeLeaseWithPrefixPath (String prefix)
specifier|synchronized
name|void
name|removeLeaseWithPrefixPath
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|entry
range|:
name|findLeaseWithPrefixPath
argument_list|(
name|prefix
argument_list|,
name|sortedLeasesByPath
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|LeaseManager
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".removeLeaseWithPrefixPath: entry="
operator|+
name|entry
argument_list|)
expr_stmt|;
block|}
name|removeLease
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|findLeaseWithPrefixPath ( String prefix, SortedMap<String, Lease> path2lease)
specifier|static
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|findLeaseWithPrefixPath
parameter_list|(
name|String
name|prefix
parameter_list|,
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|path2lease
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|LeaseManager
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".findLease: prefix="
operator|+
name|prefix
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|entries
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|srclen
init|=
name|prefix
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// prefix may ended with '/'
if|if
condition|(
name|prefix
operator|.
name|charAt
argument_list|(
name|srclen
operator|-
literal|1
argument_list|)
operator|==
name|Path
operator|.
name|SEPARATOR_CHAR
condition|)
block|{
name|srclen
operator|-=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|entry
range|:
name|path2lease
operator|.
name|tailMap
argument_list|(
name|prefix
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|p
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
return|return
name|entries
return|;
block|}
if|if
condition|(
name|p
operator|.
name|length
argument_list|()
operator|==
name|srclen
operator|||
name|p
operator|.
name|charAt
argument_list|(
name|srclen
argument_list|)
operator|==
name|Path
operator|.
name|SEPARATOR_CHAR
condition|)
block|{
name|entries
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|entries
return|;
block|}
DECL|method|setLeasePeriod (long softLimit, long hardLimit)
specifier|public
name|void
name|setLeasePeriod
parameter_list|(
name|long
name|softLimit
parameter_list|,
name|long
name|hardLimit
parameter_list|)
block|{
name|this
operator|.
name|softLimit
operator|=
name|softLimit
expr_stmt|;
name|this
operator|.
name|hardLimit
operator|=
name|hardLimit
expr_stmt|;
block|}
comment|/******************************************************    * Monitor checks for leases that have expired,    * and disposes of them.    ******************************************************/
DECL|class|Monitor
class|class
name|Monitor
implements|implements
name|Runnable
block|{
DECL|field|name
specifier|final
name|String
name|name
init|=
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
comment|/** Check leases periodically. */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
init|;
name|shouldRunMonitor
operator|&&
name|fsnamesystem
operator|.
name|isRunning
argument_list|()
condition|;
control|)
block|{
name|boolean
name|needSync
init|=
literal|false
decl_stmt|;
try|try
block|{
name|fsnamesystem
operator|.
name|writeLockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|fsnamesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
name|needSync
operator|=
name|checkLeases
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|fsnamesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// lease reassignments should to be sync'ed.
if|if
condition|(
name|needSync
condition|)
block|{
name|fsnamesystem
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|HdfsServerConstants
operator|.
name|NAMENODE_LEASE_RECHECK_INTERVAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" is interrupted"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Get the list of inodes corresponding to valid leases.    * @return list of inodes    */
DECL|method|getINodesUnderConstruction ()
name|Map
argument_list|<
name|String
argument_list|,
name|INodeFile
argument_list|>
name|getINodesUnderConstruction
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|INodeFile
argument_list|>
name|inodes
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|INodeFile
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|p
range|:
name|sortedLeasesByPath
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// verify that path exists in namespace
try|try
block|{
name|INodeFile
name|node
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|fsnamesystem
operator|.
name|dir
operator|.
name|getINode
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|node
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|inodes
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|inodes
return|;
block|}
comment|/** Check the leases beginning from the oldest.    *  @return true is sync is needed.    */
annotation|@
name|VisibleForTesting
DECL|method|checkLeases ()
specifier|synchronized
name|boolean
name|checkLeases
parameter_list|()
block|{
name|boolean
name|needSync
init|=
literal|false
decl_stmt|;
assert|assert
name|fsnamesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|Lease
name|leaseToCheck
init|=
literal|null
decl_stmt|;
try|try
block|{
name|leaseToCheck
operator|=
name|sortedLeases
operator|.
name|first
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{}
while|while
condition|(
name|leaseToCheck
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|leaseToCheck
operator|.
name|expiredHardLimit
argument_list|()
condition|)
block|{
break|break;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|leaseToCheck
operator|+
literal|" has expired hard limit"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|removing
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// need to create a copy of the oldest lease paths, because
comment|// internalReleaseLease() removes paths corresponding to empty files,
comment|// i.e. it needs to modify the collection being iterated over
comment|// causing ConcurrentModificationException
name|String
index|[]
name|leasePaths
init|=
operator|new
name|String
index|[
name|leaseToCheck
operator|.
name|getPaths
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|leaseToCheck
operator|.
name|getPaths
argument_list|()
operator|.
name|toArray
argument_list|(
name|leasePaths
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|p
range|:
name|leasePaths
control|)
block|{
try|try
block|{
name|INodesInPath
name|iip
init|=
name|fsnamesystem
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|getINodesInPath
argument_list|(
name|p
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|boolean
name|completed
init|=
name|fsnamesystem
operator|.
name|internalReleaseLease
argument_list|(
name|leaseToCheck
argument_list|,
name|p
argument_list|,
name|iip
argument_list|,
name|HdfsServerConstants
operator|.
name|NAMENODE_LEASE_HOLDER
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|completed
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lease recovery for "
operator|+
name|p
operator|+
literal|" is complete. File closed."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Started block recovery "
operator|+
name|p
operator|+
literal|" lease "
operator|+
name|leaseToCheck
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If a lease recovery happened, we need to sync later.
if|if
condition|(
operator|!
name|needSync
operator|&&
operator|!
name|completed
condition|)
block|{
name|needSync
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot release the path "
operator|+
name|p
operator|+
literal|" in the lease "
operator|+
name|leaseToCheck
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|removing
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|p
range|:
name|removing
control|)
block|{
name|removeLease
argument_list|(
name|leaseToCheck
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|leaseToCheck
operator|=
name|sortedLeases
operator|.
name|higher
argument_list|(
name|leaseToCheck
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|leaseToCheck
operator|!=
name|sortedLeases
operator|.
name|first
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to release hard-limit expired lease: "
operator|+
name|sortedLeases
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{}
return|return
name|needSync
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
specifier|synchronized
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"= {"
operator|+
literal|"\n leases="
operator|+
name|leases
operator|+
literal|"\n sortedLeases="
operator|+
name|sortedLeases
operator|+
literal|"\n sortedLeasesByPath="
operator|+
name|sortedLeasesByPath
operator|+
literal|"\n}"
return|;
block|}
DECL|method|startMonitor ()
name|void
name|startMonitor
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lmthread
operator|==
literal|null
argument_list|,
literal|"Lease Monitor already running"
argument_list|)
expr_stmt|;
name|shouldRunMonitor
operator|=
literal|true
expr_stmt|;
name|lmthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|Monitor
argument_list|()
argument_list|)
expr_stmt|;
name|lmthread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|stopMonitor ()
name|void
name|stopMonitor
parameter_list|()
block|{
if|if
condition|(
name|lmthread
operator|!=
literal|null
condition|)
block|{
name|shouldRunMonitor
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|lmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|lmthread
operator|.
name|join
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
name|lmthread
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Trigger the currently-running Lease monitor to re-check    * its leases immediately. This is for use by unit tests.    */
annotation|@
name|VisibleForTesting
DECL|method|triggerMonitorCheckNow ()
name|void
name|triggerMonitorCheckNow
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lmthread
operator|!=
literal|null
argument_list|,
literal|"Lease monitor is not running"
argument_list|)
expr_stmt|;
name|lmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

