begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BatchedRemoteIterator
operator|.
name|BatchedListEntries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|OpenFileEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|OpenFilesIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * LeaseManager does the lease housekeeping for writing on files.     * This class also provides useful static methods for lease recovery.  *   * Lease Recovery Algorithm  * 1) Namenode retrieves lease information  * 2) For each file f in the lease, consider the last block b of f  * 2.1) Get the datanodes which contains b  * 2.2) Assign one of the datanodes as the primary datanode p   * 2.3) p obtains a new generation stamp from the namenode  * 2.4) p gets the block info from each datanode  * 2.5) p computes the minimum block length  * 2.6) p updates the datanodes, which have a valid generation stamp,  *      with the new generation stamp and the minimum block length   * 2.7) p acknowledges the namenode the update results   * 2.8) Namenode updates the BlockInfo  * 2.9) Namenode removes f from the lease  *      and removes the lease once all files have been removed  * 2.10) Namenode commit changes to edit log  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|LeaseManager
specifier|public
class|class
name|LeaseManager
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LeaseManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|fsnamesystem
specifier|private
specifier|final
name|FSNamesystem
name|fsnamesystem
decl_stmt|;
DECL|field|softLimit
specifier|private
name|long
name|softLimit
init|=
name|HdfsConstants
operator|.
name|LEASE_SOFTLIMIT_PERIOD
decl_stmt|;
DECL|field|hardLimit
specifier|private
name|long
name|hardLimit
init|=
name|HdfsConstants
operator|.
name|LEASE_HARDLIMIT_PERIOD
decl_stmt|;
DECL|field|INODE_FILTER_WORKER_COUNT_MAX
specifier|static
specifier|final
name|int
name|INODE_FILTER_WORKER_COUNT_MAX
init|=
literal|4
decl_stmt|;
DECL|field|INODE_FILTER_WORKER_TASK_MIN
specifier|static
specifier|final
name|int
name|INODE_FILTER_WORKER_TASK_MIN
init|=
literal|512
decl_stmt|;
DECL|field|lastHolderUpdateTime
specifier|private
name|long
name|lastHolderUpdateTime
decl_stmt|;
DECL|field|internalLeaseHolder
specifier|private
name|String
name|internalLeaseHolder
decl_stmt|;
comment|// Used for handling lock-leases
comment|// Mapping: leaseHolder -> Lease
DECL|field|leases
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|leases
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Set of: Lease
DECL|field|sortedLeases
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|Lease
argument_list|>
name|sortedLeases
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Lease
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Lease
name|o1
parameter_list|,
name|Lease
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|.
name|getLastUpdate
argument_list|()
operator|!=
name|o2
operator|.
name|getLastUpdate
argument_list|()
condition|)
block|{
return|return
name|Long
operator|.
name|signum
argument_list|(
name|o1
operator|.
name|getLastUpdate
argument_list|()
operator|-
name|o2
operator|.
name|getLastUpdate
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|o1
operator|.
name|holder
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|holder
argument_list|)
return|;
block|}
block|}
block|}
argument_list|)
decl_stmt|;
comment|// INodeID -> Lease
DECL|field|leasesById
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Lease
argument_list|>
name|leasesById
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|lmthread
specifier|private
name|Daemon
name|lmthread
decl_stmt|;
DECL|field|shouldRunMonitor
specifier|private
specifier|volatile
name|boolean
name|shouldRunMonitor
decl_stmt|;
DECL|method|LeaseManager (FSNamesystem fsnamesystem)
name|LeaseManager
parameter_list|(
name|FSNamesystem
name|fsnamesystem
parameter_list|)
block|{
name|this
operator|.
name|fsnamesystem
operator|=
name|fsnamesystem
expr_stmt|;
name|updateInternalLeaseHolder
argument_list|()
expr_stmt|;
block|}
comment|// Update the internal lease holder with the current time stamp.
DECL|method|updateInternalLeaseHolder ()
specifier|private
name|void
name|updateInternalLeaseHolder
parameter_list|()
block|{
name|this
operator|.
name|lastHolderUpdateTime
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
expr_stmt|;
name|this
operator|.
name|internalLeaseHolder
operator|=
name|HdfsServerConstants
operator|.
name|NAMENODE_LEASE_HOLDER
operator|+
literal|"-"
operator|+
name|Time
operator|.
name|formatTime
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Get the current internal lease holder name.
DECL|method|getInternalLeaseHolder ()
name|String
name|getInternalLeaseHolder
parameter_list|()
block|{
name|long
name|elapsed
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|lastHolderUpdateTime
decl_stmt|;
if|if
condition|(
name|elapsed
operator|>
name|hardLimit
condition|)
block|{
name|updateInternalLeaseHolder
argument_list|()
expr_stmt|;
block|}
return|return
name|internalLeaseHolder
return|;
block|}
DECL|method|getLease (String holder)
name|Lease
name|getLease
parameter_list|(
name|String
name|holder
parameter_list|)
block|{
return|return
name|leases
operator|.
name|get
argument_list|(
name|holder
argument_list|)
return|;
block|}
comment|/**    * This method iterates through all the leases and counts the number of blocks    * which are not COMPLETE. The FSNamesystem read lock MUST be held before    * calling this method.    */
DECL|method|getNumUnderConstructionBlocks ()
specifier|synchronized
name|long
name|getNumUnderConstructionBlocks
parameter_list|()
block|{
assert|assert
name|this
operator|.
name|fsnamesystem
operator|.
name|hasReadLock
argument_list|()
operator|:
literal|"The FSNamesystem read lock wasn't"
operator|+
literal|"acquired before counting under construction blocks"
assert|;
name|long
name|numUCBlocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Long
name|id
range|:
name|getINodeIdWithLeases
argument_list|()
control|)
block|{
name|INode
name|inode
init|=
name|fsnamesystem
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|getInode
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
comment|// The inode could have been deleted after getINodeIdWithLeases() is
comment|// called, check here, and ignore it if so
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to find inode {} in getNumUnderConstructionBlocks()."
argument_list|,
name|id
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|final
name|INodeFile
name|cons
init|=
name|inode
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cons
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The file {} is not under construction but has lease."
argument_list|,
name|cons
operator|.
name|getFullPathName
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|BlockInfo
index|[]
name|blocks
init|=
name|cons
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
control|)
block|{
if|if
condition|(
operator|!
name|b
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|numUCBlocks
operator|++
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of blocks under construction: {}"
argument_list|,
name|numUCBlocks
argument_list|)
expr_stmt|;
return|return
name|numUCBlocks
return|;
block|}
DECL|method|getINodeIdWithLeases ()
name|Collection
argument_list|<
name|Long
argument_list|>
name|getINodeIdWithLeases
parameter_list|()
block|{
return|return
name|leasesById
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/**    * Get {@link INodesInPath} for all {@link INode} in the system    * which has a valid lease.    *    * @return Set<INodesInPath>    */
annotation|@
name|VisibleForTesting
DECL|method|getINodeWithLeases ()
name|Set
argument_list|<
name|INodesInPath
argument_list|>
name|getINodeWithLeases
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getINodeWithLeases
argument_list|(
literal|null
argument_list|)
return|;
block|}
DECL|method|getINodesWithLease ()
specifier|private
specifier|synchronized
name|INode
index|[]
name|getINodesWithLease
parameter_list|()
block|{
name|List
argument_list|<
name|INode
argument_list|>
name|inodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|leasesById
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|INode
name|currentINode
decl_stmt|;
for|for
control|(
name|long
name|inodeId
range|:
name|leasesById
operator|.
name|keySet
argument_list|()
control|)
block|{
name|currentINode
operator|=
name|fsnamesystem
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|getInode
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
comment|// A file with an active lease could get deleted, or its
comment|// parent directories could get recursively deleted.
if|if
condition|(
name|currentINode
operator|!=
literal|null
operator|&&
name|currentINode
operator|.
name|isFile
argument_list|()
operator|&&
operator|!
name|fsnamesystem
operator|.
name|isFileDeleted
argument_list|(
name|currentINode
operator|.
name|asFile
argument_list|()
argument_list|)
condition|)
block|{
name|inodes
operator|.
name|add
argument_list|(
name|currentINode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|inodes
operator|.
name|toArray
argument_list|(
operator|new
name|INode
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/**    * Get {@link INodesInPath} for all files under the ancestor directory which    * has valid lease. If the ancestor directory is null, then return all files    * in the system with valid lease. Callers must hold {@link FSNamesystem}    * read or write lock.    *    * @param ancestorDir the ancestor {@link INodeDirectory}    * @return {@code Set<INodesInPath>}    */
DECL|method|getINodeWithLeases (final INodeDirectory ancestorDir)
specifier|public
name|Set
argument_list|<
name|INodesInPath
argument_list|>
name|getINodeWithLeases
parameter_list|(
specifier|final
name|INodeDirectory
name|ancestorDir
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsnamesystem
operator|.
name|hasReadLock
argument_list|()
assert|;
specifier|final
name|long
name|startTimeMs
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|INodesInPath
argument_list|>
name|iipSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|INode
index|[]
name|inodes
init|=
name|getINodesWithLease
argument_list|()
decl_stmt|;
name|int
name|inodeCount
init|=
name|inodes
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|inodeCount
operator|==
literal|0
condition|)
block|{
return|return
name|iipSet
return|;
block|}
name|List
argument_list|<
name|Future
argument_list|<
name|List
argument_list|<
name|INodesInPath
argument_list|>
argument_list|>
argument_list|>
name|futureList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|workerCount
init|=
name|Math
operator|.
name|min
argument_list|(
name|INODE_FILTER_WORKER_COUNT_MAX
argument_list|,
operator|(
operator|(
operator|(
name|inodeCount
operator|-
literal|1
operator|)
operator|/
name|INODE_FILTER_WORKER_TASK_MIN
operator|)
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
name|ExecutorService
name|inodeFilterService
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|workerCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|workerIdx
init|=
literal|0
init|;
name|workerIdx
operator|<
name|workerCount
condition|;
name|workerIdx
operator|++
control|)
block|{
specifier|final
name|int
name|startIdx
init|=
name|workerIdx
decl_stmt|;
name|Callable
argument_list|<
name|List
argument_list|<
name|INodesInPath
argument_list|>
argument_list|>
name|c
init|=
operator|new
name|Callable
argument_list|<
name|List
argument_list|<
name|INodesInPath
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|INodesInPath
argument_list|>
name|call
parameter_list|()
block|{
name|List
argument_list|<
name|INodesInPath
argument_list|>
name|iNodesInPaths
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|startIdx
init|;
name|idx
operator|<
name|inodeCount
condition|;
name|idx
operator|+=
name|workerCount
control|)
block|{
name|INode
name|inode
init|=
name|inodes
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|INodesInPath
name|inodesInPath
init|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|fsnamesystem
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|getRoot
argument_list|()
argument_list|,
name|inode
operator|.
name|asFile
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ancestorDir
operator|!=
literal|null
operator|&&
operator|!
name|inodesInPath
operator|.
name|isDescendant
argument_list|(
name|ancestorDir
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|iNodesInPaths
operator|.
name|add
argument_list|(
name|inodesInPath
argument_list|)
expr_stmt|;
block|}
return|return
name|iNodesInPaths
return|;
block|}
block|}
decl_stmt|;
comment|// Submit the inode filter task to the Executor Service
name|futureList
operator|.
name|add
argument_list|(
name|inodeFilterService
operator|.
name|submit
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inodeFilterService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
for|for
control|(
name|Future
argument_list|<
name|List
argument_list|<
name|INodesInPath
argument_list|>
argument_list|>
name|f
range|:
name|futureList
control|)
block|{
try|try
block|{
name|iipSet
operator|.
name|addAll
argument_list|(
name|f
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to get files with active leases"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|final
name|long
name|endTimeMs
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|endTimeMs
operator|-
name|startTimeMs
operator|)
operator|>
literal|1000
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Took {} ms to collect {} open files with leases {}"
argument_list|,
operator|(
name|endTimeMs
operator|-
name|startTimeMs
operator|)
argument_list|,
name|iipSet
operator|.
name|size
argument_list|()
argument_list|,
operator|(
operator|(
name|ancestorDir
operator|!=
literal|null
operator|)
condition|?
literal|" under "
operator|+
name|ancestorDir
operator|.
name|getFullPathName
argument_list|()
else|:
literal|"."
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|iipSet
return|;
block|}
DECL|method|getUnderConstructionFiles ( final long prevId)
specifier|public
name|BatchedListEntries
argument_list|<
name|OpenFileEntry
argument_list|>
name|getUnderConstructionFiles
parameter_list|(
specifier|final
name|long
name|prevId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getUnderConstructionFiles
argument_list|(
name|prevId
argument_list|,
name|OpenFilesIterator
operator|.
name|FILTER_PATH_DEFAULT
argument_list|)
return|;
block|}
comment|/**    * Get a batch of under construction files from the currently active leases.    * File INodeID is the cursor used to fetch new batch of results and the    * batch size is configurable using below config param. Since the list is    * fetched in batches, it does not represent a consistent view of all    * open files.    *    * @see org.apache.hadoop.hdfs.DFSConfigKeys#DFS_NAMENODE_LIST_OPENFILES_NUM_RESPONSES    * @param prevId the INodeID cursor    * @throws IOException    */
DECL|method|getUnderConstructionFiles ( final long prevId, final String path)
specifier|public
name|BatchedListEntries
argument_list|<
name|OpenFileEntry
argument_list|>
name|getUnderConstructionFiles
parameter_list|(
specifier|final
name|long
name|prevId
parameter_list|,
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsnamesystem
operator|.
name|hasReadLock
argument_list|()
assert|;
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|Lease
argument_list|>
name|remainingLeases
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|remainingLeases
operator|=
name|leasesById
operator|.
name|tailMap
argument_list|(
name|prevId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|Long
argument_list|>
name|inodeIds
init|=
name|remainingLeases
operator|.
name|keySet
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numResponses
init|=
name|Math
operator|.
name|min
argument_list|(
name|this
operator|.
name|fsnamesystem
operator|.
name|getMaxListOpenFilesResponses
argument_list|()
argument_list|,
name|inodeIds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|OpenFileEntry
argument_list|>
name|openFileEntries
init|=
name|Lists
operator|.
name|newArrayListWithExpectedSize
argument_list|(
name|numResponses
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|String
name|fullPathName
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Long
name|inodeId
range|:
name|inodeIds
control|)
block|{
specifier|final
name|INodeFile
name|inodeFile
init|=
name|fsnamesystem
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|getInode
argument_list|(
name|inodeId
argument_list|)
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inodeFile
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The file {} is not under construction but has lease."
argument_list|,
name|inodeFile
operator|.
name|getFullPathName
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fullPathName
operator|=
name|inodeFile
operator|.
name|getFullPathName
argument_list|()
expr_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|path
argument_list|)
operator|||
name|fullPathName
operator|.
name|startsWith
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|openFileEntries
operator|.
name|add
argument_list|(
operator|new
name|OpenFileEntry
argument_list|(
name|inodeFile
operator|.
name|getId
argument_list|()
argument_list|,
name|fullPathName
argument_list|,
name|inodeFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientName
argument_list|()
argument_list|,
name|inodeFile
operator|.
name|getFileUnderConstructionFeature
argument_list|()
operator|.
name|getClientMachine
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>=
name|numResponses
condition|)
block|{
break|break;
block|}
block|}
name|boolean
name|hasMore
init|=
operator|(
name|numResponses
operator|<
name|remainingLeases
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
return|return
operator|new
name|BatchedListEntries
argument_list|<>
argument_list|(
name|openFileEntries
argument_list|,
name|hasMore
argument_list|)
return|;
block|}
comment|/** @return the lease containing src */
DECL|method|getLease (INodeFile src)
specifier|public
specifier|synchronized
name|Lease
name|getLease
parameter_list|(
name|INodeFile
name|src
parameter_list|)
block|{
return|return
name|leasesById
operator|.
name|get
argument_list|(
name|src
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
comment|/** @return the number of leases currently in the system */
annotation|@
name|VisibleForTesting
DECL|method|countLease ()
specifier|public
specifier|synchronized
name|int
name|countLease
parameter_list|()
block|{
return|return
name|sortedLeases
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** @return the number of paths contained in all leases */
DECL|method|countPath ()
specifier|synchronized
name|long
name|countPath
parameter_list|()
block|{
return|return
name|leasesById
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Adds (or re-adds) the lease for the specified file.    */
DECL|method|addLease (String holder, long inodeId)
specifier|synchronized
name|Lease
name|addLease
parameter_list|(
name|String
name|holder
parameter_list|,
name|long
name|inodeId
parameter_list|)
block|{
name|Lease
name|lease
init|=
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
if|if
condition|(
name|lease
operator|==
literal|null
condition|)
block|{
name|lease
operator|=
operator|new
name|Lease
argument_list|(
name|holder
argument_list|)
expr_stmt|;
name|leases
operator|.
name|put
argument_list|(
name|holder
argument_list|,
name|lease
argument_list|)
expr_stmt|;
name|sortedLeases
operator|.
name|add
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|renewLease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
name|leasesById
operator|.
name|put
argument_list|(
name|inodeId
argument_list|,
name|lease
argument_list|)
expr_stmt|;
name|lease
operator|.
name|files
operator|.
name|add
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
return|return
name|lease
return|;
block|}
DECL|method|removeLease (long inodeId)
specifier|synchronized
name|void
name|removeLease
parameter_list|(
name|long
name|inodeId
parameter_list|)
block|{
specifier|final
name|Lease
name|lease
init|=
name|leasesById
operator|.
name|get
argument_list|(
name|inodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|removeLease
argument_list|(
name|lease
argument_list|,
name|inodeId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove the specified lease and src.    */
DECL|method|removeLease (Lease lease, long inodeId)
specifier|private
specifier|synchronized
name|void
name|removeLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|long
name|inodeId
parameter_list|)
block|{
name|leasesById
operator|.
name|remove
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|.
name|removeFile
argument_list|(
name|inodeId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"inode {} not found in lease.files (={})"
argument_list|,
name|inodeId
argument_list|,
name|lease
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lease
operator|.
name|hasFiles
argument_list|()
condition|)
block|{
name|leases
operator|.
name|remove
argument_list|(
name|lease
operator|.
name|holder
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sortedLeases
operator|.
name|remove
argument_list|(
name|lease
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} not found in sortedLeases"
argument_list|,
name|lease
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove the lease for the specified holder and src    */
DECL|method|removeLease (String holder, INodeFile src)
specifier|synchronized
name|void
name|removeLease
parameter_list|(
name|String
name|holder
parameter_list|,
name|INodeFile
name|src
parameter_list|)
block|{
name|Lease
name|lease
init|=
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|removeLease
argument_list|(
name|lease
argument_list|,
name|src
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing non-existent lease! holder={} src={}"
argument_list|,
name|holder
argument_list|,
name|src
operator|.
name|getFullPathName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeAllLeases ()
specifier|synchronized
name|void
name|removeAllLeases
parameter_list|()
block|{
name|sortedLeases
operator|.
name|clear
argument_list|()
expr_stmt|;
name|leasesById
operator|.
name|clear
argument_list|()
expr_stmt|;
name|leases
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Reassign lease for file src to the new holder.    */
DECL|method|reassignLease (Lease lease, INodeFile src, String newHolder)
specifier|synchronized
name|Lease
name|reassignLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|INodeFile
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|)
block|{
assert|assert
name|newHolder
operator|!=
literal|null
operator|:
literal|"new lease holder is null"
assert|;
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|removeLease
argument_list|(
name|lease
argument_list|,
name|src
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|addLease
argument_list|(
name|newHolder
argument_list|,
name|src
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Renew the lease(s) held by the given client    */
DECL|method|renewLease (String holder)
specifier|synchronized
name|void
name|renewLease
parameter_list|(
name|String
name|holder
parameter_list|)
block|{
name|renewLease
argument_list|(
name|getLease
argument_list|(
name|holder
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|renewLease (Lease lease)
specifier|synchronized
name|void
name|renewLease
parameter_list|(
name|Lease
name|lease
parameter_list|)
block|{
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|sortedLeases
operator|.
name|remove
argument_list|(
name|lease
argument_list|)
expr_stmt|;
name|lease
operator|.
name|renew
argument_list|()
expr_stmt|;
name|sortedLeases
operator|.
name|add
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Renew all of the currently open leases.    */
DECL|method|renewAllLeases ()
specifier|synchronized
name|void
name|renewAllLeases
parameter_list|()
block|{
for|for
control|(
name|Lease
name|l
range|:
name|leases
operator|.
name|values
argument_list|()
control|)
block|{
name|renewLease
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
comment|/************************************************************    * A Lease governs all the locks held by a single client.    * For each client there's a corresponding lease, whose    * timestamp is updated when the client periodically    * checks in.  If the client dies and allows its lease to    * expire, all the corresponding locks can be released.    *************************************************************/
DECL|class|Lease
class|class
name|Lease
block|{
DECL|field|holder
specifier|private
specifier|final
name|String
name|holder
decl_stmt|;
DECL|field|lastUpdate
specifier|private
name|long
name|lastUpdate
decl_stmt|;
DECL|field|files
specifier|private
specifier|final
name|HashSet
argument_list|<
name|Long
argument_list|>
name|files
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Only LeaseManager object can create a lease */
DECL|method|Lease (String holder)
specifier|private
name|Lease
parameter_list|(
name|String
name|holder
parameter_list|)
block|{
name|this
operator|.
name|holder
operator|=
name|holder
expr_stmt|;
name|renew
argument_list|()
expr_stmt|;
block|}
comment|/** Only LeaseManager object can renew a lease */
DECL|method|renew ()
specifier|private
name|void
name|renew
parameter_list|()
block|{
name|this
operator|.
name|lastUpdate
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
comment|/** @return true if the Hard Limit Timer has expired */
DECL|method|expiredHardLimit ()
specifier|public
name|boolean
name|expiredHardLimit
parameter_list|()
block|{
return|return
name|monotonicNow
argument_list|()
operator|-
name|lastUpdate
operator|>
name|hardLimit
return|;
block|}
comment|/** @return true if the Soft Limit Timer has expired */
DECL|method|expiredSoftLimit ()
specifier|public
name|boolean
name|expiredSoftLimit
parameter_list|()
block|{
return|return
name|monotonicNow
argument_list|()
operator|-
name|lastUpdate
operator|>
name|softLimit
return|;
block|}
comment|/** Does this lease contain any path? */
DECL|method|hasFiles ()
name|boolean
name|hasFiles
parameter_list|()
block|{
return|return
operator|!
name|files
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|removeFile (long inodeId)
name|boolean
name|removeFile
parameter_list|(
name|long
name|inodeId
parameter_list|)
block|{
return|return
name|files
operator|.
name|remove
argument_list|(
name|inodeId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[Lease.  Holder: "
operator|+
name|holder
operator|+
literal|", pending creates: "
operator|+
name|files
operator|.
name|size
argument_list|()
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|holder
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|getFiles ()
specifier|private
name|Collection
argument_list|<
name|Long
argument_list|>
name|getFiles
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|files
argument_list|)
return|;
block|}
DECL|method|getHolder ()
name|String
name|getHolder
parameter_list|()
block|{
return|return
name|holder
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getLastUpdate ()
name|long
name|getLastUpdate
parameter_list|()
block|{
return|return
name|lastUpdate
return|;
block|}
block|}
DECL|method|setLeasePeriod (long softLimit, long hardLimit)
specifier|public
name|void
name|setLeasePeriod
parameter_list|(
name|long
name|softLimit
parameter_list|,
name|long
name|hardLimit
parameter_list|)
block|{
name|this
operator|.
name|softLimit
operator|=
name|softLimit
expr_stmt|;
name|this
operator|.
name|hardLimit
operator|=
name|hardLimit
expr_stmt|;
block|}
comment|/******************************************************    * Monitor checks for leases that have expired,    * and disposes of them.    ******************************************************/
DECL|class|Monitor
class|class
name|Monitor
implements|implements
name|Runnable
block|{
DECL|field|name
specifier|final
name|String
name|name
init|=
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
comment|/** Check leases periodically. */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
init|;
name|shouldRunMonitor
operator|&&
name|fsnamesystem
operator|.
name|isRunning
argument_list|()
condition|;
control|)
block|{
name|boolean
name|needSync
init|=
literal|false
decl_stmt|;
try|try
block|{
name|fsnamesystem
operator|.
name|writeLockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|fsnamesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
name|needSync
operator|=
name|checkLeases
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|fsnamesystem
operator|.
name|writeUnlock
argument_list|(
literal|"leaseManager"
argument_list|)
expr_stmt|;
comment|// lease reassignments should to be sync'ed.
if|if
condition|(
name|needSync
condition|)
block|{
name|fsnamesystem
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|fsnamesystem
operator|.
name|getLeaseRecheckIntervalMs
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} is interrupted"
argument_list|,
name|name
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected throwable: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Check the leases beginning from the oldest.    *  @return true is sync is needed.    */
annotation|@
name|VisibleForTesting
DECL|method|checkLeases ()
specifier|synchronized
name|boolean
name|checkLeases
parameter_list|()
block|{
name|boolean
name|needSync
init|=
literal|false
decl_stmt|;
assert|assert
name|fsnamesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|long
name|start
init|=
name|monotonicNow
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|sortedLeases
operator|.
name|isEmpty
argument_list|()
operator|&&
name|sortedLeases
operator|.
name|first
argument_list|()
operator|.
name|expiredHardLimit
argument_list|()
operator|&&
operator|!
name|isMaxLockHoldToReleaseLease
argument_list|(
name|start
argument_list|)
condition|)
block|{
name|Lease
name|leaseToCheck
init|=
name|sortedLeases
operator|.
name|first
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} has expired hard limit"
argument_list|,
name|leaseToCheck
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Long
argument_list|>
name|removing
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// need to create a copy of the oldest lease files, because
comment|// internalReleaseLease() removes files corresponding to empty files,
comment|// i.e. it needs to modify the collection being iterated over
comment|// causing ConcurrentModificationException
name|Collection
argument_list|<
name|Long
argument_list|>
name|files
init|=
name|leaseToCheck
operator|.
name|getFiles
argument_list|()
decl_stmt|;
name|Long
index|[]
name|leaseINodeIds
init|=
name|files
operator|.
name|toArray
argument_list|(
operator|new
name|Long
index|[
name|files
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|FSDirectory
name|fsd
init|=
name|fsnamesystem
operator|.
name|getFSDirectory
argument_list|()
decl_stmt|;
name|String
name|p
init|=
literal|null
decl_stmt|;
name|String
name|newHolder
init|=
name|getInternalLeaseHolder
argument_list|()
decl_stmt|;
for|for
control|(
name|Long
name|id
range|:
name|leaseINodeIds
control|)
block|{
try|try
block|{
name|INodesInPath
name|iip
init|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|fsd
operator|.
name|getInode
argument_list|(
name|id
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
comment|// Sanity check to make sure the path is correct
if|if
condition|(
operator|!
name|p
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid path in the lease "
operator|+
name|p
argument_list|)
throw|;
block|}
specifier|final
name|INodeFile
name|lastINode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|fsnamesystem
operator|.
name|isFileDeleted
argument_list|(
name|lastINode
argument_list|)
condition|)
block|{
comment|// INode referred by the lease could have been deleted.
name|removeLease
argument_list|(
name|lastINode
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|boolean
name|completed
init|=
literal|false
decl_stmt|;
try|try
block|{
name|completed
operator|=
name|fsnamesystem
operator|.
name|internalReleaseLease
argument_list|(
name|leaseToCheck
argument_list|,
name|p
argument_list|,
name|iip
argument_list|,
name|newHolder
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot release the path {} in the lease {}. It will be "
operator|+
literal|"retried."
argument_list|,
name|p
argument_list|,
name|leaseToCheck
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|completed
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lease recovery for inode {} is complete. File closed"
operator|+
literal|"."
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Started block recovery {} lease {}"
argument_list|,
name|p
argument_list|,
name|leaseToCheck
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If a lease recovery happened, we need to sync later.
if|if
condition|(
operator|!
name|needSync
operator|&&
operator|!
name|completed
condition|)
block|{
name|needSync
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing lease with an invalid path: {},{}"
argument_list|,
name|p
argument_list|,
name|leaseToCheck
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|removing
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isMaxLockHoldToReleaseLease
argument_list|(
name|start
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Breaking out of checkLeases after {} ms."
argument_list|,
name|fsnamesystem
operator|.
name|getMaxLockHoldToReleaseLeaseMs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|Long
name|id
range|:
name|removing
control|)
block|{
name|removeLease
argument_list|(
name|leaseToCheck
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|needSync
return|;
block|}
comment|/** @return true if max lock hold is reached */
DECL|method|isMaxLockHoldToReleaseLease (long start)
specifier|private
name|boolean
name|isMaxLockHoldToReleaseLease
parameter_list|(
name|long
name|start
parameter_list|)
block|{
return|return
name|monotonicNow
argument_list|()
operator|-
name|start
operator|>
name|fsnamesystem
operator|.
name|getMaxLockHoldToReleaseLeaseMs
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
specifier|synchronized
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"= {"
operator|+
literal|"\n leases="
operator|+
name|leases
operator|+
literal|"\n sortedLeases="
operator|+
name|sortedLeases
operator|+
literal|"\n leasesById="
operator|+
name|leasesById
operator|+
literal|"\n}"
return|;
block|}
DECL|method|startMonitor ()
name|void
name|startMonitor
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lmthread
operator|==
literal|null
argument_list|,
literal|"Lease Monitor already running"
argument_list|)
expr_stmt|;
name|shouldRunMonitor
operator|=
literal|true
expr_stmt|;
name|lmthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|Monitor
argument_list|()
argument_list|)
expr_stmt|;
name|lmthread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|stopMonitor ()
name|void
name|stopMonitor
parameter_list|()
block|{
if|if
condition|(
name|lmthread
operator|!=
literal|null
condition|)
block|{
name|shouldRunMonitor
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|lmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|lmthread
operator|.
name|join
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
name|lmthread
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Trigger the currently-running Lease monitor to re-check    * its leases immediately. This is for use by unit tests.    */
annotation|@
name|VisibleForTesting
DECL|method|triggerMonitorCheckNow ()
specifier|public
name|void
name|triggerMonitorCheckNow
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lmthread
operator|!=
literal|null
argument_list|,
literal|"Lease monitor is not running"
argument_list|)
expr_stmt|;
name|lmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|runLeaseChecks ()
specifier|public
name|void
name|runLeaseChecks
parameter_list|()
block|{
name|checkLeases
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

