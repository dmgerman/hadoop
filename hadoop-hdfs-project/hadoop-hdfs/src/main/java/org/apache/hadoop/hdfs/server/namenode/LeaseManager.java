begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * LeaseManager does the lease housekeeping for writing on files.     * This class also provides useful static methods for lease recovery.  *   * Lease Recovery Algorithm  * 1) Namenode retrieves lease information  * 2) For each file f in the lease, consider the last block b of f  * 2.1) Get the datanodes which contains b  * 2.2) Assign one of the datanodes as the primary datanode p   * 2.3) p obtains a new generation stamp from the namenode  * 2.4) p gets the block info from each datanode  * 2.5) p computes the minimum block length  * 2.6) p updates the datanodes, which have a valid generation stamp,  *      with the new generation stamp and the minimum block length   * 2.7) p acknowledges the namenode the update results   * 2.8) Namenode updates the BlockInfo  * 2.9) Namenode removes f from the lease  *      and removes the lease once all files have been removed  * 2.10) Namenode commit changes to edit log  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|LeaseManager
specifier|public
class|class
name|LeaseManager
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|LeaseManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|fsnamesystem
specifier|private
specifier|final
name|FSNamesystem
name|fsnamesystem
decl_stmt|;
DECL|field|softLimit
specifier|private
name|long
name|softLimit
init|=
name|HdfsServerConstants
operator|.
name|LEASE_SOFTLIMIT_PERIOD
decl_stmt|;
DECL|field|hardLimit
specifier|private
name|long
name|hardLimit
init|=
name|HdfsServerConstants
operator|.
name|LEASE_HARDLIMIT_PERIOD
decl_stmt|;
comment|//
comment|// Used for handling lock-leases
comment|// Mapping: leaseHolder -> Lease
comment|//
DECL|field|leases
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Lease
argument_list|>
name|leases
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Set of: Lease
DECL|field|sortedLeases
specifier|private
specifier|final
name|PriorityQueue
argument_list|<
name|Lease
argument_list|>
name|sortedLeases
init|=
operator|new
name|PriorityQueue
argument_list|<>
argument_list|(
literal|512
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Lease
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Lease
name|o1
parameter_list|,
name|Lease
name|o2
parameter_list|)
block|{
return|return
name|Long
operator|.
name|signum
argument_list|(
name|o1
operator|.
name|getLastUpdate
argument_list|()
operator|-
name|o2
operator|.
name|getLastUpdate
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// INodeID -> Lease
DECL|field|leasesById
specifier|private
specifier|final
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Lease
argument_list|>
name|leasesById
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|lmthread
specifier|private
name|Daemon
name|lmthread
decl_stmt|;
DECL|field|shouldRunMonitor
specifier|private
specifier|volatile
name|boolean
name|shouldRunMonitor
decl_stmt|;
DECL|method|LeaseManager (FSNamesystem fsnamesystem)
name|LeaseManager
parameter_list|(
name|FSNamesystem
name|fsnamesystem
parameter_list|)
block|{
name|this
operator|.
name|fsnamesystem
operator|=
name|fsnamesystem
expr_stmt|;
block|}
DECL|method|getLease (String holder)
name|Lease
name|getLease
parameter_list|(
name|String
name|holder
parameter_list|)
block|{
return|return
name|leases
operator|.
name|get
argument_list|(
name|holder
argument_list|)
return|;
block|}
comment|/**    * This method iterates through all the leases and counts the number of blocks    * which are not COMPLETE. The FSNamesystem read lock MUST be held before    * calling this method.    */
DECL|method|getNumUnderConstructionBlocks ()
specifier|synchronized
name|long
name|getNumUnderConstructionBlocks
parameter_list|()
block|{
assert|assert
name|this
operator|.
name|fsnamesystem
operator|.
name|hasReadLock
argument_list|()
operator|:
literal|"The FSNamesystem read lock wasn't"
operator|+
literal|"acquired before counting under construction blocks"
assert|;
name|long
name|numUCBlocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Long
name|id
range|:
name|getINodeIdWithLeases
argument_list|()
control|)
block|{
specifier|final
name|INodeFile
name|cons
init|=
name|fsnamesystem
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|getInode
argument_list|(
name|id
argument_list|)
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|cons
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfo
index|[]
name|blocks
init|=
name|cons
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
control|)
block|{
if|if
condition|(
operator|!
name|b
operator|.
name|isComplete
argument_list|()
condition|)
name|numUCBlocks
operator|++
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of blocks under construction: "
operator|+
name|numUCBlocks
argument_list|)
expr_stmt|;
return|return
name|numUCBlocks
return|;
block|}
DECL|method|getINodeIdWithLeases ()
name|Collection
argument_list|<
name|Long
argument_list|>
name|getINodeIdWithLeases
parameter_list|()
block|{
return|return
name|leasesById
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/** @return the lease containing src */
DECL|method|getLease (INodeFile src)
specifier|public
specifier|synchronized
name|Lease
name|getLease
parameter_list|(
name|INodeFile
name|src
parameter_list|)
block|{
return|return
name|leasesById
operator|.
name|get
argument_list|(
name|src
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
comment|/** @return the number of leases currently in the system */
annotation|@
name|VisibleForTesting
DECL|method|countLease ()
specifier|public
specifier|synchronized
name|int
name|countLease
parameter_list|()
block|{
return|return
name|sortedLeases
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** @return the number of paths contained in all leases */
DECL|method|countPath ()
specifier|synchronized
name|int
name|countPath
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Lease
name|lease
range|:
name|sortedLeases
control|)
block|{
name|count
operator|+=
name|lease
operator|.
name|getFiles
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Adds (or re-adds) the lease for the specified file.    */
DECL|method|addLease (String holder, long inodeId)
specifier|synchronized
name|Lease
name|addLease
parameter_list|(
name|String
name|holder
parameter_list|,
name|long
name|inodeId
parameter_list|)
block|{
name|Lease
name|lease
init|=
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
if|if
condition|(
name|lease
operator|==
literal|null
condition|)
block|{
name|lease
operator|=
operator|new
name|Lease
argument_list|(
name|holder
argument_list|)
expr_stmt|;
name|leases
operator|.
name|put
argument_list|(
name|holder
argument_list|,
name|lease
argument_list|)
expr_stmt|;
name|sortedLeases
operator|.
name|add
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|renewLease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
name|leasesById
operator|.
name|put
argument_list|(
name|inodeId
argument_list|,
name|lease
argument_list|)
expr_stmt|;
name|lease
operator|.
name|files
operator|.
name|add
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
return|return
name|lease
return|;
block|}
comment|/**    * Remove the specified lease and src.    */
DECL|method|removeLease (Lease lease, long inodeId)
specifier|private
specifier|synchronized
name|void
name|removeLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|long
name|inodeId
parameter_list|)
block|{
name|leasesById
operator|.
name|remove
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|.
name|removeFile
argument_list|(
name|inodeId
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"inode "
operator|+
name|inodeId
operator|+
literal|" not found in lease.files (="
operator|+
name|lease
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|lease
operator|.
name|hasFiles
argument_list|()
condition|)
block|{
name|leases
operator|.
name|remove
argument_list|(
name|lease
operator|.
name|holder
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sortedLeases
operator|.
name|remove
argument_list|(
name|lease
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|lease
operator|+
literal|" not found in sortedLeases"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove the lease for the specified holder and src    */
DECL|method|removeLease (String holder, INodeFile src)
specifier|synchronized
name|void
name|removeLease
parameter_list|(
name|String
name|holder
parameter_list|,
name|INodeFile
name|src
parameter_list|)
block|{
name|Lease
name|lease
init|=
name|getLease
argument_list|(
name|holder
argument_list|)
decl_stmt|;
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|removeLease
argument_list|(
name|lease
argument_list|,
name|src
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing non-existent lease! holder="
operator|+
name|holder
operator|+
literal|" src="
operator|+
name|src
operator|.
name|getFullPathName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeAllLeases ()
specifier|synchronized
name|void
name|removeAllLeases
parameter_list|()
block|{
name|sortedLeases
operator|.
name|clear
argument_list|()
expr_stmt|;
name|leasesById
operator|.
name|clear
argument_list|()
expr_stmt|;
name|leases
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Reassign lease for file src to the new holder.    */
DECL|method|reassignLease (Lease lease, INodeFile src, String newHolder)
specifier|synchronized
name|Lease
name|reassignLease
parameter_list|(
name|Lease
name|lease
parameter_list|,
name|INodeFile
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|)
block|{
assert|assert
name|newHolder
operator|!=
literal|null
operator|:
literal|"new lease holder is null"
assert|;
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|removeLease
argument_list|(
name|lease
argument_list|,
name|src
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|addLease
argument_list|(
name|newHolder
argument_list|,
name|src
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Renew the lease(s) held by the given client    */
DECL|method|renewLease (String holder)
specifier|synchronized
name|void
name|renewLease
parameter_list|(
name|String
name|holder
parameter_list|)
block|{
name|renewLease
argument_list|(
name|getLease
argument_list|(
name|holder
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|renewLease (Lease lease)
specifier|synchronized
name|void
name|renewLease
parameter_list|(
name|Lease
name|lease
parameter_list|)
block|{
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|sortedLeases
operator|.
name|remove
argument_list|(
name|lease
argument_list|)
expr_stmt|;
name|lease
operator|.
name|renew
argument_list|()
expr_stmt|;
name|sortedLeases
operator|.
name|add
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Renew all of the currently open leases.    */
DECL|method|renewAllLeases ()
specifier|synchronized
name|void
name|renewAllLeases
parameter_list|()
block|{
for|for
control|(
name|Lease
name|l
range|:
name|leases
operator|.
name|values
argument_list|()
control|)
block|{
name|renewLease
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
comment|/************************************************************    * A Lease governs all the locks held by a single client.    * For each client there's a corresponding lease, whose    * timestamp is updated when the client periodically    * checks in.  If the client dies and allows its lease to    * expire, all the corresponding locks can be released.    *************************************************************/
DECL|class|Lease
class|class
name|Lease
block|{
DECL|field|holder
specifier|private
specifier|final
name|String
name|holder
decl_stmt|;
DECL|field|lastUpdate
specifier|private
name|long
name|lastUpdate
decl_stmt|;
DECL|field|files
specifier|private
specifier|final
name|HashSet
argument_list|<
name|Long
argument_list|>
name|files
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Only LeaseManager object can create a lease */
DECL|method|Lease (String holder)
specifier|private
name|Lease
parameter_list|(
name|String
name|holder
parameter_list|)
block|{
name|this
operator|.
name|holder
operator|=
name|holder
expr_stmt|;
name|renew
argument_list|()
expr_stmt|;
block|}
comment|/** Only LeaseManager object can renew a lease */
DECL|method|renew ()
specifier|private
name|void
name|renew
parameter_list|()
block|{
name|this
operator|.
name|lastUpdate
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
comment|/** @return true if the Hard Limit Timer has expired */
DECL|method|expiredHardLimit ()
specifier|public
name|boolean
name|expiredHardLimit
parameter_list|()
block|{
return|return
name|monotonicNow
argument_list|()
operator|-
name|lastUpdate
operator|>
name|hardLimit
return|;
block|}
comment|/** @return true if the Soft Limit Timer has expired */
DECL|method|expiredSoftLimit ()
specifier|public
name|boolean
name|expiredSoftLimit
parameter_list|()
block|{
return|return
name|monotonicNow
argument_list|()
operator|-
name|lastUpdate
operator|>
name|softLimit
return|;
block|}
comment|/** Does this lease contain any path? */
DECL|method|hasFiles ()
name|boolean
name|hasFiles
parameter_list|()
block|{
return|return
operator|!
name|files
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|removeFile (long inodeId)
name|boolean
name|removeFile
parameter_list|(
name|long
name|inodeId
parameter_list|)
block|{
return|return
name|files
operator|.
name|remove
argument_list|(
name|inodeId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[Lease.  Holder: "
operator|+
name|holder
operator|+
literal|", pending creates: "
operator|+
name|files
operator|.
name|size
argument_list|()
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|holder
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|getFiles ()
specifier|private
name|Collection
argument_list|<
name|Long
argument_list|>
name|getFiles
parameter_list|()
block|{
return|return
name|files
return|;
block|}
DECL|method|getHolder ()
name|String
name|getHolder
parameter_list|()
block|{
return|return
name|holder
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getLastUpdate ()
name|long
name|getLastUpdate
parameter_list|()
block|{
return|return
name|lastUpdate
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|removeLeases (Collection<Long> inodes)
specifier|synchronized
name|void
name|removeLeases
parameter_list|(
name|Collection
argument_list|<
name|Long
argument_list|>
name|inodes
parameter_list|)
block|{
for|for
control|(
name|long
name|inode
range|:
name|inodes
control|)
block|{
name|Lease
name|lease
init|=
name|leasesById
operator|.
name|get
argument_list|(
name|inode
argument_list|)
decl_stmt|;
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
block|{
name|removeLease
argument_list|(
name|lease
argument_list|,
name|inode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setLeasePeriod (long softLimit, long hardLimit)
specifier|public
name|void
name|setLeasePeriod
parameter_list|(
name|long
name|softLimit
parameter_list|,
name|long
name|hardLimit
parameter_list|)
block|{
name|this
operator|.
name|softLimit
operator|=
name|softLimit
expr_stmt|;
name|this
operator|.
name|hardLimit
operator|=
name|hardLimit
expr_stmt|;
block|}
comment|/******************************************************    * Monitor checks for leases that have expired,    * and disposes of them.    ******************************************************/
DECL|class|Monitor
class|class
name|Monitor
implements|implements
name|Runnable
block|{
DECL|field|name
specifier|final
name|String
name|name
init|=
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
comment|/** Check leases periodically. */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
init|;
name|shouldRunMonitor
operator|&&
name|fsnamesystem
operator|.
name|isRunning
argument_list|()
condition|;
control|)
block|{
name|boolean
name|needSync
init|=
literal|false
decl_stmt|;
try|try
block|{
name|fsnamesystem
operator|.
name|writeLockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|fsnamesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
name|needSync
operator|=
name|checkLeases
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|fsnamesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// lease reassignments should to be sync'ed.
if|if
condition|(
name|needSync
condition|)
block|{
name|fsnamesystem
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|HdfsServerConstants
operator|.
name|NAMENODE_LEASE_RECHECK_INTERVAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" is interrupted"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected throwable: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Check the leases beginning from the oldest.    *  @return true is sync is needed.    */
annotation|@
name|VisibleForTesting
DECL|method|checkLeases ()
specifier|synchronized
name|boolean
name|checkLeases
parameter_list|()
block|{
name|boolean
name|needSync
init|=
literal|false
decl_stmt|;
assert|assert
name|fsnamesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
while|while
condition|(
operator|!
name|sortedLeases
operator|.
name|isEmpty
argument_list|()
operator|&&
name|sortedLeases
operator|.
name|peek
argument_list|()
operator|.
name|expiredHardLimit
argument_list|()
condition|)
block|{
name|Lease
name|leaseToCheck
init|=
name|sortedLeases
operator|.
name|poll
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|leaseToCheck
operator|+
literal|" has expired hard limit"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Long
argument_list|>
name|removing
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// need to create a copy of the oldest lease files, because
comment|// internalReleaseLease() removes files corresponding to empty files,
comment|// i.e. it needs to modify the collection being iterated over
comment|// causing ConcurrentModificationException
name|Collection
argument_list|<
name|Long
argument_list|>
name|files
init|=
name|leaseToCheck
operator|.
name|getFiles
argument_list|()
decl_stmt|;
name|Long
index|[]
name|leaseINodeIds
init|=
name|files
operator|.
name|toArray
argument_list|(
operator|new
name|Long
index|[
name|files
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|FSDirectory
name|fsd
init|=
name|fsnamesystem
operator|.
name|getFSDirectory
argument_list|()
decl_stmt|;
name|String
name|p
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Long
name|id
range|:
name|leaseINodeIds
control|)
block|{
try|try
block|{
name|INodesInPath
name|iip
init|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|fsd
operator|.
name|getInode
argument_list|(
name|id
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
comment|// Sanity check to make sure the path is correct
if|if
condition|(
operator|!
name|p
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid path in the lease "
operator|+
name|p
argument_list|)
throw|;
block|}
name|boolean
name|completed
init|=
name|fsnamesystem
operator|.
name|internalReleaseLease
argument_list|(
name|leaseToCheck
argument_list|,
name|p
argument_list|,
name|iip
argument_list|,
name|HdfsServerConstants
operator|.
name|NAMENODE_LEASE_HOLDER
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|completed
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lease recovery for inode "
operator|+
name|id
operator|+
literal|" is complete. "
operator|+
literal|"File closed."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Started block recovery "
operator|+
name|p
operator|+
literal|" lease "
operator|+
name|leaseToCheck
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If a lease recovery happened, we need to sync later.
if|if
condition|(
operator|!
name|needSync
operator|&&
operator|!
name|completed
condition|)
block|{
name|needSync
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot release the path "
operator|+
name|p
operator|+
literal|" in the lease "
operator|+
name|leaseToCheck
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|removing
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Long
name|id
range|:
name|removing
control|)
block|{
name|removeLease
argument_list|(
name|leaseToCheck
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|needSync
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
specifier|synchronized
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"= {"
operator|+
literal|"\n leases="
operator|+
name|leases
operator|+
literal|"\n sortedLeases="
operator|+
name|sortedLeases
operator|+
literal|"\n leasesById="
operator|+
name|leasesById
operator|+
literal|"\n}"
return|;
block|}
DECL|method|startMonitor ()
name|void
name|startMonitor
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lmthread
operator|==
literal|null
argument_list|,
literal|"Lease Monitor already running"
argument_list|)
expr_stmt|;
name|shouldRunMonitor
operator|=
literal|true
expr_stmt|;
name|lmthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|Monitor
argument_list|()
argument_list|)
expr_stmt|;
name|lmthread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|stopMonitor ()
name|void
name|stopMonitor
parameter_list|()
block|{
if|if
condition|(
name|lmthread
operator|!=
literal|null
condition|)
block|{
name|shouldRunMonitor
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|lmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|lmthread
operator|.
name|join
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
name|lmthread
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Trigger the currently-running Lease monitor to re-check    * its leases immediately. This is for use by unit tests.    */
annotation|@
name|VisibleForTesting
DECL|method|triggerMonitorCheckNow ()
specifier|public
name|void
name|triggerMonitorCheckNow
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lmthread
operator|!=
literal|null
argument_list|,
literal|"Lease monitor is not running"
argument_list|)
expr_stmt|;
name|lmthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|runLeaseChecks ()
specifier|public
name|void
name|runLeaseChecks
parameter_list|()
block|{
name|checkLeases
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

