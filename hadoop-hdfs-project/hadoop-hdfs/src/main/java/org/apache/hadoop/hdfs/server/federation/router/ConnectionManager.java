begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.federation.router
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|federation
operator|.
name|router
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|util
operator|.
name|ajax
operator|.
name|JSON
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Implements a pool of connections for the {@link Router} to be able to open  * many connections to many Namenodes.  */
end_comment

begin_class
DECL|class|ConnectionManager
specifier|public
class|class
name|ConnectionManager
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ConnectionManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Number of parallel new connections to create. */
DECL|field|MAX_NEW_CONNECTIONS
specifier|protected
specifier|static
specifier|final
name|int
name|MAX_NEW_CONNECTIONS
init|=
literal|100
decl_stmt|;
comment|/** Minimum amount of active connections: 50%. */
DECL|field|MIN_ACTIVE_RATIO
specifier|protected
specifier|static
specifier|final
name|float
name|MIN_ACTIVE_RATIO
init|=
literal|0.5f
decl_stmt|;
comment|/** Configuration for the connection manager, pool and sockets. */
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|/** Min number of connections per user + nn. */
DECL|field|minSize
specifier|private
specifier|final
name|int
name|minSize
init|=
literal|1
decl_stmt|;
comment|/** Max number of connections per user + nn. */
DECL|field|maxSize
specifier|private
specifier|final
name|int
name|maxSize
decl_stmt|;
comment|/** How often we close a pool for a particular user + nn. */
DECL|field|poolCleanupPeriodMs
specifier|private
specifier|final
name|long
name|poolCleanupPeriodMs
decl_stmt|;
comment|/** How often we close a connection in a pool. */
DECL|field|connectionCleanupPeriodMs
specifier|private
specifier|final
name|long
name|connectionCleanupPeriodMs
decl_stmt|;
comment|/** Map of connection pools, one pool per user + NN. */
DECL|field|pools
specifier|private
specifier|final
name|Map
argument_list|<
name|ConnectionPoolId
argument_list|,
name|ConnectionPool
argument_list|>
name|pools
decl_stmt|;
comment|/** Lock for accessing pools. */
DECL|field|readWriteLock
specifier|private
specifier|final
name|ReadWriteLock
name|readWriteLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
DECL|field|readLock
specifier|private
specifier|final
name|Lock
name|readLock
init|=
name|readWriteLock
operator|.
name|readLock
argument_list|()
decl_stmt|;
DECL|field|writeLock
specifier|private
specifier|final
name|Lock
name|writeLock
init|=
name|readWriteLock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
comment|/** Queue for creating new connections. */
DECL|field|creatorQueue
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|ConnectionPool
argument_list|>
name|creatorQueue
init|=
operator|new
name|ArrayBlockingQueue
argument_list|<>
argument_list|(
name|MAX_NEW_CONNECTIONS
argument_list|)
decl_stmt|;
comment|/** Create new connections asynchronously. */
DECL|field|creator
specifier|private
specifier|final
name|ConnectionCreator
name|creator
decl_stmt|;
comment|/** Periodic executor to remove stale connection pools. */
DECL|field|cleaner
specifier|private
specifier|final
name|ScheduledThreadPoolExecutor
name|cleaner
init|=
operator|new
name|ScheduledThreadPoolExecutor
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/** If the connection manager is running. */
DECL|field|running
specifier|private
name|boolean
name|running
init|=
literal|false
decl_stmt|;
comment|/**    * Creates a proxy client connection pool manager.    *    * @param config Configuration for the connections.    */
DECL|method|ConnectionManager (Configuration config)
specifier|public
name|ConnectionManager
parameter_list|(
name|Configuration
name|config
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|config
expr_stmt|;
comment|// Configure minimum and maximum connection pools
name|this
operator|.
name|maxSize
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_ROUTER_NAMENODE_CONNECTION_POOL_SIZE
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_ROUTER_NAMENODE_CONNECTION_POOL_SIZE_DEFAULT
argument_list|)
expr_stmt|;
comment|// Map with the connections indexed by UGI and Namenode
name|this
operator|.
name|pools
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
comment|// Create connections in a thread asynchronously
name|this
operator|.
name|creator
operator|=
operator|new
name|ConnectionCreator
argument_list|(
name|creatorQueue
argument_list|)
expr_stmt|;
name|this
operator|.
name|creator
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Cleanup periods
name|this
operator|.
name|poolCleanupPeriodMs
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_ROUTER_NAMENODE_CONNECTION_POOL_CLEAN
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_ROUTER_NAMENODE_CONNECTION_POOL_CLEAN_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning connection pools every {} seconds"
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|toSeconds
argument_list|(
name|this
operator|.
name|poolCleanupPeriodMs
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectionCleanupPeriodMs
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_ROUTER_NAMENODE_CONNECTION_CLEAN_MS
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_ROUTER_NAMENODE_CONNECTION_CLEAN_MS_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning connections every {} seconds"
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|toSeconds
argument_list|(
name|this
operator|.
name|connectionCleanupPeriodMs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start the connection manager.    */
DECL|method|start ()
specifier|public
name|void
name|start
parameter_list|()
block|{
comment|// Start the thread that creates connections asynchronously
name|this
operator|.
name|creator
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Schedule a task to remove stale connection pools and sockets
name|long
name|recyleTimeMs
init|=
name|Math
operator|.
name|min
argument_list|(
name|poolCleanupPeriodMs
argument_list|,
name|connectionCleanupPeriodMs
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning every {} seconds"
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|toSeconds
argument_list|(
name|recyleTimeMs
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|cleaner
operator|.
name|scheduleAtFixedRate
argument_list|(
operator|new
name|CleanupTask
argument_list|()
argument_list|,
literal|0
argument_list|,
name|recyleTimeMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
comment|// Mark the manager as running
name|this
operator|.
name|running
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Stop the connection manager by closing all the pools.    */
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
name|this
operator|.
name|creator
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|this
operator|.
name|cleaner
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|this
operator|.
name|running
operator|=
literal|false
expr_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|ConnectionPool
name|pool
range|:
name|this
operator|.
name|pools
operator|.
name|values
argument_list|()
control|)
block|{
name|pool
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|pools
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Fetches the next available proxy client in the pool. Each client connection    * is reserved for a single user and cannot be reused until free.    *    * @param ugi User group information.    * @param nnAddress Namenode address for the connection.    * @return Proxy client to connect to nnId as UGI.    * @throws IOException If the connection cannot be obtained.    */
DECL|method|getConnection ( UserGroupInformation ugi, String nnAddress)
specifier|public
name|ConnectionContext
name|getConnection
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|String
name|nnAddress
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Check if the manager is shutdown
if|if
condition|(
operator|!
name|this
operator|.
name|running
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot get a connection to {} because the manager isn't running"
argument_list|,
name|nnAddress
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Try to get the pool if created
name|ConnectionPoolId
name|connectionId
init|=
operator|new
name|ConnectionPoolId
argument_list|(
name|ugi
argument_list|,
name|nnAddress
argument_list|)
decl_stmt|;
name|ConnectionPool
name|pool
init|=
literal|null
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pool
operator|=
name|this
operator|.
name|pools
operator|.
name|get
argument_list|(
name|connectionId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Create the pool if not created before
if|if
condition|(
name|pool
operator|==
literal|null
condition|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pool
operator|=
name|this
operator|.
name|pools
operator|.
name|get
argument_list|(
name|connectionId
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
literal|null
condition|)
block|{
name|pool
operator|=
operator|new
name|ConnectionPool
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|nnAddress
argument_list|,
name|ugi
argument_list|,
name|this
operator|.
name|minSize
argument_list|,
name|this
operator|.
name|maxSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|pools
operator|.
name|put
argument_list|(
name|connectionId
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|ConnectionContext
name|conn
init|=
name|pool
operator|.
name|getConnection
argument_list|()
decl_stmt|;
comment|// Add a new connection to the pool if it wasn't usable
if|if
condition|(
name|conn
operator|==
literal|null
operator|||
operator|!
name|conn
operator|.
name|isUsable
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|creatorQueue
operator|.
name|offer
argument_list|(
name|pool
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot add more than {} connections at the same time"
argument_list|,
name|MAX_NEW_CONNECTIONS
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conn
operator|!=
literal|null
operator|&&
name|conn
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"We got a closed connection from {}"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|conn
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|conn
return|;
block|}
comment|/**    * Get the number of connection pools.    *    * @return Number of connection pools.    */
DECL|method|getNumConnectionPools ()
specifier|public
name|int
name|getNumConnectionPools
parameter_list|()
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|pools
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get number of open connections.    *    * @return Number of open connections.    */
DECL|method|getNumConnections ()
specifier|public
name|int
name|getNumConnections
parameter_list|()
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|ConnectionPool
name|pool
range|:
name|this
operator|.
name|pools
operator|.
name|values
argument_list|()
control|)
block|{
name|total
operator|+=
name|pool
operator|.
name|getNumConnections
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/**    * Get number of active connections.    *    * @return Number of active connections.    */
DECL|method|getNumActiveConnections ()
specifier|public
name|int
name|getNumActiveConnections
parameter_list|()
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|ConnectionPool
name|pool
range|:
name|this
operator|.
name|pools
operator|.
name|values
argument_list|()
control|)
block|{
name|total
operator|+=
name|pool
operator|.
name|getNumActiveConnections
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/**    * Get the number of connections to be created.    *    * @return Number of connections to be created.    */
DECL|method|getNumCreatingConnections ()
specifier|public
name|int
name|getNumCreatingConnections
parameter_list|()
block|{
return|return
name|this
operator|.
name|creatorQueue
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Get a JSON representation of the connection pool.    *    * @return JSON representation of all the connection pools.    */
DECL|method|getJSON ()
specifier|public
name|String
name|getJSON
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Entry
argument_list|<
name|ConnectionPoolId
argument_list|,
name|ConnectionPool
argument_list|>
name|entry
range|:
name|this
operator|.
name|pools
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ConnectionPoolId
name|connectionPoolId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ConnectionPool
name|pool
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
name|connectionPoolId
operator|.
name|toString
argument_list|()
argument_list|,
name|pool
operator|.
name|getJSON
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getPools ()
name|Map
argument_list|<
name|ConnectionPoolId
argument_list|,
name|ConnectionPool
argument_list|>
name|getPools
parameter_list|()
block|{
return|return
name|this
operator|.
name|pools
return|;
block|}
comment|/**    * Clean the unused connections for this pool.    *    * @param pool Connection pool to cleanup.    */
annotation|@
name|VisibleForTesting
DECL|method|cleanup (ConnectionPool pool)
name|void
name|cleanup
parameter_list|(
name|ConnectionPool
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|.
name|getNumConnections
argument_list|()
operator|>
name|pool
operator|.
name|getMinSize
argument_list|()
condition|)
block|{
comment|// Check if the pool hasn't been active in a while or not 50% are used
name|long
name|timeSinceLastActive
init|=
name|Time
operator|.
name|now
argument_list|()
operator|-
name|pool
operator|.
name|getLastActiveTime
argument_list|()
decl_stmt|;
name|int
name|total
init|=
name|pool
operator|.
name|getNumConnections
argument_list|()
decl_stmt|;
name|int
name|active
init|=
name|pool
operator|.
name|getNumActiveConnections
argument_list|()
decl_stmt|;
if|if
condition|(
name|timeSinceLastActive
operator|>
name|connectionCleanupPeriodMs
operator|||
name|active
operator|<
name|MIN_ACTIVE_RATIO
operator|*
name|total
condition|)
block|{
comment|// Remove and close 1 connection
name|List
argument_list|<
name|ConnectionContext
argument_list|>
name|conns
init|=
name|pool
operator|.
name|removeConnections
argument_list|(
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|ConnectionContext
name|conn
range|:
name|conns
control|)
block|{
name|conn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed connection {} used {} seconds ago. "
operator|+
literal|"Pool has {}/{} connections"
argument_list|,
name|pool
operator|.
name|getConnectionPoolId
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|toSeconds
argument_list|(
name|timeSinceLastActive
argument_list|)
argument_list|,
name|pool
operator|.
name|getNumConnections
argument_list|()
argument_list|,
name|pool
operator|.
name|getMaxSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Removes stale connections not accessed recently from the pool. This is    * invoked periodically.    */
DECL|class|CleanupTask
specifier|private
class|class
name|CleanupTask
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|long
name|currentTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ConnectionPoolId
argument_list|>
name|toRemove
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Look for stale pools
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Entry
argument_list|<
name|ConnectionPoolId
argument_list|,
name|ConnectionPool
argument_list|>
name|entry
range|:
name|pools
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ConnectionPool
name|pool
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|lastTimeActive
init|=
name|pool
operator|.
name|getLastActiveTime
argument_list|()
decl_stmt|;
name|boolean
name|isStale
init|=
name|currentTime
operator|>
operator|(
name|lastTimeActive
operator|+
name|poolCleanupPeriodMs
operator|)
decl_stmt|;
if|if
condition|(
name|lastTimeActive
operator|>
literal|0
operator|&&
name|isStale
condition|)
block|{
comment|// Remove this pool
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closing and removing stale pool {}"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|.
name|close
argument_list|()
expr_stmt|;
name|ConnectionPoolId
name|poolId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|toRemove
operator|.
name|add
argument_list|(
name|poolId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Keep this pool but clean connections inside
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cleaning up {}"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Remove stale pools
if|if
condition|(
operator|!
name|toRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|ConnectionPoolId
name|poolId
range|:
name|toRemove
control|)
block|{
name|pools
operator|.
name|remove
argument_list|(
name|poolId
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Thread that creates connections asynchronously.    */
DECL|class|ConnectionCreator
specifier|private
specifier|static
class|class
name|ConnectionCreator
extends|extends
name|Thread
block|{
comment|/** If the creator is running. */
DECL|field|running
specifier|private
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|/** Queue to push work to. */
DECL|field|queue
specifier|private
name|BlockingQueue
argument_list|<
name|ConnectionPool
argument_list|>
name|queue
decl_stmt|;
DECL|method|ConnectionCreator (BlockingQueue<ConnectionPool> blockingQueue)
name|ConnectionCreator
parameter_list|(
name|BlockingQueue
argument_list|<
name|ConnectionPool
argument_list|>
name|blockingQueue
parameter_list|)
block|{
name|super
argument_list|(
literal|"Connection creator"
argument_list|)
expr_stmt|;
name|this
operator|.
name|queue
operator|=
name|blockingQueue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|this
operator|.
name|running
condition|)
block|{
try|try
block|{
name|ConnectionPool
name|pool
init|=
name|this
operator|.
name|queue
operator|.
name|take
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|total
init|=
name|pool
operator|.
name|getNumConnections
argument_list|()
decl_stmt|;
name|int
name|active
init|=
name|pool
operator|.
name|getNumActiveConnections
argument_list|()
decl_stmt|;
if|if
condition|(
name|pool
operator|.
name|getNumConnections
argument_list|()
operator|<
name|pool
operator|.
name|getMaxSize
argument_list|()
operator|&&
name|active
operator|>=
name|MIN_ACTIVE_RATIO
operator|*
name|total
condition|)
block|{
name|ConnectionContext
name|conn
init|=
name|pool
operator|.
name|newConnection
argument_list|()
decl_stmt|;
name|pool
operator|.
name|addConnection
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cannot add more than {} connections to {}"
argument_list|,
name|pool
operator|.
name|getMaxSize
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot create a new connection"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The connection creator was interrupted"
argument_list|)
expr_stmt|;
name|this
operator|.
name|running
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Stop this connection creator.      */
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|this
operator|.
name|running
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

