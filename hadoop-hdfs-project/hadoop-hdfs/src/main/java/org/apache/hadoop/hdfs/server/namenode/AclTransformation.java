begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntryScope
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntryType
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ComparisonChain
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntryScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntryType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|ScopedAclEntries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|AclException
import|;
end_import

begin_comment
comment|/**  * AclTransformation defines the operations that can modify an ACL.  All ACL  * modifications take as input an existing ACL and apply logic to add new  * entries, modify existing entries or remove old entries.  Some operations also  * accept an ACL spec: a list of entries that further describes the requested  * change.  Different operations interpret the ACL spec differently.  In the  * case of adding an ACL to an inode that previously did not have one, the  * existing ACL can be a "minimal ACL" containing exactly 3 entries for owner,  * group and other, all derived from the {@link FsPermission} bits.  *  * The algorithms implemented here require sorted lists of ACL entries.  For any  * existing ACL, it is assumed that the entries are sorted.  This is because all  * ACL creation and modification is intended to go through these methods, and  * they all guarantee correct sort order in their outputs.  However, an ACL spec  * is considered untrusted user input, so all operations pre-sort the ACL spec as  * the first step.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|AclTransformation
specifier|final
class|class
name|AclTransformation
block|{
DECL|field|MAX_ENTRIES
specifier|private
specifier|static
specifier|final
name|int
name|MAX_ENTRIES
init|=
literal|32
decl_stmt|;
comment|/**    * Filters (discards) any existing ACL entries that have the same scope, type    * and name of any entry in the ACL spec.  If necessary, recalculates the mask    * entries.  If necessary, default entries may be inferred by copying the    * permissions of the corresponding access entries.  It is invalid to request    * removal of the mask entry from an ACL that would otherwise require a mask    * entry, due to existing named entries or an unnamed group entry.    *    * @param existingAcl List<AclEntry> existing ACL    * @param inAclSpec List<AclEntry> ACL spec describing entries to filter    * @return List<AclEntry> new ACL    * @throws AclException if validation fails    */
DECL|method|filterAclEntriesByAclSpec ( List<AclEntry> existingAcl, List<AclEntry> inAclSpec)
specifier|public
specifier|static
name|List
argument_list|<
name|AclEntry
argument_list|>
name|filterAclEntriesByAclSpec
parameter_list|(
name|List
argument_list|<
name|AclEntry
argument_list|>
name|existingAcl
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|inAclSpec
parameter_list|)
throws|throws
name|AclException
block|{
name|ValidatedAclSpec
name|aclSpec
init|=
operator|new
name|ValidatedAclSpec
argument_list|(
name|inAclSpec
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|AclEntry
argument_list|>
name|aclBuilder
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|MAX_ENTRIES
argument_list|)
decl_stmt|;
name|EnumMap
argument_list|<
name|AclEntryScope
argument_list|,
name|AclEntry
argument_list|>
name|providedMask
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|maskDirty
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|scopeDirty
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|AclEntry
name|existingEntry
range|:
name|existingAcl
control|)
block|{
if|if
condition|(
name|aclSpec
operator|.
name|containsKey
argument_list|(
name|existingEntry
argument_list|)
condition|)
block|{
name|scopeDirty
operator|.
name|add
argument_list|(
name|existingEntry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|existingEntry
operator|.
name|getType
argument_list|()
operator|==
name|MASK
condition|)
block|{
name|maskDirty
operator|.
name|add
argument_list|(
name|existingEntry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|existingEntry
operator|.
name|getType
argument_list|()
operator|==
name|MASK
condition|)
block|{
name|providedMask
operator|.
name|put
argument_list|(
name|existingEntry
operator|.
name|getScope
argument_list|()
argument_list|,
name|existingEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclBuilder
operator|.
name|add
argument_list|(
name|existingEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|copyDefaultsIfNeeded
argument_list|(
name|aclBuilder
argument_list|)
expr_stmt|;
name|calculateMasks
argument_list|(
name|aclBuilder
argument_list|,
name|providedMask
argument_list|,
name|maskDirty
argument_list|,
name|scopeDirty
argument_list|)
expr_stmt|;
return|return
name|buildAndValidateAcl
argument_list|(
name|aclBuilder
argument_list|)
return|;
block|}
comment|/**    * Filters (discards) any existing default ACL entries.  The new ACL retains    * only the access ACL entries.    *    * @param existingAcl List<AclEntry> existing ACL    * @return List<AclEntry> new ACL    * @throws AclException if validation fails    */
DECL|method|filterDefaultAclEntries ( List<AclEntry> existingAcl)
specifier|public
specifier|static
name|List
argument_list|<
name|AclEntry
argument_list|>
name|filterDefaultAclEntries
parameter_list|(
name|List
argument_list|<
name|AclEntry
argument_list|>
name|existingAcl
parameter_list|)
throws|throws
name|AclException
block|{
name|ArrayList
argument_list|<
name|AclEntry
argument_list|>
name|aclBuilder
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|MAX_ENTRIES
argument_list|)
decl_stmt|;
for|for
control|(
name|AclEntry
name|existingEntry
range|:
name|existingAcl
control|)
block|{
if|if
condition|(
name|existingEntry
operator|.
name|getScope
argument_list|()
operator|==
name|DEFAULT
condition|)
block|{
comment|// Default entries sort after access entries, so we can exit early.
break|break;
block|}
name|aclBuilder
operator|.
name|add
argument_list|(
name|existingEntry
argument_list|)
expr_stmt|;
block|}
return|return
name|buildAndValidateAcl
argument_list|(
name|aclBuilder
argument_list|)
return|;
block|}
comment|/**    * Merges the entries of the ACL spec into the existing ACL.  If necessary,    * recalculates the mask entries.  If necessary, default entries may be    * inferred by copying the permissions of the corresponding access entries.    *    * @param existingAcl List<AclEntry> existing ACL    * @param inAclSpec List<AclEntry> ACL spec containing entries to merge    * @return List<AclEntry> new ACL    * @throws AclException if validation fails    */
DECL|method|mergeAclEntries (List<AclEntry> existingAcl, List<AclEntry> inAclSpec)
specifier|public
specifier|static
name|List
argument_list|<
name|AclEntry
argument_list|>
name|mergeAclEntries
parameter_list|(
name|List
argument_list|<
name|AclEntry
argument_list|>
name|existingAcl
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|inAclSpec
parameter_list|)
throws|throws
name|AclException
block|{
name|ValidatedAclSpec
name|aclSpec
init|=
operator|new
name|ValidatedAclSpec
argument_list|(
name|inAclSpec
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|AclEntry
argument_list|>
name|aclBuilder
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|MAX_ENTRIES
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|foundAclSpecEntries
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|MAX_ENTRIES
argument_list|)
decl_stmt|;
name|EnumMap
argument_list|<
name|AclEntryScope
argument_list|,
name|AclEntry
argument_list|>
name|providedMask
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|maskDirty
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|scopeDirty
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|AclEntry
name|existingEntry
range|:
name|existingAcl
control|)
block|{
name|AclEntry
name|aclSpecEntry
init|=
name|aclSpec
operator|.
name|findByKey
argument_list|(
name|existingEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|aclSpecEntry
operator|!=
literal|null
condition|)
block|{
name|foundAclSpecEntries
operator|.
name|add
argument_list|(
name|aclSpecEntry
argument_list|)
expr_stmt|;
name|scopeDirty
operator|.
name|add
argument_list|(
name|aclSpecEntry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclSpecEntry
operator|.
name|getType
argument_list|()
operator|==
name|MASK
condition|)
block|{
name|providedMask
operator|.
name|put
argument_list|(
name|aclSpecEntry
operator|.
name|getScope
argument_list|()
argument_list|,
name|aclSpecEntry
argument_list|)
expr_stmt|;
name|maskDirty
operator|.
name|add
argument_list|(
name|aclSpecEntry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclBuilder
operator|.
name|add
argument_list|(
name|aclSpecEntry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|existingEntry
operator|.
name|getType
argument_list|()
operator|==
name|MASK
condition|)
block|{
name|providedMask
operator|.
name|put
argument_list|(
name|existingEntry
operator|.
name|getScope
argument_list|()
argument_list|,
name|existingEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclBuilder
operator|.
name|add
argument_list|(
name|existingEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// ACL spec entries that were not replacements are new additions.
for|for
control|(
name|AclEntry
name|newEntry
range|:
name|aclSpec
control|)
block|{
if|if
condition|(
name|Collections
operator|.
name|binarySearch
argument_list|(
name|foundAclSpecEntries
argument_list|,
name|newEntry
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|scopeDirty
operator|.
name|add
argument_list|(
name|newEntry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newEntry
operator|.
name|getType
argument_list|()
operator|==
name|MASK
condition|)
block|{
name|providedMask
operator|.
name|put
argument_list|(
name|newEntry
operator|.
name|getScope
argument_list|()
argument_list|,
name|newEntry
argument_list|)
expr_stmt|;
name|maskDirty
operator|.
name|add
argument_list|(
name|newEntry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclBuilder
operator|.
name|add
argument_list|(
name|newEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|copyDefaultsIfNeeded
argument_list|(
name|aclBuilder
argument_list|)
expr_stmt|;
name|calculateMasks
argument_list|(
name|aclBuilder
argument_list|,
name|providedMask
argument_list|,
name|maskDirty
argument_list|,
name|scopeDirty
argument_list|)
expr_stmt|;
return|return
name|buildAndValidateAcl
argument_list|(
name|aclBuilder
argument_list|)
return|;
block|}
comment|/**    * Completely replaces the ACL with the entries of the ACL spec.  If    * necessary, recalculates the mask entries.  If necessary, default entries    * are inferred by copying the permissions of the corresponding access    * entries.  Replacement occurs separately for each of the access ACL and the    * default ACL.  If the ACL spec contains only access entries, then the    * existing default entries are retained.  If the ACL spec contains only    * default entries, then the existing access entries are retained.  If the ACL    * spec contains both access and default entries, then both are replaced.    *    * @param existingAcl List<AclEntry> existing ACL    * @param inAclSpec List<AclEntry> ACL spec containing replacement entries    * @return List<AclEntry> new ACL    * @throws AclException if validation fails    */
DECL|method|replaceAclEntries (List<AclEntry> existingAcl, List<AclEntry> inAclSpec)
specifier|public
specifier|static
name|List
argument_list|<
name|AclEntry
argument_list|>
name|replaceAclEntries
parameter_list|(
name|List
argument_list|<
name|AclEntry
argument_list|>
name|existingAcl
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|inAclSpec
parameter_list|)
throws|throws
name|AclException
block|{
name|ValidatedAclSpec
name|aclSpec
init|=
operator|new
name|ValidatedAclSpec
argument_list|(
name|inAclSpec
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|AclEntry
argument_list|>
name|aclBuilder
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|MAX_ENTRIES
argument_list|)
decl_stmt|;
comment|// Replacement is done separately for each scope: access and default.
name|EnumMap
argument_list|<
name|AclEntryScope
argument_list|,
name|AclEntry
argument_list|>
name|providedMask
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|maskDirty
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|scopeDirty
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|AclEntry
name|aclSpecEntry
range|:
name|aclSpec
control|)
block|{
name|scopeDirty
operator|.
name|add
argument_list|(
name|aclSpecEntry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclSpecEntry
operator|.
name|getType
argument_list|()
operator|==
name|MASK
condition|)
block|{
name|providedMask
operator|.
name|put
argument_list|(
name|aclSpecEntry
operator|.
name|getScope
argument_list|()
argument_list|,
name|aclSpecEntry
argument_list|)
expr_stmt|;
name|maskDirty
operator|.
name|add
argument_list|(
name|aclSpecEntry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclBuilder
operator|.
name|add
argument_list|(
name|aclSpecEntry
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Copy existing entries if the scope was not replaced.
for|for
control|(
name|AclEntry
name|existingEntry
range|:
name|existingAcl
control|)
block|{
if|if
condition|(
operator|!
name|scopeDirty
operator|.
name|contains
argument_list|(
name|existingEntry
operator|.
name|getScope
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|existingEntry
operator|.
name|getType
argument_list|()
operator|==
name|MASK
condition|)
block|{
name|providedMask
operator|.
name|put
argument_list|(
name|existingEntry
operator|.
name|getScope
argument_list|()
argument_list|,
name|existingEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclBuilder
operator|.
name|add
argument_list|(
name|existingEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|copyDefaultsIfNeeded
argument_list|(
name|aclBuilder
argument_list|)
expr_stmt|;
name|calculateMasks
argument_list|(
name|aclBuilder
argument_list|,
name|providedMask
argument_list|,
name|maskDirty
argument_list|,
name|scopeDirty
argument_list|)
expr_stmt|;
return|return
name|buildAndValidateAcl
argument_list|(
name|aclBuilder
argument_list|)
return|;
block|}
comment|/**    * There is no reason to instantiate this class.    */
DECL|method|AclTransformation ()
specifier|private
name|AclTransformation
parameter_list|()
block|{   }
comment|/**    * Comparator that enforces required ordering for entries within an ACL:    * -owner entry (unnamed user)    * -all named user entries (internal ordering undefined)    * -owning group entry (unnamed group)    * -all named group entries (internal ordering undefined)    * -mask entry    * -other entry    * All access ACL entries sort ahead of all default ACL entries.    */
DECL|field|ACL_ENTRY_COMPARATOR
specifier|static
specifier|final
name|Comparator
argument_list|<
name|AclEntry
argument_list|>
name|ACL_ENTRY_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|AclEntry
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|AclEntry
name|entry1
parameter_list|,
name|AclEntry
name|entry2
parameter_list|)
block|{
return|return
name|ComparisonChain
operator|.
name|start
argument_list|()
operator|.
name|compare
argument_list|(
name|entry1
operator|.
name|getScope
argument_list|()
argument_list|,
name|entry2
operator|.
name|getScope
argument_list|()
argument_list|,
name|Ordering
operator|.
name|explicit
argument_list|(
name|ACCESS
argument_list|,
name|DEFAULT
argument_list|)
argument_list|)
operator|.
name|compare
argument_list|(
name|entry1
operator|.
name|getType
argument_list|()
argument_list|,
name|entry2
operator|.
name|getType
argument_list|()
argument_list|,
name|Ordering
operator|.
name|explicit
argument_list|(
name|USER
argument_list|,
name|GROUP
argument_list|,
name|MASK
argument_list|,
name|OTHER
argument_list|)
argument_list|)
operator|.
name|compare
argument_list|(
name|entry1
operator|.
name|getName
argument_list|()
argument_list|,
name|entry2
operator|.
name|getName
argument_list|()
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|nullsFirst
argument_list|()
argument_list|)
operator|.
name|result
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Builds the final list of ACL entries to return by trimming, sorting and    * validating the ACL entries that have been added.    *    * @param aclBuilder ArrayList<AclEntry> containing entries to build    * @return List<AclEntry> unmodifiable, sorted list of ACL entries    * @throws AclException if validation fails    */
DECL|method|buildAndValidateAcl ( ArrayList<AclEntry> aclBuilder)
specifier|private
specifier|static
name|List
argument_list|<
name|AclEntry
argument_list|>
name|buildAndValidateAcl
parameter_list|(
name|ArrayList
argument_list|<
name|AclEntry
argument_list|>
name|aclBuilder
parameter_list|)
throws|throws
name|AclException
block|{
name|aclBuilder
operator|.
name|trimToSize
argument_list|()
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|aclBuilder
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
expr_stmt|;
comment|// Full iteration to check for duplicates and invalid named entries.
name|AclEntry
name|prevEntry
init|=
literal|null
decl_stmt|;
for|for
control|(
name|AclEntry
name|entry
range|:
name|aclBuilder
control|)
block|{
if|if
condition|(
name|prevEntry
operator|!=
literal|null
operator|&&
name|ACL_ENTRY_COMPARATOR
operator|.
name|compare
argument_list|(
name|prevEntry
argument_list|,
name|entry
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|AclException
argument_list|(
literal|"Invalid ACL: multiple entries with same scope, type and name."
argument_list|)
throw|;
block|}
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
name|entry
operator|.
name|getType
argument_list|()
operator|==
name|MASK
operator|||
name|entry
operator|.
name|getType
argument_list|()
operator|==
name|OTHER
operator|)
condition|)
block|{
throw|throw
operator|new
name|AclException
argument_list|(
literal|"Invalid ACL: this entry type must not have a name: "
operator|+
name|entry
operator|+
literal|"."
argument_list|)
throw|;
block|}
name|prevEntry
operator|=
name|entry
expr_stmt|;
block|}
name|ScopedAclEntries
name|scopedEntries
init|=
operator|new
name|ScopedAclEntries
argument_list|(
name|aclBuilder
argument_list|)
decl_stmt|;
name|checkMaxEntries
argument_list|(
name|scopedEntries
argument_list|)
expr_stmt|;
comment|// Search for the required base access entries.  If there is a default ACL,
comment|// then do the same check on the default entries.
for|for
control|(
name|AclEntryType
name|type
range|:
name|EnumSet
operator|.
name|of
argument_list|(
name|USER
argument_list|,
name|GROUP
argument_list|,
name|OTHER
argument_list|)
control|)
block|{
name|AclEntry
name|accessEntryKey
init|=
operator|new
name|AclEntry
operator|.
name|Builder
argument_list|()
operator|.
name|setScope
argument_list|(
name|ACCESS
argument_list|)
operator|.
name|setType
argument_list|(
name|type
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|Collections
operator|.
name|binarySearch
argument_list|(
name|scopedEntries
operator|.
name|getAccessEntries
argument_list|()
argument_list|,
name|accessEntryKey
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|AclException
argument_list|(
literal|"Invalid ACL: the user, group and other entries are required."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|scopedEntries
operator|.
name|getDefaultEntries
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|AclEntry
name|defaultEntryKey
init|=
operator|new
name|AclEntry
operator|.
name|Builder
argument_list|()
operator|.
name|setScope
argument_list|(
name|DEFAULT
argument_list|)
operator|.
name|setType
argument_list|(
name|type
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|Collections
operator|.
name|binarySearch
argument_list|(
name|scopedEntries
operator|.
name|getDefaultEntries
argument_list|()
argument_list|,
name|defaultEntryKey
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|AclException
argument_list|(
literal|"Invalid default ACL: the user, group and other entries are required."
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|aclBuilder
argument_list|)
return|;
block|}
comment|// Check the max entries separately on access and default entries
comment|// HDFS-7582
DECL|method|checkMaxEntries (ScopedAclEntries scopedEntries)
specifier|private
specifier|static
name|void
name|checkMaxEntries
parameter_list|(
name|ScopedAclEntries
name|scopedEntries
parameter_list|)
throws|throws
name|AclException
block|{
name|List
argument_list|<
name|AclEntry
argument_list|>
name|accessEntries
init|=
name|scopedEntries
operator|.
name|getAccessEntries
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|defaultEntries
init|=
name|scopedEntries
operator|.
name|getDefaultEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|accessEntries
operator|.
name|size
argument_list|()
operator|>
name|MAX_ENTRIES
condition|)
block|{
throw|throw
operator|new
name|AclException
argument_list|(
literal|"Invalid ACL: ACL has "
operator|+
name|accessEntries
operator|.
name|size
argument_list|()
operator|+
literal|" access entries, which exceeds maximum of "
operator|+
name|MAX_ENTRIES
operator|+
literal|"."
argument_list|)
throw|;
block|}
if|if
condition|(
name|defaultEntries
operator|.
name|size
argument_list|()
operator|>
name|MAX_ENTRIES
condition|)
block|{
throw|throw
operator|new
name|AclException
argument_list|(
literal|"Invalid ACL: ACL has "
operator|+
name|defaultEntries
operator|.
name|size
argument_list|()
operator|+
literal|" default entries, which exceeds maximum of "
operator|+
name|MAX_ENTRIES
operator|+
literal|"."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Calculates mask entries required for the ACL.  Mask calculation is performed    * separately for each scope: access and default.  This method is responsible    * for handling the following cases of mask calculation:    * 1. Throws an exception if the caller attempts to remove the mask entry of an    *   existing ACL that requires it.  If the ACL has any named entries, then a    *   mask entry is required.    * 2. If the caller supplied a mask in the ACL spec, use it.    * 3. If the caller did not supply a mask, but there are ACL entry changes in    *   this scope, then automatically calculate a new mask.  The permissions of    *   the new mask are the union of the permissions on the group entry and all    *   named entries.    *    * @param aclBuilder ArrayList<AclEntry> containing entries to build    * @param providedMask EnumMap<AclEntryScope, AclEntry> mapping each scope to    *   the mask entry that was provided for that scope (if provided)    * @param maskDirty EnumSet<AclEntryScope> which contains a scope if the mask    *   entry is dirty (added or deleted) in that scope    * @param scopeDirty EnumSet<AclEntryScope> which contains a scope if any entry    *   is dirty (added or deleted) in that scope    * @throws AclException if validation fails    */
DECL|method|calculateMasks (List<AclEntry> aclBuilder, EnumMap<AclEntryScope, AclEntry> providedMask, EnumSet<AclEntryScope> maskDirty, EnumSet<AclEntryScope> scopeDirty)
specifier|private
specifier|static
name|void
name|calculateMasks
parameter_list|(
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclBuilder
parameter_list|,
name|EnumMap
argument_list|<
name|AclEntryScope
argument_list|,
name|AclEntry
argument_list|>
name|providedMask
parameter_list|,
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|maskDirty
parameter_list|,
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|scopeDirty
parameter_list|)
throws|throws
name|AclException
block|{
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|scopeFound
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumMap
argument_list|<
name|AclEntryScope
argument_list|,
name|FsAction
argument_list|>
name|unionPerms
init|=
name|Maps
operator|.
name|newEnumMap
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
name|EnumSet
argument_list|<
name|AclEntryScope
argument_list|>
name|maskNeeded
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|AclEntryScope
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Determine which scopes are present, which scopes need a mask, and the
comment|// union of group class permissions in each scope.
for|for
control|(
name|AclEntry
name|entry
range|:
name|aclBuilder
control|)
block|{
name|scopeFound
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|.
name|getType
argument_list|()
operator|==
name|GROUP
operator|||
name|entry
operator|.
name|getName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|FsAction
name|scopeUnionPerms
init|=
name|unionPerms
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getScope
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|scopeUnionPerms
operator|==
literal|null
condition|)
block|{
name|scopeUnionPerms
operator|=
name|FsAction
operator|.
name|NONE
expr_stmt|;
block|}
name|unionPerms
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getScope
argument_list|()
argument_list|,
name|scopeUnionPerms
operator|.
name|or
argument_list|(
name|entry
operator|.
name|getPermission
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|maskNeeded
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getScope
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add mask entry if needed in each scope.
for|for
control|(
name|AclEntryScope
name|scope
range|:
name|scopeFound
control|)
block|{
if|if
condition|(
operator|!
name|providedMask
operator|.
name|containsKey
argument_list|(
name|scope
argument_list|)
operator|&&
name|maskNeeded
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
operator|&&
name|maskDirty
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
condition|)
block|{
comment|// Caller explicitly removed mask entry, but it's required.
throw|throw
operator|new
name|AclException
argument_list|(
literal|"Invalid ACL: mask is required and cannot be deleted."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|providedMask
operator|.
name|containsKey
argument_list|(
name|scope
argument_list|)
operator|&&
operator|(
operator|!
name|scopeDirty
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
operator|||
name|maskDirty
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
operator|)
condition|)
block|{
comment|// Caller explicitly provided new mask, or we are preserving the existing
comment|// mask in an unchanged scope.
name|aclBuilder
operator|.
name|add
argument_list|(
name|providedMask
operator|.
name|get
argument_list|(
name|scope
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maskNeeded
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
operator|||
name|providedMask
operator|.
name|containsKey
argument_list|(
name|scope
argument_list|)
condition|)
block|{
comment|// Otherwise, if there are maskable entries present, or the ACL
comment|// previously had a mask, then recalculate a mask automatically.
name|aclBuilder
operator|.
name|add
argument_list|(
operator|new
name|AclEntry
operator|.
name|Builder
argument_list|()
operator|.
name|setScope
argument_list|(
name|scope
argument_list|)
operator|.
name|setType
argument_list|(
name|MASK
argument_list|)
operator|.
name|setPermission
argument_list|(
name|unionPerms
operator|.
name|get
argument_list|(
name|scope
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Adds unspecified default entries by copying permissions from the    * corresponding access entries.    *    * @param aclBuilder ArrayList<AclEntry> containing entries to build    */
DECL|method|copyDefaultsIfNeeded (List<AclEntry> aclBuilder)
specifier|private
specifier|static
name|void
name|copyDefaultsIfNeeded
parameter_list|(
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclBuilder
parameter_list|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|aclBuilder
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
expr_stmt|;
name|ScopedAclEntries
name|scopedEntries
init|=
operator|new
name|ScopedAclEntries
argument_list|(
name|aclBuilder
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|scopedEntries
operator|.
name|getDefaultEntries
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|AclEntry
argument_list|>
name|accessEntries
init|=
name|scopedEntries
operator|.
name|getAccessEntries
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|defaultEntries
init|=
name|scopedEntries
operator|.
name|getDefaultEntries
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|copiedEntries
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
literal|3
argument_list|)
decl_stmt|;
for|for
control|(
name|AclEntryType
name|type
range|:
name|EnumSet
operator|.
name|of
argument_list|(
name|USER
argument_list|,
name|GROUP
argument_list|,
name|OTHER
argument_list|)
control|)
block|{
name|AclEntry
name|defaultEntryKey
init|=
operator|new
name|AclEntry
operator|.
name|Builder
argument_list|()
operator|.
name|setScope
argument_list|(
name|DEFAULT
argument_list|)
operator|.
name|setType
argument_list|(
name|type
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|int
name|defaultEntryIndex
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|defaultEntries
argument_list|,
name|defaultEntryKey
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultEntryIndex
operator|<
literal|0
condition|)
block|{
name|AclEntry
name|accessEntryKey
init|=
operator|new
name|AclEntry
operator|.
name|Builder
argument_list|()
operator|.
name|setScope
argument_list|(
name|ACCESS
argument_list|)
operator|.
name|setType
argument_list|(
name|type
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|int
name|accessEntryIndex
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|accessEntries
argument_list|,
name|accessEntryKey
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|accessEntryIndex
operator|>=
literal|0
condition|)
block|{
name|copiedEntries
operator|.
name|add
argument_list|(
operator|new
name|AclEntry
operator|.
name|Builder
argument_list|()
operator|.
name|setScope
argument_list|(
name|DEFAULT
argument_list|)
operator|.
name|setType
argument_list|(
name|type
argument_list|)
operator|.
name|setPermission
argument_list|(
name|accessEntries
operator|.
name|get
argument_list|(
name|accessEntryIndex
argument_list|)
operator|.
name|getPermission
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Add all copied entries when done to prevent potential issues with binary
comment|// search on a modified aclBulider during the main loop.
name|aclBuilder
operator|.
name|addAll
argument_list|(
name|copiedEntries
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * An ACL spec that has been pre-validated and sorted.    */
DECL|class|ValidatedAclSpec
specifier|private
specifier|static
specifier|final
class|class
name|ValidatedAclSpec
implements|implements
name|Iterable
argument_list|<
name|AclEntry
argument_list|>
block|{
DECL|field|aclSpec
specifier|private
specifier|final
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
decl_stmt|;
comment|/**      * Creates a ValidatedAclSpec by pre-validating and sorting the given ACL      * entries.  Pre-validation checks that it does not exceed the maximum      * entries.  This check is performed before modifying the ACL, and it's      * actually insufficient for enforcing the maximum number of entries.      * Transformation logic can create additional entries automatically,such as      * the mask and some of the default entries, so we also need additional      * checks during transformation.  The up-front check is still valuable here      * so that we don't run a lot of expensive transformation logic while      * holding the namesystem lock for an attacker who intentionally sent a huge      * ACL spec.      *      * @param aclSpec List<AclEntry> containing unvalidated input ACL spec      * @throws AclException if validation fails      */
DECL|method|ValidatedAclSpec (List<AclEntry> aclSpec)
specifier|public
name|ValidatedAclSpec
parameter_list|(
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|AclException
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|aclSpec
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
expr_stmt|;
name|checkMaxEntries
argument_list|(
operator|new
name|ScopedAclEntries
argument_list|(
name|aclSpec
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|aclSpec
operator|=
name|aclSpec
expr_stmt|;
block|}
comment|/**      * Returns true if this contains an entry matching the given key.  An ACL      * entry's key consists of scope, type and name (but not permission).      *      * @param key AclEntry search key      * @return boolean true if found      */
DECL|method|containsKey (AclEntry key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|AclEntry
name|key
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|binarySearch
argument_list|(
name|aclSpec
argument_list|,
name|key
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
operator|>=
literal|0
return|;
block|}
comment|/**      * Returns the entry matching the given key or null if not found.  An ACL      * entry's key consists of scope, type and name (but not permission).      *      * @param key AclEntry search key      * @return AclEntry entry matching the given key or null if not found      */
DECL|method|findByKey (AclEntry key)
specifier|public
name|AclEntry
name|findByKey
parameter_list|(
name|AclEntry
name|key
parameter_list|)
block|{
name|int
name|index
init|=
name|Collections
operator|.
name|binarySearch
argument_list|(
name|aclSpec
argument_list|,
name|key
argument_list|,
name|ACL_ENTRY_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
return|return
name|aclSpec
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|AclEntry
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|aclSpec
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

