begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|NotCompliantMBeanException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|StandardMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|DF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|DU
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|GenerationStamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|metrics
operator|.
name|FSDatasetMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|InterDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReplicaRecoveryInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskErrorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskOutOfSpaceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_comment
comment|/**************************************************  * FSDataset manages a set of data blocks.  Each block  * has a unique name and an extent on disk.  *  ***************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|FSDataset
specifier|public
class|class
name|FSDataset
implements|implements
name|FSDatasetInterface
block|{
comment|/**    * A node type that can be built into a tree reflecting the    * hierarchy of blocks on the local disk.    */
DECL|class|FSDir
class|class
name|FSDir
block|{
DECL|field|dir
name|File
name|dir
decl_stmt|;
DECL|field|numBlocks
name|int
name|numBlocks
init|=
literal|0
decl_stmt|;
DECL|field|children
name|FSDir
name|children
index|[]
decl_stmt|;
DECL|field|lastChildIdx
name|int
name|lastChildIdx
init|=
literal|0
decl_stmt|;
comment|/**      */
DECL|method|FSDir (File dir)
specifier|public
name|FSDir
parameter_list|(
name|File
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|this
operator|.
name|children
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|dir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|File
index|[]
name|files
init|=
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FSDir
argument_list|>
name|dirList
init|=
operator|new
name|ArrayList
argument_list|<
name|FSDir
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|files
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|files
index|[
name|idx
index|]
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|dirList
operator|.
name|add
argument_list|(
operator|new
name|FSDir
argument_list|(
name|files
index|[
name|idx
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Block
operator|.
name|isBlockFilename
argument_list|(
name|files
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|numBlocks
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dirList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|children
operator|=
name|dirList
operator|.
name|toArray
argument_list|(
operator|new
name|FSDir
index|[
name|dirList
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|addBlock (Block b, File src)
specifier|public
name|File
name|addBlock
parameter_list|(
name|Block
name|b
parameter_list|,
name|File
name|src
parameter_list|)
throws|throws
name|IOException
block|{
comment|//First try without creating subdirectories
name|File
name|file
init|=
name|addBlock
argument_list|(
name|b
argument_list|,
name|src
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|(
name|file
operator|!=
literal|null
operator|)
condition|?
name|file
else|:
name|addBlock
argument_list|(
name|b
argument_list|,
name|src
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|addBlock (Block b, File src, boolean createOk, boolean resetIdx)
specifier|private
name|File
name|addBlock
parameter_list|(
name|Block
name|b
parameter_list|,
name|File
name|src
parameter_list|,
name|boolean
name|createOk
parameter_list|,
name|boolean
name|resetIdx
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|numBlocks
operator|<
name|maxBlocksPerDir
condition|)
block|{
specifier|final
name|File
name|dest
init|=
name|moveBlockFiles
argument_list|(
name|b
argument_list|,
name|src
argument_list|,
name|dir
argument_list|)
decl_stmt|;
name|numBlocks
operator|+=
literal|1
expr_stmt|;
return|return
name|dest
return|;
block|}
if|if
condition|(
name|lastChildIdx
operator|<
literal|0
operator|&&
name|resetIdx
condition|)
block|{
comment|//reset so that all children will be checked
name|lastChildIdx
operator|=
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|children
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastChildIdx
operator|>=
literal|0
operator|&&
name|children
operator|!=
literal|null
condition|)
block|{
comment|//Check if any child-tree has room for a block.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
operator|(
name|lastChildIdx
operator|+
name|i
operator|)
operator|%
name|children
operator|.
name|length
decl_stmt|;
name|File
name|file
init|=
name|children
index|[
name|idx
index|]
operator|.
name|addBlock
argument_list|(
name|b
argument_list|,
name|src
argument_list|,
literal|false
argument_list|,
name|resetIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|lastChildIdx
operator|=
name|idx
expr_stmt|;
return|return
name|file
return|;
block|}
block|}
name|lastChildIdx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|createOk
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|children
operator|==
literal|null
operator|||
name|children
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|children
operator|=
operator|new
name|FSDir
index|[
name|maxBlocksPerDir
index|]
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|maxBlocksPerDir
condition|;
name|idx
operator|++
control|)
block|{
name|children
index|[
name|idx
index|]
operator|=
operator|new
name|FSDir
argument_list|(
operator|new
name|File
argument_list|(
name|dir
argument_list|,
name|DataStorage
operator|.
name|BLOCK_SUBDIR_PREFIX
operator|+
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//now pick a child randomly for creating a new set of subdirs.
name|lastChildIdx
operator|=
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|children
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|children
index|[
name|lastChildIdx
index|]
operator|.
name|addBlock
argument_list|(
name|b
argument_list|,
name|src
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|getVolumeMap (String bpid, ReplicasMap volumeMap, FSVolume volume)
name|void
name|getVolumeMap
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicasMap
name|volumeMap
parameter_list|,
name|FSVolume
name|volume
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|children
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|children
index|[
name|i
index|]
operator|.
name|getVolumeMap
argument_list|(
name|bpid
argument_list|,
name|volumeMap
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
block|}
name|recoverTempUnlinkedBlock
argument_list|()
expr_stmt|;
name|volume
operator|.
name|addToReplicasMap
argument_list|(
name|bpid
argument_list|,
name|volumeMap
argument_list|,
name|dir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Recover unlinked tmp files on datanode restart. If the original block      * does not exist, then the tmp file is renamed to be the      * original file name; otherwise the tmp file is deleted.      */
DECL|method|recoverTempUnlinkedBlock ()
specifier|private
name|void
name|recoverTempUnlinkedBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|files
index|[]
init|=
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|dir
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
operator|!
name|FSDataset
operator|.
name|isUnlinkTmpFile
argument_list|(
name|file
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|File
name|blockFile
init|=
name|getOrigFile
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockFile
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//
comment|// If the original block file still exists, then no recovery
comment|// is needed.
comment|//
if|if
condition|(
operator|!
name|file
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to cleanup unlinked tmp file "
operator|+
name|file
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|renameTo
argument_list|(
name|blockFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to cleanup detached file "
operator|+
name|file
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * check if a data diretory is healthy      * @throws DiskErrorException      */
DECL|method|checkDirTree ()
specifier|public
name|void
name|checkDirTree
parameter_list|()
throws|throws
name|DiskErrorException
block|{
name|DiskChecker
operator|.
name|checkDir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|children
index|[
name|i
index|]
operator|.
name|checkDirTree
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|clearPath (File f)
name|void
name|clearPath
parameter_list|(
name|File
name|f
parameter_list|)
block|{
name|String
name|root
init|=
name|dir
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
name|String
name|dir
init|=
name|f
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|startsWith
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|String
index|[]
name|dirNames
init|=
name|dir
operator|.
name|substring
argument_list|(
name|root
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|split
argument_list|(
name|File
operator|.
name|separator
operator|+
literal|"subdir"
argument_list|)
decl_stmt|;
if|if
condition|(
name|clearPath
argument_list|(
name|f
argument_list|,
name|dirNames
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
block|}
name|clearPath
argument_list|(
name|f
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * dirNames is an array of string integers derived from      * usual directory structure data/subdirN/subdirXY/subdirM ...      * If dirName array is non-null, we only check the child at       * the children[dirNames[idx]]. This avoids iterating over      * children in common case. If directory structure changes       * in later versions, we need to revisit this.      */
DECL|method|clearPath (File f, String[] dirNames, int idx)
specifier|private
name|boolean
name|clearPath
parameter_list|(
name|File
name|f
parameter_list|,
name|String
index|[]
name|dirNames
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dirNames
operator|==
literal|null
operator|||
name|idx
operator|==
name|dirNames
operator|.
name|length
operator|)
operator|&&
name|dir
operator|.
name|compareTo
argument_list|(
name|f
argument_list|)
operator|==
literal|0
condition|)
block|{
name|numBlocks
operator|--
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|dirNames
operator|!=
literal|null
condition|)
block|{
comment|//guess the child index from the directory name
if|if
condition|(
name|idx
operator|>
operator|(
name|dirNames
operator|.
name|length
operator|-
literal|1
operator|)
operator|||
name|children
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|childIdx
decl_stmt|;
try|try
block|{
name|childIdx
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|dirNames
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ignored
parameter_list|)
block|{
comment|// layout changed? we could print a warning.
return|return
literal|false
return|;
block|}
return|return
operator|(
name|childIdx
operator|>=
literal|0
operator|&&
name|childIdx
operator|<
name|children
operator|.
name|length
operator|)
condition|?
name|children
index|[
name|childIdx
index|]
operator|.
name|clearPath
argument_list|(
name|f
argument_list|,
name|dirNames
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
else|:
literal|false
return|;
block|}
comment|//guesses failed. back to blind iteration.
if|if
condition|(
name|children
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|children
index|[
name|i
index|]
operator|.
name|clearPath
argument_list|(
name|f
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSDir{"
operator|+
literal|"dir="
operator|+
name|dir
operator|+
literal|", children="
operator|+
operator|(
name|children
operator|==
literal|null
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|children
argument_list|)
operator|)
operator|+
literal|"}"
return|;
block|}
block|}
comment|/**    * A BlockPoolSlice represents a portion of a BlockPool stored on a volume.      * Taken together, all BlockPoolSlices sharing a block pool ID across a     * cluster represent a single block pool.    */
DECL|class|BlockPoolSlice
class|class
name|BlockPoolSlice
block|{
DECL|field|bpid
specifier|private
specifier|final
name|String
name|bpid
decl_stmt|;
DECL|field|volume
specifier|private
specifier|final
name|FSVolume
name|volume
decl_stmt|;
comment|// volume to which this BlockPool belongs to
DECL|field|currentDir
specifier|private
specifier|final
name|File
name|currentDir
decl_stmt|;
comment|// StorageDirectory/current/bpid/current
DECL|field|finalizedDir
specifier|private
specifier|final
name|FSDir
name|finalizedDir
decl_stmt|;
comment|// directory store Finalized replica
DECL|field|rbwDir
specifier|private
specifier|final
name|File
name|rbwDir
decl_stmt|;
comment|// directory store RBW replica
DECL|field|tmpDir
specifier|private
specifier|final
name|File
name|tmpDir
decl_stmt|;
comment|// directory store Temporary replica
comment|// TODO:FEDERATION scalability issue - a thread per DU is needed
DECL|field|dfsUsage
specifier|private
specifier|final
name|DU
name|dfsUsage
decl_stmt|;
comment|/**      *       * @param bpid Block pool Id      * @param volume {@link FSVolume} to which this BlockPool belongs to      * @param bpDir directory corresponding to the BlockPool      * @param conf      * @throws IOException      */
DECL|method|BlockPoolSlice (String bpid, FSVolume volume, File bpDir, Configuration conf)
name|BlockPoolSlice
parameter_list|(
name|String
name|bpid
parameter_list|,
name|FSVolume
name|volume
parameter_list|,
name|File
name|bpDir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|bpid
operator|=
name|bpid
expr_stmt|;
name|this
operator|.
name|volume
operator|=
name|volume
expr_stmt|;
name|this
operator|.
name|currentDir
operator|=
operator|new
name|File
argument_list|(
name|bpDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_CURRENT
argument_list|)
expr_stmt|;
specifier|final
name|File
name|finalizedDir
init|=
operator|new
name|File
argument_list|(
name|currentDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_FINALIZED
argument_list|)
decl_stmt|;
comment|// Files that were being written when the datanode was last shutdown
comment|// are now moved back to the data directory. It is possible that
comment|// in the future, we might want to do some sort of datanode-local
comment|// recovery for these blocks. For example, crc validation.
comment|//
name|this
operator|.
name|tmpDir
operator|=
operator|new
name|File
argument_list|(
name|bpDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_TMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpDir
operator|.
name|exists
argument_list|()
condition|)
block|{
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|rbwDir
operator|=
operator|new
name|File
argument_list|(
name|currentDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_RBW
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbwDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|supportAppends
condition|)
block|{
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|rbwDir
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|finalizedDir
operator|=
operator|new
name|FSDir
argument_list|(
name|finalizedDir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rbwDir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
comment|// create rbw directory if not exist
if|if
condition|(
operator|!
name|rbwDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|rbwDir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|tmpDir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|tmpDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|tmpDir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|dfsUsage
operator|=
operator|new
name|DU
argument_list|(
name|bpDir
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|dfsUsage
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|getDirectory ()
name|File
name|getDirectory
parameter_list|()
block|{
return|return
name|currentDir
operator|.
name|getParentFile
argument_list|()
return|;
block|}
DECL|method|getCurrentDir ()
name|File
name|getCurrentDir
parameter_list|()
block|{
return|return
name|currentDir
return|;
block|}
DECL|method|getFinalizedDir ()
name|File
name|getFinalizedDir
parameter_list|()
block|{
return|return
name|finalizedDir
operator|.
name|dir
return|;
block|}
DECL|method|getRbwDir ()
name|File
name|getRbwDir
parameter_list|()
block|{
return|return
name|rbwDir
return|;
block|}
DECL|method|decDfsUsed (long value)
name|void
name|decDfsUsed
parameter_list|(
name|long
name|value
parameter_list|)
block|{
comment|// The caller to this method (BlockFileDeleteTask.run()) does
comment|// not have locked FSDataset.this yet.
synchronized|synchronized
init|(
name|FSDataset
operator|.
name|this
init|)
block|{
name|dfsUsage
operator|.
name|decDfsUsed
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getDfsUsed ()
name|long
name|getDfsUsed
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dfsUsage
operator|.
name|getUsed
argument_list|()
return|;
block|}
comment|/**      * Temporary files. They get moved to the finalized block directory when      * the block is finalized.      */
DECL|method|createTmpFile (Block b)
name|File
name|createTmpFile
parameter_list|(
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|tmpDir
argument_list|,
name|b
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|FSDataset
operator|.
name|createTmpFile
argument_list|(
name|b
argument_list|,
name|f
argument_list|)
return|;
block|}
comment|/**      * RBW files. They get moved to the finalized block directory when      * the block is finalized.      */
DECL|method|createRbwFile (Block b)
name|File
name|createRbwFile
parameter_list|(
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|rbwDir
argument_list|,
name|b
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|FSDataset
operator|.
name|createTmpFile
argument_list|(
name|b
argument_list|,
name|f
argument_list|)
return|;
block|}
DECL|method|addBlock (Block b, File f)
name|File
name|addBlock
parameter_list|(
name|Block
name|b
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|blockFile
init|=
name|finalizedDir
operator|.
name|addBlock
argument_list|(
name|b
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|File
name|metaFile
init|=
name|getMetaFile
argument_list|(
name|blockFile
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
name|dfsUsage
operator|.
name|incDfsUsed
argument_list|(
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
name|metaFile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|blockFile
return|;
block|}
DECL|method|checkDirs ()
name|void
name|checkDirs
parameter_list|()
throws|throws
name|DiskErrorException
block|{
name|finalizedDir
operator|.
name|checkDirTree
argument_list|()
expr_stmt|;
name|DiskChecker
operator|.
name|checkDir
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
name|DiskChecker
operator|.
name|checkDir
argument_list|(
name|rbwDir
argument_list|)
expr_stmt|;
block|}
DECL|method|getVolumeMap (ReplicasMap volumeMap)
name|void
name|getVolumeMap
parameter_list|(
name|ReplicasMap
name|volumeMap
parameter_list|)
throws|throws
name|IOException
block|{
comment|// add finalized replicas
name|finalizedDir
operator|.
name|getVolumeMap
argument_list|(
name|bpid
argument_list|,
name|volumeMap
argument_list|,
name|volume
argument_list|)
expr_stmt|;
comment|// add rbw replicas
name|addToReplicasMap
argument_list|(
name|volumeMap
argument_list|,
name|rbwDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add replicas under the given directory to the volume map      * @param volumeMap the replicas map      * @param dir an input directory      * @param isFinalized true if the directory has finalized replicas;      *                    false if the directory has rbw replicas      */
DECL|method|addToReplicasMap (ReplicasMap volumeMap, File dir, boolean isFinalized)
specifier|private
name|void
name|addToReplicasMap
parameter_list|(
name|ReplicasMap
name|volumeMap
parameter_list|,
name|File
name|dir
parameter_list|,
name|boolean
name|isFinalized
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|blockFiles
index|[]
init|=
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|dir
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|blockFile
range|:
name|blockFiles
control|)
block|{
if|if
condition|(
operator|!
name|Block
operator|.
name|isBlockFilename
argument_list|(
name|blockFile
argument_list|)
condition|)
continue|continue;
name|long
name|genStamp
init|=
name|getGenerationStampFromFile
argument_list|(
name|blockFiles
argument_list|,
name|blockFile
argument_list|)
decl_stmt|;
name|long
name|blockId
init|=
name|Block
operator|.
name|filename2id
argument_list|(
name|blockFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|ReplicaInfo
name|newReplica
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isFinalized
condition|)
block|{
name|newReplica
operator|=
operator|new
name|FinalizedReplica
argument_list|(
name|blockId
argument_list|,
name|blockFile
operator|.
name|length
argument_list|()
argument_list|,
name|genStamp
argument_list|,
name|volume
argument_list|,
name|blockFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newReplica
operator|=
operator|new
name|ReplicaWaitingToBeRecovered
argument_list|(
name|blockId
argument_list|,
name|validateIntegrity
argument_list|(
name|blockFile
argument_list|,
name|genStamp
argument_list|)
argument_list|,
name|genStamp
argument_list|,
name|volume
argument_list|,
name|blockFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ReplicaInfo
name|oldReplica
init|=
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplica
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldReplica
operator|!=
literal|null
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Two block files with the same block id exist "
operator|+
literal|"on disk: "
operator|+
name|oldReplica
operator|.
name|getBlockFile
argument_list|()
operator|+
literal|" and "
operator|+
name|blockFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Find out the number of bytes in the block that match its crc.      *       * This algorithm assumes that data corruption caused by unexpected       * datanode shutdown occurs only in the last crc chunk. So it checks      * only the last chunk.      *       * @param blockFile the block file      * @param genStamp generation stamp of the block      * @return the number of valid bytes      */
DECL|method|validateIntegrity (File blockFile, long genStamp)
specifier|private
name|long
name|validateIntegrity
parameter_list|(
name|File
name|blockFile
parameter_list|,
name|long
name|genStamp
parameter_list|)
block|{
name|DataInputStream
name|checksumIn
init|=
literal|null
decl_stmt|;
name|InputStream
name|blockIn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|File
name|metaFile
init|=
operator|new
name|File
argument_list|(
name|getMetaFileName
argument_list|(
name|blockFile
operator|.
name|toString
argument_list|()
argument_list|,
name|genStamp
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|blockFileLen
init|=
name|blockFile
operator|.
name|length
argument_list|()
decl_stmt|;
name|long
name|metaFileLen
init|=
name|metaFile
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|crcHeaderLen
init|=
name|DataChecksum
operator|.
name|getChecksumHeaderSize
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|blockFile
operator|.
name|exists
argument_list|()
operator|||
name|blockFileLen
operator|==
literal|0
operator|||
operator|!
name|metaFile
operator|.
name|exists
argument_list|()
operator|||
name|metaFileLen
operator|<
operator|(
name|long
operator|)
name|crcHeaderLen
condition|)
block|{
return|return
literal|0
return|;
block|}
name|checksumIn
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|metaFile
argument_list|)
argument_list|,
name|HdfsConstants
operator|.
name|IO_FILE_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|// read and handle the common header here. For now just a version
name|BlockMetadataHeader
name|header
init|=
name|BlockMetadataHeader
operator|.
name|readHeader
argument_list|(
name|checksumIn
argument_list|)
decl_stmt|;
name|short
name|version
init|=
name|header
operator|.
name|getVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|!=
name|FSDataset
operator|.
name|METADATA_VERSION
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Wrong version ("
operator|+
name|version
operator|+
literal|") for metadata file "
operator|+
name|metaFile
operator|+
literal|" ignoring ..."
argument_list|)
expr_stmt|;
block|}
name|DataChecksum
name|checksum
init|=
name|header
operator|.
name|getChecksum
argument_list|()
decl_stmt|;
name|int
name|bytesPerChecksum
init|=
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
decl_stmt|;
name|int
name|checksumSize
init|=
name|checksum
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
name|long
name|numChunks
init|=
name|Math
operator|.
name|min
argument_list|(
operator|(
name|blockFileLen
operator|+
name|bytesPerChecksum
operator|-
literal|1
operator|)
operator|/
name|bytesPerChecksum
argument_list|,
operator|(
name|metaFileLen
operator|-
name|crcHeaderLen
operator|)
operator|/
name|checksumSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|numChunks
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|IOUtils
operator|.
name|skipFully
argument_list|(
name|checksumIn
argument_list|,
operator|(
name|numChunks
operator|-
literal|1
operator|)
operator|*
name|checksumSize
argument_list|)
expr_stmt|;
name|blockIn
operator|=
operator|new
name|FileInputStream
argument_list|(
name|blockFile
argument_list|)
expr_stmt|;
name|long
name|lastChunkStartPos
init|=
operator|(
name|numChunks
operator|-
literal|1
operator|)
operator|*
name|bytesPerChecksum
decl_stmt|;
name|IOUtils
operator|.
name|skipFully
argument_list|(
name|blockIn
argument_list|,
name|lastChunkStartPos
argument_list|)
expr_stmt|;
name|int
name|lastChunkSize
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|bytesPerChecksum
argument_list|,
name|blockFileLen
operator|-
name|lastChunkStartPos
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|lastChunkSize
operator|+
name|checksumSize
index|]
decl_stmt|;
name|checksumIn
operator|.
name|readFully
argument_list|(
name|buf
argument_list|,
name|lastChunkSize
argument_list|,
name|checksumSize
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|blockIn
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|lastChunkSize
argument_list|)
expr_stmt|;
name|checksum
operator|.
name|update
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|lastChunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|.
name|compare
argument_list|(
name|buf
argument_list|,
name|lastChunkSize
argument_list|)
condition|)
block|{
comment|// last chunk matches crc
return|return
name|lastChunkStartPos
operator|+
name|lastChunkSize
return|;
block|}
else|else
block|{
comment|// last chunck is corrupt
return|return
name|lastChunkStartPos
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|checksumIn
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|blockIn
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|clearPath (File f)
name|void
name|clearPath
parameter_list|(
name|File
name|f
parameter_list|)
block|{
name|finalizedDir
operator|.
name|clearPath
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|currentDir
operator|.
name|getAbsolutePath
argument_list|()
return|;
block|}
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|dfsUsage
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|FSVolume
class|class
name|FSVolume
block|{
DECL|field|map
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|currentDir
specifier|private
specifier|final
name|File
name|currentDir
decl_stmt|;
comment|//<StorageDirectory>/current
DECL|field|usage
specifier|private
specifier|final
name|DF
name|usage
decl_stmt|;
DECL|field|reserved
specifier|private
specifier|final
name|long
name|reserved
decl_stmt|;
DECL|method|FSVolume (File currentDir, Configuration conf)
name|FSVolume
parameter_list|(
name|File
name|currentDir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|reserved
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DU_RESERVED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DU_RESERVED_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|currentDir
operator|=
name|currentDir
expr_stmt|;
name|File
name|parent
init|=
name|currentDir
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
name|this
operator|.
name|usage
operator|=
operator|new
name|DF
argument_list|(
name|parent
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/** Return storage directory corresponding to the volume */
DECL|method|getDir ()
specifier|public
name|File
name|getDir
parameter_list|()
block|{
return|return
name|currentDir
operator|.
name|getParentFile
argument_list|()
return|;
block|}
DECL|method|getCurrentDir ()
specifier|public
name|File
name|getCurrentDir
parameter_list|()
block|{
return|return
name|currentDir
return|;
block|}
DECL|method|getRbwDir (String bpid)
specifier|public
name|File
name|getRbwDir
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockPoolSlice
name|bp
init|=
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
return|return
name|bp
operator|.
name|getRbwDir
argument_list|()
return|;
block|}
DECL|method|decDfsUsed (String bpid, long value)
name|void
name|decDfsUsed
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|value
parameter_list|)
block|{
comment|// The caller to this method (BlockFileDeleteTask.run()) does
comment|// not have locked FSDataset.this yet.
synchronized|synchronized
init|(
name|FSDataset
operator|.
name|this
init|)
block|{
name|BlockPoolSlice
name|bp
init|=
name|map
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bp
operator|!=
literal|null
condition|)
block|{
name|bp
operator|.
name|decDfsUsed
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getDfsUsed ()
name|long
name|getDfsUsed
parameter_list|()
throws|throws
name|IOException
block|{
comment|// TODO valid synchronization
name|long
name|dfsUsed
init|=
literal|0
decl_stmt|;
name|Set
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
argument_list|>
name|set
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
name|entry
range|:
name|set
control|)
block|{
name|dfsUsed
operator|+=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getDfsUsed
argument_list|()
expr_stmt|;
block|}
return|return
name|dfsUsed
return|;
block|}
DECL|method|getBlockPoolUsed (String bpid)
name|long
name|getBlockPoolUsed
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
operator|.
name|getDfsUsed
argument_list|()
return|;
block|}
comment|/**      * Calculate the capacity of the filesystem, after removing any      * reserved capacity.      * @return the unreserved number of bytes left in this filesystem. May be zero.      */
DECL|method|getCapacity ()
name|long
name|getCapacity
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|remaining
init|=
name|usage
operator|.
name|getCapacity
argument_list|()
operator|-
name|reserved
decl_stmt|;
return|return
name|remaining
operator|>
literal|0
condition|?
name|remaining
else|:
literal|0
return|;
block|}
DECL|method|getAvailable ()
name|long
name|getAvailable
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|remaining
init|=
name|getCapacity
argument_list|()
operator|-
name|getDfsUsed
argument_list|()
decl_stmt|;
name|long
name|available
init|=
name|usage
operator|.
name|getAvailable
argument_list|()
decl_stmt|;
if|if
condition|(
name|remaining
operator|>
name|available
condition|)
block|{
name|remaining
operator|=
name|available
expr_stmt|;
block|}
return|return
operator|(
name|remaining
operator|>
literal|0
operator|)
condition|?
name|remaining
else|:
literal|0
return|;
block|}
DECL|method|getReserved ()
name|long
name|getReserved
parameter_list|()
block|{
return|return
name|reserved
return|;
block|}
DECL|method|getMount ()
name|String
name|getMount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|usage
operator|.
name|getMount
argument_list|()
return|;
block|}
DECL|method|getBlockPoolSlice (String bpid)
name|BlockPoolSlice
name|getBlockPoolSlice
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockPoolSlice
name|bp
init|=
name|map
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bp
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block pool "
operator|+
name|bpid
operator|+
literal|" is not found"
argument_list|)
throw|;
block|}
return|return
name|bp
return|;
block|}
comment|/**      * Make a deep copy of the list of currently active BPIDs      */
DECL|method|getBlockPoolList ()
name|String
index|[]
name|getBlockPoolList
parameter_list|()
block|{
synchronized|synchronized
init|(
name|FSDataset
operator|.
name|this
init|)
block|{
return|return
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/**      * Temporary files. They get moved to the finalized block directory when      * the block is finalized.      */
DECL|method|createTmpFile (String bpid, Block b)
name|File
name|createTmpFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockPoolSlice
name|bp
init|=
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
return|return
name|bp
operator|.
name|createTmpFile
argument_list|(
name|b
argument_list|)
return|;
block|}
comment|/**      * RBW files. They get moved to the finalized block directory when      * the block is finalized.      */
DECL|method|createRbwFile (String bpid, Block b)
name|File
name|createRbwFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockPoolSlice
name|bp
init|=
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
return|return
name|bp
operator|.
name|createRbwFile
argument_list|(
name|b
argument_list|)
return|;
block|}
DECL|method|addBlock (String bpid, Block b, File f)
name|File
name|addBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|b
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockPoolSlice
name|bp
init|=
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
return|return
name|bp
operator|.
name|addBlock
argument_list|(
name|b
argument_list|,
name|f
argument_list|)
return|;
block|}
DECL|method|checkDirs ()
name|void
name|checkDirs
parameter_list|()
throws|throws
name|DiskErrorException
block|{
comment|// TODO:FEDERATION valid synchronization
name|Set
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
argument_list|>
name|set
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
name|entry
range|:
name|set
control|)
block|{
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|checkDirs
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getVolumeMap (ReplicasMap volumeMap)
name|void
name|getVolumeMap
parameter_list|(
name|ReplicasMap
name|volumeMap
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
argument_list|>
name|set
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
name|entry
range|:
name|set
control|)
block|{
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getVolumeMap
argument_list|(
name|volumeMap
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getVolumeMap (String bpid, ReplicasMap volumeMap)
name|void
name|getVolumeMap
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicasMap
name|volumeMap
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockPoolSlice
name|bp
init|=
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|bp
operator|.
name|getVolumeMap
argument_list|(
name|volumeMap
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add replicas under the given directory to the volume map      * @param volumeMap the replicas map      * @param dir an input directory      * @param isFinalized true if the directory has finalized replicas;      *                    false if the directory has rbw replicas      * @throws IOException       */
DECL|method|addToReplicasMap (String bpid, ReplicasMap volumeMap, File dir, boolean isFinalized)
specifier|private
name|void
name|addToReplicasMap
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicasMap
name|volumeMap
parameter_list|,
name|File
name|dir
parameter_list|,
name|boolean
name|isFinalized
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockPoolSlice
name|bp
init|=
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
comment|// TODO move this up
comment|// dfsUsage.incDfsUsed(b.getNumBytes()+metaFile.length());
name|bp
operator|.
name|addToReplicasMap
argument_list|(
name|volumeMap
argument_list|,
name|dir
argument_list|,
name|isFinalized
argument_list|)
expr_stmt|;
block|}
DECL|method|clearPath (String bpid, File f)
name|void
name|clearPath
parameter_list|(
name|String
name|bpid
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockPoolSlice
name|bp
init|=
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|bp
operator|.
name|clearPath
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|currentDir
operator|.
name|getAbsolutePath
argument_list|()
return|;
block|}
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
argument_list|>
name|set
init|=
name|map
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|BlockPoolSlice
argument_list|>
name|entry
range|:
name|set
control|)
block|{
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addBlockPool (String bpid, Configuration conf)
specifier|public
name|void
name|addBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|bpdir
init|=
operator|new
name|File
argument_list|(
name|currentDir
argument_list|,
name|bpid
argument_list|)
decl_stmt|;
name|BlockPoolSlice
name|bp
init|=
operator|new
name|BlockPoolSlice
argument_list|(
name|bpid
argument_list|,
name|this
argument_list|,
name|bpdir
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|bpid
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
DECL|method|shutdownBlockPool (String bpid)
specifier|public
name|void
name|shutdownBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|BlockPoolSlice
name|bp
init|=
name|map
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bp
operator|!=
literal|null
condition|)
block|{
name|bp
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|map
operator|.
name|remove
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
DECL|method|isBPDirEmpty (String bpid)
specifier|private
name|boolean
name|isBPDirEmpty
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|volumeCurrentDir
init|=
name|this
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
name|File
name|bpDir
init|=
operator|new
name|File
argument_list|(
name|volumeCurrentDir
argument_list|,
name|bpid
argument_list|)
decl_stmt|;
name|File
name|bpCurrentDir
init|=
operator|new
name|File
argument_list|(
name|bpDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_CURRENT
argument_list|)
decl_stmt|;
name|File
name|finalizedDir
init|=
operator|new
name|File
argument_list|(
name|bpCurrentDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_FINALIZED
argument_list|)
decl_stmt|;
name|File
name|rbwDir
init|=
operator|new
name|File
argument_list|(
name|bpCurrentDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_RBW
argument_list|)
decl_stmt|;
if|if
condition|(
name|finalizedDir
operator|.
name|exists
argument_list|()
operator|&&
name|FileUtil
operator|.
name|list
argument_list|(
name|finalizedDir
argument_list|)
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|rbwDir
operator|.
name|exists
argument_list|()
operator|&&
name|FileUtil
operator|.
name|list
argument_list|(
name|rbwDir
argument_list|)
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|deleteBPDirectories (String bpid, boolean force)
specifier|private
name|void
name|deleteBPDirectories
parameter_list|(
name|String
name|bpid
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|volumeCurrentDir
init|=
name|this
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
name|File
name|bpDir
init|=
operator|new
name|File
argument_list|(
name|volumeCurrentDir
argument_list|,
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bpDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// nothing to be deleted
return|return;
block|}
name|File
name|tmpDir
init|=
operator|new
name|File
argument_list|(
name|bpDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_TMP
argument_list|)
decl_stmt|;
name|File
name|bpCurrentDir
init|=
operator|new
name|File
argument_list|(
name|bpDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_CURRENT
argument_list|)
decl_stmt|;
name|File
name|finalizedDir
init|=
operator|new
name|File
argument_list|(
name|bpCurrentDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_FINALIZED
argument_list|)
decl_stmt|;
name|File
name|rbwDir
init|=
operator|new
name|File
argument_list|(
name|bpCurrentDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_RBW
argument_list|)
decl_stmt|;
if|if
condition|(
name|force
condition|)
block|{
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|bpDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rbwDir
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to delete "
operator|+
name|rbwDir
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|finalizedDir
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to delete "
operator|+
name|finalizedDir
argument_list|)
throw|;
block|}
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
for|for
control|(
name|File
name|f
range|:
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|bpCurrentDir
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to delete "
operator|+
name|f
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|bpCurrentDir
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to delete "
operator|+
name|bpCurrentDir
argument_list|)
throw|;
block|}
for|for
control|(
name|File
name|f
range|:
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|bpDir
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to delete "
operator|+
name|f
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|bpDir
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to delete "
operator|+
name|bpDir
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|class|FSVolumeSet
specifier|static
class|class
name|FSVolumeSet
block|{
comment|/*      * Read access to this unmodifiable list is not synchronized.      * This list is replaced on modification holding "this" lock.      */
DECL|field|volumes
specifier|private
specifier|volatile
name|List
argument_list|<
name|FSVolume
argument_list|>
name|volumes
init|=
literal|null
decl_stmt|;
DECL|field|blockChooser
name|BlockVolumeChoosingPolicy
name|blockChooser
decl_stmt|;
DECL|field|numFailedVolumes
name|int
name|numFailedVolumes
decl_stmt|;
DECL|method|FSVolumeSet (FSVolume[] volumes, int failedVols, BlockVolumeChoosingPolicy blockChooser)
name|FSVolumeSet
parameter_list|(
name|FSVolume
index|[]
name|volumes
parameter_list|,
name|int
name|failedVols
parameter_list|,
name|BlockVolumeChoosingPolicy
name|blockChooser
parameter_list|)
block|{
name|List
argument_list|<
name|FSVolume
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|volumes
argument_list|)
decl_stmt|;
name|this
operator|.
name|volumes
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockChooser
operator|=
name|blockChooser
expr_stmt|;
name|this
operator|.
name|numFailedVolumes
operator|=
name|failedVols
expr_stmt|;
block|}
DECL|method|numberOfVolumes ()
specifier|private
name|int
name|numberOfVolumes
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|numberOfFailedVolumes ()
specifier|private
name|int
name|numberOfFailedVolumes
parameter_list|()
block|{
return|return
name|numFailedVolumes
return|;
block|}
comment|/**       * Get next volume. Synchronized to ensure {@link #curVolume} is updated      * by a single thread and next volume is chosen with no concurrent      * update to {@link #volumes}.      * @param blockSize free space needed on the volume      * @return next volume to store the block in.      */
DECL|method|getNextVolume (long blockSize)
specifier|synchronized
name|FSVolume
name|getNextVolume
parameter_list|(
name|long
name|blockSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|blockChooser
operator|.
name|chooseVolume
argument_list|(
name|volumes
argument_list|,
name|blockSize
argument_list|)
return|;
block|}
DECL|method|getDfsUsed ()
specifier|private
name|long
name|getDfsUsed
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|dfsUsed
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|FSVolume
name|vol
range|:
name|volumes
control|)
block|{
name|dfsUsed
operator|+=
name|vol
operator|.
name|getDfsUsed
argument_list|()
expr_stmt|;
block|}
return|return
name|dfsUsed
return|;
block|}
DECL|method|getBlockPoolUsed (String bpid)
specifier|private
name|long
name|getBlockPoolUsed
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|dfsUsed
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|FSVolume
name|vol
range|:
name|volumes
control|)
block|{
name|dfsUsed
operator|+=
name|vol
operator|.
name|getBlockPoolUsed
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
return|return
name|dfsUsed
return|;
block|}
DECL|method|getCapacity ()
specifier|private
name|long
name|getCapacity
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|capacity
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|FSVolume
name|vol
range|:
name|volumes
control|)
block|{
name|capacity
operator|+=
name|vol
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
block|}
return|return
name|capacity
return|;
block|}
DECL|method|getRemaining ()
specifier|private
name|long
name|getRemaining
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|remaining
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|FSVolume
name|vol
range|:
name|volumes
control|)
block|{
name|remaining
operator|+=
name|vol
operator|.
name|getAvailable
argument_list|()
expr_stmt|;
block|}
return|return
name|remaining
return|;
block|}
DECL|method|getVolumeMap (ReplicasMap volumeMap)
specifier|private
name|void
name|getVolumeMap
parameter_list|(
name|ReplicasMap
name|volumeMap
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|FSVolume
name|vol
range|:
name|volumes
control|)
block|{
name|vol
operator|.
name|getVolumeMap
argument_list|(
name|volumeMap
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getVolumeMap (String bpid, ReplicasMap volumeMap)
specifier|private
name|void
name|getVolumeMap
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicasMap
name|volumeMap
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|FSVolume
name|vol
range|:
name|volumes
control|)
block|{
name|vol
operator|.
name|getVolumeMap
argument_list|(
name|bpid
argument_list|,
name|volumeMap
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Calls {@link FSVolume#checkDirs()} on each volume, removing any      * volumes from the active list that result in a DiskErrorException.      *       * This method is synchronized to allow only one instance of checkDirs()       * call      * @return list of all the removed volumes.      */
DECL|method|checkDirs ()
specifier|private
specifier|synchronized
name|List
argument_list|<
name|FSVolume
argument_list|>
name|checkDirs
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|FSVolume
argument_list|>
name|removedVols
init|=
literal|null
decl_stmt|;
comment|// Make a copy of volumes for performing modification
name|List
argument_list|<
name|FSVolume
argument_list|>
name|volumeList
init|=
operator|new
name|ArrayList
argument_list|<
name|FSVolume
argument_list|>
argument_list|(
name|getVolumes
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|volumeList
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|FSVolume
name|fsv
init|=
name|volumeList
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
try|try
block|{
name|fsv
operator|.
name|checkDirs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DiskErrorException
name|e
parameter_list|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing failed volume "
operator|+
name|fsv
operator|+
literal|": "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|removedVols
operator|==
literal|null
condition|)
block|{
name|removedVols
operator|=
operator|new
name|ArrayList
argument_list|<
name|FSVolume
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|removedVols
operator|.
name|add
argument_list|(
name|fsv
argument_list|)
expr_stmt|;
name|fsv
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|volumeList
operator|.
name|set
argument_list|(
name|idx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Remove the volume
name|numFailedVolumes
operator|++
expr_stmt|;
block|}
block|}
comment|// Remove null volumes from the volumes array
if|if
condition|(
name|removedVols
operator|!=
literal|null
operator|&&
name|removedVols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|FSVolume
argument_list|>
name|newVols
init|=
operator|new
name|ArrayList
argument_list|<
name|FSVolume
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FSVolume
name|vol
range|:
name|volumeList
control|)
block|{
if|if
condition|(
name|vol
operator|!=
literal|null
condition|)
block|{
name|newVols
operator|.
name|add
argument_list|(
name|vol
argument_list|)
expr_stmt|;
block|}
block|}
name|volumes
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|newVols
argument_list|)
expr_stmt|;
comment|// Replace volume list
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed FSVolumeSet.checkDirs. Removed "
operator|+
name|removedVols
operator|.
name|size
argument_list|()
operator|+
literal|" volumes. List of current volumes: "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|removedVols
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|isValid (FSVolume volume)
name|boolean
name|isValid
parameter_list|(
name|FSVolume
name|volume
parameter_list|)
block|{
for|for
control|(
name|FSVolume
name|vol
range|:
name|volumes
control|)
block|{
if|if
condition|(
name|vol
operator|==
name|volume
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|addBlockPool (String bpid, Configuration conf)
specifier|private
name|void
name|addBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|FSVolume
name|v
range|:
name|volumes
control|)
block|{
name|v
operator|.
name|addBlockPool
argument_list|(
name|bpid
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeBlockPool (String bpid)
specifier|private
name|void
name|removeBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
for|for
control|(
name|FSVolume
name|v
range|:
name|volumes
control|)
block|{
name|v
operator|.
name|shutdownBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @return unmodifiable list of volumes      */
DECL|method|getVolumes ()
specifier|public
name|List
argument_list|<
name|FSVolume
argument_list|>
name|getVolumes
parameter_list|()
block|{
return|return
name|volumes
return|;
block|}
DECL|method|shutdown ()
specifier|private
name|void
name|shutdown
parameter_list|()
block|{
for|for
control|(
name|FSVolume
name|volume
range|:
name|volumes
control|)
block|{
if|if
condition|(
name|volume
operator|!=
literal|null
condition|)
block|{
name|volume
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//////////////////////////////////////////////////////
comment|//
comment|// FSDataSet
comment|//
comment|//////////////////////////////////////////////////////
comment|//Find better place?
DECL|field|METADATA_EXTENSION
specifier|public
specifier|static
specifier|final
name|String
name|METADATA_EXTENSION
init|=
literal|".meta"
decl_stmt|;
DECL|field|METADATA_VERSION
specifier|public
specifier|static
specifier|final
name|short
name|METADATA_VERSION
init|=
literal|1
decl_stmt|;
DECL|field|UNLINK_BLOCK_SUFFIX
specifier|static
specifier|final
name|String
name|UNLINK_BLOCK_SUFFIX
init|=
literal|".unlinked"
decl_stmt|;
DECL|method|isUnlinkTmpFile (File f)
specifier|private
specifier|static
name|boolean
name|isUnlinkTmpFile
parameter_list|(
name|File
name|f
parameter_list|)
block|{
name|String
name|name
init|=
name|f
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
name|name
operator|.
name|endsWith
argument_list|(
name|UNLINK_BLOCK_SUFFIX
argument_list|)
return|;
block|}
DECL|method|getUnlinkTmpFile (File f)
specifier|static
name|File
name|getUnlinkTmpFile
parameter_list|(
name|File
name|f
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|f
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|f
operator|.
name|getName
argument_list|()
operator|+
name|UNLINK_BLOCK_SUFFIX
argument_list|)
return|;
block|}
DECL|method|getOrigFile (File unlinkTmpFile)
specifier|private
specifier|static
name|File
name|getOrigFile
parameter_list|(
name|File
name|unlinkTmpFile
parameter_list|)
block|{
name|String
name|fileName
init|=
name|unlinkTmpFile
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
operator|new
name|File
argument_list|(
name|unlinkTmpFile
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|fileName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fileName
operator|.
name|length
argument_list|()
operator|-
name|UNLINK_BLOCK_SUFFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getMetaFileName (String blockFileName, long genStamp)
specifier|static
name|String
name|getMetaFileName
parameter_list|(
name|String
name|blockFileName
parameter_list|,
name|long
name|genStamp
parameter_list|)
block|{
return|return
name|blockFileName
operator|+
literal|"_"
operator|+
name|genStamp
operator|+
name|METADATA_EXTENSION
return|;
block|}
DECL|method|getMetaFile (File f , long genStamp)
specifier|static
name|File
name|getMetaFile
parameter_list|(
name|File
name|f
parameter_list|,
name|long
name|genStamp
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|getMetaFileName
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|genStamp
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getMetaFile (ExtendedBlock b)
specifier|protected
name|File
name|getMetaFile
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getMetaFile
argument_list|(
name|getBlockFile
argument_list|(
name|b
argument_list|)
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
return|;
block|}
comment|/** Find the metadata file for the specified block file.    * Return the generation stamp from the name of the metafile.    */
DECL|method|getGenerationStampFromFile (File[] listdir, File blockFile)
specifier|private
specifier|static
name|long
name|getGenerationStampFromFile
parameter_list|(
name|File
index|[]
name|listdir
parameter_list|,
name|File
name|blockFile
parameter_list|)
block|{
name|String
name|blockName
init|=
name|blockFile
operator|.
name|getName
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|listdir
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|String
name|path
init|=
name|listdir
index|[
name|j
index|]
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|startsWith
argument_list|(
name|blockName
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|blockFile
operator|==
name|listdir
index|[
name|j
index|]
condition|)
block|{
continue|continue;
block|}
return|return
name|Block
operator|.
name|getGenerationStamp
argument_list|(
name|listdir
index|[
name|j
index|]
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block "
operator|+
name|blockFile
operator|+
literal|" does not have a metafile!"
argument_list|)
expr_stmt|;
return|return
name|GenerationStamp
operator|.
name|GRANDFATHER_GENERATION_STAMP
return|;
block|}
comment|/** Find the corresponding meta data file from a given block file */
DECL|method|findMetaFile (final File blockFile)
specifier|private
specifier|static
name|File
name|findMetaFile
parameter_list|(
specifier|final
name|File
name|blockFile
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|prefix
init|=
name|blockFile
operator|.
name|getName
argument_list|()
operator|+
literal|"_"
decl_stmt|;
specifier|final
name|File
name|parent
init|=
name|blockFile
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
name|File
index|[]
name|matches
init|=
name|parent
operator|.
name|listFiles
argument_list|(
operator|new
name|FilenameFilter
argument_list|()
block|{
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|dir
operator|.
name|equals
argument_list|(
name|parent
argument_list|)
operator|&&
name|name
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
operator|&&
name|name
operator|.
name|endsWith
argument_list|(
name|METADATA_EXTENSION
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|matches
operator|==
literal|null
operator|||
name|matches
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Meta file not found, blockFile="
operator|+
name|blockFile
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|matches
operator|.
name|length
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Found more than one meta files: "
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|matches
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|matches
index|[
literal|0
index|]
return|;
block|}
comment|/** Find the corresponding meta data file from a given block file */
DECL|method|parseGenerationStamp (File blockFile, File metaFile )
specifier|private
specifier|static
name|long
name|parseGenerationStamp
parameter_list|(
name|File
name|blockFile
parameter_list|,
name|File
name|metaFile
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|metaname
init|=
name|metaFile
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|gs
init|=
name|metaname
operator|.
name|substring
argument_list|(
name|blockFile
operator|.
name|getName
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|,
name|metaname
operator|.
name|length
argument_list|()
operator|-
name|METADATA_EXTENSION
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|gs
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
literal|"blockFile="
operator|+
name|blockFile
operator|+
literal|", metaFile="
operator|+
name|metaFile
argument_list|)
operator|.
name|initCause
argument_list|(
name|nfe
argument_list|)
throw|;
block|}
block|}
comment|/** Return the block file for the given ID */
DECL|method|findBlockFile (String bpid, long blockId)
specifier|public
name|File
name|findBlockFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
return|return
name|getFile
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|getStoredBlock (String bpid, long blkid)
specifier|public
specifier|synchronized
name|Block
name|getStoredBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blkid
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|blockfile
init|=
name|findBlockFile
argument_list|(
name|bpid
argument_list|,
name|blkid
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockfile
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|File
name|metafile
init|=
name|findMetaFile
argument_list|(
name|blockfile
argument_list|)
decl_stmt|;
return|return
operator|new
name|Block
argument_list|(
name|blkid
argument_list|,
name|blockfile
operator|.
name|length
argument_list|()
argument_list|,
name|parseGenerationStamp
argument_list|(
name|blockfile
argument_list|,
name|metafile
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a clone of a replica stored in data-node memory.    * Should be primarily used for testing.    * @param blockId    * @return    */
DECL|method|fetchReplicaInfo (String bpid, long blockId)
name|ReplicaInfo
name|fetchReplicaInfo
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
return|return
literal|null
return|;
switch|switch
condition|(
name|r
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|FINALIZED
case|:
return|return
operator|new
name|FinalizedReplica
argument_list|(
operator|(
name|FinalizedReplica
operator|)
name|r
argument_list|)
return|;
case|case
name|RBW
case|:
return|return
operator|new
name|ReplicaBeingWritten
argument_list|(
operator|(
name|ReplicaBeingWritten
operator|)
name|r
argument_list|)
return|;
case|case
name|RWR
case|:
return|return
operator|new
name|ReplicaWaitingToBeRecovered
argument_list|(
operator|(
name|ReplicaWaitingToBeRecovered
operator|)
name|r
argument_list|)
return|;
case|case
name|RUR
case|:
return|return
operator|new
name|ReplicaUnderRecovery
argument_list|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|r
argument_list|)
return|;
case|case
name|TEMPORARY
case|:
return|return
operator|new
name|ReplicaInPipeline
argument_list|(
operator|(
name|ReplicaInPipeline
operator|)
name|r
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|metaFileExists (ExtendedBlock b)
specifier|public
name|boolean
name|metaFileExists
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getMetaFile
argument_list|(
name|b
argument_list|)
operator|.
name|exists
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|getMetaDataLength (ExtendedBlock b)
specifier|public
name|long
name|getMetaDataLength
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|checksumFile
init|=
name|getMetaFile
argument_list|(
name|b
argument_list|)
decl_stmt|;
return|return
name|checksumFile
operator|.
name|length
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|getMetaDataInputStream (ExtendedBlock b)
specifier|public
name|MetaDataInputStream
name|getMetaDataInputStream
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|checksumFile
init|=
name|getMetaFile
argument_list|(
name|b
argument_list|)
decl_stmt|;
return|return
operator|new
name|MetaDataInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|checksumFile
argument_list|)
argument_list|,
name|checksumFile
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
DECL|method|createTmpFile (Block b, File f)
specifier|static
name|File
name|createTmpFile
parameter_list|(
name|Block
name|b
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected problem in creating temporary file for "
operator|+
name|b
operator|+
literal|".  File "
operator|+
name|f
operator|+
literal|" should not be present, but is."
argument_list|)
throw|;
block|}
comment|// Create the zero-length temp file
comment|//
name|boolean
name|fileCreated
init|=
literal|false
decl_stmt|;
try|try
block|{
name|fileCreated
operator|=
name|f
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
name|DISK_ERROR
operator|+
name|f
argument_list|)
operator|.
name|initCause
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fileCreated
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected problem in creating temporary file for "
operator|+
name|b
operator|+
literal|".  File "
operator|+
name|f
operator|+
literal|" should be creatable, but is already present."
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|volumes
specifier|final
name|FSVolumeSet
name|volumes
decl_stmt|;
DECL|field|maxBlocksPerDir
specifier|private
specifier|final
name|int
name|maxBlocksPerDir
decl_stmt|;
DECL|field|volumeMap
specifier|final
name|ReplicasMap
name|volumeMap
decl_stmt|;
DECL|field|asyncDiskService
specifier|final
name|FSDatasetAsyncDiskService
name|asyncDiskService
decl_stmt|;
DECL|field|validVolsRequired
specifier|private
specifier|final
name|int
name|validVolsRequired
decl_stmt|;
comment|// Used for synchronizing access to usage stats
DECL|field|statsLock
specifier|private
specifier|final
name|Object
name|statsLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|supportAppends
specifier|final
name|boolean
name|supportAppends
decl_stmt|;
comment|/**    * An FSDataset has a directory where it loads its data files.    */
DECL|method|FSDataset (DataNode datanode, DataStorage storage, Configuration conf)
specifier|public
name|FSDataset
parameter_list|(
name|DataNode
name|datanode
parameter_list|,
name|DataStorage
name|storage
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|maxBlocksPerDir
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_NUMBLOCKS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_NUMBLOCKS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|supportAppends
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_SUPPORT_APPEND_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_SUPPORT_APPEND_DEFAULT
argument_list|)
expr_stmt|;
comment|// The number of volumes required for operation is the total number
comment|// of volumes minus the number of failed volumes we can tolerate.
specifier|final
name|int
name|volFailuresTolerated
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FAILED_VOLUMES_TOLERATED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FAILED_VOLUMES_TOLERATED_DEFAULT
argument_list|)
decl_stmt|;
name|String
index|[]
name|dataDirs
init|=
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_KEY
argument_list|)
decl_stmt|;
name|int
name|volsConfigured
init|=
operator|(
name|dataDirs
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|dataDirs
operator|.
name|length
decl_stmt|;
name|int
name|volsFailed
init|=
name|volsConfigured
operator|-
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
decl_stmt|;
name|this
operator|.
name|validVolsRequired
operator|=
name|volsConfigured
operator|-
name|volFailuresTolerated
expr_stmt|;
if|if
condition|(
name|volFailuresTolerated
operator|<
literal|0
operator|||
name|volFailuresTolerated
operator|>=
name|volsConfigured
condition|)
block|{
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"Invalid volume failure "
operator|+
literal|" config value: "
operator|+
name|volFailuresTolerated
argument_list|)
throw|;
block|}
if|if
condition|(
name|volsFailed
operator|>
name|volFailuresTolerated
condition|)
block|{
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"Too many failed volumes - "
operator|+
literal|"current valid volumes: "
operator|+
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
operator|+
literal|", volumes configured: "
operator|+
name|volsConfigured
operator|+
literal|", volumes failed: "
operator|+
name|volsFailed
operator|+
literal|", volume failures tolerated: "
operator|+
name|volFailuresTolerated
argument_list|)
throw|;
block|}
name|FSVolume
index|[]
name|volArray
init|=
operator|new
name|FSVolume
index|[
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|volArray
index|[
name|idx
index|]
operator|=
operator|new
name|FSVolume
argument_list|(
name|storage
operator|.
name|getStorageDir
argument_list|(
name|idx
argument_list|)
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"FSDataset added volume - "
operator|+
name|storage
operator|.
name|getStorageDir
argument_list|(
name|idx
argument_list|)
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|volumeMap
operator|=
operator|new
name|ReplicasMap
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|BlockVolumeChoosingPolicy
name|blockChooserImpl
init|=
operator|(
name|BlockVolumeChoosingPolicy
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_BLOCKVOLUMECHOICEPOLICY
argument_list|,
name|RoundRobinVolumesPolicy
operator|.
name|class
argument_list|,
name|BlockVolumeChoosingPolicy
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|volumes
operator|=
operator|new
name|FSVolumeSet
argument_list|(
name|volArray
argument_list|,
name|volsFailed
argument_list|,
name|blockChooserImpl
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|getVolumeMap
argument_list|(
name|volumeMap
argument_list|)
expr_stmt|;
name|File
index|[]
name|roots
init|=
operator|new
name|File
index|[
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|roots
index|[
name|idx
index|]
operator|=
name|storage
operator|.
name|getStorageDir
argument_list|(
name|idx
argument_list|)
operator|.
name|getCurrentDir
argument_list|()
expr_stmt|;
block|}
name|asyncDiskService
operator|=
operator|new
name|FSDatasetAsyncDiskService
argument_list|(
name|this
argument_list|,
name|roots
argument_list|)
expr_stmt|;
name|registerMBean
argument_list|(
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the total space used by dfs datanode    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getDfsUsed ()
specifier|public
name|long
name|getDfsUsed
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getDfsUsed
argument_list|()
return|;
block|}
block|}
comment|/**    * Return the total space used by dfs datanode    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getBlockPoolUsed (String bpid)
specifier|public
name|long
name|getBlockPoolUsed
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getBlockPoolUsed
argument_list|(
name|bpid
argument_list|)
return|;
block|}
block|}
comment|/**    * Return true - if there are still valid volumes on the DataNode.     */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|hasEnoughResource ()
specifier|public
name|boolean
name|hasEnoughResource
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|numberOfVolumes
argument_list|()
operator|>=
name|validVolsRequired
return|;
block|}
comment|/**    * Return total capacity, used and unused    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getCapacity ()
specifier|public
name|long
name|getCapacity
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getCapacity
argument_list|()
return|;
block|}
block|}
comment|/**    * Return how many bytes can still be stored in the FSDataset    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getRemaining ()
specifier|public
name|long
name|getRemaining
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getRemaining
argument_list|()
return|;
block|}
block|}
comment|/**    * Return the number of failed volumes in the FSDataset.    */
DECL|method|getNumFailedVolumes ()
specifier|public
name|int
name|getNumFailedVolumes
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|numberOfFailedVolumes
argument_list|()
return|;
block|}
comment|/**    * Find the block's on-disk length    */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|getLength (ExtendedBlock b)
specifier|public
name|long
name|getLength
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockFile
argument_list|(
name|b
argument_list|)
operator|.
name|length
argument_list|()
return|;
block|}
comment|/**    * Get File name for a given block.    */
DECL|method|getBlockFile (ExtendedBlock b)
specifier|public
name|File
name|getBlockFile
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get File name for a given block.    */
DECL|method|getBlockFile (String bpid, Block b)
specifier|public
specifier|synchronized
name|File
name|getBlockFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|f
init|=
name|validateBlockFile
argument_list|(
name|bpid
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"b="
operator|+
name|b
operator|+
literal|", volumeMap="
operator|+
name|volumeMap
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" is not valid."
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|getBlockInputStream (ExtendedBlock b)
specifier|public
specifier|synchronized
name|InputStream
name|getBlockInputStream
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileInputStream
argument_list|(
name|getBlockFile
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|getBlockInputStream (ExtendedBlock b, long seekOffset)
specifier|public
specifier|synchronized
name|InputStream
name|getBlockInputStream
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|seekOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|blockFile
init|=
name|getBlockFile
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|RandomAccessFile
name|blockInFile
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|blockFile
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekOffset
operator|>
literal|0
condition|)
block|{
name|blockInFile
operator|.
name|seek
argument_list|(
name|seekOffset
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FileInputStream
argument_list|(
name|blockInFile
operator|.
name|getFD
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the meta info of a block stored in volumeMap. To find a block,    * block pool Id, block Id and generation stamp must match.    * @param b extended block    * @return the meta replica information; null if block was not found    * @throws ReplicaNotFoundException if no entry is in the map or     *                        there is a generation stamp mismatch    */
DECL|method|getReplicaInfo (ExtendedBlock b)
specifier|private
name|ReplicaInfo
name|getReplicaInfo
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|ReplicaNotFoundException
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
comment|/**    * Get the meta info of a block stored in volumeMap. Block is looked up    * without matching the generation stamp.    * @param bpid block pool Id    * @param blkid block Id    * @return the meta replica information; null if block was not found    * @throws ReplicaNotFoundException if no entry is in the map or     *                        there is a generation stamp mismatch    */
DECL|method|getReplicaInfo (String bpid, long blkid)
specifier|private
name|ReplicaInfo
name|getReplicaInfo
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blkid
parameter_list|)
throws|throws
name|ReplicaNotFoundException
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blkid
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|bpid
operator|+
literal|":"
operator|+
name|blkid
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
comment|/**    * Returns handles to the block file and its metadata file    */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|getTmpInputStreams (ExtendedBlock b, long blkOffset, long ckoff)
specifier|public
specifier|synchronized
name|BlockInputStreams
name|getTmpInputStreams
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|blkOffset
parameter_list|,
name|long
name|ckoff
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|info
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|File
name|blockFile
init|=
name|info
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
name|RandomAccessFile
name|blockInFile
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|blockFile
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|blkOffset
operator|>
literal|0
condition|)
block|{
name|blockInFile
operator|.
name|seek
argument_list|(
name|blkOffset
argument_list|)
expr_stmt|;
block|}
name|File
name|metaFile
init|=
name|info
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
name|RandomAccessFile
name|metaInFile
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|metaFile
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ckoff
operator|>
literal|0
condition|)
block|{
name|metaInFile
operator|.
name|seek
argument_list|(
name|ckoff
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|BlockInputStreams
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|blockInFile
operator|.
name|getFD
argument_list|()
argument_list|)
argument_list|,
operator|new
name|FileInputStream
argument_list|(
name|metaInFile
operator|.
name|getFD
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Make a copy of the block if this block is linked to an existing    * snapshot. This ensures that modifying this block does not modify    * data in any existing snapshots.    * @param block Block    * @param numLinks Unlink if the number of links exceed this value    * @throws IOException    * @return - true if the specified block was unlinked or the block    *           is not in any snapshot.    */
DECL|method|unlinkBlock (ExtendedBlock block, int numLinks)
specifier|public
name|boolean
name|unlinkBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|int
name|numLinks
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|info
init|=
name|getReplicaInfo
argument_list|(
name|block
argument_list|)
decl_stmt|;
return|return
name|info
operator|.
name|unlinkBlock
argument_list|(
name|numLinks
argument_list|)
return|;
block|}
DECL|method|moveBlockFiles (Block b, File srcfile, File destdir )
specifier|private
specifier|static
name|File
name|moveBlockFiles
parameter_list|(
name|Block
name|b
parameter_list|,
name|File
name|srcfile
parameter_list|,
name|File
name|destdir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|dstfile
init|=
operator|new
name|File
argument_list|(
name|destdir
argument_list|,
name|b
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|srcmeta
init|=
name|getMetaFile
argument_list|(
name|srcfile
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dstmeta
init|=
name|getMetaFile
argument_list|(
name|dstfile
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|srcmeta
operator|.
name|renameTo
argument_list|(
name|dstmeta
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move meta file for "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|srcmeta
operator|+
literal|" to "
operator|+
name|dstmeta
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|srcfile
operator|.
name|renameTo
argument_list|(
name|dstfile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move block file for "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|srcfile
operator|+
literal|" to "
operator|+
name|dstfile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|DataNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"addBlock: Moved "
operator|+
name|srcmeta
operator|+
literal|" to "
operator|+
name|dstmeta
argument_list|)
expr_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"addBlock: Moved "
operator|+
name|srcfile
operator|+
literal|" to "
operator|+
name|dstfile
argument_list|)
expr_stmt|;
block|}
return|return
name|dstfile
return|;
block|}
DECL|method|truncateBlock (File blockFile, File metaFile, long oldlen, long newlen)
specifier|static
specifier|private
name|void
name|truncateBlock
parameter_list|(
name|File
name|blockFile
parameter_list|,
name|File
name|metaFile
parameter_list|,
name|long
name|oldlen
parameter_list|,
name|long
name|newlen
parameter_list|)
throws|throws
name|IOException
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"truncateBlock: blockFile="
operator|+
name|blockFile
operator|+
literal|", metaFile="
operator|+
name|metaFile
operator|+
literal|", oldlen="
operator|+
name|oldlen
operator|+
literal|", newlen="
operator|+
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|==
name|oldlen
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|newlen
operator|>
name|oldlen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannout truncate block to from oldlen (="
operator|+
name|oldlen
operator|+
literal|") to newlen (="
operator|+
name|newlen
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|DataChecksum
name|dcs
init|=
name|BlockMetadataHeader
operator|.
name|readHeader
argument_list|(
name|metaFile
argument_list|)
operator|.
name|getChecksum
argument_list|()
decl_stmt|;
name|int
name|checksumsize
init|=
name|dcs
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
name|int
name|bpc
init|=
name|dcs
operator|.
name|getBytesPerChecksum
argument_list|()
decl_stmt|;
name|long
name|n
init|=
operator|(
name|newlen
operator|-
literal|1
operator|)
operator|/
name|bpc
operator|+
literal|1
decl_stmt|;
name|long
name|newmetalen
init|=
name|BlockMetadataHeader
operator|.
name|getHeaderSize
argument_list|()
operator|+
name|n
operator|*
name|checksumsize
decl_stmt|;
name|long
name|lastchunkoffset
init|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
name|bpc
decl_stmt|;
name|int
name|lastchunksize
init|=
call|(
name|int
call|)
argument_list|(
name|newlen
operator|-
name|lastchunkoffset
argument_list|)
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|Math
operator|.
name|max
argument_list|(
name|lastchunksize
argument_list|,
name|checksumsize
argument_list|)
index|]
decl_stmt|;
name|RandomAccessFile
name|blockRAF
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|blockFile
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
try|try
block|{
comment|//truncate blockFile
name|blockRAF
operator|.
name|setLength
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
comment|//read last chunk
name|blockRAF
operator|.
name|seek
argument_list|(
name|lastchunkoffset
argument_list|)
expr_stmt|;
name|blockRAF
operator|.
name|readFully
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|lastchunksize
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|blockRAF
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|//compute checksum
name|dcs
operator|.
name|update
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|lastchunksize
argument_list|)
expr_stmt|;
name|dcs
operator|.
name|writeValue
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//update metaFile
name|RandomAccessFile
name|metaRAF
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|metaFile
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
try|try
block|{
name|metaRAF
operator|.
name|setLength
argument_list|(
name|newmetalen
argument_list|)
expr_stmt|;
name|metaRAF
operator|.
name|seek
argument_list|(
name|newmetalen
operator|-
name|checksumsize
argument_list|)
expr_stmt|;
name|metaRAF
operator|.
name|write
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|checksumsize
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|metaRAF
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|DISK_ERROR
specifier|private
specifier|final
specifier|static
name|String
name|DISK_ERROR
init|=
literal|"Possible disk error on file creation: "
decl_stmt|;
comment|/** Get the cause of an I/O exception if caused by a possible disk error    * @param ioe an I/O exception    * @return cause if the I/O exception is caused by a possible disk error;    *         null otherwise.    */
DECL|method|getCauseIfDiskError (IOException ioe)
specifier|static
name|IOException
name|getCauseIfDiskError
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|ioe
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|ioe
operator|.
name|getMessage
argument_list|()
operator|.
name|startsWith
argument_list|(
name|DISK_ERROR
argument_list|)
condition|)
block|{
return|return
operator|(
name|IOException
operator|)
name|ioe
operator|.
name|getCause
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|append (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
specifier|synchronized
name|ReplicaInPipelineInterface
name|append
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If the block was successfully finalized because all packets
comment|// were successfully processed at the Datanode but the ack for
comment|// some of the packets were not received by the client. The client
comment|// re-opens the connection and retries sending those packets.
comment|// The other reason is that an "append" is occurring to this block.
comment|// check the validity of the parameter
if|if
condition|(
name|newGS
operator|<
name|b
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The new generation stamp "
operator|+
name|newGS
operator|+
literal|" should be greater than the replica "
operator|+
name|b
operator|+
literal|"'s generation stamp"
argument_list|)
throw|;
block|}
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Appending to replica "
operator|+
name|replicaInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|expectedBlockLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" expected length is "
operator|+
name|expectedBlockLen
argument_list|)
throw|;
block|}
return|return
name|append
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
name|FinalizedReplica
operator|)
name|replicaInfo
argument_list|,
name|newGS
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
return|;
block|}
comment|/** Append to a finalized replica    * Change a finalized replica to be a RBW replica and     * bump its generation stamp to be the newGS    *     * @param bpid block pool Id    * @param replicaInfo a finalized replica    * @param newGS new generation stamp    * @param estimateBlockLen estimate generation stamp    * @return a RBW replica    * @throws IOException if moving the replica from finalized directory     *         to rbw directory fails    */
DECL|method|append (String bpid, FinalizedReplica replicaInfo, long newGS, long estimateBlockLen)
specifier|private
specifier|synchronized
name|ReplicaBeingWritten
name|append
parameter_list|(
name|String
name|bpid
parameter_list|,
name|FinalizedReplica
name|replicaInfo
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|estimateBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
comment|// unlink the finalized replica
name|replicaInfo
operator|.
name|unlinkBlock
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// construct a RBW replica with the new GS
name|File
name|blkfile
init|=
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
name|FSVolume
name|v
init|=
name|replicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|getAvailable
argument_list|()
operator|<
name|estimateBlockLen
operator|-
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DiskOutOfSpaceException
argument_list|(
literal|"Insufficient space for appending to "
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|File
name|newBlkFile
init|=
operator|new
name|File
argument_list|(
name|v
operator|.
name|getRbwDir
argument_list|(
name|bpid
argument_list|)
argument_list|,
name|replicaInfo
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|oldmeta
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
name|ReplicaBeingWritten
name|newReplicaInfo
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|newGS
argument_list|,
name|v
argument_list|,
name|newBlkFile
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|newmeta
init|=
name|newReplicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
comment|// rename meta file to rbw directory
if|if
condition|(
name|DataNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oldmeta
operator|.
name|renameTo
argument_list|(
name|newmeta
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|replicaInfo
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move meta file  "
operator|+
name|oldmeta
operator|+
literal|" to rbw dir "
operator|+
name|newmeta
argument_list|)
throw|;
block|}
comment|// rename block file to rbw directory
if|if
condition|(
name|DataNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|blkfile
operator|+
literal|" to "
operator|+
name|newBlkFile
argument_list|)
expr_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Old block file length is "
operator|+
name|blkfile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|blkfile
operator|.
name|renameTo
argument_list|(
name|newBlkFile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|newmeta
operator|.
name|renameTo
argument_list|(
name|oldmeta
argument_list|)
condition|)
block|{
comment|// restore the meta file
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot move meta file "
operator|+
name|newmeta
operator|+
literal|"back to the finalized directory "
operator|+
name|oldmeta
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|replicaInfo
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move block file "
operator|+
name|blkfile
operator|+
literal|" to rbw dir "
operator|+
name|newBlkFile
argument_list|)
throw|;
block|}
comment|// Replace finalized replica by a RBW replica in replicas map
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
DECL|method|recoverCheck (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|private
name|ReplicaInfo
name|recoverCheck
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
comment|// check state
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_AND_NONRBW_REPLICA
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
comment|// check generation stamp
name|long
name|replicaGenerationStamp
init|=
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaGenerationStamp
argument_list|<
name|b
operator|.
name|getGenerationStamp
operator|(
operator|)
operator|||
name|replicaGenerationStamp
argument_list|>
name|newGS
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNEXPECTED_GS_REPLICA
operator|+
name|replicaGenerationStamp
operator|+
literal|". Expected GS range is ["
operator|+
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", "
operator|+
name|newGS
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// stop the previous writer before check a replica's length
name|long
name|replicaLen
init|=
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
name|ReplicaBeingWritten
name|rbw
init|=
operator|(
name|ReplicaBeingWritten
operator|)
name|replicaInfo
decl_stmt|;
comment|// kill the previous writer
name|rbw
operator|.
name|stopWriter
argument_list|()
expr_stmt|;
name|rbw
operator|.
name|setWriter
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|// check length: bytesRcvd, bytesOnDisk, and bytesAcked should be the same
if|if
condition|(
name|replicaLen
operator|!=
name|rbw
operator|.
name|getBytesOnDisk
argument_list|()
operator|||
name|replicaLen
operator|!=
name|rbw
operator|.
name|getBytesAcked
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"RBW replica "
operator|+
name|replicaInfo
operator|+
literal|"bytesRcvd("
operator|+
name|rbw
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|"), bytesOnDisk("
operator|+
name|rbw
operator|.
name|getBytesOnDisk
argument_list|()
operator|+
literal|"), and bytesAcked("
operator|+
name|rbw
operator|.
name|getBytesAcked
argument_list|()
operator|+
literal|") are not the same."
argument_list|)
throw|;
block|}
block|}
comment|// check block length
if|if
condition|(
name|replicaLen
operator|!=
name|expectedBlockLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaLen
operator|+
literal|" expected length is "
operator|+
name|expectedBlockLen
argument_list|)
throw|;
block|}
return|return
name|replicaInfo
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|recoverAppend (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
specifier|synchronized
name|ReplicaInPipelineInterface
name|recoverAppend
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover failed append to "
operator|+
name|b
argument_list|)
expr_stmt|;
name|ReplicaInfo
name|replicaInfo
init|=
name|recoverCheck
argument_list|(
name|b
argument_list|,
name|newGS
argument_list|,
name|expectedBlockLen
argument_list|)
decl_stmt|;
comment|// change the replica's state/gs etc.
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
return|return
name|append
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
name|FinalizedReplica
operator|)
name|replicaInfo
argument_list|,
name|newGS
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|//RBW
name|bumpReplicaGS
argument_list|(
name|replicaInfo
argument_list|,
name|newGS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ReplicaBeingWritten
operator|)
name|replicaInfo
return|;
block|}
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|recoverClose (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
name|void
name|recoverClose
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover failed close "
operator|+
name|b
argument_list|)
expr_stmt|;
comment|// check replica's state
name|ReplicaInfo
name|replicaInfo
init|=
name|recoverCheck
argument_list|(
name|b
argument_list|,
name|newGS
argument_list|,
name|expectedBlockLen
argument_list|)
decl_stmt|;
comment|// bump the replica's GS
name|bumpReplicaGS
argument_list|(
name|replicaInfo
argument_list|,
name|newGS
argument_list|)
expr_stmt|;
comment|// finalize the replica if RBW
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
name|finalizeReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Bump a replica's generation stamp to a new one.    * Its on-disk meta file name is renamed to be the new one too.    *     * @param replicaInfo a replica    * @param newGS new generation stamp    * @throws IOException if rename fails    */
DECL|method|bumpReplicaGS (ReplicaInfo replicaInfo, long newGS)
specifier|private
name|void
name|bumpReplicaGS
parameter_list|(
name|ReplicaInfo
name|replicaInfo
parameter_list|,
name|long
name|newGS
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|oldGS
init|=
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
name|File
name|oldmeta
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
name|replicaInfo
operator|.
name|setGenerationStamp
argument_list|(
name|newGS
argument_list|)
expr_stmt|;
name|File
name|newmeta
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
comment|// rename meta file to new GS
if|if
condition|(
name|DataNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oldmeta
operator|.
name|renameTo
argument_list|(
name|newmeta
argument_list|)
condition|)
block|{
name|replicaInfo
operator|.
name|setGenerationStamp
argument_list|(
name|oldGS
argument_list|)
expr_stmt|;
comment|// restore old GS
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
operator|(
name|Block
operator|)
name|replicaInfo
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move meta file  "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|createRbw (ExtendedBlock b)
specifier|public
specifier|synchronized
name|ReplicaInPipelineInterface
name|createRbw
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" already exists in state "
operator|+
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|+
literal|" and thus cannot be created."
argument_list|)
throw|;
block|}
comment|// create a new block
name|FSVolume
name|v
init|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
decl_stmt|;
comment|// create a rbw file to hold block in the designated volume
name|File
name|f
init|=
name|v
operator|.
name|createRbwFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
name|ReplicaBeingWritten
name|newReplicaInfo
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|v
argument_list|,
name|f
operator|.
name|getParentFile
argument_list|()
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|recoverRbw (ExtendedBlock b, long newGS, long minBytesRcvd, long maxBytesRcvd)
specifier|public
specifier|synchronized
name|ReplicaInPipelineInterface
name|recoverRbw
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|minBytesRcvd
parameter_list|,
name|long
name|maxBytesRcvd
parameter_list|)
throws|throws
name|IOException
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover the RBW replica "
operator|+
name|b
argument_list|)
expr_stmt|;
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
comment|// check the replica's state
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_RBW_REPLICA
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|ReplicaBeingWritten
name|rbw
init|=
operator|(
name|ReplicaBeingWritten
operator|)
name|replicaInfo
decl_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering replica "
operator|+
name|rbw
argument_list|)
expr_stmt|;
comment|// Stop the previous writer
name|rbw
operator|.
name|stopWriter
argument_list|()
expr_stmt|;
name|rbw
operator|.
name|setWriter
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|// check generation stamp
name|long
name|replicaGenerationStamp
init|=
name|rbw
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaGenerationStamp
argument_list|<
name|b
operator|.
name|getGenerationStamp
operator|(
operator|)
operator|||
name|replicaGenerationStamp
argument_list|>
name|newGS
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNEXPECTED_GS_REPLICA
operator|+
name|b
operator|+
literal|". Expected GS range is ["
operator|+
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", "
operator|+
name|newGS
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// check replica length
if|if
condition|(
name|rbw
operator|.
name|getBytesAcked
argument_list|()
operator|<
name|minBytesRcvd
operator|||
name|rbw
operator|.
name|getNumBytes
argument_list|()
operator|>
name|maxBytesRcvd
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
literal|"Unmatched length replica "
operator|+
name|replicaInfo
operator|+
literal|": BytesAcked = "
operator|+
name|rbw
operator|.
name|getBytesAcked
argument_list|()
operator|+
literal|" BytesRcvd = "
operator|+
name|rbw
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" are not in the range of ["
operator|+
name|minBytesRcvd
operator|+
literal|", "
operator|+
name|maxBytesRcvd
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// bump the replica's generation stamp to newGS
name|bumpReplicaGS
argument_list|(
name|rbw
argument_list|,
name|newGS
argument_list|)
expr_stmt|;
return|return
name|rbw
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|convertTemporaryToRbw ( final ExtendedBlock b)
specifier|public
specifier|synchronized
name|ReplicaInPipelineInterface
name|convertTemporaryToRbw
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|blockId
init|=
name|b
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
specifier|final
name|long
name|expectedGs
init|=
name|b
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
specifier|final
name|long
name|visible
init|=
name|b
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Convert replica "
operator|+
name|b
operator|+
literal|" from Temporary to RBW, visible length="
operator|+
name|visible
argument_list|)
expr_stmt|;
specifier|final
name|ReplicaInPipeline
name|temp
decl_stmt|;
block|{
comment|// get replica
specifier|final
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
comment|// check the replica's state
if|if
condition|(
name|r
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|TEMPORARY
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"r.getState() != ReplicaState.TEMPORARY, r="
operator|+
name|r
argument_list|)
throw|;
block|}
name|temp
operator|=
operator|(
name|ReplicaInPipeline
operator|)
name|r
expr_stmt|;
block|}
comment|// check generation stamp
if|if
condition|(
name|temp
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|expectedGs
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"temp.getGenerationStamp() != expectedGs = "
operator|+
name|expectedGs
operator|+
literal|", temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// TODO: check writer?
comment|// set writer to the current thread
comment|// temp.setWriter(Thread.currentThread());
comment|// check length
specifier|final
name|long
name|numBytes
init|=
name|temp
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBytes
operator|<
name|visible
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|numBytes
operator|+
literal|" = numBytes< visible = "
operator|+
name|visible
operator|+
literal|", temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// check volume
specifier|final
name|FSVolume
name|v
init|=
name|temp
operator|.
name|getVolume
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"r.getVolume() = null, temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// move block files to the rbw directory
name|BlockPoolSlice
name|bpslice
init|=
name|v
operator|.
name|getBlockPoolSlice
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dest
init|=
name|moveBlockFiles
argument_list|(
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|temp
operator|.
name|getBlockFile
argument_list|()
argument_list|,
name|bpslice
operator|.
name|getRbwDir
argument_list|()
argument_list|)
decl_stmt|;
comment|// create RBW
specifier|final
name|ReplicaBeingWritten
name|rbw
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|blockId
argument_list|,
name|numBytes
argument_list|,
name|expectedGs
argument_list|,
name|v
argument_list|,
name|dest
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
decl_stmt|;
name|rbw
operator|.
name|setBytesAcked
argument_list|(
name|visible
argument_list|)
expr_stmt|;
comment|// overwrite the RBW in the volume map
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|rbw
argument_list|)
expr_stmt|;
return|return
name|rbw
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|createTemporary (ExtendedBlock b)
specifier|public
specifier|synchronized
name|ReplicaInPipelineInterface
name|createTemporary
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" already exists in state "
operator|+
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|+
literal|" and thus cannot be created."
argument_list|)
throw|;
block|}
name|FSVolume
name|v
init|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
decl_stmt|;
comment|// create a temporary file to hold block in the designated volume
name|File
name|f
init|=
name|v
operator|.
name|createTmpFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
name|ReplicaInPipeline
name|newReplicaInfo
init|=
operator|new
name|ReplicaInPipeline
argument_list|(
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|v
argument_list|,
name|f
operator|.
name|getParentFile
argument_list|()
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
comment|/**    * Sets the offset in the meta file so that the    * last checksum will be overwritten.    */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|adjustCrcChannelPosition (ExtendedBlock b, BlockWriteStreams streams, int checksumSize)
specifier|public
name|void
name|adjustCrcChannelPosition
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|BlockWriteStreams
name|streams
parameter_list|,
name|int
name|checksumSize
parameter_list|)
throws|throws
name|IOException
block|{
name|FileOutputStream
name|file
init|=
operator|(
name|FileOutputStream
operator|)
name|streams
operator|.
name|checksumOut
decl_stmt|;
name|FileChannel
name|channel
init|=
name|file
operator|.
name|getChannel
argument_list|()
decl_stmt|;
name|long
name|oldPos
init|=
name|channel
operator|.
name|position
argument_list|()
decl_stmt|;
name|long
name|newPos
init|=
name|oldPos
operator|-
name|checksumSize
decl_stmt|;
if|if
condition|(
name|DataNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Changing meta file offset of block "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|oldPos
operator|+
literal|" to "
operator|+
name|newPos
argument_list|)
expr_stmt|;
block|}
name|channel
operator|.
name|position
argument_list|(
name|newPos
argument_list|)
expr_stmt|;
block|}
DECL|method|createTmpFile (FSVolume vol, String bpid, Block blk)
specifier|synchronized
name|File
name|createTmpFile
parameter_list|(
name|FSVolume
name|vol
parameter_list|,
name|String
name|bpid
parameter_list|,
name|Block
name|blk
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|vol
operator|==
literal|null
condition|)
block|{
name|ReplicaInfo
name|replica
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blk
argument_list|)
decl_stmt|;
if|if
condition|(
name|replica
operator|!=
literal|null
condition|)
block|{
name|vol
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blk
argument_list|)
operator|.
name|getVolume
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|vol
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not find volume for block "
operator|+
name|blk
argument_list|)
throw|;
block|}
block|}
return|return
name|vol
operator|.
name|createTmpFile
argument_list|(
name|bpid
argument_list|,
name|blk
argument_list|)
return|;
block|}
comment|//
comment|// REMIND - mjc - eventually we should have a timeout system
comment|// in place to clean up block files left by abandoned clients.
comment|// We should have some timer in place, so that if a blockfile
comment|// is created but non-valid, and has been idle for>48 hours,
comment|// we can GC it safely.
comment|//
comment|/**    * Complete the block write!    */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|finalizeBlock (ExtendedBlock b)
specifier|public
specifier|synchronized
name|void
name|finalizeBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
comment|// this is legal, when recovery happens on a file that has
comment|// been opened for append but never modified
return|return;
block|}
name|finalizeReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|)
expr_stmt|;
block|}
DECL|method|finalizeReplica (String bpid, ReplicaInfo replicaInfo)
specifier|private
specifier|synchronized
name|FinalizedReplica
name|finalizeReplica
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaInfo
name|replicaInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|FinalizedReplica
name|newReplicaInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RUR
operator|&&
operator|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|replicaInfo
operator|)
operator|.
name|getOrignalReplicaState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|newReplicaInfo
operator|=
call|(
name|FinalizedReplica
call|)
argument_list|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|replicaInfo
argument_list|)
operator|.
name|getOriginalReplica
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|FSVolume
name|v
init|=
name|replicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
name|File
name|f
init|=
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No volume for temporary file "
operator|+
name|f
operator|+
literal|" for block "
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|File
name|dest
init|=
name|v
operator|.
name|addBlock
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|newReplicaInfo
operator|=
operator|new
name|FinalizedReplica
argument_list|(
name|replicaInfo
argument_list|,
name|v
argument_list|,
name|dest
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
comment|/**    * Remove the temporary block file (if any)    */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|unfinalizeBlock (ExtendedBlock b)
specifier|public
specifier|synchronized
name|void
name|unfinalizeBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|TEMPORARY
condition|)
block|{
comment|// remove from volumeMap
name|volumeMap
operator|.
name|remove
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
comment|// delete the on-disk temp file
if|if
condition|(
name|delBlockFromDisk
argument_list|(
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" unfinalized and removed. "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove a block from disk    * @param blockFile block file    * @param metaFile block meta file    * @param b a block    * @return true if on-disk files are deleted; false otherwise    */
DECL|method|delBlockFromDisk (File blockFile, File metaFile, Block b)
specifier|private
name|boolean
name|delBlockFromDisk
parameter_list|(
name|File
name|blockFile
parameter_list|,
name|File
name|metaFile
parameter_list|,
name|Block
name|b
parameter_list|)
block|{
if|if
condition|(
name|blockFile
operator|==
literal|null
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"No file exists for block: "
operator|+
name|b
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|blockFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to delete the block file: "
operator|+
name|blockFile
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// remove the meta file
if|if
condition|(
name|metaFile
operator|!=
literal|null
operator|&&
operator|!
name|metaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to delete the meta block file: "
operator|+
name|metaFile
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Generates a block report from the in-memory block map.    */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|getBlockReport (String bpid)
specifier|public
name|BlockListAsLongs
name|getBlockReport
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|int
name|size
init|=
name|volumeMap
operator|.
name|size
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ReplicaInfo
argument_list|>
name|finalized
init|=
operator|new
name|ArrayList
argument_list|<
name|ReplicaInfo
argument_list|>
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ReplicaInfo
argument_list|>
name|uc
init|=
operator|new
name|ArrayList
argument_list|<
name|ReplicaInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|BlockListAsLongs
argument_list|(
name|finalized
argument_list|,
name|uc
argument_list|)
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|ReplicaInfo
name|b
range|:
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
control|)
block|{
switch|switch
condition|(
name|b
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|FINALIZED
case|:
name|finalized
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|RBW
case|:
case|case
name|RWR
case|:
name|uc
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUR
case|:
name|ReplicaUnderRecovery
name|rur
init|=
operator|(
name|ReplicaUnderRecovery
operator|)
name|b
decl_stmt|;
name|uc
operator|.
name|add
argument_list|(
name|rur
operator|.
name|getOriginalReplica
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPORARY
case|:
break|break;
default|default:
assert|assert
literal|false
operator|:
literal|"Illegal ReplicaInfo state."
assert|;
block|}
block|}
return|return
operator|new
name|BlockListAsLongs
argument_list|(
name|finalized
argument_list|,
name|uc
argument_list|)
return|;
block|}
block|}
comment|/**    * Get the list of finalized blocks from in-memory blockmap for a block pool.    */
DECL|method|getFinalizedBlocks (String bpid)
specifier|synchronized
name|List
argument_list|<
name|Block
argument_list|>
name|getFinalizedBlocks
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Block
argument_list|>
name|finalized
init|=
operator|new
name|ArrayList
argument_list|<
name|Block
argument_list|>
argument_list|(
name|volumeMap
operator|.
name|size
argument_list|(
name|bpid
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|ReplicaInfo
name|b
range|:
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
control|)
block|{
if|if
condition|(
name|b
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|finalized
operator|.
name|add
argument_list|(
operator|new
name|Block
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|finalized
return|;
block|}
comment|/**    * Check whether the given block is a valid one.    * valid means finalized    */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|isValidBlock (ExtendedBlock b)
specifier|public
name|boolean
name|isValidBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
block|{
return|return
name|isValid
argument_list|(
name|b
argument_list|,
name|ReplicaState
operator|.
name|FINALIZED
argument_list|)
return|;
block|}
comment|/**    * Check whether the given block is a valid RBW.    */
annotation|@
name|Override
comment|// {@link FSDatasetInterface}
DECL|method|isValidRbw (final ExtendedBlock b)
specifier|public
name|boolean
name|isValidRbw
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
block|{
return|return
name|isValid
argument_list|(
name|b
argument_list|,
name|ReplicaState
operator|.
name|RBW
argument_list|)
return|;
block|}
comment|/** Does the block exist and have the given state? */
DECL|method|isValid (final ExtendedBlock b, final ReplicaState state)
specifier|private
name|boolean
name|isValid
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|,
specifier|final
name|ReplicaState
name|state
parameter_list|)
block|{
specifier|final
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|replicaInfo
operator|!=
literal|null
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|state
operator|&&
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
operator|.
name|exists
argument_list|()
return|;
block|}
comment|/**    * Find the file corresponding to the block and return it if it exists.    */
DECL|method|validateBlockFile (String bpid, Block b)
name|File
name|validateBlockFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
comment|//Should we check for metadata file too?
name|File
name|f
init|=
name|getFile
argument_list|(
name|bpid
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
return|return
name|f
return|;
comment|// if file is not null, but doesn't exist - possibly disk failed
name|datanode
operator|.
name|checkDiskError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"b="
operator|+
name|b
operator|+
literal|", f="
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Check the files of a replica. */
DECL|method|checkReplicaFiles (final ReplicaInfo r)
specifier|static
name|void
name|checkReplicaFiles
parameter_list|(
specifier|final
name|ReplicaInfo
name|r
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check replica's file
specifier|final
name|File
name|f
init|=
name|r
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File "
operator|+
name|f
operator|+
literal|" not found, r="
operator|+
name|r
argument_list|)
throw|;
block|}
if|if
condition|(
name|r
operator|.
name|getBytesOnDisk
argument_list|()
operator|!=
name|f
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File length mismatched.  The length of "
operator|+
name|f
operator|+
literal|" is "
operator|+
name|f
operator|.
name|length
argument_list|()
operator|+
literal|" but r="
operator|+
name|r
argument_list|)
throw|;
block|}
comment|//check replica's meta file
specifier|final
name|File
name|metafile
init|=
name|getMetaFile
argument_list|(
name|f
argument_list|,
name|r
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|metafile
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Metafile "
operator|+
name|metafile
operator|+
literal|" does not exist, r="
operator|+
name|r
argument_list|)
throw|;
block|}
if|if
condition|(
name|metafile
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Metafile "
operator|+
name|metafile
operator|+
literal|" is empty, r="
operator|+
name|r
argument_list|)
throw|;
block|}
block|}
comment|/**    * We're informed that a block is no longer valid.  We    * could lazily garbage-collect the block, but why bother?    * just get rid of it.    */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|invalidate (String bpid, Block invalidBlks[])
specifier|public
name|void
name|invalidate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|invalidBlks
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|error
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|invalidBlks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|File
name|f
init|=
literal|null
decl_stmt|;
name|FSVolume
name|v
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|f
operator|=
name|getFile
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ReplicaInfo
name|dinfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|dinfo
operator|==
literal|null
operator|||
name|dinfo
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected error trying to delete block "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". BlockInfo not found in volumeMap."
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|v
operator|=
name|dinfo
operator|.
name|getVolume
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected error trying to delete block "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". Block not found in blockMap."
operator|+
operator|(
operator|(
name|v
operator|==
literal|null
operator|)
condition|?
literal|" "
else|:
literal|" Block found in volumeMap."
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected error trying to delete block "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". No volume for this block."
operator|+
literal|" Block found in blockMap. "
operator|+
name|f
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|File
name|parent
init|=
name|f
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected error trying to delete block "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". Parent not found for file "
operator|+
name|f
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|ReplicaState
name|replicaState
init|=
name|dinfo
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|||
operator|(
name|replicaState
operator|==
name|ReplicaState
operator|.
name|RUR
operator|&&
operator|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|dinfo
operator|)
operator|.
name|getOrignalReplicaState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|)
condition|)
block|{
name|v
operator|.
name|clearPath
argument_list|(
name|bpid
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|volumeMap
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|File
name|metaFile
init|=
name|getMetaFile
argument_list|(
name|f
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|dfsBytes
init|=
name|f
operator|.
name|length
argument_list|()
operator|+
name|metaFile
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// Delete the block asynchronously to make sure we can do it fast enough
name|asyncDiskService
operator|.
name|deleteAsync
argument_list|(
name|v
argument_list|,
name|f
argument_list|,
name|metaFile
argument_list|,
name|dfsBytes
argument_list|,
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in deleting blocks."
argument_list|)
throw|;
block|}
block|}
DECL|method|notifyNamenodeDeletedBlock (ExtendedBlock block)
specifier|public
name|void
name|notifyNamenodeDeletedBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|datanode
operator|.
name|notifyNamenodeDeletedBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turn the block identifier into a filename; ignore generation stamp!!!    */
DECL|method|getFile (String bpid, Block b)
specifier|public
specifier|synchronized
name|File
name|getFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|b
parameter_list|)
block|{
return|return
name|getFile
argument_list|(
name|bpid
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Turn the block identifier into a filename    * @param bpid Block pool Id    * @param blockId a block's id    * @return on disk data file path; null if the replica does not exist    */
DECL|method|getFile (String bpid, long blockId)
specifier|private
name|File
name|getFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
return|return
name|info
operator|.
name|getBlockFile
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * check if a data directory is healthy    * if some volumes failed - make sure to remove all the blocks that belong    * to these volumes    * @throws DiskErrorException    */
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|checkDataDir ()
specifier|public
name|void
name|checkDataDir
parameter_list|()
throws|throws
name|DiskErrorException
block|{
name|long
name|totalBlocks
init|=
literal|0
decl_stmt|,
name|removedBlocks
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|FSVolume
argument_list|>
name|failedVols
init|=
name|volumes
operator|.
name|checkDirs
argument_list|()
decl_stmt|;
comment|// If there no failed volumes return
if|if
condition|(
name|failedVols
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// Otherwise remove blocks for the failed volumes
name|long
name|mlsec
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|FSVolume
name|fv
range|:
name|failedVols
control|)
block|{
for|for
control|(
name|String
name|bpid
range|:
name|fv
operator|.
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Iterator
argument_list|<
name|ReplicaInfo
argument_list|>
name|ib
init|=
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|ib
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ReplicaInfo
name|b
init|=
name|ib
operator|.
name|next
argument_list|()
decl_stmt|;
name|totalBlocks
operator|++
expr_stmt|;
comment|// check if the volume block belongs to still valid
if|if
condition|(
name|b
operator|.
name|getVolume
argument_list|()
operator|==
name|fv
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing replica "
operator|+
name|bpid
operator|+
literal|":"
operator|+
name|b
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" on failed volume "
operator|+
name|fv
operator|.
name|currentDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|ib
operator|.
name|remove
argument_list|()
expr_stmt|;
name|removedBlocks
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// end of sync
name|mlsec
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|mlsec
expr_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removed "
operator|+
name|removedBlocks
operator|+
literal|" out of "
operator|+
name|totalBlocks
operator|+
literal|"(took "
operator|+
name|mlsec
operator|+
literal|" millisecs)"
argument_list|)
expr_stmt|;
comment|// report the error
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|FSVolume
name|fv
range|:
name|failedVols
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|fv
operator|.
name|currentDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"DataNode failed volumes:"
operator|+
name|sb
argument_list|)
throw|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSDataset{dirpath='"
operator|+
name|volumes
operator|+
literal|"'}"
return|;
block|}
DECL|field|mbeanName
specifier|private
name|ObjectName
name|mbeanName
decl_stmt|;
comment|/**    * Register the FSDataset MBean using the name    *        "hadoop:service=DataNode,name=FSDatasetState-<storageid>"    */
DECL|method|registerMBean (final String storageId)
name|void
name|registerMBean
parameter_list|(
specifier|final
name|String
name|storageId
parameter_list|)
block|{
comment|// We wrap to bypass standard mbean naming convetion.
comment|// This wraping can be removed in java 6 as it is more flexible in
comment|// package naming for mbeans and their impl.
name|StandardMBean
name|bean
decl_stmt|;
name|String
name|storageName
decl_stmt|;
if|if
condition|(
name|storageId
operator|==
literal|null
operator|||
name|storageId
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|// Temp fix for the uninitialized storage
name|storageName
operator|=
literal|"UndefinedStorageId"
operator|+
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|storageName
operator|=
name|storageId
expr_stmt|;
block|}
try|try
block|{
name|bean
operator|=
operator|new
name|StandardMBean
argument_list|(
name|this
argument_list|,
name|FSDatasetMBean
operator|.
name|class
argument_list|)
expr_stmt|;
name|mbeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"DataNode"
argument_list|,
literal|"FSDatasetState-"
operator|+
name|storageName
argument_list|,
name|bean
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotCompliantMBeanException
name|e
parameter_list|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error registering FSDatasetState MBean"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered FSDatasetState MBean"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|mbeanName
operator|!=
literal|null
condition|)
name|MBeans
operator|.
name|unregister
argument_list|(
name|mbeanName
argument_list|)
expr_stmt|;
if|if
condition|(
name|asyncDiskService
operator|!=
literal|null
condition|)
block|{
name|asyncDiskService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|volumes
operator|!=
literal|null
condition|)
block|{
name|volumes
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getStorageInfo ()
specifier|public
name|String
name|getStorageInfo
parameter_list|()
block|{
return|return
name|toString
argument_list|()
return|;
block|}
comment|/**    * Reconcile the difference between blocks on the disk and blocks in    * volumeMap    *    * Check the given block for inconsistencies. Look at the    * current state of the block and reconcile the differences as follows:    *<ul>    *<li>If the block file is missing, delete the block from volumeMap</li>    *<li>If the block file exists and the block is missing in volumeMap,    * add the block to volumeMap<li>    *<li>If generation stamp does not match, then update the block with right    * generation stamp</li>    *<li>If the block length in memory does not match the actual block file length    * then mark the block as corrupt and update the block length in memory</li>    *<li>If the file in {@link ReplicaInfo} does not match the file on    * the disk, update {@link ReplicaInfo} with the correct file</li>    *</ul>    *    * @param blockId Block that differs    * @param diskFile Block file on the disk    * @param diskMetaFile Metadata file from on the disk    * @param vol Volume of the block file    */
DECL|method|checkAndUpdate (String bpid, long blockId, File diskFile, File diskMetaFile, FSVolume vol)
specifier|public
name|void
name|checkAndUpdate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|,
name|File
name|diskFile
parameter_list|,
name|File
name|diskMetaFile
parameter_list|,
name|FSVolume
name|vol
parameter_list|)
block|{
name|Block
name|corruptBlock
init|=
literal|null
decl_stmt|;
name|ReplicaInfo
name|memBlockInfo
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|memBlockInfo
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
if|if
condition|(
name|memBlockInfo
operator|!=
literal|null
operator|&&
name|memBlockInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
comment|// Block is not finalized - ignore the difference
return|return;
block|}
specifier|final
name|long
name|diskGS
init|=
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
condition|?
name|Block
operator|.
name|getGenerationStamp
argument_list|(
name|diskMetaFile
operator|.
name|getName
argument_list|()
argument_list|)
else|:
name|GenerationStamp
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
if|if
condition|(
name|diskFile
operator|==
literal|null
operator|||
operator|!
name|diskFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memBlockInfo
operator|==
literal|null
condition|)
block|{
comment|// Block file does not exist and block does not exist in memory
comment|// If metadata file exists then delete it
if|if
condition|(
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deleted a metadata file without a block "
operator|+
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|memBlockInfo
operator|.
name|getBlockFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// Block is in memory and not on the disk
comment|// Remove the block from volumeMap
name|volumeMap
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanode
operator|.
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|blockScanner
operator|.
name|deleteBlock
argument_list|(
name|bpid
argument_list|,
operator|new
name|Block
argument_list|(
name|blockId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removed block "
operator|+
name|blockId
operator|+
literal|" from memory with missing block file on the disk"
argument_list|)
expr_stmt|;
comment|// Finally remove the metadata file
if|if
condition|(
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deleted a metadata file for the deleted block "
operator|+
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/*        * Block file exists on the disk        */
if|if
condition|(
name|memBlockInfo
operator|==
literal|null
condition|)
block|{
comment|// Block is missing in memory - add the block to volumeMap
name|ReplicaInfo
name|diskBlockInfo
init|=
operator|new
name|FinalizedReplica
argument_list|(
name|blockId
argument_list|,
name|diskFile
operator|.
name|length
argument_list|()
argument_list|,
name|diskGS
argument_list|,
name|vol
argument_list|,
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|diskBlockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanode
operator|.
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|blockScanner
operator|.
name|addBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|diskBlockInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Added missing block to memory "
operator|+
operator|(
name|Block
operator|)
name|diskBlockInfo
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*        * Block exists in volumeMap and the block file exists on the disk        */
comment|// Compare block files
name|File
name|memFile
init|=
name|memBlockInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|memFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memFile
operator|.
name|compareTo
argument_list|(
name|diskFile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block file "
operator|+
name|memFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" does not match file found by scan "
operator|+
name|diskFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Should the diskFile be deleted?
block|}
block|}
else|else
block|{
comment|// Block refers to a block file that does not exist.
comment|// Update the block with the file found on the disk. Since the block
comment|// file and metadata file are found as a pair on the disk, update
comment|// the block based on the metadata file found on the disk
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block file in volumeMap "
operator|+
name|memFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" does not exist. Updating it to the file found during scan "
operator|+
name|diskFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setDir
argument_list|(
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
name|memFile
operator|=
name|diskFile
expr_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating generation stamp for block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|" to "
operator|+
name|diskGS
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setGenerationStamp
argument_list|(
name|diskGS
argument_list|)
expr_stmt|;
block|}
comment|// Compare generation stamp
if|if
condition|(
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|diskGS
condition|)
block|{
name|File
name|memMetaFile
init|=
name|getMetaFile
argument_list|(
name|diskFile
argument_list|,
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|memMetaFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memMetaFile
operator|.
name|compareTo
argument_list|(
name|diskMetaFile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Metadata file in memory "
operator|+
name|memMetaFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" does not match file found by scan "
operator|+
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Metadata file corresponding to block in memory is missing
comment|// If metadata file found during the scan is on the same directory
comment|// as the block file, then use the generation stamp from it
name|long
name|gs
init|=
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|getParent
argument_list|()
operator|.
name|equals
argument_list|(
name|memFile
operator|.
name|getParent
argument_list|()
argument_list|)
condition|?
name|diskGS
else|:
name|GenerationStamp
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating generation stamp for block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|" to "
operator|+
name|gs
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setGenerationStamp
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Compare block size
if|if
condition|(
name|memBlockInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|memFile
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// Update the length based on the block file
name|corruptBlock
operator|=
operator|new
name|Block
argument_list|(
name|memBlockInfo
argument_list|)
expr_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating size of block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" to "
operator|+
name|memFile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setNumBytes
argument_list|(
name|memFile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Send corrupt block report outside the lock
if|if
condition|(
name|corruptBlock
operator|!=
literal|null
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reporting the block "
operator|+
name|corruptBlock
operator|+
literal|" as corrupt due to length mismatch"
argument_list|)
expr_stmt|;
try|try
block|{
name|datanode
operator|.
name|reportBadBlocks
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|corruptBlock
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to repot bad block "
operator|+
name|corruptBlock
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @deprecated use {@link #fetchReplicaInfo(String, long)} instead.    */
annotation|@
name|Override
comment|// FSDatasetInterface
annotation|@
name|Deprecated
DECL|method|getReplica (String bpid, long blockId)
specifier|public
name|ReplicaInfo
name|getReplica
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
return|return
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getReplicaString (String bpid, long blockId)
specifier|public
specifier|synchronized
name|String
name|getReplicaString
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
specifier|final
name|Replica
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
return|return
name|r
operator|==
literal|null
condition|?
literal|"null"
else|:
name|r
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|initReplicaRecovery ( RecoveringBlock rBlock)
specifier|public
specifier|synchronized
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|initReplicaRecovery
argument_list|(
name|rBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|volumeMap
argument_list|,
name|rBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
argument_list|)
return|;
block|}
comment|/** static version of {@link #initReplicaRecovery(Block, long)}. */
DECL|method|initReplicaRecovery (String bpid, ReplicasMap map, Block block, long recoveryId)
specifier|static
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicasMap
name|map
parameter_list|,
name|Block
name|block
parameter_list|,
name|long
name|recoveryId
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ReplicaInfo
name|replica
init|=
name|map
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: block="
operator|+
name|block
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
expr_stmt|;
comment|//check replica
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//stop writer if there is any
if|if
condition|(
name|replica
operator|instanceof
name|ReplicaInPipeline
condition|)
block|{
specifier|final
name|ReplicaInPipeline
name|rip
init|=
operator|(
name|ReplicaInPipeline
operator|)
name|replica
decl_stmt|;
name|rip
operator|.
name|stopWriter
argument_list|()
expr_stmt|;
comment|//check replica bytes on disk.
if|if
condition|(
name|rip
operator|.
name|getBytesOnDisk
argument_list|()
operator|<
name|rip
operator|.
name|getVisibleLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" getBytesOnDisk()< getVisibleLength(), rip="
operator|+
name|rip
argument_list|)
throw|;
block|}
comment|//check the replica's files
name|checkReplicaFiles
argument_list|(
name|rip
argument_list|)
expr_stmt|;
block|}
comment|//check generation stamp
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getGenerationStamp()< block.getGenerationStamp(), block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check recovery id
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|>=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" replica.getGenerationStamp()>= recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check RUR
specifier|final
name|ReplicaUnderRecovery
name|rur
decl_stmt|;
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RUR
condition|)
block|{
name|rur
operator|=
operator|(
name|ReplicaUnderRecovery
operator|)
name|replica
expr_stmt|;
if|if
condition|(
name|rur
operator|.
name|getRecoveryID
argument_list|()
operator|>=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
literal|"rur.getRecoveryID()>= recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", block="
operator|+
name|block
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
specifier|final
name|long
name|oldRecoveryID
init|=
name|rur
operator|.
name|getRecoveryID
argument_list|()
decl_stmt|;
name|rur
operator|.
name|setRecoveryID
argument_list|(
name|recoveryId
argument_list|)
expr_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: update recovery id for "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|oldRecoveryID
operator|+
literal|" to "
operator|+
name|recoveryId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rur
operator|=
operator|new
name|ReplicaUnderRecovery
argument_list|(
name|replica
argument_list|,
name|recoveryId
argument_list|)
expr_stmt|;
name|map
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|rur
argument_list|)
expr_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: changing replica state for "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|replica
operator|.
name|getState
argument_list|()
operator|+
literal|" to "
operator|+
name|rur
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rur
operator|.
name|createInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|updateReplicaUnderRecovery ( final ExtendedBlock oldBlock, final long recoveryId, final long newlength)
specifier|public
specifier|synchronized
name|ReplicaInfo
name|updateReplicaUnderRecovery
parameter_list|(
specifier|final
name|ExtendedBlock
name|oldBlock
parameter_list|,
specifier|final
name|long
name|recoveryId
parameter_list|,
specifier|final
name|long
name|newlength
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get replica
specifier|final
name|ReplicaInfo
name|replica
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|oldBlock
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"updateReplica: block="
operator|+
name|oldBlock
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", length="
operator|+
name|newlength
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
expr_stmt|;
comment|//check replica
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|oldBlock
argument_list|)
throw|;
block|}
comment|//check replica state
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RUR
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getState() != "
operator|+
name|ReplicaState
operator|.
name|RUR
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check replica's byte on disk
if|if
condition|(
name|replica
operator|.
name|getBytesOnDisk
argument_list|()
operator|!=
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" replica.getBytesOnDisk() != block.getNumBytes(), block="
operator|+
name|oldBlock
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check replica files before update
name|checkReplicaFiles
argument_list|(
name|replica
argument_list|)
expr_stmt|;
comment|//update replica
specifier|final
name|FinalizedReplica
name|finalized
init|=
name|updateReplicaUnderRecovery
argument_list|(
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
name|ReplicaUnderRecovery
operator|)
name|replica
argument_list|,
name|recoveryId
argument_list|,
name|newlength
argument_list|)
decl_stmt|;
comment|//check replica files after update
name|checkReplicaFiles
argument_list|(
name|finalized
argument_list|)
expr_stmt|;
return|return
name|finalized
return|;
block|}
DECL|method|updateReplicaUnderRecovery ( String bpid, ReplicaUnderRecovery rur, long recoveryId, long newlength)
specifier|private
name|FinalizedReplica
name|updateReplicaUnderRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaUnderRecovery
name|rur
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|newlength
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check recovery id
if|if
condition|(
name|rur
operator|.
name|getRecoveryID
argument_list|()
operator|!=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rur.getRecoveryID() != recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
comment|// bump rur's GS to be recovery id
name|bumpReplicaGS
argument_list|(
name|rur
argument_list|,
name|recoveryId
argument_list|)
expr_stmt|;
comment|//update length
specifier|final
name|File
name|replicafile
init|=
name|rur
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|rur
operator|.
name|getNumBytes
argument_list|()
operator|<
name|newlength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rur.getNumBytes()< newlength = "
operator|+
name|newlength
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
if|if
condition|(
name|rur
operator|.
name|getNumBytes
argument_list|()
operator|>
name|newlength
condition|)
block|{
name|rur
operator|.
name|unlinkBlock
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|truncateBlock
argument_list|(
name|replicafile
argument_list|,
name|rur
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|rur
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|newlength
argument_list|)
expr_stmt|;
comment|// update RUR with the new length
name|rur
operator|.
name|setNumBytes
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
block|}
comment|// finalize the block
return|return
name|finalizeReplica
argument_list|(
name|bpid
argument_list|,
name|rur
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetInterface
DECL|method|getReplicaVisibleLength (final ExtendedBlock block)
specifier|public
specifier|synchronized
name|long
name|getReplicaVisibleLength
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Replica
name|replica
init|=
name|getReplicaInfo
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getGenerationStamp()< block.getGenerationStamp(), block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
return|return
name|replica
operator|.
name|getVisibleLength
argument_list|()
return|;
block|}
DECL|method|addBlockPool (String bpid, Configuration conf)
specifier|public
specifier|synchronized
name|void
name|addBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding block pool "
operator|+
name|bpid
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|addBlockPool
argument_list|(
name|bpid
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|volumeMap
operator|.
name|initBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|getVolumeMap
argument_list|(
name|bpid
argument_list|,
name|volumeMap
argument_list|)
expr_stmt|;
block|}
DECL|method|shutdownBlockPool (String bpid)
specifier|public
specifier|synchronized
name|void
name|shutdownBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing block pool "
operator|+
name|bpid
argument_list|)
expr_stmt|;
name|volumeMap
operator|.
name|cleanUpBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|removeBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
comment|/**    * get list of all bpids    * @return list of bpids    */
DECL|method|getBPIdlist ()
specifier|public
name|String
index|[]
name|getBPIdlist
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|volumeMap
operator|.
name|getBlockPoolList
argument_list|()
return|;
block|}
comment|/**    * Class for representing the Datanode volume information    */
DECL|class|VolumeInfo
specifier|static
class|class
name|VolumeInfo
block|{
DECL|field|directory
specifier|final
name|String
name|directory
decl_stmt|;
DECL|field|usedSpace
specifier|final
name|long
name|usedSpace
decl_stmt|;
DECL|field|freeSpace
specifier|final
name|long
name|freeSpace
decl_stmt|;
DECL|field|reservedSpace
specifier|final
name|long
name|reservedSpace
decl_stmt|;
DECL|method|VolumeInfo (String dir, long usedSpace, long freeSpace, long reservedSpace)
name|VolumeInfo
parameter_list|(
name|String
name|dir
parameter_list|,
name|long
name|usedSpace
parameter_list|,
name|long
name|freeSpace
parameter_list|,
name|long
name|reservedSpace
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|dir
expr_stmt|;
name|this
operator|.
name|usedSpace
operator|=
name|usedSpace
expr_stmt|;
name|this
operator|.
name|freeSpace
operator|=
name|freeSpace
expr_stmt|;
name|this
operator|.
name|reservedSpace
operator|=
name|reservedSpace
expr_stmt|;
block|}
block|}
DECL|method|getVolumeInfo ()
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|getVolumeInfo
parameter_list|()
block|{
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|info
init|=
operator|new
name|ArrayList
argument_list|<
name|VolumeInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FSVolume
name|volume
range|:
name|volumes
operator|.
name|volumes
control|)
block|{
name|long
name|used
init|=
literal|0
decl_stmt|;
name|long
name|free
init|=
literal|0
decl_stmt|;
try|try
block|{
name|used
operator|=
name|volume
operator|.
name|getDfsUsed
argument_list|()
expr_stmt|;
name|free
operator|=
name|volume
operator|.
name|getAvailable
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|free
operator|=
literal|0
expr_stmt|;
block|}
name|info
operator|.
name|add
argument_list|(
operator|new
name|VolumeInfo
argument_list|(
name|volume
operator|.
name|toString
argument_list|()
argument_list|,
name|used
argument_list|,
name|free
argument_list|,
name|volume
operator|.
name|getReserved
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
annotation|@
name|Override
comment|//FSDatasetInterface
DECL|method|deleteBlockPool (String bpid, boolean force)
specifier|public
specifier|synchronized
name|void
name|deleteBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
for|for
control|(
name|FSVolume
name|volume
range|:
name|volumes
operator|.
name|volumes
control|)
block|{
if|if
condition|(
operator|!
name|volume
operator|.
name|isBPDirEmpty
argument_list|(
name|bpid
argument_list|)
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
name|bpid
operator|+
literal|" has some block files, cannot delete unless forced"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot delete block pool, "
operator|+
literal|"it contains some block files"
argument_list|)
throw|;
block|}
block|}
block|}
for|for
control|(
name|FSVolume
name|volume
range|:
name|volumes
operator|.
name|volumes
control|)
block|{
name|volume
operator|.
name|deleteBPDirectories
argument_list|(
name|bpid
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

