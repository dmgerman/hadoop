begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode.sps
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|sps
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfoWithStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|StoragePolicySatisfierMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|StoragePolicySatisfyPathStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsLocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedStripedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ErasureCodingPolicyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockStorageMovementCommand
operator|.
name|BlockMovingInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksStorageMoveAttemptFinished
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|StripedBlockUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * Setting storagePolicy on a file after the file write will only update the new  * storage policy type in Namespace, but physical block storage movement will  * not happen until user runs "Mover Tool" explicitly for such files. The  * StoragePolicySatisfier Daemon thread implemented for addressing the case  * where users may want to physically move the blocks by a dedicated daemon (can  * run inside Namenode or stand alone) instead of running mover tool explicitly.  * Just calling client API to satisfyStoragePolicy on a file/dir will  * automatically trigger to move its physical storage locations as expected in  * asynchronous manner. Here SPS will pick the file blocks which are expecting  * to change its storages, then it will build the mapping of source block  * location and expected storage type and location to move. After that this  * class will also prepare requests to send to Datanode for processing the  * physical block movements.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|StoragePolicySatisfier
specifier|public
class|class
name|StoragePolicySatisfier
parameter_list|<
name|T
parameter_list|>
implements|implements
name|SPSService
argument_list|<
name|T
argument_list|>
implements|,
name|Runnable
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StoragePolicySatisfier
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|storagePolicySatisfierThread
specifier|private
name|Daemon
name|storagePolicySatisfierThread
decl_stmt|;
DECL|field|storageMovementNeeded
specifier|private
name|BlockStorageMovementNeeded
argument_list|<
name|T
argument_list|>
name|storageMovementNeeded
decl_stmt|;
DECL|field|storageMovementsMonitor
specifier|private
name|BlockStorageMovementAttemptedItems
argument_list|<
name|T
argument_list|>
name|storageMovementsMonitor
decl_stmt|;
DECL|field|isRunning
specifier|private
specifier|volatile
name|boolean
name|isRunning
init|=
literal|false
decl_stmt|;
DECL|field|spsMode
specifier|private
specifier|volatile
name|StoragePolicySatisfierMode
name|spsMode
init|=
name|StoragePolicySatisfierMode
operator|.
name|NONE
decl_stmt|;
DECL|field|spsWorkMultiplier
specifier|private
name|int
name|spsWorkMultiplier
decl_stmt|;
DECL|field|blockCount
specifier|private
name|long
name|blockCount
init|=
literal|0L
decl_stmt|;
DECL|field|blockMovementMaxRetry
specifier|private
name|int
name|blockMovementMaxRetry
decl_stmt|;
DECL|field|ctxt
specifier|private
name|Context
argument_list|<
name|T
argument_list|>
name|ctxt
decl_stmt|;
DECL|field|blockMoveTaskHandler
specifier|private
name|BlockMoveTaskHandler
name|blockMoveTaskHandler
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|method|StoragePolicySatisfier (Configuration conf)
specifier|public
name|StoragePolicySatisfier
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|/**    * Represents the collective analysis status for all blocks.    */
DECL|class|BlocksMovingAnalysis
specifier|private
specifier|static
class|class
name|BlocksMovingAnalysis
block|{
DECL|enum|Status
enum|enum
name|Status
block|{
comment|// Represents that, the analysis skipped due to some conditions. A such
comment|// condition is if block collection is in incomplete state.
DECL|enumConstant|ANALYSIS_SKIPPED_FOR_RETRY
name|ANALYSIS_SKIPPED_FOR_RETRY
block|,
comment|// Represents that few or all blocks found respective target to do
comment|// the storage movement.
DECL|enumConstant|BLOCKS_TARGETS_PAIRED
name|BLOCKS_TARGETS_PAIRED
block|,
comment|// Represents that none of the blocks found respective target to do
comment|// the storage movement.
DECL|enumConstant|NO_BLOCKS_TARGETS_PAIRED
name|NO_BLOCKS_TARGETS_PAIRED
block|,
comment|// Represents that, none of the blocks found for block storage movements.
DECL|enumConstant|BLOCKS_ALREADY_SATISFIED
name|BLOCKS_ALREADY_SATISFIED
block|,
comment|// Represents that, the analysis skipped due to some conditions.
comment|// Example conditions are if no blocks really exists in block collection
comment|// or
comment|// if analysis is not required on ec files with unsuitable storage
comment|// policies
DECL|enumConstant|BLOCKS_TARGET_PAIRING_SKIPPED
name|BLOCKS_TARGET_PAIRING_SKIPPED
block|,
comment|// Represents that, All the reported blocks are satisfied the policy but
comment|// some of the blocks are low redundant.
DECL|enumConstant|FEW_LOW_REDUNDANCY_BLOCKS
name|FEW_LOW_REDUNDANCY_BLOCKS
block|,
comment|// Represents that, movement failures due to unexpected errors.
DECL|enumConstant|BLOCKS_FAILED_TO_MOVE
name|BLOCKS_FAILED_TO_MOVE
block|}
DECL|field|status
specifier|private
name|Status
name|status
init|=
literal|null
decl_stmt|;
DECL|field|assignedBlocks
specifier|private
name|List
argument_list|<
name|Block
argument_list|>
name|assignedBlocks
init|=
literal|null
decl_stmt|;
DECL|method|BlocksMovingAnalysis (Status status, List<Block> blockMovingInfo)
name|BlocksMovingAnalysis
parameter_list|(
name|Status
name|status
parameter_list|,
name|List
argument_list|<
name|Block
argument_list|>
name|blockMovingInfo
parameter_list|)
block|{
name|this
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|this
operator|.
name|assignedBlocks
operator|=
name|blockMovingInfo
expr_stmt|;
block|}
block|}
DECL|method|init (final Context<T> context, final FileCollector<T> fileIDCollector, final BlockMoveTaskHandler blockMovementTaskHandler, final BlockMovementListener blockMovementListener)
specifier|public
name|void
name|init
parameter_list|(
specifier|final
name|Context
argument_list|<
name|T
argument_list|>
name|context
parameter_list|,
specifier|final
name|FileCollector
argument_list|<
name|T
argument_list|>
name|fileIDCollector
parameter_list|,
specifier|final
name|BlockMoveTaskHandler
name|blockMovementTaskHandler
parameter_list|,
specifier|final
name|BlockMovementListener
name|blockMovementListener
parameter_list|)
block|{
name|this
operator|.
name|ctxt
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|storageMovementNeeded
operator|=
operator|new
name|BlockStorageMovementNeeded
argument_list|<
name|T
argument_list|>
argument_list|(
name|context
argument_list|,
name|fileIDCollector
argument_list|)
expr_stmt|;
name|this
operator|.
name|storageMovementsMonitor
operator|=
operator|new
name|BlockStorageMovementAttemptedItems
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|storageMovementNeeded
argument_list|,
name|blockMovementListener
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockMoveTaskHandler
operator|=
name|blockMovementTaskHandler
expr_stmt|;
name|this
operator|.
name|spsWorkMultiplier
operator|=
name|getSPSWorkMultiplier
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockMovementMaxRetry
operator|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_SATISFIER_MAX_RETRY_ATTEMPTS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_SATISFIER_MAX_RETRY_ATTEMPTS_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start storage policy satisfier demon thread. Also start block storage    * movements monitor for retry the attempts if needed.    */
annotation|@
name|Override
DECL|method|start (boolean reconfigStart, StoragePolicySatisfierMode serviceMode)
specifier|public
specifier|synchronized
name|void
name|start
parameter_list|(
name|boolean
name|reconfigStart
parameter_list|,
name|StoragePolicySatisfierMode
name|serviceMode
parameter_list|)
block|{
if|if
condition|(
name|serviceMode
operator|==
name|StoragePolicySatisfierMode
operator|.
name|NONE
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't start StoragePolicySatisfier for the given mode:{}"
argument_list|,
name|serviceMode
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|spsMode
operator|==
name|StoragePolicySatisfierMode
operator|.
name|INTERNAL
operator|&&
name|ctxt
operator|.
name|isMoverRunning
argument_list|()
condition|)
block|{
name|isRunning
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Stopping StoragePolicySatisfier thread "
operator|+
literal|"as Mover ID file "
operator|+
name|HdfsServerConstants
operator|.
name|MOVER_ID_PATH
operator|.
name|toString
argument_list|()
operator|+
literal|" been opened. Maybe a Mover instance is running!"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reconfigStart
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting {} StoragePolicySatisfier, as admin requested to "
operator|+
literal|"start it."
argument_list|,
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|spsMode
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting {} StoragePolicySatisfier."
argument_list|,
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|spsMode
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isRunning
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|spsMode
operator|=
name|serviceMode
expr_stmt|;
comment|// Ensure that all the previously submitted block movements(if any) have to
comment|// be stopped in all datanodes.
name|addDropSPSWorkCommandsToAllDNs
argument_list|()
expr_stmt|;
name|storagePolicySatisfierThread
operator|=
operator|new
name|Daemon
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|storagePolicySatisfierThread
operator|.
name|setName
argument_list|(
literal|"StoragePolicySatisfier"
argument_list|)
expr_stmt|;
name|storagePolicySatisfierThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|storageMovementsMonitor
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|storageMovementNeeded
operator|.
name|activate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|stop (boolean forceStop)
specifier|public
specifier|synchronized
name|void
name|stop
parameter_list|(
name|boolean
name|forceStop
parameter_list|)
block|{
name|isRunning
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|storagePolicySatisfierThread
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|storageMovementNeeded
operator|.
name|close
argument_list|()
expr_stmt|;
name|storagePolicySatisfierThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|this
operator|.
name|storageMovementsMonitor
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|forceStop
condition|)
block|{
name|storageMovementNeeded
operator|.
name|clearQueuesWithNotification
argument_list|()
expr_stmt|;
name|addDropSPSWorkCommandsToAllDNs
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping StoragePolicySatisfier."
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|stopGracefully ()
specifier|public
specifier|synchronized
name|void
name|stopGracefully
parameter_list|()
block|{
if|if
condition|(
name|isRunning
condition|)
block|{
name|stop
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|storageMovementsMonitor
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|storageMovementsMonitor
operator|.
name|stopGracefully
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|storagePolicySatisfierThread
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|storagePolicySatisfierThread
operator|.
name|join
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted Exception while waiting to join sps thread,"
operator|+
literal|" ignoring it"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|isRunning ()
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|isRunning
return|;
block|}
comment|/**    * Adding drop commands to all datanodes to stop performing the satisfier    * block movements, if any.    */
DECL|method|addDropSPSWorkCommandsToAllDNs ()
specifier|private
name|void
name|addDropSPSWorkCommandsToAllDNs
parameter_list|()
block|{
name|ctxt
operator|.
name|addDropPreviousSPSWorkAtDNs
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|isRunning
condition|)
block|{
comment|// Check if dependent service is running
if|if
condition|(
operator|!
name|ctxt
operator|.
name|isRunning
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Upstream service is down, skipping the sps work."
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
try|try
block|{
name|ItemInfo
argument_list|<
name|T
argument_list|>
name|itemInfo
init|=
literal|null
decl_stmt|;
name|boolean
name|retryItem
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|ctxt
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
name|itemInfo
operator|=
name|storageMovementNeeded
operator|.
name|get
argument_list|()
expr_stmt|;
if|if
condition|(
name|itemInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|itemInfo
operator|.
name|getRetryCount
argument_list|()
operator|>=
name|blockMovementMaxRetry
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to satisfy the policy after "
operator|+
name|blockMovementMaxRetry
operator|+
literal|" retries. Removing inode "
operator|+
name|itemInfo
operator|.
name|getFile
argument_list|()
operator|+
literal|" from the queue"
argument_list|)
expr_stmt|;
name|storageMovementNeeded
operator|.
name|removeItemTrackInfo
argument_list|(
name|itemInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|T
name|trackId
init|=
name|itemInfo
operator|.
name|getFile
argument_list|()
decl_stmt|;
name|BlocksMovingAnalysis
name|status
init|=
literal|null
decl_stmt|;
name|DatanodeStorageReport
index|[]
name|liveDnReports
decl_stmt|;
name|BlockStoragePolicy
name|existingStoragePolicy
decl_stmt|;
comment|// TODO: presently, context internally acquire the lock
comment|// and returns the result. Need to discuss to move the lock outside?
name|HdfsFileStatus
name|fileStatus
init|=
name|ctxt
operator|.
name|getFileInfo
argument_list|(
name|trackId
argument_list|)
decl_stmt|;
comment|// Check path existence.
if|if
condition|(
name|fileStatus
operator|==
literal|null
operator|||
name|fileStatus
operator|.
name|isDir
argument_list|()
condition|)
block|{
comment|// File doesn't exists (maybe got deleted) or its a directory,
comment|// just remove trackId from the queue
name|storageMovementNeeded
operator|.
name|removeItemTrackInfo
argument_list|(
name|itemInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|liveDnReports
operator|=
name|ctxt
operator|.
name|getLiveDatanodeStorageReport
argument_list|()
expr_stmt|;
name|byte
name|existingStoragePolicyID
init|=
name|fileStatus
operator|.
name|getStoragePolicy
argument_list|()
decl_stmt|;
name|existingStoragePolicy
operator|=
name|ctxt
operator|.
name|getStoragePolicy
argument_list|(
name|existingStoragePolicyID
argument_list|)
expr_stmt|;
name|HdfsLocatedFileStatus
name|file
init|=
operator|(
name|HdfsLocatedFileStatus
operator|)
name|fileStatus
decl_stmt|;
name|status
operator|=
name|analyseBlocksStorageMovementsAndAssignToDN
argument_list|(
name|file
argument_list|,
name|existingStoragePolicy
argument_list|,
name|liveDnReports
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|.
name|status
condition|)
block|{
comment|// Just add to monitor, so it will be retried after timeout
case|case
name|ANALYSIS_SKIPPED_FOR_RETRY
case|:
comment|// Just add to monitor, so it will be tracked for report and
comment|// be removed on storage movement attempt finished report.
case|case
name|BLOCKS_TARGETS_PAIRED
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block analysis status:{} for the file path:{}."
operator|+
literal|" Adding to attempt monitor queue for the storage "
operator|+
literal|"movement attempt finished report"
argument_list|,
name|status
operator|.
name|status
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|storageMovementsMonitor
operator|.
name|add
argument_list|(
operator|new
name|AttemptedItemInfo
argument_list|<
name|T
argument_list|>
argument_list|(
name|itemInfo
operator|.
name|getStartPath
argument_list|()
argument_list|,
name|itemInfo
operator|.
name|getFile
argument_list|()
argument_list|,
name|monotonicNow
argument_list|()
argument_list|,
name|status
operator|.
name|assignedBlocks
argument_list|,
name|itemInfo
operator|.
name|getRetryCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_BLOCKS_TARGETS_PAIRED
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding trackID:{} for the file path:{} back to"
operator|+
literal|" retry queue as none of the blocks found its eligible"
operator|+
literal|" targets."
argument_list|,
name|trackId
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|retryItem
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|FEW_LOW_REDUNDANCY_BLOCKS
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding trackID:{} for the file path:{} back to "
operator|+
literal|"retry queue as some of the blocks are low redundant."
argument_list|,
name|trackId
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|retryItem
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|BLOCKS_FAILED_TO_MOVE
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding trackID:{} for the file path:{} back to "
operator|+
literal|"retry queue as some of the blocks movement failed."
argument_list|,
name|trackId
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|retryItem
operator|=
literal|true
expr_stmt|;
break|break;
comment|// Just clean Xattrs
case|case
name|BLOCKS_TARGET_PAIRING_SKIPPED
case|:
case|case
name|BLOCKS_ALREADY_SATISFIED
case|:
default|default:
name|LOG
operator|.
name|info
argument_list|(
literal|"Block analysis status:{} for the file path:{}."
operator|+
literal|" So, Cleaning up the Xattrs."
argument_list|,
name|status
operator|.
name|status
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|storageMovementNeeded
operator|.
name|removeItemTrackInfo
argument_list|(
name|itemInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Namenode is in safemode. It will retry again."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
name|int
name|numLiveDn
init|=
name|ctxt
operator|.
name|getNumLiveDataNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|storageMovementNeeded
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|blockCount
operator|>
operator|(
name|numLiveDn
operator|*
name|spsWorkMultiplier
operator|)
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|blockCount
operator|=
literal|0L
expr_stmt|;
block|}
if|if
condition|(
name|retryItem
condition|)
block|{
name|itemInfo
operator|.
name|increRetryCount
argument_list|()
expr_stmt|;
name|this
operator|.
name|storageMovementNeeded
operator|.
name|add
argument_list|(
name|itemInfo
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception during StoragePolicySatisfier execution - "
operator|+
literal|"will continue next cycle"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|isRunning
condition|)
block|{
name|isRunning
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|InterruptedException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping StoragePolicySatisfier."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"StoragePolicySatisfier thread received "
operator|+
literal|"runtime exception."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|// Stopping monitor thread and clearing queues as well
name|this
operator|.
name|clearQueues
argument_list|()
expr_stmt|;
name|this
operator|.
name|storageMovementsMonitor
operator|.
name|stopGracefully
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|analyseBlocksStorageMovementsAndAssignToDN ( HdfsLocatedFileStatus fileInfo, BlockStoragePolicy existingStoragePolicy, DatanodeStorageReport[] liveDns)
specifier|private
name|BlocksMovingAnalysis
name|analyseBlocksStorageMovementsAndAssignToDN
parameter_list|(
name|HdfsLocatedFileStatus
name|fileInfo
parameter_list|,
name|BlockStoragePolicy
name|existingStoragePolicy
parameter_list|,
name|DatanodeStorageReport
index|[]
name|liveDns
parameter_list|)
block|{
name|BlocksMovingAnalysis
operator|.
name|Status
name|status
init|=
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|BLOCKS_ALREADY_SATISFIED
decl_stmt|;
specifier|final
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|fileInfo
operator|.
name|getErasureCodingPolicy
argument_list|()
decl_stmt|;
specifier|final
name|LocatedBlocks
name|locatedBlocks
init|=
name|fileInfo
operator|.
name|getLocatedBlocks
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|lastBlkComplete
init|=
name|locatedBlocks
operator|.
name|isLastBlockComplete
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lastBlkComplete
condition|)
block|{
comment|// Postpone, currently file is under construction
name|LOG
operator|.
name|info
argument_list|(
literal|"File: {} is under construction. So, postpone"
operator|+
literal|" this to the next retry iteration"
argument_list|,
name|fileInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlocksMovingAnalysis
argument_list|(
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|ANALYSIS_SKIPPED_FOR_RETRY
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
return|;
block|}
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|blocks
init|=
name|locatedBlocks
operator|.
name|getLocatedBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|blocks
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"File: {} is not having any blocks."
operator|+
literal|" So, skipping the analysis."
argument_list|,
name|fileInfo
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlocksMovingAnalysis
argument_list|(
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|BLOCKS_TARGET_PAIRING_SKIPPED
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
return|;
block|}
name|List
argument_list|<
name|BlockMovingInfo
argument_list|>
name|blockMovingInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockMovingInfo
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|hasLowRedundancyBlocks
init|=
literal|false
decl_stmt|;
name|int
name|replication
init|=
name|fileInfo
operator|.
name|getReplication
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|LocatedBlock
name|blockInfo
init|=
name|blocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Block is considered as low redundancy when the block locations array
comment|// length is less than expected replication factor. If any of the block is
comment|// low redundant, then hasLowRedundancyBlocks will be marked as true.
name|hasLowRedundancyBlocks
operator||=
name|isLowRedundancyBlock
argument_list|(
name|blockInfo
argument_list|,
name|replication
argument_list|,
name|ecPolicy
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|StorageType
argument_list|>
name|expectedStorageTypes
decl_stmt|;
if|if
condition|(
name|blockInfo
operator|.
name|isStriped
argument_list|()
condition|)
block|{
if|if
condition|(
name|ErasureCodingPolicyManager
operator|.
name|checkStoragePolicySuitableForECStripedMode
argument_list|(
name|existingStoragePolicy
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|expectedStorageTypes
operator|=
name|existingStoragePolicy
operator|.
name|chooseStorageTypes
argument_list|(
operator|(
name|short
operator|)
name|blockInfo
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Currently we support only limited policies (HOT, COLD, ALLSSD)
comment|// for EC striped mode files. SPS will ignore to move the blocks if
comment|// the storage policy is not in EC Striped mode supported policies
name|LOG
operator|.
name|warn
argument_list|(
literal|"The storage policy "
operator|+
name|existingStoragePolicy
operator|.
name|getName
argument_list|()
operator|+
literal|" is not suitable for Striped EC files. "
operator|+
literal|"So, ignoring to move the blocks"
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlocksMovingAnalysis
argument_list|(
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|BLOCKS_TARGET_PAIRING_SKIPPED
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|expectedStorageTypes
operator|=
name|existingStoragePolicy
operator|.
name|chooseStorageTypes
argument_list|(
name|fileInfo
operator|.
name|getReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|StorageType
argument_list|>
name|existing
init|=
operator|new
name|LinkedList
argument_list|<
name|StorageType
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|blockInfo
operator|.
name|getStorageTypes
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|removeOverlapBetweenStorageTypes
argument_list|(
name|expectedStorageTypes
argument_list|,
name|existing
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|boolean
name|blocksPaired
init|=
name|computeBlockMovingInfos
argument_list|(
name|blockMovingInfos
argument_list|,
name|blockInfo
argument_list|,
name|expectedStorageTypes
argument_list|,
name|existing
argument_list|,
name|blockInfo
operator|.
name|getLocations
argument_list|()
argument_list|,
name|liveDns
argument_list|,
name|ecPolicy
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocksPaired
condition|)
block|{
name|status
operator|=
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|BLOCKS_TARGETS_PAIRED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|BLOCKS_TARGETS_PAIRED
condition|)
block|{
comment|// Check if the previous block was successfully paired. Here the
comment|// status will set to NO_BLOCKS_TARGETS_PAIRED only when none of the
comment|// blocks of a file found its eligible targets to satisfy the storage
comment|// policy.
name|status
operator|=
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|NO_BLOCKS_TARGETS_PAIRED
expr_stmt|;
block|}
block|}
block|}
comment|// If there is no block paired and few blocks are low redundant, so marking
comment|// the status as FEW_LOW_REDUNDANCY_BLOCKS.
if|if
condition|(
name|hasLowRedundancyBlocks
operator|&&
name|status
operator|==
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|NO_BLOCKS_TARGETS_PAIRED
condition|)
block|{
name|status
operator|=
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|FEW_LOW_REDUNDANCY_BLOCKS
expr_stmt|;
block|}
name|List
argument_list|<
name|Block
argument_list|>
name|assignedBlockIds
init|=
operator|new
name|ArrayList
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockMovingInfo
name|blkMovingInfo
range|:
name|blockMovingInfos
control|)
block|{
comment|// Check for at least one block storage movement has been chosen
try|try
block|{
name|blockMoveTaskHandler
operator|.
name|submitMoveTask
argument_list|(
name|blkMovingInfo
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"BlockMovingInfo: {}"
argument_list|,
name|blkMovingInfo
argument_list|)
expr_stmt|;
name|assignedBlockIds
operator|.
name|add
argument_list|(
name|blkMovingInfo
operator|.
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|blockCount
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while scheduling movement task"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// failed to move the block.
name|status
operator|=
name|BlocksMovingAnalysis
operator|.
name|Status
operator|.
name|BLOCKS_FAILED_TO_MOVE
expr_stmt|;
block|}
block|}
return|return
operator|new
name|BlocksMovingAnalysis
argument_list|(
name|status
argument_list|,
name|assignedBlockIds
argument_list|)
return|;
block|}
comment|/**    * The given block is considered as low redundancy when the block locations    * length is less than expected replication factor. For EC blocks, redundancy    * is the summation of data + parity blocks.    *    * @param blockInfo    *          block    * @param replication    *          replication factor of the given file block    * @param ecPolicy    *          erasure coding policy of the given file block    * @return true if the given block is low redundant.    */
DECL|method|isLowRedundancyBlock (LocatedBlock blockInfo, int replication, ErasureCodingPolicy ecPolicy)
specifier|private
name|boolean
name|isLowRedundancyBlock
parameter_list|(
name|LocatedBlock
name|blockInfo
parameter_list|,
name|int
name|replication
parameter_list|,
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|)
block|{
name|boolean
name|hasLowRedundancyBlock
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|blockInfo
operator|.
name|isStriped
argument_list|()
condition|)
block|{
comment|// For EC blocks, redundancy is the summation of data + parity blocks.
name|replication
operator|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
operator|+
name|ecPolicy
operator|.
name|getNumParityUnits
argument_list|()
expr_stmt|;
block|}
comment|// block is considered as low redundancy when the block locations length is
comment|// less than expected replication factor.
name|hasLowRedundancyBlock
operator|=
name|blockInfo
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|<
name|replication
condition|?
literal|true
else|:
literal|false
expr_stmt|;
return|return
name|hasLowRedundancyBlock
return|;
block|}
comment|/**    * Compute the list of block moving information corresponding to the given    * blockId. This will check that each block location of the given block is    * satisfying the expected storage policy. If block location is not satisfied    * the policy then find out the target node with the expected storage type to    * satisfy the storage policy.    *    * @param blockMovingInfos    *          - list of block source and target node pair    * @param blockInfo    *          - block details    * @param expectedStorageTypes    *          - list of expected storage type to satisfy the storage policy    * @param existing    *          - list to get existing storage types    * @param storages    *          - available storages    * @return false if some of the block locations failed to find target node to    *         satisfy the storage policy, true otherwise    */
DECL|method|computeBlockMovingInfos ( List<BlockMovingInfo> blockMovingInfos, LocatedBlock blockInfo, List<StorageType> expectedStorageTypes, List<StorageType> existing, DatanodeInfo[] storages, DatanodeStorageReport[] liveDns, ErasureCodingPolicy ecPolicy)
specifier|private
name|boolean
name|computeBlockMovingInfos
parameter_list|(
name|List
argument_list|<
name|BlockMovingInfo
argument_list|>
name|blockMovingInfos
parameter_list|,
name|LocatedBlock
name|blockInfo
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|expectedStorageTypes
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|existing
parameter_list|,
name|DatanodeInfo
index|[]
name|storages
parameter_list|,
name|DatanodeStorageReport
index|[]
name|liveDns
parameter_list|,
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|)
block|{
name|boolean
name|foundMatchingTargetNodesForBlock
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|removeOverlapBetweenStorageTypes
argument_list|(
name|expectedStorageTypes
argument_list|,
name|existing
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|StorageTypeNodePair
argument_list|>
name|sourceWithStorageMap
init|=
operator|new
name|ArrayList
argument_list|<
name|StorageTypeNodePair
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|existingBlockStorages
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|storages
argument_list|)
argument_list|)
decl_stmt|;
comment|// if expected type exists in source node already, local movement would be
comment|// possible, so lets find such sources first.
name|Iterator
argument_list|<
name|DatanodeInfo
argument_list|>
name|iterator
init|=
name|existingBlockStorages
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeInfoWithStorage
name|dnInfo
init|=
operator|(
name|DatanodeInfoWithStorage
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|checkSourceAndTargetTypeExists
argument_list|(
name|dnInfo
argument_list|,
name|existing
argument_list|,
name|expectedStorageTypes
argument_list|,
name|liveDns
argument_list|)
condition|)
block|{
name|sourceWithStorageMap
operator|.
name|add
argument_list|(
operator|new
name|StorageTypeNodePair
argument_list|(
name|dnInfo
operator|.
name|getStorageType
argument_list|()
argument_list|,
name|dnInfo
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|existing
operator|.
name|remove
argument_list|(
name|dnInfo
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Let's find sources for existing types left.
for|for
control|(
name|StorageType
name|existingType
range|:
name|existing
control|)
block|{
name|iterator
operator|=
name|existingBlockStorages
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeInfoWithStorage
name|dnStorageInfo
init|=
operator|(
name|DatanodeInfoWithStorage
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|StorageType
name|storageType
init|=
name|dnStorageInfo
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
if|if
condition|(
name|storageType
operator|==
name|existingType
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|sourceWithStorageMap
operator|.
name|add
argument_list|(
operator|new
name|StorageTypeNodePair
argument_list|(
name|storageType
argument_list|,
name|dnStorageInfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|StorageTypeNodeMap
name|locsForExpectedStorageTypes
init|=
name|findTargetsForExpectedStorageTypes
argument_list|(
name|expectedStorageTypes
argument_list|,
name|liveDns
argument_list|)
decl_stmt|;
name|foundMatchingTargetNodesForBlock
operator||=
name|findSourceAndTargetToMove
argument_list|(
name|blockMovingInfos
argument_list|,
name|blockInfo
argument_list|,
name|sourceWithStorageMap
argument_list|,
name|expectedStorageTypes
argument_list|,
name|locsForExpectedStorageTypes
argument_list|,
name|ecPolicy
argument_list|)
expr_stmt|;
block|}
return|return
name|foundMatchingTargetNodesForBlock
return|;
block|}
comment|/**    * Find the good target node for each source node for which block storages was    * misplaced.    *    * @param blockMovingInfos    *          - list of block source and target node pair    * @param blockInfo    *          - Block    * @param sourceWithStorageList    *          - Source Datanode with storages list    * @param expected    *          - Expecting storages to move    * @param locsForExpectedStorageTypes    *          - Available DNs for expected storage types    * @return false if some of the block locations failed to find target node to    *         satisfy the storage policy    */
DECL|method|findSourceAndTargetToMove ( List<BlockMovingInfo> blockMovingInfos, LocatedBlock blockInfo, List<StorageTypeNodePair> sourceWithStorageList, List<StorageType> expected, StorageTypeNodeMap locsForExpectedStorageTypes, ErasureCodingPolicy ecPolicy)
specifier|private
name|boolean
name|findSourceAndTargetToMove
parameter_list|(
name|List
argument_list|<
name|BlockMovingInfo
argument_list|>
name|blockMovingInfos
parameter_list|,
name|LocatedBlock
name|blockInfo
parameter_list|,
name|List
argument_list|<
name|StorageTypeNodePair
argument_list|>
name|sourceWithStorageList
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|expected
parameter_list|,
name|StorageTypeNodeMap
name|locsForExpectedStorageTypes
parameter_list|,
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|)
block|{
name|boolean
name|foundMatchingTargetNodesForBlock
init|=
literal|true
decl_stmt|;
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|excludeNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Looping over all the source node locations and choose the target
comment|// storage within same node if possible. This is done separately to
comment|// avoid choosing a target which already has this block.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceWithStorageList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StorageTypeNodePair
name|existingTypeNodePair
init|=
name|sourceWithStorageList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Check whether the block replica is already placed in the expected
comment|// storage type in this source datanode.
if|if
condition|(
operator|!
name|expected
operator|.
name|contains
argument_list|(
name|existingTypeNodePair
operator|.
name|storageType
argument_list|)
condition|)
block|{
name|StorageTypeNodePair
name|chosenTarget
init|=
name|chooseTargetTypeInSameNode
argument_list|(
name|blockInfo
argument_list|,
name|existingTypeNodePair
operator|.
name|dn
argument_list|,
name|expected
argument_list|)
decl_stmt|;
if|if
condition|(
name|chosenTarget
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|blockInfo
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|buildStripedBlockMovingInfos
argument_list|(
name|blockInfo
argument_list|,
name|existingTypeNodePair
operator|.
name|dn
argument_list|,
name|existingTypeNodePair
operator|.
name|storageType
argument_list|,
name|chosenTarget
operator|.
name|dn
argument_list|,
name|chosenTarget
operator|.
name|storageType
argument_list|,
name|blockMovingInfos
argument_list|,
name|ecPolicy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buildContinuousBlockMovingInfos
argument_list|(
name|blockInfo
argument_list|,
name|existingTypeNodePair
operator|.
name|dn
argument_list|,
name|existingTypeNodePair
operator|.
name|storageType
argument_list|,
name|chosenTarget
operator|.
name|dn
argument_list|,
name|chosenTarget
operator|.
name|storageType
argument_list|,
name|blockMovingInfos
argument_list|)
expr_stmt|;
block|}
name|expected
operator|.
name|remove
argument_list|(
name|chosenTarget
operator|.
name|storageType
argument_list|)
expr_stmt|;
block|}
block|}
comment|// To avoid choosing this excludeNodes as targets later
name|excludeNodes
operator|.
name|add
argument_list|(
name|existingTypeNodePair
operator|.
name|dn
argument_list|)
expr_stmt|;
block|}
comment|// Looping over all the source node locations. Choose a remote target
comment|// storage node if it was not found out within same node.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceWithStorageList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StorageTypeNodePair
name|existingTypeNodePair
init|=
name|sourceWithStorageList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|StorageTypeNodePair
name|chosenTarget
init|=
literal|null
decl_stmt|;
comment|// Chosen the target storage within same datanode. So just skipping this
comment|// source node.
if|if
condition|(
name|checkIfAlreadyChosen
argument_list|(
name|blockMovingInfos
argument_list|,
name|existingTypeNodePair
operator|.
name|dn
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|chosenTarget
operator|==
literal|null
operator|&&
name|ctxt
operator|.
name|getNetworkTopology
argument_list|()
operator|.
name|isNodeGroupAware
argument_list|()
condition|)
block|{
name|chosenTarget
operator|=
name|chooseTarget
argument_list|(
name|blockInfo
argument_list|,
name|existingTypeNodePair
operator|.
name|dn
argument_list|,
name|expected
argument_list|,
name|Matcher
operator|.
name|SAME_NODE_GROUP
argument_list|,
name|locsForExpectedStorageTypes
argument_list|,
name|excludeNodes
argument_list|)
expr_stmt|;
block|}
comment|// Then, match nodes on the same rack
if|if
condition|(
name|chosenTarget
operator|==
literal|null
condition|)
block|{
name|chosenTarget
operator|=
name|chooseTarget
argument_list|(
name|blockInfo
argument_list|,
name|existingTypeNodePair
operator|.
name|dn
argument_list|,
name|expected
argument_list|,
name|Matcher
operator|.
name|SAME_RACK
argument_list|,
name|locsForExpectedStorageTypes
argument_list|,
name|excludeNodes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chosenTarget
operator|==
literal|null
condition|)
block|{
name|chosenTarget
operator|=
name|chooseTarget
argument_list|(
name|blockInfo
argument_list|,
name|existingTypeNodePair
operator|.
name|dn
argument_list|,
name|expected
argument_list|,
name|Matcher
operator|.
name|ANY_OTHER
argument_list|,
name|locsForExpectedStorageTypes
argument_list|,
name|excludeNodes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|chosenTarget
condition|)
block|{
if|if
condition|(
name|blockInfo
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|buildStripedBlockMovingInfos
argument_list|(
name|blockInfo
argument_list|,
name|existingTypeNodePair
operator|.
name|dn
argument_list|,
name|existingTypeNodePair
operator|.
name|storageType
argument_list|,
name|chosenTarget
operator|.
name|dn
argument_list|,
name|chosenTarget
operator|.
name|storageType
argument_list|,
name|blockMovingInfos
argument_list|,
name|ecPolicy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buildContinuousBlockMovingInfos
argument_list|(
name|blockInfo
argument_list|,
name|existingTypeNodePair
operator|.
name|dn
argument_list|,
name|existingTypeNodePair
operator|.
name|storageType
argument_list|,
name|chosenTarget
operator|.
name|dn
argument_list|,
name|chosenTarget
operator|.
name|storageType
argument_list|,
name|blockMovingInfos
argument_list|)
expr_stmt|;
block|}
name|expected
operator|.
name|remove
argument_list|(
name|chosenTarget
operator|.
name|storageType
argument_list|)
expr_stmt|;
name|excludeNodes
operator|.
name|add
argument_list|(
name|chosenTarget
operator|.
name|dn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to choose target datanode for the required"
operator|+
literal|" storage types {}, block:{}, existing storage type:{}"
argument_list|,
name|expected
argument_list|,
name|blockInfo
argument_list|,
name|existingTypeNodePair
operator|.
name|storageType
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expected
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|foundMatchingTargetNodesForBlock
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|foundMatchingTargetNodesForBlock
return|;
block|}
DECL|method|checkIfAlreadyChosen (List<BlockMovingInfo> blockMovingInfos, DatanodeInfo dn)
specifier|private
name|boolean
name|checkIfAlreadyChosen
parameter_list|(
name|List
argument_list|<
name|BlockMovingInfo
argument_list|>
name|blockMovingInfos
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
block|{
for|for
control|(
name|BlockMovingInfo
name|blockMovingInfo
range|:
name|blockMovingInfos
control|)
block|{
if|if
condition|(
name|blockMovingInfo
operator|.
name|getSource
argument_list|()
operator|.
name|equals
argument_list|(
name|dn
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|buildContinuousBlockMovingInfos (LocatedBlock blockInfo, DatanodeInfo sourceNode, StorageType sourceStorageType, DatanodeInfo targetNode, StorageType targetStorageType, List<BlockMovingInfo> blkMovingInfos)
specifier|private
name|void
name|buildContinuousBlockMovingInfos
parameter_list|(
name|LocatedBlock
name|blockInfo
parameter_list|,
name|DatanodeInfo
name|sourceNode
parameter_list|,
name|StorageType
name|sourceStorageType
parameter_list|,
name|DatanodeInfo
name|targetNode
parameter_list|,
name|StorageType
name|targetStorageType
parameter_list|,
name|List
argument_list|<
name|BlockMovingInfo
argument_list|>
name|blkMovingInfos
parameter_list|)
block|{
name|Block
name|blk
init|=
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|blockInfo
operator|.
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
name|BlockMovingInfo
name|blkMovingInfo
init|=
operator|new
name|BlockMovingInfo
argument_list|(
name|blk
argument_list|,
name|sourceNode
argument_list|,
name|targetNode
argument_list|,
name|sourceStorageType
argument_list|,
name|targetStorageType
argument_list|)
decl_stmt|;
name|blkMovingInfos
operator|.
name|add
argument_list|(
name|blkMovingInfo
argument_list|)
expr_stmt|;
block|}
DECL|method|buildStripedBlockMovingInfos (LocatedBlock blockInfo, DatanodeInfo sourceNode, StorageType sourceStorageType, DatanodeInfo targetNode, StorageType targetStorageType, List<BlockMovingInfo> blkMovingInfos, ErasureCodingPolicy ecPolicy)
specifier|private
name|void
name|buildStripedBlockMovingInfos
parameter_list|(
name|LocatedBlock
name|blockInfo
parameter_list|,
name|DatanodeInfo
name|sourceNode
parameter_list|,
name|StorageType
name|sourceStorageType
parameter_list|,
name|DatanodeInfo
name|targetNode
parameter_list|,
name|StorageType
name|targetStorageType
parameter_list|,
name|List
argument_list|<
name|BlockMovingInfo
argument_list|>
name|blkMovingInfos
parameter_list|,
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|)
block|{
comment|// For a striped block, it needs to construct internal block at the given
comment|// index of a block group. Here it is iterating over all the block indices
comment|// and construct internal blocks which can be then considered for block
comment|// movement.
name|LocatedStripedBlock
name|sBlockInfo
init|=
operator|(
name|LocatedStripedBlock
operator|)
name|blockInfo
decl_stmt|;
name|byte
index|[]
name|indices
init|=
name|sBlockInfo
operator|.
name|getBlockIndices
argument_list|()
decl_stmt|;
name|DatanodeInfo
index|[]
name|locations
init|=
name|sBlockInfo
operator|.
name|getLocations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|blkIndex
init|=
name|indices
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|blkIndex
operator|>=
literal|0
condition|)
block|{
comment|// pick block movement only for the given source node.
if|if
condition|(
name|sourceNode
operator|.
name|equals
argument_list|(
name|locations
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|// construct internal block
name|ExtendedBlock
name|extBlock
init|=
name|sBlockInfo
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|long
name|numBytes
init|=
name|StripedBlockUtil
operator|.
name|getInternalBlockLength
argument_list|(
name|extBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|ecPolicy
argument_list|,
name|blkIndex
argument_list|)
decl_stmt|;
name|Block
name|blk
init|=
operator|new
name|Block
argument_list|(
name|ExtendedBlock
operator|.
name|getLocalBlock
argument_list|(
name|extBlock
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|blkId
init|=
name|blk
operator|.
name|getBlockId
argument_list|()
operator|+
name|blkIndex
decl_stmt|;
name|blk
operator|.
name|setBlockId
argument_list|(
name|blkId
argument_list|)
expr_stmt|;
name|blk
operator|.
name|setNumBytes
argument_list|(
name|numBytes
argument_list|)
expr_stmt|;
name|BlockMovingInfo
name|blkMovingInfo
init|=
operator|new
name|BlockMovingInfo
argument_list|(
name|blk
argument_list|,
name|sourceNode
argument_list|,
name|targetNode
argument_list|,
name|sourceStorageType
argument_list|,
name|targetStorageType
argument_list|)
decl_stmt|;
name|blkMovingInfos
operator|.
name|add
argument_list|(
name|blkMovingInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Choose the target storage within same datanode if possible.    *    * @param block    *          - block info    * @param source    *          - source datanode    * @param targetTypes    *          - list of target storage types    */
DECL|method|chooseTargetTypeInSameNode (LocatedBlock blockInfo, DatanodeInfo source, List<StorageType> targetTypes)
specifier|private
name|StorageTypeNodePair
name|chooseTargetTypeInSameNode
parameter_list|(
name|LocatedBlock
name|blockInfo
parameter_list|,
name|DatanodeInfo
name|source
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|targetTypes
parameter_list|)
block|{
for|for
control|(
name|StorageType
name|t
range|:
name|targetTypes
control|)
block|{
name|boolean
name|goodTargetDn
init|=
name|ctxt
operator|.
name|checkDNSpaceForScheduling
argument_list|(
name|source
argument_list|,
name|t
argument_list|,
name|blockInfo
operator|.
name|getBlockSize
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|goodTargetDn
condition|)
block|{
return|return
operator|new
name|StorageTypeNodePair
argument_list|(
name|t
argument_list|,
name|source
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|chooseTarget (LocatedBlock block, DatanodeInfo source, List<StorageType> targetTypes, Matcher matcher, StorageTypeNodeMap locsForExpectedStorageTypes, List<DatanodeInfo> excludeNodes)
specifier|private
name|StorageTypeNodePair
name|chooseTarget
parameter_list|(
name|LocatedBlock
name|block
parameter_list|,
name|DatanodeInfo
name|source
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|targetTypes
parameter_list|,
name|Matcher
name|matcher
parameter_list|,
name|StorageTypeNodeMap
name|locsForExpectedStorageTypes
parameter_list|,
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|excludeNodes
parameter_list|)
block|{
for|for
control|(
name|StorageType
name|t
range|:
name|targetTypes
control|)
block|{
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|nodesWithStorages
init|=
name|locsForExpectedStorageTypes
operator|.
name|getNodesWithStorages
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodesWithStorages
operator|==
literal|null
operator|||
name|nodesWithStorages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
comment|// no target nodes with the required storage type.
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|nodesWithStorages
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeInfo
name|target
range|:
name|nodesWithStorages
control|)
block|{
if|if
condition|(
operator|!
name|excludeNodes
operator|.
name|contains
argument_list|(
name|target
argument_list|)
operator|&&
name|matcher
operator|.
name|match
argument_list|(
name|ctxt
operator|.
name|getNetworkTopology
argument_list|()
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|boolean
name|goodTargetDn
init|=
name|ctxt
operator|.
name|checkDNSpaceForScheduling
argument_list|(
name|target
argument_list|,
name|t
argument_list|,
name|block
operator|.
name|getBlockSize
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|goodTargetDn
condition|)
block|{
return|return
operator|new
name|StorageTypeNodePair
argument_list|(
name|t
argument_list|,
name|target
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|class|StorageTypeNodePair
specifier|private
specifier|static
class|class
name|StorageTypeNodePair
block|{
DECL|field|storageType
specifier|private
name|StorageType
name|storageType
init|=
literal|null
decl_stmt|;
DECL|field|dn
specifier|private
name|DatanodeInfo
name|dn
init|=
literal|null
decl_stmt|;
DECL|method|StorageTypeNodePair (StorageType storageType, DatanodeInfo dn)
name|StorageTypeNodePair
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
block|{
name|this
operator|.
name|storageType
operator|=
name|storageType
expr_stmt|;
name|this
operator|.
name|dn
operator|=
name|dn
expr_stmt|;
block|}
block|}
DECL|method|findTargetsForExpectedStorageTypes ( List<StorageType> expected, DatanodeStorageReport[] liveDns)
specifier|private
name|StorageTypeNodeMap
name|findTargetsForExpectedStorageTypes
parameter_list|(
name|List
argument_list|<
name|StorageType
argument_list|>
name|expected
parameter_list|,
name|DatanodeStorageReport
index|[]
name|liveDns
parameter_list|)
block|{
name|StorageTypeNodeMap
name|targetMap
init|=
operator|new
name|StorageTypeNodeMap
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeStorageReport
name|dn
range|:
name|liveDns
control|)
block|{
name|StorageReport
index|[]
name|storageReports
init|=
name|dn
operator|.
name|getStorageReports
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageReport
name|storageReport
range|:
name|storageReports
control|)
block|{
name|StorageType
name|t
init|=
name|storageReport
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
if|if
condition|(
name|expected
operator|.
name|contains
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|final
name|long
name|maxRemaining
init|=
name|getMaxRemaining
argument_list|(
name|dn
operator|.
name|getStorageReports
argument_list|()
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxRemaining
operator|>
literal|0L
condition|)
block|{
name|targetMap
operator|.
name|add
argument_list|(
name|t
argument_list|,
name|dn
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|targetMap
return|;
block|}
DECL|method|getMaxRemaining (StorageReport[] storageReports, StorageType t)
specifier|private
specifier|static
name|long
name|getMaxRemaining
parameter_list|(
name|StorageReport
index|[]
name|storageReports
parameter_list|,
name|StorageType
name|t
parameter_list|)
block|{
name|long
name|max
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|StorageReport
name|r
range|:
name|storageReports
control|)
block|{
if|if
condition|(
name|r
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageType
argument_list|()
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|r
operator|.
name|getRemaining
argument_list|()
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|r
operator|.
name|getRemaining
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|max
return|;
block|}
DECL|method|checkSourceAndTargetTypeExists (DatanodeInfo dn, List<StorageType> existing, List<StorageType> expectedStorageTypes, DatanodeStorageReport[] liveDns)
specifier|private
name|boolean
name|checkSourceAndTargetTypeExists
parameter_list|(
name|DatanodeInfo
name|dn
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|existing
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|expectedStorageTypes
parameter_list|,
name|DatanodeStorageReport
index|[]
name|liveDns
parameter_list|)
block|{
name|boolean
name|isExpectedTypeAvailable
init|=
literal|false
decl_stmt|;
name|boolean
name|isExistingTypeAvailable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|DatanodeStorageReport
name|liveDn
range|:
name|liveDns
control|)
block|{
if|if
condition|(
name|dn
operator|.
name|equals
argument_list|(
name|liveDn
operator|.
name|getDatanodeInfo
argument_list|()
argument_list|)
condition|)
block|{
name|StorageReport
index|[]
name|storageReports
init|=
name|liveDn
operator|.
name|getStorageReports
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageReport
name|eachStorage
range|:
name|storageReports
control|)
block|{
name|StorageType
name|storageType
init|=
name|eachStorage
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
if|if
condition|(
name|existing
operator|.
name|contains
argument_list|(
name|storageType
argument_list|)
condition|)
block|{
name|isExistingTypeAvailable
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|expectedStorageTypes
operator|.
name|contains
argument_list|(
name|storageType
argument_list|)
condition|)
block|{
name|isExpectedTypeAvailable
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|isExistingTypeAvailable
operator|&&
name|isExpectedTypeAvailable
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
name|isExistingTypeAvailable
operator|&&
name|isExpectedTypeAvailable
return|;
block|}
DECL|class|StorageTypeNodeMap
specifier|private
specifier|static
class|class
name|StorageTypeNodeMap
block|{
DECL|field|typeNodeMap
specifier|private
specifier|final
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
name|typeNodeMap
init|=
operator|new
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|add (StorageType t, DatanodeInfo dn)
specifier|private
name|void
name|add
parameter_list|(
name|StorageType
name|t
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|nodesWithStorages
init|=
name|getNodesWithStorages
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|LinkedList
argument_list|<
name|DatanodeInfo
argument_list|>
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodesWithStorages
operator|==
literal|null
condition|)
block|{
name|value
operator|=
operator|new
name|LinkedList
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|()
expr_stmt|;
name|value
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|typeNodeMap
operator|.
name|put
argument_list|(
name|t
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodesWithStorages
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param type      *          - Storage type      * @return datanodes which has the given storage type      */
DECL|method|getNodesWithStorages (StorageType type)
specifier|private
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|getNodesWithStorages
parameter_list|(
name|StorageType
name|type
parameter_list|)
block|{
return|return
name|typeNodeMap
operator|.
name|get
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
comment|/**    * Receives set of storage movement attempt finished blocks report.    *    * @param moveAttemptFinishedBlks    *          set of storage movement attempt finished blocks.    */
DECL|method|notifyStorageMovementAttemptFinishedBlks ( BlocksStorageMoveAttemptFinished moveAttemptFinishedBlks)
specifier|public
name|void
name|notifyStorageMovementAttemptFinishedBlks
parameter_list|(
name|BlocksStorageMoveAttemptFinished
name|moveAttemptFinishedBlks
parameter_list|)
block|{
if|if
condition|(
name|moveAttemptFinishedBlks
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
name|storageMovementsMonitor
operator|.
name|notifyMovementTriedBlocks
argument_list|(
name|moveAttemptFinishedBlks
operator|.
name|getBlocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAttemptedItemsMonitor ()
specifier|public
name|BlockStorageMovementAttemptedItems
argument_list|<
name|T
argument_list|>
name|getAttemptedItemsMonitor
parameter_list|()
block|{
return|return
name|storageMovementsMonitor
return|;
block|}
comment|/**    * Clear the queues from to be storage movement needed lists and items tracked    * in storage movement monitor.    */
DECL|method|clearQueues ()
specifier|public
name|void
name|clearQueues
parameter_list|()
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Clearing all the queues from StoragePolicySatisfier. So, "
operator|+
literal|"user requests on satisfying block storages would be discarded."
argument_list|)
expr_stmt|;
name|storageMovementNeeded
operator|.
name|clearAll
argument_list|()
expr_stmt|;
block|}
comment|/**    * Clear queues for given track id.    */
DECL|method|clearQueue (T trackId)
specifier|public
name|void
name|clearQueue
parameter_list|(
name|T
name|trackId
parameter_list|)
block|{
name|storageMovementNeeded
operator|.
name|clearQueue
argument_list|(
name|trackId
argument_list|)
expr_stmt|;
block|}
comment|/**    * This class contains information of an attempted blocks and its last    * attempted or reported time stamp. This is used by    * {@link BlockStorageMovementAttemptedItems#storageMovementAttemptedItems}.    */
DECL|class|AttemptedItemInfo
specifier|final
specifier|static
class|class
name|AttemptedItemInfo
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ItemInfo
argument_list|<
name|T
argument_list|>
block|{
DECL|field|lastAttemptedOrReportedTime
specifier|private
name|long
name|lastAttemptedOrReportedTime
decl_stmt|;
DECL|field|blocks
specifier|private
specifier|final
name|List
argument_list|<
name|Block
argument_list|>
name|blocks
decl_stmt|;
comment|/**      * AttemptedItemInfo constructor.      *      * @param rootId      *          rootId for trackId      * @param trackId      *          trackId for file.      * @param lastAttemptedOrReportedTime      *          last attempted or reported time      */
DECL|method|AttemptedItemInfo (T rootId, T trackId, long lastAttemptedOrReportedTime, List<Block> blocks, int retryCount)
name|AttemptedItemInfo
parameter_list|(
name|T
name|rootId
parameter_list|,
name|T
name|trackId
parameter_list|,
name|long
name|lastAttemptedOrReportedTime
parameter_list|,
name|List
argument_list|<
name|Block
argument_list|>
name|blocks
parameter_list|,
name|int
name|retryCount
parameter_list|)
block|{
name|super
argument_list|(
name|rootId
argument_list|,
name|trackId
argument_list|,
name|retryCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|lastAttemptedOrReportedTime
operator|=
name|lastAttemptedOrReportedTime
expr_stmt|;
name|this
operator|.
name|blocks
operator|=
name|blocks
expr_stmt|;
block|}
comment|/**      * @return last attempted or reported time stamp.      */
DECL|method|getLastAttemptedOrReportedTime ()
name|long
name|getLastAttemptedOrReportedTime
parameter_list|()
block|{
return|return
name|lastAttemptedOrReportedTime
return|;
block|}
comment|/**      * Update lastAttemptedOrReportedTime, so that the expiration time will be      * postponed to future.      */
DECL|method|touchLastReportedTimeStamp ()
name|void
name|touchLastReportedTimeStamp
parameter_list|()
block|{
name|this
operator|.
name|lastAttemptedOrReportedTime
operator|=
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
DECL|method|getBlocks ()
name|List
argument_list|<
name|Block
argument_list|>
name|getBlocks
parameter_list|()
block|{
return|return
name|this
operator|.
name|blocks
return|;
block|}
block|}
comment|/**    * Returns sps invoked path status. This method is used by internal satisfy    * storage policy service.    *    * @param path    *          sps path    * @return storage policy satisfy path status    * @throws IOException    */
DECL|method|checkStoragePolicySatisfyPathStatus ( String path)
specifier|public
name|StoragePolicySatisfyPathStatus
name|checkStoragePolicySatisfyPathStatus
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|storageMovementNeeded
operator|.
name|getStatus
argument_list|(
name|ctxt
operator|.
name|getFileID
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|addFileToProcess (ItemInfo<T> trackInfo, boolean scanCompleted)
specifier|public
name|void
name|addFileToProcess
parameter_list|(
name|ItemInfo
argument_list|<
name|T
argument_list|>
name|trackInfo
parameter_list|,
name|boolean
name|scanCompleted
parameter_list|)
block|{
name|storageMovementNeeded
operator|.
name|add
argument_list|(
name|trackInfo
argument_list|,
name|scanCompleted
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added track info for inode {} to block "
operator|+
literal|"storageMovementNeeded queue"
argument_list|,
name|trackInfo
operator|.
name|getFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|addAllFilesToProcess (T startPath, List<ItemInfo<T>> itemInfoList, boolean scanCompleted)
specifier|public
name|void
name|addAllFilesToProcess
parameter_list|(
name|T
name|startPath
parameter_list|,
name|List
argument_list|<
name|ItemInfo
argument_list|<
name|T
argument_list|>
argument_list|>
name|itemInfoList
parameter_list|,
name|boolean
name|scanCompleted
parameter_list|)
block|{
name|getStorageMovementQueue
argument_list|()
operator|.
name|addAll
argument_list|(
name|startPath
argument_list|,
name|itemInfoList
argument_list|,
name|scanCompleted
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|processingQueueSize ()
specifier|public
name|int
name|processingQueueSize
parameter_list|()
block|{
return|return
name|storageMovementNeeded
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getConf ()
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStorageMovementQueue ()
specifier|public
name|BlockStorageMovementNeeded
argument_list|<
name|T
argument_list|>
name|getStorageMovementQueue
parameter_list|()
block|{
return|return
name|storageMovementNeeded
return|;
block|}
annotation|@
name|Override
DECL|method|markScanCompletedForPath (T inodeId)
specifier|public
name|void
name|markScanCompletedForPath
parameter_list|(
name|T
name|inodeId
parameter_list|)
block|{
name|getStorageMovementQueue
argument_list|()
operator|.
name|markScanCompletedForDir
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
block|}
comment|/**    * Join main SPS thread.    */
DECL|method|join ()
specifier|public
name|void
name|join
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|storagePolicySatisfierThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
comment|/**    * Remove the overlap between the expected types and the existing types.    *    * @param expected    *          - Expected storage types list.    * @param existing    *          - Existing storage types list.    * @param ignoreNonMovable    *          ignore non-movable storage types by removing them from both    *          expected and existing storage type list to prevent non-movable    *          storage from being moved.    * @returns if the existing types or the expected types is empty after    *          removing the overlap.    */
DECL|method|removeOverlapBetweenStorageTypes ( List<StorageType> expected, List<StorageType> existing, boolean ignoreNonMovable)
specifier|private
specifier|static
name|boolean
name|removeOverlapBetweenStorageTypes
parameter_list|(
name|List
argument_list|<
name|StorageType
argument_list|>
name|expected
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|existing
parameter_list|,
name|boolean
name|ignoreNonMovable
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageType
argument_list|>
name|i
init|=
name|existing
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|StorageType
name|t
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|expected
operator|.
name|remove
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ignoreNonMovable
condition|)
block|{
name|removeNonMovable
argument_list|(
name|existing
argument_list|)
expr_stmt|;
name|removeNonMovable
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
return|return
name|expected
operator|.
name|isEmpty
argument_list|()
operator|||
name|existing
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|removeNonMovable (List<StorageType> types)
specifier|private
specifier|static
name|void
name|removeNonMovable
parameter_list|(
name|List
argument_list|<
name|StorageType
argument_list|>
name|types
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageType
argument_list|>
name|i
init|=
name|types
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|StorageType
name|t
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|isMovable
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get DFS_SPS_WORK_MULTIPLIER_PER_ITERATION from    * configuration.    *    * @param conf Configuration    * @return Value of DFS_SPS_WORK_MULTIPLIER_PER_ITERATION    */
DECL|method|getSPSWorkMultiplier (Configuration conf)
specifier|private
specifier|static
name|int
name|getSPSWorkMultiplier
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|spsWorkMultiplier
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_SPS_WORK_MULTIPLIER_PER_ITERATION
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_SPS_WORK_MULTIPLIER_PER_ITERATION_DEFAULT
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|(
name|spsWorkMultiplier
operator|>
literal|0
operator|)
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_SPS_WORK_MULTIPLIER_PER_ITERATION
operator|+
literal|" = '"
operator|+
name|spsWorkMultiplier
operator|+
literal|"' is invalid. "
operator|+
literal|"It should be a positive, non-zero integer value."
argument_list|)
expr_stmt|;
return|return
name|spsWorkMultiplier
return|;
block|}
block|}
end_class

end_unit

