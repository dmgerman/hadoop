begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
operator|.
name|Feature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|InconsistentFSStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|now
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|CheckpointCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|MD5FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * FSImage handles checkpointing and logging of the namespace edits.  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|FSImage
specifier|public
class|class
name|FSImage
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSImage
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|namesystem
specifier|protected
name|FSNamesystem
name|namesystem
init|=
literal|null
decl_stmt|;
DECL|field|editLog
specifier|protected
name|FSEditLog
name|editLog
init|=
literal|null
decl_stmt|;
DECL|field|isUpgradeFinalized
specifier|private
name|boolean
name|isUpgradeFinalized
init|=
literal|false
decl_stmt|;
DECL|field|storage
specifier|protected
name|NNStorage
name|storage
decl_stmt|;
comment|/**    * The last transaction ID that was either loaded from an image    * or loaded by loading edits files.    */
DECL|field|lastAppliedTxId
specifier|protected
name|long
name|lastAppliedTxId
init|=
literal|0
decl_stmt|;
comment|/**    * URIs for importing an image from a checkpoint. In the default case,    * URIs will represent directories.     */
DECL|field|checkpointDirs
specifier|private
name|Collection
argument_list|<
name|URI
argument_list|>
name|checkpointDirs
decl_stmt|;
DECL|field|checkpointEditsDirs
specifier|private
name|Collection
argument_list|<
name|URI
argument_list|>
name|checkpointEditsDirs
decl_stmt|;
DECL|field|conf
specifier|final
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|archivalManager
specifier|private
specifier|final
name|NNStorageRetentionManager
name|archivalManager
decl_stmt|;
comment|/**    * Construct an FSImage.    * @param conf Configuration    * @see #FSImage(Configuration conf, FSNamesystem ns,     *               Collection imageDirs, Collection editsDirs)     * @throws IOException if default directories are invalid.    */
DECL|method|FSImage (Configuration conf)
specifier|public
name|FSImage
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
operator|(
name|FSNamesystem
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct an FSImage    * @param conf Configuration    * @param ns The FSNamesystem using this image.    * @see #FSImage(Configuration conf, FSNamesystem ns,     *               Collection imageDirs, Collection editsDirs)     * @throws IOException if default directories are invalid.    */
DECL|method|FSImage (Configuration conf, FSNamesystem ns)
specifier|private
name|FSImage
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSNamesystem
name|ns
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|ns
argument_list|,
name|FSNamesystem
operator|.
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
argument_list|,
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct the FSImage. Set the default checkpoint directories.    *    * Setup storage and initialize the edit log.    *    * @param conf Configuration    * @param ns The FSNamesystem using this image.    * @param imageDirs Directories the image can be stored in.    * @param editsDirs Directories the editlog can be stored in.    * @throws IOException if directories are invalid.    */
DECL|method|FSImage (Configuration conf, FSNamesystem ns, Collection<URI> imageDirs, Collection<URI> editsDirs)
specifier|protected
name|FSImage
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSNamesystem
name|ns
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|imageDirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|setCheckpointDirectories
argument_list|(
name|FSImage
operator|.
name|getCheckpointDirs
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|)
argument_list|,
name|FSImage
operator|.
name|getCheckpointEditsDirs
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|storage
operator|=
operator|new
name|NNStorage
argument_list|(
name|conf
argument_list|,
name|imageDirs
argument_list|,
name|editsDirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_RESTORE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_RESTORE_DEFAULT
argument_list|)
condition|)
block|{
name|storage
operator|.
name|setRestoreFailedStorage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|editLog
operator|=
operator|new
name|FSEditLog
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|setFSNamesystem
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|archivalManager
operator|=
operator|new
name|NNStorageRetentionManager
argument_list|(
name|conf
argument_list|,
name|storage
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
block|}
DECL|method|getFSNamesystem ()
specifier|protected
name|FSNamesystem
name|getFSNamesystem
parameter_list|()
block|{
return|return
name|namesystem
return|;
block|}
DECL|method|setFSNamesystem (FSNamesystem ns)
name|void
name|setFSNamesystem
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|)
block|{
name|namesystem
operator|=
name|ns
expr_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
name|storage
operator|.
name|setUpgradeManager
argument_list|(
name|ns
operator|.
name|upgradeManager
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setCheckpointDirectories (Collection<URI> dirs, Collection<URI> editsDirs)
name|void
name|setCheckpointDirectories
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|dirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
parameter_list|)
block|{
name|checkpointDirs
operator|=
name|dirs
expr_stmt|;
name|checkpointEditsDirs
operator|=
name|editsDirs
expr_stmt|;
block|}
DECL|method|format (String clusterId)
name|void
name|format
parameter_list|(
name|String
name|clusterId
parameter_list|)
throws|throws
name|IOException
block|{
name|storage
operator|.
name|format
argument_list|(
name|clusterId
argument_list|)
expr_stmt|;
name|saveFSImageInAllDirs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Analyze storage directories.    * Recover from previous transitions if required.     * Perform fs state transition if necessary depending on the namespace info.    * Read storage info.     *     * @throws IOException    * @return true if the image needs to be saved or false otherwise    */
DECL|method|recoverTransitionRead (StartupOption startOpt)
name|boolean
name|recoverTransitionRead
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|startOpt
operator|!=
name|StartupOption
operator|.
name|FORMAT
operator|:
literal|"NameNode formatting should be performed before reading the image"
assert|;
name|Collection
argument_list|<
name|URI
argument_list|>
name|imageDirs
init|=
name|storage
operator|.
name|getImageDirectories
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
name|storage
operator|.
name|getEditsDirectories
argument_list|()
decl_stmt|;
comment|// none of the data dirs exist
if|if
condition|(
operator|(
name|imageDirs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|editsDirs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|IMPORT
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All specified directories are not accessible or do not exist."
argument_list|)
throw|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
operator|&&
operator|(
name|checkpointDirs
operator|==
literal|null
operator|||
name|checkpointDirs
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot import image from a checkpoint. "
operator|+
literal|"\"dfs.namenode.checkpoint.dir\" is not set."
argument_list|)
throw|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
operator|&&
operator|(
name|checkpointEditsDirs
operator|==
literal|null
operator|||
name|checkpointEditsDirs
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot import image from a checkpoint. "
operator|+
literal|"\"dfs.namenode.checkpoint.dir\" is not set."
argument_list|)
throw|;
comment|// 1. For each data directory calculate its state and
comment|// check whether all is consistent before transitioning.
name|Map
argument_list|<
name|StorageDirectory
argument_list|,
name|StorageState
argument_list|>
name|dataDirStates
init|=
operator|new
name|HashMap
argument_list|<
name|StorageDirectory
argument_list|,
name|StorageState
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|isFormatted
init|=
name|recoverStorageDirs
argument_list|(
name|startOpt
argument_list|,
name|dataDirStates
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Data dir states:\n  "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|"\n  "
argument_list|)
operator|.
name|withKeyValueSeparator
argument_list|(
literal|": "
argument_list|)
operator|.
name|join
argument_list|(
name|dataDirStates
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isFormatted
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|ROLLBACK
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|IMPORT
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NameNode is not formatted."
argument_list|)
throw|;
block|}
name|int
name|layoutVersion
init|=
name|storage
operator|.
name|getLayoutVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|layoutVersion
operator|<
name|Storage
operator|.
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
condition|)
block|{
name|NNStorage
operator|.
name|checkVersionUpgradable
argument_list|(
name|storage
operator|.
name|getLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startOpt
operator|!=
name|StartupOption
operator|.
name|UPGRADE
operator|&&
name|layoutVersion
operator|<
name|Storage
operator|.
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
operator|&&
name|layoutVersion
operator|!=
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"\nFile system image contains an old layout version "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|".\nAn upgrade to version "
operator|+
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
operator|+
literal|" is required.\n"
operator|+
literal|"Please restart NameNode with -upgrade option."
argument_list|)
throw|;
block|}
name|storage
operator|.
name|processStartupOptionsForUpgrade
argument_list|(
name|startOpt
argument_list|,
name|layoutVersion
argument_list|)
expr_stmt|;
comment|// check whether distributed upgrade is required and/or should be continued
name|storage
operator|.
name|verifyDistributedUpgradeProgress
argument_list|(
name|startOpt
argument_list|)
expr_stmt|;
comment|// 2. Format unformatted dirs.
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|StorageState
name|curState
init|=
name|dataDirStates
operator|.
name|get
argument_list|(
name|sd
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|NON_EXISTENT
case|:
throw|throw
operator|new
name|IOException
argument_list|(
name|StorageState
operator|.
name|NON_EXISTENT
operator|+
literal|" state cannot be here"
argument_list|)
throw|;
case|case
name|NOT_FORMATTED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is not formatted."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Formatting ..."
argument_list|)
expr_stmt|;
name|sd
operator|.
name|clearDirectory
argument_list|()
expr_stmt|;
comment|// create empty currrent dir
break|break;
default|default:
break|break;
block|}
block|}
comment|// 3. Do transitions
switch|switch
condition|(
name|startOpt
condition|)
block|{
case|case
name|UPGRADE
case|:
name|doUpgrade
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// upgrade saved image already
case|case
name|IMPORT
case|:
name|doImportCheckpoint
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// import checkpoint saved image already
case|case
name|ROLLBACK
case|:
name|doRollback
argument_list|()
expr_stmt|;
break|break;
case|case
name|REGULAR
case|:
comment|// just load the image
block|}
return|return
name|loadFSImage
argument_list|()
return|;
block|}
comment|/**    * For each storage directory, performs recovery of incomplete transitions    * (eg. upgrade, rollback, checkpoint) and inserts the directory's storage    * state into the dataDirStates map.    * @param dataDirStates output of storage directory states    * @return true if there is at least one valid formatted storage directory    */
DECL|method|recoverStorageDirs (StartupOption startOpt, Map<StorageDirectory, StorageState> dataDirStates)
specifier|private
name|boolean
name|recoverStorageDirs
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|Map
argument_list|<
name|StorageDirectory
argument_list|,
name|StorageState
argument_list|>
name|dataDirStates
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|isFormatted
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|StorageState
name|curState
decl_stmt|;
try|try
block|{
name|curState
operator|=
name|sd
operator|.
name|analyzeStorage
argument_list|(
name|startOpt
argument_list|,
name|storage
argument_list|)
expr_stmt|;
comment|// sd is locked but not opened
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|NON_EXISTENT
case|:
comment|// name-node fails if any of the configured storage dirs are missing
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"storage directory does not exist or is not accessible."
argument_list|)
throw|;
case|case
name|NOT_FORMATTED
case|:
break|break;
case|case
name|NORMAL
case|:
break|break;
default|default:
comment|// recovery is possible
name|sd
operator|.
name|doRecover
argument_list|(
name|curState
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curState
operator|!=
name|StorageState
operator|.
name|NOT_FORMATTED
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|ROLLBACK
condition|)
block|{
comment|// read and verify consistency with other directories
name|storage
operator|.
name|readProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|isFormatted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
operator|&&
name|isFormatted
condition|)
comment|// import of a checkpoint is allowed only into empty image directories
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot import image from a checkpoint. "
operator|+
literal|" NameNode already contains an image in "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
name|dataDirStates
operator|.
name|put
argument_list|(
name|sd
argument_list|,
name|curState
argument_list|)
expr_stmt|;
block|}
return|return
name|isFormatted
return|;
block|}
DECL|method|doUpgrade ()
specifier|private
name|void
name|doUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|storage
operator|.
name|getDistributedUpgradeState
argument_list|()
condition|)
block|{
comment|// only distributed upgrade need to continue
comment|// don't do version upgrade
name|this
operator|.
name|loadFSImage
argument_list|()
expr_stmt|;
name|storage
operator|.
name|initializeDistributedUpgrade
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Upgrade is allowed only if there are
comment|// no previous fs states in any of the directories
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sd
operator|.
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"previous fs state should not exist during upgrade. "
operator|+
literal|"Finalize or rollback first."
argument_list|)
throw|;
block|}
comment|// load the latest image
name|this
operator|.
name|loadFSImage
argument_list|()
expr_stmt|;
comment|// Do upgrade for each directory
name|long
name|oldCTime
init|=
name|storage
operator|.
name|getCTime
argument_list|()
decl_stmt|;
name|storage
operator|.
name|cTime
operator|=
name|now
argument_list|()
expr_stmt|;
comment|// generate new cTime for the state
name|int
name|oldLV
init|=
name|storage
operator|.
name|getLayoutVersion
argument_list|()
decl_stmt|;
name|storage
operator|.
name|layoutVersion
operator|=
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
expr_stmt|;
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|errorSDs
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting upgrade of image directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|".\n   old LV = "
operator|+
name|oldLV
operator|+
literal|"; old CTime = "
operator|+
name|oldCTime
operator|+
literal|".\n   new LV = "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; new CTime = "
operator|+
name|storage
operator|.
name|getCTime
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|File
name|curDir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
name|File
name|prevDir
init|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
name|File
name|tmpDir
init|=
name|sd
operator|.
name|getPreviousTmp
argument_list|()
decl_stmt|;
assert|assert
name|curDir
operator|.
name|exists
argument_list|()
operator|:
literal|"Current directory must exist."
assert|;
assert|assert
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
operator|:
literal|"prvious directory must not exist."
assert|;
assert|assert
operator|!
name|tmpDir
operator|.
name|exists
argument_list|()
operator|:
literal|"prvious.tmp directory must not exist."
assert|;
assert|assert
operator|!
name|editLog
operator|.
name|isOpen
argument_list|()
operator|:
literal|"Edits log must not be open."
assert|;
comment|// rename current to tmp
name|NNStorage
operator|.
name|rename
argument_list|(
name|curDir
argument_list|,
name|tmpDir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curDir
operator|.
name|mkdir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create directory "
operator|+
name|curDir
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to move aside pre-upgrade storage "
operator|+
literal|"in image directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|errorSDs
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|saveFSImageInAllDirs
argument_list|(
name|editLog
operator|.
name|getLastWrittenTxId
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Write the version file, since saveFsImage above only makes the
comment|// fsimage_<txid>, and the directory is otherwise empty.
name|storage
operator|.
name|writeProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|File
name|prevDir
init|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
name|File
name|tmpDir
init|=
name|sd
operator|.
name|getPreviousTmp
argument_list|()
decl_stmt|;
comment|// rename tmp to previous
name|NNStorage
operator|.
name|rename
argument_list|(
name|tmpDir
argument_list|,
name|prevDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to rename temp to previous for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Upgrade of "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is complete."
argument_list|)
expr_stmt|;
block|}
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|errorSDs
argument_list|)
expr_stmt|;
name|isUpgradeFinalized
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|storage
operator|.
name|getRemovedStorageDirs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//during upgrade, it's a fatal error to fail any storage directory
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Upgrade failed in "
operator|+
name|storage
operator|.
name|getRemovedStorageDirs
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" storage directory(ies), previously logged."
argument_list|)
throw|;
block|}
name|storage
operator|.
name|initializeDistributedUpgrade
argument_list|()
expr_stmt|;
block|}
DECL|method|doRollback ()
specifier|private
name|void
name|doRollback
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Rollback is allowed only if there is
comment|// a previous fs states in at least one of the storage directories.
comment|// Directories that don't have previous state do not rollback
name|boolean
name|canRollback
init|=
literal|false
decl_stmt|;
name|FSImage
name|prevState
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|getFSNamesystem
argument_list|()
argument_list|)
decl_stmt|;
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|layoutVersion
operator|=
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|File
name|prevDir
init|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// use current directory then
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" does not contain previous fs state."
argument_list|)
expr_stmt|;
comment|// read and verify consistency with other directories
name|storage
operator|.
name|readProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// read and verify consistency of the prev dir
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|readPreviousVersionProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevState
operator|.
name|getLayoutVersion
argument_list|()
operator|!=
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot rollback to storage version "
operator|+
name|prevState
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" using this version of the NameNode, which uses storage version "
operator|+
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
operator|+
literal|". "
operator|+
literal|"Please use the previous version of HDFS to perform the rollback."
argument_list|)
throw|;
block|}
name|canRollback
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|canRollback
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot rollback. None of the storage "
operator|+
literal|"directories contain previous fs state."
argument_list|)
throw|;
comment|// Now that we know all directories are going to be consistent
comment|// Do rollback for each directory containing previous state
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|File
name|prevDir
init|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
condition|)
continue|continue;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rolling back storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|".\n   new LV = "
operator|+
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; new CTime = "
operator|+
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|getCTime
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|tmpDir
init|=
name|sd
operator|.
name|getRemovedTmp
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|tmpDir
operator|.
name|exists
argument_list|()
operator|:
literal|"removed.tmp directory must not exist."
assert|;
comment|// rename current to tmp
name|File
name|curDir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
assert|assert
name|curDir
operator|.
name|exists
argument_list|()
operator|:
literal|"Current directory must exist."
assert|;
name|NNStorage
operator|.
name|rename
argument_list|(
name|curDir
argument_list|,
name|tmpDir
argument_list|)
expr_stmt|;
comment|// rename previous to current
name|NNStorage
operator|.
name|rename
argument_list|(
name|prevDir
argument_list|,
name|curDir
argument_list|)
expr_stmt|;
comment|// delete tmp dir
name|NNStorage
operator|.
name|deleteDir
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rollback of "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is complete."
argument_list|)
expr_stmt|;
block|}
name|isUpgradeFinalized
operator|=
literal|true
expr_stmt|;
comment|// check whether name-node can start in regular mode
name|storage
operator|.
name|verifyDistributedUpgradeProgress
argument_list|(
name|StartupOption
operator|.
name|REGULAR
argument_list|)
expr_stmt|;
block|}
DECL|method|doFinalize (StorageDirectory sd)
specifier|private
name|void
name|doFinalize
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|prevDir
init|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// already discarded
name|LOG
operator|.
name|info
argument_list|(
literal|"Directory "
operator|+
name|prevDir
operator|+
literal|" does not exist."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalize upgrade for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is not required."
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalizing upgrade for storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|"."
operator|+
operator|(
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
literal|"\n   cur LV = "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; cur CTime = "
operator|+
name|storage
operator|.
name|getCTime
argument_list|()
operator|)
argument_list|)
expr_stmt|;
assert|assert
name|sd
operator|.
name|getCurrentDir
argument_list|()
operator|.
name|exists
argument_list|()
operator|:
literal|"Current directory must exist."
assert|;
specifier|final
name|File
name|tmpDir
init|=
name|sd
operator|.
name|getFinalizedTmp
argument_list|()
decl_stmt|;
comment|// rename previous to tmp and remove
name|NNStorage
operator|.
name|rename
argument_list|(
name|prevDir
argument_list|,
name|tmpDir
argument_list|)
expr_stmt|;
name|NNStorage
operator|.
name|deleteDir
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
name|isUpgradeFinalized
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalize upgrade for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is complete."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Load image from a checkpoint directory and save it into the current one.    * @throws IOException    */
DECL|method|doImportCheckpoint ()
name|void
name|doImportCheckpoint
parameter_list|()
throws|throws
name|IOException
block|{
name|FSNamesystem
name|fsNamesys
init|=
name|getFSNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|ckptImage
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|fsNamesys
argument_list|,
name|checkpointDirs
argument_list|,
name|checkpointEditsDirs
argument_list|)
decl_stmt|;
comment|// replace real image with the checkpoint image
name|FSImage
name|realImage
init|=
name|fsNamesys
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
assert|assert
name|realImage
operator|==
name|this
assert|;
name|fsNamesys
operator|.
name|dir
operator|.
name|fsImage
operator|=
name|ckptImage
expr_stmt|;
comment|// load from the checkpoint dirs
try|try
block|{
name|ckptImage
operator|.
name|recoverTransitionRead
argument_list|(
name|StartupOption
operator|.
name|REGULAR
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ckptImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// return back the real image
name|realImage
operator|.
name|getStorage
argument_list|()
operator|.
name|setStorageInfo
argument_list|(
name|ckptImage
operator|.
name|getStorage
argument_list|()
argument_list|)
expr_stmt|;
name|realImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|setNextTxId
argument_list|(
name|ckptImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fsNamesys
operator|.
name|dir
operator|.
name|fsImage
operator|=
name|realImage
expr_stmt|;
name|realImage
operator|.
name|getStorage
argument_list|()
operator|.
name|setBlockPoolID
argument_list|(
name|ckptImage
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
comment|// and save it but keep the same checkpointTime
name|saveNamespace
argument_list|()
expr_stmt|;
name|getStorage
argument_list|()
operator|.
name|writeAll
argument_list|()
expr_stmt|;
block|}
DECL|method|finalizeUpgrade ()
name|void
name|finalizeUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|doFinalize
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isUpgradeFinalized ()
name|boolean
name|isUpgradeFinalized
parameter_list|()
block|{
return|return
name|isUpgradeFinalized
return|;
block|}
DECL|method|getEditLog ()
specifier|public
name|FSEditLog
name|getEditLog
parameter_list|()
block|{
return|return
name|editLog
return|;
block|}
DECL|method|openEditLog ()
name|void
name|openEditLog
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|editLog
operator|!=
literal|null
operator|:
literal|"editLog must be initialized"
assert|;
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|editLog
operator|.
name|isOpen
argument_list|()
argument_list|,
literal|"edit log should not yet be open"
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|open
argument_list|()
expr_stmt|;
name|storage
operator|.
name|writeTransactionIdFileToStorage
argument_list|(
name|editLog
operator|.
name|getCurSegmentTxId
argument_list|()
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/**    * Toss the current image and namesystem, reloading from the specified    * file.    */
DECL|method|reloadFromImageFile (File file)
name|void
name|reloadFromImageFile
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|dir
operator|.
name|reset
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reloading namespace from "
operator|+
name|file
argument_list|)
expr_stmt|;
name|loadFSImage
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/**    * Choose latest image from one of the directories,    * load it and merge with the edits from that directory.    *     * Saving and loading fsimage should never trigger symlink resolution.     * The paths that are persisted do not have *intermediate* symlinks     * because intermediate symlinks are resolved at the time files,     * directories, and symlinks are created. All paths accessed while     * loading or saving fsimage should therefore only see symlinks as     * the final path component, and the functions called below do not    * resolve symlinks that are the final path component.    *    * @return whether the image should be saved    * @throws IOException    */
DECL|method|loadFSImage ()
name|boolean
name|loadFSImage
parameter_list|()
throws|throws
name|IOException
block|{
name|FSImageStorageInspector
name|inspector
init|=
name|storage
operator|.
name|readAndInspectDirs
argument_list|()
decl_stmt|;
name|isUpgradeFinalized
operator|=
name|inspector
operator|.
name|isUpgradeFinalized
argument_list|()
expr_stmt|;
name|FSImageStorageInspector
operator|.
name|FSImageFile
name|imageFile
init|=
name|inspector
operator|.
name|getLatestImage
argument_list|()
decl_stmt|;
name|boolean
name|needToSave
init|=
name|inspector
operator|.
name|needToSave
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|EditLogInputStream
argument_list|>
name|editStreams
init|=
literal|null
decl_stmt|;
name|editLog
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
if|if
condition|(
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|TXID_BASED_LAYOUT
argument_list|,
name|getLayoutVersion
argument_list|()
argument_list|)
condition|)
block|{
name|editStreams
operator|=
name|editLog
operator|.
name|selectInputStreams
argument_list|(
name|imageFile
operator|.
name|getCheckpointTxId
argument_list|()
operator|+
literal|1
argument_list|,
name|inspector
operator|.
name|getMaxSeenTxId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|editStreams
operator|=
name|FSImagePreTransactionalStorageInspector
operator|.
name|getEditLogStreams
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Planning to load image :\n"
operator|+
name|imageFile
argument_list|)
expr_stmt|;
for|for
control|(
name|EditLogInputStream
name|l
range|:
name|editStreams
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"\t Planning to load edit stream: "
operator|+
name|l
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|StorageDirectory
name|sdForProperties
init|=
name|imageFile
operator|.
name|sd
decl_stmt|;
name|storage
operator|.
name|readProperties
argument_list|(
name|sdForProperties
argument_list|)
expr_stmt|;
if|if
condition|(
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|TXID_BASED_LAYOUT
argument_list|,
name|getLayoutVersion
argument_list|()
argument_list|)
condition|)
block|{
comment|// For txid-based layout, we should have a .md5 file
comment|// next to the image file
name|loadFSImage
argument_list|(
name|imageFile
operator|.
name|getFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|FSIMAGE_CHECKSUM
argument_list|,
name|getLayoutVersion
argument_list|()
argument_list|)
condition|)
block|{
comment|// In 0.22, we have the checksum stored in the VERSION file.
name|String
name|md5
init|=
name|storage
operator|.
name|getDeprecatedProperty
argument_list|(
name|NNStorage
operator|.
name|DEPRECATED_MESSAGE_DIGEST_PROPERTY
argument_list|)
decl_stmt|;
if|if
condition|(
name|md5
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sdForProperties
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"Message digest property "
operator|+
name|NNStorage
operator|.
name|DEPRECATED_MESSAGE_DIGEST_PROPERTY
operator|+
literal|" not set for storage directory "
operator|+
name|sdForProperties
operator|.
name|getRoot
argument_list|()
argument_list|)
throw|;
block|}
name|loadFSImage
argument_list|(
name|imageFile
operator|.
name|getFile
argument_list|()
argument_list|,
operator|new
name|MD5Hash
argument_list|(
name|md5
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We don't have any record of the md5sum
name|loadFSImage
argument_list|(
name|imageFile
operator|.
name|getFile
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|FSEditLog
operator|.
name|closeAllStreams
argument_list|(
name|editStreams
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to load image from "
operator|+
name|imageFile
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
name|long
name|numLoaded
init|=
name|loadEdits
argument_list|(
name|editStreams
argument_list|)
decl_stmt|;
name|needToSave
operator||=
name|needsResaveBasedOnStaleCheckpoint
argument_list|(
name|imageFile
operator|.
name|getFile
argument_list|()
argument_list|,
name|numLoaded
argument_list|)
expr_stmt|;
comment|// update the txid for the edit log
name|editLog
operator|.
name|setNextTxId
argument_list|(
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
operator|+
name|numLoaded
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|needToSave
return|;
block|}
comment|/**    * @param imageFile the image file that was loaded    * @param numEditsLoaded the number of edits loaded from edits logs    * @return true if the NameNode should automatically save the namespace    * when it is started, due to the latest checkpoint being too old.    */
DECL|method|needsResaveBasedOnStaleCheckpoint ( File imageFile, long numEditsLoaded)
specifier|private
name|boolean
name|needsResaveBasedOnStaleCheckpoint
parameter_list|(
name|File
name|imageFile
parameter_list|,
name|long
name|numEditsLoaded
parameter_list|)
block|{
specifier|final
name|long
name|checkpointPeriod
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_PERIOD_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_PERIOD_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|long
name|checkpointTxnCount
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|checkpointAge
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|imageFile
operator|.
name|lastModified
argument_list|()
decl_stmt|;
return|return
operator|(
name|checkpointAge
operator|>
name|checkpointPeriod
operator|*
literal|1000
operator|)
operator|||
operator|(
name|numEditsLoaded
operator|>
name|checkpointTxnCount
operator|)
return|;
block|}
comment|/**    * Load the specified list of edit files into the image.    * @return the number of transactions loaded    */
DECL|method|loadEdits (Iterable<EditLogInputStream> editStreams)
specifier|protected
name|long
name|loadEdits
parameter_list|(
name|Iterable
argument_list|<
name|EditLogInputStream
argument_list|>
name|editStreams
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"About to load edits:\n  "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|"\n  "
argument_list|)
operator|.
name|join
argument_list|(
name|editStreams
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|startingTxId
init|=
name|getLastAppliedTxId
argument_list|()
operator|+
literal|1
decl_stmt|;
name|int
name|numLoaded
init|=
literal|0
decl_stmt|;
try|try
block|{
name|FSEditLogLoader
name|loader
init|=
operator|new
name|FSEditLogLoader
argument_list|(
name|namesystem
argument_list|)
decl_stmt|;
comment|// Load latest edits
for|for
control|(
name|EditLogInputStream
name|editIn
range|:
name|editStreams
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reading "
operator|+
name|editIn
operator|+
literal|" expecting start txid #"
operator|+
name|startingTxId
argument_list|)
expr_stmt|;
name|int
name|thisNumLoaded
init|=
name|loader
operator|.
name|loadFSEdits
argument_list|(
name|editIn
argument_list|,
name|startingTxId
argument_list|)
decl_stmt|;
name|startingTxId
operator|+=
name|thisNumLoaded
expr_stmt|;
name|numLoaded
operator|+=
name|thisNumLoaded
expr_stmt|;
name|lastAppliedTxId
operator|+=
name|thisNumLoaded
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|FSEditLog
operator|.
name|closeAllStreams
argument_list|(
name|editStreams
argument_list|)
expr_stmt|;
block|}
comment|// update the counts
name|getFSNamesystem
argument_list|()
operator|.
name|dir
operator|.
name|updateCountForINodeWithQuota
argument_list|()
expr_stmt|;
return|return
name|numLoaded
return|;
block|}
comment|/**    * Load the image namespace from the given image file, verifying    * it against the MD5 sum stored in its associated .md5 file.    */
DECL|method|loadFSImage (File imageFile)
specifier|private
name|void
name|loadFSImage
parameter_list|(
name|File
name|imageFile
parameter_list|)
throws|throws
name|IOException
block|{
name|MD5Hash
name|expectedMD5
init|=
name|MD5FileUtils
operator|.
name|readStoredMd5ForFile
argument_list|(
name|imageFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedMD5
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No MD5 file found corresponding to image file "
operator|+
name|imageFile
argument_list|)
throw|;
block|}
name|loadFSImage
argument_list|(
name|imageFile
argument_list|,
name|expectedMD5
argument_list|)
expr_stmt|;
block|}
comment|/**    * Load in the filesystem image from file. It's a big list of    * filenames and blocks.  Return whether we should    * "re-save" and consolidate the edit-logs    */
DECL|method|loadFSImage (File curFile, MD5Hash expectedMd5)
specifier|private
name|void
name|loadFSImage
parameter_list|(
name|File
name|curFile
parameter_list|,
name|MD5Hash
name|expectedMd5
parameter_list|)
throws|throws
name|IOException
block|{
name|FSImageFormat
operator|.
name|Loader
name|loader
init|=
operator|new
name|FSImageFormat
operator|.
name|Loader
argument_list|(
name|conf
argument_list|,
name|getFSNamesystem
argument_list|()
argument_list|)
decl_stmt|;
name|loader
operator|.
name|load
argument_list|(
name|curFile
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|setBlockPoolId
argument_list|(
name|this
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check that the image digest we loaded matches up with what
comment|// we expected
name|MD5Hash
name|readImageMd5
init|=
name|loader
operator|.
name|getLoadedImageMd5
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedMd5
operator|!=
literal|null
operator|&&
operator|!
name|expectedMd5
operator|.
name|equals
argument_list|(
name|readImageMd5
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Image file "
operator|+
name|curFile
operator|+
literal|" is corrupt with MD5 checksum of "
operator|+
name|readImageMd5
operator|+
literal|" but expecting "
operator|+
name|expectedMd5
argument_list|)
throw|;
block|}
name|long
name|txId
init|=
name|loader
operator|.
name|getLoadedImageTxId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Loaded image for txid "
operator|+
name|txId
operator|+
literal|" from "
operator|+
name|curFile
argument_list|)
expr_stmt|;
name|lastAppliedTxId
operator|=
name|txId
expr_stmt|;
name|storage
operator|.
name|setMostRecentCheckpointTxId
argument_list|(
name|txId
argument_list|)
expr_stmt|;
block|}
comment|/**    * Save the contents of the FS image to the file.    */
DECL|method|saveFSImage (StorageDirectory sd, long txid)
name|void
name|saveFSImage
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|newFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|,
name|txid
argument_list|)
decl_stmt|;
name|File
name|dstFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
name|txid
argument_list|)
decl_stmt|;
name|FSImageFormat
operator|.
name|Saver
name|saver
init|=
operator|new
name|FSImageFormat
operator|.
name|Saver
argument_list|()
decl_stmt|;
name|FSImageCompression
name|compression
init|=
name|FSImageCompression
operator|.
name|createCompression
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|saver
operator|.
name|save
argument_list|(
name|newFile
argument_list|,
name|txid
argument_list|,
name|getFSNamesystem
argument_list|()
argument_list|,
name|compression
argument_list|)
expr_stmt|;
name|MD5FileUtils
operator|.
name|saveMD5File
argument_list|(
name|dstFile
argument_list|,
name|saver
operator|.
name|getSavedDigest
argument_list|()
argument_list|)
expr_stmt|;
name|storage
operator|.
name|setMostRecentCheckpointTxId
argument_list|(
name|txid
argument_list|)
expr_stmt|;
block|}
comment|/**    * FSImageSaver is being run in a separate thread when saving    * FSImage. There is one thread per each copy of the image.    *    * FSImageSaver assumes that it was launched from a thread that holds    * FSNamesystem lock and waits for the execution of FSImageSaver thread    * to finish.    * This way we are guraranteed that the namespace is not being updated    * while multiple instances of FSImageSaver are traversing it    * and writing it out.    */
DECL|class|FSImageSaver
specifier|private
class|class
name|FSImageSaver
implements|implements
name|Runnable
block|{
DECL|field|sd
specifier|private
name|StorageDirectory
name|sd
decl_stmt|;
DECL|field|errorSDs
specifier|private
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|errorSDs
decl_stmt|;
DECL|field|txid
specifier|private
specifier|final
name|long
name|txid
decl_stmt|;
DECL|method|FSImageSaver (StorageDirectory sd, List<StorageDirectory> errorSDs, long txid)
name|FSImageSaver
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|errorSDs
parameter_list|,
name|long
name|txid
parameter_list|)
block|{
name|this
operator|.
name|sd
operator|=
name|sd
expr_stmt|;
name|this
operator|.
name|errorSDs
operator|=
name|errorSDs
expr_stmt|;
name|this
operator|.
name|txid
operator|=
name|txid
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|saveFSImage
argument_list|(
name|sd
argument_list|,
name|txid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to save image for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSImageSaver for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" of type "
operator|+
name|sd
operator|.
name|getStorageDirType
argument_list|()
return|;
block|}
block|}
DECL|method|waitForThreads (List<Thread> threads)
specifier|private
name|void
name|waitForThreads
parameter_list|(
name|List
argument_list|<
name|Thread
argument_list|>
name|threads
parameter_list|)
block|{
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
while|while
condition|(
name|thread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
try|try
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught exception while waiting for thread "
operator|+
name|thread
operator|.
name|getName
argument_list|()
operator|+
literal|" to finish. Retrying join"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Save the contents of the FS image to a new image file in each of the    * current storage directories.    */
DECL|method|saveNamespace ()
name|void
name|saveNamespace
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|editLog
operator|!=
literal|null
operator|:
literal|"editLog must be initialized"
assert|;
name|storage
operator|.
name|attemptRestoreRemovedStorage
argument_list|()
expr_stmt|;
name|boolean
name|editLogWasOpen
init|=
name|editLog
operator|.
name|isOpen
argument_list|()
decl_stmt|;
if|if
condition|(
name|editLogWasOpen
condition|)
block|{
name|editLog
operator|.
name|endCurrentLogSegment
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|long
name|imageTxId
init|=
name|editLog
operator|.
name|getLastWrittenTxId
argument_list|()
decl_stmt|;
try|try
block|{
name|saveFSImageInAllDirs
argument_list|(
name|imageTxId
argument_list|)
expr_stmt|;
name|storage
operator|.
name|writeAll
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|editLogWasOpen
condition|)
block|{
name|editLog
operator|.
name|startLogSegment
argument_list|(
name|imageTxId
operator|+
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Take this opportunity to note the current transaction
name|storage
operator|.
name|writeTransactionIdFileToStorage
argument_list|(
name|imageTxId
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|saveFSImageInAllDirs (long txid)
specifier|protected
name|void
name|saveFSImageInAllDirs
parameter_list|(
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No image directories available!"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|errorSDs
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Thread
argument_list|>
name|saveThreads
init|=
operator|new
name|ArrayList
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
comment|// save images into current
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|FSImageSaver
name|saver
init|=
operator|new
name|FSImageSaver
argument_list|(
name|sd
argument_list|,
name|errorSDs
argument_list|,
name|txid
argument_list|)
decl_stmt|;
name|Thread
name|saveThread
init|=
operator|new
name|Thread
argument_list|(
name|saver
argument_list|,
name|saver
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|saveThreads
operator|.
name|add
argument_list|(
name|saveThread
argument_list|)
expr_stmt|;
name|saveThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|waitForThreads
argument_list|(
name|saveThreads
argument_list|)
expr_stmt|;
name|saveThreads
operator|.
name|clear
argument_list|()
expr_stmt|;
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|errorSDs
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to save in any storage directories while saving namespace."
argument_list|)
throw|;
block|}
name|renameCheckpoint
argument_list|(
name|txid
argument_list|)
expr_stmt|;
comment|// Since we now have a new checkpoint, we can clean up some
comment|// old edit logs and checkpoints.
name|purgeOldStorage
argument_list|()
expr_stmt|;
block|}
comment|/**    * Purge any files in the storage directories that are no longer    * necessary.    */
DECL|method|purgeOldStorage ()
specifier|public
name|void
name|purgeOldStorage
parameter_list|()
block|{
try|try
block|{
name|archivalManager
operator|.
name|purgeOldStorage
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to purge old storage"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Renames new image    */
DECL|method|renameCheckpoint (long txid)
specifier|private
name|void
name|renameCheckpoint
parameter_list|(
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
name|al
init|=
literal|null
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
control|)
block|{
try|try
block|{
name|renameCheckpointInDir
argument_list|(
name|sd
argument_list|,
name|txid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to rename checkpoint in "
operator|+
name|sd
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|null
condition|)
block|{
name|al
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
block|}
name|al
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|al
operator|!=
literal|null
condition|)
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|al
argument_list|)
expr_stmt|;
block|}
DECL|method|renameCheckpointInDir (StorageDirectory sd, long txid)
specifier|private
name|void
name|renameCheckpointInDir
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|ckpt
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|,
name|txid
argument_list|)
decl_stmt|;
name|File
name|curFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
name|txid
argument_list|)
decl_stmt|;
comment|// renameTo fails on Windows if the destination file
comment|// already exists.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"renaming  "
operator|+
name|ckpt
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" to "
operator|+
name|curFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ckpt
operator|.
name|renameTo
argument_list|(
name|curFile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|curFile
operator|.
name|delete
argument_list|()
operator|||
operator|!
name|ckpt
operator|.
name|renameTo
argument_list|(
name|curFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"renaming  "
operator|+
name|ckpt
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" to "
operator|+
name|curFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" FAILED"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|rollEditLog ()
name|CheckpointSignature
name|rollEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|getEditLog
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
comment|// Record this log segment ID in all of the storage directories, so
comment|// we won't miss this log segment on a restart if the edits directories
comment|// go missing.
name|storage
operator|.
name|writeTransactionIdFileToStorage
argument_list|(
name|getEditLog
argument_list|()
operator|.
name|getCurSegmentTxId
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|CheckpointSignature
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Start checkpoint.    *<p>    * If backup storage contains image that is newer than or incompatible with     * what the active name-node has, then the backup node should shutdown.<br>    * If the backup image is older than the active one then it should     * be discarded and downloaded from the active node.<br>    * If the images are the same then the backup image will be used as current.    *     * @param bnReg the backup node registration.    * @param nnReg this (active) name-node registration.    * @return {@link NamenodeCommand} if backup node should shutdown or    * {@link CheckpointCommand} prescribing what backup node should     *         do with its image.    * @throws IOException    */
DECL|method|startCheckpoint (NamenodeRegistration bnReg, NamenodeRegistration nnReg)
name|NamenodeCommand
name|startCheckpoint
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
comment|// backup node
name|NamenodeRegistration
name|nnReg
parameter_list|)
comment|// active name-node
throws|throws
name|IOException
block|{
name|String
name|msg
init|=
literal|null
decl_stmt|;
comment|// Verify that checkpoint is allowed
if|if
condition|(
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
operator|!=
name|storage
operator|.
name|getNamespaceID
argument_list|()
condition|)
name|msg
operator|=
literal|"Name node "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
operator|+
literal|" has incompatible namespace id: "
operator|+
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|" expected: "
operator|+
name|storage
operator|.
name|getNamespaceID
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|bnReg
operator|.
name|isRole
argument_list|(
name|NamenodeRole
operator|.
name|NAMENODE
argument_list|)
condition|)
name|msg
operator|=
literal|"Name node "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
operator|+
literal|" role "
operator|+
name|bnReg
operator|.
name|getRole
argument_list|()
operator|+
literal|": checkpoint is not allowed."
expr_stmt|;
elseif|else
if|if
condition|(
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|<
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|||
operator|(
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|==
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|&&
name|bnReg
operator|.
name|getCTime
argument_list|()
operator|>
name|storage
operator|.
name|getCTime
argument_list|()
operator|)
condition|)
comment|// remote node has newer image age
name|msg
operator|=
literal|"Name node "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
operator|+
literal|" has newer image layout version: LV = "
operator|+
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" cTime = "
operator|+
name|bnReg
operator|.
name|getCTime
argument_list|()
operator|+
literal|". Current version: LV = "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" cTime = "
operator|+
name|storage
operator|.
name|getCTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|new
name|NamenodeCommand
argument_list|(
name|NamenodeProtocol
operator|.
name|ACT_SHUTDOWN
argument_list|)
return|;
block|}
name|boolean
name|needToReturnImg
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|==
literal|0
condition|)
comment|// do not return image if there are no image directories
name|needToReturnImg
operator|=
literal|false
expr_stmt|;
name|CheckpointSignature
name|sig
init|=
name|rollEditLog
argument_list|()
decl_stmt|;
return|return
operator|new
name|CheckpointCommand
argument_list|(
name|sig
argument_list|,
name|needToReturnImg
argument_list|)
return|;
block|}
comment|/**    * End checkpoint.    *<p>    * Rename uploaded checkpoint to the new image;    * purge old edits file;    * rename edits.new to edits;    * redirect edit log streams to the new edits;    * update checkpoint time if the remote node is a checkpoint only node.    *     * @param sig    * @param remoteNNRole    * @throws IOException    */
DECL|method|endCheckpoint (CheckpointSignature sig, NamenodeRole remoteNNRole)
name|void
name|endCheckpoint
parameter_list|(
name|CheckpointSignature
name|sig
parameter_list|,
name|NamenodeRole
name|remoteNNRole
parameter_list|)
throws|throws
name|IOException
block|{
name|sig
operator|.
name|validateStorageInfo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * This is called by the 2NN after having downloaded an image, and by    * the NN after having received a new image from the 2NN. It    * renames the image from fsimage_N.ckpt to fsimage_N and also    * saves the related .md5 file into place.    */
DECL|method|saveDigestAndRenameCheckpointImage ( long txid, MD5Hash digest)
specifier|synchronized
name|void
name|saveDigestAndRenameCheckpointImage
parameter_list|(
name|long
name|txid
parameter_list|,
name|MD5Hash
name|digest
parameter_list|)
throws|throws
name|IOException
block|{
name|renameCheckpoint
argument_list|(
name|txid
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|badSds
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
control|)
block|{
name|File
name|imageFile
init|=
name|NNStorage
operator|.
name|getImageFile
argument_list|(
name|sd
argument_list|,
name|txid
argument_list|)
decl_stmt|;
try|try
block|{
name|MD5FileUtils
operator|.
name|saveMD5File
argument_list|(
name|imageFile
argument_list|,
name|digest
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|badSds
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|badSds
argument_list|)
expr_stmt|;
comment|// So long as this is the newest image available,
comment|// advertise it as such to other checkpointers
comment|// from now on
if|if
condition|(
name|txid
operator|>
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
condition|)
block|{
name|storage
operator|.
name|setMostRecentCheckpointTxId
argument_list|(
name|txid
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|close ()
specifier|synchronized
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|editLog
operator|!=
literal|null
condition|)
block|{
comment|// 2NN doesn't have any edit log
name|getEditLog
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|storage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Retrieve checkpoint dirs from configuration.    *    * @param conf the Configuration    * @param defaultValue a default value for the attribute, if null    * @return a Collection of URIs representing the values in     * dfs.namenode.checkpoint.dir configuration property    */
DECL|method|getCheckpointDirs (Configuration conf, String defaultValue)
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getCheckpointDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_DIR_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirNames
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|defaultValue
operator|!=
literal|null
condition|)
block|{
name|dirNames
operator|.
name|add
argument_list|(
name|defaultValue
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
DECL|method|getCheckpointEditsDirs (Configuration conf, String defaultName)
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getCheckpointEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|defaultName
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_EDITS_DIR_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirNames
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|defaultName
operator|!=
literal|null
condition|)
block|{
name|dirNames
operator|.
name|add
argument_list|(
name|defaultName
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
DECL|method|getStorage ()
specifier|public
name|NNStorage
name|getStorage
parameter_list|()
block|{
return|return
name|storage
return|;
block|}
DECL|method|getLayoutVersion ()
specifier|public
name|int
name|getLayoutVersion
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getLayoutVersion
argument_list|()
return|;
block|}
DECL|method|getNamespaceID ()
specifier|public
name|int
name|getNamespaceID
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getNamespaceID
argument_list|()
return|;
block|}
DECL|method|getClusterID ()
specifier|public
name|String
name|getClusterID
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getClusterID
argument_list|()
return|;
block|}
DECL|method|getBlockPoolID ()
specifier|public
name|String
name|getBlockPoolID
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getBlockPoolID
argument_list|()
return|;
block|}
DECL|method|getLastAppliedTxId ()
specifier|public
specifier|synchronized
name|long
name|getLastAppliedTxId
parameter_list|()
block|{
return|return
name|lastAppliedTxId
return|;
block|}
block|}
end_class

end_unit

