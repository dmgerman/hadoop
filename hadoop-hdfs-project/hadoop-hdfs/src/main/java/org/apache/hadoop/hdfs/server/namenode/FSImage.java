begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|RollingUpgradeStartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|InconsistentFSStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|FormatConfirmable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSImageStorageInspector
operator|.
name|FSImageFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|Phase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|CheckpointCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|Canceler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|MD5FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * FSImage handles checkpointing and logging of the namespace edits.  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|FSImage
specifier|public
class|class
name|FSImage
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSImage
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|editLog
specifier|protected
name|FSEditLog
name|editLog
init|=
literal|null
decl_stmt|;
DECL|field|isUpgradeFinalized
specifier|private
name|boolean
name|isUpgradeFinalized
init|=
literal|false
decl_stmt|;
DECL|field|storage
specifier|protected
name|NNStorage
name|storage
decl_stmt|;
comment|/**    * The last transaction ID that was either loaded from an image    * or loaded by loading edits files.    */
DECL|field|lastAppliedTxId
specifier|protected
name|long
name|lastAppliedTxId
init|=
literal|0
decl_stmt|;
DECL|field|conf
specifier|final
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|archivalManager
specifier|protected
name|NNStorageRetentionManager
name|archivalManager
decl_stmt|;
DECL|field|quotaInitThreads
specifier|private
name|int
name|quotaInitThreads
decl_stmt|;
comment|/* Used to make sure there are no concurrent checkpoints for a given txid    * The checkpoint here could be one of the following operations.    * a. checkpoint when NN is in standby.    * b. admin saveNameSpace operation.    * c. download checkpoint file from any remote checkpointer.   */
DECL|field|currentlyCheckpointing
specifier|private
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|currentlyCheckpointing
init|=
name|Collections
operator|.
expr|<
name|Long
operator|>
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Construct an FSImage    * @param conf Configuration    * @throws IOException if default directories are invalid.    */
DECL|method|FSImage (Configuration conf)
specifier|public
name|FSImage
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|FSNamesystem
operator|.
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
argument_list|,
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct the FSImage. Set the default checkpoint directories.    *    * Setup storage and initialize the edit log.    *    * @param conf Configuration    * @param imageDirs Directories the image can be stored in.    * @param editsDirs Directories the editlog can be stored in.    * @throws IOException if directories are invalid.    */
DECL|method|FSImage (Configuration conf, Collection<URI> imageDirs, List<URI> editsDirs)
specifier|protected
name|FSImage
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|imageDirs
parameter_list|,
name|List
argument_list|<
name|URI
argument_list|>
name|editsDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|storage
operator|=
operator|new
name|NNStorage
argument_list|(
name|conf
argument_list|,
name|imageDirs
argument_list|,
name|editsDirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_RESTORE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_RESTORE_DEFAULT
argument_list|)
condition|)
block|{
name|storage
operator|.
name|setRestoreFailedStorage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|editLog
operator|=
operator|new
name|FSEditLog
argument_list|(
name|conf
argument_list|,
name|storage
argument_list|,
name|editsDirs
argument_list|)
expr_stmt|;
name|archivalManager
operator|=
operator|new
name|NNStorageRetentionManager
argument_list|(
name|conf
argument_list|,
name|storage
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
block|}
DECL|method|format (FSNamesystem fsn, String clusterId)
name|void
name|format
parameter_list|(
name|FSNamesystem
name|fsn
parameter_list|,
name|String
name|clusterId
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|fileCount
init|=
name|fsn
operator|.
name|getFilesTotal
argument_list|()
decl_stmt|;
comment|// Expect 1 file, which is the root inode
name|Preconditions
operator|.
name|checkState
argument_list|(
name|fileCount
operator|==
literal|1
argument_list|,
literal|"FSImage.format should be called with an uninitialized namesystem, has "
operator|+
name|fileCount
operator|+
literal|" files"
argument_list|)
expr_stmt|;
name|NamespaceInfo
name|ns
init|=
name|NNStorage
operator|.
name|newNamespaceInfo
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Allocated new BlockPoolId: "
operator|+
name|ns
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
name|ns
operator|.
name|clusterID
operator|=
name|clusterId
expr_stmt|;
name|storage
operator|.
name|format
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|formatNonFileJournals
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|saveFSImageInAllDirs
argument_list|(
name|fsn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check whether the storage directories and non-file journals exist.    * If running in interactive mode, will prompt the user for each    * directory to allow them to format anyway. Otherwise, returns    * false, unless 'force' is specified.    *     * @param force if true, format regardless of whether dirs exist    * @param interactive prompt the user when a dir exists    * @return true if formatting should proceed    * @throws IOException if some storage cannot be accessed    */
DECL|method|confirmFormat (boolean force, boolean interactive)
name|boolean
name|confirmFormat
parameter_list|(
name|boolean
name|force
parameter_list|,
name|boolean
name|interactive
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FormatConfirmable
argument_list|>
name|confirms
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
literal|null
argument_list|)
control|)
block|{
name|confirms
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
name|confirms
operator|.
name|addAll
argument_list|(
name|editLog
operator|.
name|getFormatConfirmables
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Storage
operator|.
name|confirmFormat
argument_list|(
name|confirms
argument_list|,
name|force
argument_list|,
name|interactive
argument_list|)
return|;
block|}
comment|/**    * Analyze storage directories.    * Recover from previous transitions if required.     * Perform fs state transition if necessary depending on the namespace info.    * Read storage info.     *     * @throws IOException    * @return true if the image needs to be saved or false otherwise    */
DECL|method|recoverTransitionRead (StartupOption startOpt, FSNamesystem target, MetaRecoveryContext recovery)
name|boolean
name|recoverTransitionRead
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|FSNamesystem
name|target
parameter_list|,
name|MetaRecoveryContext
name|recovery
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|startOpt
operator|!=
name|StartupOption
operator|.
name|FORMAT
operator|:
literal|"NameNode formatting should be performed before reading the image"
assert|;
name|Collection
argument_list|<
name|URI
argument_list|>
name|imageDirs
init|=
name|storage
operator|.
name|getImageDirectories
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
name|editLog
operator|.
name|getEditURIs
argument_list|()
decl_stmt|;
comment|// none of the data dirs exist
if|if
condition|(
operator|(
name|imageDirs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|editsDirs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|IMPORT
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All specified directories are not accessible or do not exist."
argument_list|)
throw|;
comment|// 1. For each data directory calculate its state and
comment|// check whether all is consistent before transitioning.
name|Map
argument_list|<
name|StorageDirectory
argument_list|,
name|StorageState
argument_list|>
name|dataDirStates
init|=
operator|new
name|HashMap
argument_list|<
name|StorageDirectory
argument_list|,
name|StorageState
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|isFormatted
init|=
name|recoverStorageDirs
argument_list|(
name|startOpt
argument_list|,
name|storage
argument_list|,
name|dataDirStates
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Data dir states:\n  "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|"\n  "
argument_list|)
operator|.
name|withKeyValueSeparator
argument_list|(
literal|": "
argument_list|)
operator|.
name|join
argument_list|(
name|dataDirStates
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isFormatted
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|ROLLBACK
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|IMPORT
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NameNode is not formatted."
argument_list|)
throw|;
block|}
name|int
name|layoutVersion
init|=
name|storage
operator|.
name|getLayoutVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|METADATAVERSION
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"HDFS Image Version: "
operator|+
name|layoutVersion
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Software format version: "
operator|+
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|layoutVersion
operator|<
name|Storage
operator|.
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
condition|)
block|{
name|NNStorage
operator|.
name|checkVersionUpgradable
argument_list|(
name|storage
operator|.
name|getLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startOpt
operator|!=
name|StartupOption
operator|.
name|UPGRADE
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|UPGRADEONLY
operator|&&
operator|!
name|RollingUpgradeStartupOption
operator|.
name|STARTED
operator|.
name|matches
argument_list|(
name|startOpt
argument_list|)
operator|&&
name|layoutVersion
operator|<
name|Storage
operator|.
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
operator|&&
name|layoutVersion
operator|!=
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"\nFile system image contains an old layout version "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|".\nAn upgrade to version "
operator|+
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
operator|+
literal|" is required.\n"
operator|+
literal|"Please restart NameNode with the \""
operator|+
name|RollingUpgradeStartupOption
operator|.
name|STARTED
operator|.
name|getOptionString
argument_list|()
operator|+
literal|"\" option if a rolling upgrade is already started;"
operator|+
literal|" or restart NameNode with the \""
operator|+
name|StartupOption
operator|.
name|UPGRADE
operator|.
name|getName
argument_list|()
operator|+
literal|"\" option to start"
operator|+
literal|" a new upgrade."
argument_list|)
throw|;
block|}
name|storage
operator|.
name|processStartupOptionsForUpgrade
argument_list|(
name|startOpt
argument_list|,
name|layoutVersion
argument_list|)
expr_stmt|;
comment|// 2. Format unformatted dirs.
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|StorageState
name|curState
init|=
name|dataDirStates
operator|.
name|get
argument_list|(
name|sd
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|NON_EXISTENT
case|:
throw|throw
operator|new
name|IOException
argument_list|(
name|StorageState
operator|.
name|NON_EXISTENT
operator|+
literal|" state cannot be here"
argument_list|)
throw|;
case|case
name|NOT_FORMATTED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is not formatted."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Formatting ..."
argument_list|)
expr_stmt|;
name|sd
operator|.
name|clearDirectory
argument_list|()
expr_stmt|;
comment|// create empty currrent dir
break|break;
default|default:
break|break;
block|}
block|}
comment|// 3. Do transitions
switch|switch
condition|(
name|startOpt
condition|)
block|{
case|case
name|UPGRADE
case|:
case|case
name|UPGRADEONLY
case|:
name|doUpgrade
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// upgrade saved image already
case|case
name|IMPORT
case|:
name|doImportCheckpoint
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// import checkpoint saved image already
case|case
name|ROLLBACK
case|:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Rollback is now a standalone command, "
operator|+
literal|"NameNode should not be starting with this option."
argument_list|)
throw|;
case|case
name|REGULAR
case|:
default|default:
comment|// just load the image
block|}
return|return
name|loadFSImage
argument_list|(
name|target
argument_list|,
name|startOpt
argument_list|,
name|recovery
argument_list|)
return|;
block|}
comment|/**    * For each storage directory, performs recovery of incomplete transitions    * (eg. upgrade, rollback, checkpoint) and inserts the directory's storage    * state into the dataDirStates map.    * @param dataDirStates output of storage directory states    * @return true if there is at least one valid formatted storage directory    */
DECL|method|recoverStorageDirs (StartupOption startOpt, NNStorage storage, Map<StorageDirectory, StorageState> dataDirStates)
specifier|public
specifier|static
name|boolean
name|recoverStorageDirs
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|NNStorage
name|storage
parameter_list|,
name|Map
argument_list|<
name|StorageDirectory
argument_list|,
name|StorageState
argument_list|>
name|dataDirStates
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|isFormatted
init|=
literal|false
decl_stmt|;
comment|// This loop needs to be over all storage dirs, even shared dirs, to make
comment|// sure that we properly examine their state, but we make sure we don't
comment|// mutate the shared dir below in the actual loop.
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|StorageState
name|curState
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|METADATAVERSION
condition|)
block|{
comment|/* All we need is the layout version. */
name|storage
operator|.
name|readProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
try|try
block|{
name|curState
operator|=
name|sd
operator|.
name|analyzeStorage
argument_list|(
name|startOpt
argument_list|,
name|storage
argument_list|)
expr_stmt|;
comment|// sd is locked but not opened
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|NON_EXISTENT
case|:
comment|// name-node fails if any of the configured storage dirs are missing
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"storage directory does not exist or is not accessible."
argument_list|)
throw|;
case|case
name|NOT_FORMATTED
case|:
break|break;
case|case
name|NORMAL
case|:
break|break;
default|default:
comment|// recovery is possible
name|sd
operator|.
name|doRecover
argument_list|(
name|curState
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curState
operator|!=
name|StorageState
operator|.
name|NOT_FORMATTED
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|ROLLBACK
condition|)
block|{
comment|// read and verify consistency with other directories
name|storage
operator|.
name|readProperties
argument_list|(
name|sd
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
name|isFormatted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
operator|&&
name|isFormatted
condition|)
comment|// import of a checkpoint is allowed only into empty image directories
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot import image from a checkpoint. "
operator|+
literal|" NameNode already contains an image in "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
name|dataDirStates
operator|.
name|put
argument_list|(
name|sd
argument_list|,
name|curState
argument_list|)
expr_stmt|;
block|}
return|return
name|isFormatted
return|;
block|}
comment|/** Check if upgrade is in progress. */
DECL|method|checkUpgrade (NNStorage storage)
specifier|public
specifier|static
name|void
name|checkUpgrade
parameter_list|(
name|NNStorage
name|storage
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Upgrade or rolling upgrade is allowed only if there are
comment|// no previous fs states in any of the local directories
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
literal|false
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sd
operator|.
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"previous fs state should not exist during upgrade. "
operator|+
literal|"Finalize or rollback first."
argument_list|)
throw|;
block|}
block|}
DECL|method|checkUpgrade ()
name|void
name|checkUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|checkUpgrade
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return true if there is rollback fsimage (for rolling upgrade) in NameNode    * directory.    */
DECL|method|hasRollbackFSImage ()
specifier|public
name|boolean
name|hasRollbackFSImage
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FSImageStorageInspector
name|inspector
init|=
operator|new
name|FSImageTransactionalStorageInspector
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|)
argument_list|)
decl_stmt|;
name|storage
operator|.
name|inspectStorageDirs
argument_list|(
name|inspector
argument_list|)
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|FSImageFile
argument_list|>
name|images
init|=
name|inspector
operator|.
name|getLatestImages
argument_list|()
decl_stmt|;
return|return
name|images
operator|!=
literal|null
operator|&&
operator|!
name|images
operator|.
name|isEmpty
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|doUpgrade (FSNamesystem target)
name|void
name|doUpgrade
parameter_list|(
name|FSNamesystem
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|checkUpgrade
argument_list|()
expr_stmt|;
comment|// load the latest image
comment|// Do upgrade for each directory
name|this
operator|.
name|loadFSImage
argument_list|(
name|target
argument_list|,
name|StartupOption
operator|.
name|UPGRADE
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|target
operator|.
name|checkRollingUpgrade
argument_list|(
literal|"upgrade namenode"
argument_list|)
expr_stmt|;
name|long
name|oldCTime
init|=
name|storage
operator|.
name|getCTime
argument_list|()
decl_stmt|;
name|storage
operator|.
name|cTime
operator|=
name|now
argument_list|()
expr_stmt|;
comment|// generate new cTime for the state
name|int
name|oldLV
init|=
name|storage
operator|.
name|getLayoutVersion
argument_list|()
decl_stmt|;
name|storage
operator|.
name|layoutVersion
operator|=
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
expr_stmt|;
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|errorSDs
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
operator|!
name|editLog
operator|.
name|isSegmentOpen
argument_list|()
operator|:
literal|"Edits log must not be open."
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting upgrade of local storage directories."
operator|+
literal|"\n   old LV = "
operator|+
name|oldLV
operator|+
literal|"; old CTime = "
operator|+
name|oldCTime
operator|+
literal|".\n   new LV = "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; new CTime = "
operator|+
name|storage
operator|.
name|getCTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// Do upgrade for each directory
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
literal|false
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|NNUpgradeUtil
operator|.
name|doPreUpgrade
argument_list|(
name|conf
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to move aside pre-upgrade storage "
operator|+
literal|"in image directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|target
operator|.
name|isHaEnabled
argument_list|()
condition|)
block|{
name|editLog
operator|.
name|doPreUpgradeOfSharedLog
argument_list|()
expr_stmt|;
block|}
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|errorSDs
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|saveFSImageInAllDirs
argument_list|(
name|target
argument_list|,
name|editLog
operator|.
name|getLastWrittenTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// upgrade shared edit storage first
if|if
condition|(
name|target
operator|.
name|isHaEnabled
argument_list|()
condition|)
block|{
name|editLog
operator|.
name|doUpgradeOfSharedLog
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
literal|false
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|NNUpgradeUtil
operator|.
name|doUpgrade
argument_list|(
name|sd
argument_list|,
name|storage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|errorSDs
argument_list|)
expr_stmt|;
name|isUpgradeFinalized
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|storage
operator|.
name|getRemovedStorageDirs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// during upgrade, it's a fatal error to fail any storage directory
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Upgrade failed in "
operator|+
name|storage
operator|.
name|getRemovedStorageDirs
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" storage directory(ies), previously logged."
argument_list|)
throw|;
block|}
block|}
DECL|method|doRollback (FSNamesystem fsns)
name|void
name|doRollback
parameter_list|(
name|FSNamesystem
name|fsns
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Rollback is allowed only if there is
comment|// a previous fs states in at least one of the storage directories.
comment|// Directories that don't have previous state do not rollback
name|boolean
name|canRollback
init|=
literal|false
decl_stmt|;
name|FSImage
name|prevState
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|layoutVersion
operator|=
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
literal|false
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|NNUpgradeUtil
operator|.
name|canRollBack
argument_list|(
name|sd
argument_list|,
name|storage
argument_list|,
name|prevState
operator|.
name|getStorage
argument_list|()
argument_list|,
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Can perform rollback for "
operator|+
name|sd
argument_list|)
expr_stmt|;
name|canRollback
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|fsns
operator|.
name|isHaEnabled
argument_list|()
condition|)
block|{
comment|// If HA is enabled, check if the shared log can be rolled back as well.
name|editLog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|boolean
name|canRollBackSharedEditLog
init|=
name|editLog
operator|.
name|canRollBackSharedLog
argument_list|(
name|prevState
operator|.
name|getStorage
argument_list|()
argument_list|,
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|canRollBackSharedEditLog
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Can perform rollback for shared edit log."
argument_list|)
expr_stmt|;
name|canRollback
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|canRollback
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot rollback. None of the storage "
operator|+
literal|"directories contain previous fs state."
argument_list|)
throw|;
comment|// Now that we know all directories are going to be consistent
comment|// Do rollback for each directory containing previous state
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
literal|false
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rolling back storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|".\n   new LV = "
operator|+
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; new CTime = "
operator|+
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|getCTime
argument_list|()
argument_list|)
expr_stmt|;
name|NNUpgradeUtil
operator|.
name|doRollBack
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fsns
operator|.
name|isHaEnabled
argument_list|()
condition|)
block|{
comment|// If HA is enabled, try to roll back the shared log as well.
name|editLog
operator|.
name|doRollback
argument_list|()
expr_stmt|;
block|}
name|isUpgradeFinalized
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|prevState
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Load image from a checkpoint directory and save it into the current one.    * @param target the NameSystem to import into    * @throws IOException    */
DECL|method|doImportCheckpoint (FSNamesystem target)
name|void
name|doImportCheckpoint
parameter_list|(
name|FSNamesystem
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|URI
argument_list|>
name|checkpointDirs
init|=
name|FSImage
operator|.
name|getCheckpointDirs
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|checkpointEditsDirs
init|=
name|FSImage
operator|.
name|getCheckpointEditsDirs
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkpointDirs
operator|==
literal|null
operator|||
name|checkpointDirs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot import image from a checkpoint. "
operator|+
literal|"\"dfs.namenode.checkpoint.dir\" is not set."
argument_list|)
throw|;
block|}
if|if
condition|(
name|checkpointEditsDirs
operator|==
literal|null
operator|||
name|checkpointEditsDirs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot import image from a checkpoint. "
operator|+
literal|"\"dfs.namenode.checkpoint.dir\" is not set."
argument_list|)
throw|;
block|}
name|FSImage
name|realImage
init|=
name|target
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
name|FSImage
name|ckptImage
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|checkpointDirs
argument_list|,
name|checkpointEditsDirs
argument_list|)
decl_stmt|;
comment|// load from the checkpoint dirs
try|try
block|{
name|ckptImage
operator|.
name|recoverTransitionRead
argument_list|(
name|StartupOption
operator|.
name|REGULAR
argument_list|,
name|target
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ckptImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// return back the real image
name|realImage
operator|.
name|getStorage
argument_list|()
operator|.
name|setStorageInfo
argument_list|(
name|ckptImage
operator|.
name|getStorage
argument_list|()
argument_list|)
expr_stmt|;
name|realImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|setNextTxId
argument_list|(
name|ckptImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|realImage
operator|.
name|initEditLog
argument_list|(
name|StartupOption
operator|.
name|IMPORT
argument_list|)
expr_stmt|;
name|realImage
operator|.
name|getStorage
argument_list|()
operator|.
name|setBlockPoolID
argument_list|(
name|ckptImage
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
comment|// and save it but keep the same checkpointTime
name|saveNamespace
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|getStorage
argument_list|()
operator|.
name|writeAll
argument_list|()
expr_stmt|;
block|}
DECL|method|finalizeUpgrade (boolean finalizeEditLog)
name|void
name|finalizeUpgrade
parameter_list|(
name|boolean
name|finalizeEditLog
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalizing upgrade for local dirs. "
operator|+
operator|(
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
literal|"\n   cur LV = "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; cur CTime = "
operator|+
name|storage
operator|.
name|getCTime
argument_list|()
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
literal|false
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|NNUpgradeUtil
operator|.
name|doFinalize
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finalizeEditLog
condition|)
block|{
comment|// We only do this in the case that HA is enabled and we're active. In any
comment|// other case the NN will have done the upgrade of the edits directories
comment|// already by virtue of the fact that they're local.
name|editLog
operator|.
name|doFinalizeOfSharedLog
argument_list|()
expr_stmt|;
block|}
name|isUpgradeFinalized
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|isUpgradeFinalized ()
name|boolean
name|isUpgradeFinalized
parameter_list|()
block|{
return|return
name|isUpgradeFinalized
return|;
block|}
DECL|method|getEditLog ()
specifier|public
name|FSEditLog
name|getEditLog
parameter_list|()
block|{
return|return
name|editLog
return|;
block|}
DECL|method|openEditLogForWrite (int layoutVersion)
name|void
name|openEditLogForWrite
parameter_list|(
name|int
name|layoutVersion
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|editLog
operator|!=
literal|null
operator|:
literal|"editLog must be initialized"
assert|;
name|editLog
operator|.
name|openForWrite
argument_list|(
name|layoutVersion
argument_list|)
expr_stmt|;
name|storage
operator|.
name|writeTransactionIdFileToStorage
argument_list|(
name|editLog
operator|.
name|getCurSegmentTxId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Toss the current image and namesystem, reloading from the specified    * file.    */
DECL|method|reloadFromImageFile (File file, FSNamesystem target)
name|void
name|reloadFromImageFile
parameter_list|(
name|File
name|file
parameter_list|,
name|FSNamesystem
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|target
operator|.
name|clear
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reloading namespace from "
operator|+
name|file
argument_list|)
expr_stmt|;
name|loadFSImage
argument_list|(
name|file
argument_list|,
name|target
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Choose latest image from one of the directories,    * load it and merge with the edits.    *     * Saving and loading fsimage should never trigger symlink resolution.     * The paths that are persisted do not have *intermediate* symlinks     * because intermediate symlinks are resolved at the time files,     * directories, and symlinks are created. All paths accessed while     * loading or saving fsimage should therefore only see symlinks as     * the final path component, and the functions called below do not    * resolve symlinks that are the final path component.    *    * @return whether the image should be saved    * @throws IOException    */
DECL|method|loadFSImage (FSNamesystem target, StartupOption startOpt, MetaRecoveryContext recovery)
specifier|private
name|boolean
name|loadFSImage
parameter_list|(
name|FSNamesystem
name|target
parameter_list|,
name|StartupOption
name|startOpt
parameter_list|,
name|MetaRecoveryContext
name|recovery
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|rollingRollback
init|=
name|RollingUpgradeStartupOption
operator|.
name|ROLLBACK
operator|.
name|matches
argument_list|(
name|startOpt
argument_list|)
decl_stmt|;
specifier|final
name|EnumSet
argument_list|<
name|NameNodeFile
argument_list|>
name|nnfs
decl_stmt|;
if|if
condition|(
name|rollingRollback
condition|)
block|{
comment|// if it is rollback of rolling upgrade, only load from the rollback image
name|nnfs
operator|=
name|EnumSet
operator|.
name|of
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise we can load from both IMAGE and IMAGE_ROLLBACK
name|nnfs
operator|=
name|EnumSet
operator|.
name|of
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|)
expr_stmt|;
block|}
specifier|final
name|FSImageStorageInspector
name|inspector
init|=
name|storage
operator|.
name|readAndInspectDirs
argument_list|(
name|nnfs
argument_list|,
name|startOpt
argument_list|)
decl_stmt|;
name|isUpgradeFinalized
operator|=
name|inspector
operator|.
name|isUpgradeFinalized
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|FSImageFile
argument_list|>
name|imageFiles
init|=
name|inspector
operator|.
name|getLatestImages
argument_list|()
decl_stmt|;
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
name|prog
operator|.
name|beginPhase
argument_list|(
name|Phase
operator|.
name|LOADING_FSIMAGE
argument_list|)
expr_stmt|;
name|File
name|phaseFile
init|=
name|imageFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFile
argument_list|()
decl_stmt|;
name|prog
operator|.
name|setFile
argument_list|(
name|Phase
operator|.
name|LOADING_FSIMAGE
argument_list|,
name|phaseFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|prog
operator|.
name|setSize
argument_list|(
name|Phase
operator|.
name|LOADING_FSIMAGE
argument_list|,
name|phaseFile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|needToSave
init|=
name|inspector
operator|.
name|needToSave
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|EditLogInputStream
argument_list|>
name|editStreams
init|=
literal|null
decl_stmt|;
name|initEditLog
argument_list|(
name|startOpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|LayoutVersion
operator|.
name|Feature
operator|.
name|TXID_BASED_LAYOUT
argument_list|,
name|getLayoutVersion
argument_list|()
argument_list|)
condition|)
block|{
comment|// If we're open for write, we're either non-HA or we're the active NN, so
comment|// we better be able to load all the edits. If we're the standby NN, it's
comment|// OK to not be able to read all of edits right now.
comment|// In the meanwhile, for HA upgrade, we will still write editlog thus need
comment|// this toAtLeastTxId to be set to the max-seen txid
comment|// For rollback in rolling upgrade, we need to set the toAtLeastTxId to
comment|// the txid right before the upgrade marker.
name|long
name|toAtLeastTxId
init|=
name|editLog
operator|.
name|isOpenForWrite
argument_list|()
condition|?
name|inspector
operator|.
name|getMaxSeenTxId
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|rollingRollback
condition|)
block|{
comment|// note that the first image in imageFiles is the special checkpoint
comment|// for the rolling upgrade
name|toAtLeastTxId
operator|=
name|imageFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getCheckpointTxId
argument_list|()
operator|+
literal|2
expr_stmt|;
block|}
name|editStreams
operator|=
name|editLog
operator|.
name|selectInputStreams
argument_list|(
name|imageFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getCheckpointTxId
argument_list|()
operator|+
literal|1
argument_list|,
name|toAtLeastTxId
argument_list|,
name|recovery
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|editStreams
operator|=
name|FSImagePreTransactionalStorageInspector
operator|.
name|getEditLogStreams
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
name|int
name|maxOpSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_OP_SIZE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_OP_SIZE_DEFAULT
argument_list|)
decl_stmt|;
for|for
control|(
name|EditLogInputStream
name|elis
range|:
name|editStreams
control|)
block|{
name|elis
operator|.
name|setMaxOpSize
argument_list|(
name|maxOpSize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|EditLogInputStream
name|l
range|:
name|editStreams
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Planning to load edit log stream: "
operator|+
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|editStreams
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No edit log streams selected."
argument_list|)
expr_stmt|;
block|}
name|Exception
name|le
init|=
literal|null
decl_stmt|;
name|FSImageFile
name|imageFile
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|imageFiles
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|imageFile
operator|=
name|imageFiles
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|loadFSImageFile
argument_list|(
name|target
argument_list|,
name|recovery
argument_list|,
name|imageFile
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IllegalReservedPathException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to load image from "
operator|+
name|imageFile
argument_list|,
name|ie
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|le
operator|=
name|e
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to load image from "
operator|+
name|imageFile
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|target
operator|.
name|clear
argument_list|()
expr_stmt|;
name|imageFile
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Failed to load any images, error out
if|if
condition|(
name|imageFile
operator|==
literal|null
condition|)
block|{
name|FSEditLog
operator|.
name|closeAllStreams
argument_list|(
name|editStreams
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to load FSImage file, see error(s) "
operator|+
literal|"above for more info."
argument_list|)
throw|;
block|}
name|prog
operator|.
name|endPhase
argument_list|(
name|Phase
operator|.
name|LOADING_FSIMAGE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rollingRollback
condition|)
block|{
name|long
name|txnsAdvanced
init|=
name|loadEdits
argument_list|(
name|editStreams
argument_list|,
name|target
argument_list|,
name|startOpt
argument_list|,
name|recovery
argument_list|)
decl_stmt|;
name|needToSave
operator||=
name|needsResaveBasedOnStaleCheckpoint
argument_list|(
name|imageFile
operator|.
name|getFile
argument_list|()
argument_list|,
name|txnsAdvanced
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals
comment|// to the last txid in rollback fsimage.
name|rollingRollback
argument_list|(
name|lastAppliedTxId
operator|+
literal|1
argument_list|,
name|imageFiles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getCheckpointTxId
argument_list|()
argument_list|)
expr_stmt|;
name|needToSave
operator|=
literal|false
expr_stmt|;
block|}
name|editLog
operator|.
name|setNextTxId
argument_list|(
name|lastAppliedTxId
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|needToSave
return|;
block|}
comment|/** rollback for rolling upgrade. */
DECL|method|rollingRollback (long discardSegmentTxId, long ckptId)
specifier|private
name|void
name|rollingRollback
parameter_list|(
name|long
name|discardSegmentTxId
parameter_list|,
name|long
name|ckptId
parameter_list|)
throws|throws
name|IOException
block|{
comment|// discard discard unnecessary editlog segments starting from the given id
name|this
operator|.
name|editLog
operator|.
name|discardSegments
argument_list|(
name|discardSegmentTxId
argument_list|)
expr_stmt|;
comment|// rename the special checkpoint
name|renameCheckpoint
argument_list|(
name|ckptId
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// purge all the checkpoints after the marker
name|archivalManager
operator|.
name|purgeCheckpoinsAfter
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
name|ckptId
argument_list|)
expr_stmt|;
comment|// HDFS-7939: purge all old fsimage_rollback_*
name|archivalManager
operator|.
name|purgeCheckpoints
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|)
expr_stmt|;
name|String
name|nameserviceId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|)
condition|)
block|{
comment|// close the editlog since it is currently open for write
name|this
operator|.
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// reopen the editlog for read
name|this
operator|.
name|editLog
operator|.
name|initSharedJournalsForRead
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|loadFSImageFile (FSNamesystem target, MetaRecoveryContext recovery, FSImageFile imageFile, StartupOption startupOption)
name|void
name|loadFSImageFile
parameter_list|(
name|FSNamesystem
name|target
parameter_list|,
name|MetaRecoveryContext
name|recovery
parameter_list|,
name|FSImageFile
name|imageFile
parameter_list|,
name|StartupOption
name|startupOption
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Planning to load image: "
operator|+
name|imageFile
argument_list|)
expr_stmt|;
name|StorageDirectory
name|sdForProperties
init|=
name|imageFile
operator|.
name|sd
decl_stmt|;
name|storage
operator|.
name|readProperties
argument_list|(
name|sdForProperties
argument_list|,
name|startupOption
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|LayoutVersion
operator|.
name|Feature
operator|.
name|TXID_BASED_LAYOUT
argument_list|,
name|getLayoutVersion
argument_list|()
argument_list|)
condition|)
block|{
comment|// For txid-based layout, we should have a .md5 file
comment|// next to the image file
name|boolean
name|isRollingRollback
init|=
name|RollingUpgradeStartupOption
operator|.
name|ROLLBACK
operator|.
name|matches
argument_list|(
name|startupOption
argument_list|)
decl_stmt|;
name|loadFSImage
argument_list|(
name|imageFile
operator|.
name|getFile
argument_list|()
argument_list|,
name|target
argument_list|,
name|recovery
argument_list|,
name|isRollingRollback
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NameNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|LayoutVersion
operator|.
name|Feature
operator|.
name|FSIMAGE_CHECKSUM
argument_list|,
name|getLayoutVersion
argument_list|()
argument_list|)
condition|)
block|{
comment|// In 0.22, we have the checksum stored in the VERSION file.
name|String
name|md5
init|=
name|storage
operator|.
name|getDeprecatedProperty
argument_list|(
name|NNStorage
operator|.
name|DEPRECATED_MESSAGE_DIGEST_PROPERTY
argument_list|)
decl_stmt|;
if|if
condition|(
name|md5
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sdForProperties
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"Message digest property "
operator|+
name|NNStorage
operator|.
name|DEPRECATED_MESSAGE_DIGEST_PROPERTY
operator|+
literal|" not set for storage directory "
operator|+
name|sdForProperties
operator|.
name|getRoot
argument_list|()
argument_list|)
throw|;
block|}
name|loadFSImage
argument_list|(
name|imageFile
operator|.
name|getFile
argument_list|()
argument_list|,
operator|new
name|MD5Hash
argument_list|(
name|md5
argument_list|)
argument_list|,
name|target
argument_list|,
name|recovery
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We don't have any record of the md5sum
name|loadFSImage
argument_list|(
name|imageFile
operator|.
name|getFile
argument_list|()
argument_list|,
literal|null
argument_list|,
name|target
argument_list|,
name|recovery
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|initEditLog (StartupOption startOpt)
specifier|public
name|void
name|initEditLog
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|getNamespaceID
argument_list|()
operator|!=
literal|0
argument_list|,
literal|"Must know namespace ID before initting edit log"
argument_list|)
expr_stmt|;
name|String
name|nameserviceId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|)
condition|)
block|{
comment|// If this NN is not HA
name|editLog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|editLog
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|)
operator|&&
operator|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADE
operator|||
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADEONLY
operator|||
name|RollingUpgradeStartupOption
operator|.
name|ROLLBACK
operator|.
name|matches
argument_list|(
name|startOpt
argument_list|)
operator|)
condition|)
block|{
comment|// This NN is HA, but we're doing an upgrade or a rollback of rolling
comment|// upgrade so init the edit log for write.
name|editLog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADE
operator|||
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADEONLY
condition|)
block|{
name|long
name|sharedLogCTime
init|=
name|editLog
operator|.
name|getSharedLogCTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|storage
operator|.
name|getCTime
argument_list|()
operator|<
name|sharedLogCTime
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"It looks like the shared log is already "
operator|+
literal|"being upgraded but this NN has not been upgraded yet. You "
operator|+
literal|"should restart this NameNode with the '"
operator|+
name|StartupOption
operator|.
name|BOOTSTRAPSTANDBY
operator|.
name|getName
argument_list|()
operator|+
literal|"' option to bring "
operator|+
literal|"this NN in sync with the other."
argument_list|)
throw|;
block|}
block|}
name|editLog
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// This NN is HA and we're not doing an upgrade.
name|editLog
operator|.
name|initSharedJournalsForRead
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @param imageFile the image file that was loaded    * @param numEditsLoaded the number of edits loaded from edits logs    * @return true if the NameNode should automatically save the namespace    * when it is started, due to the latest checkpoint being too old.    */
DECL|method|needsResaveBasedOnStaleCheckpoint ( File imageFile, long numEditsLoaded)
specifier|private
name|boolean
name|needsResaveBasedOnStaleCheckpoint
parameter_list|(
name|File
name|imageFile
parameter_list|,
name|long
name|numEditsLoaded
parameter_list|)
block|{
specifier|final
name|long
name|checkpointPeriod
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_PERIOD_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_PERIOD_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|long
name|checkpointTxnCount
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|checkpointAge
init|=
name|Time
operator|.
name|now
argument_list|()
operator|-
name|imageFile
operator|.
name|lastModified
argument_list|()
decl_stmt|;
return|return
operator|(
name|checkpointAge
operator|>
name|checkpointPeriod
operator|*
literal|1000
operator|)
operator|||
operator|(
name|numEditsLoaded
operator|>
name|checkpointTxnCount
operator|)
return|;
block|}
comment|/**    * Load the specified list of edit files into the image.    */
DECL|method|loadEdits (Iterable<EditLogInputStream> editStreams, FSNamesystem target)
specifier|public
name|long
name|loadEdits
parameter_list|(
name|Iterable
argument_list|<
name|EditLogInputStream
argument_list|>
name|editStreams
parameter_list|,
name|FSNamesystem
name|target
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|loadEdits
argument_list|(
name|editStreams
argument_list|,
name|target
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|loadEdits (Iterable<EditLogInputStream> editStreams, FSNamesystem target, StartupOption startOpt, MetaRecoveryContext recovery)
specifier|private
name|long
name|loadEdits
parameter_list|(
name|Iterable
argument_list|<
name|EditLogInputStream
argument_list|>
name|editStreams
parameter_list|,
name|FSNamesystem
name|target
parameter_list|,
name|StartupOption
name|startOpt
parameter_list|,
name|MetaRecoveryContext
name|recovery
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"About to load edits:\n  "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|"\n  "
argument_list|)
operator|.
name|join
argument_list|(
name|editStreams
argument_list|)
argument_list|)
expr_stmt|;
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
name|prog
operator|.
name|beginPhase
argument_list|(
name|Phase
operator|.
name|LOADING_EDITS
argument_list|)
expr_stmt|;
name|long
name|prevLastAppliedTxId
init|=
name|lastAppliedTxId
decl_stmt|;
try|try
block|{
name|FSEditLogLoader
name|loader
init|=
operator|new
name|FSEditLogLoader
argument_list|(
name|target
argument_list|,
name|lastAppliedTxId
argument_list|)
decl_stmt|;
comment|// Load latest edits
for|for
control|(
name|EditLogInputStream
name|editIn
range|:
name|editStreams
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reading "
operator|+
name|editIn
operator|+
literal|" expecting start txid #"
operator|+
operator|(
name|lastAppliedTxId
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
try|try
block|{
name|loader
operator|.
name|loadFSEdits
argument_list|(
name|editIn
argument_list|,
name|lastAppliedTxId
operator|+
literal|1
argument_list|,
name|startOpt
argument_list|,
name|recovery
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Update lastAppliedTxId even in case of error, since some ops may
comment|// have been successfully applied before the error.
name|lastAppliedTxId
operator|=
name|loader
operator|.
name|getLastAppliedTxId
argument_list|()
expr_stmt|;
block|}
comment|// If we are in recovery mode, we may have skipped over some txids.
if|if
condition|(
name|editIn
operator|.
name|getLastTxId
argument_list|()
operator|!=
name|HdfsServerConstants
operator|.
name|INVALID_TXID
condition|)
block|{
name|lastAppliedTxId
operator|=
name|editIn
operator|.
name|getLastTxId
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|FSEditLog
operator|.
name|closeAllStreams
argument_list|(
name|editStreams
argument_list|)
expr_stmt|;
block|}
name|prog
operator|.
name|endPhase
argument_list|(
name|Phase
operator|.
name|LOADING_EDITS
argument_list|)
expr_stmt|;
return|return
name|lastAppliedTxId
operator|-
name|prevLastAppliedTxId
return|;
block|}
comment|/**    * Load the image namespace from the given image file, verifying    * it against the MD5 sum stored in its associated .md5 file.    */
DECL|method|loadFSImage (File imageFile, FSNamesystem target, MetaRecoveryContext recovery, boolean requireSameLayoutVersion)
specifier|private
name|void
name|loadFSImage
parameter_list|(
name|File
name|imageFile
parameter_list|,
name|FSNamesystem
name|target
parameter_list|,
name|MetaRecoveryContext
name|recovery
parameter_list|,
name|boolean
name|requireSameLayoutVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|MD5Hash
name|expectedMD5
init|=
name|MD5FileUtils
operator|.
name|readStoredMd5ForFile
argument_list|(
name|imageFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedMD5
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No MD5 file found corresponding to image file "
operator|+
name|imageFile
argument_list|)
throw|;
block|}
name|loadFSImage
argument_list|(
name|imageFile
argument_list|,
name|expectedMD5
argument_list|,
name|target
argument_list|,
name|recovery
argument_list|,
name|requireSameLayoutVersion
argument_list|)
expr_stmt|;
block|}
comment|/**    * Load in the filesystem image from file. It's a big list of    * filenames and blocks.    */
DECL|method|loadFSImage (File curFile, MD5Hash expectedMd5, FSNamesystem target, MetaRecoveryContext recovery, boolean requireSameLayoutVersion)
specifier|private
name|void
name|loadFSImage
parameter_list|(
name|File
name|curFile
parameter_list|,
name|MD5Hash
name|expectedMd5
parameter_list|,
name|FSNamesystem
name|target
parameter_list|,
name|MetaRecoveryContext
name|recovery
parameter_list|,
name|boolean
name|requireSameLayoutVersion
parameter_list|)
throws|throws
name|IOException
block|{
comment|// BlockPoolId is required when the FsImageLoader loads the rolling upgrade
comment|// information. Make sure the ID is properly set.
name|target
operator|.
name|setBlockPoolId
argument_list|(
name|this
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
name|FSImageFormat
operator|.
name|LoaderDelegator
name|loader
init|=
name|FSImageFormat
operator|.
name|newLoader
argument_list|(
name|conf
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|loader
operator|.
name|load
argument_list|(
name|curFile
argument_list|,
name|requireSameLayoutVersion
argument_list|)
expr_stmt|;
comment|// Check that the image digest we loaded matches up with what
comment|// we expected
name|MD5Hash
name|readImageMd5
init|=
name|loader
operator|.
name|getLoadedImageMd5
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedMd5
operator|!=
literal|null
operator|&&
operator|!
name|expectedMd5
operator|.
name|equals
argument_list|(
name|readImageMd5
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Image file "
operator|+
name|curFile
operator|+
literal|" is corrupt with MD5 checksum of "
operator|+
name|readImageMd5
operator|+
literal|" but expecting "
operator|+
name|expectedMd5
argument_list|)
throw|;
block|}
name|long
name|txId
init|=
name|loader
operator|.
name|getLoadedImageTxId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Loaded image for txid "
operator|+
name|txId
operator|+
literal|" from "
operator|+
name|curFile
argument_list|)
expr_stmt|;
name|lastAppliedTxId
operator|=
name|txId
expr_stmt|;
name|storage
operator|.
name|setMostRecentCheckpointInfo
argument_list|(
name|txId
argument_list|,
name|curFile
operator|.
name|lastModified
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Save the contents of the FS image to the file.    */
DECL|method|saveFSImage (SaveNamespaceContext context, StorageDirectory sd, NameNodeFile dstType)
name|void
name|saveFSImage
parameter_list|(
name|SaveNamespaceContext
name|context
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|,
name|NameNodeFile
name|dstType
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|txid
init|=
name|context
operator|.
name|getTxId
argument_list|()
decl_stmt|;
name|File
name|newFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|,
name|txid
argument_list|)
decl_stmt|;
name|File
name|dstFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|dstType
argument_list|,
name|txid
argument_list|)
decl_stmt|;
name|FSImageFormatProtobuf
operator|.
name|Saver
name|saver
init|=
operator|new
name|FSImageFormatProtobuf
operator|.
name|Saver
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|FSImageCompression
name|compression
init|=
name|FSImageCompression
operator|.
name|createCompression
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|saver
operator|.
name|save
argument_list|(
name|newFile
argument_list|,
name|compression
argument_list|)
expr_stmt|;
name|MD5FileUtils
operator|.
name|saveMD5File
argument_list|(
name|dstFile
argument_list|,
name|saver
operator|.
name|getSavedDigest
argument_list|()
argument_list|)
expr_stmt|;
name|storage
operator|.
name|setMostRecentCheckpointInfo
argument_list|(
name|txid
argument_list|,
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Save FSimage in the legacy format. This is not for NN consumption,    * but for tools like OIV.    */
DECL|method|saveLegacyOIVImage (FSNamesystem source, String targetDir, Canceler canceler)
specifier|public
name|void
name|saveLegacyOIVImage
parameter_list|(
name|FSNamesystem
name|source
parameter_list|,
name|String
name|targetDir
parameter_list|,
name|Canceler
name|canceler
parameter_list|)
throws|throws
name|IOException
block|{
name|FSImageCompression
name|compression
init|=
name|FSImageCompression
operator|.
name|createCompression
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|long
name|txid
init|=
name|getLastAppliedOrWrittenTxId
argument_list|()
decl_stmt|;
name|SaveNamespaceContext
name|ctx
init|=
operator|new
name|SaveNamespaceContext
argument_list|(
name|source
argument_list|,
name|txid
argument_list|,
name|canceler
argument_list|)
decl_stmt|;
name|FSImageFormat
operator|.
name|Saver
name|saver
init|=
operator|new
name|FSImageFormat
operator|.
name|Saver
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|String
name|imageFileName
init|=
name|NNStorage
operator|.
name|getLegacyOIVImageFileName
argument_list|(
name|txid
argument_list|)
decl_stmt|;
name|File
name|imageFile
init|=
operator|new
name|File
argument_list|(
name|targetDir
argument_list|,
name|imageFileName
argument_list|)
decl_stmt|;
name|saver
operator|.
name|save
argument_list|(
name|imageFile
argument_list|,
name|compression
argument_list|)
expr_stmt|;
name|archivalManager
operator|.
name|purgeOldLegacyOIVImages
argument_list|(
name|targetDir
argument_list|,
name|txid
argument_list|)
expr_stmt|;
block|}
comment|/**    * FSImageSaver is being run in a separate thread when saving    * FSImage. There is one thread per each copy of the image.    *    * FSImageSaver assumes that it was launched from a thread that holds    * FSNamesystem lock and waits for the execution of FSImageSaver thread    * to finish.    * This way we are guaranteed that the namespace is not being updated    * while multiple instances of FSImageSaver are traversing it    * and writing it out.    */
DECL|class|FSImageSaver
specifier|private
class|class
name|FSImageSaver
implements|implements
name|Runnable
block|{
DECL|field|context
specifier|private
specifier|final
name|SaveNamespaceContext
name|context
decl_stmt|;
DECL|field|sd
specifier|private
specifier|final
name|StorageDirectory
name|sd
decl_stmt|;
DECL|field|nnf
specifier|private
specifier|final
name|NameNodeFile
name|nnf
decl_stmt|;
DECL|method|FSImageSaver (SaveNamespaceContext context, StorageDirectory sd, NameNodeFile nnf)
specifier|public
name|FSImageSaver
parameter_list|(
name|SaveNamespaceContext
name|context
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|,
name|NameNodeFile
name|nnf
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|sd
operator|=
name|sd
expr_stmt|;
name|this
operator|.
name|nnf
operator|=
name|nnf
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|saveFSImage
argument_list|(
name|context
argument_list|,
name|sd
argument_list|,
name|nnf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SaveNamespaceCancelledException
name|snce
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cancelled image saving for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|": "
operator|+
name|snce
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// don't report an error on the storage dir!
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to save image for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|context
operator|.
name|reportErrorOnStorageDirectory
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSImageSaver for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" of type "
operator|+
name|sd
operator|.
name|getStorageDirType
argument_list|()
return|;
block|}
block|}
DECL|method|waitForThreads (List<Thread> threads)
specifier|private
name|void
name|waitForThreads
parameter_list|(
name|List
argument_list|<
name|Thread
argument_list|>
name|threads
parameter_list|)
block|{
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
while|while
condition|(
name|thread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
try|try
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught interrupted exception while waiting for thread "
operator|+
name|thread
operator|.
name|getName
argument_list|()
operator|+
literal|" to finish. Retrying join"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Update version of all storage directories.    */
DECL|method|updateStorageVersion ()
specifier|public
specifier|synchronized
name|void
name|updateStorageVersion
parameter_list|()
throws|throws
name|IOException
block|{
name|storage
operator|.
name|writeAll
argument_list|()
expr_stmt|;
block|}
comment|/**    * @param timeWindow a checkpoint is done if the latest checkpoint    *                   was done more than this number of seconds ago.    * @param txGap a checkpoint is done also if the gap between the latest tx id    *              and the latest checkpoint is greater than this number.    * @return true if a checkpoint has been made    * @see #saveNamespace(FSNamesystem, NameNodeFile, Canceler)    */
DECL|method|saveNamespace (long timeWindow, long txGap, FSNamesystem source)
specifier|public
specifier|synchronized
name|boolean
name|saveNamespace
parameter_list|(
name|long
name|timeWindow
parameter_list|,
name|long
name|txGap
parameter_list|,
name|FSNamesystem
name|source
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|timeWindow
operator|>
literal|0
operator|||
name|txGap
operator|>
literal|0
condition|)
block|{
specifier|final
name|FSImageStorageInspector
name|inspector
init|=
name|storage
operator|.
name|readAndInspectDirs
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|)
argument_list|,
name|StartupOption
operator|.
name|REGULAR
argument_list|)
decl_stmt|;
name|FSImageFile
name|image
init|=
name|inspector
operator|.
name|getLatestImages
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|File
name|imageFile
init|=
name|image
operator|.
name|getFile
argument_list|()
decl_stmt|;
specifier|final
name|long
name|checkpointTxId
init|=
name|image
operator|.
name|getCheckpointTxId
argument_list|()
decl_stmt|;
specifier|final
name|long
name|checkpointAge
init|=
name|Time
operator|.
name|now
argument_list|()
operator|-
name|imageFile
operator|.
name|lastModified
argument_list|()
decl_stmt|;
if|if
condition|(
name|checkpointAge
operator|<=
name|timeWindow
operator|*
literal|1000
operator|&&
name|checkpointTxId
operator|>=
name|this
operator|.
name|getLastAppliedOrWrittenTxId
argument_list|()
operator|-
name|txGap
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|saveNamespace
argument_list|(
name|source
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|saveNamespace (FSNamesystem source)
specifier|public
name|void
name|saveNamespace
parameter_list|(
name|FSNamesystem
name|source
parameter_list|)
throws|throws
name|IOException
block|{
name|saveNamespace
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
comment|/**    * Save the contents of the FS image to a new image file in each of the    * current storage directories.    */
DECL|method|saveNamespace (FSNamesystem source, NameNodeFile nnf, Canceler canceler)
specifier|public
specifier|synchronized
name|void
name|saveNamespace
parameter_list|(
name|FSNamesystem
name|source
parameter_list|,
name|NameNodeFile
name|nnf
parameter_list|,
name|Canceler
name|canceler
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|editLog
operator|!=
literal|null
operator|:
literal|"editLog must be initialized"
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Save namespace ..."
argument_list|)
expr_stmt|;
name|storage
operator|.
name|attemptRestoreRemovedStorage
argument_list|()
expr_stmt|;
name|boolean
name|editLogWasOpen
init|=
name|editLog
operator|.
name|isSegmentOpen
argument_list|()
decl_stmt|;
if|if
condition|(
name|editLogWasOpen
condition|)
block|{
name|editLog
operator|.
name|endCurrentLogSegment
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|long
name|imageTxId
init|=
name|getLastAppliedOrWrittenTxId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addToCheckpointing
argument_list|(
name|imageTxId
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FS image is being downloaded from another NN at txid "
operator|+
name|imageTxId
argument_list|)
throw|;
block|}
try|try
block|{
try|try
block|{
name|saveFSImageInAllDirs
argument_list|(
name|source
argument_list|,
name|nnf
argument_list|,
name|imageTxId
argument_list|,
name|canceler
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|source
operator|.
name|isRollingUpgrade
argument_list|()
condition|)
block|{
name|storage
operator|.
name|writeAll
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|editLogWasOpen
condition|)
block|{
name|editLog
operator|.
name|startLogSegmentAndWriteHeaderTxn
argument_list|(
name|imageTxId
operator|+
literal|1
argument_list|,
name|source
operator|.
name|getEffectiveLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|// Take this opportunity to note the current transaction.
comment|// Even if the namespace save was cancelled, this marker
comment|// is only used to determine what transaction ID is required
comment|// for startup. So, it doesn't hurt to update it unnecessarily.
name|storage
operator|.
name|writeTransactionIdFileToStorage
argument_list|(
name|imageTxId
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|removeFromCheckpointing
argument_list|(
name|imageTxId
argument_list|)
expr_stmt|;
block|}
comment|//Update NameDirSize Metric
name|getStorage
argument_list|()
operator|.
name|updateNameDirSize
argument_list|()
expr_stmt|;
block|}
comment|/**    * @see #saveFSImageInAllDirs(FSNamesystem, NameNodeFile, long, Canceler)    */
DECL|method|saveFSImageInAllDirs (FSNamesystem source, long txid)
specifier|protected
specifier|synchronized
name|void
name|saveFSImageInAllDirs
parameter_list|(
name|FSNamesystem
name|source
parameter_list|,
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|addToCheckpointing
argument_list|(
name|txid
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
operator|(
literal|"FS image is being downloaded from another NN"
operator|)
argument_list|)
throw|;
block|}
try|try
block|{
name|saveFSImageInAllDirs
argument_list|(
name|source
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
name|txid
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|removeFromCheckpointing
argument_list|(
name|txid
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addToCheckpointing (long txid)
specifier|public
name|boolean
name|addToCheckpointing
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
return|return
name|currentlyCheckpointing
operator|.
name|add
argument_list|(
name|txid
argument_list|)
return|;
block|}
DECL|method|removeFromCheckpointing (long txid)
specifier|public
name|void
name|removeFromCheckpointing
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
name|currentlyCheckpointing
operator|.
name|remove
argument_list|(
name|txid
argument_list|)
expr_stmt|;
block|}
DECL|method|saveFSImageInAllDirs (FSNamesystem source, NameNodeFile nnf, long txid, Canceler canceler)
specifier|private
specifier|synchronized
name|void
name|saveFSImageInAllDirs
parameter_list|(
name|FSNamesystem
name|source
parameter_list|,
name|NameNodeFile
name|nnf
parameter_list|,
name|long
name|txid
parameter_list|,
name|Canceler
name|canceler
parameter_list|)
throws|throws
name|IOException
block|{
name|StartupProgress
name|prog
init|=
name|NameNode
operator|.
name|getStartupProgress
argument_list|()
decl_stmt|;
name|prog
operator|.
name|beginPhase
argument_list|(
name|Phase
operator|.
name|SAVING_CHECKPOINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No image directories available!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|canceler
operator|==
literal|null
condition|)
block|{
name|canceler
operator|=
operator|new
name|Canceler
argument_list|()
expr_stmt|;
block|}
name|SaveNamespaceContext
name|ctx
init|=
operator|new
name|SaveNamespaceContext
argument_list|(
name|source
argument_list|,
name|txid
argument_list|,
name|canceler
argument_list|)
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|Thread
argument_list|>
name|saveThreads
init|=
operator|new
name|ArrayList
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
comment|// save images into current
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|FSImageSaver
name|saver
init|=
operator|new
name|FSImageSaver
argument_list|(
name|ctx
argument_list|,
name|sd
argument_list|,
name|nnf
argument_list|)
decl_stmt|;
name|Thread
name|saveThread
init|=
operator|new
name|Thread
argument_list|(
name|saver
argument_list|,
name|saver
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|saveThreads
operator|.
name|add
argument_list|(
name|saveThread
argument_list|)
expr_stmt|;
name|saveThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|waitForThreads
argument_list|(
name|saveThreads
argument_list|)
expr_stmt|;
name|saveThreads
operator|.
name|clear
argument_list|()
expr_stmt|;
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|ctx
operator|.
name|getErrorSDs
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to save in any storage directories while saving namespace."
argument_list|)
throw|;
block|}
if|if
condition|(
name|canceler
operator|.
name|isCancelled
argument_list|()
condition|)
block|{
name|deleteCancelledCheckpoint
argument_list|(
name|txid
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|checkCancelled
argument_list|()
expr_stmt|;
comment|// throws
assert|assert
literal|false
operator|:
literal|"should have thrown above!"
assert|;
block|}
name|renameCheckpoint
argument_list|(
name|txid
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|,
name|nnf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Since we now have a new checkpoint, we can clean up some
comment|// old edit logs and checkpoints.
name|purgeOldStorage
argument_list|(
name|nnf
argument_list|)
expr_stmt|;
name|archivalManager
operator|.
name|purgeCheckpoints
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Notify any threads waiting on the checkpoint to be canceled
comment|// that it is complete.
name|ctx
operator|.
name|markComplete
argument_list|()
expr_stmt|;
name|ctx
operator|=
literal|null
expr_stmt|;
block|}
name|prog
operator|.
name|endPhase
argument_list|(
name|Phase
operator|.
name|SAVING_CHECKPOINT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Purge any files in the storage directories that are no longer    * necessary.    */
DECL|method|purgeOldStorage (NameNodeFile nnf)
name|void
name|purgeOldStorage
parameter_list|(
name|NameNodeFile
name|nnf
parameter_list|)
block|{
try|try
block|{
name|archivalManager
operator|.
name|purgeOldStorage
argument_list|(
name|nnf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to purge old storage "
operator|+
name|nnf
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rename FSImage with the specific txid    */
DECL|method|renameCheckpoint (long txid, NameNodeFile fromNnf, NameNodeFile toNnf, boolean renameMD5)
specifier|private
name|void
name|renameCheckpoint
parameter_list|(
name|long
name|txid
parameter_list|,
name|NameNodeFile
name|fromNnf
parameter_list|,
name|NameNodeFile
name|toNnf
parameter_list|,
name|boolean
name|renameMD5
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
name|al
init|=
literal|null
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
control|)
block|{
try|try
block|{
name|renameImageFileInDir
argument_list|(
name|sd
argument_list|,
name|fromNnf
argument_list|,
name|toNnf
argument_list|,
name|txid
argument_list|,
name|renameMD5
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to rename checkpoint in "
operator|+
name|sd
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|null
condition|)
block|{
name|al
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
block|}
name|al
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|al
operator|!=
literal|null
condition|)
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|al
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rename all the fsimage files with the specific NameNodeFile type. The    * associated checksum files will also be renamed.    */
DECL|method|renameCheckpoint (NameNodeFile fromNnf, NameNodeFile toNnf)
name|void
name|renameCheckpoint
parameter_list|(
name|NameNodeFile
name|fromNnf
parameter_list|,
name|NameNodeFile
name|toNnf
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
name|al
init|=
literal|null
decl_stmt|;
name|FSImageTransactionalStorageInspector
name|inspector
init|=
operator|new
name|FSImageTransactionalStorageInspector
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|fromNnf
argument_list|)
argument_list|)
decl_stmt|;
name|storage
operator|.
name|inspectStorageDirs
argument_list|(
name|inspector
argument_list|)
expr_stmt|;
for|for
control|(
name|FSImageFile
name|image
range|:
name|inspector
operator|.
name|getFoundImages
argument_list|()
control|)
block|{
try|try
block|{
name|renameImageFileInDir
argument_list|(
name|image
operator|.
name|sd
argument_list|,
name|fromNnf
argument_list|,
name|toNnf
argument_list|,
name|image
operator|.
name|txId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to rename checkpoint in "
operator|+
name|image
operator|.
name|sd
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|null
condition|)
block|{
name|al
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
block|}
name|al
operator|.
name|add
argument_list|(
name|image
operator|.
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|al
operator|!=
literal|null
condition|)
block|{
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|al
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes the checkpoint file in every storage directory,    * since the checkpoint was cancelled.    */
DECL|method|deleteCancelledCheckpoint (long txid)
specifier|private
name|void
name|deleteCancelledCheckpoint
parameter_list|(
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
name|al
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
control|)
block|{
name|File
name|ckpt
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|,
name|txid
argument_list|)
decl_stmt|;
if|if
condition|(
name|ckpt
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|ckpt
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to delete cancelled checkpoint in "
operator|+
name|sd
argument_list|)
expr_stmt|;
name|al
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|al
argument_list|)
expr_stmt|;
block|}
DECL|method|renameImageFileInDir (StorageDirectory sd, NameNodeFile fromNnf, NameNodeFile toNnf, long txid, boolean renameMD5)
specifier|private
name|void
name|renameImageFileInDir
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|NameNodeFile
name|fromNnf
parameter_list|,
name|NameNodeFile
name|toNnf
parameter_list|,
name|long
name|txid
parameter_list|,
name|boolean
name|renameMD5
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|fromFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|fromNnf
argument_list|,
name|txid
argument_list|)
decl_stmt|;
specifier|final
name|File
name|toFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|toNnf
argument_list|,
name|txid
argument_list|)
decl_stmt|;
comment|// renameTo fails on Windows if the destination file already exists.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"renaming  "
operator|+
name|fromFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" to "
operator|+
name|toFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fromFile
operator|.
name|renameTo
argument_list|(
name|toFile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|toFile
operator|.
name|delete
argument_list|()
operator|||
operator|!
name|fromFile
operator|.
name|renameTo
argument_list|(
name|toFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"renaming  "
operator|+
name|fromFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" to "
operator|+
name|toFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" FAILED"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|renameMD5
condition|)
block|{
name|MD5FileUtils
operator|.
name|renameMD5File
argument_list|(
name|fromFile
argument_list|,
name|toFile
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|rollEditLog (int layoutVersion)
name|CheckpointSignature
name|rollEditLog
parameter_list|(
name|int
name|layoutVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|getEditLog
argument_list|()
operator|.
name|rollEditLog
argument_list|(
name|layoutVersion
argument_list|)
expr_stmt|;
comment|// Record this log segment ID in all of the storage directories, so
comment|// we won't miss this log segment on a restart if the edits directories
comment|// go missing.
name|storage
operator|.
name|writeTransactionIdFileToStorage
argument_list|(
name|getEditLog
argument_list|()
operator|.
name|getCurSegmentTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|//Update NameDirSize Metric
name|getStorage
argument_list|()
operator|.
name|updateNameDirSize
argument_list|()
expr_stmt|;
return|return
operator|new
name|CheckpointSignature
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Start checkpoint.    *<p>    * If backup storage contains image that is newer than or incompatible with     * what the active name-node has, then the backup node should shutdown.<br>    * If the backup image is older than the active one then it should     * be discarded and downloaded from the active node.<br>    * If the images are the same then the backup image will be used as current.    *     * @param bnReg the backup node registration.    * @param nnReg this (active) name-node registration.    * @return {@link NamenodeCommand} if backup node should shutdown or    * {@link CheckpointCommand} prescribing what backup node should     *         do with its image.    * @throws IOException    */
DECL|method|startCheckpoint (NamenodeRegistration bnReg, NamenodeRegistration nnReg, int layoutVersion)
name|NamenodeCommand
name|startCheckpoint
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
comment|// backup node
name|NamenodeRegistration
name|nnReg
parameter_list|,
name|int
name|layoutVersion
parameter_list|)
comment|// active name-node
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Start checkpoint at txid "
operator|+
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|msg
init|=
literal|null
decl_stmt|;
comment|// Verify that checkpoint is allowed
if|if
condition|(
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
operator|!=
name|storage
operator|.
name|getNamespaceID
argument_list|()
condition|)
name|msg
operator|=
literal|"Name node "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
operator|+
literal|" has incompatible namespace id: "
operator|+
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|" expected: "
operator|+
name|storage
operator|.
name|getNamespaceID
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|bnReg
operator|.
name|isRole
argument_list|(
name|NamenodeRole
operator|.
name|NAMENODE
argument_list|)
condition|)
name|msg
operator|=
literal|"Name node "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
operator|+
literal|" role "
operator|+
name|bnReg
operator|.
name|getRole
argument_list|()
operator|+
literal|": checkpoint is not allowed."
expr_stmt|;
elseif|else
if|if
condition|(
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|<
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|||
operator|(
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|==
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|&&
name|bnReg
operator|.
name|getCTime
argument_list|()
operator|>
name|storage
operator|.
name|getCTime
argument_list|()
operator|)
condition|)
comment|// remote node has newer image age
name|msg
operator|=
literal|"Name node "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
operator|+
literal|" has newer image layout version: LV = "
operator|+
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" cTime = "
operator|+
name|bnReg
operator|.
name|getCTime
argument_list|()
operator|+
literal|". Current version: LV = "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" cTime = "
operator|+
name|storage
operator|.
name|getCTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|new
name|NamenodeCommand
argument_list|(
name|NamenodeProtocol
operator|.
name|ACT_SHUTDOWN
argument_list|)
return|;
block|}
name|boolean
name|needToReturnImg
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|==
literal|0
condition|)
comment|// do not return image if there are no image directories
name|needToReturnImg
operator|=
literal|false
expr_stmt|;
name|CheckpointSignature
name|sig
init|=
name|rollEditLog
argument_list|(
name|layoutVersion
argument_list|)
decl_stmt|;
return|return
operator|new
name|CheckpointCommand
argument_list|(
name|sig
argument_list|,
name|needToReturnImg
argument_list|)
return|;
block|}
comment|/**    * End checkpoint.    *<p>    * Validate the current storage info with the given signature.    *     * @param sig to validate the current storage info against    * @throws IOException if the checkpoint fields are inconsistent    */
DECL|method|endCheckpoint (CheckpointSignature sig)
name|void
name|endCheckpoint
parameter_list|(
name|CheckpointSignature
name|sig
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"End checkpoint at txid "
operator|+
name|getEditLog
argument_list|()
operator|.
name|getLastWrittenTxId
argument_list|()
argument_list|)
expr_stmt|;
name|sig
operator|.
name|validateStorageInfo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * This is called by the 2NN after having downloaded an image, and by    * the NN after having received a new image from the 2NN. It    * renames the image from fsimage_N.ckpt to fsimage_N and also    * saves the related .md5 file into place.    */
DECL|method|saveDigestAndRenameCheckpointImage (NameNodeFile nnf, long txid, MD5Hash digest)
specifier|public
specifier|synchronized
name|void
name|saveDigestAndRenameCheckpointImage
parameter_list|(
name|NameNodeFile
name|nnf
parameter_list|,
name|long
name|txid
parameter_list|,
name|MD5Hash
name|digest
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Write and rename MD5 file
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|badSds
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
control|)
block|{
name|File
name|imageFile
init|=
name|NNStorage
operator|.
name|getImageFile
argument_list|(
name|sd
argument_list|,
name|nnf
argument_list|,
name|txid
argument_list|)
decl_stmt|;
try|try
block|{
name|MD5FileUtils
operator|.
name|saveMD5File
argument_list|(
name|imageFile
argument_list|,
name|digest
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|badSds
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|badSds
argument_list|)
expr_stmt|;
name|CheckpointFaultInjector
operator|.
name|getInstance
argument_list|()
operator|.
name|afterMD5Rename
argument_list|()
expr_stmt|;
comment|// Rename image from tmp file
name|renameCheckpoint
argument_list|(
name|txid
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|,
name|nnf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// So long as this is the newest image available,
comment|// advertise it as such to other checkpointers
comment|// from now on
if|if
condition|(
name|txid
operator|>
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
condition|)
block|{
name|storage
operator|.
name|setMostRecentCheckpointInfo
argument_list|(
name|txid
argument_list|,
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|synchronized
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|editLog
operator|!=
literal|null
condition|)
block|{
comment|// 2NN doesn't have any edit log
name|getEditLog
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|storage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Retrieve checkpoint dirs from configuration.    *    * @param conf the Configuration    * @param defaultValue a default value for the attribute, if null    * @return a Collection of URIs representing the values in     * dfs.namenode.checkpoint.dir configuration property    */
DECL|method|getCheckpointDirs (Configuration conf, String defaultValue)
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getCheckpointDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_DIR_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirNames
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|defaultValue
operator|!=
literal|null
condition|)
block|{
name|dirNames
operator|.
name|add
argument_list|(
name|defaultValue
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
DECL|method|getCheckpointEditsDirs (Configuration conf, String defaultName)
specifier|static
name|List
argument_list|<
name|URI
argument_list|>
name|getCheckpointEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|defaultName
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_EDITS_DIR_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirNames
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|defaultName
operator|!=
literal|null
condition|)
block|{
name|dirNames
operator|.
name|add
argument_list|(
name|defaultName
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
DECL|method|getStorage ()
specifier|public
name|NNStorage
name|getStorage
parameter_list|()
block|{
return|return
name|storage
return|;
block|}
DECL|method|getLayoutVersion ()
specifier|public
name|int
name|getLayoutVersion
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getLayoutVersion
argument_list|()
return|;
block|}
DECL|method|getNamespaceID ()
specifier|public
name|int
name|getNamespaceID
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getNamespaceID
argument_list|()
return|;
block|}
DECL|method|getClusterID ()
specifier|public
name|String
name|getClusterID
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getClusterID
argument_list|()
return|;
block|}
DECL|method|getBlockPoolID ()
specifier|public
name|String
name|getBlockPoolID
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getBlockPoolID
argument_list|()
return|;
block|}
DECL|method|getLastAppliedTxId ()
specifier|public
specifier|synchronized
name|long
name|getLastAppliedTxId
parameter_list|()
block|{
return|return
name|lastAppliedTxId
return|;
block|}
DECL|method|getLastAppliedOrWrittenTxId ()
specifier|public
name|long
name|getLastAppliedOrWrittenTxId
parameter_list|()
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
name|lastAppliedTxId
argument_list|,
name|editLog
operator|!=
literal|null
condition|?
name|editLog
operator|.
name|getLastWrittenTxId
argument_list|()
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|updateLastAppliedTxIdFromWritten ()
specifier|public
name|void
name|updateLastAppliedTxIdFromWritten
parameter_list|()
block|{
name|this
operator|.
name|lastAppliedTxId
operator|=
name|editLog
operator|.
name|getLastWrittenTxId
argument_list|()
expr_stmt|;
block|}
comment|// Should be OK for this to not be synchronized since all of the places which
comment|// mutate this value are themselves synchronized so it shouldn't be possible
comment|// to see this flop back and forth. In the worst case this will just return an
comment|// old value.
DECL|method|getMostRecentCheckpointTxId ()
specifier|public
name|long
name|getMostRecentCheckpointTxId
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
return|;
block|}
block|}
end_class

end_unit

