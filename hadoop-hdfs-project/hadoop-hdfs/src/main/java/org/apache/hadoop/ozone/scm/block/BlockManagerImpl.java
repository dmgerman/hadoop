begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with this  * work for additional information regarding copyright ownership.  The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ozone.scm.block
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|scm
operator|.
name|block
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|protocol
operator|.
name|proto
operator|.
name|OzoneProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|protocol
operator|.
name|proto
operator|.
name|OzoneProtos
operator|.
name|Owner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|protocol
operator|.
name|proto
operator|.
name|OzoneProtos
operator|.
name|ReplicationFactor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|protocol
operator|.
name|proto
operator|.
name|OzoneProtos
operator|.
name|ReplicationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|scm
operator|.
name|container
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|scm
operator|.
name|node
operator|.
name|NodeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|web
operator|.
name|utils
operator|.
name|OzoneUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|scm
operator|.
name|ScmConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|AllocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|ContainerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|Pipeline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|utils
operator|.
name|BatchOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|utils
operator|.
name|MetadataStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|utils
operator|.
name|MetadataStoreBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConfigKeys
operator|.
name|OZONE_BLOCK_DELETING_SERVICE_INTERVAL_MS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConfigKeys
operator|.
name|OZONE_BLOCK_DELETING_SERVICE_INTERVAL_MS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConfigKeys
operator|.
name|OZONE_BLOCK_DELETING_SERVICE_TIMEOUT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConfigKeys
operator|.
name|OZONE_BLOCK_DELETING_SERVICE_TIMEOUT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
operator|.
name|BLOCK_DB
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
operator|.
name|ResultCodes
operator|.
name|CHILL_MODE_EXCEPTION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
operator|.
name|ResultCodes
operator|.
name|FAILED_TO_FIND_BLOCK
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|scm
operator|.
name|exceptions
operator|.
name|SCMException
operator|.
name|ResultCodes
operator|.
name|INVALID_BLOCK_SIZE
import|;
end_import

begin_comment
comment|/** Block Manager manages the block access for SCM. */
end_comment

begin_class
DECL|class|BlockManagerImpl
specifier|public
class|class
name|BlockManagerImpl
implements|implements
name|BlockManager
implements|,
name|BlockmanagerMXBean
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BlockManagerImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// TODO : FIX ME : Hard coding the owner.
comment|// Currently only user of the block service is Ozone, CBlock manages blocks
comment|// by itself and does not rely on the Block service offered by SCM.
DECL|field|owner
specifier|private
specifier|final
name|Owner
name|owner
init|=
name|Owner
operator|.
name|OZONE
decl_stmt|;
DECL|field|nodeManager
specifier|private
specifier|final
name|NodeManager
name|nodeManager
decl_stmt|;
DECL|field|containerManager
specifier|private
specifier|final
name|Mapping
name|containerManager
decl_stmt|;
DECL|field|blockStore
specifier|private
specifier|final
name|MetadataStore
name|blockStore
decl_stmt|;
DECL|field|lock
specifier|private
specifier|final
name|Lock
name|lock
decl_stmt|;
DECL|field|containerSize
specifier|private
specifier|final
name|long
name|containerSize
decl_stmt|;
DECL|field|cacheSize
specifier|private
specifier|final
name|long
name|cacheSize
decl_stmt|;
DECL|field|deletedBlockLog
specifier|private
specifier|final
name|DeletedBlockLog
name|deletedBlockLog
decl_stmt|;
DECL|field|blockDeletingService
specifier|private
specifier|final
name|SCMBlockDeletingService
name|blockDeletingService
decl_stmt|;
DECL|field|containerProvisionBatchSize
specifier|private
specifier|final
name|int
name|containerProvisionBatchSize
decl_stmt|;
DECL|field|rand
specifier|private
specifier|final
name|Random
name|rand
decl_stmt|;
DECL|field|mxBean
specifier|private
name|ObjectName
name|mxBean
decl_stmt|;
comment|/**    * Constructor.    *    * @param conf - configuration.    * @param nodeManager - node manager.    * @param containerManager - container manager.    * @param cacheSizeMB - cache size for level db store.    * @throws IOException    */
DECL|method|BlockManagerImpl (final Configuration conf, final NodeManager nodeManager, final Mapping containerManager, final int cacheSizeMB)
specifier|public
name|BlockManagerImpl
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|NodeManager
name|nodeManager
parameter_list|,
specifier|final
name|Mapping
name|containerManager
parameter_list|,
specifier|final
name|int
name|cacheSizeMB
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|nodeManager
operator|=
name|nodeManager
expr_stmt|;
name|this
operator|.
name|containerManager
operator|=
name|containerManager
expr_stmt|;
name|this
operator|.
name|cacheSize
operator|=
name|cacheSizeMB
expr_stmt|;
name|this
operator|.
name|containerSize
operator|=
name|OzoneConsts
operator|.
name|GB
operator|*
name|conf
operator|.
name|getInt
argument_list|(
name|ScmConfigKeys
operator|.
name|OZONE_SCM_CONTAINER_SIZE_GB
argument_list|,
name|ScmConfigKeys
operator|.
name|OZONE_SCM_CONTAINER_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|File
name|metaDir
init|=
name|OzoneUtils
operator|.
name|getScmMetadirPath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|scmMetaDataDir
init|=
name|metaDir
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// Write the block key to container name mapping.
name|File
name|blockContainerDbPath
init|=
operator|new
name|File
argument_list|(
name|scmMetaDataDir
argument_list|,
name|BLOCK_DB
argument_list|)
decl_stmt|;
name|blockStore
operator|=
name|MetadataStoreBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
operator|.
name|setDbFile
argument_list|(
name|blockContainerDbPath
argument_list|)
operator|.
name|setCacheSize
argument_list|(
name|this
operator|.
name|cacheSize
operator|*
name|OzoneConsts
operator|.
name|MB
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|this
operator|.
name|containerProvisionBatchSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|ScmConfigKeys
operator|.
name|OZONE_SCM_CONTAINER_PROVISION_BATCH_SIZE
argument_list|,
name|ScmConfigKeys
operator|.
name|OZONE_SCM_CONTAINER_PROVISION_BATCH_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
name|this
operator|.
name|lock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|mxBean
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"BlockManager"
argument_list|,
literal|"BlockManagerImpl"
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// SCM block deleting transaction log and deleting service.
name|deletedBlockLog
operator|=
operator|new
name|DeletedBlockLogImpl
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|int
name|svcInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|OZONE_BLOCK_DELETING_SERVICE_INTERVAL_MS
argument_list|,
name|OZONE_BLOCK_DELETING_SERVICE_INTERVAL_MS_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|serviceTimeout
init|=
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|OZONE_BLOCK_DELETING_SERVICE_TIMEOUT
argument_list|,
name|OZONE_BLOCK_DELETING_SERVICE_TIMEOUT_DEFAULT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|blockDeletingService
operator|=
operator|new
name|SCMBlockDeletingService
argument_list|(
name|deletedBlockLog
argument_list|,
name|containerManager
argument_list|,
name|nodeManager
argument_list|,
name|svcInterval
argument_list|,
name|serviceTimeout
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start block manager services.    *    * @throws IOException    */
DECL|method|start ()
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|blockDeletingService
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Shutdown block manager services.    *    * @throws IOException    */
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|blockDeletingService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Pre allocate specified count of containers for block creation.    *    * @param count - Number of containers to allocate.    * @param type - Type of containers    * @param factor - how many copies needed for this container.    * @throws IOException    */
DECL|method|preAllocateContainers (int count, ReplicationType type, ReplicationFactor factor)
specifier|private
name|void
name|preAllocateContainers
parameter_list|(
name|int
name|count
parameter_list|,
name|ReplicationType
name|type
parameter_list|,
name|ReplicationFactor
name|factor
parameter_list|)
throws|throws
name|IOException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|String
name|containerName
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|ContainerInfo
name|containerInfo
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// TODO: Fix this later when Ratis is made the Default.
name|containerInfo
operator|=
name|containerManager
operator|.
name|allocateContainer
argument_list|(
name|type
argument_list|,
name|factor
argument_list|,
name|containerName
argument_list|,
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|containerInfo
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to allocate container."
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to allocate container: {}"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Allocates a block in a container and returns that info.    *    * @param size - Block Size    * @param type Replication Type    * @param factor - Replication Factor    * @return Allocated block    * @throws IOException on failure.    */
annotation|@
name|Override
DECL|method|allocateBlock ( final long size, ReplicationType type, ReplicationFactor factor)
specifier|public
name|AllocatedBlock
name|allocateBlock
parameter_list|(
specifier|final
name|long
name|size
parameter_list|,
name|ReplicationType
name|type
parameter_list|,
name|ReplicationFactor
name|factor
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Size;{} , type : {}, factor : {} "
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|factor
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|<
literal|0
operator|||
name|size
argument_list|>
name|containerSize
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid block size requested : {}"
argument_list|,
name|size
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Unsupported block size: "
operator|+
name|size
argument_list|,
name|INVALID_BLOCK_SIZE
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|nodeManager
operator|.
name|isOutOfChillMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not out of Chill mode."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Unable to create block while in chill mode"
argument_list|,
name|CHILL_MODE_EXCEPTION
argument_list|)
throw|;
block|}
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|/*                Here is the high level logic.                 1. First we check if there are containers in ALLOCATED state,                that is                 SCM has allocated them in the SCM namespace but the                 corresponding                 container has not been created in the Datanode yet. If we                 have any                 in that state, we will return that to the client, which allows                 client to finish creating those containers. This is a sort of                  greedy                  algorithm, our primary purpose is to get as many containers as                  possible.                  2. If there are no allocated containers -- Then we find a Open                 container that matches that pattern.                  3. If both of them fail, the we will pre-allocate a bunch of                 conatainers in SCM and try again.                 TODO : Support random picking of two containers from the list.                 So we                can use different kind of policies.       */
name|ContainerInfo
name|containerInfo
decl_stmt|;
comment|// Look for ALLOCATED container that matches all other parameters.
name|containerInfo
operator|=
name|containerManager
operator|.
name|getStateManager
argument_list|()
operator|.
name|getMatchingContainer
argument_list|(
name|size
argument_list|,
name|owner
argument_list|,
name|type
argument_list|,
name|factor
argument_list|,
name|OzoneProtos
operator|.
name|LifeCycleState
operator|.
name|ALLOCATED
argument_list|)
expr_stmt|;
if|if
condition|(
name|containerInfo
operator|!=
literal|null
condition|)
block|{
name|containerManager
operator|.
name|updateContainerState
argument_list|(
name|containerInfo
operator|.
name|getContainerName
argument_list|()
argument_list|,
name|OzoneProtos
operator|.
name|LifeCycleEvent
operator|.
name|BEGIN_CREATE
argument_list|)
expr_stmt|;
return|return
name|newBlock
argument_list|(
name|containerInfo
argument_list|,
name|OzoneProtos
operator|.
name|LifeCycleState
operator|.
name|ALLOCATED
argument_list|)
return|;
block|}
comment|// Since we found no allocated containers that match our criteria, let us
comment|// look for OPEN containers that match the criteria.
name|containerInfo
operator|=
name|containerManager
operator|.
name|getStateManager
argument_list|()
operator|.
name|getMatchingContainer
argument_list|(
name|size
argument_list|,
name|owner
argument_list|,
name|type
argument_list|,
name|factor
argument_list|,
name|OzoneProtos
operator|.
name|LifeCycleState
operator|.
name|OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|containerInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|newBlock
argument_list|(
name|containerInfo
argument_list|,
name|OzoneProtos
operator|.
name|LifeCycleState
operator|.
name|OPEN
argument_list|)
return|;
block|}
comment|// We found neither ALLOCATED or OPEN Containers. This generally means
comment|// that most of our containers are full or we have not allocated
comment|// containers of the type and replication factor. So let us go and
comment|// allocate some.
name|preAllocateContainers
argument_list|(
name|containerProvisionBatchSize
argument_list|,
name|type
argument_list|,
name|factor
argument_list|)
expr_stmt|;
comment|// Since we just allocated a set of containers this should work
name|containerInfo
operator|=
name|containerManager
operator|.
name|getStateManager
argument_list|()
operator|.
name|getMatchingContainer
argument_list|(
name|size
argument_list|,
name|owner
argument_list|,
name|type
argument_list|,
name|factor
argument_list|,
name|OzoneProtos
operator|.
name|LifeCycleState
operator|.
name|ALLOCATED
argument_list|)
expr_stmt|;
if|if
condition|(
name|containerInfo
operator|!=
literal|null
condition|)
block|{
name|containerManager
operator|.
name|updateContainerState
argument_list|(
name|containerInfo
operator|.
name|getContainerName
argument_list|()
argument_list|,
name|OzoneProtos
operator|.
name|LifeCycleEvent
operator|.
name|BEGIN_CREATE
argument_list|)
expr_stmt|;
return|return
name|newBlock
argument_list|(
name|containerInfo
argument_list|,
name|OzoneProtos
operator|.
name|LifeCycleState
operator|.
name|ALLOCATED
argument_list|)
return|;
block|}
comment|// we have tried all strategies we know and but somehow we are not able
comment|// to get a container for this block. Log that info and return a null.
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to allocate a block for the size: {}, type: {}, "
operator|+
literal|"factor: {}"
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|factor
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * newBlock - returns a new block assigned to a container.    *    * @param containerInfo - Container Info.    * @param state - Current state of the container.    * @return AllocatedBlock    */
DECL|method|newBlock ( ContainerInfo containerInfo, OzoneProtos.LifeCycleState state)
specifier|private
name|AllocatedBlock
name|newBlock
parameter_list|(
name|ContainerInfo
name|containerInfo
parameter_list|,
name|OzoneProtos
operator|.
name|LifeCycleState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO : Replace this with Block ID.
name|String
name|blockKey
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|boolean
name|createContainer
init|=
operator|(
name|state
operator|==
name|OzoneProtos
operator|.
name|LifeCycleState
operator|.
name|ALLOCATED
operator|)
decl_stmt|;
name|AllocatedBlock
operator|.
name|Builder
name|abb
init|=
operator|new
name|AllocatedBlock
operator|.
name|Builder
argument_list|()
operator|.
name|setKey
argument_list|(
name|blockKey
argument_list|)
comment|// TODO : Use containerinfo instead of pipeline.
operator|.
name|setPipeline
argument_list|(
name|containerInfo
operator|.
name|getPipeline
argument_list|()
argument_list|)
operator|.
name|setShouldCreateContainer
argument_list|(
name|createContainer
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"New block allocated : {} Container ID: {}"
argument_list|,
name|blockKey
argument_list|,
name|containerInfo
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|containerInfo
operator|.
name|getPipeline
argument_list|()
operator|.
name|getMachines
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Pipeline Machine count is zero."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Persist this block info to the blockStore DB, so getBlock(key) can
comment|// find which container the block lives.
comment|// TODO : Remove this DB in future
comment|// and make this a KSM operation. Category: SCALABILITY.
if|if
condition|(
name|containerInfo
operator|.
name|getPipeline
argument_list|()
operator|.
name|getMachines
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|blockStore
operator|.
name|put
argument_list|(
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|blockKey
argument_list|)
argument_list|,
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|containerInfo
operator|.
name|getPipeline
argument_list|()
operator|.
name|getContainerName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|abb
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Given a block key, return the Pipeline information.    *    * @param key - block key assigned by SCM.    * @return Pipeline (list of DNs and leader) to access the block.    * @throws IOException    */
annotation|@
name|Override
DECL|method|getBlock (final String key)
specifier|public
name|Pipeline
name|getBlock
parameter_list|(
specifier|final
name|String
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|byte
index|[]
name|containerBytes
init|=
name|blockStore
operator|.
name|get
argument_list|(
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerBytes
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Specified block key does not exist. key : "
operator|+
name|key
argument_list|,
name|FAILED_TO_FIND_BLOCK
argument_list|)
throw|;
block|}
name|String
name|containerName
init|=
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|containerBytes
argument_list|)
decl_stmt|;
name|ContainerInfo
name|containerInfo
init|=
name|containerManager
operator|.
name|getContainer
argument_list|(
name|containerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerInfo
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Container {} allocated by block service"
operator|+
literal|"can't be found in SCM"
argument_list|,
name|containerName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Unable to find container for the block"
argument_list|,
name|SCMException
operator|.
name|ResultCodes
operator|.
name|FAILED_TO_FIND_CONTAINER
argument_list|)
throw|;
block|}
return|return
name|containerInfo
operator|.
name|getPipeline
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Deletes a list of blocks in an atomic operation. Internally, SCM writes    * these blocks into a    * {@link DeletedBlockLog} and deletes them from SCM DB. If this is    * successful, given blocks are    * entering pending deletion state and becomes invisible from SCM namespace.    *    * @param blockIDs block IDs. This is often the list of blocks of a    * particular object key.    * @throws IOException if exception happens, non of the blocks is deleted.    */
annotation|@
name|Override
DECL|method|deleteBlocks (List<String> blockIDs)
specifier|public
name|void
name|deleteBlocks
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|blockIDs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|nodeManager
operator|.
name|isOutOfChillMode
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Unable to delete block while in chill mode"
argument_list|,
name|CHILL_MODE_EXCEPTION
argument_list|)
throw|;
block|}
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting blocks {}"
argument_list|,
name|String
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|blockIDs
argument_list|)
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|containerBlocks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|BatchOperation
name|batch
init|=
operator|new
name|BatchOperation
argument_list|()
decl_stmt|;
name|BatchOperation
name|rollbackBatch
init|=
operator|new
name|BatchOperation
argument_list|()
decl_stmt|;
comment|// TODO: track the block size info so that we can reclaim the container
comment|// TODO: used space when the block is deleted.
try|try
block|{
for|for
control|(
name|String
name|blockKey
range|:
name|blockIDs
control|)
block|{
name|byte
index|[]
name|blockKeyBytes
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|blockKey
argument_list|)
decl_stmt|;
name|byte
index|[]
name|containerBytes
init|=
name|blockStore
operator|.
name|get
argument_list|(
name|blockKeyBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerBytes
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SCMException
argument_list|(
literal|"Specified block key does not exist. key : "
operator|+
name|blockKey
argument_list|,
name|FAILED_TO_FIND_BLOCK
argument_list|)
throw|;
block|}
name|batch
operator|.
name|delete
argument_list|(
name|blockKeyBytes
argument_list|)
expr_stmt|;
name|rollbackBatch
operator|.
name|put
argument_list|(
name|blockKeyBytes
argument_list|,
name|containerBytes
argument_list|)
expr_stmt|;
comment|// Merge blocks to a container to blocks mapping,
comment|// prepare to persist this info to the deletedBlocksLog.
name|String
name|containerName
init|=
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|containerBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerBlocks
operator|.
name|containsKey
argument_list|(
name|containerName
argument_list|)
condition|)
block|{
name|containerBlocks
operator|.
name|get
argument_list|(
name|containerName
argument_list|)
operator|.
name|add
argument_list|(
name|blockKey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|String
argument_list|>
name|item
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|item
operator|.
name|add
argument_list|(
name|blockKey
argument_list|)
expr_stmt|;
name|containerBlocks
operator|.
name|put
argument_list|(
name|containerName
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
block|}
comment|// We update SCM DB first, so if this step fails, we end up here,
comment|// nothing gets into the delLog so no blocks will be accidentally
comment|// removed. If we write the log first, once log is written, the
comment|// async deleting service will start to scan and might be picking
comment|// up some blocks to do real deletions, that might cause data loss.
name|blockStore
operator|.
name|writeBatch
argument_list|(
name|batch
argument_list|)
expr_stmt|;
try|try
block|{
name|deletedBlockLog
operator|.
name|addTransactions
argument_list|(
name|containerBlocks
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
comment|// If delLog update is failed, we need to rollback the changes.
name|blockStore
operator|.
name|writeBatch
argument_list|(
name|rollbackBatch
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|rollbackException
parameter_list|)
block|{
comment|// This is a corner case. AddTX fails and rollback also fails,
comment|// this will leave these blocks in inconsistent state. They were
comment|// moved to pending deletion state in SCM DB but were not written
comment|// into delLog so real deletions would not be done. Blocks become
comment|// to be invisible from namespace but actual data are not removed.
comment|// We log an error here so admin can manually check and fix such
comment|// errors.
name|LOG
operator|.
name|error
argument_list|(
literal|"Blocks might be in inconsistent state because"
operator|+
literal|" they were moved to pending deletion state in SCM DB but"
operator|+
literal|" not written into delLog. Admin can manually add them"
operator|+
literal|" into delLog for deletions. Inconsistent block list: {}"
argument_list|,
name|String
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|blockIDs
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|rollbackException
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Skip writing the deleted blocks info to"
operator|+
literal|" the delLog because addTransaction fails. Batch skipped: "
operator|+
name|String
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|blockIDs
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// TODO: Container report handling of the deleted blocks:
comment|// Remove tombstone and update open container usage.
comment|// We will revisit this when the closed container replication is done.
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getDeletedBlockLog ()
specifier|public
name|DeletedBlockLog
name|getDeletedBlockLog
parameter_list|()
block|{
return|return
name|this
operator|.
name|deletedBlockLog
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getDeletedKeyName (String key)
specifier|public
name|String
name|getDeletedKeyName
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|StringUtils
operator|.
name|format
argument_list|(
literal|".Deleted/%s"
argument_list|,
name|key
argument_list|)
return|;
block|}
comment|/**    * Close the resources for BlockManager.    *    * @throws IOException    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockStore
operator|!=
literal|null
condition|)
block|{
name|blockStore
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|deletedBlockLog
operator|!=
literal|null
condition|)
block|{
name|deletedBlockLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|blockDeletingService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|mxBean
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|mxBean
argument_list|)
expr_stmt|;
name|mxBean
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getOpenContainersNo ()
specifier|public
name|int
name|getOpenContainersNo
parameter_list|()
block|{
return|return
literal|0
return|;
comment|// TODO : FIX ME : The open container being a single number does not make
comment|// sense.
comment|// We have to get open containers by Replication Type and Replication
comment|// factor. Hence returning 0 for now.
comment|// containers.get(OzoneProtos.LifeCycleState.OPEN).size();
block|}
annotation|@
name|Override
DECL|method|getSCMBlockDeletingService ()
specifier|public
name|SCMBlockDeletingService
name|getSCMBlockDeletingService
parameter_list|()
block|{
return|return
name|this
operator|.
name|blockDeletingService
return|;
block|}
block|}
end_class

end_unit

