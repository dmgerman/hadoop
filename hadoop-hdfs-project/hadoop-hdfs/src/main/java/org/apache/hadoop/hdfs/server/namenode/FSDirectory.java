begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|Rename
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathIsNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DirectoryListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|MaxDirectoryItemsExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|PathComponentTooLongException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsLocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapUpdateInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeDirectory
operator|.
name|INodesInPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|INodeDirectorySnapshottable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|SnapshotAccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ReadOnlyList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/*************************************************  * FSDirectory stores the filesystem directory state.  * It handles writing/loading values to disk, and logging  * changes as we go.  *  * It keeps the filename->blockset mapping always-current  * and logged to disk.  *   *************************************************/
end_comment

begin_class
DECL|class|FSDirectory
specifier|public
class|class
name|FSDirectory
implements|implements
name|Closeable
block|{
DECL|method|createRoot (FSNamesystem namesystem)
specifier|private
specifier|static
name|INodeDirectoryWithQuota
name|createRoot
parameter_list|(
name|FSNamesystem
name|namesystem
parameter_list|)
block|{
specifier|final
name|INodeDirectoryWithQuota
name|r
init|=
operator|new
name|INodeDirectoryWithQuota
argument_list|(
name|namesystem
operator|.
name|allocateNewInodeId
argument_list|()
argument_list|,
name|INodeDirectory
operator|.
name|ROOT_NAME
argument_list|,
name|namesystem
operator|.
name|createFsOwnerPermissions
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|INodeDirectorySnapshottable
name|s
init|=
operator|new
name|INodeDirectorySnapshottable
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|s
operator|.
name|setSnapshotQuota
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
DECL|field|rootDir
name|INodeDirectoryWithQuota
name|rootDir
decl_stmt|;
DECL|field|fsImage
name|FSImage
name|fsImage
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|ready
specifier|private
specifier|volatile
name|boolean
name|ready
init|=
literal|false
decl_stmt|;
DECL|field|maxComponentLength
specifier|private
specifier|final
name|int
name|maxComponentLength
decl_stmt|;
DECL|field|maxDirItems
specifier|private
specifier|final
name|int
name|maxDirItems
decl_stmt|;
DECL|field|lsLimit
specifier|private
specifier|final
name|int
name|lsLimit
decl_stmt|;
comment|// max list limit
comment|// lock to protect the directory and BlockMap
DECL|field|dirLock
specifier|private
name|ReentrantReadWriteLock
name|dirLock
decl_stmt|;
DECL|field|cond
specifier|private
name|Condition
name|cond
decl_stmt|;
comment|// utility methods to acquire and release read lock and write lock
DECL|method|readLock ()
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|readUnlock ()
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeLock ()
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeUnlock ()
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|hasWriteLock ()
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|isWriteLockedByCurrentThread
argument_list|()
return|;
block|}
DECL|method|hasReadLock ()
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getReadHoldCount
argument_list|()
operator|>
literal|0
return|;
block|}
comment|/**    * Caches frequently used file names used in {@link INode} to reuse     * byte[] objects and reduce heap usage.    */
DECL|field|nameCache
specifier|private
specifier|final
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
name|nameCache
decl_stmt|;
DECL|method|FSDirectory (FSImage fsImage, FSNamesystem ns, Configuration conf)
name|FSDirectory
parameter_list|(
name|FSImage
name|fsImage
parameter_list|,
name|FSNamesystem
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|dirLock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// fair
name|this
operator|.
name|cond
operator|=
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|newCondition
argument_list|()
expr_stmt|;
name|rootDir
operator|=
name|createRoot
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsImage
operator|=
name|fsImage
expr_stmt|;
name|int
name|configuredLimit
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
argument_list|)
decl_stmt|;
name|this
operator|.
name|lsLimit
operator|=
name|configuredLimit
operator|>
literal|0
condition|?
name|configuredLimit
else|:
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
expr_stmt|;
comment|// filesystem limits
name|this
operator|.
name|maxComponentLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxDirItems
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_DEFAULT
argument_list|)
expr_stmt|;
name|int
name|threshold
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_DEFAULT
argument_list|)
decl_stmt|;
name|NameNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Caching file names occuring more than "
operator|+
name|threshold
operator|+
literal|" times"
argument_list|)
expr_stmt|;
name|nameCache
operator|=
operator|new
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|namesystem
operator|=
name|ns
expr_stmt|;
block|}
DECL|method|getFSNamesystem ()
specifier|private
name|FSNamesystem
name|getFSNamesystem
parameter_list|()
block|{
return|return
name|namesystem
return|;
block|}
DECL|method|getBlockManager ()
specifier|private
name|BlockManager
name|getBlockManager
parameter_list|()
block|{
return|return
name|getFSNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
return|;
block|}
comment|/**    * Notify that loading of this FSDirectory is complete, and    * it is ready for use     */
DECL|method|imageLoadComplete ()
name|void
name|imageLoadComplete
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|ready
argument_list|,
literal|"FSDirectory already loaded"
argument_list|)
expr_stmt|;
name|setReady
argument_list|()
expr_stmt|;
block|}
DECL|method|setReady ()
name|void
name|setReady
parameter_list|()
block|{
if|if
condition|(
name|ready
condition|)
return|return;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|setReady
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|nameCache
operator|.
name|initialized
argument_list|()
expr_stmt|;
name|cond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//This is for testing purposes only
annotation|@
name|VisibleForTesting
DECL|method|isReady ()
name|boolean
name|isReady
parameter_list|()
block|{
return|return
name|ready
return|;
block|}
comment|// exposed for unit tests
DECL|method|setReady (boolean flag)
specifier|protected
name|void
name|setReady
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|ready
operator|=
name|flag
expr_stmt|;
block|}
DECL|method|incrDeletedFileCount (int count)
specifier|private
name|void
name|incrDeletedFileCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|getFSNamesystem
argument_list|()
operator|!=
literal|null
condition|)
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|incrFilesDeleted
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
comment|/**    * Shutdown the filestore    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|fsImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Block until the object is ready to be used.    */
DECL|method|waitForReady ()
name|void
name|waitForReady
parameter_list|()
block|{
if|if
condition|(
operator|!
name|ready
condition|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|ready
condition|)
block|{
try|try
block|{
name|cond
operator|.
name|await
argument_list|(
literal|5000
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{           }
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Add the given filename to the fs.    * @throws FileAlreadyExistsException    * @throws QuotaExceededException    * @throws UnresolvedLinkException    * @throws SnapshotAccessControlException     */
DECL|method|addFile (String path, PermissionStatus permissions, short replication, long preferredBlockSize, String clientName, String clientMachine, DatanodeDescriptor clientNode, long generationStamp)
name|INodeFileUnderConstruction
name|addFile
parameter_list|(
name|String
name|path
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|DatanodeDescriptor
name|clientNode
parameter_list|,
name|long
name|generationStamp
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
comment|// Always do an implicit mkdirs for parent directory tree.
name|long
name|modTime
init|=
name|now
argument_list|()
decl_stmt|;
name|Path
name|parent
init|=
operator|new
name|Path
argument_list|(
name|path
argument_list|)
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|// Trying to add "/" as a file - this path has no
comment|// parent -- avoids an NPE below.
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|mkdirs
argument_list|(
name|parent
operator|.
name|toString
argument_list|()
argument_list|,
name|permissions
argument_list|,
literal|true
argument_list|,
name|modTime
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|long
name|id
init|=
name|namesystem
operator|.
name|allocateNewInodeId
argument_list|()
decl_stmt|;
name|INodeFileUnderConstruction
name|newNode
init|=
operator|new
name|INodeFileUnderConstruction
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|modTime
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
name|clientNode
argument_list|)
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|added
operator|=
name|addINode
argument_list|(
name|path
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* addFile: failed to add "
operator|+
name|path
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* addFile: "
operator|+
name|path
operator|+
literal|" is added"
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
block|}
DECL|method|unprotectedAddFile ( long id, String path, PermissionStatus permissions, short replication, long modificationTime, long atime, long preferredBlockSize, boolean underConstruction, String clientName, String clientMachine)
name|INode
name|unprotectedAddFile
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|path
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|modificationTime
parameter_list|,
name|long
name|atime
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|boolean
name|underConstruction
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|)
block|{
specifier|final
name|INode
name|newNode
decl_stmt|;
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|underConstruction
condition|)
block|{
name|newNode
operator|=
operator|new
name|INodeFileUnderConstruction
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|modificationTime
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNode
operator|=
operator|new
name|INodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|BlockInfo
operator|.
name|EMPTY_ARRAY
argument_list|,
name|replication
argument_list|,
name|modificationTime
argument_list|,
name|atime
argument_list|,
name|preferredBlockSize
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|addINode
argument_list|(
name|path
argument_list|,
name|newNode
argument_list|)
condition|)
block|{
return|return
name|newNode
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedAddFile: exception when add "
operator|+
name|path
operator|+
literal|" to the file system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Add a block to the file. Returns a reference to the added block.    */
DECL|method|addBlock (String path, INodesInPath inodesInPath, Block block, DatanodeDescriptor targets[])
name|BlockInfo
name|addBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|Block
name|block
parameter_list|,
name|DatanodeDescriptor
name|targets
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodeFileUnderConstruction
name|fileINode
init|=
name|INodeFileUnderConstruction
operator|.
name|valueOf
argument_list|(
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|// check quota limits and updated space consumed
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
literal|0
argument_list|,
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
operator|*
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// associate new last block for the file
name|BlockInfoUnderConstruction
name|blockInfo
init|=
operator|new
name|BlockInfoUnderConstruction
argument_list|(
name|block
argument_list|,
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|,
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|fileINode
argument_list|)
expr_stmt|;
name|fileINode
operator|.
name|addBlock
argument_list|(
name|blockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.addBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is added to the in-memory "
operator|+
literal|"file system"
argument_list|)
expr_stmt|;
block|}
return|return
name|blockInfo
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Persist the block list for the inode.    */
DECL|method|persistBlocks (String path, INodeFileUnderConstruction file)
name|void
name|persistBlocks
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|file
parameter_list|)
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logUpdateBlocks
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.persistBlocks: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|" blocks is persisted to the file system"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Close file.    */
DECL|method|closeFile (String path, INodeFile file)
name|void
name|closeFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|)
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// file is closed
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logCloseFile
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.closeFile: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|" blocks is persisted to the file system"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Remove a block from the file.    */
DECL|method|removeBlock (String path, INodeFileUnderConstruction fileNode, Block block)
name|void
name|removeBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedRemoveBlock
argument_list|(
name|path
argument_list|,
name|fileNode
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedRemoveBlock (String path, INodeFileUnderConstruction fileNode, Block block)
name|void
name|unprotectedRemoveBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
comment|// modify file-> block and blocksMap
name|fileNode
operator|.
name|removeLastBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|removeBlockFromMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.removeBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is removed from the file system"
argument_list|)
expr_stmt|;
block|}
comment|// update space consumed
specifier|final
name|INodesInPath
name|iip
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
operator|-
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
operator|*
name|fileNode
operator|.
name|getFileReplication
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * @throws SnapshotAccessControlException     * @see #unprotectedRenameTo(String, String, long)    * @deprecated Use {@link #renameTo(String, String, Rename...)} instead.    */
annotation|@
name|Deprecated
DECL|method|renameTo (String src, String dst)
name|boolean
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|FileAlreadyExistsException
throws|,
name|SnapshotAccessControlException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.renameTo: "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|waitForReady
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|unprotectedRenameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|now
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logRename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * @see #unprotectedRenameTo(String, String, long, Options.Rename...)    */
DECL|method|renameTo (String src, String dst, Options.Rename... options)
name|void
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.renameTo: "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|waitForReady
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|unprotectedRenameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|now
argument_list|,
name|options
argument_list|)
condition|)
block|{
name|incrDeletedFileCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logRename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|now
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
comment|/**    * Change a path name    *     * @param src source path    * @param dst destination path    * @return true if rename succeeds; false otherwise    * @throws QuotaExceededException if the operation violates any quota limit    * @throws FileAlreadyExistsException if the src is a symlink that points to dst    * @throws SnapshotAccessControlException if path is in RO snapshot    * @deprecated See {@link #renameTo(String, String)}    */
annotation|@
name|Deprecated
DECL|method|unprotectedRenameTo (String src, String dst, long timestamp)
name|boolean
name|unprotectedRenameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|FileAlreadyExistsException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|srcInodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|INode
index|[]
name|srcInodes
init|=
name|srcInodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
name|INode
name|srcInode
init|=
name|srcInodes
index|[
name|srcInodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
comment|// check the validation of the source
if|if
condition|(
name|srcInode
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because source does not exist"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|srcInodes
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because source is the root"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isDir
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|dst
operator|+=
name|Path
operator|.
name|SEPARATOR
operator|+
operator|new
name|Path
argument_list|(
name|src
argument_list|)
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
comment|// check the validity of the destination
if|if
condition|(
name|dst
operator|.
name|equals
argument_list|(
name|src
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|srcInode
operator|.
name|isSymlink
argument_list|()
operator|&&
name|dst
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|INodeSymlink
operator|)
name|srcInode
operator|)
operator|.
name|getSymlinkString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Cannot rename symlink "
operator|+
name|src
operator|+
literal|" to its target "
operator|+
name|dst
argument_list|)
throw|;
block|}
comment|// dst cannot be directory or a file under src
if|if
condition|(
name|dst
operator|.
name|startsWith
argument_list|(
name|src
argument_list|)
operator|&&
name|dst
operator|.
name|charAt
argument_list|(
name|src
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|Path
operator|.
name|SEPARATOR_CHAR
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because destination starts with src"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|byte
index|[]
index|[]
name|dstComponents
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|INodesInPath
name|dstInodesInPath
init|=
name|rootDir
operator|.
name|getExistingPathINodes
argument_list|(
name|dstComponents
argument_list|,
name|dstComponents
operator|.
name|length
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstInodesInPath
operator|.
name|isSnapshot
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SnapshotAccessControlException
argument_list|(
literal|"Modification on RO snapshot is disallowed"
argument_list|)
throw|;
block|}
name|INode
index|[]
name|dstInodes
init|=
name|dstInodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstInodes
index|[
name|dstInodes
operator|.
name|length
operator|-
literal|1
index|]
operator|!=
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because destination exists"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|dstInodes
index|[
name|dstInodes
operator|.
name|length
operator|-
literal|2
index|]
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because destination's parent does not exist"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Ensure dst has quota to accommodate rename
name|verifyQuotaForRename
argument_list|(
name|srcInodes
argument_list|,
name|dstInodes
argument_list|)
expr_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|INode
name|srcChild
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|srcChildName
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// remove src
name|srcChild
operator|=
name|removeLastINode
argument_list|(
name|srcInodesInPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcChild
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because the source can not be removed"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|srcChildName
operator|=
name|srcChild
operator|.
name|getLocalNameBytes
argument_list|()
expr_stmt|;
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|dstComponents
index|[
name|dstInodes
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// add src to the destination
name|added
operator|=
name|addLastINodeNoQuotaCheck
argument_list|(
name|dstInodesInPath
argument_list|,
name|srcChild
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
condition|)
block|{
name|srcChild
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|src
operator|+
literal|" is renamed to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
comment|// update modification time of dst and the parent of src
name|srcInodes
index|[
name|srcInodes
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|srcInodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
name|dstInodes
index|[
name|dstInodes
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|dstInodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
comment|// update moved leases with new filename
name|getFSNamesystem
argument_list|()
operator|.
name|unprotectedChangeLease
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|added
operator|&&
name|srcChild
operator|!=
literal|null
condition|)
block|{
comment|// put it back
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
name|addLastINodeNoQuotaCheck
argument_list|(
name|srcInodesInPath
argument_list|,
name|srcChild
argument_list|)
expr_stmt|;
block|}
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**    * Rename src to dst.    * See {@link DistributedFileSystem#rename(Path, Path, Options.Rename...)}    * for details related to rename semantics and exceptions.    *     * @param src source path    * @param dst destination path    * @param timestamp modification time    * @param options Rename options    */
DECL|method|unprotectedRenameTo (String src, String dst, long timestamp, Options.Rename... options)
name|boolean
name|unprotectedRenameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|boolean
name|overwrite
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|options
condition|)
block|{
for|for
control|(
name|Rename
name|option
range|:
name|options
control|)
block|{
if|if
condition|(
name|option
operator|==
name|Rename
operator|.
name|OVERWRITE
condition|)
block|{
name|overwrite
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|String
name|error
init|=
literal|null
decl_stmt|;
specifier|final
name|INodesInPath
name|srcInodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|srcInodes
init|=
name|srcInodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|srcInode
init|=
name|srcInodes
index|[
name|srcInodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
comment|// validate source
if|if
condition|(
name|srcInode
operator|==
literal|null
condition|)
block|{
name|error
operator|=
literal|"rename source "
operator|+
name|src
operator|+
literal|" is not found."
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcInodes
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|error
operator|=
literal|"rename source cannot be the root"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
comment|// validate the destination
if|if
condition|(
name|dst
operator|.
name|equals
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"The source "
operator|+
name|src
operator|+
literal|" and destination "
operator|+
name|dst
operator|+
literal|" are the same"
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcInode
operator|.
name|isSymlink
argument_list|()
operator|&&
name|dst
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|INodeSymlink
operator|)
name|srcInode
operator|)
operator|.
name|getSymlinkString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Cannot rename symlink "
operator|+
name|src
operator|+
literal|" to its target "
operator|+
name|dst
argument_list|)
throw|;
block|}
comment|// dst cannot be a directory or a file under src
if|if
condition|(
name|dst
operator|.
name|startsWith
argument_list|(
name|src
argument_list|)
operator|&&
name|dst
operator|.
name|charAt
argument_list|(
name|src
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|Path
operator|.
name|SEPARATOR_CHAR
condition|)
block|{
name|error
operator|=
literal|"Rename destination "
operator|+
name|dst
operator|+
literal|" is a directory or file under source "
operator|+
name|src
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
specifier|final
name|INodesInPath
name|dstInodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|dst
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|dstInodes
init|=
name|dstInodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
name|INode
name|dstInode
init|=
name|dstInodes
index|[
name|dstInodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|dstInodes
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|error
operator|=
literal|"rename destination cannot be the root"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstInode
operator|!=
literal|null
condition|)
block|{
comment|// Destination exists
comment|// It's OK to rename a file to a symlink and vice versa
if|if
condition|(
name|dstInode
operator|.
name|isDirectory
argument_list|()
operator|!=
name|srcInode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|error
operator|=
literal|"Source "
operator|+
name|src
operator|+
literal|" and destination "
operator|+
name|dst
operator|+
literal|" must both be directories"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
comment|// If destination exists, overwrite flag must be true
name|error
operator|=
literal|"rename destination "
operator|+
name|dst
operator|+
literal|" already exists"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
name|dstInode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
specifier|final
name|ReadOnlyList
argument_list|<
name|INode
argument_list|>
name|children
init|=
operator|(
operator|(
name|INodeDirectory
operator|)
name|dstInode
operator|)
operator|.
name|getChildrenList
argument_list|(
name|dstInodesInPath
operator|.
name|getPathSnapshot
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|error
operator|=
literal|"rename destination directory is not empty: "
operator|+
name|dst
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
block|}
name|INode
name|snapshotNode
init|=
name|hasSnapshot
argument_list|(
name|dstInode
argument_list|,
name|snapshottableDirs
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotNode
operator|!=
literal|null
condition|)
block|{
name|error
operator|=
literal|"The direcotry "
operator|+
name|dstInode
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" cannot be deleted for renaming since "
operator|+
name|snapshotNode
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" is snapshottable and already has snapshots"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|dstInodes
index|[
name|dstInodes
operator|.
name|length
operator|-
literal|2
index|]
operator|==
literal|null
condition|)
block|{
name|error
operator|=
literal|"rename destination parent "
operator|+
name|dst
operator|+
literal|" not found."
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|dstInodes
index|[
name|dstInodes
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|error
operator|=
literal|"rename destination parent "
operator|+
name|dst
operator|+
literal|" is a file."
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
name|error
argument_list|)
throw|;
block|}
comment|// Ensure dst has quota to accommodate rename
name|verifyQuotaForRename
argument_list|(
name|srcInodes
argument_list|,
name|dstInodes
argument_list|)
expr_stmt|;
name|INode
name|removedSrc
init|=
name|removeLastINode
argument_list|(
name|srcInodesInPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|removedSrc
operator|==
literal|null
condition|)
block|{
name|error
operator|=
literal|"Failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because the source can not be removed"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
specifier|final
name|byte
index|[]
name|srcChildName
init|=
name|removedSrc
operator|.
name|getLocalNameBytes
argument_list|()
decl_stmt|;
name|byte
index|[]
name|dstChildName
init|=
literal|null
decl_stmt|;
name|INode
name|removedDst
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|dstInode
operator|!=
literal|null
condition|)
block|{
comment|// dst exists remove it
name|removedDst
operator|=
name|removeLastINode
argument_list|(
name|dstInodesInPath
argument_list|)
expr_stmt|;
name|dstChildName
operator|=
name|removedDst
operator|.
name|getLocalNameBytes
argument_list|()
expr_stmt|;
block|}
name|removedSrc
operator|.
name|setLocalName
argument_list|(
name|dstInodesInPath
operator|.
name|getLastLocalName
argument_list|()
argument_list|)
expr_stmt|;
comment|// add src as dst to complete rename
if|if
condition|(
name|addLastINodeNoQuotaCheck
argument_list|(
name|dstInodesInPath
argument_list|,
name|removedSrc
argument_list|)
condition|)
block|{
name|removedSrc
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|src
operator|+
literal|" is renamed to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|srcInodes
index|[
name|srcInodes
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|srcInodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
name|dstInodes
index|[
name|dstInodes
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|dstInodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
comment|// update moved lease with new filename
name|getFSNamesystem
argument_list|()
operator|.
name|unprotectedChangeLease
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
comment|// Collect the blocks and remove the lease for previous dst
name|int
name|filesDeleted
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|removedDst
operator|!=
literal|null
condition|)
block|{
name|INode
name|rmdst
init|=
name|removedDst
decl_stmt|;
name|removedDst
operator|=
literal|null
expr_stmt|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|filesDeleted
operator|=
name|rmdst
operator|.
name|collectSubtreeBlocksAndClear
argument_list|(
name|collectedBlocks
argument_list|)
expr_stmt|;
name|getFSNamesystem
argument_list|()
operator|.
name|removePathAndBlocks
argument_list|(
name|src
argument_list|,
name|collectedBlocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snapshottableDirs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// There are snapshottable directories (without snapshots) to be
comment|// deleted. Need to update the SnapshotManager.
name|namesystem
operator|.
name|removeSnapshottableDirs
argument_list|(
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
return|return
name|filesDeleted
operator|>
literal|0
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|removedSrc
operator|!=
literal|null
condition|)
block|{
comment|// Rename failed - restore src
name|removedSrc
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
name|addLastINodeNoQuotaCheck
argument_list|(
name|srcInodesInPath
argument_list|,
name|removedSrc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removedDst
operator|!=
literal|null
condition|)
block|{
comment|// Rename failed - restore dst
name|removedDst
operator|.
name|setLocalName
argument_list|(
name|dstChildName
argument_list|)
expr_stmt|;
name|addLastINodeNoQuotaCheck
argument_list|(
name|dstInodesInPath
argument_list|,
name|removedDst
argument_list|)
expr_stmt|;
block|}
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rename from "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" failed."
argument_list|)
throw|;
block|}
comment|/**    * Set file replication    *     * @param src file name    * @param replication new replication    * @param oldReplication old replication - output parameter    * @return array of file blocks    * @throws QuotaExceededException    * @throws SnapshotAccessControlException     */
DECL|method|setReplication (String src, short replication, short[] oldReplication)
name|Block
index|[]
name|setReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|,
name|short
index|[]
name|oldReplication
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|Block
index|[]
name|fileBlocks
init|=
literal|null
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|fileBlocks
operator|=
name|unprotectedSetReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
name|oldReplication
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileBlocks
operator|!=
literal|null
condition|)
comment|// log replication change
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSetReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|)
expr_stmt|;
return|return
name|fileBlocks
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetReplication (String src, short replication, short[] oldReplication)
name|Block
index|[]
name|unprotectedSetReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|,
name|short
index|[]
name|oldReplication
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
name|INode
name|inode
init|=
name|inodes
index|[
name|inodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
operator|||
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|INodeFile
name|fileNode
init|=
operator|(
name|INodeFile
operator|)
name|inode
decl_stmt|;
specifier|final
name|short
name|oldRepl
init|=
name|fileNode
operator|.
name|getFileReplication
argument_list|()
decl_stmt|;
comment|// check disk quota
name|long
name|dsDelta
init|=
operator|(
name|replication
operator|-
name|oldRepl
operator|)
operator|*
operator|(
name|fileNode
operator|.
name|diskspaceConsumed
argument_list|()
operator|/
name|oldRepl
operator|)
decl_stmt|;
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
literal|0
argument_list|,
name|dsDelta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fileNode
operator|.
name|setFileReplication
argument_list|(
name|replication
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldReplication
operator|!=
literal|null
condition|)
block|{
name|oldReplication
index|[
literal|0
index|]
operator|=
name|oldRepl
expr_stmt|;
block|}
return|return
name|fileNode
operator|.
name|getBlocks
argument_list|()
return|;
block|}
comment|/**    * @param path the file path    * @return the block size of the file.     */
DECL|method|getPreferredBlockSize (String path)
name|long
name|getPreferredBlockSize
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|rootDir
operator|.
name|getNode
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
argument_list|,
name|path
argument_list|)
operator|.
name|getPreferredBlockSize
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|exists (String src)
name|boolean
name|exists
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|inode
init|=
name|rootDir
operator|.
name|getNode
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|!
name|inode
operator|.
name|isFile
argument_list|()
operator|||
operator|(
operator|(
name|INodeFile
operator|)
name|inode
operator|)
operator|.
name|getBlocks
argument_list|()
operator|!=
literal|null
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setPermission (String src, FsPermission permission)
name|void
name|setPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedSetPermission
argument_list|(
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSetPermissions
argument_list|(
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
DECL|method|unprotectedSetPermission (String src, FsPermission permissions)
name|void
name|unprotectedSetPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permissions
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
name|inode
operator|.
name|setPermission
argument_list|(
name|permissions
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setOwner (String src, String username, String groupname)
name|void
name|setOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedSetOwner
argument_list|(
name|src
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSetOwner
argument_list|(
name|src
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
block|}
DECL|method|unprotectedSetOwner (String src, String username, String groupname)
name|void
name|unprotectedSetOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|username
operator|!=
literal|null
condition|)
block|{
name|inode
operator|=
name|inode
operator|.
name|setUser
argument_list|(
name|username
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupname
operator|!=
literal|null
condition|)
block|{
name|inode
operator|.
name|setGroup
argument_list|(
name|groupname
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Concat all the blocks from srcs to trg and delete the srcs files    */
DECL|method|concat (String target, String [] srcs)
specifier|public
name|void
name|concat
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// actual move
name|waitForReady
argument_list|()
expr_stmt|;
name|long
name|timestamp
init|=
name|now
argument_list|()
decl_stmt|;
name|unprotectedConcat
argument_list|(
name|target
argument_list|,
name|srcs
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
comment|// do the commit
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logConcat
argument_list|(
name|target
argument_list|,
name|srcs
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Concat all the blocks from srcs to trg and delete the srcs files    * @param target target file to move the blocks to    * @param srcs list of file to move the blocks from    * Must be public because also called from EditLogs    * NOTE: - it does not update quota (not needed for concat)    */
DECL|method|unprotectedConcat (String target, String [] srcs, long timestamp)
specifier|public
name|void
name|unprotectedConcat
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSNamesystem.concat to "
operator|+
name|target
argument_list|)
expr_stmt|;
block|}
comment|// do the move
specifier|final
name|INodesInPath
name|trgINodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|trgINodes
init|=
name|trgINodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
name|INodeFile
name|trgInode
init|=
operator|(
name|INodeFile
operator|)
name|trgINodes
index|[
name|trgINodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|INodeDirectory
name|trgParent
init|=
operator|(
name|INodeDirectory
operator|)
name|trgINodes
index|[
name|trgINodes
operator|.
name|length
operator|-
literal|2
index|]
decl_stmt|;
specifier|final
name|Snapshot
name|trgLatestSnapshot
init|=
name|trgINodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
name|INodeFile
index|[]
name|allSrcInodes
init|=
operator|new
name|INodeFile
index|[
name|srcs
operator|.
name|length
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|totalBlocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|src
range|:
name|srcs
control|)
block|{
name|INodeFile
name|srcInode
init|=
operator|(
name|INodeFile
operator|)
name|getINode
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|allSrcInodes
index|[
name|i
operator|++
index|]
operator|=
name|srcInode
expr_stmt|;
name|totalBlocks
operator|+=
name|srcInode
operator|.
name|numBlocks
argument_list|()
expr_stmt|;
block|}
name|trgInode
operator|.
name|appendBlocks
argument_list|(
name|allSrcInodes
argument_list|,
name|totalBlocks
argument_list|)
expr_stmt|;
comment|// copy the blocks
comment|// since we are in the same dir - we can use same parent to remove files
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|INodeFile
name|nodeToRemove
range|:
name|allSrcInodes
control|)
block|{
if|if
condition|(
name|nodeToRemove
operator|==
literal|null
condition|)
continue|continue;
name|nodeToRemove
operator|.
name|setBlocks
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|trgParent
operator|.
name|removeChild
argument_list|(
name|nodeToRemove
argument_list|,
name|trgLatestSnapshot
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|trgInode
operator|.
name|setModificationTime
argument_list|(
name|timestamp
argument_list|,
name|trgLatestSnapshot
argument_list|)
expr_stmt|;
name|trgParent
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|trgLatestSnapshot
argument_list|)
expr_stmt|;
comment|// update quota on the parent directory ('count' files removed, 0 space)
name|unprotectedUpdateCount
argument_list|(
name|trgINodesInPath
argument_list|,
name|trgINodes
operator|.
name|length
operator|-
literal|1
argument_list|,
operator|-
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete the target directory and collect the blocks under it    *     * @param src Path of a directory to delete    * @param collectedBlocks Blocks under the deleted directory    * @return true on successful deletion; else false    */
DECL|method|delete (String src, BlocksMapUpdateInfo collectedBlocks)
name|boolean
name|delete
parameter_list|(
name|String
name|src
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.delete: "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
name|waitForReady
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
name|int
name|filesRemoved
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|checkPathINodes
argument_list|(
name|inodes
argument_list|,
name|src
argument_list|)
operator|==
literal|0
condition|)
block|{
name|filesRemoved
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Before removing the node, first check if the targetNode is for a
comment|// snapshottable dir with snapshots, or its descendants have
comment|// snapshottable dir with snapshots
name|INode
name|targetNode
init|=
name|inodes
index|[
name|inodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|List
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
argument_list|()
decl_stmt|;
name|INode
name|snapshotNode
init|=
name|hasSnapshot
argument_list|(
name|targetNode
argument_list|,
name|snapshottableDirs
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotNode
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The direcotry "
operator|+
name|targetNode
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" cannot be deleted since "
operator|+
name|snapshotNode
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" is snapshottable and already has snapshots"
argument_list|)
throw|;
block|}
name|filesRemoved
operator|=
name|unprotectedDelete
argument_list|(
name|inodesInPath
argument_list|,
name|collectedBlocks
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapshottableDirs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// There are some snapshottable directories without snapshots to be
comment|// deleted. Need to update the SnapshotManager.
name|namesystem
operator|.
name|removeSnapshottableDirs
argument_list|(
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logDelete
argument_list|(
name|src
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesRemoved
operator|<=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|incrDeletedFileCount
argument_list|(
name|filesRemoved
argument_list|)
expr_stmt|;
comment|// Blocks will be deleted later by the caller of this method
name|getFSNamesystem
argument_list|()
operator|.
name|removePathAndBlocks
argument_list|(
name|src
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|checkPathINodes (INode[] inodes, String src)
specifier|private
name|int
name|checkPathINodes
parameter_list|(
name|INode
index|[]
name|inodes
parameter_list|,
name|String
name|src
parameter_list|)
block|{
if|if
condition|(
name|inodes
operator|==
literal|null
operator|||
name|inodes
operator|.
name|length
operator|==
literal|0
operator|||
name|inodes
index|[
name|inodes
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
literal|"failed to remove "
operator|+
name|src
operator|+
literal|" because it does not exist"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|inodes
operator|.
name|length
operator|==
literal|1
condition|)
block|{
comment|// src is the root
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
literal|"failed to remove "
operator|+
name|src
operator|+
literal|" because the root is not allowed to be deleted"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|inodes
operator|.
name|length
return|;
block|}
comment|/**    * @return true if the path is a non-empty directory; otherwise, return false.    */
DECL|method|isNonEmptyDirectory (String path)
name|boolean
name|isNonEmptyDirectory
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getLastINodeInPath
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
operator|||
operator|!
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//not found or not a directory
return|return
literal|false
return|;
block|}
specifier|final
name|Snapshot
name|s
init|=
name|inodesInPath
operator|.
name|getPathSnapshot
argument_list|()
decl_stmt|;
return|return
operator|!
operator|(
operator|(
name|INodeDirectory
operator|)
name|inode
operator|)
operator|.
name|getChildrenList
argument_list|(
name|s
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Delete a path from the name space    * Update the count at each ancestor directory with quota    *<br>    * Note: This is to be used by {@link FSEditLog} only.    *<br>    * @param src a string representation of a path to an inode    * @param mtime the time the inode is removed    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|unprotectedDelete (String src, long mtime)
name|void
name|unprotectedDelete
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|int
name|filesRemoved
init|=
literal|0
decl_stmt|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|checkPathINodes
argument_list|(
name|inodes
argument_list|,
name|src
argument_list|)
operator|==
literal|0
condition|)
block|{
name|filesRemoved
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|filesRemoved
operator|=
name|unprotectedDelete
argument_list|(
name|inodesInPath
argument_list|,
name|collectedBlocks
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filesRemoved
operator|>
literal|0
condition|)
block|{
name|getFSNamesystem
argument_list|()
operator|.
name|removePathAndBlocks
argument_list|(
name|src
argument_list|,
name|collectedBlocks
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a path from the name space    * Update the count at each ancestor directory with quota    * @param inodes the INode array resolved from the path    * @param collectedBlocks blocks collected from the deleted path    * @param mtime the time the inode is removed    * @return the number of inodes deleted; 0 if no inodes are deleted.    */
DECL|method|unprotectedDelete (INodesInPath inodesInPath, BlocksMapUpdateInfo collectedBlocks, long mtime)
name|int
name|unprotectedDelete
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|long
name|mtime
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// Remove the node from the namespace
specifier|final
name|INode
name|targetNode
init|=
name|removeLastINode
argument_list|(
name|inodesInPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// set the parent's modification time
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|Snapshot
name|latestSnapshot
init|=
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
specifier|final
name|INodeDirectory
name|parent
init|=
operator|(
name|INodeDirectory
operator|)
name|inodes
index|[
name|inodes
operator|.
name|length
operator|-
literal|2
index|]
decl_stmt|;
name|parent
operator|.
name|updateModificationTime
argument_list|(
name|mtime
argument_list|,
name|latestSnapshot
argument_list|)
expr_stmt|;
specifier|final
name|INode
name|snapshotCopy
init|=
name|parent
operator|.
name|getChild
argument_list|(
name|targetNode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|latestSnapshot
argument_list|)
decl_stmt|;
comment|// if snapshotCopy == targetNode, it means that the file is also stored in
comment|// a snapshot so that the block should not be removed.
specifier|final
name|int
name|filesRemoved
init|=
name|snapshotCopy
operator|==
name|targetNode
condition|?
literal|0
else|:
name|targetNode
operator|.
name|collectSubtreeBlocksAndClear
argument_list|(
name|collectedBlocks
argument_list|)
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
name|targetNode
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" is removed"
argument_list|)
expr_stmt|;
block|}
return|return
name|filesRemoved
return|;
block|}
comment|/**    * Check if the given INode (or one of its descendants) is snapshottable and    * already has snapshots.    *     * @param target    *          The given INode    * @param snapshottableDirs    *          The list of directories that are snapshottable but do not have    *          snapshots yet    * @return The INode which is snapshottable and already has snapshots.    */
DECL|method|hasSnapshot (INode target, List<INodeDirectorySnapshottable> snapshottableDirs)
specifier|private
specifier|static
name|INode
name|hasSnapshot
parameter_list|(
name|INode
name|target
parameter_list|,
name|List
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
name|snapshottableDirs
parameter_list|)
block|{
if|if
condition|(
name|target
operator|instanceof
name|INodeDirectory
condition|)
block|{
name|INodeDirectory
name|targetDir
init|=
operator|(
name|INodeDirectory
operator|)
name|target
decl_stmt|;
if|if
condition|(
name|targetDir
operator|.
name|isSnapshottable
argument_list|()
condition|)
block|{
name|INodeDirectorySnapshottable
name|ssTargetDir
init|=
operator|(
name|INodeDirectorySnapshottable
operator|)
name|targetDir
decl_stmt|;
if|if
condition|(
name|ssTargetDir
operator|.
name|getNumSnapshots
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|target
return|;
block|}
else|else
block|{
name|snapshottableDirs
operator|.
name|add
argument_list|(
name|ssTargetDir
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|INode
name|child
range|:
name|targetDir
operator|.
name|getChildrenList
argument_list|(
literal|null
argument_list|)
control|)
block|{
name|INode
name|snapshotDir
init|=
name|hasSnapshot
argument_list|(
name|child
argument_list|,
name|snapshottableDirs
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotDir
operator|!=
literal|null
condition|)
block|{
return|return
name|snapshotDir
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Replaces the specified INodeFile with the specified one.    */
DECL|method|replaceINodeFile (String path, INodeFile oldnode, INodeFile newnode, Snapshot latest)
specifier|public
name|void
name|replaceINodeFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|oldnode
parameter_list|,
name|INodeFile
name|newnode
parameter_list|,
name|Snapshot
name|latest
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedReplaceINodeFile
argument_list|(
name|path
argument_list|,
name|oldnode
argument_list|,
name|newnode
argument_list|,
name|latest
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedReplaceINodeFile (final String path, final INodeFile oldnode, final INodeFile newnode, final Snapshot latest)
name|void
name|unprotectedReplaceINodeFile
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|INodeFile
name|oldnode
parameter_list|,
specifier|final
name|INodeFile
name|newnode
parameter_list|,
specifier|final
name|Snapshot
name|latest
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|hasWriteLock
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|INodeDirectory
name|parent
init|=
name|oldnode
operator|.
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|removed
init|=
name|parent
operator|.
name|removeChild
argument_list|(
name|oldnode
argument_list|,
name|latest
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|removed
operator|==
name|oldnode
argument_list|,
literal|"removed != oldnode=%s, removed=%s"
argument_list|,
name|oldnode
argument_list|,
name|removed
argument_list|)
expr_stmt|;
name|oldnode
operator|.
name|setParent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|parent
operator|.
name|addChild
argument_list|(
name|newnode
argument_list|,
literal|true
argument_list|,
name|latest
argument_list|)
expr_stmt|;
comment|/* Currently oldnode and newnode are assumed to contain the same      * blocks. Otherwise, blocks need to be removed from the blocksMap.      */
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockInfo
name|b
range|:
name|newnode
operator|.
name|getBlocks
argument_list|()
control|)
block|{
name|BlockInfo
name|info
init|=
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|b
argument_list|,
name|newnode
argument_list|)
decl_stmt|;
name|newnode
operator|.
name|setBlock
argument_list|(
name|index
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|// inode refers to the block in BlocksMap
name|index
operator|++
expr_stmt|;
block|}
block|}
comment|/**    * Get a partial listing of the indicated directory    *    * @param src the directory name    * @param startAfter the name to start listing after    * @param needLocation if block locations are returned    * @return a partial listing starting after startAfter    */
DECL|method|getListing (String src, byte[] startAfter, boolean needLocation)
name|DirectoryListing
name|getListing
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getLastINodeInPath
argument_list|(
name|srcs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|Snapshot
name|snapshot
init|=
name|inodesInPath
operator|.
name|getPathSnapshot
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|targetNode
init|=
name|inodesInPath
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
name|targetNode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
return|return
operator|new
name|DirectoryListing
argument_list|(
operator|new
name|HdfsFileStatus
index|[]
block|{
name|createFileStatus
argument_list|(
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|,
name|targetNode
argument_list|,
name|needLocation
argument_list|,
name|snapshot
argument_list|)
block|}
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|INodeDirectory
name|dirInode
init|=
operator|(
name|INodeDirectory
operator|)
name|targetNode
decl_stmt|;
specifier|final
name|ReadOnlyList
argument_list|<
name|INode
argument_list|>
name|contents
init|=
name|dirInode
operator|.
name|getChildrenList
argument_list|(
name|inodesInPath
operator|.
name|getPathSnapshot
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|startChild
init|=
name|INodeDirectory
operator|.
name|nextChild
argument_list|(
name|contents
argument_list|,
name|startAfter
argument_list|)
decl_stmt|;
name|int
name|totalNumChildren
init|=
name|contents
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numOfListing
init|=
name|Math
operator|.
name|min
argument_list|(
name|totalNumChildren
operator|-
name|startChild
argument_list|,
name|this
operator|.
name|lsLimit
argument_list|)
decl_stmt|;
name|HdfsFileStatus
name|listing
index|[]
init|=
operator|new
name|HdfsFileStatus
index|[
name|numOfListing
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfListing
condition|;
name|i
operator|++
control|)
block|{
name|INode
name|cur
init|=
name|contents
operator|.
name|get
argument_list|(
name|startChild
operator|+
name|i
argument_list|)
decl_stmt|;
name|listing
index|[
name|i
index|]
operator|=
name|createFileStatus
argument_list|(
name|cur
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|cur
argument_list|,
name|needLocation
argument_list|,
name|snapshot
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DirectoryListing
argument_list|(
name|listing
argument_list|,
name|totalNumChildren
operator|-
name|startChild
operator|-
name|numOfListing
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Get the file info for a specific file.    * @param src The string representation of the path to the file    * @param resolveLink whether to throw UnresolvedLinkException     * @return object containing information regarding the file    *         or null if file not found    */
DECL|method|getFileInfo (String src, boolean resolveLink)
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getLastINodeInPath
argument_list|(
name|srcs
argument_list|,
name|resolveLink
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|i
init|=
name|inodesInPath
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|i
operator|==
literal|null
condition|?
literal|null
else|:
name|createFileStatus
argument_list|(
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|,
name|i
argument_list|,
name|inodesInPath
operator|.
name|getPathSnapshot
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the blocks associated with the file.    */
DECL|method|getFileBlocks (String src)
name|Block
index|[]
name|getFileBlocks
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INode
name|i
init|=
name|rootDir
operator|.
name|getNode
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|i
operator|!=
literal|null
operator|&&
name|i
operator|.
name|isFile
argument_list|()
condition|?
operator|(
operator|(
name|INodeFile
operator|)
name|i
operator|)
operator|.
name|getBlocks
argument_list|()
else|:
literal|null
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getINode (String src)
specifier|public
name|INode
name|getINode
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|getLastINodeInPath
argument_list|(
name|src
argument_list|)
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getLastINodeInPath (String src)
specifier|public
name|INodesInPath
name|getLastINodeInPath
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|getLastINodeInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getINodesInPath4Write (String src )
specifier|public
name|INodesInPath
name|getINodesInPath4Write
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|getINode4Write (String src)
specifier|public
name|INode
name|getINode4Write
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|getINode4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**     * Check whether the filepath could be created    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|isValidToCreate (String src)
name|boolean
name|isValidToCreate
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|srcs
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
operator|!
name|srcs
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|rootDir
operator|.
name|getINode4Write
argument_list|(
name|srcs
argument_list|,
literal|false
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check whether the path specifies a directory    */
DECL|method|isDir (String src)
name|boolean
name|isDir
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|node
init|=
name|rootDir
operator|.
name|getNode
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check whether the path specifies a directory    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|isDirMutable (String src)
name|boolean
name|isDirMutable
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|node
init|=
name|rootDir
operator|.
name|getINode4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Updates namespace and diskspace consumed for all    * directories until the parent directory of file represented by path.    *     * @param path path for the file.    * @param nsDelta the delta change of namespace    * @param dsDelta the delta change of diskspace    * @throws QuotaExceededException if the new count violates any quota limit    * @throws FileNotFoundException if path does not exist.    */
DECL|method|updateSpaceConsumed (String path, long nsDelta, long dsDelta)
name|void
name|updateSpaceConsumed
parameter_list|(
name|String
name|path
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|iip
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|iip
operator|.
name|getLastINode
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Path not found: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|updateCount
argument_list|(
name|iip
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateCount (INodesInPath iip, long nsDelta, long dsDelta, boolean checkQuota)
specifier|private
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|updateCount
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|-
literal|1
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
block|}
comment|/** update count of each inode with quota    *     * @param inodes an array of inodes on a path    * @param numOfINodes the number of inodes to update starting from index 0    * @param nsDelta the delta change of namespace    * @param dsDelta the delta change of diskspace    * @param checkQuota if true then check if quota is exceeded    * @throws QuotaExceededException if the new count violates any quota limit    */
DECL|method|updateCount (INodesInPath inodesInPath, int numOfINodes, long nsDelta, long dsDelta, boolean checkQuota)
specifier|private
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
operator|!
name|ready
condition|)
block|{
comment|//still initializing. do not check or update quotas.
return|return;
block|}
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|numOfINodes
operator|>
name|inodes
operator|.
name|length
condition|)
block|{
name|numOfINodes
operator|=
name|inodes
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|checkQuota
condition|)
block|{
name|verifyQuota
argument_list|(
name|inodes
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|unprotectedUpdateCount
argument_list|(
name|inodesInPath
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
comment|/**     * update quota of each inode and check to see if quota is exceeded.     * See {@link #updateCount(INode[], int, long, long, boolean)}    */
DECL|method|updateCountNoQuotaCheck (INodesInPath inodesInPath, int numOfINodes, long nsDelta, long dsDelta)
specifier|private
name|void
name|updateCountNoQuotaCheck
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
try|try
block|{
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"FSDirectory.updateCountNoQuotaCheck - unexpected "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * updates quota without verification    * callers responsibility is to make sure quota is not exceeded    * @param inodes    * @param numOfINodes    * @param nsDelta    * @param dsDelta    */
DECL|method|unprotectedUpdateCount (INodesInPath inodesInPath, int numOfINodes, long nsDelta, long dsDelta)
specifier|private
name|void
name|unprotectedUpdateCount
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfINodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inodes
index|[
name|i
index|]
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
comment|// a directory with quota
name|INodeDirectoryWithQuota
name|node
init|=
operator|(
name|INodeDirectoryWithQuota
operator|)
name|inodes
index|[
name|i
index|]
decl_stmt|;
name|node
operator|.
name|addSpaceConsumed
argument_list|(
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Return the name of the path represented by inodes at [0, pos] */
DECL|method|getFullPathName (INode[] inodes, int pos)
specifier|private
specifier|static
name|String
name|getFullPathName
parameter_list|(
name|INode
index|[]
name|inodes
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|StringBuilder
name|fullPathName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|inodes
index|[
literal|0
index|]
operator|.
name|isRoot
argument_list|()
condition|)
block|{
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
else|else
block|{
name|fullPathName
operator|.
name|append
argument_list|(
name|inodes
index|[
literal|0
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|pos
condition|;
name|i
operator|++
control|)
block|{
name|fullPathName
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR_CHAR
argument_list|)
operator|.
name|append
argument_list|(
name|inodes
index|[
name|i
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|fullPathName
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Return the full path name of the specified inode */
DECL|method|getFullPathName (INode inode)
specifier|static
name|String
name|getFullPathName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
comment|// calculate the depth of this inode from root
name|int
name|depth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|INode
name|i
init|=
name|inode
init|;
name|i
operator|!=
literal|null
condition|;
name|i
operator|=
name|i
operator|.
name|parent
control|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
name|INode
index|[]
name|inodes
init|=
operator|new
name|INode
index|[
name|depth
index|]
decl_stmt|;
comment|// fill up the inodes in the path from this inode to root
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|inodes
index|[
name|depth
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|inode
expr_stmt|;
name|inode
operator|=
name|inode
operator|.
name|parent
expr_stmt|;
block|}
return|return
name|getFullPathName
argument_list|(
name|inodes
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Create a directory     * If ancestor directories do not exist, automatically create them.     * @param src string representation of the path to the directory    * @param permissions the permission of the directory    * @param isAutocreate if the permission of the directory should inherit    *                          from its parent or not. u+wx is implicitly added to    *                          the automatically created directories, and to the    *                          given directory if inheritPermission is true    * @param now creation time    * @return true if the operation succeeds false otherwise    * @throws FileNotFoundException if an ancestor or itself is a file    * @throws QuotaExceededException if directory creation violates     *                                any quota limit    * @throws UnresolvedLinkException if a symlink is encountered in src.                          * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|mkdirs (String src, PermissionStatus permissions, boolean inheritPermission, long now)
name|boolean
name|mkdirs
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|boolean
name|inheritPermission
parameter_list|,
name|long
name|now
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|String
index|[]
name|names
init|=
name|INode
operator|.
name|getPathNames
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|names
argument_list|)
decl_stmt|;
specifier|final
name|int
name|lastInodeIndex
init|=
name|components
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getExistingPathINodes
argument_list|(
name|components
argument_list|,
name|components
operator|.
name|length
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|inodesInPath
operator|.
name|isSnapshot
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SnapshotAccessControlException
argument_list|(
literal|"Modification on RO snapshot is disallowed"
argument_list|)
throw|;
block|}
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
comment|// find the index of the first null in inodes[]
name|StringBuilder
name|pathbuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|inodes
operator|.
name|length
operator|&&
name|inodes
index|[
name|i
index|]
operator|!=
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|pathbuilder
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inodes
index|[
name|i
index|]
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Parent path is not a directory: "
operator|+
name|pathbuilder
operator|+
literal|" "
operator|+
name|inodes
index|[
name|i
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// default to creating parent dirs with the given perms
name|PermissionStatus
name|parentPermissions
init|=
name|permissions
decl_stmt|;
comment|// if not inheriting and it's the last inode, there's no use in
comment|// computing perms that won't be used
if|if
condition|(
name|inheritPermission
operator|||
operator|(
name|i
operator|<
name|lastInodeIndex
operator|)
condition|)
block|{
comment|// if inheriting (ie. creating a file or symlink), use the parent dir,
comment|// else the supplied permissions
comment|// NOTE: the permissions of the auto-created directories violate posix
name|FsPermission
name|parentFsPerm
init|=
name|inheritPermission
condition|?
name|inodes
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|getFsPermission
argument_list|()
else|:
name|permissions
operator|.
name|getPermission
argument_list|()
decl_stmt|;
comment|// ensure that the permissions allow user write+execute
if|if
condition|(
operator|!
name|parentFsPerm
operator|.
name|getUserAction
argument_list|()
operator|.
name|implies
argument_list|(
name|FsAction
operator|.
name|WRITE_EXECUTE
argument_list|)
condition|)
block|{
name|parentFsPerm
operator|=
operator|new
name|FsPermission
argument_list|(
name|parentFsPerm
operator|.
name|getUserAction
argument_list|()
operator|.
name|or
argument_list|(
name|FsAction
operator|.
name|WRITE_EXECUTE
argument_list|)
argument_list|,
name|parentFsPerm
operator|.
name|getGroupAction
argument_list|()
argument_list|,
name|parentFsPerm
operator|.
name|getOtherAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parentPermissions
operator|.
name|getPermission
argument_list|()
operator|.
name|equals
argument_list|(
name|parentFsPerm
argument_list|)
condition|)
block|{
name|parentPermissions
operator|=
operator|new
name|PermissionStatus
argument_list|(
name|parentPermissions
operator|.
name|getUserName
argument_list|()
argument_list|,
name|parentPermissions
operator|.
name|getGroupName
argument_list|()
argument_list|,
name|parentFsPerm
argument_list|)
expr_stmt|;
comment|// when inheriting, use same perms for entire path
if|if
condition|(
name|inheritPermission
condition|)
name|permissions
operator|=
name|parentPermissions
expr_stmt|;
block|}
block|}
comment|// create directories beginning from the first null index
for|for
control|(
init|;
name|i
operator|<
name|inodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pathbuilder
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
operator|+
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|unprotectedMkdir
argument_list|(
name|namesystem
operator|.
name|allocateNewInodeId
argument_list|()
argument_list|,
name|inodesInPath
argument_list|,
name|i
argument_list|,
name|components
index|[
name|i
index|]
argument_list|,
operator|(
name|i
operator|<
name|lastInodeIndex
operator|)
condition|?
name|parentPermissions
else|:
name|permissions
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodes
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Directory creation also count towards FilesCreated
comment|// to match count of FilesDeleted metric.
if|if
condition|(
name|getFSNamesystem
argument_list|()
operator|!=
literal|null
condition|)
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|incrFilesCreated
argument_list|()
expr_stmt|;
specifier|final
name|String
name|cur
init|=
name|pathbuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logMkDir
argument_list|(
name|cur
argument_list|,
name|inodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.mkdirs: created directory "
operator|+
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|unprotectedMkdir (long inodeId, String src, PermissionStatus permissions, long timestamp)
name|INode
name|unprotectedMkdir
parameter_list|(
name|long
name|inodeId
parameter_list|,
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getExistingPathINodes
argument_list|(
name|components
argument_list|,
name|components
operator|.
name|length
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pos
init|=
name|inodes
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|unprotectedMkdir
argument_list|(
name|inodeId
argument_list|,
name|inodesInPath
argument_list|,
name|pos
argument_list|,
name|components
index|[
name|pos
index|]
argument_list|,
name|permissions
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
return|return
name|inodes
index|[
name|pos
index|]
return|;
block|}
comment|/** create a directory at index pos.    * The parent path to the directory is at [0, pos-1].    * All ancestors exist. Newly created one stored at index pos.    */
DECL|method|unprotectedMkdir (long inodeId, INodesInPath inodesInPath, int pos, byte[] name, PermissionStatus permission, long timestamp)
specifier|private
name|void
name|unprotectedMkdir
parameter_list|(
name|long
name|inodeId
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|pos
parameter_list|,
name|byte
index|[]
name|name
parameter_list|,
name|PermissionStatus
name|permission
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeDirectory
name|dir
init|=
operator|new
name|INodeDirectory
argument_list|(
name|inodeId
argument_list|,
name|name
argument_list|,
name|permission
argument_list|,
name|timestamp
argument_list|)
decl_stmt|;
if|if
condition|(
name|addChild
argument_list|(
name|inodesInPath
argument_list|,
name|pos
argument_list|,
name|dir
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|inodesInPath
operator|.
name|setINode
argument_list|(
name|pos
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add the given child to the namespace.    * @param src The full path name of the child node.    * @throw QuotaExceededException is thrown if it violates quota limit    */
DECL|method|addINode (String src, INode child )
specifier|private
name|boolean
name|addINode
parameter_list|(
name|String
name|src
parameter_list|,
name|INode
name|child
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
block|{
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|child
operator|.
name|setLocalName
argument_list|(
name|components
index|[
name|components
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|cacheName
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getExistingPathINodes
argument_list|(
name|components
argument_list|,
name|components
operator|.
name|length
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|addLastINode
argument_list|(
name|inodesInPath
argument_list|,
name|child
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Verify quota for adding or moving a new INode with required     * namespace and diskspace to a given position.    *      * @param inodes INodes corresponding to a path    * @param pos position where a new INode will be added    * @param nsDelta needed namespace    * @param dsDelta needed diskspace    * @param commonAncestor Last node in inodes array that is a common ancestor    *          for a INode that is being moved from one location to the other.    *          Pass null if a node is not being moved.    * @throws QuotaExceededException if quota limit is exceeded.    */
DECL|method|verifyQuota (INode[] inodes, int pos, long nsDelta, long dsDelta, INode commonAncestor)
specifier|private
name|void
name|verifyQuota
parameter_list|(
name|INode
index|[]
name|inodes
parameter_list|,
name|int
name|pos
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|INode
name|commonAncestor
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
operator|!
name|ready
condition|)
block|{
comment|// Do not check quota if edits log is still being processed
return|return;
block|}
if|if
condition|(
name|nsDelta
operator|<=
literal|0
operator|&&
name|dsDelta
operator|<=
literal|0
condition|)
block|{
comment|// if quota is being freed or not being consumed
return|return;
block|}
if|if
condition|(
name|pos
operator|>
name|inodes
operator|.
name|length
condition|)
block|{
name|pos
operator|=
name|inodes
operator|.
name|length
expr_stmt|;
block|}
name|int
name|i
init|=
name|pos
operator|-
literal|1
decl_stmt|;
try|try
block|{
comment|// check existing components in the path
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|commonAncestor
operator|==
name|inodes
index|[
name|i
index|]
condition|)
block|{
comment|// Moving an existing node. Stop checking for quota when common
comment|// ancestor is reached
return|return;
block|}
if|if
condition|(
name|inodes
index|[
name|i
index|]
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
comment|// a directory with quota
name|INodeDirectoryWithQuota
name|node
init|=
operator|(
name|INodeDirectoryWithQuota
operator|)
name|inodes
index|[
name|i
index|]
decl_stmt|;
name|node
operator|.
name|verifyQuota
argument_list|(
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|e
operator|.
name|setPathName
argument_list|(
name|getFullPathName
argument_list|(
name|inodes
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Verify quota for rename operation where srcInodes[srcInodes.length-1] moves    * dstInodes[dstInodes.length-1]    *     * @param srcInodes directory from where node is being moved.    * @param dstInodes directory to where node is moved to.    * @throws QuotaExceededException if quota limit is exceeded.    */
DECL|method|verifyQuotaForRename (INode[] srcInodes, INode[]dstInodes)
specifier|private
name|void
name|verifyQuotaForRename
parameter_list|(
name|INode
index|[]
name|srcInodes
parameter_list|,
name|INode
index|[]
name|dstInodes
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
operator|!
name|ready
condition|)
block|{
comment|// Do not check quota if edits log is still being processed
return|return;
block|}
name|INode
name|srcInode
init|=
name|srcInodes
index|[
name|srcInodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|INode
name|commonAncestor
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|srcInodes
index|[
name|i
index|]
operator|==
name|dstInodes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|commonAncestor
operator|=
name|srcInodes
index|[
name|i
index|]
expr_stmt|;
block|}
name|INode
operator|.
name|DirCounts
name|srcCounts
init|=
operator|new
name|INode
operator|.
name|DirCounts
argument_list|()
decl_stmt|;
name|srcInode
operator|.
name|spaceConsumedInTree
argument_list|(
name|srcCounts
argument_list|)
expr_stmt|;
name|long
name|nsDelta
init|=
name|srcCounts
operator|.
name|getNsCount
argument_list|()
decl_stmt|;
name|long
name|dsDelta
init|=
name|srcCounts
operator|.
name|getDsCount
argument_list|()
decl_stmt|;
comment|// Reduce the required quota by dst that is being removed
name|INode
name|dstInode
init|=
name|dstInodes
index|[
name|dstInodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|dstInode
operator|!=
literal|null
condition|)
block|{
name|INode
operator|.
name|DirCounts
name|dstCounts
init|=
operator|new
name|INode
operator|.
name|DirCounts
argument_list|()
decl_stmt|;
name|dstInode
operator|.
name|spaceConsumedInTree
argument_list|(
name|dstCounts
argument_list|)
expr_stmt|;
name|nsDelta
operator|-=
name|dstCounts
operator|.
name|getNsCount
argument_list|()
expr_stmt|;
name|dsDelta
operator|-=
name|dstCounts
operator|.
name|getDsCount
argument_list|()
expr_stmt|;
block|}
name|verifyQuota
argument_list|(
name|dstInodes
argument_list|,
name|dstInodes
operator|.
name|length
operator|-
literal|1
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
name|commonAncestor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that filesystem limit constraints are not violated    * @throws PathComponentTooLongException child's name is too long    * @throws MaxDirectoryItemsExceededException items per directory is exceeded    */
DECL|method|verifyFsLimits (INode[] pathComponents, int pos, T child)
specifier|protected
parameter_list|<
name|T
extends|extends
name|INode
parameter_list|>
name|void
name|verifyFsLimits
parameter_list|(
name|INode
index|[]
name|pathComponents
parameter_list|,
name|int
name|pos
parameter_list|,
name|T
name|child
parameter_list|)
throws|throws
name|FSLimitException
block|{
name|boolean
name|includeChildName
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|maxComponentLength
operator|!=
literal|0
condition|)
block|{
name|int
name|length
init|=
name|child
operator|.
name|getLocalName
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|maxComponentLength
condition|)
block|{
name|includeChildName
operator|=
literal|true
expr_stmt|;
throw|throw
operator|new
name|PathComponentTooLongException
argument_list|(
name|maxComponentLength
argument_list|,
name|length
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|maxDirItems
operator|!=
literal|0
condition|)
block|{
name|INodeDirectory
name|parent
init|=
operator|(
name|INodeDirectory
operator|)
name|pathComponents
index|[
name|pos
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|count
init|=
name|parent
operator|.
name|getChildrenList
argument_list|(
literal|null
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>=
name|maxDirItems
condition|)
block|{
throw|throw
operator|new
name|MaxDirectoryItemsExceededException
argument_list|(
name|maxDirItems
argument_list|,
name|count
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|FSLimitException
name|e
parameter_list|)
block|{
name|String
name|badPath
init|=
name|getFullPathName
argument_list|(
name|pathComponents
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|includeChildName
condition|)
block|{
name|badPath
operator|+=
name|Path
operator|.
name|SEPARATOR
operator|+
name|child
operator|.
name|getLocalName
argument_list|()
expr_stmt|;
block|}
name|e
operator|.
name|setPathName
argument_list|(
name|badPath
argument_list|)
expr_stmt|;
comment|// Do not throw if edits log is still being processed
if|if
condition|(
name|ready
condition|)
throw|throw
operator|(
name|e
operator|)
throw|;
comment|// log pre-existing paths that exceed limits
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"FSDirectory.verifyFsLimits - "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The same as {@link #addChild(INodesInPath, int, INode, boolean)}    * with pos = length - 1.    */
DECL|method|addLastINode (INodesInPath inodesInPath, INode inode, boolean checkQuota)
specifier|private
name|boolean
name|addLastINode
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|INode
name|inode
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|int
name|pos
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|-
literal|1
decl_stmt|;
return|return
name|addChild
argument_list|(
name|inodesInPath
argument_list|,
name|pos
argument_list|,
name|inode
argument_list|,
name|checkQuota
argument_list|)
return|;
block|}
comment|/** Add a node child to the inodes at index pos.     * Its ancestors are stored at [0, pos-1].    * @return false if the child with this name already exists;     *         otherwise return true;    * @throw QuotaExceededException is thrown if it violates quota limit    */
DECL|method|addChild (INodesInPath inodesInPath, int pos, INode child, boolean checkQuota)
specifier|private
name|boolean
name|addChild
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|pos
parameter_list|,
name|INode
name|child
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
comment|// The filesystem limits are not really quotas, so this check may appear
comment|// odd. It's because a rename operation deletes the src, tries to add
comment|// to the dest, if that fails, re-adds the src from whence it came.
comment|// The rename code disables the quota when it's restoring to the
comment|// original location becase a quota violation would cause the the item
comment|// to go "poof".  The fs limits must be bypassed for the same reason.
if|if
condition|(
name|checkQuota
condition|)
block|{
name|verifyFsLimits
argument_list|(
name|inodes
argument_list|,
name|pos
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
name|INode
operator|.
name|DirCounts
name|counts
init|=
operator|new
name|INode
operator|.
name|DirCounts
argument_list|()
decl_stmt|;
name|child
operator|.
name|spaceConsumedInTree
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
name|pos
argument_list|,
name|counts
operator|.
name|getNsCount
argument_list|()
argument_list|,
name|counts
operator|.
name|getDsCount
argument_list|()
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodes
index|[
name|pos
operator|-
literal|1
index|]
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Panic: parent does not exist"
argument_list|)
throw|;
block|}
specifier|final
name|boolean
name|added
init|=
operator|(
operator|(
name|INodeDirectory
operator|)
name|inodes
index|[
name|pos
operator|-
literal|1
index|]
operator|)
operator|.
name|addChild
argument_list|(
name|child
argument_list|,
literal|true
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
name|pos
argument_list|,
operator|-
name|counts
operator|.
name|getNsCount
argument_list|()
argument_list|,
operator|-
name|counts
operator|.
name|getDsCount
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
DECL|method|addLastINodeNoQuotaCheck (INodesInPath inodesInPath, INode i)
specifier|private
name|boolean
name|addLastINodeNoQuotaCheck
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|INode
name|i
parameter_list|)
block|{
try|try
block|{
return|return
name|addLastINode
argument_list|(
name|inodesInPath
argument_list|,
name|i
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"FSDirectory.addChildNoQuotaCheck - unexpected"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Remove the last inode in the path from the namespace.    * Count of each ancestor with quota is also updated.    * @return the removed node; null if the removal fails.    */
DECL|method|removeLastINode (final INodesInPath inodesInPath)
specifier|private
name|INode
name|removeLastINode
parameter_list|(
specifier|final
name|INodesInPath
name|inodesInPath
parameter_list|)
block|{
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pos
init|=
name|inodes
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|INode
name|removedNode
init|=
operator|(
operator|(
name|INodeDirectory
operator|)
name|inodes
index|[
name|pos
operator|-
literal|1
index|]
operator|)
operator|.
name|removeChild
argument_list|(
name|inodes
index|[
name|pos
index|]
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|removedNode
operator|!=
literal|null
condition|)
block|{
name|inodesInPath
operator|.
name|setINode
argument_list|(
name|pos
operator|-
literal|1
argument_list|,
name|removedNode
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
name|INode
operator|.
name|DirCounts
name|counts
init|=
operator|new
name|INode
operator|.
name|DirCounts
argument_list|()
decl_stmt|;
name|removedNode
operator|.
name|spaceConsumedInTree
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|updateCountNoQuotaCheck
argument_list|(
name|inodesInPath
argument_list|,
name|pos
argument_list|,
operator|-
name|counts
operator|.
name|getNsCount
argument_list|()
argument_list|,
operator|-
name|counts
operator|.
name|getDsCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|removedNode
return|;
block|}
comment|/**    */
DECL|method|normalizePath (String src)
name|String
name|normalizePath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|src
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
DECL|method|getContentSummary (String src)
name|ContentSummary
name|getContentSummary
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|targetNode
init|=
name|rootDir
operator|.
name|getNode
argument_list|(
name|srcs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|srcs
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|targetNode
operator|.
name|computeContentSummary
argument_list|()
return|;
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Update the count of each directory with quota in the namespace    * A directory's count is defined as the total number inodes in the tree    * rooted at the directory.    *     * This is an update of existing state of the filesystem and does not    * throw QuotaExceededException.    */
DECL|method|updateCountForINodeWithQuota ()
name|void
name|updateCountForINodeWithQuota
parameter_list|()
block|{
name|updateCountForINodeWithQuota
argument_list|(
name|rootDir
argument_list|,
operator|new
name|INode
operator|.
name|DirCounts
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|INode
argument_list|>
argument_list|(
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Update the count of the directory if it has a quota and return the count    *     * This does not throw a QuotaExceededException. This is just an update    * of of existing state and throwing QuotaExceededException does not help    * with fixing the state, if there is a problem.    *     * @param dir the root of the tree that represents the directory    * @param counters counters for name space and disk space    * @param nodesInPath INodes for the each of components in the path.    */
DECL|method|updateCountForINodeWithQuota (INodeDirectory dir, INode.DirCounts counts, ArrayList<INode> nodesInPath)
specifier|private
specifier|static
name|void
name|updateCountForINodeWithQuota
parameter_list|(
name|INodeDirectory
name|dir
parameter_list|,
name|INode
operator|.
name|DirCounts
name|counts
parameter_list|,
name|ArrayList
argument_list|<
name|INode
argument_list|>
name|nodesInPath
parameter_list|)
block|{
name|long
name|parentNamespace
init|=
name|counts
operator|.
name|nsCount
decl_stmt|;
name|long
name|parentDiskspace
init|=
name|counts
operator|.
name|dsCount
decl_stmt|;
name|counts
operator|.
name|nsCount
operator|=
literal|1L
expr_stmt|;
comment|//for self. should not call node.spaceConsumedInTree()
name|counts
operator|.
name|dsCount
operator|=
literal|0L
expr_stmt|;
comment|/* We don't need nodesInPath if we could use 'parent' field in       * INode. using 'parent' is not currently recommended. */
name|nodesInPath
operator|.
name|add
argument_list|(
name|dir
argument_list|)
expr_stmt|;
for|for
control|(
name|INode
name|child
range|:
name|dir
operator|.
name|getChildrenList
argument_list|(
literal|null
argument_list|)
control|)
block|{
if|if
condition|(
name|child
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|updateCountForINodeWithQuota
argument_list|(
operator|(
name|INodeDirectory
operator|)
name|child
argument_list|,
name|counts
argument_list|,
name|nodesInPath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
name|counts
operator|.
name|nsCount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// reduce recursive calls
name|counts
operator|.
name|nsCount
operator|+=
literal|1
expr_stmt|;
name|counts
operator|.
name|dsCount
operator|+=
operator|(
operator|(
name|INodeFile
operator|)
name|child
operator|)
operator|.
name|diskspaceConsumed
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dir
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
operator|(
operator|(
name|INodeDirectoryWithQuota
operator|)
name|dir
operator|)
operator|.
name|setSpaceConsumed
argument_list|(
name|counts
operator|.
name|nsCount
argument_list|,
name|counts
operator|.
name|dsCount
argument_list|)
expr_stmt|;
comment|// check if quota is violated for some reason.
if|if
condition|(
operator|(
name|dir
operator|.
name|getNsQuota
argument_list|()
operator|>=
literal|0
operator|&&
name|counts
operator|.
name|nsCount
operator|>
name|dir
operator|.
name|getNsQuota
argument_list|()
operator|)
operator|||
operator|(
name|dir
operator|.
name|getDsQuota
argument_list|()
operator|>=
literal|0
operator|&&
name|counts
operator|.
name|dsCount
operator|>
name|dir
operator|.
name|getDsQuota
argument_list|()
operator|)
condition|)
block|{
comment|// can only happen because of a software bug. the bug should be fixed.
name|StringBuilder
name|path
init|=
operator|new
name|StringBuilder
argument_list|(
literal|512
argument_list|)
decl_stmt|;
for|for
control|(
name|INode
name|n
range|:
name|nodesInPath
control|)
block|{
name|path
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|path
operator|.
name|append
argument_list|(
name|n
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Quota violation in image for "
operator|+
name|path
operator|+
literal|" (Namespace quota : "
operator|+
name|dir
operator|.
name|getNsQuota
argument_list|()
operator|+
literal|" consumed : "
operator|+
name|counts
operator|.
name|nsCount
operator|+
literal|")"
operator|+
literal|" (Diskspace quota : "
operator|+
name|dir
operator|.
name|getDsQuota
argument_list|()
operator|+
literal|" consumed : "
operator|+
name|counts
operator|.
name|dsCount
operator|+
literal|")."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// pop
name|nodesInPath
operator|.
name|remove
argument_list|(
name|nodesInPath
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|counts
operator|.
name|nsCount
operator|+=
name|parentNamespace
expr_stmt|;
name|counts
operator|.
name|dsCount
operator|+=
name|parentDiskspace
expr_stmt|;
block|}
comment|/**    * See {@link ClientProtocol#setQuota(String, long, long)} for the contract.    * Sets quota for for a directory.    * @returns INodeDirectory if any of the quotas have changed. null other wise.    * @throws FileNotFoundException if the path does not exist.    * @throws PathIsNotDirectoryException if the path is not a directory.    * @throws QuotaExceededException if the directory tree size is     *                                greater than the given quota    * @throws UnresolvedLinkException if a symlink is encountered in src.    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|unprotectedSetQuota (String src, long nsQuota, long dsQuota)
name|INodeDirectory
name|unprotectedSetQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|PathIsNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// sanity check
if|if
condition|(
operator|(
name|nsQuota
operator|<
literal|0
operator|&&
name|nsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
operator|&&
name|nsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_RESET
operator|)
operator|||
operator|(
name|dsQuota
operator|<
literal|0
operator|&&
name|dsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
operator|&&
name|dsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_RESET
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal value for nsQuota or "
operator|+
literal|"dsQuota : "
operator|+
name|nsQuota
operator|+
literal|" and "
operator|+
name|dsQuota
argument_list|)
throw|;
block|}
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|srcs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INodeDirectory
name|dirNode
init|=
name|INodeDirectory
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|srcs
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirNode
operator|.
name|isRoot
argument_list|()
operator|&&
name|nsQuota
operator|==
name|HdfsConstants
operator|.
name|QUOTA_RESET
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot clear namespace quota on root."
argument_list|)
throw|;
block|}
else|else
block|{
comment|// a directory inode
name|long
name|oldNsQuota
init|=
name|dirNode
operator|.
name|getNsQuota
argument_list|()
decl_stmt|;
name|long
name|oldDsQuota
init|=
name|dirNode
operator|.
name|getDsQuota
argument_list|()
decl_stmt|;
if|if
condition|(
name|nsQuota
operator|==
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
condition|)
block|{
name|nsQuota
operator|=
name|oldNsQuota
expr_stmt|;
block|}
if|if
condition|(
name|dsQuota
operator|==
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
condition|)
block|{
name|dsQuota
operator|=
name|oldDsQuota
expr_stmt|;
block|}
specifier|final
name|Snapshot
name|latest
init|=
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirNode
operator|instanceof
name|INodeDirectoryWithQuota
condition|)
block|{
comment|// a directory with quota; so set the quota to the new value
operator|(
operator|(
name|INodeDirectoryWithQuota
operator|)
name|dirNode
operator|)
operator|.
name|setQuota
argument_list|(
name|nsQuota
argument_list|,
name|dsQuota
argument_list|,
name|latest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirNode
operator|.
name|isQuotaSet
argument_list|()
operator|&&
name|latest
operator|==
literal|null
condition|)
block|{
comment|// will not come here for root because root's nsQuota is always set
return|return
name|dirNode
operator|.
name|replaceSelf4INodeDirectory
argument_list|()
return|;
block|}
block|}
else|else
block|{
comment|// a non-quota directory; so replace it with a directory with quota
return|return
name|dirNode
operator|.
name|replaceSelf4Quota
argument_list|(
name|latest
argument_list|,
name|nsQuota
argument_list|,
name|dsQuota
argument_list|)
return|;
block|}
return|return
operator|(
name|oldNsQuota
operator|!=
name|nsQuota
operator|||
name|oldDsQuota
operator|!=
name|dsQuota
operator|)
condition|?
name|dirNode
else|:
literal|null
return|;
block|}
block|}
comment|/**    * See {@link ClientProtocol#setQuota(String, long, long)} for the contract.    * @throws SnapshotAccessControlException if path is in RO snapshot    * @see #unprotectedSetQuota(String, long, long)    */
DECL|method|setQuota (String src, long nsQuota, long dsQuota)
name|void
name|setQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|PathIsNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INodeDirectory
name|dir
init|=
name|unprotectedSetQuota
argument_list|(
name|src
argument_list|,
name|nsQuota
argument_list|,
name|dsQuota
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSetQuota
argument_list|(
name|src
argument_list|,
name|dir
operator|.
name|getNsQuota
argument_list|()
argument_list|,
name|dir
operator|.
name|getDsQuota
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|totalInodes ()
name|long
name|totalInodes
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|numItemsInTree
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Sets the access time on the file/directory. Logs it in the transaction log.    */
DECL|method|setTimes (String src, INode inode, long mtime, long atime, boolean force, Snapshot latest)
name|void
name|setTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|INode
name|inode
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|boolean
name|force
parameter_list|,
name|Snapshot
name|latest
parameter_list|)
block|{
name|boolean
name|status
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|status
operator|=
name|unprotectedSetTimes
argument_list|(
name|src
argument_list|,
name|inode
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|force
argument_list|,
name|latest
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logTimes
argument_list|(
name|src
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetTimes (String src, long mtime, long atime, boolean force)
name|boolean
name|unprotectedSetTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|i
init|=
name|getLastINodeInPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
return|return
name|unprotectedSetTimes
argument_list|(
name|src
argument_list|,
name|i
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|force
argument_list|,
name|i
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
return|;
block|}
DECL|method|unprotectedSetTimes (String src, INode inode, long mtime, long atime, boolean force, Snapshot latest)
specifier|private
name|boolean
name|unprotectedSetTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|INode
name|inode
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|boolean
name|force
parameter_list|,
name|Snapshot
name|latest
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|boolean
name|status
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|mtime
operator|!=
operator|-
literal|1
condition|)
block|{
name|inode
operator|=
name|inode
operator|.
name|setModificationTime
argument_list|(
name|mtime
argument_list|,
name|latest
argument_list|)
expr_stmt|;
name|status
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|atime
operator|!=
operator|-
literal|1
condition|)
block|{
name|long
name|inodeTime
init|=
name|inode
operator|.
name|getAccessTime
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|// if the last access time update was within the last precision interval, then
comment|// no need to store access time
if|if
condition|(
name|atime
operator|<=
name|inodeTime
operator|+
name|getFSNamesystem
argument_list|()
operator|.
name|getAccessTimePrecision
argument_list|()
operator|&&
operator|!
name|force
condition|)
block|{
name|status
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|.
name|setAccessTime
argument_list|(
name|atime
argument_list|,
name|latest
argument_list|)
expr_stmt|;
name|status
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
comment|/**    * Reset the entire namespace tree.    */
DECL|method|reset ()
name|void
name|reset
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|setReady
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|rootDir
operator|=
name|createRoot
argument_list|(
name|getFSNamesystem
argument_list|()
argument_list|)
expr_stmt|;
name|nameCache
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * create an hdfs file status from an inode    *     * @param path the local name    * @param node inode    * @param needLocation if block locations need to be included or not    * @return a file status    * @throws IOException if any error occurs    */
DECL|method|createFileStatus (byte[] path, INode node, boolean needLocation, Snapshot snapshot)
specifier|private
name|HdfsFileStatus
name|createFileStatus
parameter_list|(
name|byte
index|[]
name|path
parameter_list|,
name|INode
name|node
parameter_list|,
name|boolean
name|needLocation
parameter_list|,
name|Snapshot
name|snapshot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|needLocation
condition|)
block|{
return|return
name|createLocatedFileStatus
argument_list|(
name|path
argument_list|,
name|node
argument_list|,
name|snapshot
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createFileStatus
argument_list|(
name|path
argument_list|,
name|node
argument_list|,
name|snapshot
argument_list|)
return|;
block|}
block|}
comment|/**    * Create FileStatus by file INode     */
DECL|method|createFileStatus (byte[] path, INode node, Snapshot snapshot)
specifier|private
name|HdfsFileStatus
name|createFileStatus
parameter_list|(
name|byte
index|[]
name|path
parameter_list|,
name|INode
name|node
parameter_list|,
name|Snapshot
name|snapshot
parameter_list|)
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
comment|// length is zero for directories
name|short
name|replication
init|=
literal|0
decl_stmt|;
name|long
name|blocksize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|INodeFile
condition|)
block|{
name|INodeFile
name|fileNode
init|=
operator|(
name|INodeFile
operator|)
name|node
decl_stmt|;
name|size
operator|=
name|fileNode
operator|.
name|computeFileSize
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|replication
operator|=
name|fileNode
operator|.
name|getFileReplication
argument_list|()
expr_stmt|;
name|blocksize
operator|=
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|HdfsFileStatus
argument_list|(
name|size
argument_list|,
name|node
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|node
operator|.
name|getModificationTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getAccessTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getFsPermission
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getUserName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getGroupName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|isSymlink
argument_list|()
condition|?
operator|(
operator|(
name|INodeSymlink
operator|)
name|node
operator|)
operator|.
name|getSymlink
argument_list|()
else|:
literal|null
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/**     * Create FileStatus with location info by file INode      */
DECL|method|createLocatedFileStatus ( byte[] path, INode node, Snapshot snapshot)
specifier|private
name|HdfsLocatedFileStatus
name|createLocatedFileStatus
parameter_list|(
name|byte
index|[]
name|path
parameter_list|,
name|INode
name|node
parameter_list|,
name|Snapshot
name|snapshot
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
name|long
name|size
init|=
literal|0
decl_stmt|;
comment|// length is zero for directories
name|short
name|replication
init|=
literal|0
decl_stmt|;
name|long
name|blocksize
init|=
literal|0
decl_stmt|;
name|LocatedBlocks
name|loc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|INodeFile
condition|)
block|{
name|INodeFile
name|fileNode
init|=
operator|(
name|INodeFile
operator|)
name|node
decl_stmt|;
name|size
operator|=
name|fileNode
operator|.
name|computeFileSize
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|replication
operator|=
name|fileNode
operator|.
name|getFileReplication
argument_list|()
expr_stmt|;
name|blocksize
operator|=
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
name|loc
operator|=
name|getFSNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
operator|.
name|createLocatedBlocks
argument_list|(
name|fileNode
operator|.
name|getBlocks
argument_list|()
argument_list|,
name|fileNode
operator|.
name|computeFileSize
argument_list|(
literal|false
argument_list|)
argument_list|,
name|fileNode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|,
literal|0L
argument_list|,
name|size
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
literal|null
condition|)
block|{
name|loc
operator|=
operator|new
name|LocatedBlocks
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|new
name|HdfsLocatedFileStatus
argument_list|(
name|size
argument_list|,
name|node
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|node
operator|.
name|getModificationTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getAccessTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getFsPermission
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getUserName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getGroupName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|isSymlink
argument_list|()
condition|?
operator|(
operator|(
name|INodeSymlink
operator|)
name|node
operator|)
operator|.
name|getSymlink
argument_list|()
else|:
literal|null
argument_list|,
name|path
argument_list|,
name|loc
argument_list|)
return|;
block|}
comment|/**    * Add the given symbolic link to the fs. Record it in the edits log.    */
DECL|method|addSymlink (String path, String target, PermissionStatus dirPerms, boolean createParent)
name|INodeSymlink
name|addSymlink
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|target
parameter_list|,
name|PermissionStatus
name|dirPerms
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|FileAlreadyExistsException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
specifier|final
name|long
name|modTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|createParent
condition|)
block|{
specifier|final
name|String
name|parent
init|=
operator|new
name|Path
argument_list|(
name|path
argument_list|)
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|mkdirs
argument_list|(
name|parent
argument_list|,
name|dirPerms
argument_list|,
literal|true
argument_list|,
name|modTime
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|String
name|userName
init|=
name|dirPerms
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|INodeSymlink
name|newNode
init|=
literal|null
decl_stmt|;
name|long
name|id
init|=
name|namesystem
operator|.
name|allocateNewInodeId
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|newNode
operator|=
name|unprotectedAddSymlink
argument_list|(
name|id
argument_list|,
name|path
argument_list|,
name|target
argument_list|,
name|modTime
argument_list|,
name|modTime
argument_list|,
operator|new
name|PermissionStatus
argument_list|(
name|userName
argument_list|,
literal|null
argument_list|,
name|FsPermission
operator|.
name|getDefault
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|newNode
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* addSymlink: failed to add "
operator|+
name|path
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSymlink
argument_list|(
name|path
argument_list|,
name|target
argument_list|,
name|modTime
argument_list|,
name|modTime
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* addSymlink: "
operator|+
name|path
operator|+
literal|" is added"
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
block|}
comment|/**    * Add the specified path into the namespace. Invoked from edit log processing.    */
DECL|method|unprotectedAddSymlink (long id, String path, String target, long mtime, long atime, PermissionStatus perm)
name|INodeSymlink
name|unprotectedAddSymlink
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|path
parameter_list|,
name|String
name|target
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|PermissionStatus
name|perm
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeSymlink
name|symlink
init|=
operator|new
name|INodeSymlink
argument_list|(
name|id
argument_list|,
name|target
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|perm
argument_list|)
decl_stmt|;
return|return
name|addINode
argument_list|(
name|path
argument_list|,
name|symlink
argument_list|)
condition|?
name|symlink
else|:
literal|null
return|;
block|}
comment|/**    * Caches frequently used file names to reuse file name objects and    * reduce heap size.    */
DECL|method|cacheName (INode inode)
name|void
name|cacheName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
comment|// Name is cached only for files
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return;
block|}
name|ByteArray
name|name
init|=
operator|new
name|ByteArray
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
decl_stmt|;
name|name
operator|=
name|nameCache
operator|.
name|put
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|inode
operator|.
name|setLocalName
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

