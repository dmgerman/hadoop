begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BatchedRemoteIterator
operator|.
name|BatchedListEntries
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|CRYPTO_XATTR_ENCRYPTION_ZONE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|CRYPTO_XATTR_FILE_ENCRYPTION_INFO
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|SECURITY_XATTR_UNREADABLE_BY_SUPERUSER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CipherSuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CryptoProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|Rename
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathIsNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttrSetFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|XAttrHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|AclException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DirectoryListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|EncryptionZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|MaxDirectoryItemsExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|PathComponentTooLongException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FsPermissionExtension
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsLocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotAccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HdfsProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|PBHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockStoragePolicySuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapUpdateInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeReference
operator|.
name|WithCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|DirectorySnapshottableFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
operator|.
name|Root
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ChunkedArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ReadOnlyList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_comment
comment|/**  * Both FSDirectory and FSNamesystem manage the state of the namespace.  * FSDirectory is a pure in-memory data structure, all of whose operations  * happen entirely in memory. In contrast, FSNamesystem persists the operations  * to the disk.  * @see org.apache.hadoop.hdfs.server.namenode.FSNamesystem  **/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|FSDirectory
specifier|public
class|class
name|FSDirectory
implements|implements
name|Closeable
block|{
DECL|method|createRoot (FSNamesystem namesystem)
specifier|private
specifier|static
name|INodeDirectory
name|createRoot
parameter_list|(
name|FSNamesystem
name|namesystem
parameter_list|)
block|{
specifier|final
name|INodeDirectory
name|r
init|=
operator|new
name|INodeDirectory
argument_list|(
name|INodeId
operator|.
name|ROOT_INODE_ID
argument_list|,
name|INodeDirectory
operator|.
name|ROOT_NAME
argument_list|,
name|namesystem
operator|.
name|createFsOwnerPermissions
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
argument_list|)
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
name|r
operator|.
name|addDirectoryWithQuotaFeature
argument_list|(
name|DirectoryWithQuotaFeature
operator|.
name|DEFAULT_NAMESPACE_QUOTA
argument_list|,
name|DirectoryWithQuotaFeature
operator|.
name|DEFAULT_DISKSPACE_QUOTA
argument_list|)
expr_stmt|;
name|r
operator|.
name|addSnapshottableFeature
argument_list|()
expr_stmt|;
name|r
operator|.
name|setSnapshotQuota
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|field|CHECK_RESERVED_FILE_NAMES
specifier|static
name|boolean
name|CHECK_RESERVED_FILE_NAMES
init|=
literal|true
decl_stmt|;
DECL|field|DOT_RESERVED_STRING
specifier|public
specifier|final
specifier|static
name|String
name|DOT_RESERVED_STRING
init|=
literal|".reserved"
decl_stmt|;
DECL|field|DOT_RESERVED_PATH_PREFIX
specifier|public
specifier|final
specifier|static
name|String
name|DOT_RESERVED_PATH_PREFIX
init|=
name|Path
operator|.
name|SEPARATOR
operator|+
name|DOT_RESERVED_STRING
decl_stmt|;
DECL|field|DOT_RESERVED
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|DOT_RESERVED
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|DOT_RESERVED_STRING
argument_list|)
decl_stmt|;
DECL|field|RAW_STRING
specifier|private
specifier|final
specifier|static
name|String
name|RAW_STRING
init|=
literal|"raw"
decl_stmt|;
DECL|field|RAW
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|RAW
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|RAW_STRING
argument_list|)
decl_stmt|;
DECL|field|DOT_INODES_STRING
specifier|public
specifier|final
specifier|static
name|String
name|DOT_INODES_STRING
init|=
literal|".inodes"
decl_stmt|;
DECL|field|DOT_INODES
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|DOT_INODES
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|DOT_INODES_STRING
argument_list|)
decl_stmt|;
DECL|field|KEYID_XATTR
specifier|private
specifier|final
name|XAttr
name|KEYID_XATTR
init|=
name|XAttrHelper
operator|.
name|buildXAttr
argument_list|(
name|CRYPTO_XATTR_ENCRYPTION_ZONE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
DECL|field|UNREADABLE_BY_SUPERUSER_XATTR
specifier|private
specifier|final
name|XAttr
name|UNREADABLE_BY_SUPERUSER_XATTR
init|=
name|XAttrHelper
operator|.
name|buildXAttr
argument_list|(
name|SECURITY_XATTR_UNREADABLE_BY_SUPERUSER
argument_list|,
literal|null
argument_list|)
decl_stmt|;
DECL|field|rootDir
name|INodeDirectory
name|rootDir
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|skipQuotaCheck
specifier|private
specifier|volatile
name|boolean
name|skipQuotaCheck
init|=
literal|false
decl_stmt|;
comment|//skip while consuming edits
DECL|field|maxComponentLength
specifier|private
specifier|final
name|int
name|maxComponentLength
decl_stmt|;
DECL|field|maxDirItems
specifier|private
specifier|final
name|int
name|maxDirItems
decl_stmt|;
DECL|field|lsLimit
specifier|private
specifier|final
name|int
name|lsLimit
decl_stmt|;
comment|// max list limit
DECL|field|contentCountLimit
specifier|private
specifier|final
name|int
name|contentCountLimit
decl_stmt|;
comment|// max content summary counts per run
DECL|field|inodeMap
specifier|private
specifier|final
name|INodeMap
name|inodeMap
decl_stmt|;
comment|// Synchronized by dirLock
DECL|field|yieldCount
specifier|private
name|long
name|yieldCount
init|=
literal|0
decl_stmt|;
comment|// keep track of lock yield count.
DECL|field|inodeXAttrsLimit
specifier|private
specifier|final
name|int
name|inodeXAttrsLimit
decl_stmt|;
comment|//inode xattrs max limit
comment|// lock to protect the directory and BlockMap
DECL|field|dirLock
specifier|private
specifier|final
name|ReentrantReadWriteLock
name|dirLock
decl_stmt|;
comment|// utility methods to acquire and release read lock and write lock
DECL|method|readLock ()
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|readUnlock ()
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeLock ()
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeUnlock ()
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|hasWriteLock ()
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|isWriteLockedByCurrentThread
argument_list|()
return|;
block|}
DECL|method|hasReadLock ()
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getReadHoldCount
argument_list|()
operator|>
literal|0
operator|||
name|hasWriteLock
argument_list|()
return|;
block|}
DECL|method|getReadHoldCount ()
specifier|public
name|int
name|getReadHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getReadHoldCount
argument_list|()
return|;
block|}
DECL|method|getWriteHoldCount ()
specifier|public
name|int
name|getWriteHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getWriteHoldCount
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|field|ezManager
specifier|public
specifier|final
name|EncryptionZoneManager
name|ezManager
decl_stmt|;
comment|/**    * Caches frequently used file names used in {@link INode} to reuse     * byte[] objects and reduce heap usage.    */
DECL|field|nameCache
specifier|private
specifier|final
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
name|nameCache
decl_stmt|;
DECL|method|FSDirectory (FSNamesystem ns, Configuration conf)
name|FSDirectory
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|dirLock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// fair
name|rootDir
operator|=
name|createRoot
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|inodeMap
operator|=
name|INodeMap
operator|.
name|newInstance
argument_list|(
name|rootDir
argument_list|)
expr_stmt|;
name|int
name|configuredLimit
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
argument_list|)
decl_stmt|;
name|this
operator|.
name|lsLimit
operator|=
name|configuredLimit
operator|>
literal|0
condition|?
name|configuredLimit
else|:
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
expr_stmt|;
name|this
operator|.
name|contentCountLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CONTENT_SUMMARY_LIMIT_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CONTENT_SUMMARY_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
comment|// filesystem limits
name|this
operator|.
name|maxComponentLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxDirItems
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|inodeXAttrsLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTRS_PER_INODE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTRS_PER_INODE_DEFAULT
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|this
operator|.
name|inodeXAttrsLimit
operator|>=
literal|0
argument_list|,
literal|"Cannot set a negative limit on the number of xattrs per inode (%s)."
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTRS_PER_INODE_KEY
argument_list|)
expr_stmt|;
comment|// We need a maximum maximum because by default, PB limits message sizes
comment|// to 64MB. This means we can only store approximately 6.7 million entries
comment|// per directory, but let's use 6.4 million for some safety.
specifier|final
name|int
name|MAX_DIR_ITEMS
init|=
literal|64
operator|*
literal|100
operator|*
literal|1000
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|maxDirItems
operator|>
literal|0
operator|&&
name|maxDirItems
operator|<=
name|MAX_DIR_ITEMS
argument_list|,
literal|"Cannot set "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_KEY
operator|+
literal|" to a value less than 0 or greater than "
operator|+
name|MAX_DIR_ITEMS
argument_list|)
expr_stmt|;
name|int
name|threshold
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_DEFAULT
argument_list|)
decl_stmt|;
name|NameNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Caching file names occuring more than "
operator|+
name|threshold
operator|+
literal|" times"
argument_list|)
expr_stmt|;
name|nameCache
operator|=
operator|new
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|namesystem
operator|=
name|ns
expr_stmt|;
name|ezManager
operator|=
operator|new
name|EncryptionZoneManager
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|getFSNamesystem ()
specifier|private
name|FSNamesystem
name|getFSNamesystem
parameter_list|()
block|{
return|return
name|namesystem
return|;
block|}
DECL|method|getBlockManager ()
specifier|private
name|BlockManager
name|getBlockManager
parameter_list|()
block|{
return|return
name|getFSNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
return|;
block|}
comment|/** @return the root directory inode. */
DECL|method|getRoot ()
specifier|public
name|INodeDirectory
name|getRoot
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
comment|/**    * Shutdown the filestore    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{}
DECL|method|markNameCacheInitialized ()
name|void
name|markNameCacheInitialized
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|nameCache
operator|.
name|initialized
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Enable quota verification */
DECL|method|enableQuotaChecks ()
name|void
name|enableQuotaChecks
parameter_list|()
block|{
name|skipQuotaCheck
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Disable quota verification */
DECL|method|disableQuotaChecks ()
name|void
name|disableQuotaChecks
parameter_list|()
block|{
name|skipQuotaCheck
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|newINodeFile (long id, PermissionStatus permissions, long mtime, long atime, short replication, long preferredBlockSize, boolean isLazyPersist)
specifier|private
specifier|static
name|INodeFile
name|newINodeFile
parameter_list|(
name|long
name|id
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|boolean
name|isLazyPersist
parameter_list|)
block|{
return|return
name|newINodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|isLazyPersist
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
return|;
block|}
DECL|method|newINodeFile (long id, PermissionStatus permissions, long mtime, long atime, short replication, long preferredBlockSize, boolean isLazyPersist, byte storagePolicyId)
specifier|private
specifier|static
name|INodeFile
name|newINodeFile
parameter_list|(
name|long
name|id
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|boolean
name|isLazyPersist
parameter_list|,
name|byte
name|storagePolicyId
parameter_list|)
block|{
return|return
operator|new
name|INodeFile
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|permissions
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|BlockInfo
operator|.
name|EMPTY_ARRAY
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|isLazyPersist
argument_list|,
name|storagePolicyId
argument_list|)
return|;
block|}
comment|/**    * Add the given filename to the fs.    * @throws FileAlreadyExistsException    * @throws QuotaExceededException    * @throws UnresolvedLinkException    * @throws SnapshotAccessControlException     */
DECL|method|addFile (String path, PermissionStatus permissions, short replication, long preferredBlockSize, boolean isLazyPersist, String clientName, String clientMachine)
name|INodeFile
name|addFile
parameter_list|(
name|String
name|path
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|boolean
name|isLazyPersist
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
throws|,
name|AclException
block|{
name|long
name|modTime
init|=
name|now
argument_list|()
decl_stmt|;
name|INodeFile
name|newNode
init|=
name|newINodeFile
argument_list|(
name|namesystem
operator|.
name|allocateNewInodeId
argument_list|()
argument_list|,
name|permissions
argument_list|,
name|modTime
argument_list|,
name|modTime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|isLazyPersist
argument_list|)
decl_stmt|;
name|newNode
operator|.
name|toUnderConstruction
argument_list|(
name|clientName
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|added
operator|=
name|addINode
argument_list|(
name|path
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* addFile: failed to add "
operator|+
name|path
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* addFile: "
operator|+
name|path
operator|+
literal|" is added"
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
block|}
DECL|method|unprotectedAddFile ( long id, String path, PermissionStatus permissions, List<AclEntry> aclEntries, List<XAttr> xAttrs, short replication, long modificationTime, long atime, long preferredBlockSize, boolean isLazyPersist, boolean underConstruction, String clientName, String clientMachine, byte storagePolicyId)
name|INodeFile
name|unprotectedAddFile
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|path
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclEntries
parameter_list|,
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|modificationTime
parameter_list|,
name|long
name|atime
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|boolean
name|isLazyPersist
parameter_list|,
name|boolean
name|underConstruction
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|byte
name|storagePolicyId
parameter_list|)
block|{
specifier|final
name|INodeFile
name|newNode
decl_stmt|;
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|underConstruction
condition|)
block|{
name|newNode
operator|=
name|newINodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|modificationTime
argument_list|,
name|modificationTime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|isLazyPersist
argument_list|,
name|storagePolicyId
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|toUnderConstruction
argument_list|(
name|clientName
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNode
operator|=
name|newINodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|modificationTime
argument_list|,
name|atime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|isLazyPersist
argument_list|,
name|storagePolicyId
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|addINode
argument_list|(
name|path
argument_list|,
name|newNode
argument_list|)
condition|)
block|{
if|if
condition|(
name|aclEntries
operator|!=
literal|null
condition|)
block|{
name|AclStorage
operator|.
name|updateINodeAcl
argument_list|(
name|newNode
argument_list|,
name|aclEntries
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xAttrs
operator|!=
literal|null
condition|)
block|{
name|XAttrStorage
operator|.
name|updateINodeXAttrs
argument_list|(
name|newNode
argument_list|,
name|xAttrs
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedAddFile: exception when add "
operator|+
name|path
operator|+
literal|" to the file system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Add a block to the file. Returns a reference to the added block.    */
DECL|method|addBlock (String path, INodesInPath inodesInPath, Block block, DatanodeStorageInfo[] targets)
name|BlockInfo
name|addBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|Block
name|block
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodeFile
name|fileINode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
comment|// check quota limits and updated space consumed
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
literal|0
argument_list|,
name|fileINode
operator|.
name|getBlockDiskspace
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// associate new last block for the file
name|BlockInfoUnderConstruction
name|blockInfo
init|=
operator|new
name|BlockInfoUnderConstruction
argument_list|(
name|block
argument_list|,
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|,
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|fileINode
argument_list|)
expr_stmt|;
name|fileINode
operator|.
name|addBlock
argument_list|(
name|blockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.addBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is added to the in-memory "
operator|+
literal|"file system"
argument_list|)
expr_stmt|;
block|}
return|return
name|blockInfo
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Remove a block from the file.    * @return Whether the block exists in the corresponding file    */
DECL|method|removeBlock (String path, INodeFile fileNode, Block block)
name|boolean
name|removeBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fileNode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedRemoveBlock
argument_list|(
name|path
argument_list|,
name|fileNode
argument_list|,
name|block
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedRemoveBlock (String path, INodeFile fileNode, Block block)
name|boolean
name|unprotectedRemoveBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
comment|// modify file-> block and blocksMap
comment|// fileNode should be under construction
name|boolean
name|removed
init|=
name|fileNode
operator|.
name|removeLastBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|removed
condition|)
block|{
return|return
literal|false
return|;
block|}
name|getBlockManager
argument_list|()
operator|.
name|removeBlockFromMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.removeBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is removed from the file system"
argument_list|)
expr_stmt|;
block|}
comment|// update space consumed
specifier|final
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
operator|-
name|fileNode
operator|.
name|getBlockDiskspace
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * @throws SnapshotAccessControlException     * @see #unprotectedRenameTo(String, String, long)    * @deprecated Use {@link #renameTo(String, String, long,    *                                  BlocksMapUpdateInfo, Rename...)}    */
annotation|@
name|Deprecated
DECL|method|renameTo (String src, String dst, long mtime)
name|boolean
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|FileAlreadyExistsException
throws|,
name|SnapshotAccessControlException
throws|,
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.renameTo: "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|unprotectedRenameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|mtime
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @see #unprotectedRenameTo(String, String, long, Options.Rename...)    */
DECL|method|renameTo (String src, String dst, long mtime, BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)
name|void
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|mtime
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.renameTo: "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|unprotectedRenameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|mtime
argument_list|,
name|collectedBlocks
argument_list|,
name|options
argument_list|)
condition|)
block|{
name|namesystem
operator|.
name|incrDeletedFileCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Change a path name    *     * @param src source path    * @param dst destination path    * @return true if rename succeeds; false otherwise    * @throws QuotaExceededException if the operation violates any quota limit    * @throws FileAlreadyExistsException if the src is a symlink that points to dst    * @throws SnapshotAccessControlException if path is in RO snapshot    * @deprecated See {@link #renameTo(String, String, long, BlocksMapUpdateInfo, Rename...)}    */
annotation|@
name|Deprecated
DECL|method|unprotectedRenameTo (String src, String dst, long timestamp)
name|boolean
name|unprotectedRenameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|FileAlreadyExistsException
throws|,
name|SnapshotAccessControlException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|srcIIP
init|=
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|srcInode
init|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
try|try
block|{
name|validateRenameSource
argument_list|(
name|src
argument_list|,
name|srcIIP
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SnapshotException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isDir
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|dst
operator|+=
name|Path
operator|.
name|SEPARATOR
operator|+
operator|new
name|Path
argument_list|(
name|src
argument_list|)
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
comment|// validate the destination
if|if
condition|(
name|dst
operator|.
name|equals
argument_list|(
name|src
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
try|try
block|{
name|validateRenameDestination
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|srcInode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
name|INodesInPath
name|dstIIP
init|=
name|getINodesInPath4Write
argument_list|(
name|dst
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstIIP
operator|.
name|getLastINode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because destination exists"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|INode
name|dstParent
init|=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstParent
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because destination's parent does not exist"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|ezManager
operator|.
name|checkMoveValidity
argument_list|(
name|srcIIP
argument_list|,
name|dstIIP
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|// Ensure dst has quota to accommodate rename
name|verifyFsLimitsForRename
argument_list|(
name|srcIIP
argument_list|,
name|dstIIP
argument_list|)
expr_stmt|;
name|verifyQuotaForRename
argument_list|(
name|srcIIP
operator|.
name|getINodes
argument_list|()
argument_list|,
name|dstIIP
operator|.
name|getINodes
argument_list|()
argument_list|)
expr_stmt|;
name|RenameOperation
name|tx
init|=
operator|new
name|RenameOperation
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|srcIIP
argument_list|,
name|dstIIP
argument_list|)
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// remove src
specifier|final
name|long
name|removedSrc
init|=
name|removeLastINode
argument_list|(
name|srcIIP
argument_list|)
decl_stmt|;
if|if
condition|(
name|removedSrc
operator|==
operator|-
literal|1
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because the source can not be removed"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|added
operator|=
name|tx
operator|.
name|addSourceToDestination
argument_list|()
expr_stmt|;
if|if
condition|(
name|added
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|src
operator|+
literal|" is renamed to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|tx
operator|.
name|updateMtimeAndLease
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
name|tx
operator|.
name|updateQuotasInSourceTree
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|tx
operator|.
name|restoreSource
argument_list|()
expr_stmt|;
block|}
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**    * Rename src to dst.    *<br>    * Note: This is to be used by {@link FSEditLog} only.    *<br>    *     * @param src source path    * @param dst destination path    * @param timestamp modification time    * @param options Rename options    */
DECL|method|unprotectedRenameTo (String src, String dst, long timestamp, Options.Rename... options)
name|boolean
name|unprotectedRenameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|boolean
name|ret
init|=
name|unprotectedRenameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|timestamp
argument_list|,
name|collectedBlocks
argument_list|,
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|collectedBlocks
operator|.
name|getToDeleteList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|getFSNamesystem
argument_list|()
operator|.
name|removeBlocksAndUpdateSafemodeTotal
argument_list|(
name|collectedBlocks
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Rename src to dst.    * See {@link DistributedFileSystem#rename(Path, Path, Options.Rename...)}    * for details related to rename semantics and exceptions.    *     * @param src source path    * @param dst destination path    * @param timestamp modification time    * @param collectedBlocks blocks to be removed    * @param options Rename options    */
DECL|method|unprotectedRenameTo (String src, String dst, long timestamp, BlocksMapUpdateInfo collectedBlocks, Options.Rename... options)
name|boolean
name|unprotectedRenameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|boolean
name|overwrite
init|=
name|options
operator|!=
literal|null
operator|&&
name|Arrays
operator|.
name|asList
argument_list|(
name|options
argument_list|)
operator|.
name|contains
argument_list|(
name|Rename
operator|.
name|OVERWRITE
argument_list|)
decl_stmt|;
specifier|final
name|String
name|error
decl_stmt|;
specifier|final
name|INodesInPath
name|srcIIP
init|=
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|srcInode
init|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
name|validateRenameSource
argument_list|(
name|src
argument_list|,
name|srcIIP
argument_list|)
expr_stmt|;
comment|// validate the destination
if|if
condition|(
name|dst
operator|.
name|equals
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"The source "
operator|+
name|src
operator|+
literal|" and destination "
operator|+
name|dst
operator|+
literal|" are the same"
argument_list|)
throw|;
block|}
name|validateRenameDestination
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|srcInode
argument_list|)
expr_stmt|;
name|INodesInPath
name|dstIIP
init|=
name|getINodesInPath4Write
argument_list|(
name|dst
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstIIP
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|error
operator|=
literal|"rename destination cannot be the root"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
name|ezManager
operator|.
name|checkMoveValidity
argument_list|(
name|srcIIP
argument_list|,
name|dstIIP
argument_list|,
name|src
argument_list|)
expr_stmt|;
specifier|final
name|INode
name|dstInode
init|=
name|dstIIP
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|INodeDirectory
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectory
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstInode
operator|!=
literal|null
condition|)
block|{
comment|// Destination exists
name|validateRenameOverwrite
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|overwrite
argument_list|,
name|srcInode
argument_list|,
name|dstInode
argument_list|)
expr_stmt|;
name|checkSnapshot
argument_list|(
name|dstInode
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
name|INode
name|dstParent
init|=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstParent
operator|==
literal|null
condition|)
block|{
name|error
operator|=
literal|"rename destination parent "
operator|+
name|dst
operator|+
literal|" not found."
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|dstParent
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|error
operator|=
literal|"rename destination parent "
operator|+
name|dst
operator|+
literal|" is a file."
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
name|error
argument_list|)
throw|;
block|}
comment|// Ensure dst has quota to accommodate rename
name|verifyFsLimitsForRename
argument_list|(
name|srcIIP
argument_list|,
name|dstIIP
argument_list|)
expr_stmt|;
name|verifyQuotaForRename
argument_list|(
name|srcIIP
operator|.
name|getINodes
argument_list|()
argument_list|,
name|dstIIP
operator|.
name|getINodes
argument_list|()
argument_list|)
expr_stmt|;
name|RenameOperation
name|tx
init|=
operator|new
name|RenameOperation
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|srcIIP
argument_list|,
name|dstIIP
argument_list|)
decl_stmt|;
name|boolean
name|undoRemoveSrc
init|=
literal|true
decl_stmt|;
specifier|final
name|long
name|removedSrc
init|=
name|removeLastINode
argument_list|(
name|srcIIP
argument_list|)
decl_stmt|;
if|if
condition|(
name|removedSrc
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
literal|"Failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because the source can not be removed"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
name|boolean
name|undoRemoveDst
init|=
literal|false
decl_stmt|;
name|INode
name|removedDst
init|=
literal|null
decl_stmt|;
name|long
name|removedNum
init|=
literal|0
decl_stmt|;
try|try
block|{
if|if
condition|(
name|dstInode
operator|!=
literal|null
condition|)
block|{
comment|// dst exists remove it
if|if
condition|(
operator|(
name|removedNum
operator|=
name|removeLastINode
argument_list|(
name|dstIIP
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|removedDst
operator|=
name|dstIIP
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
name|undoRemoveDst
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// add src as dst to complete rename
if|if
condition|(
name|tx
operator|.
name|addSourceToDestination
argument_list|()
condition|)
block|{
name|undoRemoveSrc
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|src
operator|+
literal|" is renamed to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|tx
operator|.
name|updateMtimeAndLease
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
comment|// Collect the blocks and remove the lease for previous dst
name|boolean
name|filesDeleted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|removedDst
operator|!=
literal|null
condition|)
block|{
name|undoRemoveDst
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|removedNum
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
init|=
operator|new
name|ChunkedArrayList
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|removedDst
operator|.
name|isInLatestSnapshot
argument_list|(
name|dstIIP
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
condition|)
block|{
name|removedDst
operator|.
name|destroyAndCollectBlocks
argument_list|(
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|)
expr_stmt|;
name|filesDeleted
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|filesDeleted
operator|=
name|removedDst
operator|.
name|cleanSubtree
argument_list|(
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|,
name|dstIIP
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
literal|true
argument_list|)
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
operator|>=
literal|0
expr_stmt|;
block|}
name|getFSNamesystem
argument_list|()
operator|.
name|removePathAndBlocks
argument_list|(
name|src
argument_list|,
literal|null
argument_list|,
name|removedINodes
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|snapshottableDirs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// There are snapshottable directories (without snapshots) to be
comment|// deleted. Need to update the SnapshotManager.
name|namesystem
operator|.
name|removeSnapshottableDirs
argument_list|(
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
name|tx
operator|.
name|updateQuotasInSourceTree
argument_list|()
expr_stmt|;
return|return
name|filesDeleted
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|undoRemoveSrc
condition|)
block|{
name|tx
operator|.
name|restoreSource
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|undoRemoveDst
condition|)
block|{
comment|// Rename failed - restore dst
if|if
condition|(
name|dstParent
operator|.
name|isDirectory
argument_list|()
operator|&&
name|dstParent
operator|.
name|asDirectory
argument_list|()
operator|.
name|isWithSnapshot
argument_list|()
condition|)
block|{
name|dstParent
operator|.
name|asDirectory
argument_list|()
operator|.
name|undoRename4DstParent
argument_list|(
name|removedDst
argument_list|,
name|dstIIP
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addLastINodeNoQuotaCheck
argument_list|(
name|dstIIP
argument_list|,
name|removedDst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removedDst
operator|.
name|isReference
argument_list|()
condition|)
block|{
specifier|final
name|INodeReference
name|removedDstRef
init|=
name|removedDst
operator|.
name|asReference
argument_list|()
decl_stmt|;
specifier|final
name|INodeReference
operator|.
name|WithCount
name|wc
init|=
operator|(
name|WithCount
operator|)
name|removedDstRef
operator|.
name|getReferredINode
argument_list|()
operator|.
name|asReference
argument_list|()
decl_stmt|;
name|wc
operator|.
name|addReference
argument_list|(
name|removedDstRef
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rename from "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" failed."
argument_list|)
throw|;
block|}
DECL|method|validateRenameOverwrite (String src, String dst, boolean overwrite, INode srcInode, INode dstInode)
specifier|private
specifier|static
name|void
name|validateRenameOverwrite
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|INode
name|srcInode
parameter_list|,
name|INode
name|dstInode
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|error
decl_stmt|;
comment|// It's OK to rename a file to a symlink and vice versa
if|if
condition|(
name|dstInode
operator|.
name|isDirectory
argument_list|()
operator|!=
name|srcInode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|error
operator|=
literal|"Source "
operator|+
name|src
operator|+
literal|" and destination "
operator|+
name|dst
operator|+
literal|" must both be directories"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
comment|// If destination exists, overwrite flag must be true
name|error
operator|=
literal|"rename destination "
operator|+
name|dst
operator|+
literal|" already exists"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
name|dstInode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
specifier|final
name|ReadOnlyList
argument_list|<
name|INode
argument_list|>
name|children
init|=
name|dstInode
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenList
argument_list|(
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|error
operator|=
literal|"rename destination directory is not empty: "
operator|+
name|dst
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|validateRenameDestination (String src, String dst, INode srcInode)
specifier|private
specifier|static
name|void
name|validateRenameDestination
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|INode
name|srcInode
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|error
decl_stmt|;
if|if
condition|(
name|srcInode
operator|.
name|isSymlink
argument_list|()
operator|&&
name|dst
operator|.
name|equals
argument_list|(
name|srcInode
operator|.
name|asSymlink
argument_list|()
operator|.
name|getSymlinkString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Cannot rename symlink "
operator|+
name|src
operator|+
literal|" to its target "
operator|+
name|dst
argument_list|)
throw|;
block|}
comment|// dst cannot be a directory or a file under src
if|if
condition|(
name|dst
operator|.
name|startsWith
argument_list|(
name|src
argument_list|)
operator|&&
name|dst
operator|.
name|charAt
argument_list|(
name|src
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|Path
operator|.
name|SEPARATOR_CHAR
condition|)
block|{
name|error
operator|=
literal|"Rename destination "
operator|+
name|dst
operator|+
literal|" is a directory or file under source "
operator|+
name|src
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
block|}
DECL|method|validateRenameSource (String src, INodesInPath srcIIP)
specifier|private
specifier|static
name|void
name|validateRenameSource
parameter_list|(
name|String
name|src
parameter_list|,
name|INodesInPath
name|srcIIP
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|error
decl_stmt|;
specifier|final
name|INode
name|srcInode
init|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
comment|// validate source
if|if
condition|(
name|srcInode
operator|==
literal|null
condition|)
block|{
name|error
operator|=
literal|"rename source "
operator|+
name|src
operator|+
literal|" is not found."
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcIIP
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|error
operator|=
literal|"rename source cannot be the root"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
comment|// srcInode and its subtree cannot contain snapshottable directories with
comment|// snapshots
name|checkSnapshot
argument_list|(
name|srcInode
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|class|RenameOperation
specifier|private
class|class
name|RenameOperation
block|{
DECL|field|srcIIP
specifier|private
specifier|final
name|INodesInPath
name|srcIIP
decl_stmt|;
DECL|field|dstIIP
specifier|private
specifier|final
name|INodesInPath
name|dstIIP
decl_stmt|;
DECL|field|src
specifier|private
specifier|final
name|String
name|src
decl_stmt|;
DECL|field|dst
specifier|private
specifier|final
name|String
name|dst
decl_stmt|;
DECL|field|srcChild
specifier|private
name|INode
name|srcChild
decl_stmt|;
DECL|field|withCount
specifier|private
specifier|final
name|INodeReference
operator|.
name|WithCount
name|withCount
decl_stmt|;
DECL|field|srcRefDstSnapshot
specifier|private
specifier|final
name|int
name|srcRefDstSnapshot
decl_stmt|;
DECL|field|srcParent
specifier|private
specifier|final
name|INodeDirectory
name|srcParent
decl_stmt|;
DECL|field|srcChildName
specifier|private
specifier|final
name|byte
index|[]
name|srcChildName
decl_stmt|;
DECL|field|isSrcInSnapshot
specifier|private
specifier|final
name|boolean
name|isSrcInSnapshot
decl_stmt|;
DECL|field|srcChildIsReference
specifier|private
specifier|final
name|boolean
name|srcChildIsReference
decl_stmt|;
DECL|field|oldSrcCounts
specifier|private
specifier|final
name|Quota
operator|.
name|Counts
name|oldSrcCounts
decl_stmt|;
DECL|method|RenameOperation (String src, String dst, INodesInPath srcIIP, INodesInPath dstIIP)
specifier|private
name|RenameOperation
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|INodesInPath
name|srcIIP
parameter_list|,
name|INodesInPath
name|dstIIP
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|this
operator|.
name|srcIIP
operator|=
name|srcIIP
expr_stmt|;
name|this
operator|.
name|dstIIP
operator|=
name|dstIIP
expr_stmt|;
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|srcChild
operator|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
name|srcChildName
operator|=
name|srcChild
operator|.
name|getLocalNameBytes
argument_list|()
expr_stmt|;
name|isSrcInSnapshot
operator|=
name|srcChild
operator|.
name|isInLatestSnapshot
argument_list|(
name|srcIIP
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
name|srcChildIsReference
operator|=
name|srcChild
operator|.
name|isReference
argument_list|()
expr_stmt|;
name|srcParent
operator|=
name|srcIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
expr_stmt|;
comment|// Record the snapshot on srcChild. After the rename, before any new
comment|// snapshot is taken on the dst tree, changes will be recorded in the latest
comment|// snapshot of the src tree.
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
name|srcChild
operator|.
name|recordModification
argument_list|(
name|srcIIP
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// check srcChild for reference
name|srcRefDstSnapshot
operator|=
name|srcChildIsReference
condition|?
name|srcChild
operator|.
name|asReference
argument_list|()
operator|.
name|getDstSnapshotId
argument_list|()
else|:
name|Snapshot
operator|.
name|CURRENT_STATE_ID
expr_stmt|;
name|oldSrcCounts
operator|=
name|Quota
operator|.
name|Counts
operator|.
name|newInstance
argument_list|()
expr_stmt|;
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
specifier|final
name|INodeReference
operator|.
name|WithName
name|withName
init|=
name|srcIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
operator|.
name|replaceChild4ReferenceWithName
argument_list|(
name|srcChild
argument_list|,
name|srcIIP
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
decl_stmt|;
name|withCount
operator|=
operator|(
name|INodeReference
operator|.
name|WithCount
operator|)
name|withName
operator|.
name|getReferredINode
argument_list|()
expr_stmt|;
name|srcChild
operator|=
name|withName
expr_stmt|;
name|srcIIP
operator|.
name|setLastINode
argument_list|(
name|srcChild
argument_list|)
expr_stmt|;
comment|// get the counts before rename
name|withCount
operator|.
name|getReferredINode
argument_list|()
operator|.
name|computeQuotaUsage
argument_list|(
name|oldSrcCounts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|srcChildIsReference
condition|)
block|{
comment|// srcChild is reference but srcChild is not in latest snapshot
name|withCount
operator|=
operator|(
name|WithCount
operator|)
name|srcChild
operator|.
name|asReference
argument_list|()
operator|.
name|getReferredINode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|withCount
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|addSourceToDestination ()
name|boolean
name|addSourceToDestination
parameter_list|()
block|{
specifier|final
name|INode
name|dstParent
init|=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
name|srcChild
operator|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
specifier|final
name|byte
index|[]
name|dstChildName
init|=
name|dstIIP
operator|.
name|getLastLocalName
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|toDst
decl_stmt|;
if|if
condition|(
name|withCount
operator|==
literal|null
condition|)
block|{
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|dstChildName
argument_list|)
expr_stmt|;
name|toDst
operator|=
name|srcChild
expr_stmt|;
block|}
else|else
block|{
name|withCount
operator|.
name|getReferredINode
argument_list|()
operator|.
name|setLocalName
argument_list|(
name|dstChildName
argument_list|)
expr_stmt|;
name|int
name|dstSnapshotId
init|=
name|dstIIP
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|toDst
operator|=
operator|new
name|INodeReference
operator|.
name|DstReference
argument_list|(
name|dstParent
operator|.
name|asDirectory
argument_list|()
argument_list|,
name|withCount
argument_list|,
name|dstSnapshotId
argument_list|)
expr_stmt|;
block|}
return|return
name|addLastINodeNoQuotaCheck
argument_list|(
name|dstIIP
argument_list|,
name|toDst
argument_list|)
return|;
block|}
DECL|method|updateMtimeAndLease (long timestamp)
name|void
name|updateMtimeAndLease
parameter_list|(
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|srcParent
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|srcIIP
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|INode
name|dstParent
init|=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
name|dstParent
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|dstIIP
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
comment|// update moved lease with new filename
name|getFSNamesystem
argument_list|()
operator|.
name|unprotectedChangeLease
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
DECL|method|restoreSource ()
name|void
name|restoreSource
parameter_list|()
throws|throws
name|QuotaExceededException
block|{
comment|// Rename failed - restore src
specifier|final
name|INode
name|oldSrcChild
init|=
name|srcChild
decl_stmt|;
comment|// put it back
if|if
condition|(
name|withCount
operator|==
literal|null
condition|)
block|{
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|srcChildIsReference
condition|)
block|{
comment|// src must be in snapshot
comment|// the withCount node will no longer be used thus no need to update
comment|// its reference number here
name|srcChild
operator|=
name|withCount
operator|.
name|getReferredINode
argument_list|()
expr_stmt|;
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|withCount
operator|.
name|removeReference
argument_list|(
name|oldSrcChild
operator|.
name|asReference
argument_list|()
argument_list|)
expr_stmt|;
name|srcChild
operator|=
operator|new
name|INodeReference
operator|.
name|DstReference
argument_list|(
name|srcParent
argument_list|,
name|withCount
argument_list|,
name|srcRefDstSnapshot
argument_list|)
expr_stmt|;
name|withCount
operator|.
name|getReferredINode
argument_list|()
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
name|srcParent
operator|.
name|undoRename4ScrParent
argument_list|(
name|oldSrcChild
operator|.
name|asReference
argument_list|()
argument_list|,
name|srcChild
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// srcParent is not an INodeDirectoryWithSnapshot, we only need to add
comment|// the srcChild back
name|addLastINodeNoQuotaCheck
argument_list|(
name|srcIIP
argument_list|,
name|srcChild
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateQuotasInSourceTree ()
name|void
name|updateQuotasInSourceTree
parameter_list|()
throws|throws
name|QuotaExceededException
block|{
comment|// update the quota usage in src tree
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
comment|// get the counts after rename
name|Quota
operator|.
name|Counts
name|newSrcCounts
init|=
name|srcChild
operator|.
name|computeQuotaUsage
argument_list|(
name|Quota
operator|.
name|Counts
operator|.
name|newInstance
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|newSrcCounts
operator|.
name|subtract
argument_list|(
name|oldSrcCounts
argument_list|)
expr_stmt|;
name|srcParent
operator|.
name|addSpaceConsumed
argument_list|(
name|newSrcCounts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
name|newSrcCounts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Set file replication    *     * @param src file name    * @param replication new replication    * @param blockRepls block replications - output parameter    * @return array of file blocks    * @throws QuotaExceededException    * @throws SnapshotAccessControlException     */
DECL|method|setReplication (String src, short replication, short[] blockRepls)
name|Block
index|[]
name|setReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|,
name|short
index|[]
name|blockRepls
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedSetReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
name|blockRepls
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetReplication (String src, short replication, short[] blockRepls)
name|Block
index|[]
name|unprotectedSetReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|,
name|short
index|[]
name|blockRepls
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
operator|||
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|INodeFile
name|file
init|=
name|inode
operator|.
name|asFile
argument_list|()
decl_stmt|;
specifier|final
name|short
name|oldBR
init|=
name|file
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
comment|// before setFileReplication, check for increasing block replication.
comment|// if replication> oldBR, then newBR == replication.
comment|// if replication< oldBR, we don't know newBR yet.
if|if
condition|(
name|replication
operator|>
name|oldBR
condition|)
block|{
name|long
name|dsDelta
init|=
operator|(
name|replication
operator|-
name|oldBR
operator|)
operator|*
operator|(
name|file
operator|.
name|diskspaceConsumed
argument_list|()
operator|/
name|oldBR
operator|)
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
name|dsDelta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|file
operator|.
name|setFileReplication
argument_list|(
name|replication
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|short
name|newBR
init|=
name|file
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
comment|// check newBR< oldBR case.
if|if
condition|(
name|newBR
operator|<
name|oldBR
condition|)
block|{
name|long
name|dsDelta
init|=
operator|(
name|newBR
operator|-
name|oldBR
operator|)
operator|*
operator|(
name|file
operator|.
name|diskspaceConsumed
argument_list|()
operator|/
name|newBR
operator|)
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
name|dsDelta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blockRepls
operator|!=
literal|null
condition|)
block|{
name|blockRepls
index|[
literal|0
index|]
operator|=
name|oldBR
expr_stmt|;
name|blockRepls
index|[
literal|1
index|]
operator|=
name|newBR
expr_stmt|;
block|}
return|return
name|file
operator|.
name|getBlocks
argument_list|()
return|;
block|}
comment|/** Set block storage policy for a directory */
DECL|method|setStoragePolicy (String src, byte policyId)
name|void
name|setStoragePolicy
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
name|policyId
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedSetStoragePolicy
argument_list|(
name|src
argument_list|,
name|policyId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetStoragePolicy (String src, byte policyId)
name|void
name|unprotectedSetStoragePolicy
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
name|policyId
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File/Directory does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
specifier|final
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|inode
operator|.
name|asFile
argument_list|()
operator|.
name|setStoragePolicyID
argument_list|(
name|policyId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|setDirStoragePolicy
argument_list|(
name|inode
operator|.
name|asDirectory
argument_list|()
argument_list|,
name|policyId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|src
operator|+
literal|" is not a file or directory"
argument_list|)
throw|;
block|}
block|}
DECL|method|setDirStoragePolicy (INodeDirectory inode, byte policyId, int latestSnapshotId)
specifier|private
name|void
name|setDirStoragePolicy
parameter_list|(
name|INodeDirectory
name|inode
parameter_list|,
name|byte
name|policyId
parameter_list|,
name|int
name|latestSnapshotId
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|XAttr
argument_list|>
name|existingXAttrs
init|=
name|XAttrStorage
operator|.
name|readINodeXAttrs
argument_list|(
name|inode
argument_list|)
decl_stmt|;
name|XAttr
name|xAttr
init|=
name|BlockStoragePolicySuite
operator|.
name|buildXAttr
argument_list|(
name|policyId
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|XAttr
argument_list|>
name|newXAttrs
init|=
name|setINodeXAttrs
argument_list|(
name|existingXAttrs
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|xAttr
argument_list|)
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|XAttrSetFlag
operator|.
name|CREATE
argument_list|,
name|XAttrSetFlag
operator|.
name|REPLACE
argument_list|)
argument_list|)
decl_stmt|;
name|XAttrStorage
operator|.
name|updateINodeXAttrs
argument_list|(
name|inode
argument_list|,
name|newXAttrs
argument_list|,
name|latestSnapshotId
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param path the file path    * @return the block size of the file.     */
DECL|method|getPreferredBlockSize (String path)
name|long
name|getPreferredBlockSize
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|getNode
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
argument_list|,
name|path
argument_list|)
operator|.
name|getPreferredBlockSize
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setPermission (String src, FsPermission permission)
name|void
name|setPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedSetPermission
argument_list|(
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetPermission (String src, FsPermission permissions)
name|void
name|unprotectedSetPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permissions
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
name|int
name|snapshotId
init|=
name|inodesInPath
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|inode
operator|.
name|setPermission
argument_list|(
name|permissions
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
DECL|method|setOwner (String src, String username, String groupname)
name|void
name|setOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedSetOwner
argument_list|(
name|src
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetOwner (String src, String username, String groupname)
name|void
name|unprotectedSetOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|username
operator|!=
literal|null
condition|)
block|{
name|inode
operator|=
name|inode
operator|.
name|setUser
argument_list|(
name|username
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupname
operator|!=
literal|null
condition|)
block|{
name|inode
operator|.
name|setGroup
argument_list|(
name|groupname
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Concat all the blocks from srcs to trg and delete the srcs files    */
DECL|method|concat (String target, String[] srcs, long timestamp)
name|void
name|concat
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
throws|,
name|SnapshotException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// actual move
name|unprotectedConcat
argument_list|(
name|target
argument_list|,
name|srcs
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Concat all the blocks from srcs to trg and delete the srcs files    * @param target target file to move the blocks to    * @param srcs list of file to move the blocks from    */
DECL|method|unprotectedConcat (String target, String [] srcs, long timestamp)
name|void
name|unprotectedConcat
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
throws|,
name|SnapshotException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSNamesystem.concat to "
operator|+
name|target
argument_list|)
expr_stmt|;
block|}
comment|// do the move
specifier|final
name|INodesInPath
name|trgIIP
init|=
name|getINodesInPath4Write
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|trgINodes
init|=
name|trgIIP
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|INodeFile
name|trgInode
init|=
name|trgIIP
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|INodeDirectory
name|trgParent
init|=
name|trgINodes
index|[
name|trgINodes
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
specifier|final
name|int
name|trgLatestSnapshot
init|=
name|trgIIP
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
specifier|final
name|INodeFile
index|[]
name|allSrcInodes
init|=
operator|new
name|INodeFile
index|[
name|srcs
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|srcs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|srcs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
specifier|final
name|int
name|latest
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
comment|// check if the file in the latest snapshot
if|if
condition|(
name|inode
operator|.
name|isInLatestSnapshot
argument_list|(
name|latest
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
literal|"Concat: the source file "
operator|+
name|srcs
index|[
name|i
index|]
operator|+
literal|" is in snapshot "
operator|+
name|latest
argument_list|)
throw|;
block|}
comment|// check if the file has other references.
if|if
condition|(
name|inode
operator|.
name|isReference
argument_list|()
operator|&&
operator|(
operator|(
name|INodeReference
operator|.
name|WithCount
operator|)
name|inode
operator|.
name|asReference
argument_list|()
operator|.
name|getReferredINode
argument_list|()
operator|)
operator|.
name|getReferenceCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
literal|"Concat: the source file "
operator|+
name|srcs
index|[
name|i
index|]
operator|+
literal|" is referred by some other reference in some snapshot."
argument_list|)
throw|;
block|}
name|allSrcInodes
index|[
name|i
index|]
operator|=
name|inode
operator|.
name|asFile
argument_list|()
expr_stmt|;
block|}
name|trgInode
operator|.
name|concatBlocks
argument_list|(
name|allSrcInodes
argument_list|)
expr_stmt|;
comment|// since we are in the same dir - we can use same parent to remove files
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|INodeFile
name|nodeToRemove
range|:
name|allSrcInodes
control|)
block|{
if|if
condition|(
name|nodeToRemove
operator|==
literal|null
condition|)
continue|continue;
name|nodeToRemove
operator|.
name|setBlocks
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|trgParent
operator|.
name|removeChild
argument_list|(
name|nodeToRemove
argument_list|,
name|trgLatestSnapshot
argument_list|)
expr_stmt|;
name|inodeMap
operator|.
name|remove
argument_list|(
name|nodeToRemove
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|trgInode
operator|.
name|setModificationTime
argument_list|(
name|timestamp
argument_list|,
name|trgLatestSnapshot
argument_list|)
expr_stmt|;
name|trgParent
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|trgLatestSnapshot
argument_list|)
expr_stmt|;
comment|// update quota on the parent directory ('count' files removed, 0 space)
name|unprotectedUpdateCount
argument_list|(
name|trgIIP
argument_list|,
name|trgINodes
operator|.
name|length
operator|-
literal|1
argument_list|,
operator|-
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete the target directory and collect the blocks under it    *     * @param src Path of a directory to delete    * @param collectedBlocks Blocks under the deleted directory    * @param removedINodes INodes that should be removed from {@link #inodeMap}    * @return the number of files that have been removed    */
DECL|method|delete (String src, BlocksMapUpdateInfo collectedBlocks, List<INode> removedINodes, long mtime)
name|long
name|delete
parameter_list|(
name|String
name|src
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.delete: "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|filesRemoved
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|deleteAllowed
argument_list|(
name|inodesInPath
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|filesRemoved
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|INodeDirectory
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectory
argument_list|>
argument_list|()
decl_stmt|;
name|checkSnapshot
argument_list|(
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
name|filesRemoved
operator|=
name|unprotectedDelete
argument_list|(
name|inodesInPath
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|removeSnapshottableDirs
argument_list|(
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
return|return
name|filesRemoved
return|;
block|}
DECL|method|deleteAllowed (final INodesInPath iip, final String src)
specifier|private
specifier|static
name|boolean
name|deleteAllowed
parameter_list|(
specifier|final
name|INodesInPath
name|iip
parameter_list|,
specifier|final
name|String
name|src
parameter_list|)
block|{
specifier|final
name|INode
index|[]
name|inodes
init|=
name|iip
operator|.
name|getINodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|inodes
operator|==
literal|null
operator|||
name|inodes
operator|.
name|length
operator|==
literal|0
operator|||
name|inodes
index|[
name|inodes
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
literal|"failed to remove "
operator|+
name|src
operator|+
literal|" because it does not exist"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|inodes
operator|.
name|length
operator|==
literal|1
condition|)
block|{
comment|// src is the root
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
literal|"failed to remove "
operator|+
name|src
operator|+
literal|" because the root is not allowed to be deleted"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @return true if the path is a non-empty directory; otherwise, return false.    */
DECL|method|isNonEmptyDirectory (String path)
name|boolean
name|isNonEmptyDirectory
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|getLastINodeInPath
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
operator|||
operator|!
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//not found or not a directory
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|s
init|=
name|inodesInPath
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
return|return
operator|!
name|inode
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenList
argument_list|(
name|s
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Delete a path from the name space    * Update the count at each ancestor directory with quota    *<br>    * Note: This is to be used by {@link FSEditLog} only.    *<br>    * @param src a string representation of a path to an inode    * @param mtime the time the inode is removed    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|unprotectedDelete (String src, long mtime)
name|void
name|unprotectedDelete
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
init|=
operator|new
name|ChunkedArrayList
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|long
name|filesRemoved
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|deleteAllowed
argument_list|(
name|inodesInPath
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|INodeDirectory
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectory
argument_list|>
argument_list|()
decl_stmt|;
name|checkSnapshot
argument_list|(
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
name|filesRemoved
operator|=
name|unprotectedDelete
argument_list|(
name|inodesInPath
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|removeSnapshottableDirs
argument_list|(
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filesRemoved
operator|>=
literal|0
condition|)
block|{
name|getFSNamesystem
argument_list|()
operator|.
name|removePathAndBlocks
argument_list|(
name|src
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a path from the name space    * Update the count at each ancestor directory with quota    * @param iip the inodes resolved from the path    * @param collectedBlocks blocks collected from the deleted path    * @param removedINodes inodes that should be removed from {@link #inodeMap}    * @param mtime the time the inode is removed    * @return the number of inodes deleted; 0 if no inodes are deleted.    */
DECL|method|unprotectedDelete (INodesInPath iip, BlocksMapUpdateInfo collectedBlocks, List<INode> removedINodes, long mtime)
name|long
name|unprotectedDelete
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// check if target node exists
name|INode
name|targetNode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// record modification
specifier|final
name|int
name|latestSnapshot
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|targetNode
operator|.
name|recordModification
argument_list|(
name|latestSnapshot
argument_list|)
expr_stmt|;
comment|// Remove the node from the namespace
name|long
name|removed
init|=
name|removeLastINode
argument_list|(
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// set the parent's modification time
specifier|final
name|INodeDirectory
name|parent
init|=
name|targetNode
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|parent
operator|.
name|updateModificationTime
argument_list|(
name|mtime
argument_list|,
name|latestSnapshot
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// collect block
if|if
condition|(
operator|!
name|targetNode
operator|.
name|isInLatestSnapshot
argument_list|(
name|latestSnapshot
argument_list|)
condition|)
block|{
name|targetNode
operator|.
name|destroyAndCollectBlocks
argument_list|(
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Quota
operator|.
name|Counts
name|counts
init|=
name|targetNode
operator|.
name|cleanSubtree
argument_list|(
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|,
name|latestSnapshot
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|parent
operator|.
name|addSpaceConsumed
argument_list|(
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
name|targetNode
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" is removed"
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
comment|/**    * Check if the given INode (or one of its descendants) is snapshottable and    * already has snapshots.    *     * @param target The given INode    * @param snapshottableDirs The list of directories that are snapshottable     *                          but do not have snapshots yet    */
DECL|method|checkSnapshot (INode target, List<INodeDirectory> snapshottableDirs)
specifier|private
specifier|static
name|void
name|checkSnapshot
parameter_list|(
name|INode
name|target
parameter_list|,
name|List
argument_list|<
name|INodeDirectory
argument_list|>
name|snapshottableDirs
parameter_list|)
throws|throws
name|SnapshotException
block|{
if|if
condition|(
name|target
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|INodeDirectory
name|targetDir
init|=
name|target
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
name|DirectorySnapshottableFeature
name|sf
init|=
name|targetDir
operator|.
name|getDirectorySnapshottableFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sf
operator|.
name|getNumSnapshots
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|fullPath
init|=
name|targetDir
operator|.
name|getFullPathName
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SnapshotException
argument_list|(
literal|"The directory "
operator|+
name|fullPath
operator|+
literal|" cannot be deleted since "
operator|+
name|fullPath
operator|+
literal|" is snapshottable and already has snapshots"
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|snapshottableDirs
operator|!=
literal|null
condition|)
block|{
name|snapshottableDirs
operator|.
name|add
argument_list|(
name|targetDir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|INode
name|child
range|:
name|targetDir
operator|.
name|getChildrenList
argument_list|(
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
control|)
block|{
name|checkSnapshot
argument_list|(
name|child
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getStoragePolicyID (byte inodePolicy, byte parentPolicy)
specifier|private
name|byte
name|getStoragePolicyID
parameter_list|(
name|byte
name|inodePolicy
parameter_list|,
name|byte
name|parentPolicy
parameter_list|)
block|{
return|return
name|inodePolicy
operator|!=
name|BlockStoragePolicySuite
operator|.
name|ID_UNSPECIFIED
condition|?
name|inodePolicy
else|:
name|parentPolicy
return|;
block|}
comment|/**    * Get a partial listing of the indicated directory    *    * We will stop when any of the following conditions is met:    * 1) this.lsLimit files have been added    * 2) needLocation is true AND enough files have been added such    * that at least this.lsLimit block locations are in the response    *    * @param src the directory name    * @param startAfter the name to start listing after    * @param needLocation if block locations are returned    * @return a partial listing starting after startAfter    */
DECL|method|getListing (String src, byte[] startAfter, boolean needLocation, boolean isSuperUser)
name|DirectoryListing
name|getListing
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|,
name|boolean
name|isSuperUser
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isRawPath
init|=
name|isReservedRawName
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|srcs
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
condition|)
block|{
return|return
name|getSnapshotsListing
argument_list|(
name|srcs
argument_list|,
name|startAfter
argument_list|)
return|;
block|}
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|getINodesInPath
argument_list|(
name|srcs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|snapshot
init|=
name|inodesInPath
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|targetNode
init|=
name|inodes
index|[
name|inodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|byte
name|parentStoragePolicy
init|=
name|isSuperUser
condition|?
name|targetNode
operator|.
name|getStoragePolicyID
argument_list|()
else|:
name|BlockStoragePolicySuite
operator|.
name|ID_UNSPECIFIED
decl_stmt|;
if|if
condition|(
operator|!
name|targetNode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
return|return
operator|new
name|DirectoryListing
argument_list|(
operator|new
name|HdfsFileStatus
index|[]
block|{
name|createFileStatus
argument_list|(
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|,
name|targetNode
argument_list|,
name|needLocation
argument_list|,
name|parentStoragePolicy
argument_list|,
name|snapshot
argument_list|,
name|isRawPath
argument_list|,
name|inodesInPath
argument_list|)
block|}
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|final
name|INodeDirectory
name|dirInode
init|=
name|targetNode
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
specifier|final
name|ReadOnlyList
argument_list|<
name|INode
argument_list|>
name|contents
init|=
name|dirInode
operator|.
name|getChildrenList
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|int
name|startChild
init|=
name|INodeDirectory
operator|.
name|nextChild
argument_list|(
name|contents
argument_list|,
name|startAfter
argument_list|)
decl_stmt|;
name|int
name|totalNumChildren
init|=
name|contents
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numOfListing
init|=
name|Math
operator|.
name|min
argument_list|(
name|totalNumChildren
operator|-
name|startChild
argument_list|,
name|this
operator|.
name|lsLimit
argument_list|)
decl_stmt|;
name|int
name|locationBudget
init|=
name|this
operator|.
name|lsLimit
decl_stmt|;
name|int
name|listingCnt
init|=
literal|0
decl_stmt|;
name|HdfsFileStatus
name|listing
index|[]
init|=
operator|new
name|HdfsFileStatus
index|[
name|numOfListing
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
argument_list|<
name|numOfListing
operator|&&
name|locationBudget
argument_list|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|INode
name|cur
init|=
name|contents
operator|.
name|get
argument_list|(
name|startChild
operator|+
name|i
argument_list|)
decl_stmt|;
name|byte
name|curPolicy
init|=
name|isSuperUser
operator|&&
operator|!
name|cur
operator|.
name|isSymlink
argument_list|()
condition|?
name|cur
operator|.
name|getLocalStoragePolicyID
argument_list|()
else|:
name|BlockStoragePolicySuite
operator|.
name|ID_UNSPECIFIED
decl_stmt|;
name|listing
index|[
name|i
index|]
operator|=
name|createFileStatus
argument_list|(
name|cur
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|cur
argument_list|,
name|needLocation
argument_list|,
name|getStoragePolicyID
argument_list|(
name|curPolicy
argument_list|,
name|parentStoragePolicy
argument_list|)
argument_list|,
name|snapshot
argument_list|,
name|isRawPath
argument_list|,
name|inodesInPath
argument_list|)
expr_stmt|;
name|listingCnt
operator|++
expr_stmt|;
if|if
condition|(
name|needLocation
condition|)
block|{
comment|// Once we  hit lsLimit locations, stop.
comment|// This helps to prevent excessively large response payloads.
comment|// Approximate #locations with locatedBlockCount() * repl_factor
name|LocatedBlocks
name|blks
init|=
operator|(
operator|(
name|HdfsLocatedFileStatus
operator|)
name|listing
index|[
name|i
index|]
operator|)
operator|.
name|getBlockLocations
argument_list|()
decl_stmt|;
name|locationBudget
operator|-=
operator|(
name|blks
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|blks
operator|.
name|locatedBlockCount
argument_list|()
operator|*
name|listing
index|[
name|i
index|]
operator|.
name|getReplication
argument_list|()
expr_stmt|;
block|}
block|}
comment|// truncate return array if necessary
if|if
condition|(
name|listingCnt
operator|<
name|numOfListing
condition|)
block|{
name|listing
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|listing
argument_list|,
name|listingCnt
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DirectoryListing
argument_list|(
name|listing
argument_list|,
name|totalNumChildren
operator|-
name|startChild
operator|-
name|listingCnt
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a listing of all the snapshots of a snapshottable directory    */
DECL|method|getSnapshotsListing (String src, byte[] startAfter)
specifier|private
name|DirectoryListing
name|getSnapshotsListing
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|hasReadLock
argument_list|()
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|src
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
argument_list|,
literal|"%s does not end with %s"
argument_list|,
name|src
argument_list|,
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
expr_stmt|;
specifier|final
name|String
name|dirPath
init|=
name|normalizePath
argument_list|(
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|node
init|=
name|this
operator|.
name|getINode
argument_list|(
name|dirPath
argument_list|)
decl_stmt|;
specifier|final
name|INodeDirectory
name|dirNode
init|=
name|INodeDirectory
operator|.
name|valueOf
argument_list|(
name|node
argument_list|,
name|dirPath
argument_list|)
decl_stmt|;
specifier|final
name|DirectorySnapshottableFeature
name|sf
init|=
name|dirNode
operator|.
name|getDirectorySnapshottableFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
literal|"Directory is not a snapshottable directory: "
operator|+
name|dirPath
argument_list|)
throw|;
block|}
specifier|final
name|ReadOnlyList
argument_list|<
name|Snapshot
argument_list|>
name|snapshots
init|=
name|sf
operator|.
name|getSnapshotList
argument_list|()
decl_stmt|;
name|int
name|skipSize
init|=
name|ReadOnlyList
operator|.
name|Util
operator|.
name|binarySearch
argument_list|(
name|snapshots
argument_list|,
name|startAfter
argument_list|)
decl_stmt|;
name|skipSize
operator|=
name|skipSize
operator|<
literal|0
condition|?
operator|-
name|skipSize
operator|-
literal|1
else|:
name|skipSize
operator|+
literal|1
expr_stmt|;
name|int
name|numOfListing
init|=
name|Math
operator|.
name|min
argument_list|(
name|snapshots
operator|.
name|size
argument_list|()
operator|-
name|skipSize
argument_list|,
name|this
operator|.
name|lsLimit
argument_list|)
decl_stmt|;
specifier|final
name|HdfsFileStatus
name|listing
index|[]
init|=
operator|new
name|HdfsFileStatus
index|[
name|numOfListing
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfListing
condition|;
name|i
operator|++
control|)
block|{
name|Root
name|sRoot
init|=
name|snapshots
operator|.
name|get
argument_list|(
name|i
operator|+
name|skipSize
argument_list|)
operator|.
name|getRoot
argument_list|()
decl_stmt|;
name|listing
index|[
name|i
index|]
operator|=
name|createFileStatus
argument_list|(
name|sRoot
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|sRoot
argument_list|,
name|BlockStoragePolicySuite
operator|.
name|ID_UNSPECIFIED
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DirectoryListing
argument_list|(
name|listing
argument_list|,
name|snapshots
operator|.
name|size
argument_list|()
operator|-
name|skipSize
operator|-
name|numOfListing
argument_list|)
return|;
block|}
comment|/** Get the file info for a specific file.    * @param src The string representation of the path to the file    * @param resolveLink whether to throw UnresolvedLinkException    * @param isRawPath true if a /.reserved/raw pathname was passed by the user    * @param includeStoragePolicy whether to include storage policy    * @return object containing information regarding the file    *         or null if file not found    */
DECL|method|getFileInfo (String src, boolean resolveLink, boolean isRawPath, boolean includeStoragePolicy)
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|resolveLink
parameter_list|,
name|boolean
name|isRawPath
parameter_list|,
name|boolean
name|includeStoragePolicy
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|srcs
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
condition|)
block|{
return|return
name|getFileInfo4DotSnapshot
argument_list|(
name|srcs
argument_list|)
return|;
block|}
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|getINodesInPath
argument_list|(
name|srcs
argument_list|,
name|resolveLink
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|i
init|=
name|inodes
index|[
name|inodes
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|byte
name|policyId
init|=
name|includeStoragePolicy
operator|&&
name|i
operator|!=
literal|null
operator|&&
operator|!
name|i
operator|.
name|isSymlink
argument_list|()
condition|?
name|i
operator|.
name|getStoragePolicyID
argument_list|()
else|:
name|BlockStoragePolicySuite
operator|.
name|ID_UNSPECIFIED
decl_stmt|;
return|return
name|i
operator|==
literal|null
condition|?
literal|null
else|:
name|createFileStatus
argument_list|(
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|,
name|i
argument_list|,
name|policyId
argument_list|,
name|inodesInPath
operator|.
name|getPathSnapshotId
argument_list|()
argument_list|,
name|isRawPath
argument_list|,
name|inodesInPath
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Currently we only support "ls /xxx/.snapshot" which will return all the    * snapshots of a directory. The FSCommand Ls will first call getFileInfo to    * make sure the file/directory exists (before the real getListing call).    * Since we do not have a real INode for ".snapshot", we return an empty    * non-null HdfsFileStatus here.    */
DECL|method|getFileInfo4DotSnapshot (String src)
specifier|private
name|HdfsFileStatus
name|getFileInfo4DotSnapshot
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
if|if
condition|(
name|getINode4DotSnapshot
argument_list|(
name|src
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|HdfsFileStatus
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|,
operator|-
literal|1L
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|BlockStoragePolicySuite
operator|.
name|ID_UNSPECIFIED
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|getINode4DotSnapshot (String src)
specifier|private
name|INode
name|getINode4DotSnapshot
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|src
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
argument_list|,
literal|"%s does not end with %s"
argument_list|,
name|src
argument_list|,
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
expr_stmt|;
specifier|final
name|String
name|dirPath
init|=
name|normalizePath
argument_list|(
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|node
init|=
name|this
operator|.
name|getINode
argument_list|(
name|dirPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
operator|&&
name|node
operator|.
name|asDirectory
argument_list|()
operator|.
name|isSnapshottable
argument_list|()
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|getExistingPathINodes (byte[][] components)
name|INodesInPath
name|getExistingPathINodes
parameter_list|(
name|byte
index|[]
index|[]
name|components
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|components
argument_list|)
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getINode (String src)
specifier|public
name|INode
name|getINode
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|getLastINodeInPath
argument_list|(
name|src
argument_list|)
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getLastINodeInPath (String src)
specifier|public
name|INodesInPath
name|getLastINodeInPath
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getLastINodeInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getINodesInPath4Write (String src )
specifier|public
name|INodesInPath
name|getINodesInPath4Write
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|getINode4Write (String src)
specifier|public
name|INode
name|getINode4Write
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getINode4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**     * Check whether the filepath could be created    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|isValidToCreate (String src)
name|boolean
name|isValidToCreate
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|srcs
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
operator|!
name|srcs
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|getINode4Write
argument_list|(
name|srcs
argument_list|,
literal|false
argument_list|)
operator|==
literal|null
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check whether the path specifies a directory    */
DECL|method|isDir (String src)
name|boolean
name|isDir
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|node
init|=
name|getNode
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check whether the path specifies a directory    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|isDirMutable (String src)
name|boolean
name|isDirMutable
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|node
init|=
name|getINode4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Updates namespace and diskspace consumed for all    * directories until the parent directory of file represented by path.    *     * @param path path for the file.    * @param nsDelta the delta change of namespace    * @param dsDelta the delta change of diskspace    * @throws QuotaExceededException if the new count violates any quota limit    * @throws FileNotFoundException if path does not exist.    */
DECL|method|updateSpaceConsumed (String path, long nsDelta, long dsDelta)
name|void
name|updateSpaceConsumed
parameter_list|(
name|String
name|path
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|iip
operator|.
name|getLastINode
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Path not found: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|updateCount
argument_list|(
name|iip
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateCount (INodesInPath iip, long nsDelta, long dsDelta, boolean checkQuota)
specifier|private
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|updateCount
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|-
literal|1
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
block|}
comment|/** update count of each inode with quota    *     * @param iip inodes in a path    * @param numOfINodes the number of inodes to update starting from index 0    * @param nsDelta the delta change of namespace    * @param dsDelta the delta change of diskspace    * @param checkQuota if true then check if quota is exceeded    * @throws QuotaExceededException if the new count violates any quota limit    */
DECL|method|updateCount (INodesInPath iip, int numOfINodes, long nsDelta, long dsDelta, boolean checkQuota)
specifier|private
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
comment|//still initializing. do not check or update quotas.
return|return;
block|}
specifier|final
name|INode
index|[]
name|inodes
init|=
name|iip
operator|.
name|getINodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|numOfINodes
operator|>
name|inodes
operator|.
name|length
condition|)
block|{
name|numOfINodes
operator|=
name|inodes
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|checkQuota
operator|&&
operator|!
name|skipQuotaCheck
condition|)
block|{
name|verifyQuota
argument_list|(
name|inodes
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|unprotectedUpdateCount
argument_list|(
name|iip
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
comment|/**     * update quota of each inode and check to see if quota is exceeded.     * See {@link #updateCount(INodesInPath, long, long, boolean)}    */
DECL|method|updateCountNoQuotaCheck (INodesInPath inodesInPath, int numOfINodes, long nsDelta, long dsDelta)
specifier|private
name|void
name|updateCountNoQuotaCheck
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
try|try
block|{
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"BUG: unexpected exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * updates quota without verification    * callers responsibility is to make sure quota is not exceeded    */
DECL|method|unprotectedUpdateCount (INodesInPath inodesInPath, int numOfINodes, long nsDelta, long dsDelta)
specifier|private
specifier|static
name|void
name|unprotectedUpdateCount
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
block|{
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfINodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inodes
index|[
name|i
index|]
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
comment|// a directory with quota
name|inodes
index|[
name|i
index|]
operator|.
name|asDirectory
argument_list|()
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
operator|.
name|addSpaceConsumed2Cache
argument_list|(
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Return the name of the path represented by inodes at [0, pos] */
DECL|method|getFullPathName (INode[] inodes, int pos)
specifier|static
name|String
name|getFullPathName
parameter_list|(
name|INode
index|[]
name|inodes
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|StringBuilder
name|fullPathName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|inodes
index|[
literal|0
index|]
operator|.
name|isRoot
argument_list|()
condition|)
block|{
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
else|else
block|{
name|fullPathName
operator|.
name|append
argument_list|(
name|inodes
index|[
literal|0
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|pos
condition|;
name|i
operator|++
control|)
block|{
name|fullPathName
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR_CHAR
argument_list|)
operator|.
name|append
argument_list|(
name|inodes
index|[
name|i
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|fullPathName
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return the relative path of an inode from one of its ancestors,    *         represented by an array of inodes.    */
DECL|method|getRelativePathINodes (INode inode, INode ancestor)
specifier|private
specifier|static
name|INode
index|[]
name|getRelativePathINodes
parameter_list|(
name|INode
name|inode
parameter_list|,
name|INode
name|ancestor
parameter_list|)
block|{
comment|// calculate the depth of this inode from the ancestor
name|int
name|depth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|INode
name|i
init|=
name|inode
init|;
name|i
operator|!=
literal|null
operator|&&
operator|!
name|i
operator|.
name|equals
argument_list|(
name|ancestor
argument_list|)
condition|;
name|i
operator|=
name|i
operator|.
name|getParent
argument_list|()
control|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
name|INode
index|[]
name|inodes
init|=
operator|new
name|INode
index|[
name|depth
index|]
decl_stmt|;
comment|// fill up the inodes in the path from this inode to root
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"Could not get full path."
operator|+
literal|" Corresponding file might have deleted already."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|inodes
index|[
name|depth
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|inode
expr_stmt|;
name|inode
operator|=
name|inode
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
name|inodes
return|;
block|}
DECL|method|getFullPathINodes (INode inode)
specifier|private
specifier|static
name|INode
index|[]
name|getFullPathINodes
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
return|return
name|getRelativePathINodes
argument_list|(
name|inode
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Return the full path name of the specified inode */
DECL|method|getFullPathName (INode inode)
specifier|static
name|String
name|getFullPathName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
name|INode
index|[]
name|inodes
init|=
name|getFullPathINodes
argument_list|(
name|inode
argument_list|)
decl_stmt|;
comment|// inodes can be null only when its called without holding lock
return|return
name|inodes
operator|==
literal|null
condition|?
literal|""
else|:
name|getFullPathName
argument_list|(
name|inodes
argument_list|,
name|inodes
operator|.
name|length
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|unprotectedMkdir (long inodeId, String src, PermissionStatus permissions, List<AclEntry> aclEntries, long timestamp)
name|INode
name|unprotectedMkdir
parameter_list|(
name|long
name|inodeId
parameter_list|,
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclEntries
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|AclException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|INodesInPath
name|iip
init|=
name|getExistingPathINodes
argument_list|(
name|components
argument_list|)
decl_stmt|;
name|INode
index|[]
name|inodes
init|=
name|iip
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pos
init|=
name|inodes
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|unprotectedMkdir
argument_list|(
name|inodeId
argument_list|,
name|iip
argument_list|,
name|pos
argument_list|,
name|components
index|[
name|pos
index|]
argument_list|,
name|permissions
argument_list|,
name|aclEntries
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
return|return
name|inodes
index|[
name|pos
index|]
return|;
block|}
comment|/** create a directory at index pos.    * The parent path to the directory is at [0, pos-1].    * All ancestors exist. Newly created one stored at index pos.    */
DECL|method|unprotectedMkdir (long inodeId, INodesInPath inodesInPath, int pos, byte[] name, PermissionStatus permission, List<AclEntry> aclEntries, long timestamp)
name|void
name|unprotectedMkdir
parameter_list|(
name|long
name|inodeId
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|pos
parameter_list|,
name|byte
index|[]
name|name
parameter_list|,
name|PermissionStatus
name|permission
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclEntries
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|AclException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeDirectory
name|dir
init|=
operator|new
name|INodeDirectory
argument_list|(
name|inodeId
argument_list|,
name|name
argument_list|,
name|permission
argument_list|,
name|timestamp
argument_list|)
decl_stmt|;
if|if
condition|(
name|addChild
argument_list|(
name|inodesInPath
argument_list|,
name|pos
argument_list|,
name|dir
argument_list|,
literal|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|aclEntries
operator|!=
literal|null
condition|)
block|{
name|AclStorage
operator|.
name|updateINodeAcl
argument_list|(
name|dir
argument_list|,
name|aclEntries
argument_list|,
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
expr_stmt|;
block|}
name|inodesInPath
operator|.
name|setINode
argument_list|(
name|pos
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add the given child to the namespace.    * @param src The full path name of the child node.    * @throws QuotaExceededException is thrown if it violates quota limit    */
DECL|method|addINode (String src, INode child )
specifier|private
name|boolean
name|addINode
parameter_list|(
name|String
name|src
parameter_list|,
name|INode
name|child
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
block|{
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|child
operator|.
name|setLocalName
argument_list|(
name|components
index|[
name|components
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|cacheName
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|addLastINode
argument_list|(
name|getExistingPathINodes
argument_list|(
name|components
argument_list|)
argument_list|,
name|child
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Verify quota for adding or moving a new INode with required     * namespace and diskspace to a given position.    *      * @param inodes INodes corresponding to a path    * @param pos position where a new INode will be added    * @param nsDelta needed namespace    * @param dsDelta needed diskspace    * @param commonAncestor Last node in inodes array that is a common ancestor    *          for a INode that is being moved from one location to the other.    *          Pass null if a node is not being moved.    * @throws QuotaExceededException if quota limit is exceeded.    */
DECL|method|verifyQuota (INode[] inodes, int pos, long nsDelta, long dsDelta, INode commonAncestor)
specifier|private
specifier|static
name|void
name|verifyQuota
parameter_list|(
name|INode
index|[]
name|inodes
parameter_list|,
name|int
name|pos
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|INode
name|commonAncestor
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
name|nsDelta
operator|<=
literal|0
operator|&&
name|dsDelta
operator|<=
literal|0
condition|)
block|{
comment|// if quota is being freed or not being consumed
return|return;
block|}
comment|// check existing components in the path
for|for
control|(
name|int
name|i
init|=
operator|(
name|pos
operator|>
name|inodes
operator|.
name|length
condition|?
name|inodes
operator|.
name|length
else|:
name|pos
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|commonAncestor
operator|==
name|inodes
index|[
name|i
index|]
condition|)
block|{
comment|// Stop checking for quota when common ancestor is reached
return|return;
block|}
specifier|final
name|DirectoryWithQuotaFeature
name|q
init|=
name|inodes
index|[
name|i
index|]
operator|.
name|asDirectory
argument_list|()
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
comment|// a directory with quota
try|try
block|{
name|q
operator|.
name|verifyQuota
argument_list|(
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|e
operator|.
name|setPathName
argument_list|(
name|getFullPathName
argument_list|(
name|inodes
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Verify quota for rename operation where srcInodes[srcInodes.length-1] moves    * dstInodes[dstInodes.length-1]    *     * @param src directory from where node is being moved.    * @param dst directory to where node is moved to.    * @throws QuotaExceededException if quota limit is exceeded.    */
DECL|method|verifyQuotaForRename (INode[] src, INode[] dst)
specifier|private
name|void
name|verifyQuotaForRename
parameter_list|(
name|INode
index|[]
name|src
parameter_list|,
name|INode
index|[]
name|dst
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
operator|||
name|skipQuotaCheck
condition|)
block|{
comment|// Do not check quota if edits log is still being processed
return|return;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|src
index|[
name|i
index|]
operator|==
name|dst
index|[
name|i
index|]
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
comment|// src[i - 1] is the last common ancestor.
specifier|final
name|Quota
operator|.
name|Counts
name|delta
init|=
name|src
index|[
name|src
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|computeQuotaUsage
argument_list|()
decl_stmt|;
comment|// Reduce the required quota by dst that is being removed
specifier|final
name|int
name|dstIndex
init|=
name|dst
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|dst
index|[
name|dstIndex
index|]
operator|!=
literal|null
condition|)
block|{
name|delta
operator|.
name|subtract
argument_list|(
name|dst
index|[
name|dstIndex
index|]
operator|.
name|computeQuotaUsage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|verifyQuota
argument_list|(
name|dst
argument_list|,
name|dstIndex
argument_list|,
name|delta
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
name|delta
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
name|src
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks file system limits (max component length and max directory items)    * during a rename operation.    *    * @param srcIIP INodesInPath containing every inode in the rename source    * @param dstIIP INodesInPath containing every inode in the rename destination    * @throws PathComponentTooLongException child's name is too long.    * @throws MaxDirectoryItemsExceededException too many children.    */
DECL|method|verifyFsLimitsForRename (INodesInPath srcIIP, INodesInPath dstIIP)
specifier|private
name|void
name|verifyFsLimitsForRename
parameter_list|(
name|INodesInPath
name|srcIIP
parameter_list|,
name|INodesInPath
name|dstIIP
parameter_list|)
throws|throws
name|PathComponentTooLongException
throws|,
name|MaxDirectoryItemsExceededException
block|{
name|byte
index|[]
name|dstChildName
init|=
name|dstIIP
operator|.
name|getLastLocalName
argument_list|()
decl_stmt|;
name|INode
index|[]
name|dstInodes
init|=
name|dstIIP
operator|.
name|getINodes
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|dstInodes
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|verifyMaxComponentLength
argument_list|(
name|dstChildName
argument_list|,
name|dstInodes
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|// Do not enforce max directory items if renaming within same directory.
if|if
condition|(
name|srcIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|!=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
condition|)
block|{
name|verifyMaxDirItems
argument_list|(
name|dstInodes
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Verify if the snapshot name is legal. */
DECL|method|verifySnapshotName (String snapshotName, String path)
name|void
name|verifySnapshotName
parameter_list|(
name|String
name|snapshotName
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|PathComponentTooLongException
block|{
if|if
condition|(
name|snapshotName
operator|.
name|contains
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Snapshot name cannot contain \""
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"\""
argument_list|)
throw|;
block|}
specifier|final
name|byte
index|[]
name|bytes
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|snapshotName
argument_list|)
decl_stmt|;
name|verifyINodeName
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|verifyMaxComponentLength
argument_list|(
name|bytes
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/** Verify if the inode name is legal. */
DECL|method|verifyINodeName (byte[] childName)
name|void
name|verifyINodeName
parameter_list|(
name|byte
index|[]
name|childName
parameter_list|)
throws|throws
name|HadoopIllegalArgumentException
block|{
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR_BYTES
argument_list|,
name|childName
argument_list|)
condition|)
block|{
name|String
name|s
init|=
literal|"\""
operator|+
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|+
literal|"\" is a reserved name."
decl_stmt|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
name|s
operator|+=
literal|"  Please rename it before upgrade."
expr_stmt|;
block|}
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
name|s
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verify child's name for fs limit.    *    * @param childName byte[] containing new child name    * @param parentPath Object either INode[] or String containing parent path    * @param pos int position of new child in path    * @throws PathComponentTooLongException child's name is too long.    */
DECL|method|verifyMaxComponentLength (byte[] childName, Object parentPath, int pos)
specifier|private
name|void
name|verifyMaxComponentLength
parameter_list|(
name|byte
index|[]
name|childName
parameter_list|,
name|Object
name|parentPath
parameter_list|,
name|int
name|pos
parameter_list|)
throws|throws
name|PathComponentTooLongException
block|{
if|if
condition|(
name|maxComponentLength
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|int
name|length
init|=
name|childName
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|maxComponentLength
condition|)
block|{
specifier|final
name|String
name|p
init|=
name|parentPath
operator|instanceof
name|INode
index|[]
condition|?
name|getFullPathName
argument_list|(
operator|(
name|INode
index|[]
operator|)
name|parentPath
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
else|:
operator|(
name|String
operator|)
name|parentPath
decl_stmt|;
specifier|final
name|PathComponentTooLongException
name|e
init|=
operator|new
name|PathComponentTooLongException
argument_list|(
name|maxComponentLength
argument_list|,
name|length
argument_list|,
name|p
argument_list|,
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|childName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// Do not throw if edits log is still being processed
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"ERROR in FSDirectory.verifyINodeName"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Verify children size for fs limit.    *    * @param pathComponents INode[] containing full path of inodes to new child    * @param pos int position of new child in pathComponents    * @throws MaxDirectoryItemsExceededException too many children.    */
DECL|method|verifyMaxDirItems (INode[] pathComponents, int pos)
specifier|private
name|void
name|verifyMaxDirItems
parameter_list|(
name|INode
index|[]
name|pathComponents
parameter_list|,
name|int
name|pos
parameter_list|)
throws|throws
name|MaxDirectoryItemsExceededException
block|{
specifier|final
name|INodeDirectory
name|parent
init|=
name|pathComponents
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|parent
operator|.
name|getChildrenList
argument_list|(
name|Snapshot
operator|.
name|CURRENT_STATE_ID
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>=
name|maxDirItems
condition|)
block|{
specifier|final
name|MaxDirectoryItemsExceededException
name|e
init|=
operator|new
name|MaxDirectoryItemsExceededException
argument_list|(
name|maxDirItems
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
name|e
operator|.
name|setPathName
argument_list|(
name|getFullPathName
argument_list|(
name|pathComponents
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// Do not throw if edits log is still being processed
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"FSDirectory.verifyMaxDirItems: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The same as {@link #addChild(INodesInPath, int, INode, boolean)}    * with pos = length - 1.    */
DECL|method|addLastINode (INodesInPath inodesInPath, INode inode, boolean checkQuota)
specifier|private
name|boolean
name|addLastINode
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|INode
name|inode
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|int
name|pos
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|-
literal|1
decl_stmt|;
return|return
name|addChild
argument_list|(
name|inodesInPath
argument_list|,
name|pos
argument_list|,
name|inode
argument_list|,
name|checkQuota
argument_list|)
return|;
block|}
comment|/** Add a node child to the inodes at index pos.     * Its ancestors are stored at [0, pos-1].    * @return false if the child with this name already exists;     *         otherwise return true;    * @throws QuotaExceededException is thrown if it violates quota limit    */
DECL|method|addChild (INodesInPath iip, int pos, INode child, boolean checkQuota)
specifier|private
name|boolean
name|addChild
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|int
name|pos
parameter_list|,
name|INode
name|child
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|INode
index|[]
name|inodes
init|=
name|iip
operator|.
name|getINodes
argument_list|()
decl_stmt|;
comment|// Disallow creation of /.reserved. This may be created when loading
comment|// editlog/fsimage during upgrade since /.reserved was a valid name in older
comment|// release. This may also be called when a user tries to create a file
comment|// or directory /.reserved.
if|if
condition|(
name|pos
operator|==
literal|1
operator|&&
name|inodes
index|[
literal|0
index|]
operator|==
name|rootDir
operator|&&
name|isReservedName
argument_list|(
name|child
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"File name \""
operator|+
name|child
operator|.
name|getLocalName
argument_list|()
operator|+
literal|"\" is reserved and cannot "
operator|+
literal|"be created. If this is during upgrade change the name of the "
operator|+
literal|"existing file or directory to another name before upgrading "
operator|+
literal|"to the new release."
argument_list|)
throw|;
block|}
comment|// The filesystem limits are not really quotas, so this check may appear
comment|// odd. It's because a rename operation deletes the src, tries to add
comment|// to the dest, if that fails, re-adds the src from whence it came.
comment|// The rename code disables the quota when it's restoring to the
comment|// original location becase a quota violation would cause the the item
comment|// to go "poof".  The fs limits must be bypassed for the same reason.
if|if
condition|(
name|checkQuota
condition|)
block|{
name|verifyMaxComponentLength
argument_list|(
name|child
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|inodes
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|verifyMaxDirItems
argument_list|(
name|inodes
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
comment|// always verify inode name
name|verifyINodeName
argument_list|(
name|child
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Quota
operator|.
name|Counts
name|counts
init|=
name|child
operator|.
name|computeQuotaUsage
argument_list|()
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
name|pos
argument_list|,
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
name|boolean
name|isRename
init|=
operator|(
name|child
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
operator|)
decl_stmt|;
specifier|final
name|INodeDirectory
name|parent
init|=
name|inodes
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
name|boolean
name|added
decl_stmt|;
try|try
block|{
name|added
operator|=
name|parent
operator|.
name|addChild
argument_list|(
name|child
argument_list|,
literal|true
argument_list|,
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|updateCountNoQuotaCheck
argument_list|(
name|iip
argument_list|,
name|pos
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|updateCountNoQuotaCheck
argument_list|(
name|iip
argument_list|,
name|pos
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iip
operator|.
name|setINode
argument_list|(
name|pos
operator|-
literal|1
argument_list|,
name|child
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRename
condition|)
block|{
name|AclStorage
operator|.
name|copyINodeDefaultAcl
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
name|addToInodeMap
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
DECL|method|addLastINodeNoQuotaCheck (INodesInPath inodesInPath, INode i)
specifier|private
name|boolean
name|addLastINodeNoQuotaCheck
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|INode
name|i
parameter_list|)
block|{
try|try
block|{
return|return
name|addLastINode
argument_list|(
name|inodesInPath
argument_list|,
name|i
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"FSDirectory.addChildNoQuotaCheck - unexpected"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Remove the last inode in the path from the namespace.    * Count of each ancestor with quota is also updated.    * @return -1 for failing to remove;    *          0 for removing a reference whose referred inode has other     *            reference nodes;    *>0 otherwise.     */
DECL|method|removeLastINode (final INodesInPath iip)
specifier|private
name|long
name|removeLastINode
parameter_list|(
specifier|final
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|int
name|latestSnapshot
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|last
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|INodeDirectory
name|parent
init|=
name|iip
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|removeChild
argument_list|(
name|last
argument_list|,
name|latestSnapshot
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|last
operator|.
name|isInLatestSnapshot
argument_list|(
name|latestSnapshot
argument_list|)
condition|)
block|{
specifier|final
name|Quota
operator|.
name|Counts
name|counts
init|=
name|last
operator|.
name|computeQuotaUsage
argument_list|()
decl_stmt|;
name|updateCountNoQuotaCheck
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|-
literal|1
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INodeReference
operator|.
name|tryRemoveReference
argument_list|(
name|last
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
DECL|method|normalizePath (String src)
specifier|static
name|String
name|normalizePath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|src
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
DECL|method|getContentSummary (String src)
name|ContentSummary
name|getContentSummary
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|targetNode
init|=
name|getNode
argument_list|(
name|srcs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|srcs
argument_list|)
throw|;
block|}
else|else
block|{
comment|// Make it relinquish locks everytime contentCountLimit entries are
comment|// processed. 0 means disabled. I.e. blocking for the entire duration.
name|ContentSummaryComputationContext
name|cscc
init|=
operator|new
name|ContentSummaryComputationContext
argument_list|(
name|this
argument_list|,
name|getFSNamesystem
argument_list|()
argument_list|,
name|contentCountLimit
argument_list|)
decl_stmt|;
name|ContentSummary
name|cs
init|=
name|targetNode
operator|.
name|computeAndConvertContentSummary
argument_list|(
name|cscc
argument_list|)
decl_stmt|;
name|yieldCount
operator|+=
name|cscc
operator|.
name|getYieldCount
argument_list|()
expr_stmt|;
return|return
name|cs
return|;
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getYieldCount ()
specifier|public
name|long
name|getYieldCount
parameter_list|()
block|{
return|return
name|yieldCount
return|;
block|}
DECL|method|getINodeMap ()
specifier|public
name|INodeMap
name|getINodeMap
parameter_list|()
block|{
return|return
name|inodeMap
return|;
block|}
comment|/**    * This method is always called with writeLock of FSDirectory held.    */
DECL|method|addToInodeMap (INode inode)
specifier|public
specifier|final
name|void
name|addToInodeMap
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
if|if
condition|(
name|inode
operator|instanceof
name|INodeWithAdditionalFields
condition|)
block|{
name|inodeMap
operator|.
name|put
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inode
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
specifier|final
name|XAttrFeature
name|xaf
init|=
name|inode
operator|.
name|getXAttrFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|xaf
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|xattrs
init|=
name|xaf
operator|.
name|getXAttrs
argument_list|()
decl_stmt|;
for|for
control|(
name|XAttr
name|xattr
range|:
name|xattrs
control|)
block|{
specifier|final
name|String
name|xaName
init|=
name|XAttrHelper
operator|.
name|getPrefixName
argument_list|(
name|xattr
argument_list|)
decl_stmt|;
if|if
condition|(
name|CRYPTO_XATTR_ENCRYPTION_ZONE
operator|.
name|equals
argument_list|(
name|xaName
argument_list|)
condition|)
block|{
try|try
block|{
specifier|final
name|HdfsProtos
operator|.
name|ZoneEncryptionInfoProto
name|ezProto
init|=
name|HdfsProtos
operator|.
name|ZoneEncryptionInfoProto
operator|.
name|parseFrom
argument_list|(
name|xattr
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|ezManager
operator|.
name|unprotectedAddEncryptionZone
argument_list|(
name|inode
operator|.
name|getId
argument_list|()
argument_list|,
name|PBHelper
operator|.
name|convert
argument_list|(
name|ezProto
operator|.
name|getSuite
argument_list|()
argument_list|)
argument_list|,
name|PBHelper
operator|.
name|convert
argument_list|(
name|ezProto
operator|.
name|getCryptoProtocolVersion
argument_list|()
argument_list|)
argument_list|,
name|ezProto
operator|.
name|getKeyName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error parsing protocol buffer of "
operator|+
literal|"EZ XAttr "
operator|+
name|xattr
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * This method is always called with writeLock of FSDirectory held.    */
DECL|method|removeFromInodeMap (List<? extends INode> inodes)
specifier|public
specifier|final
name|void
name|removeFromInodeMap
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|INode
argument_list|>
name|inodes
parameter_list|)
block|{
if|if
condition|(
name|inodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|INode
name|inode
range|:
name|inodes
control|)
block|{
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|instanceof
name|INodeWithAdditionalFields
condition|)
block|{
name|inodeMap
operator|.
name|remove
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|ezManager
operator|.
name|removeEncryptionZone
argument_list|(
name|inode
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Get the inode from inodeMap based on its inode id.    * @param id The given id    * @return The inode associated with the given id    */
DECL|method|getInode (long id)
specifier|public
name|INode
name|getInode
parameter_list|(
name|long
name|id
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|inodeMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getInodeMapSize ()
name|int
name|getInodeMapSize
parameter_list|()
block|{
return|return
name|inodeMap
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * See {@link ClientProtocol#setQuota(String, long, long)} for the contract.    * Sets quota for for a directory.    * @return INodeDirectory if any of the quotas have changed. null otherwise.    * @throws FileNotFoundException if the path does not exist.    * @throws PathIsNotDirectoryException if the path is not a directory.    * @throws QuotaExceededException if the directory tree size is     *                                greater than the given quota    * @throws UnresolvedLinkException if a symlink is encountered in src.    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|unprotectedSetQuota (String src, long nsQuota, long dsQuota)
name|INodeDirectory
name|unprotectedSetQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|PathIsNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// sanity check
if|if
condition|(
operator|(
name|nsQuota
operator|<
literal|0
operator|&&
name|nsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
operator|&&
name|nsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_RESET
operator|)
operator|||
operator|(
name|dsQuota
operator|<
literal|0
operator|&&
name|dsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
operator|&&
name|dsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_RESET
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal value for nsQuota or "
operator|+
literal|"dsQuota : "
operator|+
name|nsQuota
operator|+
literal|" and "
operator|+
name|dsQuota
argument_list|)
throw|;
block|}
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|srcs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INodeDirectory
name|dirNode
init|=
name|INodeDirectory
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|srcs
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirNode
operator|.
name|isRoot
argument_list|()
operator|&&
name|nsQuota
operator|==
name|HdfsConstants
operator|.
name|QUOTA_RESET
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot clear namespace quota on root."
argument_list|)
throw|;
block|}
else|else
block|{
comment|// a directory inode
specifier|final
name|Quota
operator|.
name|Counts
name|oldQuota
init|=
name|dirNode
operator|.
name|getQuotaCounts
argument_list|()
decl_stmt|;
specifier|final
name|long
name|oldNsQuota
init|=
name|oldQuota
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
decl_stmt|;
specifier|final
name|long
name|oldDsQuota
init|=
name|oldQuota
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsQuota
operator|==
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
condition|)
block|{
name|nsQuota
operator|=
name|oldNsQuota
expr_stmt|;
block|}
if|if
condition|(
name|dsQuota
operator|==
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
condition|)
block|{
name|dsQuota
operator|=
name|oldDsQuota
expr_stmt|;
block|}
if|if
condition|(
name|oldNsQuota
operator|==
name|nsQuota
operator|&&
name|oldDsQuota
operator|==
name|dsQuota
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|latest
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|dirNode
operator|.
name|recordModification
argument_list|(
name|latest
argument_list|)
expr_stmt|;
name|dirNode
operator|.
name|setQuota
argument_list|(
name|nsQuota
argument_list|,
name|dsQuota
argument_list|)
expr_stmt|;
return|return
name|dirNode
return|;
block|}
block|}
comment|/**    * See {@link ClientProtocol#setQuota(String, long, long)} for the contract.    * @return INodeDirectory if any of the quotas have changed. null otherwise.    * @throws SnapshotAccessControlException if path is in RO snapshot    * @see #unprotectedSetQuota(String, long, long)    */
DECL|method|setQuota (String src, long nsQuota, long dsQuota)
name|INodeDirectory
name|setQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|PathIsNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedSetQuota
argument_list|(
name|src
argument_list|,
name|nsQuota
argument_list|,
name|dsQuota
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|totalInodes ()
name|long
name|totalInodes
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
operator|.
name|getSpaceConsumed
argument_list|()
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Sets the access time on the file/directory. Logs it in the transaction log.    */
DECL|method|setTimes (INode inode, long mtime, long atime, boolean force, int latestSnapshotId)
name|boolean
name|setTimes
parameter_list|(
name|INode
name|inode
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|boolean
name|force
parameter_list|,
name|int
name|latestSnapshotId
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedSetTimes
argument_list|(
name|inode
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|force
argument_list|,
name|latestSnapshotId
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetTimes (String src, long mtime, long atime, boolean force)
name|boolean
name|unprotectedSetTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|i
init|=
name|getLastINodeInPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
return|return
name|unprotectedSetTimes
argument_list|(
name|i
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|force
argument_list|,
name|i
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
return|;
block|}
DECL|method|unprotectedSetTimes (INode inode, long mtime, long atime, boolean force, int latest)
specifier|private
name|boolean
name|unprotectedSetTimes
parameter_list|(
name|INode
name|inode
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|boolean
name|force
parameter_list|,
name|int
name|latest
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|boolean
name|status
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|mtime
operator|!=
operator|-
literal|1
condition|)
block|{
name|inode
operator|=
name|inode
operator|.
name|setModificationTime
argument_list|(
name|mtime
argument_list|,
name|latest
argument_list|)
expr_stmt|;
name|status
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|atime
operator|!=
operator|-
literal|1
condition|)
block|{
name|long
name|inodeTime
init|=
name|inode
operator|.
name|getAccessTime
argument_list|()
decl_stmt|;
comment|// if the last access time update was within the last precision interval, then
comment|// no need to store access time
if|if
condition|(
name|atime
operator|<=
name|inodeTime
operator|+
name|getFSNamesystem
argument_list|()
operator|.
name|getAccessTimePrecision
argument_list|()
operator|&&
operator|!
name|force
condition|)
block|{
name|status
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|.
name|setAccessTime
argument_list|(
name|atime
argument_list|,
name|latest
argument_list|)
expr_stmt|;
name|status
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
comment|/**    * Reset the entire namespace tree.    */
DECL|method|reset ()
name|void
name|reset
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|rootDir
operator|=
name|createRoot
argument_list|(
name|getFSNamesystem
argument_list|()
argument_list|)
expr_stmt|;
name|inodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|addToInodeMap
argument_list|(
name|rootDir
argument_list|)
expr_stmt|;
name|nameCache
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * create an hdfs file status from an inode    *     * @param path the local name    * @param node inode    * @param needLocation if block locations need to be included or not    * @param isRawPath true if this is being called on behalf of a path in    *                  /.reserved/raw    * @return a file status    * @throws IOException if any error occurs    */
DECL|method|createFileStatus (byte[] path, INode node, boolean needLocation, byte storagePolicy, int snapshot, boolean isRawPath, INodesInPath iip)
specifier|private
name|HdfsFileStatus
name|createFileStatus
parameter_list|(
name|byte
index|[]
name|path
parameter_list|,
name|INode
name|node
parameter_list|,
name|boolean
name|needLocation
parameter_list|,
name|byte
name|storagePolicy
parameter_list|,
name|int
name|snapshot
parameter_list|,
name|boolean
name|isRawPath
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|needLocation
condition|)
block|{
return|return
name|createLocatedFileStatus
argument_list|(
name|path
argument_list|,
name|node
argument_list|,
name|storagePolicy
argument_list|,
name|snapshot
argument_list|,
name|isRawPath
argument_list|,
name|iip
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createFileStatus
argument_list|(
name|path
argument_list|,
name|node
argument_list|,
name|storagePolicy
argument_list|,
name|snapshot
argument_list|,
name|isRawPath
argument_list|,
name|iip
argument_list|)
return|;
block|}
block|}
comment|/**    * Create FileStatus by file INode     */
DECL|method|createFileStatus (byte[] path, INode node, byte storagePolicy, int snapshot, boolean isRawPath, INodesInPath iip)
name|HdfsFileStatus
name|createFileStatus
parameter_list|(
name|byte
index|[]
name|path
parameter_list|,
name|INode
name|node
parameter_list|,
name|byte
name|storagePolicy
parameter_list|,
name|int
name|snapshot
parameter_list|,
name|boolean
name|isRawPath
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
comment|// length is zero for directories
name|short
name|replication
init|=
literal|0
decl_stmt|;
name|long
name|blocksize
init|=
literal|0
decl_stmt|;
name|boolean
name|isLazyPersist
init|=
literal|false
decl_stmt|;
specifier|final
name|boolean
name|isEncrypted
decl_stmt|;
specifier|final
name|FileEncryptionInfo
name|feInfo
init|=
name|isRawPath
condition|?
literal|null
else|:
name|getFileEncryptionInfo
argument_list|(
name|node
argument_list|,
name|snapshot
argument_list|,
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isFile
argument_list|()
condition|)
block|{
specifier|final
name|INodeFile
name|fileNode
init|=
name|node
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|size
operator|=
name|fileNode
operator|.
name|computeFileSize
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|replication
operator|=
name|fileNode
operator|.
name|getFileReplication
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
name|isLazyPersist
operator|=
name|fileNode
operator|.
name|getLazyPersistFlag
argument_list|()
expr_stmt|;
name|isEncrypted
operator|=
operator|(
name|feInfo
operator|!=
literal|null
operator|)
operator|||
operator|(
name|isRawPath
operator|&&
name|isInAnEZ
argument_list|(
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|node
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|isEncrypted
operator|=
name|isInAnEZ
argument_list|(
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|childrenNum
init|=
name|node
operator|.
name|isDirectory
argument_list|()
condition|?
name|node
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenNum
argument_list|(
name|snapshot
argument_list|)
else|:
literal|0
decl_stmt|;
return|return
operator|new
name|HdfsFileStatus
argument_list|(
name|size
argument_list|,
name|node
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|isLazyPersist
argument_list|,
name|node
operator|.
name|getModificationTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getAccessTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|getPermissionForFileStatus
argument_list|(
name|node
argument_list|,
name|snapshot
argument_list|,
name|isEncrypted
argument_list|)
argument_list|,
name|node
operator|.
name|getUserName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getGroupName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|isSymlink
argument_list|()
condition|?
name|node
operator|.
name|asSymlink
argument_list|()
operator|.
name|getSymlink
argument_list|()
else|:
literal|null
argument_list|,
name|path
argument_list|,
name|node
operator|.
name|getId
argument_list|()
argument_list|,
name|childrenNum
argument_list|,
name|feInfo
argument_list|,
name|storagePolicy
argument_list|)
return|;
block|}
comment|/**    * Create FileStatus with location info by file INode    */
DECL|method|createLocatedFileStatus (byte[] path, INode node, byte storagePolicy, int snapshot, boolean isRawPath, INodesInPath iip)
specifier|private
name|HdfsLocatedFileStatus
name|createLocatedFileStatus
parameter_list|(
name|byte
index|[]
name|path
parameter_list|,
name|INode
name|node
parameter_list|,
name|byte
name|storagePolicy
parameter_list|,
name|int
name|snapshot
parameter_list|,
name|boolean
name|isRawPath
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
name|long
name|size
init|=
literal|0
decl_stmt|;
comment|// length is zero for directories
name|short
name|replication
init|=
literal|0
decl_stmt|;
name|long
name|blocksize
init|=
literal|0
decl_stmt|;
name|boolean
name|isLazyPersist
init|=
literal|false
decl_stmt|;
name|LocatedBlocks
name|loc
init|=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|isEncrypted
decl_stmt|;
specifier|final
name|FileEncryptionInfo
name|feInfo
init|=
name|isRawPath
condition|?
literal|null
else|:
name|getFileEncryptionInfo
argument_list|(
name|node
argument_list|,
name|snapshot
argument_list|,
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isFile
argument_list|()
condition|)
block|{
specifier|final
name|INodeFile
name|fileNode
init|=
name|node
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|size
operator|=
name|fileNode
operator|.
name|computeFileSize
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|replication
operator|=
name|fileNode
operator|.
name|getFileReplication
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
name|isLazyPersist
operator|=
name|fileNode
operator|.
name|getLazyPersistFlag
argument_list|()
expr_stmt|;
specifier|final
name|boolean
name|inSnapshot
init|=
name|snapshot
operator|!=
name|Snapshot
operator|.
name|CURRENT_STATE_ID
decl_stmt|;
specifier|final
name|boolean
name|isUc
init|=
operator|!
name|inSnapshot
operator|&&
name|fileNode
operator|.
name|isUnderConstruction
argument_list|()
decl_stmt|;
specifier|final
name|long
name|fileSize
init|=
operator|!
name|inSnapshot
operator|&&
name|isUc
condition|?
name|fileNode
operator|.
name|computeFileSizeNotIncludingLastUcBlock
argument_list|()
else|:
name|size
decl_stmt|;
name|loc
operator|=
name|getFSNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
operator|.
name|createLocatedBlocks
argument_list|(
name|fileNode
operator|.
name|getBlocks
argument_list|()
argument_list|,
name|fileSize
argument_list|,
name|isUc
argument_list|,
literal|0L
argument_list|,
name|size
argument_list|,
literal|false
argument_list|,
name|inSnapshot
argument_list|,
name|feInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
literal|null
condition|)
block|{
name|loc
operator|=
operator|new
name|LocatedBlocks
argument_list|()
expr_stmt|;
block|}
name|isEncrypted
operator|=
operator|(
name|feInfo
operator|!=
literal|null
operator|)
operator|||
operator|(
name|isRawPath
operator|&&
name|isInAnEZ
argument_list|(
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|node
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|isEncrypted
operator|=
name|isInAnEZ
argument_list|(
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|childrenNum
init|=
name|node
operator|.
name|isDirectory
argument_list|()
condition|?
name|node
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenNum
argument_list|(
name|snapshot
argument_list|)
else|:
literal|0
decl_stmt|;
name|HdfsLocatedFileStatus
name|status
init|=
operator|new
name|HdfsLocatedFileStatus
argument_list|(
name|size
argument_list|,
name|node
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|isLazyPersist
argument_list|,
name|node
operator|.
name|getModificationTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getAccessTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|getPermissionForFileStatus
argument_list|(
name|node
argument_list|,
name|snapshot
argument_list|,
name|isEncrypted
argument_list|)
argument_list|,
name|node
operator|.
name|getUserName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getGroupName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|isSymlink
argument_list|()
condition|?
name|node
operator|.
name|asSymlink
argument_list|()
operator|.
name|getSymlink
argument_list|()
else|:
literal|null
argument_list|,
name|path
argument_list|,
name|node
operator|.
name|getId
argument_list|()
argument_list|,
name|loc
argument_list|,
name|childrenNum
argument_list|,
name|feInfo
argument_list|,
name|storagePolicy
argument_list|)
decl_stmt|;
comment|// Set caching information for the located blocks.
if|if
condition|(
name|loc
operator|!=
literal|null
condition|)
block|{
name|CacheManager
name|cacheManager
init|=
name|namesystem
operator|.
name|getCacheManager
argument_list|()
decl_stmt|;
for|for
control|(
name|LocatedBlock
name|lb
range|:
name|loc
operator|.
name|getLocatedBlocks
argument_list|()
control|)
block|{
name|cacheManager
operator|.
name|setCachedLocations
argument_list|(
name|lb
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
comment|/**    * Returns an inode's FsPermission for use in an outbound FileStatus.  If the    * inode has an ACL or is for an encrypted file/dir, then this method will    * return an FsPermissionExtension.    *    * @param node INode to check    * @param snapshot int snapshot ID    * @param isEncrypted boolean true if the file/dir is encrypted    * @return FsPermission from inode, with ACL bit on if the inode has an ACL    * and encrypted bit on if it represents an encrypted file/dir.    */
DECL|method|getPermissionForFileStatus (INode node, int snapshot, boolean isEncrypted)
specifier|private
specifier|static
name|FsPermission
name|getPermissionForFileStatus
parameter_list|(
name|INode
name|node
parameter_list|,
name|int
name|snapshot
parameter_list|,
name|boolean
name|isEncrypted
parameter_list|)
block|{
name|FsPermission
name|perm
init|=
name|node
operator|.
name|getFsPermission
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|boolean
name|hasAcl
init|=
name|node
operator|.
name|getAclFeature
argument_list|(
name|snapshot
argument_list|)
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|hasAcl
operator|||
name|isEncrypted
condition|)
block|{
name|perm
operator|=
operator|new
name|FsPermissionExtension
argument_list|(
name|perm
argument_list|,
name|hasAcl
argument_list|,
name|isEncrypted
argument_list|)
expr_stmt|;
block|}
return|return
name|perm
return|;
block|}
comment|/**    * Add the specified path into the namespace.    */
DECL|method|addSymlink (long id, String path, String target, long mtime, long atime, PermissionStatus perm)
name|INodeSymlink
name|addSymlink
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|path
parameter_list|,
name|String
name|target
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|PermissionStatus
name|perm
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedAddSymlink
argument_list|(
name|id
argument_list|,
name|path
argument_list|,
name|target
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|perm
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedAddSymlink (long id, String path, String target, long mtime, long atime, PermissionStatus perm)
name|INodeSymlink
name|unprotectedAddSymlink
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|path
parameter_list|,
name|String
name|target
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|PermissionStatus
name|perm
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeSymlink
name|symlink
init|=
operator|new
name|INodeSymlink
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|perm
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|target
argument_list|)
decl_stmt|;
return|return
name|addINode
argument_list|(
name|path
argument_list|,
name|symlink
argument_list|)
condition|?
name|symlink
else|:
literal|null
return|;
block|}
DECL|method|modifyAclEntries (String src, List<AclEntry> aclSpec)
name|List
argument_list|<
name|AclEntry
argument_list|>
name|modifyAclEntries
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedModifyAclEntries
argument_list|(
name|src
argument_list|,
name|aclSpec
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedModifyAclEntries (String src, List<AclEntry> aclSpec)
specifier|private
name|List
argument_list|<
name|AclEntry
argument_list|>
name|unprotectedModifyAclEntries
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|resolveLastINode
argument_list|(
name|src
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|existingAcl
init|=
name|AclStorage
operator|.
name|readINodeLogicalAcl
argument_list|(
name|inode
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|newAcl
init|=
name|AclTransformation
operator|.
name|mergeAclEntries
argument_list|(
name|existingAcl
argument_list|,
name|aclSpec
argument_list|)
decl_stmt|;
name|AclStorage
operator|.
name|updateINodeAcl
argument_list|(
name|inode
argument_list|,
name|newAcl
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
return|return
name|newAcl
return|;
block|}
DECL|method|removeAclEntries (String src, List<AclEntry> aclSpec)
name|List
argument_list|<
name|AclEntry
argument_list|>
name|removeAclEntries
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedRemoveAclEntries
argument_list|(
name|src
argument_list|,
name|aclSpec
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedRemoveAclEntries (String src, List<AclEntry> aclSpec)
specifier|private
name|List
argument_list|<
name|AclEntry
argument_list|>
name|unprotectedRemoveAclEntries
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|resolveLastINode
argument_list|(
name|src
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|existingAcl
init|=
name|AclStorage
operator|.
name|readINodeLogicalAcl
argument_list|(
name|inode
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|newAcl
init|=
name|AclTransformation
operator|.
name|filterAclEntriesByAclSpec
argument_list|(
name|existingAcl
argument_list|,
name|aclSpec
argument_list|)
decl_stmt|;
name|AclStorage
operator|.
name|updateINodeAcl
argument_list|(
name|inode
argument_list|,
name|newAcl
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
return|return
name|newAcl
return|;
block|}
DECL|method|removeDefaultAcl (String src)
name|List
argument_list|<
name|AclEntry
argument_list|>
name|removeDefaultAcl
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedRemoveDefaultAcl
argument_list|(
name|src
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedRemoveDefaultAcl (String src)
specifier|private
name|List
argument_list|<
name|AclEntry
argument_list|>
name|unprotectedRemoveDefaultAcl
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|resolveLastINode
argument_list|(
name|src
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|existingAcl
init|=
name|AclStorage
operator|.
name|readINodeLogicalAcl
argument_list|(
name|inode
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|newAcl
init|=
name|AclTransformation
operator|.
name|filterDefaultAclEntries
argument_list|(
name|existingAcl
argument_list|)
decl_stmt|;
name|AclStorage
operator|.
name|updateINodeAcl
argument_list|(
name|inode
argument_list|,
name|newAcl
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
return|return
name|newAcl
return|;
block|}
DECL|method|removeAcl (String src)
name|void
name|removeAcl
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedRemoveAcl
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedRemoveAcl (String src)
specifier|private
name|void
name|unprotectedRemoveAcl
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|resolveLastINode
argument_list|(
name|src
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|AclStorage
operator|.
name|removeINodeAcl
argument_list|(
name|inode
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
DECL|method|setAcl (String src, List<AclEntry> aclSpec)
name|List
argument_list|<
name|AclEntry
argument_list|>
name|setAcl
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedSetAcl
argument_list|(
name|src
argument_list|,
name|aclSpec
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetAcl (String src, List<AclEntry> aclSpec)
name|List
argument_list|<
name|AclEntry
argument_list|>
name|unprotectedSetAcl
parameter_list|(
name|String
name|src
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ACL removal is logged to edits as OP_SET_ACL with an empty list.
if|if
condition|(
name|aclSpec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|unprotectedRemoveAcl
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return
name|AclFeature
operator|.
name|EMPTY_ENTRY_LIST
return|;
block|}
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|resolveLastINode
argument_list|(
name|src
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|existingAcl
init|=
name|AclStorage
operator|.
name|readINodeLogicalAcl
argument_list|(
name|inode
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|newAcl
init|=
name|AclTransformation
operator|.
name|replaceAclEntries
argument_list|(
name|existingAcl
argument_list|,
name|aclSpec
argument_list|)
decl_stmt|;
name|AclStorage
operator|.
name|updateINodeAcl
argument_list|(
name|inode
argument_list|,
name|newAcl
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
return|return
name|newAcl
return|;
block|}
DECL|method|getAclStatus (String src)
name|AclStatus
name|getAclStatus
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// There is no real inode for the path ending in ".snapshot", so return a
comment|// non-null, unpopulated AclStatus.  This is similar to getFileInfo.
if|if
condition|(
name|srcs
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
operator|&&
name|getINode4DotSnapshot
argument_list|(
name|srcs
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|AclStatus
operator|.
name|Builder
argument_list|()
operator|.
name|owner
argument_list|(
literal|""
argument_list|)
operator|.
name|group
argument_list|(
literal|""
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
name|INodesInPath
name|iip
init|=
name|getLastINodeInPath
argument_list|(
name|srcs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|resolveLastINode
argument_list|(
name|src
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AclEntry
argument_list|>
name|acl
init|=
name|AclStorage
operator|.
name|readINodeAcl
argument_list|(
name|inode
argument_list|,
name|snapshotId
argument_list|)
decl_stmt|;
return|return
operator|new
name|AclStatus
operator|.
name|Builder
argument_list|()
operator|.
name|owner
argument_list|(
name|inode
operator|.
name|getUserName
argument_list|()
argument_list|)
operator|.
name|group
argument_list|(
name|inode
operator|.
name|getGroupName
argument_list|()
argument_list|)
operator|.
name|stickyBit
argument_list|(
name|inode
operator|.
name|getFsPermission
argument_list|(
name|snapshotId
argument_list|)
operator|.
name|getStickyBit
argument_list|()
argument_list|)
operator|.
name|addEntries
argument_list|(
name|acl
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Removes a list of XAttrs from an inode at a path.    *    * @param src path of inode    * @param toRemove XAttrs to be removed    * @return List of XAttrs that were removed    * @throws IOException if the inode does not exist, if quota is exceeded    */
DECL|method|removeXAttrs (final String src, final List<XAttr> toRemove)
name|List
argument_list|<
name|XAttr
argument_list|>
name|removeXAttrs
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|toRemove
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedRemoveXAttrs
argument_list|(
name|src
argument_list|,
name|toRemove
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedRemoveXAttrs (final String src, final List<XAttr> toRemove)
name|List
argument_list|<
name|XAttr
argument_list|>
name|unprotectedRemoveXAttrs
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|toRemove
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|resolveLastINode
argument_list|(
name|src
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|XAttr
argument_list|>
name|existingXAttrs
init|=
name|XAttrStorage
operator|.
name|readINodeXAttrs
argument_list|(
name|inode
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|XAttr
argument_list|>
name|removedXAttrs
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|toRemove
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|XAttr
argument_list|>
name|newXAttrs
init|=
name|filterINodeXAttrs
argument_list|(
name|existingXAttrs
argument_list|,
name|toRemove
argument_list|,
name|removedXAttrs
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingXAttrs
operator|.
name|size
argument_list|()
operator|!=
name|newXAttrs
operator|.
name|size
argument_list|()
condition|)
block|{
name|XAttrStorage
operator|.
name|updateINodeXAttrs
argument_list|(
name|inode
argument_list|,
name|newXAttrs
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
return|return
name|removedXAttrs
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Filter XAttrs from a list of existing XAttrs. Removes matched XAttrs from    * toFilter and puts them into filtered. Upon completion,    * toFilter contains the filter XAttrs that were not found, while    * fitleredXAttrs contains the XAttrs that were found.    *    * @param existingXAttrs Existing XAttrs to be filtered    * @param toFilter XAttrs to filter from the existing XAttrs    * @param filtered Return parameter, XAttrs that were filtered    * @return List of XAttrs that does not contain filtered XAttrs    */
annotation|@
name|VisibleForTesting
DECL|method|filterINodeXAttrs (final List<XAttr> existingXAttrs, final List<XAttr> toFilter, final List<XAttr> filtered)
name|List
argument_list|<
name|XAttr
argument_list|>
name|filterINodeXAttrs
parameter_list|(
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|existingXAttrs
parameter_list|,
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|toFilter
parameter_list|,
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|filtered
parameter_list|)
throws|throws
name|AccessControlException
block|{
if|if
condition|(
name|existingXAttrs
operator|==
literal|null
operator|||
name|existingXAttrs
operator|.
name|isEmpty
argument_list|()
operator|||
name|toFilter
operator|==
literal|null
operator|||
name|toFilter
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|existingXAttrs
return|;
block|}
comment|// Populate a new list with XAttrs that pass the filter
name|List
argument_list|<
name|XAttr
argument_list|>
name|newXAttrs
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|existingXAttrs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|XAttr
name|a
range|:
name|existingXAttrs
control|)
block|{
name|boolean
name|add
init|=
literal|true
decl_stmt|;
for|for
control|(
name|ListIterator
argument_list|<
name|XAttr
argument_list|>
name|it
init|=
name|toFilter
operator|.
name|listIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|XAttr
name|filter
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|KEYID_XATTR
operator|.
name|equalsIgnoreValue
argument_list|(
name|filter
argument_list|)
argument_list|,
literal|"The encryption zone xattr should never be deleted."
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNREADABLE_BY_SUPERUSER_XATTR
operator|.
name|equalsIgnoreValue
argument_list|(
name|filter
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"The xattr '"
operator|+
name|SECURITY_XATTR_UNREADABLE_BY_SUPERUSER
operator|+
literal|"' can not be deleted."
argument_list|)
throw|;
block|}
if|if
condition|(
name|a
operator|.
name|equalsIgnoreValue
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|add
operator|=
literal|false
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|filtered
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|add
condition|)
block|{
name|newXAttrs
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newXAttrs
return|;
block|}
DECL|method|isInAnEZ (INodesInPath iip)
name|boolean
name|isInAnEZ
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|isInAnEZ
argument_list|(
name|iip
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getKeyName (INodesInPath iip)
name|String
name|getKeyName
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|getKeyName
argument_list|(
name|iip
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createEncryptionZone (String src, CipherSuite suite, CryptoProtocolVersion version, String keyName)
name|XAttr
name|createEncryptionZone
parameter_list|(
name|String
name|src
parameter_list|,
name|CipherSuite
name|suite
parameter_list|,
name|CryptoProtocolVersion
name|version
parameter_list|,
name|String
name|keyName
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|createEncryptionZone
argument_list|(
name|src
argument_list|,
name|suite
argument_list|,
name|version
argument_list|,
name|keyName
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getEZForPath (INodesInPath iip)
name|EncryptionZone
name|getEZForPath
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|getEZINodeForPath
argument_list|(
name|iip
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|listEncryptionZones (long prevId)
name|BatchedListEntries
argument_list|<
name|EncryptionZone
argument_list|>
name|listEncryptionZones
parameter_list|(
name|long
name|prevId
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|listEncryptionZones
argument_list|(
name|prevId
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Set the FileEncryptionInfo for an INode.    */
DECL|method|setFileEncryptionInfo (String src, FileEncryptionInfo info)
name|void
name|setFileEncryptionInfo
parameter_list|(
name|String
name|src
parameter_list|,
name|FileEncryptionInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Make the PB for the xattr
specifier|final
name|HdfsProtos
operator|.
name|PerFileEncryptionInfoProto
name|proto
init|=
name|PBHelper
operator|.
name|convertPerFileEncInfo
argument_list|(
name|info
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|protoBytes
init|=
name|proto
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
specifier|final
name|XAttr
name|fileEncryptionAttr
init|=
name|XAttrHelper
operator|.
name|buildXAttr
argument_list|(
name|CRYPTO_XATTR_FILE_ENCRYPTION_INFO
argument_list|,
name|protoBytes
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|xAttrs
operator|.
name|add
argument_list|(
name|fileEncryptionAttr
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedSetXAttrs
argument_list|(
name|src
argument_list|,
name|xAttrs
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|XAttrSetFlag
operator|.
name|CREATE
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This function combines the per-file encryption info (obtained    * from the inode's XAttrs), and the encryption info from its zone, and    * returns a consolidated FileEncryptionInfo instance. Null is returned    * for non-encrypted files.    *    * @param inode inode of the file    * @param snapshotId ID of the snapshot that    *                   we want to get encryption info from    * @param iip inodes in the path containing the file, passed in to    *            avoid obtaining the list of inodes again; if iip is    *            null then the list of inodes will be obtained again    * @return consolidated file encryption info; null for non-encrypted files    */
DECL|method|getFileEncryptionInfo (INode inode, int snapshotId, INodesInPath iip)
name|FileEncryptionInfo
name|getFileEncryptionInfo
parameter_list|(
name|INode
name|inode
parameter_list|,
name|int
name|snapshotId
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|iip
operator|==
literal|null
condition|)
block|{
name|iip
operator|=
name|getINodesInPath
argument_list|(
name|inode
operator|.
name|getFullPathName
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|EncryptionZone
name|encryptionZone
init|=
name|getEZForPath
argument_list|(
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|encryptionZone
operator|==
literal|null
operator|||
name|encryptionZone
operator|.
name|equals
argument_list|(
name|EncryptionZoneManager
operator|.
name|NULL_EZ
argument_list|)
condition|)
block|{
comment|// not an encrypted file
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|encryptionZone
operator|.
name|getPath
argument_list|()
operator|==
literal|null
operator|||
name|encryptionZone
operator|.
name|getPath
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encryption zone "
operator|+
name|encryptionZone
operator|.
name|getPath
argument_list|()
operator|+
literal|" does not have a valid path."
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|CryptoProtocolVersion
name|version
init|=
name|encryptionZone
operator|.
name|getVersion
argument_list|()
decl_stmt|;
specifier|final
name|CipherSuite
name|suite
init|=
name|encryptionZone
operator|.
name|getSuite
argument_list|()
decl_stmt|;
specifier|final
name|String
name|keyName
init|=
name|encryptionZone
operator|.
name|getKeyName
argument_list|()
decl_stmt|;
name|XAttr
name|fileXAttr
init|=
name|unprotectedGetXAttrByName
argument_list|(
name|inode
argument_list|,
name|snapshotId
argument_list|,
name|CRYPTO_XATTR_FILE_ENCRYPTION_INFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileXAttr
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find encryption XAttr for file "
operator|+
name|inode
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" in encryption zone "
operator|+
name|encryptionZone
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
name|HdfsProtos
operator|.
name|PerFileEncryptionInfoProto
name|fileProto
init|=
name|HdfsProtos
operator|.
name|PerFileEncryptionInfoProto
operator|.
name|parseFrom
argument_list|(
name|fileXAttr
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|PBHelper
operator|.
name|convert
argument_list|(
name|fileProto
argument_list|,
name|suite
argument_list|,
name|version
argument_list|,
name|keyName
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not parse file encryption info for "
operator|+
literal|"inode "
operator|+
name|inode
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setXAttrs (final String src, final List<XAttr> xAttrs, final EnumSet<XAttrSetFlag> flag)
name|void
name|setXAttrs
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|XAttrSetFlag
argument_list|>
name|flag
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedSetXAttrs
argument_list|(
name|src
argument_list|,
name|xAttrs
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetXAttrs (final String src, final List<XAttr> xAttrs, final EnumSet<XAttrSetFlag> flag)
name|INode
name|unprotectedSetXAttrs
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|XAttrSetFlag
argument_list|>
name|flag
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|resolveLastINode
argument_list|(
name|src
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|XAttr
argument_list|>
name|existingXAttrs
init|=
name|XAttrStorage
operator|.
name|readINodeXAttrs
argument_list|(
name|inode
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|XAttr
argument_list|>
name|newXAttrs
init|=
name|setINodeXAttrs
argument_list|(
name|existingXAttrs
argument_list|,
name|xAttrs
argument_list|,
name|flag
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isFile
init|=
name|inode
operator|.
name|isFile
argument_list|()
decl_stmt|;
for|for
control|(
name|XAttr
name|xattr
range|:
name|newXAttrs
control|)
block|{
specifier|final
name|String
name|xaName
init|=
name|XAttrHelper
operator|.
name|getPrefixName
argument_list|(
name|xattr
argument_list|)
decl_stmt|;
comment|/*        * If we're adding the encryption zone xattr, then add src to the list        * of encryption zones.        */
if|if
condition|(
name|CRYPTO_XATTR_ENCRYPTION_ZONE
operator|.
name|equals
argument_list|(
name|xaName
argument_list|)
condition|)
block|{
specifier|final
name|HdfsProtos
operator|.
name|ZoneEncryptionInfoProto
name|ezProto
init|=
name|HdfsProtos
operator|.
name|ZoneEncryptionInfoProto
operator|.
name|parseFrom
argument_list|(
name|xattr
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|ezManager
operator|.
name|addEncryptionZone
argument_list|(
name|inode
operator|.
name|getId
argument_list|()
argument_list|,
name|PBHelper
operator|.
name|convert
argument_list|(
name|ezProto
operator|.
name|getSuite
argument_list|()
argument_list|)
argument_list|,
name|PBHelper
operator|.
name|convert
argument_list|(
name|ezProto
operator|.
name|getCryptoProtocolVersion
argument_list|()
argument_list|)
argument_list|,
name|ezProto
operator|.
name|getKeyName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isFile
operator|&&
name|SECURITY_XATTR_UNREADABLE_BY_SUPERUSER
operator|.
name|equals
argument_list|(
name|xaName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can only set '"
operator|+
name|SECURITY_XATTR_UNREADABLE_BY_SUPERUSER
operator|+
literal|"' on a file."
argument_list|)
throw|;
block|}
block|}
name|XAttrStorage
operator|.
name|updateINodeXAttrs
argument_list|(
name|inode
argument_list|,
name|newXAttrs
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
return|return
name|inode
return|;
block|}
DECL|method|setINodeXAttrs (final List<XAttr> existingXAttrs, final List<XAttr> toSet, final EnumSet<XAttrSetFlag> flag)
name|List
argument_list|<
name|XAttr
argument_list|>
name|setINodeXAttrs
parameter_list|(
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|existingXAttrs
parameter_list|,
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|toSet
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|XAttrSetFlag
argument_list|>
name|flag
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Check for duplicate XAttrs in toSet
comment|// We need to use a custom comparator, so using a HashSet is not suitable
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toSet
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|toSet
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|toSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equalsIgnoreValue
argument_list|(
name|toSet
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot specify the same XAttr to be set "
operator|+
literal|"more than once"
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Count the current number of user-visible XAttrs for limit checking
name|int
name|userVisibleXAttrsNum
init|=
literal|0
decl_stmt|;
comment|// Number of user visible xAttrs
comment|// The XAttr list is copied to an exactly-sized array when it's stored,
comment|// so there's no need to size it precisely here.
name|int
name|newSize
init|=
operator|(
name|existingXAttrs
operator|!=
literal|null
operator|)
condition|?
name|existingXAttrs
operator|.
name|size
argument_list|()
else|:
literal|0
decl_stmt|;
name|newSize
operator|+=
name|toSet
operator|.
name|size
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|newSize
argument_list|)
decl_stmt|;
comment|// Check if the XAttr already exists to validate with the provided flag
for|for
control|(
name|XAttr
name|xAttr
range|:
name|toSet
control|)
block|{
name|boolean
name|exist
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|existingXAttrs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|XAttr
name|a
range|:
name|existingXAttrs
control|)
block|{
if|if
condition|(
name|a
operator|.
name|equalsIgnoreValue
argument_list|(
name|xAttr
argument_list|)
condition|)
block|{
name|exist
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
name|XAttrSetFlag
operator|.
name|validate
argument_list|(
name|xAttr
operator|.
name|getName
argument_list|()
argument_list|,
name|exist
argument_list|,
name|flag
argument_list|)
expr_stmt|;
comment|// add the new XAttr since it passed validation
name|xAttrs
operator|.
name|add
argument_list|(
name|xAttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|isUserVisible
argument_list|(
name|xAttr
argument_list|)
condition|)
block|{
name|userVisibleXAttrsNum
operator|++
expr_stmt|;
block|}
block|}
comment|// Add the existing xattrs back in, if they weren't already set
if|if
condition|(
name|existingXAttrs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|XAttr
name|existing
range|:
name|existingXAttrs
control|)
block|{
name|boolean
name|alreadySet
init|=
literal|false
decl_stmt|;
for|for
control|(
name|XAttr
name|set
range|:
name|toSet
control|)
block|{
if|if
condition|(
name|set
operator|.
name|equalsIgnoreValue
argument_list|(
name|existing
argument_list|)
condition|)
block|{
name|alreadySet
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|alreadySet
condition|)
block|{
name|xAttrs
operator|.
name|add
argument_list|(
name|existing
argument_list|)
expr_stmt|;
if|if
condition|(
name|isUserVisible
argument_list|(
name|existing
argument_list|)
condition|)
block|{
name|userVisibleXAttrsNum
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|userVisibleXAttrsNum
operator|>
name|inodeXAttrsLimit
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot add additional XAttr to inode, "
operator|+
literal|"would exceed limit of "
operator|+
name|inodeXAttrsLimit
argument_list|)
throw|;
block|}
return|return
name|xAttrs
return|;
block|}
DECL|method|isUserVisible (XAttr xAttr)
specifier|private
name|boolean
name|isUserVisible
parameter_list|(
name|XAttr
name|xAttr
parameter_list|)
block|{
if|if
condition|(
name|xAttr
operator|.
name|getNameSpace
argument_list|()
operator|==
name|XAttr
operator|.
name|NameSpace
operator|.
name|USER
operator|||
name|xAttr
operator|.
name|getNameSpace
argument_list|()
operator|==
name|XAttr
operator|.
name|NameSpace
operator|.
name|TRUSTED
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|getXAttrs (String src)
name|List
argument_list|<
name|XAttr
argument_list|>
name|getXAttrs
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INodesInPath
name|iip
init|=
name|getLastINodeInPath
argument_list|(
name|srcs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|resolveLastINode
argument_list|(
name|src
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshotId
init|=
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
return|return
name|unprotectedGetXAttrs
argument_list|(
name|inode
argument_list|,
name|snapshotId
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getXAttrs (INode inode, int snapshotId)
name|List
argument_list|<
name|XAttr
argument_list|>
name|getXAttrs
parameter_list|(
name|INode
name|inode
parameter_list|,
name|int
name|snapshotId
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedGetXAttrs
argument_list|(
name|inode
argument_list|,
name|snapshotId
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedGetXAttrs (INode inode, int snapshotId)
specifier|private
name|List
argument_list|<
name|XAttr
argument_list|>
name|unprotectedGetXAttrs
parameter_list|(
name|INode
name|inode
parameter_list|,
name|int
name|snapshotId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|XAttrStorage
operator|.
name|readINodeXAttrs
argument_list|(
name|inode
argument_list|,
name|snapshotId
argument_list|)
return|;
block|}
DECL|method|unprotectedGetXAttrByName (INode inode, int snapshotId, String xAttrName)
specifier|private
name|XAttr
name|unprotectedGetXAttrByName
parameter_list|(
name|INode
name|inode
parameter_list|,
name|int
name|snapshotId
parameter_list|,
name|String
name|xAttrName
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
init|=
name|XAttrStorage
operator|.
name|readINodeXAttrs
argument_list|(
name|inode
argument_list|,
name|snapshotId
argument_list|)
decl_stmt|;
if|if
condition|(
name|xAttrs
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|XAttr
name|x
range|:
name|xAttrs
control|)
block|{
if|if
condition|(
name|XAttrHelper
operator|.
name|getPrefixName
argument_list|(
name|x
argument_list|)
operator|.
name|equals
argument_list|(
name|xAttrName
argument_list|)
condition|)
block|{
return|return
name|x
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|resolveLastINode (String src, INodesInPath iip)
specifier|private
specifier|static
name|INode
name|resolveLastINode
parameter_list|(
name|String
name|src
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"cannot find "
operator|+
name|src
argument_list|)
throw|;
return|return
name|inode
return|;
block|}
comment|/**    * Caches frequently used file names to reuse file name objects and    * reduce heap size.    */
DECL|method|cacheName (INode inode)
name|void
name|cacheName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
comment|// Name is cached only for files
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return;
block|}
name|ByteArray
name|name
init|=
operator|new
name|ByteArray
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
decl_stmt|;
name|name
operator|=
name|nameCache
operator|.
name|put
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|inode
operator|.
name|setLocalName
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
name|nameCache
operator|.
name|reset
argument_list|()
expr_stmt|;
name|inodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Given an INode get all the path complents leading to it from the root.    * If an Inode corresponding to C is given in /A/B/C, the returned    * patch components will be {root, A, B, C}.    * Note that this method cannot handle scenarios where the inode is in a    * snapshot.    */
DECL|method|getPathComponents (INode inode)
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|getPathComponents
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|components
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|components
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|inode
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|components
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|inode
operator|.
name|getParent
argument_list|()
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
name|inode
operator|=
name|inode
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
name|components
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|components
operator|.
name|size
argument_list|()
index|]
index|[]
argument_list|)
return|;
block|}
comment|/**    * @return path components for reserved path, else null.    */
DECL|method|getPathComponentsForReservedPath (String src)
specifier|static
name|byte
index|[]
index|[]
name|getPathComponentsForReservedPath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
operator|!
name|isReservedName
argument_list|(
name|src
argument_list|)
condition|?
literal|null
else|:
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
return|;
block|}
comment|/** Check if a given inode name is reserved */
DECL|method|isReservedName (INode inode)
specifier|public
specifier|static
name|boolean
name|isReservedName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
return|return
name|CHECK_RESERVED_FILE_NAMES
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|DOT_RESERVED
argument_list|)
return|;
block|}
comment|/** Check if a given path is reserved */
DECL|method|isReservedName (String src)
specifier|public
specifier|static
name|boolean
name|isReservedName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|src
operator|.
name|startsWith
argument_list|(
name|DOT_RESERVED_PATH_PREFIX
argument_list|)
return|;
block|}
DECL|method|isReservedRawName (String src)
specifier|static
name|boolean
name|isReservedRawName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|src
operator|.
name|startsWith
argument_list|(
name|DOT_RESERVED_PATH_PREFIX
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|RAW_STRING
argument_list|)
return|;
block|}
comment|/**    * Resolve a /.reserved/... path to a non-reserved path.    *<p/>    * There are two special hierarchies under /.reserved/:    *<p/>    * /.reserved/.inodes/<inodeid> performs a path lookup by inodeid,    *<p/>    * /.reserved/raw/... returns the encrypted (raw) bytes of a file in an    * encryption zone. For instance, if /ezone is an encryption zone, then    * /ezone/a refers to the decrypted file and /.reserved/raw/ezone/a refers to    * the encrypted (raw) bytes of /ezone/a.    *<p/>    * Pathnames in the /.reserved/raw directory that resolve to files not in an    * encryption zone are equivalent to the corresponding non-raw path. Hence,    * if /a/b/c refers to a file that is not in an encryption zone, then    * /.reserved/raw/a/b/c is equivalent (they both refer to the same    * unencrypted file).    *     * @param src path that is being processed    * @param pathComponents path components corresponding to the path    * @param fsd FSDirectory    * @return if the path indicates an inode, return path after replacing up to    *<inodeid> with the corresponding path of the inode, else the path    *         in {@code src} as is. If the path refers to a path in the "raw"    *         directory, return the non-raw pathname.    * @throws FileNotFoundException if inodeid is invalid    */
DECL|method|resolvePath (String src, byte[][] pathComponents, FSDirectory fsd)
specifier|static
name|String
name|resolvePath
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|,
name|FSDirectory
name|fsd
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|int
name|nComponents
init|=
operator|(
name|pathComponents
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|pathComponents
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|nComponents
operator|<=
literal|2
condition|)
block|{
return|return
name|src
return|;
block|}
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|DOT_RESERVED
argument_list|,
name|pathComponents
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* This is not a /.reserved/ path so do nothing. */
return|return
name|src
return|;
block|}
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|DOT_INODES
argument_list|,
name|pathComponents
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* It's a /.reserved/.inodes path. */
if|if
condition|(
name|nComponents
operator|>
literal|3
condition|)
block|{
return|return
name|resolveDotInodesPath
argument_list|(
name|src
argument_list|,
name|pathComponents
argument_list|,
name|fsd
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|src
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|RAW
argument_list|,
name|pathComponents
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* It's /.reserved/raw so strip off the /.reserved/raw prefix. */
if|if
condition|(
name|nComponents
operator|==
literal|3
condition|)
block|{
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
else|else
block|{
return|return
name|constructRemainingPath
argument_list|(
literal|""
argument_list|,
name|pathComponents
argument_list|,
literal|3
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* It's some sort of /.reserved/<unknown> path. Ignore it. */
return|return
name|src
return|;
block|}
block|}
DECL|method|resolveDotInodesPath (String src, byte[][] pathComponents, FSDirectory fsd)
specifier|private
specifier|static
name|String
name|resolveDotInodesPath
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|,
name|FSDirectory
name|fsd
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|String
name|inodeId
init|=
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
specifier|final
name|long
name|id
decl_stmt|;
try|try
block|{
name|id
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Invalid inode path: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
operator|&&
name|pathComponents
operator|.
name|length
operator|==
literal|4
condition|)
block|{
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
name|INode
name|inode
init|=
name|fsd
operator|.
name|getInode
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File for given inode path does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
comment|// Handle single ".." for NFS lookup support.
if|if
condition|(
operator|(
name|pathComponents
operator|.
name|length
operator|>
literal|4
operator|)
operator|&&
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
literal|4
index|]
argument_list|)
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
name|INode
name|parent
init|=
name|inode
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
operator|||
name|parent
operator|.
name|getId
argument_list|()
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|)
block|{
comment|// inode is root, or its parent is root.
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
else|else
block|{
return|return
name|parent
operator|.
name|getFullPathName
argument_list|()
return|;
block|}
block|}
name|String
name|path
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|id
operator|!=
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|)
block|{
name|path
operator|=
name|inode
operator|.
name|getFullPathName
argument_list|()
expr_stmt|;
block|}
return|return
name|constructRemainingPath
argument_list|(
name|path
argument_list|,
name|pathComponents
argument_list|,
literal|4
argument_list|)
return|;
block|}
DECL|method|constructRemainingPath (String pathPrefix, byte[][] pathComponents, int startAt)
specifier|private
specifier|static
name|String
name|constructRemainingPath
parameter_list|(
name|String
name|pathPrefix
parameter_list|,
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|,
name|int
name|startAt
parameter_list|)
block|{
name|StringBuilder
name|path
init|=
operator|new
name|StringBuilder
argument_list|(
name|pathPrefix
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startAt
init|;
name|i
operator|<
name|pathComponents
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|path
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Resolved path is "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|path
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** @return the {@link INodesInPath} containing only the last inode. */
DECL|method|getLastINodeInPath (String path, boolean resolveLink )
specifier|private
name|INodesInPath
name|getLastINodeInPath
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|INode
operator|.
name|getPathComponents
argument_list|(
name|path
argument_list|)
argument_list|,
literal|1
argument_list|,
name|resolveLink
argument_list|)
return|;
block|}
comment|/** @return the {@link INodesInPath} containing all inodes in the path. */
DECL|method|getINodesInPath (String path, boolean resolveLink )
name|INodesInPath
name|getINodesInPath
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
specifier|final
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|components
argument_list|,
name|components
operator|.
name|length
argument_list|,
name|resolveLink
argument_list|)
return|;
block|}
comment|/** @return the last inode in the path. */
DECL|method|getNode (String path, boolean resolveLink)
name|INode
name|getNode
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|getLastINodeInPath
argument_list|(
name|path
argument_list|,
name|resolveLink
argument_list|)
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * @return the INode of the last component in src, or null if the last    * component does not exist.    * @throws UnresolvedLinkException if symlink can't be resolved    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|getINode4Write (String src, boolean resolveLink)
specifier|private
name|INode
name|getINode4Write
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
return|return
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
name|resolveLink
argument_list|)
operator|.
name|getLastINode
argument_list|()
return|;
block|}
comment|/**    * @return the INodesInPath of the components in src    * @throws UnresolvedLinkException if symlink can't be resolved    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|getINodesInPath4Write (String src, boolean resolveLink)
name|INodesInPath
name|getINodesInPath4Write
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
specifier|final
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|INodesInPath
name|inodesInPath
init|=
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|components
argument_list|,
name|components
operator|.
name|length
argument_list|,
name|resolveLink
argument_list|)
decl_stmt|;
if|if
condition|(
name|inodesInPath
operator|.
name|isSnapshot
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SnapshotAccessControlException
argument_list|(
literal|"Modification on a read-only snapshot is disallowed"
argument_list|)
throw|;
block|}
return|return
name|inodesInPath
return|;
block|}
block|}
end_class

end_unit

