begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CipherSuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CryptoProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttrSetFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|XAttrHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|AclException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|EncryptionZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|MaxDirectoryItemsExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|PathComponentTooLongException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotAccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HdfsProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|PBHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapUpdateInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ChunkedArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BatchedRemoteIterator
operator|.
name|BatchedListEntries
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACCESSTIME_PRECISION_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACCESSTIME_PRECISION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|CRYPTO_XATTR_ENCRYPTION_ZONE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|CRYPTO_XATTR_FILE_ENCRYPTION_INFO
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
operator|.
name|CURRENT_STATE_ID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_comment
comment|/**  * Both FSDirectory and FSNamesystem manage the state of the namespace.  * FSDirectory is a pure in-memory data structure, all of whose operations  * happen entirely in memory. In contrast, FSNamesystem persists the operations  * to the disk.  * @see org.apache.hadoop.hdfs.server.namenode.FSNamesystem  **/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|FSDirectory
specifier|public
class|class
name|FSDirectory
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|createRoot (FSNamesystem namesystem)
specifier|private
specifier|static
name|INodeDirectory
name|createRoot
parameter_list|(
name|FSNamesystem
name|namesystem
parameter_list|)
block|{
specifier|final
name|INodeDirectory
name|r
init|=
operator|new
name|INodeDirectory
argument_list|(
name|INodeId
operator|.
name|ROOT_INODE_ID
argument_list|,
name|INodeDirectory
operator|.
name|ROOT_NAME
argument_list|,
name|namesystem
operator|.
name|createFsOwnerPermissions
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
argument_list|)
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
name|r
operator|.
name|addDirectoryWithQuotaFeature
argument_list|(
name|DirectoryWithQuotaFeature
operator|.
name|DEFAULT_NAMESPACE_QUOTA
argument_list|,
name|DirectoryWithQuotaFeature
operator|.
name|DEFAULT_DISKSPACE_QUOTA
argument_list|)
expr_stmt|;
name|r
operator|.
name|addSnapshottableFeature
argument_list|()
expr_stmt|;
name|r
operator|.
name|setSnapshotQuota
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|field|CHECK_RESERVED_FILE_NAMES
specifier|static
name|boolean
name|CHECK_RESERVED_FILE_NAMES
init|=
literal|true
decl_stmt|;
DECL|field|DOT_RESERVED_STRING
specifier|public
specifier|final
specifier|static
name|String
name|DOT_RESERVED_STRING
init|=
literal|".reserved"
decl_stmt|;
DECL|field|DOT_RESERVED_PATH_PREFIX
specifier|public
specifier|final
specifier|static
name|String
name|DOT_RESERVED_PATH_PREFIX
init|=
name|Path
operator|.
name|SEPARATOR
operator|+
name|DOT_RESERVED_STRING
decl_stmt|;
DECL|field|DOT_RESERVED
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|DOT_RESERVED
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|DOT_RESERVED_STRING
argument_list|)
decl_stmt|;
DECL|field|RAW_STRING
specifier|private
specifier|final
specifier|static
name|String
name|RAW_STRING
init|=
literal|"raw"
decl_stmt|;
DECL|field|RAW
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|RAW
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|RAW_STRING
argument_list|)
decl_stmt|;
DECL|field|DOT_INODES_STRING
specifier|public
specifier|final
specifier|static
name|String
name|DOT_INODES_STRING
init|=
literal|".inodes"
decl_stmt|;
DECL|field|DOT_INODES
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|DOT_INODES
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|DOT_INODES_STRING
argument_list|)
decl_stmt|;
DECL|field|rootDir
name|INodeDirectory
name|rootDir
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|skipQuotaCheck
specifier|private
specifier|volatile
name|boolean
name|skipQuotaCheck
init|=
literal|false
decl_stmt|;
comment|//skip while consuming edits
DECL|field|maxComponentLength
specifier|private
specifier|final
name|int
name|maxComponentLength
decl_stmt|;
DECL|field|maxDirItems
specifier|private
specifier|final
name|int
name|maxDirItems
decl_stmt|;
DECL|field|lsLimit
specifier|private
specifier|final
name|int
name|lsLimit
decl_stmt|;
comment|// max list limit
DECL|field|contentCountLimit
specifier|private
specifier|final
name|int
name|contentCountLimit
decl_stmt|;
comment|// max content summary counts per run
DECL|field|inodeMap
specifier|private
specifier|final
name|INodeMap
name|inodeMap
decl_stmt|;
comment|// Synchronized by dirLock
DECL|field|yieldCount
specifier|private
name|long
name|yieldCount
init|=
literal|0
decl_stmt|;
comment|// keep track of lock yield count.
DECL|field|inodeXAttrsLimit
specifier|private
specifier|final
name|int
name|inodeXAttrsLimit
decl_stmt|;
comment|//inode xattrs max limit
comment|// lock to protect the directory and BlockMap
DECL|field|dirLock
specifier|private
specifier|final
name|ReentrantReadWriteLock
name|dirLock
decl_stmt|;
DECL|field|isPermissionEnabled
specifier|private
specifier|final
name|boolean
name|isPermissionEnabled
decl_stmt|;
comment|/**    * Support for ACLs is controlled by a configuration flag. If the    * configuration flag is false, then the NameNode will reject all    * ACL-related operations.    */
DECL|field|aclsEnabled
specifier|private
specifier|final
name|boolean
name|aclsEnabled
decl_stmt|;
DECL|field|xattrsEnabled
specifier|private
specifier|final
name|boolean
name|xattrsEnabled
decl_stmt|;
DECL|field|xattrMaxSize
specifier|private
specifier|final
name|int
name|xattrMaxSize
decl_stmt|;
comment|// precision of access times.
DECL|field|accessTimePrecision
specifier|private
specifier|final
name|long
name|accessTimePrecision
decl_stmt|;
comment|// whether setStoragePolicy is allowed.
DECL|field|storagePolicyEnabled
specifier|private
specifier|final
name|boolean
name|storagePolicyEnabled
decl_stmt|;
DECL|field|fsOwnerShortUserName
specifier|private
specifier|final
name|String
name|fsOwnerShortUserName
decl_stmt|;
DECL|field|supergroup
specifier|private
specifier|final
name|String
name|supergroup
decl_stmt|;
DECL|field|inodeId
specifier|private
specifier|final
name|INodeId
name|inodeId
decl_stmt|;
DECL|field|editLog
specifier|private
specifier|final
name|FSEditLog
name|editLog
decl_stmt|;
comment|// utility methods to acquire and release read lock and write lock
DECL|method|readLock ()
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|readUnlock ()
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeLock ()
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeUnlock ()
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|hasWriteLock ()
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|isWriteLockedByCurrentThread
argument_list|()
return|;
block|}
DECL|method|hasReadLock ()
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getReadHoldCount
argument_list|()
operator|>
literal|0
operator|||
name|hasWriteLock
argument_list|()
return|;
block|}
DECL|method|getReadHoldCount ()
specifier|public
name|int
name|getReadHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getReadHoldCount
argument_list|()
return|;
block|}
DECL|method|getWriteHoldCount ()
specifier|public
name|int
name|getWriteHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getWriteHoldCount
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|field|ezManager
specifier|public
specifier|final
name|EncryptionZoneManager
name|ezManager
decl_stmt|;
comment|/**    * Caches frequently used file names used in {@link INode} to reuse     * byte[] objects and reduce heap usage.    */
DECL|field|nameCache
specifier|private
specifier|final
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
name|nameCache
decl_stmt|;
DECL|method|FSDirectory (FSNamesystem ns, Configuration conf)
name|FSDirectory
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|dirLock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// fair
name|this
operator|.
name|inodeId
operator|=
operator|new
name|INodeId
argument_list|()
expr_stmt|;
name|rootDir
operator|=
name|createRoot
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|inodeMap
operator|=
name|INodeMap
operator|.
name|newInstance
argument_list|(
name|rootDir
argument_list|)
expr_stmt|;
name|this
operator|.
name|isPermissionEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsOwnerShortUserName
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
name|this
operator|.
name|supergroup
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|aclsEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACLS_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACLS_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"ACLs enabled? "
operator|+
name|aclsEnabled
argument_list|)
expr_stmt|;
name|this
operator|.
name|xattrsEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_XATTRS_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_XATTRS_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"XAttrs enabled? "
operator|+
name|xattrsEnabled
argument_list|)
expr_stmt|;
name|this
operator|.
name|xattrMaxSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTR_SIZE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTR_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|xattrMaxSize
operator|>=
literal|0
argument_list|,
literal|"Cannot set a negative value for the maximum size of an xattr (%s)."
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTR_SIZE_KEY
argument_list|)
expr_stmt|;
specifier|final
name|String
name|unlimited
init|=
name|xattrMaxSize
operator|==
literal|0
condition|?
literal|" (unlimited)"
else|:
literal|""
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Maximum size of an xattr: "
operator|+
name|xattrMaxSize
operator|+
name|unlimited
argument_list|)
expr_stmt|;
name|this
operator|.
name|accessTimePrecision
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_ACCESSTIME_PRECISION_KEY
argument_list|,
name|DFS_NAMENODE_ACCESSTIME_PRECISION_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|storagePolicyEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_STORAGE_POLICY_ENABLED_KEY
argument_list|,
name|DFS_STORAGE_POLICY_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|int
name|configuredLimit
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
argument_list|)
decl_stmt|;
name|this
operator|.
name|lsLimit
operator|=
name|configuredLimit
operator|>
literal|0
condition|?
name|configuredLimit
else|:
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
expr_stmt|;
name|this
operator|.
name|contentCountLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CONTENT_SUMMARY_LIMIT_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CONTENT_SUMMARY_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
comment|// filesystem limits
name|this
operator|.
name|maxComponentLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxDirItems
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|inodeXAttrsLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTRS_PER_INODE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTRS_PER_INODE_DEFAULT
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|this
operator|.
name|inodeXAttrsLimit
operator|>=
literal|0
argument_list|,
literal|"Cannot set a negative limit on the number of xattrs per inode (%s)."
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTRS_PER_INODE_KEY
argument_list|)
expr_stmt|;
comment|// We need a maximum maximum because by default, PB limits message sizes
comment|// to 64MB. This means we can only store approximately 6.7 million entries
comment|// per directory, but let's use 6.4 million for some safety.
specifier|final
name|int
name|MAX_DIR_ITEMS
init|=
literal|64
operator|*
literal|100
operator|*
literal|1000
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|maxDirItems
operator|>
literal|0
operator|&&
name|maxDirItems
operator|<=
name|MAX_DIR_ITEMS
argument_list|,
literal|"Cannot set "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_KEY
operator|+
literal|" to a value less than 1 or greater than "
operator|+
name|MAX_DIR_ITEMS
argument_list|)
expr_stmt|;
name|int
name|threshold
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_DEFAULT
argument_list|)
decl_stmt|;
name|NameNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Caching file names occuring more than "
operator|+
name|threshold
operator|+
literal|" times"
argument_list|)
expr_stmt|;
name|nameCache
operator|=
operator|new
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|namesystem
operator|=
name|ns
expr_stmt|;
name|this
operator|.
name|editLog
operator|=
name|ns
operator|.
name|getEditLog
argument_list|()
expr_stmt|;
name|ezManager
operator|=
operator|new
name|EncryptionZoneManager
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|getFSNamesystem ()
name|FSNamesystem
name|getFSNamesystem
parameter_list|()
block|{
return|return
name|namesystem
return|;
block|}
DECL|method|getBlockManager ()
specifier|private
name|BlockManager
name|getBlockManager
parameter_list|()
block|{
return|return
name|getFSNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
return|;
block|}
comment|/** @return the root directory inode. */
DECL|method|getRoot ()
specifier|public
name|INodeDirectory
name|getRoot
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
DECL|method|isPermissionEnabled ()
name|boolean
name|isPermissionEnabled
parameter_list|()
block|{
return|return
name|isPermissionEnabled
return|;
block|}
DECL|method|isAclsEnabled ()
name|boolean
name|isAclsEnabled
parameter_list|()
block|{
return|return
name|aclsEnabled
return|;
block|}
DECL|method|isXattrsEnabled ()
name|boolean
name|isXattrsEnabled
parameter_list|()
block|{
return|return
name|xattrsEnabled
return|;
block|}
DECL|method|getXattrMaxSize ()
name|int
name|getXattrMaxSize
parameter_list|()
block|{
return|return
name|xattrMaxSize
return|;
block|}
DECL|method|isStoragePolicyEnabled ()
name|boolean
name|isStoragePolicyEnabled
parameter_list|()
block|{
return|return
name|storagePolicyEnabled
return|;
block|}
DECL|method|isAccessTimeSupported ()
name|boolean
name|isAccessTimeSupported
parameter_list|()
block|{
return|return
name|accessTimePrecision
operator|>
literal|0
return|;
block|}
DECL|method|getLsLimit ()
name|int
name|getLsLimit
parameter_list|()
block|{
return|return
name|lsLimit
return|;
block|}
DECL|method|getContentCountLimit ()
name|int
name|getContentCountLimit
parameter_list|()
block|{
return|return
name|contentCountLimit
return|;
block|}
DECL|method|getInodeXAttrsLimit ()
name|int
name|getInodeXAttrsLimit
parameter_list|()
block|{
return|return
name|inodeXAttrsLimit
return|;
block|}
DECL|method|getEditLog ()
name|FSEditLog
name|getEditLog
parameter_list|()
block|{
return|return
name|editLog
return|;
block|}
comment|/**    * Shutdown the filestore    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{}
DECL|method|markNameCacheInitialized ()
name|void
name|markNameCacheInitialized
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|nameCache
operator|.
name|initialized
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|shouldSkipQuotaChecks ()
name|boolean
name|shouldSkipQuotaChecks
parameter_list|()
block|{
return|return
name|skipQuotaCheck
return|;
block|}
comment|/** Enable quota verification */
DECL|method|enableQuotaChecks ()
name|void
name|enableQuotaChecks
parameter_list|()
block|{
name|skipQuotaCheck
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Disable quota verification */
DECL|method|disableQuotaChecks ()
name|void
name|disableQuotaChecks
parameter_list|()
block|{
name|skipQuotaCheck
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|newINodeFile (long id, PermissionStatus permissions, long mtime, long atime, short replication, long preferredBlockSize)
specifier|private
specifier|static
name|INodeFile
name|newINodeFile
parameter_list|(
name|long
name|id
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|)
block|{
return|return
name|newINodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
return|;
block|}
DECL|method|newINodeFile (long id, PermissionStatus permissions, long mtime, long atime, short replication, long preferredBlockSize, byte storagePolicyId)
specifier|private
specifier|static
name|INodeFile
name|newINodeFile
parameter_list|(
name|long
name|id
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|byte
name|storagePolicyId
parameter_list|)
block|{
return|return
operator|new
name|INodeFile
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|permissions
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|BlockInfo
operator|.
name|EMPTY_ARRAY
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|storagePolicyId
argument_list|)
return|;
block|}
comment|/**    * Add the given filename to the fs.    * @return the new INodesInPath instance that contains the new INode    */
DECL|method|addFile (INodesInPath existing, String localName, PermissionStatus permissions, short replication, long preferredBlockSize, String clientName, String clientMachine)
name|INodesInPath
name|addFile
parameter_list|(
name|INodesInPath
name|existing
parameter_list|,
name|String
name|localName
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
throws|,
name|AclException
block|{
name|long
name|modTime
init|=
name|now
argument_list|()
decl_stmt|;
name|INodeFile
name|newNode
init|=
name|newINodeFile
argument_list|(
name|allocateNewInodeId
argument_list|()
argument_list|,
name|permissions
argument_list|,
name|modTime
argument_list|,
name|modTime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|)
decl_stmt|;
name|newNode
operator|.
name|setLocalName
argument_list|(
name|localName
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|toUnderConstruction
argument_list|(
name|clientName
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
name|INodesInPath
name|newiip
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|newiip
operator|=
name|addINode
argument_list|(
name|existing
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|newiip
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* addFile: failed to add "
operator|+
name|existing
operator|.
name|getPath
argument_list|()
operator|+
literal|"/"
operator|+
name|localName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* addFile: "
operator|+
name|localName
operator|+
literal|" is added"
argument_list|)
expr_stmt|;
block|}
return|return
name|newiip
return|;
block|}
DECL|method|addFileForEditLog (long id, INodesInPath existing, byte[] localName, PermissionStatus permissions, List<AclEntry> aclEntries, List<XAttr> xAttrs, short replication, long modificationTime, long atime, long preferredBlockSize, boolean underConstruction, String clientName, String clientMachine, byte storagePolicyId)
name|INodeFile
name|addFileForEditLog
parameter_list|(
name|long
name|id
parameter_list|,
name|INodesInPath
name|existing
parameter_list|,
name|byte
index|[]
name|localName
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclEntries
parameter_list|,
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|modificationTime
parameter_list|,
name|long
name|atime
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|boolean
name|underConstruction
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|byte
name|storagePolicyId
parameter_list|)
block|{
specifier|final
name|INodeFile
name|newNode
decl_stmt|;
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|underConstruction
condition|)
block|{
name|newNode
operator|=
name|newINodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|modificationTime
argument_list|,
name|modificationTime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|storagePolicyId
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|toUnderConstruction
argument_list|(
name|clientName
argument_list|,
name|clientMachine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNode
operator|=
name|newINodeFile
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|modificationTime
argument_list|,
name|atime
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|storagePolicyId
argument_list|)
expr_stmt|;
block|}
name|newNode
operator|.
name|setLocalName
argument_list|(
name|localName
argument_list|)
expr_stmt|;
try|try
block|{
name|INodesInPath
name|iip
init|=
name|addINode
argument_list|(
name|existing
argument_list|,
name|newNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|iip
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|aclEntries
operator|!=
literal|null
condition|)
block|{
name|AclStorage
operator|.
name|updateINodeAcl
argument_list|(
name|newNode
argument_list|,
name|aclEntries
argument_list|,
name|CURRENT_STATE_ID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xAttrs
operator|!=
literal|null
condition|)
block|{
name|XAttrStorage
operator|.
name|updateINodeXAttrs
argument_list|(
name|newNode
argument_list|,
name|xAttrs
argument_list|,
name|CURRENT_STATE_ID
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedAddFile: exception when add "
operator|+
name|existing
operator|.
name|getPath
argument_list|()
operator|+
literal|" to the file system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Add a block to the file. Returns a reference to the added block.    */
DECL|method|addBlock (String path, INodesInPath inodesInPath, Block block, DatanodeStorageInfo[] targets)
name|BlockInfo
name|addBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|Block
name|block
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodeFile
name|fileINode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
comment|// check quota limits and updated space consumed
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
literal|0
argument_list|,
name|fileINode
operator|.
name|getBlockDiskspace
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// associate new last block for the file
name|BlockInfoUnderConstruction
name|blockInfo
init|=
operator|new
name|BlockInfoUnderConstruction
argument_list|(
name|block
argument_list|,
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|,
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|fileINode
argument_list|)
expr_stmt|;
name|fileINode
operator|.
name|addBlock
argument_list|(
name|blockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.addBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is added to the in-memory "
operator|+
literal|"file system"
argument_list|)
expr_stmt|;
block|}
return|return
name|blockInfo
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Remove a block from the file.    * @return Whether the block exists in the corresponding file    */
DECL|method|removeBlock (String path, INodesInPath iip, INodeFile fileNode, Block block)
name|boolean
name|removeBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|INodeFile
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fileNode
operator|.
name|isUnderConstruction
argument_list|()
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedRemoveBlock
argument_list|(
name|path
argument_list|,
name|iip
argument_list|,
name|fileNode
argument_list|,
name|block
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedRemoveBlock (String path, INodesInPath iip, INodeFile fileNode, Block block)
name|boolean
name|unprotectedRemoveBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|INodeFile
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
comment|// modify file-> block and blocksMap
comment|// fileNode should be under construction
name|boolean
name|removed
init|=
name|fileNode
operator|.
name|removeLastBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|removed
condition|)
block|{
return|return
literal|false
return|;
block|}
name|getBlockManager
argument_list|()
operator|.
name|removeBlockFromMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.removeBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is removed from the file system"
argument_list|)
expr_stmt|;
block|}
comment|// update space consumed
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
operator|-
name|fileNode
operator|.
name|getBlockDiskspace
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * This is a wrapper for resolvePath(). If the path passed    * is prefixed with /.reserved/raw, then it checks to ensure that the caller    * has super user privileges.    *    * @param pc The permission checker used when resolving path.    * @param path The path to resolve.    * @param pathComponents path components corresponding to the path    * @return if the path indicates an inode, return path after replacing up to    *<inodeid> with the corresponding path of the inode, else the path    *         in {@code src} as is. If the path refers to a path in the "raw"    *         directory, return the non-raw pathname.    * @throws FileNotFoundException    * @throws AccessControlException    */
DECL|method|resolvePath (FSPermissionChecker pc, String path, byte[][] pathComponents)
name|String
name|resolvePath
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|String
name|path
parameter_list|,
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|AccessControlException
block|{
if|if
condition|(
name|isReservedRawName
argument_list|(
name|path
argument_list|)
operator|&&
name|isPermissionEnabled
condition|)
block|{
name|pc
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
block|}
return|return
name|resolvePath
argument_list|(
name|path
argument_list|,
name|pathComponents
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**    * Delete the target directory and collect the blocks under it    *    * @param iip the INodesInPath instance containing all the INodes for the path    * @param collectedBlocks Blocks under the deleted directory    * @param removedINodes INodes that should be removed from {@link #inodeMap}    * @return the number of files that have been removed    */
DECL|method|delete (INodesInPath iip, BlocksMapUpdateInfo collectedBlocks, List<INode> removedINodes, long mtime)
name|long
name|delete
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.delete: "
operator|+
name|iip
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|filesRemoved
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|deleteAllowed
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|filesRemoved
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|INodeDirectory
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectory
argument_list|>
argument_list|()
decl_stmt|;
name|FSDirSnapshotOp
operator|.
name|checkSnapshot
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
name|filesRemoved
operator|=
name|unprotectedDelete
argument_list|(
name|iip
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|removeSnapshottableDirs
argument_list|(
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
return|return
name|filesRemoved
return|;
block|}
DECL|method|deleteAllowed (final INodesInPath iip, final String src)
specifier|private
specifier|static
name|boolean
name|deleteAllowed
parameter_list|(
specifier|final
name|INodesInPath
name|iip
parameter_list|,
specifier|final
name|String
name|src
parameter_list|)
block|{
if|if
condition|(
name|iip
operator|.
name|length
argument_list|()
operator|<
literal|1
operator|||
name|iip
operator|.
name|getLastINode
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
literal|"failed to remove "
operator|+
name|src
operator|+
literal|" because it does not exist"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|iip
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// src is the root
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
literal|"failed to remove "
operator|+
name|src
operator|+
literal|" because the root is not allowed to be deleted"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @return true if the path is a non-empty directory; otherwise, return false.    */
DECL|method|isNonEmptyDirectory (INodesInPath inodesInPath)
name|boolean
name|isNonEmptyDirectory
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
operator|||
operator|!
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//not found or not a directory
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|s
init|=
name|inodesInPath
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
return|return
operator|!
name|inode
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenList
argument_list|(
name|s
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Delete a path from the name space    * Update the count at each ancestor directory with quota    *<br>    * Note: This is to be used by {@link FSEditLog} only.    *<br>    * @param src a string representation of a path to an inode    * @param mtime the time the inode is removed    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|unprotectedDelete (String src, long mtime)
name|void
name|unprotectedDelete
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
init|=
operator|new
name|ChunkedArrayList
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|long
name|filesRemoved
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|deleteAllowed
argument_list|(
name|inodesInPath
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|INodeDirectory
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectory
argument_list|>
argument_list|()
decl_stmt|;
name|FSDirSnapshotOp
operator|.
name|checkSnapshot
argument_list|(
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
name|filesRemoved
operator|=
name|unprotectedDelete
argument_list|(
name|inodesInPath
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|removeSnapshottableDirs
argument_list|(
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filesRemoved
operator|>=
literal|0
condition|)
block|{
name|getFSNamesystem
argument_list|()
operator|.
name|removePathAndBlocks
argument_list|(
name|src
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a path from the name space    * Update the count at each ancestor directory with quota    * @param iip the inodes resolved from the path    * @param collectedBlocks blocks collected from the deleted path    * @param removedINodes inodes that should be removed from {@link #inodeMap}    * @param mtime the time the inode is removed    * @return the number of inodes deleted; 0 if no inodes are deleted.    */
DECL|method|unprotectedDelete (INodesInPath iip, BlocksMapUpdateInfo collectedBlocks, List<INode> removedINodes, long mtime)
name|long
name|unprotectedDelete
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// check if target node exists
name|INode
name|targetNode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// record modification
specifier|final
name|int
name|latestSnapshot
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|targetNode
operator|.
name|recordModification
argument_list|(
name|latestSnapshot
argument_list|)
expr_stmt|;
comment|// Remove the node from the namespace
name|long
name|removed
init|=
name|removeLastINode
argument_list|(
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// set the parent's modification time
specifier|final
name|INodeDirectory
name|parent
init|=
name|targetNode
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|parent
operator|.
name|updateModificationTime
argument_list|(
name|mtime
argument_list|,
name|latestSnapshot
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// collect block
if|if
condition|(
operator|!
name|targetNode
operator|.
name|isInLatestSnapshot
argument_list|(
name|latestSnapshot
argument_list|)
condition|)
block|{
name|targetNode
operator|.
name|destroyAndCollectBlocks
argument_list|(
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Quota
operator|.
name|Counts
name|counts
init|=
name|targetNode
operator|.
name|cleanSubtree
argument_list|(
name|CURRENT_STATE_ID
argument_list|,
name|latestSnapshot
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|parent
operator|.
name|addSpaceConsumed
argument_list|(
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
name|iip
operator|.
name|getPath
argument_list|()
operator|+
literal|" is removed"
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
comment|/**     * Check whether the filepath could be created    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|isValidToCreate (String src, INodesInPath iip)
name|boolean
name|isValidToCreate
parameter_list|(
name|String
name|src
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|SnapshotAccessControlException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
return|return
name|srcs
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
operator|!
name|srcs
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|iip
operator|.
name|getLastINode
argument_list|()
operator|==
literal|null
return|;
block|}
comment|/**    * Check whether the path specifies a directory    */
DECL|method|isDir (String src)
name|boolean
name|isDir
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|node
init|=
name|getINode
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Updates namespace and diskspace consumed for all    * directories until the parent directory of file represented by path.    *    * @param iip the INodesInPath instance containing all the INodes for    *            updating quota usage    * @param nsDelta the delta change of namespace    * @param dsDelta the delta change of diskspace    * @throws QuotaExceededException if the new count violates any quota limit    * @throws FileNotFoundException if path does not exist.    */
DECL|method|updateSpaceConsumed (INodesInPath iip, long nsDelta, long dsDelta)
name|void
name|updateSpaceConsumed
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|iip
operator|.
name|getLastINode
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Path not found: "
operator|+
name|iip
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|updateCount
argument_list|(
name|iip
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateCount (INodesInPath iip, long nsDelta, long dsDelta, boolean checkQuota)
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|updateCount
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
block|}
comment|/** update count of each inode with quota    *     * @param iip inodes in a path    * @param numOfINodes the number of inodes to update starting from index 0    * @param nsDelta the delta change of namespace    * @param dsDelta the delta change of diskspace    * @param checkQuota if true then check if quota is exceeded    * @throws QuotaExceededException if the new count violates any quota limit    */
DECL|method|updateCount (INodesInPath iip, int numOfINodes, long nsDelta, long dsDelta, boolean checkQuota)
specifier|private
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
comment|//still initializing. do not check or update quotas.
return|return;
block|}
if|if
condition|(
name|numOfINodes
operator|>
name|iip
operator|.
name|length
argument_list|()
condition|)
block|{
name|numOfINodes
operator|=
name|iip
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|checkQuota
operator|&&
operator|!
name|skipQuotaCheck
condition|)
block|{
name|verifyQuota
argument_list|(
name|iip
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|unprotectedUpdateCount
argument_list|(
name|iip
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
comment|/**     * update quota of each inode and check to see if quota is exceeded.     * See {@link #updateCount(INodesInPath, long, long, boolean)}    */
DECL|method|updateCountNoQuotaCheck (INodesInPath inodesInPath, int numOfINodes, long nsDelta, long dsDelta)
specifier|private
name|void
name|updateCountNoQuotaCheck
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
try|try
block|{
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"BUG: unexpected exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * updates quota without verification    * callers responsibility is to make sure quota is not exceeded    */
DECL|method|unprotectedUpdateCount (INodesInPath inodesInPath, int numOfINodes, long nsDelta, long dsDelta)
specifier|static
name|void
name|unprotectedUpdateCount
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfINodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inodesInPath
operator|.
name|getINode
argument_list|(
name|i
argument_list|)
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
comment|// a directory with quota
name|inodesInPath
operator|.
name|getINode
argument_list|(
name|i
argument_list|)
operator|.
name|asDirectory
argument_list|()
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
operator|.
name|addSpaceConsumed2Cache
argument_list|(
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Return the name of the path represented by inodes at [0, pos] */
DECL|method|getFullPathName (INode[] inodes, int pos)
specifier|static
name|String
name|getFullPathName
parameter_list|(
name|INode
index|[]
name|inodes
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|StringBuilder
name|fullPathName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|inodes
index|[
literal|0
index|]
operator|.
name|isRoot
argument_list|()
condition|)
block|{
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
else|else
block|{
name|fullPathName
operator|.
name|append
argument_list|(
name|inodes
index|[
literal|0
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|pos
condition|;
name|i
operator|++
control|)
block|{
name|fullPathName
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR_CHAR
argument_list|)
operator|.
name|append
argument_list|(
name|inodes
index|[
name|i
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|fullPathName
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return the relative path of an inode from one of its ancestors,    *         represented by an array of inodes.    */
DECL|method|getRelativePathINodes (INode inode, INode ancestor)
specifier|private
specifier|static
name|INode
index|[]
name|getRelativePathINodes
parameter_list|(
name|INode
name|inode
parameter_list|,
name|INode
name|ancestor
parameter_list|)
block|{
comment|// calculate the depth of this inode from the ancestor
name|int
name|depth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|INode
name|i
init|=
name|inode
init|;
name|i
operator|!=
literal|null
operator|&&
operator|!
name|i
operator|.
name|equals
argument_list|(
name|ancestor
argument_list|)
condition|;
name|i
operator|=
name|i
operator|.
name|getParent
argument_list|()
control|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
name|INode
index|[]
name|inodes
init|=
operator|new
name|INode
index|[
name|depth
index|]
decl_stmt|;
comment|// fill up the inodes in the path from this inode to root
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"Could not get full path."
operator|+
literal|" Corresponding file might have deleted already."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|inodes
index|[
name|depth
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|inode
expr_stmt|;
name|inode
operator|=
name|inode
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
name|inodes
return|;
block|}
DECL|method|getFullPathINodes (INode inode)
specifier|private
specifier|static
name|INode
index|[]
name|getFullPathINodes
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
return|return
name|getRelativePathINodes
argument_list|(
name|inode
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Return the full path name of the specified inode */
DECL|method|getFullPathName (INode inode)
specifier|static
name|String
name|getFullPathName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
name|INode
index|[]
name|inodes
init|=
name|getFullPathINodes
argument_list|(
name|inode
argument_list|)
decl_stmt|;
comment|// inodes can be null only when its called without holding lock
return|return
name|inodes
operator|==
literal|null
condition|?
literal|""
else|:
name|getFullPathName
argument_list|(
name|inodes
argument_list|,
name|inodes
operator|.
name|length
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Add the given child to the namespace.    * @param existing the INodesInPath containing all the ancestral INodes    * @param child the new INode to add    * @return a new INodesInPath instance containing the new child INode. Null    * if the adding fails.    * @throws QuotaExceededException is thrown if it violates quota limit    */
DECL|method|addINode (INodesInPath existing, INode child)
name|INodesInPath
name|addINode
parameter_list|(
name|INodesInPath
name|existing
parameter_list|,
name|INode
name|child
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
block|{
name|cacheName
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|addLastINode
argument_list|(
name|existing
argument_list|,
name|child
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Verify quota for adding or moving a new INode with required     * namespace and diskspace to a given position.    *      * @param iip INodes corresponding to a path    * @param pos position where a new INode will be added    * @param nsDelta needed namespace    * @param dsDelta needed diskspace    * @param commonAncestor Last node in inodes array that is a common ancestor    *          for a INode that is being moved from one location to the other.    *          Pass null if a node is not being moved.    * @throws QuotaExceededException if quota limit is exceeded.    */
DECL|method|verifyQuota (INodesInPath iip, int pos, long nsDelta, long dsDelta, INode commonAncestor)
specifier|static
name|void
name|verifyQuota
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|int
name|pos
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|INode
name|commonAncestor
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
name|nsDelta
operator|<=
literal|0
operator|&&
name|dsDelta
operator|<=
literal|0
condition|)
block|{
comment|// if quota is being freed or not being consumed
return|return;
block|}
comment|// check existing components in the path
for|for
control|(
name|int
name|i
init|=
operator|(
name|pos
operator|>
name|iip
operator|.
name|length
argument_list|()
condition|?
name|iip
operator|.
name|length
argument_list|()
else|:
name|pos
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|commonAncestor
operator|==
name|iip
operator|.
name|getINode
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|// Stop checking for quota when common ancestor is reached
return|return;
block|}
specifier|final
name|DirectoryWithQuotaFeature
name|q
init|=
name|iip
operator|.
name|getINode
argument_list|(
name|i
argument_list|)
operator|.
name|asDirectory
argument_list|()
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
comment|// a directory with quota
try|try
block|{
name|q
operator|.
name|verifyQuota
argument_list|(
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|List
argument_list|<
name|INode
argument_list|>
name|inodes
init|=
name|iip
operator|.
name|getReadOnlyINodes
argument_list|()
decl_stmt|;
specifier|final
name|String
name|path
init|=
name|getFullPathName
argument_list|(
name|inodes
operator|.
name|toArray
argument_list|(
operator|new
name|INode
index|[
name|inodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|e
operator|.
name|setPathName
argument_list|(
name|path
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
comment|/** Verify if the inode name is legal. */
DECL|method|verifyINodeName (byte[] childName)
name|void
name|verifyINodeName
parameter_list|(
name|byte
index|[]
name|childName
parameter_list|)
throws|throws
name|HadoopIllegalArgumentException
block|{
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR_BYTES
argument_list|,
name|childName
argument_list|)
condition|)
block|{
name|String
name|s
init|=
literal|"\""
operator|+
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|+
literal|"\" is a reserved name."
decl_stmt|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
name|s
operator|+=
literal|"  Please rename it before upgrade."
expr_stmt|;
block|}
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
name|s
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verify child's name for fs limit.    *    * @param childName byte[] containing new child name    * @param parentPath String containing parent path    * @throws PathComponentTooLongException child's name is too long.    */
DECL|method|verifyMaxComponentLength (byte[] childName, String parentPath)
name|void
name|verifyMaxComponentLength
parameter_list|(
name|byte
index|[]
name|childName
parameter_list|,
name|String
name|parentPath
parameter_list|)
throws|throws
name|PathComponentTooLongException
block|{
if|if
condition|(
name|maxComponentLength
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|int
name|length
init|=
name|childName
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|maxComponentLength
condition|)
block|{
specifier|final
name|PathComponentTooLongException
name|e
init|=
operator|new
name|PathComponentTooLongException
argument_list|(
name|maxComponentLength
argument_list|,
name|length
argument_list|,
name|parentPath
argument_list|,
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|childName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// Do not throw if edits log is still being processed
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"ERROR in FSDirectory.verifyINodeName"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Verify children size for fs limit.    *    * @throws MaxDirectoryItemsExceededException too many children.    */
DECL|method|verifyMaxDirItems (INodeDirectory parent, String parentPath)
name|void
name|verifyMaxDirItems
parameter_list|(
name|INodeDirectory
name|parent
parameter_list|,
name|String
name|parentPath
parameter_list|)
throws|throws
name|MaxDirectoryItemsExceededException
block|{
specifier|final
name|int
name|count
init|=
name|parent
operator|.
name|getChildrenList
argument_list|(
name|CURRENT_STATE_ID
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>=
name|maxDirItems
condition|)
block|{
specifier|final
name|MaxDirectoryItemsExceededException
name|e
init|=
operator|new
name|MaxDirectoryItemsExceededException
argument_list|(
name|maxDirItems
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
name|e
operator|.
name|setPathName
argument_list|(
name|parentPath
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// Do not throw if edits log is still being processed
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"FSDirectory.verifyMaxDirItems: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Add a child to the end of the path specified by INodesInPath.    * @return an INodesInPath instance containing the new INode    */
DECL|method|addLastINode (INodesInPath existing, INode inode, boolean checkQuota)
name|INodesInPath
name|addLastINode
parameter_list|(
name|INodesInPath
name|existing
parameter_list|,
name|INode
name|inode
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|existing
operator|.
name|getLastINode
argument_list|()
operator|!=
literal|null
operator|&&
name|existing
operator|.
name|getLastINode
argument_list|()
operator|.
name|isDirectory
argument_list|()
assert|;
specifier|final
name|int
name|pos
init|=
name|existing
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// Disallow creation of /.reserved. This may be created when loading
comment|// editlog/fsimage during upgrade since /.reserved was a valid name in older
comment|// release. This may also be called when a user tries to create a file
comment|// or directory /.reserved.
if|if
condition|(
name|pos
operator|==
literal|1
operator|&&
name|existing
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
operator|==
name|rootDir
operator|&&
name|isReservedName
argument_list|(
name|inode
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"File name \""
operator|+
name|inode
operator|.
name|getLocalName
argument_list|()
operator|+
literal|"\" is reserved and cannot "
operator|+
literal|"be created. If this is during upgrade change the name of the "
operator|+
literal|"existing file or directory to another name before upgrading "
operator|+
literal|"to the new release."
argument_list|)
throw|;
block|}
specifier|final
name|INodeDirectory
name|parent
init|=
name|existing
operator|.
name|getINode
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
comment|// The filesystem limits are not really quotas, so this check may appear
comment|// odd. It's because a rename operation deletes the src, tries to add
comment|// to the dest, if that fails, re-adds the src from whence it came.
comment|// The rename code disables the quota when it's restoring to the
comment|// original location becase a quota violation would cause the the item
comment|// to go "poof".  The fs limits must be bypassed for the same reason.
if|if
condition|(
name|checkQuota
condition|)
block|{
specifier|final
name|String
name|parentPath
init|=
name|existing
operator|.
name|getPath
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
decl_stmt|;
name|verifyMaxComponentLength
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|parentPath
argument_list|)
expr_stmt|;
name|verifyMaxDirItems
argument_list|(
name|parent
argument_list|,
name|parentPath
argument_list|)
expr_stmt|;
block|}
comment|// always verify inode name
name|verifyINodeName
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Quota
operator|.
name|Counts
name|counts
init|=
name|inode
operator|.
name|computeQuotaUsage
argument_list|()
decl_stmt|;
name|updateCount
argument_list|(
name|existing
argument_list|,
name|pos
argument_list|,
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
name|boolean
name|isRename
init|=
operator|(
name|inode
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
operator|)
decl_stmt|;
name|boolean
name|added
decl_stmt|;
try|try
block|{
name|added
operator|=
name|parent
operator|.
name|addChild
argument_list|(
name|inode
argument_list|,
literal|true
argument_list|,
name|existing
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|updateCountNoQuotaCheck
argument_list|(
name|existing
argument_list|,
name|pos
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|updateCountNoQuotaCheck
argument_list|(
name|existing
argument_list|,
name|pos
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isRename
condition|)
block|{
name|AclStorage
operator|.
name|copyINodeDefaultAcl
argument_list|(
name|inode
argument_list|)
expr_stmt|;
block|}
name|addToInodeMap
argument_list|(
name|inode
argument_list|)
expr_stmt|;
block|}
return|return
name|INodesInPath
operator|.
name|append
argument_list|(
name|existing
argument_list|,
name|inode
argument_list|,
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
return|;
block|}
DECL|method|addLastINodeNoQuotaCheck (INodesInPath existing, INode i)
name|INodesInPath
name|addLastINodeNoQuotaCheck
parameter_list|(
name|INodesInPath
name|existing
parameter_list|,
name|INode
name|i
parameter_list|)
block|{
try|try
block|{
return|return
name|addLastINode
argument_list|(
name|existing
argument_list|,
name|i
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"FSDirectory.addChildNoQuotaCheck - unexpected"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Remove the last inode in the path from the namespace.    * Count of each ancestor with quota is also updated.    * @return -1 for failing to remove;    *          0 for removing a reference whose referred inode has other     *            reference nodes;    *>0 otherwise.     */
DECL|method|removeLastINode (final INodesInPath iip)
name|long
name|removeLastINode
parameter_list|(
specifier|final
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|int
name|latestSnapshot
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|last
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|INodeDirectory
name|parent
init|=
name|iip
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|removeChild
argument_list|(
name|last
argument_list|,
name|latestSnapshot
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|last
operator|.
name|isInLatestSnapshot
argument_list|(
name|latestSnapshot
argument_list|)
condition|)
block|{
specifier|final
name|Quota
operator|.
name|Counts
name|counts
init|=
name|last
operator|.
name|computeQuotaUsage
argument_list|()
decl_stmt|;
name|updateCountNoQuotaCheck
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INodeReference
operator|.
name|tryRemoveReference
argument_list|(
name|last
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
DECL|method|normalizePath (String src)
specifier|static
name|String
name|normalizePath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|src
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getYieldCount ()
specifier|public
name|long
name|getYieldCount
parameter_list|()
block|{
return|return
name|yieldCount
return|;
block|}
DECL|method|addYieldCount (long value)
name|void
name|addYieldCount
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|yieldCount
operator|+=
name|value
expr_stmt|;
block|}
DECL|method|getINodeMap ()
specifier|public
name|INodeMap
name|getINodeMap
parameter_list|()
block|{
return|return
name|inodeMap
return|;
block|}
comment|/**    * FSEditLogLoader implementation.    * Unlike FSNamesystem.truncate, this will not schedule block recovery.    */
DECL|method|unprotectedTruncate (String src, String clientName, String clientMachine, long newLength, long mtime, Block truncateBlock)
name|void
name|unprotectedTruncate
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|long
name|newLength
parameter_list|,
name|long
name|mtime
parameter_list|,
name|Block
name|truncateBlock
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
throws|,
name|IOException
block|{
name|INodesInPath
name|iip
init|=
name|getINodesInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INodeFile
name|file
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|boolean
name|onBlockBoundary
init|=
name|unprotectedTruncate
argument_list|(
name|iip
argument_list|,
name|newLength
argument_list|,
name|collectedBlocks
argument_list|,
name|mtime
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|onBlockBoundary
condition|)
block|{
name|BlockInfo
name|oldBlock
init|=
name|file
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
name|Block
name|tBlk
init|=
name|getFSNamesystem
argument_list|()
operator|.
name|prepareFileForTruncate
argument_list|(
name|iip
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
name|file
operator|.
name|computeFileSize
argument_list|()
operator|-
name|newLength
argument_list|,
name|truncateBlock
argument_list|)
decl_stmt|;
assert|assert
name|Block
operator|.
name|matchingIdAndGenStamp
argument_list|(
name|tBlk
argument_list|,
name|truncateBlock
argument_list|)
operator|&&
name|tBlk
operator|.
name|getNumBytes
argument_list|()
operator|==
name|truncateBlock
operator|.
name|getNumBytes
argument_list|()
operator|:
literal|"Should be the same block."
assert|;
if|if
condition|(
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|!=
name|tBlk
operator|.
name|getBlockId
argument_list|()
operator|&&
operator|!
name|file
operator|.
name|isBlockInLatestSnapshot
argument_list|(
name|oldBlock
argument_list|)
condition|)
block|{
name|getBlockManager
argument_list|()
operator|.
name|removeBlockFromMap
argument_list|(
name|oldBlock
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|onBlockBoundary
operator|==
operator|(
name|truncateBlock
operator|==
literal|null
operator|)
operator|:
literal|"truncateBlock is null iff on block boundary: "
operator|+
name|truncateBlock
assert|;
name|getFSNamesystem
argument_list|()
operator|.
name|removeBlocksAndUpdateSafemodeTotal
argument_list|(
name|collectedBlocks
argument_list|)
expr_stmt|;
block|}
DECL|method|truncate (INodesInPath iip, long newLength, BlocksMapUpdateInfo collectedBlocks, long mtime)
name|boolean
name|truncate
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|newLength
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedTruncate
argument_list|(
name|iip
argument_list|,
name|newLength
argument_list|,
name|collectedBlocks
argument_list|,
name|mtime
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Truncate has the following properties:    * 1.) Any block deletions occur now.    * 2.) INode length is truncated now â new clients can only read up to    * the truncated length.    * 3.) INode will be set to UC and lastBlock set to UNDER_RECOVERY.    * 4.) NN will trigger DN truncation recovery and waits for DNs to report.    * 5.) File is considered UNDER_RECOVERY until truncation recovery completes.    * 6.) Soft and hard Lease expiration require truncation recovery to complete.    *    * @return true if on the block boundary or false if recovery is need    */
DECL|method|unprotectedTruncate (INodesInPath iip, long newLength, BlocksMapUpdateInfo collectedBlocks, long mtime)
name|boolean
name|unprotectedTruncate
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|newLength
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodeFile
name|file
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|int
name|latestSnapshot
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
name|file
operator|.
name|recordModification
argument_list|(
name|latestSnapshot
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|long
name|oldDiskspace
init|=
name|file
operator|.
name|diskspaceConsumed
argument_list|()
decl_stmt|;
name|long
name|remainingLength
init|=
name|file
operator|.
name|collectBlocksBeyondMax
argument_list|(
name|newLength
argument_list|,
name|collectedBlocks
argument_list|)
decl_stmt|;
name|file
operator|.
name|excludeSnapshotBlocks
argument_list|(
name|latestSnapshot
argument_list|,
name|collectedBlocks
argument_list|)
expr_stmt|;
name|file
operator|.
name|setModificationTime
argument_list|(
name|mtime
argument_list|)
expr_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
name|file
operator|.
name|diskspaceConsumed
argument_list|()
operator|-
name|oldDiskspace
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// return whether on a block boundary
return|return
operator|(
name|remainingLength
operator|-
name|newLength
operator|)
operator|==
literal|0
return|;
block|}
comment|/**    * This method is always called with writeLock of FSDirectory held.    */
DECL|method|addToInodeMap (INode inode)
specifier|public
specifier|final
name|void
name|addToInodeMap
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
if|if
condition|(
name|inode
operator|instanceof
name|INodeWithAdditionalFields
condition|)
block|{
name|inodeMap
operator|.
name|put
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inode
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
specifier|final
name|XAttrFeature
name|xaf
init|=
name|inode
operator|.
name|getXAttrFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|xaf
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|xattrs
init|=
name|xaf
operator|.
name|getXAttrs
argument_list|()
decl_stmt|;
for|for
control|(
name|XAttr
name|xattr
range|:
name|xattrs
control|)
block|{
specifier|final
name|String
name|xaName
init|=
name|XAttrHelper
operator|.
name|getPrefixName
argument_list|(
name|xattr
argument_list|)
decl_stmt|;
if|if
condition|(
name|CRYPTO_XATTR_ENCRYPTION_ZONE
operator|.
name|equals
argument_list|(
name|xaName
argument_list|)
condition|)
block|{
try|try
block|{
specifier|final
name|HdfsProtos
operator|.
name|ZoneEncryptionInfoProto
name|ezProto
init|=
name|HdfsProtos
operator|.
name|ZoneEncryptionInfoProto
operator|.
name|parseFrom
argument_list|(
name|xattr
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|ezManager
operator|.
name|unprotectedAddEncryptionZone
argument_list|(
name|inode
operator|.
name|getId
argument_list|()
argument_list|,
name|PBHelper
operator|.
name|convert
argument_list|(
name|ezProto
operator|.
name|getSuite
argument_list|()
argument_list|)
argument_list|,
name|PBHelper
operator|.
name|convert
argument_list|(
name|ezProto
operator|.
name|getCryptoProtocolVersion
argument_list|()
argument_list|)
argument_list|,
name|ezProto
operator|.
name|getKeyName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error parsing protocol buffer of "
operator|+
literal|"EZ XAttr "
operator|+
name|xattr
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * This method is always called with writeLock of FSDirectory held.    */
DECL|method|removeFromInodeMap (List<? extends INode> inodes)
specifier|public
specifier|final
name|void
name|removeFromInodeMap
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|INode
argument_list|>
name|inodes
parameter_list|)
block|{
if|if
condition|(
name|inodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|INode
name|inode
range|:
name|inodes
control|)
block|{
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|instanceof
name|INodeWithAdditionalFields
condition|)
block|{
name|inodeMap
operator|.
name|remove
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|ezManager
operator|.
name|removeEncryptionZone
argument_list|(
name|inode
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Get the inode from inodeMap based on its inode id.    * @param id The given id    * @return The inode associated with the given id    */
DECL|method|getInode (long id)
specifier|public
name|INode
name|getInode
parameter_list|(
name|long
name|id
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|inodeMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getInodeMapSize ()
name|int
name|getInodeMapSize
parameter_list|()
block|{
return|return
name|inodeMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|totalInodes ()
name|long
name|totalInodes
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
operator|.
name|getSpaceConsumed
argument_list|()
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Reset the entire namespace tree.    */
DECL|method|reset ()
name|void
name|reset
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|rootDir
operator|=
name|createRoot
argument_list|(
name|getFSNamesystem
argument_list|()
argument_list|)
expr_stmt|;
name|inodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|addToInodeMap
argument_list|(
name|rootDir
argument_list|)
expr_stmt|;
name|nameCache
operator|.
name|reset
argument_list|()
expr_stmt|;
name|inodeId
operator|.
name|setCurrentValue
argument_list|(
name|INodeId
operator|.
name|LAST_RESERVED_ID
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|isInAnEZ (INodesInPath iip)
name|boolean
name|isInAnEZ
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|isInAnEZ
argument_list|(
name|iip
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getKeyName (INodesInPath iip)
name|String
name|getKeyName
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|getKeyName
argument_list|(
name|iip
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createEncryptionZone (String src, CipherSuite suite, CryptoProtocolVersion version, String keyName)
name|XAttr
name|createEncryptionZone
parameter_list|(
name|String
name|src
parameter_list|,
name|CipherSuite
name|suite
parameter_list|,
name|CryptoProtocolVersion
name|version
parameter_list|,
name|String
name|keyName
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|createEncryptionZone
argument_list|(
name|src
argument_list|,
name|suite
argument_list|,
name|version
argument_list|,
name|keyName
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getEZForPath (INodesInPath iip)
name|EncryptionZone
name|getEZForPath
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|getEZINodeForPath
argument_list|(
name|iip
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|listEncryptionZones (long prevId)
name|BatchedListEntries
argument_list|<
name|EncryptionZone
argument_list|>
name|listEncryptionZones
parameter_list|(
name|long
name|prevId
parameter_list|)
throws|throws
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|ezManager
operator|.
name|listEncryptionZones
argument_list|(
name|prevId
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Set the FileEncryptionInfo for an INode.    */
DECL|method|setFileEncryptionInfo (String src, FileEncryptionInfo info)
name|void
name|setFileEncryptionInfo
parameter_list|(
name|String
name|src
parameter_list|,
name|FileEncryptionInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Make the PB for the xattr
specifier|final
name|HdfsProtos
operator|.
name|PerFileEncryptionInfoProto
name|proto
init|=
name|PBHelper
operator|.
name|convertPerFileEncInfo
argument_list|(
name|info
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|protoBytes
init|=
name|proto
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
specifier|final
name|XAttr
name|fileEncryptionAttr
init|=
name|XAttrHelper
operator|.
name|buildXAttr
argument_list|(
name|CRYPTO_XATTR_FILE_ENCRYPTION_INFO
argument_list|,
name|protoBytes
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|XAttr
argument_list|>
name|xAttrs
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|xAttrs
operator|.
name|add
argument_list|(
name|fileEncryptionAttr
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|FSDirXAttrOp
operator|.
name|unprotectedSetXAttrs
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|xAttrs
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|XAttrSetFlag
operator|.
name|CREATE
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This function combines the per-file encryption info (obtained    * from the inode's XAttrs), and the encryption info from its zone, and    * returns a consolidated FileEncryptionInfo instance. Null is returned    * for non-encrypted files.    *    * @param inode inode of the file    * @param snapshotId ID of the snapshot that    *                   we want to get encryption info from    * @param iip inodes in the path containing the file, passed in to    *            avoid obtaining the list of inodes again; if iip is    *            null then the list of inodes will be obtained again    * @return consolidated file encryption info; null for non-encrypted files    */
DECL|method|getFileEncryptionInfo (INode inode, int snapshotId, INodesInPath iip)
name|FileEncryptionInfo
name|getFileEncryptionInfo
parameter_list|(
name|INode
name|inode
parameter_list|,
name|int
name|snapshotId
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|EncryptionZone
name|encryptionZone
init|=
name|getEZForPath
argument_list|(
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|encryptionZone
operator|==
literal|null
condition|)
block|{
comment|// not an encrypted file
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|encryptionZone
operator|.
name|getPath
argument_list|()
operator|==
literal|null
operator|||
name|encryptionZone
operator|.
name|getPath
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encryption zone "
operator|+
name|encryptionZone
operator|.
name|getPath
argument_list|()
operator|+
literal|" does not have a valid path."
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|CryptoProtocolVersion
name|version
init|=
name|encryptionZone
operator|.
name|getVersion
argument_list|()
decl_stmt|;
specifier|final
name|CipherSuite
name|suite
init|=
name|encryptionZone
operator|.
name|getSuite
argument_list|()
decl_stmt|;
specifier|final
name|String
name|keyName
init|=
name|encryptionZone
operator|.
name|getKeyName
argument_list|()
decl_stmt|;
name|XAttr
name|fileXAttr
init|=
name|FSDirXAttrOp
operator|.
name|unprotectedGetXAttrByName
argument_list|(
name|inode
argument_list|,
name|snapshotId
argument_list|,
name|CRYPTO_XATTR_FILE_ENCRYPTION_INFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileXAttr
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find encryption XAttr for file "
operator|+
name|iip
operator|.
name|getPath
argument_list|()
operator|+
literal|" in encryption zone "
operator|+
name|encryptionZone
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
try|try
block|{
name|HdfsProtos
operator|.
name|PerFileEncryptionInfoProto
name|fileProto
init|=
name|HdfsProtos
operator|.
name|PerFileEncryptionInfoProto
operator|.
name|parseFrom
argument_list|(
name|fileXAttr
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|PBHelper
operator|.
name|convert
argument_list|(
name|fileProto
argument_list|,
name|suite
argument_list|,
name|version
argument_list|,
name|keyName
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not parse file encryption info for "
operator|+
literal|"inode "
operator|+
name|inode
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|resolveLastINode (INodesInPath iip)
specifier|static
name|INode
name|resolveLastINode
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"cannot find "
operator|+
name|iip
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|inode
return|;
block|}
comment|/**    * Caches frequently used file names to reuse file name objects and    * reduce heap size.    */
DECL|method|cacheName (INode inode)
name|void
name|cacheName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
comment|// Name is cached only for files
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return;
block|}
name|ByteArray
name|name
init|=
operator|new
name|ByteArray
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
decl_stmt|;
name|name
operator|=
name|nameCache
operator|.
name|put
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|inode
operator|.
name|setLocalName
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
name|nameCache
operator|.
name|reset
argument_list|()
expr_stmt|;
name|inodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Given an INode get all the path complents leading to it from the root.    * If an Inode corresponding to C is given in /A/B/C, the returned    * patch components will be {root, A, B, C}.    * Note that this method cannot handle scenarios where the inode is in a    * snapshot.    */
DECL|method|getPathComponents (INode inode)
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|getPathComponents
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|components
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|components
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|inode
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|components
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|inode
operator|.
name|getParent
argument_list|()
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
name|inode
operator|=
name|inode
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
name|components
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|components
operator|.
name|size
argument_list|()
index|]
index|[]
argument_list|)
return|;
block|}
comment|/**    * @return path components for reserved path, else null.    */
DECL|method|getPathComponentsForReservedPath (String src)
specifier|static
name|byte
index|[]
index|[]
name|getPathComponentsForReservedPath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
operator|!
name|isReservedName
argument_list|(
name|src
argument_list|)
condition|?
literal|null
else|:
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
return|;
block|}
comment|/** Check if a given inode name is reserved */
DECL|method|isReservedName (INode inode)
specifier|public
specifier|static
name|boolean
name|isReservedName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
return|return
name|CHECK_RESERVED_FILE_NAMES
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|DOT_RESERVED
argument_list|)
return|;
block|}
comment|/** Check if a given path is reserved */
DECL|method|isReservedName (String src)
specifier|public
specifier|static
name|boolean
name|isReservedName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|src
operator|.
name|startsWith
argument_list|(
name|DOT_RESERVED_PATH_PREFIX
argument_list|)
return|;
block|}
DECL|method|isReservedRawName (String src)
specifier|static
name|boolean
name|isReservedRawName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|src
operator|.
name|startsWith
argument_list|(
name|DOT_RESERVED_PATH_PREFIX
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|RAW_STRING
argument_list|)
return|;
block|}
comment|/**    * Resolve a /.reserved/... path to a non-reserved path.    *<p/>    * There are two special hierarchies under /.reserved/:    *<p/>    * /.reserved/.inodes/<inodeid> performs a path lookup by inodeid,    *<p/>    * /.reserved/raw/... returns the encrypted (raw) bytes of a file in an    * encryption zone. For instance, if /ezone is an encryption zone, then    * /ezone/a refers to the decrypted file and /.reserved/raw/ezone/a refers to    * the encrypted (raw) bytes of /ezone/a.    *<p/>    * Pathnames in the /.reserved/raw directory that resolve to files not in an    * encryption zone are equivalent to the corresponding non-raw path. Hence,    * if /a/b/c refers to a file that is not in an encryption zone, then    * /.reserved/raw/a/b/c is equivalent (they both refer to the same    * unencrypted file).    *     * @param src path that is being processed    * @param pathComponents path components corresponding to the path    * @param fsd FSDirectory    * @return if the path indicates an inode, return path after replacing up to    *<inodeid> with the corresponding path of the inode, else the path    *         in {@code src} as is. If the path refers to a path in the "raw"    *         directory, return the non-raw pathname.    * @throws FileNotFoundException if inodeid is invalid    */
DECL|method|resolvePath (String src, byte[][] pathComponents, FSDirectory fsd)
specifier|static
name|String
name|resolvePath
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|,
name|FSDirectory
name|fsd
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|int
name|nComponents
init|=
operator|(
name|pathComponents
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|pathComponents
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|nComponents
operator|<=
literal|2
condition|)
block|{
return|return
name|src
return|;
block|}
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|DOT_RESERVED
argument_list|,
name|pathComponents
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* This is not a /.reserved/ path so do nothing. */
return|return
name|src
return|;
block|}
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|DOT_INODES
argument_list|,
name|pathComponents
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* It's a /.reserved/.inodes path. */
if|if
condition|(
name|nComponents
operator|>
literal|3
condition|)
block|{
return|return
name|resolveDotInodesPath
argument_list|(
name|src
argument_list|,
name|pathComponents
argument_list|,
name|fsd
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|src
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|RAW
argument_list|,
name|pathComponents
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* It's /.reserved/raw so strip off the /.reserved/raw prefix. */
if|if
condition|(
name|nComponents
operator|==
literal|3
condition|)
block|{
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
else|else
block|{
return|return
name|constructRemainingPath
argument_list|(
literal|""
argument_list|,
name|pathComponents
argument_list|,
literal|3
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* It's some sort of /.reserved/<unknown> path. Ignore it. */
return|return
name|src
return|;
block|}
block|}
DECL|method|resolveDotInodesPath (String src, byte[][] pathComponents, FSDirectory fsd)
specifier|private
specifier|static
name|String
name|resolveDotInodesPath
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|,
name|FSDirectory
name|fsd
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|String
name|inodeId
init|=
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
specifier|final
name|long
name|id
decl_stmt|;
try|try
block|{
name|id
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Invalid inode path: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
operator|&&
name|pathComponents
operator|.
name|length
operator|==
literal|4
condition|)
block|{
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
name|INode
name|inode
init|=
name|fsd
operator|.
name|getInode
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File for given inode path does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
comment|// Handle single ".." for NFS lookup support.
if|if
condition|(
operator|(
name|pathComponents
operator|.
name|length
operator|>
literal|4
operator|)
operator|&&
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
literal|4
index|]
argument_list|)
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
name|INode
name|parent
init|=
name|inode
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
operator|||
name|parent
operator|.
name|getId
argument_list|()
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|)
block|{
comment|// inode is root, or its parent is root.
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
else|else
block|{
return|return
name|parent
operator|.
name|getFullPathName
argument_list|()
return|;
block|}
block|}
name|String
name|path
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|id
operator|!=
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|)
block|{
name|path
operator|=
name|inode
operator|.
name|getFullPathName
argument_list|()
expr_stmt|;
block|}
return|return
name|constructRemainingPath
argument_list|(
name|path
argument_list|,
name|pathComponents
argument_list|,
literal|4
argument_list|)
return|;
block|}
DECL|method|constructRemainingPath (String pathPrefix, byte[][] pathComponents, int startAt)
specifier|private
specifier|static
name|String
name|constructRemainingPath
parameter_list|(
name|String
name|pathPrefix
parameter_list|,
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|,
name|int
name|startAt
parameter_list|)
block|{
name|StringBuilder
name|path
init|=
operator|new
name|StringBuilder
argument_list|(
name|pathPrefix
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startAt
init|;
name|i
operator|<
name|pathComponents
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|path
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Resolved path is "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|path
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getINode4DotSnapshot (String src)
name|INode
name|getINode4DotSnapshot
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|src
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
argument_list|,
literal|"%s does not end with %s"
argument_list|,
name|src
argument_list|,
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
expr_stmt|;
specifier|final
name|String
name|dirPath
init|=
name|normalizePath
argument_list|(
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|node
init|=
name|this
operator|.
name|getINode
argument_list|(
name|dirPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
operator|&&
name|node
operator|.
name|asDirectory
argument_list|()
operator|.
name|isSnapshottable
argument_list|()
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|getExistingPathINodes (byte[][] components)
name|INodesInPath
name|getExistingPathINodes
parameter_list|(
name|byte
index|[]
index|[]
name|components
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|components
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getINodesInPath4Write (String src)
specifier|public
name|INodesInPath
name|getINodesInPath4Write
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
return|return
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|getINode4Write (String src)
specifier|public
name|INode
name|getINode4Write
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
return|return
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
operator|.
name|getLastINode
argument_list|()
return|;
block|}
comment|/** @return the {@link INodesInPath} containing all inodes in the path. */
DECL|method|getINodesInPath (String path, boolean resolveLink)
specifier|public
name|INodesInPath
name|getINodesInPath
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
specifier|final
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|components
argument_list|,
name|resolveLink
argument_list|)
return|;
block|}
comment|/** @return the last inode in the path. */
DECL|method|getINode (String path, boolean resolveLink)
name|INode
name|getINode
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|getINodesInPath
argument_list|(
name|path
argument_list|,
name|resolveLink
argument_list|)
operator|.
name|getLastINode
argument_list|()
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getINode (String src)
specifier|public
name|INode
name|getINode
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|getINode
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * @return the INodesInPath of the components in src    * @throws UnresolvedLinkException if symlink can't be resolved    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|getINodesInPath4Write (String src, boolean resolveLink)
name|INodesInPath
name|getINodesInPath4Write
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
specifier|final
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|INodesInPath
name|inodesInPath
init|=
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|components
argument_list|,
name|resolveLink
argument_list|)
decl_stmt|;
if|if
condition|(
name|inodesInPath
operator|.
name|isSnapshot
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SnapshotAccessControlException
argument_list|(
literal|"Modification on a read-only snapshot is disallowed"
argument_list|)
throw|;
block|}
return|return
name|inodesInPath
return|;
block|}
DECL|method|getPermissionChecker ()
name|FSPermissionChecker
name|getPermissionChecker
parameter_list|()
throws|throws
name|AccessControlException
block|{
try|try
block|{
return|return
operator|new
name|FSPermissionChecker
argument_list|(
name|fsOwnerShortUserName
argument_list|,
name|supergroup
argument_list|,
name|NameNode
operator|.
name|getRemoteUser
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
DECL|method|checkOwner (FSPermissionChecker pc, INodesInPath iip)
name|void
name|checkOwner
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|checkPathAccess (FSPermissionChecker pc, INodesInPath iip, FsAction access)
name|void
name|checkPathAccess
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|FsAction
name|access
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|access
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|checkParentAccess (FSPermissionChecker pc, INodesInPath iip, FsAction access)
name|void
name|checkParentAccess
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|FsAction
name|access
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|access
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|checkAncestorAccess (FSPermissionChecker pc, INodesInPath iip, FsAction access)
name|void
name|checkAncestorAccess
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|FsAction
name|access
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
name|access
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|checkTraverse (FSPermissionChecker pc, INodesInPath iip)
name|void
name|checkTraverse
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check whether current user have permissions to access the path. For more    * details of the parameters, see    * {@link FSPermissionChecker#checkPermission}.    */
DECL|method|checkPermission (FSPermissionChecker pc, INodesInPath iip, boolean doCheckOwner, FsAction ancestorAccess, FsAction parentAccess, FsAction access, FsAction subAccess)
name|void
name|checkPermission
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|boolean
name|doCheckOwner
parameter_list|,
name|FsAction
name|ancestorAccess
parameter_list|,
name|FsAction
name|parentAccess
parameter_list|,
name|FsAction
name|access
parameter_list|,
name|FsAction
name|subAccess
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|doCheckOwner
argument_list|,
name|ancestorAccess
argument_list|,
name|parentAccess
argument_list|,
name|access
argument_list|,
name|subAccess
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check whether current user have permissions to access the path. For more    * details of the parameters, see    * {@link FSPermissionChecker#checkPermission}.    */
DECL|method|checkPermission (FSPermissionChecker pc, INodesInPath iip, boolean doCheckOwner, FsAction ancestorAccess, FsAction parentAccess, FsAction access, FsAction subAccess, boolean ignoreEmptyDir)
name|void
name|checkPermission
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|boolean
name|doCheckOwner
parameter_list|,
name|FsAction
name|ancestorAccess
parameter_list|,
name|FsAction
name|parentAccess
parameter_list|,
name|FsAction
name|access
parameter_list|,
name|FsAction
name|subAccess
parameter_list|,
name|boolean
name|ignoreEmptyDir
parameter_list|)
throws|throws
name|AccessControlException
block|{
if|if
condition|(
operator|!
name|pc
operator|.
name|isSuperUser
argument_list|()
condition|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|pc
operator|.
name|checkPermission
argument_list|(
name|iip
argument_list|,
name|doCheckOwner
argument_list|,
name|ancestorAccess
argument_list|,
name|parentAccess
argument_list|,
name|access
argument_list|,
name|subAccess
argument_list|,
name|ignoreEmptyDir
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getAuditFileInfo (INodesInPath iip)
name|HdfsFileStatus
name|getAuditFileInfo
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
name|namesystem
operator|.
name|isAuditEnabled
argument_list|()
operator|&&
name|namesystem
operator|.
name|isExternalInvocation
argument_list|()
operator|)
condition|?
name|FSDirStatAndListingOp
operator|.
name|getFileInfo
argument_list|(
name|this
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**    * Verify that parent directory of src exists.    */
DECL|method|verifyParentDir (INodesInPath iip, String src)
name|void
name|verifyParentDir
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|String
name|src
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
block|{
name|Path
name|parent
init|=
operator|new
name|Path
argument_list|(
name|src
argument_list|)
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
specifier|final
name|INode
name|parentNode
init|=
name|iip
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Parent directory doesn't exist: "
operator|+
name|parent
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parentNode
operator|.
name|isDirectory
argument_list|()
operator|&&
operator|!
name|parentNode
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
literal|"Parent path is not a directory: "
operator|+
name|parent
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Allocate a new inode ID. */
DECL|method|allocateNewInodeId ()
name|long
name|allocateNewInodeId
parameter_list|()
block|{
return|return
name|inodeId
operator|.
name|nextValue
argument_list|()
return|;
block|}
comment|/** @return the last inode ID. */
DECL|method|getLastInodeId ()
specifier|public
name|long
name|getLastInodeId
parameter_list|()
block|{
return|return
name|inodeId
operator|.
name|getCurrentValue
argument_list|()
return|;
block|}
comment|/**    * Set the last allocated inode id when fsimage or editlog is loaded.    */
DECL|method|resetLastInodeId (long newValue)
name|void
name|resetLastInodeId
parameter_list|(
name|long
name|newValue
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|inodeId
operator|.
name|skipTo
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|ise
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ise
argument_list|)
throw|;
block|}
block|}
comment|/** Should only be used for tests to reset to any value */
DECL|method|resetLastInodeIdWithoutChecking (long newValue)
name|void
name|resetLastInodeIdWithoutChecking
parameter_list|(
name|long
name|newValue
parameter_list|)
block|{
name|inodeId
operator|.
name|setCurrentValue
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

