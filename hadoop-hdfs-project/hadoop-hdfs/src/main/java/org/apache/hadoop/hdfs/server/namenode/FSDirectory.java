begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|Rename
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathIsNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DirectoryListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|MaxDirectoryItemsExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|PathComponentTooLongException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsLocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotAccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapUpdateInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeReference
operator|.
name|WithCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|INodeDirectorySnapshottable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|INodeDirectoryWithSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
operator|.
name|Root
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ChunkedArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ReadOnlyList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/*************************************************  * FSDirectory stores the filesystem directory state.  * It handles writing/loading values to disk, and logging  * changes as we go.  *  * It keeps the filename->blockset mapping always-current  * and logged to disk.  *   *************************************************/
end_comment

begin_class
DECL|class|FSDirectory
specifier|public
class|class
name|FSDirectory
implements|implements
name|Closeable
block|{
DECL|method|createRoot (FSNamesystem namesystem)
specifier|private
specifier|static
name|INodeDirectoryWithQuota
name|createRoot
parameter_list|(
name|FSNamesystem
name|namesystem
parameter_list|)
block|{
specifier|final
name|INodeDirectoryWithQuota
name|r
init|=
operator|new
name|INodeDirectoryWithQuota
argument_list|(
name|INodeId
operator|.
name|ROOT_INODE_ID
argument_list|,
name|INodeDirectory
operator|.
name|ROOT_NAME
argument_list|,
name|namesystem
operator|.
name|createFsOwnerPermissions
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|INodeDirectorySnapshottable
name|s
init|=
operator|new
name|INodeDirectorySnapshottable
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|s
operator|.
name|setSnapshotQuota
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|field|CHECK_RESERVED_FILE_NAMES
specifier|static
name|boolean
name|CHECK_RESERVED_FILE_NAMES
init|=
literal|true
decl_stmt|;
DECL|field|DOT_RESERVED_STRING
specifier|public
specifier|final
specifier|static
name|String
name|DOT_RESERVED_STRING
init|=
literal|".reserved"
decl_stmt|;
DECL|field|DOT_RESERVED_PATH_PREFIX
specifier|public
specifier|final
specifier|static
name|String
name|DOT_RESERVED_PATH_PREFIX
init|=
name|Path
operator|.
name|SEPARATOR
operator|+
name|DOT_RESERVED_STRING
decl_stmt|;
DECL|field|DOT_RESERVED
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|DOT_RESERVED
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|DOT_RESERVED_STRING
argument_list|)
decl_stmt|;
DECL|field|DOT_INODES_STRING
specifier|public
specifier|final
specifier|static
name|String
name|DOT_INODES_STRING
init|=
literal|".inodes"
decl_stmt|;
DECL|field|DOT_INODES
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|DOT_INODES
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|DOT_INODES_STRING
argument_list|)
decl_stmt|;
DECL|field|rootDir
name|INodeDirectoryWithQuota
name|rootDir
decl_stmt|;
DECL|field|fsImage
name|FSImage
name|fsImage
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|ready
specifier|private
specifier|volatile
name|boolean
name|ready
init|=
literal|false
decl_stmt|;
DECL|field|maxComponentLength
specifier|private
specifier|final
name|int
name|maxComponentLength
decl_stmt|;
DECL|field|maxDirItems
specifier|private
specifier|final
name|int
name|maxDirItems
decl_stmt|;
DECL|field|lsLimit
specifier|private
specifier|final
name|int
name|lsLimit
decl_stmt|;
comment|// max list limit
DECL|field|inodeMap
specifier|private
specifier|final
name|INodeMap
name|inodeMap
decl_stmt|;
comment|// Synchronized by dirLock
comment|// lock to protect the directory and BlockMap
DECL|field|dirLock
specifier|private
name|ReentrantReadWriteLock
name|dirLock
decl_stmt|;
DECL|field|cond
specifier|private
name|Condition
name|cond
decl_stmt|;
comment|// utility methods to acquire and release read lock and write lock
DECL|method|readLock ()
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|readUnlock ()
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeLock ()
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeUnlock ()
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|hasWriteLock ()
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|isWriteLockedByCurrentThread
argument_list|()
return|;
block|}
DECL|method|hasReadLock ()
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getReadHoldCount
argument_list|()
operator|>
literal|0
return|;
block|}
comment|/**    * Caches frequently used file names used in {@link INode} to reuse     * byte[] objects and reduce heap usage.    */
DECL|field|nameCache
specifier|private
specifier|final
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
name|nameCache
decl_stmt|;
DECL|method|FSDirectory (FSImage fsImage, FSNamesystem ns, Configuration conf)
name|FSDirectory
parameter_list|(
name|FSImage
name|fsImage
parameter_list|,
name|FSNamesystem
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|dirLock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// fair
name|this
operator|.
name|cond
operator|=
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|newCondition
argument_list|()
expr_stmt|;
name|rootDir
operator|=
name|createRoot
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|inodeMap
operator|=
name|INodeMap
operator|.
name|newInstance
argument_list|(
name|rootDir
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsImage
operator|=
name|fsImage
expr_stmt|;
name|int
name|configuredLimit
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
argument_list|)
decl_stmt|;
name|this
operator|.
name|lsLimit
operator|=
name|configuredLimit
operator|>
literal|0
condition|?
name|configuredLimit
else|:
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
expr_stmt|;
comment|// filesystem limits
name|this
operator|.
name|maxComponentLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxDirItems
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_DEFAULT
argument_list|)
expr_stmt|;
name|int
name|threshold
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_DEFAULT
argument_list|)
decl_stmt|;
name|NameNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Caching file names occuring more than "
operator|+
name|threshold
operator|+
literal|" times"
argument_list|)
expr_stmt|;
name|nameCache
operator|=
operator|new
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|namesystem
operator|=
name|ns
expr_stmt|;
block|}
DECL|method|getFSNamesystem ()
specifier|private
name|FSNamesystem
name|getFSNamesystem
parameter_list|()
block|{
return|return
name|namesystem
return|;
block|}
DECL|method|getBlockManager ()
specifier|private
name|BlockManager
name|getBlockManager
parameter_list|()
block|{
return|return
name|getFSNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
return|;
block|}
comment|/** @return the root directory inode. */
DECL|method|getRoot ()
specifier|public
name|INodeDirectoryWithQuota
name|getRoot
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
comment|/**    * Notify that loading of this FSDirectory is complete, and    * it is ready for use     */
DECL|method|imageLoadComplete ()
name|void
name|imageLoadComplete
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|ready
argument_list|,
literal|"FSDirectory already loaded"
argument_list|)
expr_stmt|;
name|setReady
argument_list|()
expr_stmt|;
block|}
DECL|method|setReady ()
name|void
name|setReady
parameter_list|()
block|{
if|if
condition|(
name|ready
condition|)
return|return;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|setReady
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|nameCache
operator|.
name|initialized
argument_list|()
expr_stmt|;
name|cond
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//This is for testing purposes only
annotation|@
name|VisibleForTesting
DECL|method|isReady ()
name|boolean
name|isReady
parameter_list|()
block|{
return|return
name|ready
return|;
block|}
comment|// exposed for unit tests
DECL|method|setReady (boolean flag)
specifier|protected
name|void
name|setReady
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|ready
operator|=
name|flag
expr_stmt|;
block|}
DECL|method|incrDeletedFileCount (long count)
specifier|private
name|void
name|incrDeletedFileCount
parameter_list|(
name|long
name|count
parameter_list|)
block|{
if|if
condition|(
name|getFSNamesystem
argument_list|()
operator|!=
literal|null
condition|)
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|incrFilesDeleted
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
comment|/**    * Shutdown the filestore    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|fsImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Block until the object is ready to be used.    */
DECL|method|waitForReady ()
name|void
name|waitForReady
parameter_list|()
block|{
if|if
condition|(
operator|!
name|ready
condition|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|ready
condition|)
block|{
try|try
block|{
name|cond
operator|.
name|await
argument_list|(
literal|5000
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{           }
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Add the given filename to the fs.    * @throws FileAlreadyExistsException    * @throws QuotaExceededException    * @throws UnresolvedLinkException    * @throws SnapshotAccessControlException     */
DECL|method|addFile (String path, PermissionStatus permissions, short replication, long preferredBlockSize, String clientName, String clientMachine, DatanodeDescriptor clientNode)
name|INodeFileUnderConstruction
name|addFile
parameter_list|(
name|String
name|path
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|DatanodeDescriptor
name|clientNode
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
comment|// Always do an implicit mkdirs for parent directory tree.
name|long
name|modTime
init|=
name|now
argument_list|()
decl_stmt|;
name|Path
name|parent
init|=
operator|new
name|Path
argument_list|(
name|path
argument_list|)
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|// Trying to add "/" as a file - this path has no
comment|// parent -- avoids an NPE below.
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|mkdirs
argument_list|(
name|parent
operator|.
name|toString
argument_list|()
argument_list|,
name|permissions
argument_list|,
literal|true
argument_list|,
name|modTime
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|INodeFileUnderConstruction
name|newNode
init|=
operator|new
name|INodeFileUnderConstruction
argument_list|(
name|namesystem
operator|.
name|allocateNewInodeId
argument_list|()
argument_list|,
name|permissions
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|modTime
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
name|clientNode
argument_list|)
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|added
operator|=
name|addINode
argument_list|(
name|path
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* addFile: failed to add "
operator|+
name|path
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* addFile: "
operator|+
name|path
operator|+
literal|" is added"
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
block|}
DECL|method|unprotectedAddFile ( long id, String path, PermissionStatus permissions, short replication, long modificationTime, long atime, long preferredBlockSize, boolean underConstruction, String clientName, String clientMachine)
name|INodeFile
name|unprotectedAddFile
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|path
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|modificationTime
parameter_list|,
name|long
name|atime
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|boolean
name|underConstruction
parameter_list|,
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|)
block|{
specifier|final
name|INodeFile
name|newNode
decl_stmt|;
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|underConstruction
condition|)
block|{
name|newNode
operator|=
operator|new
name|INodeFileUnderConstruction
argument_list|(
name|id
argument_list|,
name|permissions
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|,
name|modificationTime
argument_list|,
name|clientName
argument_list|,
name|clientMachine
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNode
operator|=
operator|new
name|INodeFile
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|permissions
argument_list|,
name|modificationTime
argument_list|,
name|atime
argument_list|,
name|BlockInfo
operator|.
name|EMPTY_ARRAY
argument_list|,
name|replication
argument_list|,
name|preferredBlockSize
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|addINode
argument_list|(
name|path
argument_list|,
name|newNode
argument_list|)
condition|)
block|{
return|return
name|newNode
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedAddFile: exception when add "
operator|+
name|path
operator|+
literal|" to the file system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Add a block to the file. Returns a reference to the added block.    */
DECL|method|addBlock (String path, INodesInPath inodesInPath, Block block, DatanodeDescriptor targets[])
name|BlockInfo
name|addBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|Block
name|block
parameter_list|,
name|DatanodeDescriptor
name|targets
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodeFileUnderConstruction
name|fileINode
init|=
name|INodeFileUnderConstruction
operator|.
name|valueOf
argument_list|(
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|// check quota limits and updated space consumed
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
literal|0
argument_list|,
name|fileINode
operator|.
name|getBlockDiskspace
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// associate new last block for the file
name|BlockInfoUnderConstruction
name|blockInfo
init|=
operator|new
name|BlockInfoUnderConstruction
argument_list|(
name|block
argument_list|,
name|fileINode
operator|.
name|getFileReplication
argument_list|()
argument_list|,
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|blockInfo
argument_list|,
name|fileINode
argument_list|)
expr_stmt|;
name|fileINode
operator|.
name|addBlock
argument_list|(
name|blockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.addBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is added to the in-memory "
operator|+
literal|"file system"
argument_list|)
expr_stmt|;
block|}
return|return
name|blockInfo
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Persist the block list for the inode.    */
DECL|method|persistBlocks (String path, INodeFileUnderConstruction file, boolean logRetryCache)
name|void
name|persistBlocks
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|file
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logUpdateBlocks
argument_list|(
name|path
argument_list|,
name|file
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.persistBlocks: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|" blocks is persisted to the file system"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Close file.    */
DECL|method|closeFile (String path, INodeFile file)
name|void
name|closeFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|file
parameter_list|)
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// file is closed
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logCloseFile
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.closeFile: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|file
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
operator|+
literal|" blocks is persisted to the file system"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Remove a block from the file.    * @return Whether the block exists in the corresponding file    */
DECL|method|removeBlock (String path, INodeFileUnderConstruction fileNode, Block block)
name|boolean
name|removeBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|unprotectedRemoveBlock
argument_list|(
name|path
argument_list|,
name|fileNode
argument_list|,
name|block
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedRemoveBlock (String path, INodeFileUnderConstruction fileNode, Block block)
name|boolean
name|unprotectedRemoveBlock
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|fileNode
parameter_list|,
name|Block
name|block
parameter_list|)
throws|throws
name|IOException
block|{
comment|// modify file-> block and blocksMap
name|boolean
name|removed
init|=
name|fileNode
operator|.
name|removeLastBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|removed
condition|)
block|{
return|return
literal|false
return|;
block|}
name|getBlockManager
argument_list|()
operator|.
name|removeBlockFromMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.removeBlock: "
operator|+
name|path
operator|+
literal|" with "
operator|+
name|block
operator|+
literal|" block is removed from the file system"
argument_list|)
expr_stmt|;
block|}
comment|// update space consumed
specifier|final
name|INodesInPath
name|iip
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
operator|-
name|fileNode
operator|.
name|getBlockDiskspace
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * @throws SnapshotAccessControlException     * @see #unprotectedRenameTo(String, String, long)    * @deprecated Use {@link #renameTo(String, String, Rename...)} instead.    */
annotation|@
name|Deprecated
DECL|method|renameTo (String src, String dst, boolean logRetryCache)
name|boolean
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|FileAlreadyExistsException
throws|,
name|SnapshotAccessControlException
throws|,
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.renameTo: "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|waitForReady
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|unprotectedRenameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|now
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logRename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|now
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * @see #unprotectedRenameTo(String, String, long, Options.Rename...)    */
DECL|method|renameTo (String src, String dst, boolean logRetryCache, Options.Rename... options)
name|void
name|renameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.renameTo: "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
name|waitForReady
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|unprotectedRenameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|now
argument_list|,
name|options
argument_list|)
condition|)
block|{
name|incrDeletedFileCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logRename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|now
argument_list|,
name|logRetryCache
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
comment|/**    * Change a path name    *     * @param src source path    * @param dst destination path    * @return true if rename succeeds; false otherwise    * @throws QuotaExceededException if the operation violates any quota limit    * @throws FileAlreadyExistsException if the src is a symlink that points to dst    * @throws SnapshotAccessControlException if path is in RO snapshot    * @deprecated See {@link #renameTo(String, String)}    */
annotation|@
name|Deprecated
DECL|method|unprotectedRenameTo (String src, String dst, long timestamp)
name|boolean
name|unprotectedRenameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|FileAlreadyExistsException
throws|,
name|SnapshotAccessControlException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|srcIIP
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|srcInode
init|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
comment|// check the validation of the source
if|if
condition|(
name|srcInode
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because source does not exist"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|srcIIP
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because source is the root"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// srcInode and its subtree cannot contain snapshottable directories with
comment|// snapshots
name|List
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
argument_list|()
decl_stmt|;
name|checkSnapshot
argument_list|(
name|srcInode
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDir
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|dst
operator|+=
name|Path
operator|.
name|SEPARATOR
operator|+
operator|new
name|Path
argument_list|(
name|src
argument_list|)
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
comment|// check the validity of the destination
if|if
condition|(
name|dst
operator|.
name|equals
argument_list|(
name|src
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|srcInode
operator|.
name|isSymlink
argument_list|()
operator|&&
name|dst
operator|.
name|equals
argument_list|(
name|srcInode
operator|.
name|asSymlink
argument_list|()
operator|.
name|getSymlinkString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Cannot rename symlink "
operator|+
name|src
operator|+
literal|" to its target "
operator|+
name|dst
argument_list|)
throw|;
block|}
comment|// dst cannot be directory or a file under src
if|if
condition|(
name|dst
operator|.
name|startsWith
argument_list|(
name|src
argument_list|)
operator|&&
name|dst
operator|.
name|charAt
argument_list|(
name|src
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|Path
operator|.
name|SEPARATOR_CHAR
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because destination starts with src"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|byte
index|[]
index|[]
name|dstComponents
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|INodesInPath
name|dstIIP
init|=
name|getExistingPathINodes
argument_list|(
name|dstComponents
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstIIP
operator|.
name|isSnapshot
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SnapshotAccessControlException
argument_list|(
literal|"Modification on RO snapshot is disallowed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dstIIP
operator|.
name|getLastINode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because destination exists"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|INode
name|dstParent
init|=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstParent
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because destination's parent does not exist"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Ensure dst has quota to accommodate rename
name|verifyQuotaForRename
argument_list|(
name|srcIIP
operator|.
name|getINodes
argument_list|()
argument_list|,
name|dstIIP
operator|.
name|getINodes
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|INode
name|srcChild
init|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|srcChildName
init|=
name|srcChild
operator|.
name|getLocalNameBytes
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isSrcInSnapshot
init|=
name|srcChild
operator|.
name|isInLatestSnapshot
argument_list|(
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|srcChildIsReference
init|=
name|srcChild
operator|.
name|isReference
argument_list|()
decl_stmt|;
comment|// Record the snapshot on srcChild. After the rename, before any new
comment|// snapshot is taken on the dst tree, changes will be recorded in the latest
comment|// snapshot of the src tree.
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
name|srcChild
operator|=
name|srcChild
operator|.
name|recordModification
argument_list|(
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
name|srcIIP
operator|.
name|setLastINode
argument_list|(
name|srcChild
argument_list|)
expr_stmt|;
block|}
comment|// check srcChild for reference
specifier|final
name|INodeReference
operator|.
name|WithCount
name|withCount
decl_stmt|;
name|Quota
operator|.
name|Counts
name|oldSrcCounts
init|=
name|Quota
operator|.
name|Counts
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|int
name|srcRefDstSnapshot
init|=
name|srcChildIsReference
condition|?
name|srcChild
operator|.
name|asReference
argument_list|()
operator|.
name|getDstSnapshotId
argument_list|()
else|:
name|Snapshot
operator|.
name|INVALID_ID
decl_stmt|;
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
specifier|final
name|INodeReference
operator|.
name|WithName
name|withName
init|=
name|srcIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
operator|.
name|replaceChild4ReferenceWithName
argument_list|(
name|srcChild
argument_list|,
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
decl_stmt|;
name|withCount
operator|=
operator|(
name|INodeReference
operator|.
name|WithCount
operator|)
name|withName
operator|.
name|getReferredINode
argument_list|()
expr_stmt|;
name|srcChild
operator|=
name|withName
expr_stmt|;
name|srcIIP
operator|.
name|setLastINode
argument_list|(
name|srcChild
argument_list|)
expr_stmt|;
comment|// get the counts before rename
name|withCount
operator|.
name|getReferredINode
argument_list|()
operator|.
name|computeQuotaUsage
argument_list|(
name|oldSrcCounts
argument_list|,
literal|true
argument_list|,
name|Snapshot
operator|.
name|INVALID_ID
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|srcChildIsReference
condition|)
block|{
comment|// srcChild is reference but srcChild is not in latest snapshot
name|withCount
operator|=
operator|(
name|WithCount
operator|)
name|srcChild
operator|.
name|asReference
argument_list|()
operator|.
name|getReferredINode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|withCount
operator|=
literal|null
expr_stmt|;
block|}
try|try
block|{
comment|// remove src
specifier|final
name|long
name|removedSrc
init|=
name|removeLastINode
argument_list|(
name|srcIIP
argument_list|)
decl_stmt|;
if|if
condition|(
name|removedSrc
operator|==
operator|-
literal|1
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because the source can not be removed"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|dstParent
operator|.
name|getParent
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// src and dst file/dir are in the same directory, and the dstParent has
comment|// been replaced when we removed the src. Refresh the dstIIP and
comment|// dstParent.
name|dstIIP
operator|=
name|getExistingPathINodes
argument_list|(
name|dstComponents
argument_list|)
expr_stmt|;
name|dstParent
operator|=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|// add src to the destination
name|srcChild
operator|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
specifier|final
name|byte
index|[]
name|dstChildName
init|=
name|dstIIP
operator|.
name|getLastLocalName
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|toDst
decl_stmt|;
if|if
condition|(
name|withCount
operator|==
literal|null
condition|)
block|{
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|dstChildName
argument_list|)
expr_stmt|;
name|toDst
operator|=
name|srcChild
expr_stmt|;
block|}
else|else
block|{
name|withCount
operator|.
name|getReferredINode
argument_list|()
operator|.
name|setLocalName
argument_list|(
name|dstChildName
argument_list|)
expr_stmt|;
name|Snapshot
name|dstSnapshot
init|=
name|dstIIP
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
specifier|final
name|INodeReference
operator|.
name|DstReference
name|ref
init|=
operator|new
name|INodeReference
operator|.
name|DstReference
argument_list|(
name|dstParent
operator|.
name|asDirectory
argument_list|()
argument_list|,
name|withCount
argument_list|,
name|dstSnapshot
operator|==
literal|null
condition|?
name|Snapshot
operator|.
name|INVALID_ID
else|:
name|dstSnapshot
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|toDst
operator|=
name|ref
expr_stmt|;
block|}
name|added
operator|=
name|addLastINodeNoQuotaCheck
argument_list|(
name|dstIIP
argument_list|,
name|toDst
argument_list|)
expr_stmt|;
if|if
condition|(
name|added
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|src
operator|+
literal|" is renamed to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
comment|// update modification time of dst and the parent of src
specifier|final
name|INode
name|srcParent
init|=
name|srcIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
name|srcParent
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
name|dstParent
operator|=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|// refresh dstParent
name|dstParent
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|dstIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
comment|// update moved leases with new filename
name|getFSNamesystem
argument_list|()
operator|.
name|unprotectedChangeLease
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
comment|// update the quota usage in src tree
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
comment|// get the counts after rename
name|Quota
operator|.
name|Counts
name|newSrcCounts
init|=
name|srcChild
operator|.
name|computeQuotaUsage
argument_list|(
name|Quota
operator|.
name|Counts
operator|.
name|newInstance
argument_list|()
argument_list|,
literal|false
argument_list|,
name|Snapshot
operator|.
name|INVALID_ID
argument_list|)
decl_stmt|;
name|newSrcCounts
operator|.
name|subtract
argument_list|(
name|oldSrcCounts
argument_list|)
expr_stmt|;
name|srcParent
operator|.
name|addSpaceConsumed
argument_list|(
name|newSrcCounts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
name|newSrcCounts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|added
condition|)
block|{
specifier|final
name|INodeDirectory
name|srcParent
init|=
name|srcIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|oldSrcChild
init|=
name|srcChild
decl_stmt|;
comment|// put it back
if|if
condition|(
name|withCount
operator|==
literal|null
condition|)
block|{
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|srcChildIsReference
condition|)
block|{
comment|// src must be in snapshot
comment|// the withCount node will no longer be used thus no need to update
comment|// its reference number here
specifier|final
name|INode
name|originalChild
init|=
name|withCount
operator|.
name|getReferredINode
argument_list|()
decl_stmt|;
name|srcChild
operator|=
name|originalChild
expr_stmt|;
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|withCount
operator|.
name|removeReference
argument_list|(
name|oldSrcChild
operator|.
name|asReference
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|INodeReference
name|originalRef
init|=
operator|new
name|INodeReference
operator|.
name|DstReference
argument_list|(
name|srcParent
argument_list|,
name|withCount
argument_list|,
name|srcRefDstSnapshot
argument_list|)
decl_stmt|;
name|srcChild
operator|=
name|originalRef
expr_stmt|;
name|withCount
operator|.
name|getReferredINode
argument_list|()
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
comment|// srcParent must be an INodeDirectoryWithSnapshot instance since
comment|// isSrcInSnapshot is true and src node has been removed from
comment|// srcParent
operator|(
operator|(
name|INodeDirectoryWithSnapshot
operator|)
name|srcParent
operator|)
operator|.
name|undoRename4ScrParent
argument_list|(
name|oldSrcChild
operator|.
name|asReference
argument_list|()
argument_list|,
name|srcChild
argument_list|,
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// original srcChild is not in latest snapshot, we only need to add
comment|// the srcChild back
name|addLastINodeNoQuotaCheck
argument_list|(
name|srcIIP
argument_list|,
name|srcChild
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**    * Rename src to dst.    * See {@link DistributedFileSystem#rename(Path, Path, Options.Rename...)}    * for details related to rename semantics and exceptions.    *     * @param src source path    * @param dst destination path    * @param timestamp modification time    * @param options Rename options    */
DECL|method|unprotectedRenameTo (String src, String dst, long timestamp, Options.Rename... options)
name|boolean
name|unprotectedRenameTo
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|boolean
name|overwrite
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|options
condition|)
block|{
for|for
control|(
name|Rename
name|option
range|:
name|options
control|)
block|{
if|if
condition|(
name|option
operator|==
name|Rename
operator|.
name|OVERWRITE
condition|)
block|{
name|overwrite
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|String
name|error
init|=
literal|null
decl_stmt|;
specifier|final
name|INodesInPath
name|srcIIP
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|srcInode
init|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
comment|// validate source
if|if
condition|(
name|srcInode
operator|==
literal|null
condition|)
block|{
name|error
operator|=
literal|"rename source "
operator|+
name|src
operator|+
literal|" is not found."
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcIIP
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|error
operator|=
literal|"rename source cannot be the root"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
comment|// srcInode and its subtree cannot contain snapshottable directories with
comment|// snapshots
name|checkSnapshot
argument_list|(
name|srcInode
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// validate the destination
if|if
condition|(
name|dst
operator|.
name|equals
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"The source "
operator|+
name|src
operator|+
literal|" and destination "
operator|+
name|dst
operator|+
literal|" are the same"
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcInode
operator|.
name|isSymlink
argument_list|()
operator|&&
name|dst
operator|.
name|equals
argument_list|(
name|srcInode
operator|.
name|asSymlink
argument_list|()
operator|.
name|getSymlinkString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Cannot rename symlink "
operator|+
name|src
operator|+
literal|" to its target "
operator|+
name|dst
argument_list|)
throw|;
block|}
comment|// dst cannot be a directory or a file under src
if|if
condition|(
name|dst
operator|.
name|startsWith
argument_list|(
name|src
argument_list|)
operator|&&
name|dst
operator|.
name|charAt
argument_list|(
name|src
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|Path
operator|.
name|SEPARATOR_CHAR
condition|)
block|{
name|error
operator|=
literal|"Rename destination "
operator|+
name|dst
operator|+
literal|" is a directory or file under source "
operator|+
name|src
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
name|INodesInPath
name|dstIIP
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|dst
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstIIP
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|error
operator|=
literal|"rename destination cannot be the root"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
specifier|final
name|INode
name|dstInode
init|=
name|dstIIP
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstInode
operator|!=
literal|null
condition|)
block|{
comment|// Destination exists
comment|// It's OK to rename a file to a symlink and vice versa
if|if
condition|(
name|dstInode
operator|.
name|isDirectory
argument_list|()
operator|!=
name|srcInode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|error
operator|=
literal|"Source "
operator|+
name|src
operator|+
literal|" and destination "
operator|+
name|dst
operator|+
literal|" must both be directories"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
comment|// If destination exists, overwrite flag must be true
name|error
operator|=
literal|"rename destination "
operator|+
name|dst
operator|+
literal|" already exists"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
name|dstInode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
specifier|final
name|ReadOnlyList
argument_list|<
name|INode
argument_list|>
name|children
init|=
name|dstInode
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenList
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|error
operator|=
literal|"rename destination directory is not empty: "
operator|+
name|dst
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
block|}
name|checkSnapshot
argument_list|(
name|dstInode
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
name|INode
name|dstParent
init|=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstParent
operator|==
literal|null
condition|)
block|{
name|error
operator|=
literal|"rename destination parent "
operator|+
name|dst
operator|+
literal|" not found."
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|dstParent
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|error
operator|=
literal|"rename destination parent "
operator|+
name|dst
operator|+
literal|" is a file."
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
name|error
argument_list|)
throw|;
block|}
comment|// Ensure dst has quota to accommodate rename
name|verifyQuotaForRename
argument_list|(
name|srcIIP
operator|.
name|getINodes
argument_list|()
argument_list|,
name|dstIIP
operator|.
name|getINodes
argument_list|()
argument_list|)
expr_stmt|;
name|INode
name|srcChild
init|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|srcChildName
init|=
name|srcChild
operator|.
name|getLocalNameBytes
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isSrcInSnapshot
init|=
name|srcChild
operator|.
name|isInLatestSnapshot
argument_list|(
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|srcChildIsReference
init|=
name|srcChild
operator|.
name|isReference
argument_list|()
decl_stmt|;
comment|// Record the snapshot on srcChild. After the rename, before any new
comment|// snapshot is taken on the dst tree, changes will be recorded in the latest
comment|// snapshot of the src tree.
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
name|srcChild
operator|=
name|srcChild
operator|.
name|recordModification
argument_list|(
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
name|srcIIP
operator|.
name|setLastINode
argument_list|(
name|srcChild
argument_list|)
expr_stmt|;
block|}
comment|// check srcChild for reference
specifier|final
name|INodeReference
operator|.
name|WithCount
name|withCount
decl_stmt|;
name|int
name|srcRefDstSnapshot
init|=
name|srcChildIsReference
condition|?
name|srcChild
operator|.
name|asReference
argument_list|()
operator|.
name|getDstSnapshotId
argument_list|()
else|:
name|Snapshot
operator|.
name|INVALID_ID
decl_stmt|;
name|Quota
operator|.
name|Counts
name|oldSrcCounts
init|=
name|Quota
operator|.
name|Counts
operator|.
name|newInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
specifier|final
name|INodeReference
operator|.
name|WithName
name|withName
init|=
name|srcIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
operator|.
name|replaceChild4ReferenceWithName
argument_list|(
name|srcChild
argument_list|,
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
decl_stmt|;
name|withCount
operator|=
operator|(
name|INodeReference
operator|.
name|WithCount
operator|)
name|withName
operator|.
name|getReferredINode
argument_list|()
expr_stmt|;
name|srcChild
operator|=
name|withName
expr_stmt|;
name|srcIIP
operator|.
name|setLastINode
argument_list|(
name|srcChild
argument_list|)
expr_stmt|;
comment|// get the counts before rename
name|withCount
operator|.
name|getReferredINode
argument_list|()
operator|.
name|computeQuotaUsage
argument_list|(
name|oldSrcCounts
argument_list|,
literal|true
argument_list|,
name|Snapshot
operator|.
name|INVALID_ID
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|srcChildIsReference
condition|)
block|{
comment|// srcChild is reference but srcChild is not in latest snapshot
name|withCount
operator|=
operator|(
name|WithCount
operator|)
name|srcChild
operator|.
name|asReference
argument_list|()
operator|.
name|getReferredINode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|withCount
operator|=
literal|null
expr_stmt|;
block|}
name|boolean
name|undoRemoveSrc
init|=
literal|true
decl_stmt|;
specifier|final
name|long
name|removedSrc
init|=
name|removeLastINode
argument_list|(
name|srcIIP
argument_list|)
decl_stmt|;
if|if
condition|(
name|removedSrc
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
literal|"Failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" because the source can not be removed"
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|error
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|error
argument_list|)
throw|;
block|}
if|if
condition|(
name|dstParent
operator|.
name|getParent
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// src and dst file/dir are in the same directory, and the dstParent has
comment|// been replaced when we removed the src. Refresh the dstIIP and
comment|// dstParent.
name|dstIIP
operator|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|dst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|boolean
name|undoRemoveDst
init|=
literal|false
decl_stmt|;
name|INode
name|removedDst
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|dstInode
operator|!=
literal|null
condition|)
block|{
comment|// dst exists remove it
if|if
condition|(
name|removeLastINode
argument_list|(
name|dstIIP
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|removedDst
operator|=
name|dstIIP
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
name|undoRemoveDst
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|srcChild
operator|=
name|srcIIP
operator|.
name|getLastINode
argument_list|()
expr_stmt|;
specifier|final
name|byte
index|[]
name|dstChildName
init|=
name|dstIIP
operator|.
name|getLastLocalName
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|toDst
decl_stmt|;
if|if
condition|(
name|withCount
operator|==
literal|null
condition|)
block|{
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|dstChildName
argument_list|)
expr_stmt|;
name|toDst
operator|=
name|srcChild
expr_stmt|;
block|}
else|else
block|{
name|withCount
operator|.
name|getReferredINode
argument_list|()
operator|.
name|setLocalName
argument_list|(
name|dstChildName
argument_list|)
expr_stmt|;
name|Snapshot
name|dstSnapshot
init|=
name|dstIIP
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
specifier|final
name|INodeReference
operator|.
name|DstReference
name|ref
init|=
operator|new
name|INodeReference
operator|.
name|DstReference
argument_list|(
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
argument_list|,
name|withCount
argument_list|,
name|dstSnapshot
operator|==
literal|null
condition|?
name|Snapshot
operator|.
name|INVALID_ID
else|:
name|dstSnapshot
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|toDst
operator|=
name|ref
expr_stmt|;
block|}
comment|// add src as dst to complete rename
if|if
condition|(
name|addLastINodeNoQuotaCheck
argument_list|(
name|dstIIP
argument_list|,
name|toDst
argument_list|)
condition|)
block|{
name|undoRemoveSrc
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
name|src
operator|+
literal|" is renamed to "
operator|+
name|dst
argument_list|)
expr_stmt|;
block|}
specifier|final
name|INode
name|srcParent
init|=
name|srcIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
name|srcParent
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
name|dstParent
operator|=
name|dstIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
name|dstParent
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|dstIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
comment|// update moved lease with new filename
name|getFSNamesystem
argument_list|()
operator|.
name|unprotectedChangeLease
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
comment|// Collect the blocks and remove the lease for previous dst
name|long
name|filesDeleted
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|removedDst
operator|!=
literal|null
condition|)
block|{
name|undoRemoveDst
operator|=
literal|false
expr_stmt|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
init|=
operator|new
name|ChunkedArrayList
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
name|filesDeleted
operator|=
name|removedDst
operator|.
name|cleanSubtree
argument_list|(
literal|null
argument_list|,
name|dstIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
literal|true
argument_list|)
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
expr_stmt|;
name|getFSNamesystem
argument_list|()
operator|.
name|removePathAndBlocks
argument_list|(
name|src
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snapshottableDirs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// There are snapshottable directories (without snapshots) to be
comment|// deleted. Need to update the SnapshotManager.
name|namesystem
operator|.
name|removeSnapshottableDirs
argument_list|(
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
comment|// update the quota usage in src tree
if|if
condition|(
name|isSrcInSnapshot
condition|)
block|{
comment|// get the counts after rename
name|Quota
operator|.
name|Counts
name|newSrcCounts
init|=
name|srcChild
operator|.
name|computeQuotaUsage
argument_list|(
name|Quota
operator|.
name|Counts
operator|.
name|newInstance
argument_list|()
argument_list|,
literal|false
argument_list|,
name|Snapshot
operator|.
name|INVALID_ID
argument_list|)
decl_stmt|;
name|newSrcCounts
operator|.
name|subtract
argument_list|(
name|oldSrcCounts
argument_list|)
expr_stmt|;
name|srcParent
operator|.
name|addSpaceConsumed
argument_list|(
name|newSrcCounts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
name|newSrcCounts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|filesDeleted
operator|>=
literal|0
return|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|undoRemoveSrc
condition|)
block|{
comment|// Rename failed - restore src
specifier|final
name|INodeDirectory
name|srcParent
init|=
name|srcIIP
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|oldSrcChild
init|=
name|srcChild
decl_stmt|;
comment|// put it back
if|if
condition|(
name|withCount
operator|==
literal|null
condition|)
block|{
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|srcChildIsReference
condition|)
block|{
comment|// src must be in snapshot
comment|// the withCount node will no longer be used thus no need to update
comment|// its reference number here
specifier|final
name|INode
name|originalChild
init|=
name|withCount
operator|.
name|getReferredINode
argument_list|()
decl_stmt|;
name|srcChild
operator|=
name|originalChild
expr_stmt|;
name|srcChild
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|withCount
operator|.
name|removeReference
argument_list|(
name|oldSrcChild
operator|.
name|asReference
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|INodeReference
name|originalRef
init|=
operator|new
name|INodeReference
operator|.
name|DstReference
argument_list|(
name|srcParent
argument_list|,
name|withCount
argument_list|,
name|srcRefDstSnapshot
argument_list|)
decl_stmt|;
name|srcChild
operator|=
name|originalRef
expr_stmt|;
name|withCount
operator|.
name|getReferredINode
argument_list|()
operator|.
name|setLocalName
argument_list|(
name|srcChildName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srcParent
operator|instanceof
name|INodeDirectoryWithSnapshot
condition|)
block|{
operator|(
operator|(
name|INodeDirectoryWithSnapshot
operator|)
name|srcParent
operator|)
operator|.
name|undoRename4ScrParent
argument_list|(
name|oldSrcChild
operator|.
name|asReference
argument_list|()
argument_list|,
name|srcChild
argument_list|,
name|srcIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// srcParent is not an INodeDirectoryWithSnapshot, we only need to add
comment|// the srcChild back
name|addLastINodeNoQuotaCheck
argument_list|(
name|srcIIP
argument_list|,
name|srcChild
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|undoRemoveDst
condition|)
block|{
comment|// Rename failed - restore dst
if|if
condition|(
name|dstParent
operator|instanceof
name|INodeDirectoryWithSnapshot
condition|)
block|{
operator|(
operator|(
name|INodeDirectoryWithSnapshot
operator|)
name|dstParent
operator|)
operator|.
name|undoRename4DstParent
argument_list|(
name|removedDst
argument_list|,
name|dstIIP
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addLastINodeNoQuotaCheck
argument_list|(
name|dstIIP
argument_list|,
name|removedDst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removedDst
operator|.
name|isReference
argument_list|()
condition|)
block|{
specifier|final
name|INodeReference
name|removedDstRef
init|=
name|removedDst
operator|.
name|asReference
argument_list|()
decl_stmt|;
specifier|final
name|INodeReference
operator|.
name|WithCount
name|wc
init|=
operator|(
name|WithCount
operator|)
name|removedDstRef
operator|.
name|getReferredINode
argument_list|()
operator|.
name|asReference
argument_list|()
decl_stmt|;
name|wc
operator|.
name|addReference
argument_list|(
name|removedDstRef
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedRenameTo: "
operator|+
literal|"failed to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rename from "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" failed."
argument_list|)
throw|;
block|}
comment|/**    * Set file replication    *     * @param src file name    * @param replication new replication    * @param blockRepls block replications - output parameter    * @return array of file blocks    * @throws QuotaExceededException    * @throws SnapshotAccessControlException     */
DECL|method|setReplication (String src, short replication, short[] blockRepls)
name|Block
index|[]
name|setReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|,
name|short
index|[]
name|blockRepls
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|Block
index|[]
name|fileBlocks
init|=
name|unprotectedSetReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|,
name|blockRepls
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileBlocks
operator|!=
literal|null
condition|)
comment|// log replication change
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSetReplication
argument_list|(
name|src
argument_list|,
name|replication
argument_list|)
expr_stmt|;
return|return
name|fileBlocks
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetReplication (String src, short replication, short[] blockRepls)
name|Block
index|[]
name|unprotectedSetReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|,
name|short
index|[]
name|blockRepls
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|iip
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
operator|||
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|INodeFile
name|file
init|=
name|inode
operator|.
name|asFile
argument_list|()
decl_stmt|;
specifier|final
name|short
name|oldBR
init|=
name|file
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
comment|// before setFileReplication, check for increasing block replication.
comment|// if replication> oldBR, then newBR == replication.
comment|// if replication< oldBR, we don't know newBR yet.
if|if
condition|(
name|replication
operator|>
name|oldBR
condition|)
block|{
name|long
name|dsDelta
init|=
operator|(
name|replication
operator|-
name|oldBR
operator|)
operator|*
operator|(
name|file
operator|.
name|diskspaceConsumed
argument_list|()
operator|/
name|oldBR
operator|)
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
name|dsDelta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|file
operator|.
name|setFileReplication
argument_list|(
name|replication
argument_list|,
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
specifier|final
name|short
name|newBR
init|=
name|file
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
comment|// check newBR< oldBR case.
if|if
condition|(
name|newBR
operator|<
name|oldBR
condition|)
block|{
name|long
name|dsDelta
init|=
operator|(
name|newBR
operator|-
name|oldBR
operator|)
operator|*
operator|(
name|file
operator|.
name|diskspaceConsumed
argument_list|()
operator|/
name|newBR
operator|)
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
name|dsDelta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blockRepls
operator|!=
literal|null
condition|)
block|{
name|blockRepls
index|[
literal|0
index|]
operator|=
name|oldBR
expr_stmt|;
name|blockRepls
index|[
literal|1
index|]
operator|=
name|newBR
expr_stmt|;
block|}
return|return
name|file
operator|.
name|getBlocks
argument_list|()
return|;
block|}
comment|/**    * @param path the file path    * @return the block size of the file.     */
DECL|method|getPreferredBlockSize (String path)
name|long
name|getPreferredBlockSize
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|rootDir
operator|.
name|getNode
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
argument_list|,
name|path
argument_list|)
operator|.
name|getPreferredBlockSize
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|exists (String src)
name|boolean
name|exists
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|inode
init|=
name|rootDir
operator|.
name|getNode
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|!
name|inode
operator|.
name|isFile
argument_list|()
operator|||
name|inode
operator|.
name|asFile
argument_list|()
operator|.
name|getBlocks
argument_list|()
operator|!=
literal|null
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setPermission (String src, FsPermission permission)
name|void
name|setPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedSetPermission
argument_list|(
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSetPermissions
argument_list|(
name|src
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
DECL|method|unprotectedSetPermission (String src, FsPermission permissions)
name|void
name|unprotectedSetPermission
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permissions
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
name|inode
operator|.
name|setPermission
argument_list|(
name|permissions
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
block|}
DECL|method|setOwner (String src, String username, String groupname)
name|void
name|setOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedSetOwner
argument_list|(
name|src
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSetOwner
argument_list|(
name|src
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
block|}
DECL|method|unprotectedSetOwner (String src, String username, String groupname)
name|void
name|unprotectedSetOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|username
operator|!=
literal|null
condition|)
block|{
name|inode
operator|=
name|inode
operator|.
name|setUser
argument_list|(
name|username
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupname
operator|!=
literal|null
condition|)
block|{
name|inode
operator|.
name|setGroup
argument_list|(
name|groupname
argument_list|,
name|inodesInPath
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Concat all the blocks from srcs to trg and delete the srcs files    */
DECL|method|concat (String target, String [] srcs, boolean supportRetryCache)
name|void
name|concat
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|boolean
name|supportRetryCache
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
throws|,
name|SnapshotException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// actual move
name|waitForReady
argument_list|()
expr_stmt|;
name|long
name|timestamp
init|=
name|now
argument_list|()
decl_stmt|;
name|unprotectedConcat
argument_list|(
name|target
argument_list|,
name|srcs
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
comment|// do the commit
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logConcat
argument_list|(
name|target
argument_list|,
name|srcs
argument_list|,
name|timestamp
argument_list|,
name|supportRetryCache
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Concat all the blocks from srcs to trg and delete the srcs files    * @param target target file to move the blocks to    * @param srcs list of file to move the blocks from    */
DECL|method|unprotectedConcat (String target, String [] srcs, long timestamp)
name|void
name|unprotectedConcat
parameter_list|(
name|String
name|target
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
throws|,
name|SnapshotException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSNamesystem.concat to "
operator|+
name|target
argument_list|)
expr_stmt|;
block|}
comment|// do the move
specifier|final
name|INodesInPath
name|trgIIP
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|target
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|INode
index|[]
name|trgINodes
init|=
name|trgIIP
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|INodeFile
name|trgInode
init|=
name|trgIIP
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|INodeDirectory
name|trgParent
init|=
name|trgINodes
index|[
name|trgINodes
operator|.
name|length
operator|-
literal|2
index|]
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
specifier|final
name|Snapshot
name|trgLatestSnapshot
init|=
name|trgIIP
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
specifier|final
name|INodeFile
index|[]
name|allSrcInodes
init|=
operator|new
name|INodeFile
index|[
name|srcs
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|srcs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|INodesInPath
name|iip
init|=
name|getINodesInPath4Write
argument_list|(
name|srcs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
specifier|final
name|Snapshot
name|latest
init|=
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
comment|// check if the file in the latest snapshot
if|if
condition|(
name|inode
operator|.
name|isInLatestSnapshot
argument_list|(
name|latest
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
literal|"Concat: the source file "
operator|+
name|srcs
index|[
name|i
index|]
operator|+
literal|" is in snapshot "
operator|+
name|latest
argument_list|)
throw|;
block|}
comment|// check if the file has other references.
if|if
condition|(
name|inode
operator|.
name|isReference
argument_list|()
operator|&&
operator|(
operator|(
name|INodeReference
operator|.
name|WithCount
operator|)
name|inode
operator|.
name|asReference
argument_list|()
operator|.
name|getReferredINode
argument_list|()
operator|)
operator|.
name|getReferenceCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
literal|"Concat: the source file "
operator|+
name|srcs
index|[
name|i
index|]
operator|+
literal|" is referred by some other reference in some snapshot."
argument_list|)
throw|;
block|}
name|allSrcInodes
index|[
name|i
index|]
operator|=
name|inode
operator|.
name|asFile
argument_list|()
expr_stmt|;
block|}
name|trgInode
operator|.
name|concatBlocks
argument_list|(
name|allSrcInodes
argument_list|)
expr_stmt|;
comment|// since we are in the same dir - we can use same parent to remove files
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|INodeFile
name|nodeToRemove
range|:
name|allSrcInodes
control|)
block|{
if|if
condition|(
name|nodeToRemove
operator|==
literal|null
condition|)
continue|continue;
name|nodeToRemove
operator|.
name|setBlocks
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|trgParent
operator|.
name|removeChild
argument_list|(
name|nodeToRemove
argument_list|,
name|trgLatestSnapshot
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|inodeMap
operator|.
name|remove
argument_list|(
name|nodeToRemove
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|// update inodeMap
name|removeFromInodeMap
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|allSrcInodes
argument_list|)
argument_list|)
expr_stmt|;
name|trgInode
operator|.
name|setModificationTime
argument_list|(
name|timestamp
argument_list|,
name|trgLatestSnapshot
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
name|trgParent
operator|.
name|updateModificationTime
argument_list|(
name|timestamp
argument_list|,
name|trgLatestSnapshot
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
comment|// update quota on the parent directory ('count' files removed, 0 space)
name|unprotectedUpdateCount
argument_list|(
name|trgIIP
argument_list|,
name|trgINodes
operator|.
name|length
operator|-
literal|1
argument_list|,
operator|-
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete the target directory and collect the blocks under it    *     * @param src Path of a directory to delete    * @param collectedBlocks Blocks under the deleted directory    * @param removedINodes INodes that should be removed from {@link #inodeMap}    * @param logRetryCache Whether to record RPC IDs in editlog to support retry    *                      cache rebuilding.    * @return true on successful deletion; else false    */
DECL|method|delete (String src, BlocksMapUpdateInfo collectedBlocks, List<INode> removedINodes, boolean logRetryCache)
name|boolean
name|delete
parameter_list|(
name|String
name|src
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.delete: "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
name|waitForReady
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
specifier|final
name|long
name|filesRemoved
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|deleteAllowed
argument_list|(
name|inodesInPath
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|filesRemoved
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// Before removing the node, first check if the targetNode is for a
comment|// snapshottable dir with snapshots, or its descendants have
comment|// snapshottable dir with snapshots
specifier|final
name|INode
name|targetNode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
name|snapshottableDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
argument_list|()
decl_stmt|;
name|checkSnapshot
argument_list|(
name|targetNode
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
name|filesRemoved
operator|=
name|unprotectedDelete
argument_list|(
name|inodesInPath
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapshottableDirs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// There are some snapshottable directories without snapshots to be
comment|// deleted. Need to update the SnapshotManager.
name|namesystem
operator|.
name|removeSnapshottableDirs
argument_list|(
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|filesRemoved
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logDelete
argument_list|(
name|src
argument_list|,
name|now
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
name|incrDeletedFileCount
argument_list|(
name|filesRemoved
argument_list|)
expr_stmt|;
comment|// Blocks/INodes will be handled later by the caller of this method
name|getFSNamesystem
argument_list|()
operator|.
name|removePathAndBlocks
argument_list|(
name|src
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|deleteAllowed (final INodesInPath iip, final String src)
specifier|private
specifier|static
name|boolean
name|deleteAllowed
parameter_list|(
specifier|final
name|INodesInPath
name|iip
parameter_list|,
specifier|final
name|String
name|src
parameter_list|)
block|{
specifier|final
name|INode
index|[]
name|inodes
init|=
name|iip
operator|.
name|getINodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|inodes
operator|==
literal|null
operator|||
name|inodes
operator|.
name|length
operator|==
literal|0
operator|||
name|inodes
index|[
name|inodes
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
literal|"failed to remove "
operator|+
name|src
operator|+
literal|" because it does not exist"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|inodes
operator|.
name|length
operator|==
literal|1
condition|)
block|{
comment|// src is the root
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
literal|"failed to remove "
operator|+
name|src
operator|+
literal|" because the root is not allowed to be deleted"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @return true if the path is a non-empty directory; otherwise, return false.    */
DECL|method|isNonEmptyDirectory (String path)
name|boolean
name|isNonEmptyDirectory
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getLastINodeInPath
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
operator|||
operator|!
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//not found or not a directory
return|return
literal|false
return|;
block|}
specifier|final
name|Snapshot
name|s
init|=
name|inodesInPath
operator|.
name|getPathSnapshot
argument_list|()
decl_stmt|;
return|return
operator|!
name|inode
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenList
argument_list|(
name|s
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Delete a path from the name space    * Update the count at each ancestor directory with quota    *<br>    * Note: This is to be used by {@link FSEditLog} only.    *<br>    * @param src a string representation of a path to an inode    * @param mtime the time the inode is removed    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|unprotectedDelete (String src, long mtime)
name|void
name|unprotectedDelete
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|BlocksMapUpdateInfo
name|collectedBlocks
init|=
operator|new
name|BlocksMapUpdateInfo
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
init|=
operator|new
name|ChunkedArrayList
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|normalizePath
argument_list|(
name|src
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|long
name|filesRemoved
init|=
name|deleteAllowed
argument_list|(
name|inodesInPath
argument_list|,
name|src
argument_list|)
condition|?
name|unprotectedDelete
argument_list|(
name|inodesInPath
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
name|mtime
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|filesRemoved
operator|>=
literal|0
condition|)
block|{
name|getFSNamesystem
argument_list|()
operator|.
name|removePathAndBlocks
argument_list|(
name|src
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a path from the name space    * Update the count at each ancestor directory with quota    * @param iip the inodes resolved from the path    * @param collectedBlocks blocks collected from the deleted path    * @param removedINodes inodes that should be removed from {@link #inodeMap}    * @param mtime the time the inode is removed    * @return the number of inodes deleted; 0 if no inodes are deleted.    */
DECL|method|unprotectedDelete (INodesInPath iip, BlocksMapUpdateInfo collectedBlocks, List<INode> removedINodes, long mtime)
name|long
name|unprotectedDelete
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|,
name|long
name|mtime
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// check if target node exists
name|INode
name|targetNode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// record modification
specifier|final
name|Snapshot
name|latestSnapshot
init|=
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
name|targetNode
operator|=
name|targetNode
operator|.
name|recordModification
argument_list|(
name|latestSnapshot
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
name|iip
operator|.
name|setLastINode
argument_list|(
name|targetNode
argument_list|)
expr_stmt|;
comment|// Remove the node from the namespace
name|long
name|removed
init|=
name|removeLastINode
argument_list|(
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// set the parent's modification time
specifier|final
name|INodeDirectory
name|parent
init|=
name|targetNode
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|parent
operator|.
name|updateModificationTime
argument_list|(
name|mtime
argument_list|,
name|latestSnapshot
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// collect block
if|if
condition|(
operator|!
name|targetNode
operator|.
name|isInLatestSnapshot
argument_list|(
name|latestSnapshot
argument_list|)
condition|)
block|{
name|targetNode
operator|.
name|destroyAndCollectBlocks
argument_list|(
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Quota
operator|.
name|Counts
name|counts
init|=
name|targetNode
operator|.
name|cleanSubtree
argument_list|(
literal|null
argument_list|,
name|latestSnapshot
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|parent
operator|.
name|addSpaceConsumed
argument_list|(
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.unprotectedDelete: "
operator|+
name|targetNode
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" is removed"
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
comment|/**    * Check if the given INode (or one of its descendants) is snapshottable and    * already has snapshots.    *     * @param target The given INode    * @param snapshottableDirs The list of directories that are snapshottable     *                          but do not have snapshots yet    */
DECL|method|checkSnapshot (INode target, List<INodeDirectorySnapshottable> snapshottableDirs)
specifier|private
specifier|static
name|void
name|checkSnapshot
parameter_list|(
name|INode
name|target
parameter_list|,
name|List
argument_list|<
name|INodeDirectorySnapshottable
argument_list|>
name|snapshottableDirs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|target
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|INodeDirectory
name|targetDir
init|=
name|target
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetDir
operator|.
name|isSnapshottable
argument_list|()
condition|)
block|{
name|INodeDirectorySnapshottable
name|ssTargetDir
init|=
operator|(
name|INodeDirectorySnapshottable
operator|)
name|targetDir
decl_stmt|;
if|if
condition|(
name|ssTargetDir
operator|.
name|getNumSnapshots
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The directory "
operator|+
name|ssTargetDir
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" cannot be deleted since "
operator|+
name|ssTargetDir
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" is snapshottable and already has snapshots"
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|snapshottableDirs
operator|!=
literal|null
condition|)
block|{
name|snapshottableDirs
operator|.
name|add
argument_list|(
name|ssTargetDir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|INode
name|child
range|:
name|targetDir
operator|.
name|getChildrenList
argument_list|(
literal|null
argument_list|)
control|)
block|{
name|checkSnapshot
argument_list|(
name|child
argument_list|,
name|snapshottableDirs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Replaces the specified INodeFile with the specified one.    */
DECL|method|replaceINodeFile (String path, INodeFile oldnode, INodeFile newnode)
name|void
name|replaceINodeFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|oldnode
parameter_list|,
name|INodeFile
name|newnode
parameter_list|)
throws|throws
name|IOException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|unprotectedReplaceINodeFile
argument_list|(
name|path
argument_list|,
name|oldnode
argument_list|,
name|newnode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Replace an INodeFile and record modification for the latest snapshot. */
DECL|method|unprotectedReplaceINodeFile (final String path, final INodeFile oldnode, final INodeFile newnode)
name|void
name|unprotectedReplaceINodeFile
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|INodeFile
name|oldnode
parameter_list|,
specifier|final
name|INodeFile
name|newnode
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|hasWriteLock
argument_list|()
argument_list|)
expr_stmt|;
name|oldnode
operator|.
name|getParent
argument_list|()
operator|.
name|replaceChild
argument_list|(
name|oldnode
argument_list|,
name|newnode
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
name|oldnode
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|/* Currently oldnode and newnode are assumed to contain the same      * blocks. Otherwise, blocks need to be removed from the blocksMap.      */
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockInfo
name|b
range|:
name|newnode
operator|.
name|getBlocks
argument_list|()
control|)
block|{
name|BlockInfo
name|info
init|=
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|b
argument_list|,
name|newnode
argument_list|)
decl_stmt|;
name|newnode
operator|.
name|setBlock
argument_list|(
name|index
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|// inode refers to the block in BlocksMap
name|index
operator|++
expr_stmt|;
block|}
block|}
comment|/**    * Get a partial listing of the indicated directory    *    * @param src the directory name    * @param startAfter the name to start listing after    * @param needLocation if block locations are returned    * @return a partial listing starting after startAfter    */
DECL|method|getListing (String src, byte[] startAfter, boolean needLocation)
name|DirectoryListing
name|getListing
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|srcs
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
condition|)
block|{
return|return
name|getSnapshotsListing
argument_list|(
name|srcs
argument_list|,
name|startAfter
argument_list|)
return|;
block|}
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getLastINodeInPath
argument_list|(
name|srcs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|Snapshot
name|snapshot
init|=
name|inodesInPath
operator|.
name|getPathSnapshot
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|targetNode
init|=
name|inodesInPath
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
name|targetNode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
return|return
operator|new
name|DirectoryListing
argument_list|(
operator|new
name|HdfsFileStatus
index|[]
block|{
name|createFileStatus
argument_list|(
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|,
name|targetNode
argument_list|,
name|needLocation
argument_list|,
name|snapshot
argument_list|)
block|}
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|final
name|INodeDirectory
name|dirInode
init|=
name|targetNode
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
specifier|final
name|ReadOnlyList
argument_list|<
name|INode
argument_list|>
name|contents
init|=
name|dirInode
operator|.
name|getChildrenList
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|int
name|startChild
init|=
name|INodeDirectory
operator|.
name|nextChild
argument_list|(
name|contents
argument_list|,
name|startAfter
argument_list|)
decl_stmt|;
name|int
name|totalNumChildren
init|=
name|contents
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numOfListing
init|=
name|Math
operator|.
name|min
argument_list|(
name|totalNumChildren
operator|-
name|startChild
argument_list|,
name|this
operator|.
name|lsLimit
argument_list|)
decl_stmt|;
name|HdfsFileStatus
name|listing
index|[]
init|=
operator|new
name|HdfsFileStatus
index|[
name|numOfListing
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfListing
condition|;
name|i
operator|++
control|)
block|{
name|INode
name|cur
init|=
name|contents
operator|.
name|get
argument_list|(
name|startChild
operator|+
name|i
argument_list|)
decl_stmt|;
name|listing
index|[
name|i
index|]
operator|=
name|createFileStatus
argument_list|(
name|cur
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|cur
argument_list|,
name|needLocation
argument_list|,
name|snapshot
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DirectoryListing
argument_list|(
name|listing
argument_list|,
name|totalNumChildren
operator|-
name|startChild
operator|-
name|numOfListing
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a listing of all the snapshots of a snapshottable directory    */
DECL|method|getSnapshotsListing (String src, byte[] startAfter)
specifier|private
name|DirectoryListing
name|getSnapshotsListing
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|hasReadLock
argument_list|()
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|src
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
argument_list|,
literal|"%s does not end with %s"
argument_list|,
name|src
argument_list|,
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
expr_stmt|;
specifier|final
name|String
name|dirPath
init|=
name|normalizePath
argument_list|(
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|node
init|=
name|this
operator|.
name|getINode
argument_list|(
name|dirPath
argument_list|)
decl_stmt|;
specifier|final
name|INodeDirectorySnapshottable
name|dirNode
init|=
name|INodeDirectorySnapshottable
operator|.
name|valueOf
argument_list|(
name|node
argument_list|,
name|dirPath
argument_list|)
decl_stmt|;
specifier|final
name|ReadOnlyList
argument_list|<
name|Snapshot
argument_list|>
name|snapshots
init|=
name|dirNode
operator|.
name|getSnapshotList
argument_list|()
decl_stmt|;
name|int
name|skipSize
init|=
name|ReadOnlyList
operator|.
name|Util
operator|.
name|binarySearch
argument_list|(
name|snapshots
argument_list|,
name|startAfter
argument_list|)
decl_stmt|;
name|skipSize
operator|=
name|skipSize
operator|<
literal|0
condition|?
operator|-
name|skipSize
operator|-
literal|1
else|:
name|skipSize
operator|+
literal|1
expr_stmt|;
name|int
name|numOfListing
init|=
name|Math
operator|.
name|min
argument_list|(
name|snapshots
operator|.
name|size
argument_list|()
operator|-
name|skipSize
argument_list|,
name|this
operator|.
name|lsLimit
argument_list|)
decl_stmt|;
specifier|final
name|HdfsFileStatus
name|listing
index|[]
init|=
operator|new
name|HdfsFileStatus
index|[
name|numOfListing
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfListing
condition|;
name|i
operator|++
control|)
block|{
name|Root
name|sRoot
init|=
name|snapshots
operator|.
name|get
argument_list|(
name|i
operator|+
name|skipSize
argument_list|)
operator|.
name|getRoot
argument_list|()
decl_stmt|;
name|listing
index|[
name|i
index|]
operator|=
name|createFileStatus
argument_list|(
name|sRoot
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|sRoot
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DirectoryListing
argument_list|(
name|listing
argument_list|,
name|snapshots
operator|.
name|size
argument_list|()
operator|-
name|skipSize
operator|-
name|numOfListing
argument_list|)
return|;
block|}
comment|/** Get the file info for a specific file.    * @param src The string representation of the path to the file    * @param resolveLink whether to throw UnresolvedLinkException     * @return object containing information regarding the file    *         or null if file not found    */
DECL|method|getFileInfo (String src, boolean resolveLink)
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
name|String
name|src
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|srcs
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
condition|)
block|{
return|return
name|getFileInfo4DotSnapshot
argument_list|(
name|srcs
argument_list|)
return|;
block|}
specifier|final
name|INodesInPath
name|inodesInPath
init|=
name|rootDir
operator|.
name|getLastINodeInPath
argument_list|(
name|srcs
argument_list|,
name|resolveLink
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|i
init|=
name|inodesInPath
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|i
operator|==
literal|null
condition|?
literal|null
else|:
name|createFileStatus
argument_list|(
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|,
name|i
argument_list|,
name|inodesInPath
operator|.
name|getPathSnapshot
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Currently we only support "ls /xxx/.snapshot" which will return all the    * snapshots of a directory. The FSCommand Ls will first call getFileInfo to    * make sure the file/directory exists (before the real getListing call).    * Since we do not have a real INode for ".snapshot", we return an empty    * non-null HdfsFileStatus here.    */
DECL|method|getFileInfo4DotSnapshot (String src)
specifier|private
name|HdfsFileStatus
name|getFileInfo4DotSnapshot
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|src
operator|.
name|endsWith
argument_list|(
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
argument_list|,
literal|"%s does not end with %s"
argument_list|,
name|src
argument_list|,
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
expr_stmt|;
specifier|final
name|String
name|dirPath
init|=
name|normalizePath
argument_list|(
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|INode
name|node
init|=
name|this
operator|.
name|getINode
argument_list|(
name|dirPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
operator|&&
name|node
operator|.
name|asDirectory
argument_list|()
operator|instanceof
name|INodeDirectorySnapshottable
condition|)
block|{
return|return
operator|new
name|HdfsFileStatus
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
argument_list|,
operator|-
literal|1L
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get the blocks associated with the file.    */
DECL|method|getFileBlocks (String src)
name|Block
index|[]
name|getFileBlocks
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INode
name|i
init|=
name|rootDir
operator|.
name|getNode
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|i
operator|!=
literal|null
operator|&&
name|i
operator|.
name|isFile
argument_list|()
condition|?
name|i
operator|.
name|asFile
argument_list|()
operator|.
name|getBlocks
argument_list|()
else|:
literal|null
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getExistingPathINodes (byte[][] components)
name|INodesInPath
name|getExistingPathINodes
parameter_list|(
name|byte
index|[]
index|[]
name|components
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|components
argument_list|)
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getINode (String src)
specifier|public
name|INode
name|getINode
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
return|return
name|getLastINodeInPath
argument_list|(
name|src
argument_list|)
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getLastINodeInPath (String src)
specifier|public
name|INodesInPath
name|getLastINodeInPath
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|getLastINodeInPath
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getINodesInPath4Write (String src )
specifier|public
name|INodesInPath
name|getINodesInPath4Write
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|getINode4Write (String src)
specifier|public
name|INode
name|getINode4Write
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|getINode4Write
argument_list|(
name|src
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**     * Check whether the filepath could be created    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|isValidToCreate (String src)
name|boolean
name|isValidToCreate
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|srcs
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
operator|!
name|srcs
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|rootDir
operator|.
name|getINode4Write
argument_list|(
name|srcs
argument_list|,
literal|false
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check whether the path specifies a directory    */
DECL|method|isDir (String src)
name|boolean
name|isDir
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|node
init|=
name|rootDir
operator|.
name|getNode
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check whether the path specifies a directory    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|isDirMutable (String src)
name|boolean
name|isDirMutable
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|node
init|=
name|rootDir
operator|.
name|getINode4Write
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Updates namespace and diskspace consumed for all    * directories until the parent directory of file represented by path.    *     * @param path path for the file.    * @param nsDelta the delta change of namespace    * @param dsDelta the delta change of diskspace    * @throws QuotaExceededException if the new count violates any quota limit    * @throws FileNotFoundException if path does not exist.    */
DECL|method|updateSpaceConsumed (String path, long nsDelta, long dsDelta)
name|void
name|updateSpaceConsumed
parameter_list|(
name|String
name|path
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|iip
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|iip
operator|.
name|getLastINode
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Path not found: "
operator|+
name|path
argument_list|)
throw|;
block|}
name|updateCount
argument_list|(
name|iip
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateCount (INodesInPath iip, long nsDelta, long dsDelta, boolean checkQuota)
specifier|private
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|updateCount
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|-
literal|1
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
block|}
comment|/** update count of each inode with quota    *     * @param iip inodes in a path    * @param numOfINodes the number of inodes to update starting from index 0    * @param nsDelta the delta change of namespace    * @param dsDelta the delta change of diskspace    * @param checkQuota if true then check if quota is exceeded    * @throws QuotaExceededException if the new count violates any quota limit    */
DECL|method|updateCount (INodesInPath iip, int numOfINodes, long nsDelta, long dsDelta, boolean checkQuota)
specifier|private
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
operator|!
name|ready
condition|)
block|{
comment|//still initializing. do not check or update quotas.
return|return;
block|}
specifier|final
name|INode
index|[]
name|inodes
init|=
name|iip
operator|.
name|getINodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|numOfINodes
operator|>
name|inodes
operator|.
name|length
condition|)
block|{
name|numOfINodes
operator|=
name|inodes
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|checkQuota
condition|)
block|{
name|verifyQuota
argument_list|(
name|inodes
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|unprotectedUpdateCount
argument_list|(
name|iip
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
comment|/**     * update quota of each inode and check to see if quota is exceeded.     * See {@link #updateCount(INode[], int, long, long, boolean)}    */
DECL|method|updateCountNoQuotaCheck (INodesInPath inodesInPath, int numOfINodes, long nsDelta, long dsDelta)
specifier|private
name|void
name|updateCountNoQuotaCheck
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
try|try
block|{
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
name|numOfINodes
argument_list|,
name|nsDelta
argument_list|,
name|dsDelta
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"BUG: unexpected exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * updates quota without verification    * callers responsibility is to make sure quota is not exceeded    */
DECL|method|unprotectedUpdateCount (INodesInPath inodesInPath, int numOfINodes, long nsDelta, long dsDelta)
specifier|private
specifier|static
name|void
name|unprotectedUpdateCount
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|)
block|{
specifier|final
name|INode
index|[]
name|inodes
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfINodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inodes
index|[
name|i
index|]
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
comment|// a directory with quota
name|INodeDirectoryWithQuota
name|node
init|=
operator|(
name|INodeDirectoryWithQuota
operator|)
name|inodes
index|[
name|i
index|]
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
name|node
operator|.
name|addSpaceConsumed2Cache
argument_list|(
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Return the name of the path represented by inodes at [0, pos] */
DECL|method|getFullPathName (INode[] inodes, int pos)
specifier|static
name|String
name|getFullPathName
parameter_list|(
name|INode
index|[]
name|inodes
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|StringBuilder
name|fullPathName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|inodes
index|[
literal|0
index|]
operator|.
name|isRoot
argument_list|()
condition|)
block|{
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
else|else
block|{
name|fullPathName
operator|.
name|append
argument_list|(
name|inodes
index|[
literal|0
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|pos
condition|;
name|i
operator|++
control|)
block|{
name|fullPathName
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR_CHAR
argument_list|)
operator|.
name|append
argument_list|(
name|inodes
index|[
name|i
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|fullPathName
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return the relative path of an inode from one of its ancestors,    *         represented by an array of inodes.    */
DECL|method|getRelativePathINodes (INode inode, INode ancestor)
specifier|private
specifier|static
name|INode
index|[]
name|getRelativePathINodes
parameter_list|(
name|INode
name|inode
parameter_list|,
name|INode
name|ancestor
parameter_list|)
block|{
comment|// calculate the depth of this inode from the ancestor
name|int
name|depth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|INode
name|i
init|=
name|inode
init|;
name|i
operator|!=
literal|null
operator|&&
operator|!
name|i
operator|.
name|equals
argument_list|(
name|ancestor
argument_list|)
condition|;
name|i
operator|=
name|i
operator|.
name|getParent
argument_list|()
control|)
block|{
name|depth
operator|++
expr_stmt|;
block|}
name|INode
index|[]
name|inodes
init|=
operator|new
name|INode
index|[
name|depth
index|]
decl_stmt|;
comment|// fill up the inodes in the path from this inode to root
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"Could not get full path."
operator|+
literal|" Corresponding file might have deleted already."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|inodes
index|[
name|depth
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|inode
expr_stmt|;
name|inode
operator|=
name|inode
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
name|inodes
return|;
block|}
DECL|method|getFullPathINodes (INode inode)
specifier|private
specifier|static
name|INode
index|[]
name|getFullPathINodes
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
return|return
name|getRelativePathINodes
argument_list|(
name|inode
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Return the full path name of the specified inode */
DECL|method|getFullPathName (INode inode)
specifier|static
name|String
name|getFullPathName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
name|INode
index|[]
name|inodes
init|=
name|getFullPathINodes
argument_list|(
name|inode
argument_list|)
decl_stmt|;
return|return
name|getFullPathName
argument_list|(
name|inodes
argument_list|,
name|inodes
operator|.
name|length
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Create a directory     * If ancestor directories do not exist, automatically create them.     * @param src string representation of the path to the directory    * @param permissions the permission of the directory    * @param isAutocreate if the permission of the directory should inherit    *                          from its parent or not. u+wx is implicitly added to    *                          the automatically created directories, and to the    *                          given directory if inheritPermission is true    * @param now creation time    * @return true if the operation succeeds false otherwise    * @throws FileNotFoundException if an ancestor or itself is a file    * @throws QuotaExceededException if directory creation violates     *                                any quota limit    * @throws UnresolvedLinkException if a symlink is encountered in src.                          * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|mkdirs (String src, PermissionStatus permissions, boolean inheritPermission, long now)
name|boolean
name|mkdirs
parameter_list|(
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|boolean
name|inheritPermission
parameter_list|,
name|long
name|now
parameter_list|)
throws|throws
name|FileAlreadyExistsException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|src
operator|=
name|normalizePath
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|String
index|[]
name|names
init|=
name|INode
operator|.
name|getPathNames
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|names
argument_list|)
decl_stmt|;
specifier|final
name|int
name|lastInodeIndex
init|=
name|components
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INodesInPath
name|iip
init|=
name|getExistingPathINodes
argument_list|(
name|components
argument_list|)
decl_stmt|;
if|if
condition|(
name|iip
operator|.
name|isSnapshot
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SnapshotAccessControlException
argument_list|(
literal|"Modification on RO snapshot is disallowed"
argument_list|)
throw|;
block|}
name|INode
index|[]
name|inodes
init|=
name|iip
operator|.
name|getINodes
argument_list|()
decl_stmt|;
comment|// find the index of the first null in inodes[]
name|StringBuilder
name|pathbuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|inodes
operator|.
name|length
operator|&&
name|inodes
index|[
name|i
index|]
operator|!=
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|pathbuilder
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inodes
index|[
name|i
index|]
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Parent path is not a directory: "
operator|+
name|pathbuilder
operator|+
literal|" "
operator|+
name|inodes
index|[
name|i
index|]
operator|.
name|getLocalName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// default to creating parent dirs with the given perms
name|PermissionStatus
name|parentPermissions
init|=
name|permissions
decl_stmt|;
comment|// if not inheriting and it's the last inode, there's no use in
comment|// computing perms that won't be used
if|if
condition|(
name|inheritPermission
operator|||
operator|(
name|i
operator|<
name|lastInodeIndex
operator|)
condition|)
block|{
comment|// if inheriting (ie. creating a file or symlink), use the parent dir,
comment|// else the supplied permissions
comment|// NOTE: the permissions of the auto-created directories violate posix
name|FsPermission
name|parentFsPerm
init|=
name|inheritPermission
condition|?
name|inodes
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|getFsPermission
argument_list|()
else|:
name|permissions
operator|.
name|getPermission
argument_list|()
decl_stmt|;
comment|// ensure that the permissions allow user write+execute
if|if
condition|(
operator|!
name|parentFsPerm
operator|.
name|getUserAction
argument_list|()
operator|.
name|implies
argument_list|(
name|FsAction
operator|.
name|WRITE_EXECUTE
argument_list|)
condition|)
block|{
name|parentFsPerm
operator|=
operator|new
name|FsPermission
argument_list|(
name|parentFsPerm
operator|.
name|getUserAction
argument_list|()
operator|.
name|or
argument_list|(
name|FsAction
operator|.
name|WRITE_EXECUTE
argument_list|)
argument_list|,
name|parentFsPerm
operator|.
name|getGroupAction
argument_list|()
argument_list|,
name|parentFsPerm
operator|.
name|getOtherAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parentPermissions
operator|.
name|getPermission
argument_list|()
operator|.
name|equals
argument_list|(
name|parentFsPerm
argument_list|)
condition|)
block|{
name|parentPermissions
operator|=
operator|new
name|PermissionStatus
argument_list|(
name|parentPermissions
operator|.
name|getUserName
argument_list|()
argument_list|,
name|parentPermissions
operator|.
name|getGroupName
argument_list|()
argument_list|,
name|parentFsPerm
argument_list|)
expr_stmt|;
comment|// when inheriting, use same perms for entire path
if|if
condition|(
name|inheritPermission
condition|)
name|permissions
operator|=
name|parentPermissions
expr_stmt|;
block|}
block|}
comment|// create directories beginning from the first null index
for|for
control|(
init|;
name|i
operator|<
name|inodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pathbuilder
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
operator|+
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|unprotectedMkdir
argument_list|(
name|namesystem
operator|.
name|allocateNewInodeId
argument_list|()
argument_list|,
name|iip
argument_list|,
name|i
argument_list|,
name|components
index|[
name|i
index|]
argument_list|,
operator|(
name|i
operator|<
name|lastInodeIndex
operator|)
condition|?
name|parentPermissions
else|:
name|permissions
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|inodes
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Directory creation also count towards FilesCreated
comment|// to match count of FilesDeleted metric.
if|if
condition|(
name|getFSNamesystem
argument_list|()
operator|!=
literal|null
condition|)
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|incrFilesCreated
argument_list|()
expr_stmt|;
specifier|final
name|String
name|cur
init|=
name|pathbuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logMkDir
argument_list|(
name|cur
argument_list|,
name|inodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* FSDirectory.mkdirs: created directory "
operator|+
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|unprotectedMkdir (long inodeId, String src, PermissionStatus permissions, long timestamp)
name|INode
name|unprotectedMkdir
parameter_list|(
name|long
name|inodeId
parameter_list|,
name|String
name|src
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|INodesInPath
name|iip
init|=
name|getExistingPathINodes
argument_list|(
name|components
argument_list|)
decl_stmt|;
name|INode
index|[]
name|inodes
init|=
name|iip
operator|.
name|getINodes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|pos
init|=
name|inodes
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|unprotectedMkdir
argument_list|(
name|inodeId
argument_list|,
name|iip
argument_list|,
name|pos
argument_list|,
name|components
index|[
name|pos
index|]
argument_list|,
name|permissions
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
return|return
name|inodes
index|[
name|pos
index|]
return|;
block|}
comment|/** create a directory at index pos.    * The parent path to the directory is at [0, pos-1].    * All ancestors exist. Newly created one stored at index pos.    */
DECL|method|unprotectedMkdir (long inodeId, INodesInPath inodesInPath, int pos, byte[] name, PermissionStatus permission, long timestamp)
specifier|private
name|void
name|unprotectedMkdir
parameter_list|(
name|long
name|inodeId
parameter_list|,
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|pos
parameter_list|,
name|byte
index|[]
name|name
parameter_list|,
name|PermissionStatus
name|permission
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeDirectory
name|dir
init|=
operator|new
name|INodeDirectory
argument_list|(
name|inodeId
argument_list|,
name|name
argument_list|,
name|permission
argument_list|,
name|timestamp
argument_list|)
decl_stmt|;
if|if
condition|(
name|addChild
argument_list|(
name|inodesInPath
argument_list|,
name|pos
argument_list|,
name|dir
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|inodesInPath
operator|.
name|setINode
argument_list|(
name|pos
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add the given child to the namespace.    * @param src The full path name of the child node.    * @throw QuotaExceededException is thrown if it violates quota limit    */
DECL|method|addINode (String src, INode child )
specifier|private
name|boolean
name|addINode
parameter_list|(
name|String
name|src
parameter_list|,
name|INode
name|child
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
block|{
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|child
operator|.
name|setLocalName
argument_list|(
name|components
index|[
name|components
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|cacheName
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|addLastINode
argument_list|(
name|getExistingPathINodes
argument_list|(
name|components
argument_list|)
argument_list|,
name|child
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Verify quota for adding or moving a new INode with required     * namespace and diskspace to a given position.    *      * @param inodes INodes corresponding to a path    * @param pos position where a new INode will be added    * @param nsDelta needed namespace    * @param dsDelta needed diskspace    * @param commonAncestor Last node in inodes array that is a common ancestor    *          for a INode that is being moved from one location to the other.    *          Pass null if a node is not being moved.    * @throws QuotaExceededException if quota limit is exceeded.    */
DECL|method|verifyQuota (INode[] inodes, int pos, long nsDelta, long dsDelta, INode commonAncestor)
specifier|private
specifier|static
name|void
name|verifyQuota
parameter_list|(
name|INode
index|[]
name|inodes
parameter_list|,
name|int
name|pos
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|INode
name|commonAncestor
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
name|nsDelta
operator|<=
literal|0
operator|&&
name|dsDelta
operator|<=
literal|0
condition|)
block|{
comment|// if quota is being freed or not being consumed
return|return;
block|}
comment|// check existing components in the path
for|for
control|(
name|int
name|i
init|=
operator|(
name|pos
operator|>
name|inodes
operator|.
name|length
condition|?
name|inodes
operator|.
name|length
else|:
name|pos
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|commonAncestor
operator|==
name|inodes
index|[
name|i
index|]
condition|)
block|{
comment|// Stop checking for quota when common ancestor is reached
return|return;
block|}
if|if
condition|(
name|inodes
index|[
name|i
index|]
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
comment|// a directory with quota
try|try
block|{
operator|(
operator|(
name|INodeDirectoryWithQuota
operator|)
name|inodes
index|[
name|i
index|]
operator|.
name|asDirectory
argument_list|()
operator|)
operator|.
name|verifyQuota
argument_list|(
name|nsDelta
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|e
operator|.
name|setPathName
argument_list|(
name|getFullPathName
argument_list|(
name|inodes
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Verify quota for rename operation where srcInodes[srcInodes.length-1] moves    * dstInodes[dstInodes.length-1]    *     * @param src directory from where node is being moved.    * @param dst directory to where node is moved to.    * @throws QuotaExceededException if quota limit is exceeded.    */
DECL|method|verifyQuotaForRename (INode[] src, INode[] dst)
specifier|private
name|void
name|verifyQuotaForRename
parameter_list|(
name|INode
index|[]
name|src
parameter_list|,
name|INode
index|[]
name|dst
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
operator|!
name|ready
condition|)
block|{
comment|// Do not check quota if edits log is still being processed
return|return;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|src
index|[
name|i
index|]
operator|==
name|dst
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|// src[i - 1] is the last common ancestor.
specifier|final
name|Quota
operator|.
name|Counts
name|delta
init|=
name|src
index|[
name|src
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|computeQuotaUsage
argument_list|()
decl_stmt|;
comment|// Reduce the required quota by dst that is being removed
specifier|final
name|int
name|dstIndex
init|=
name|dst
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|dst
index|[
name|dstIndex
index|]
operator|!=
literal|null
condition|)
block|{
name|delta
operator|.
name|subtract
argument_list|(
name|dst
index|[
name|dstIndex
index|]
operator|.
name|computeQuotaUsage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|verifyQuota
argument_list|(
name|dst
argument_list|,
name|dstIndex
argument_list|,
name|delta
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
name|delta
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
name|src
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/** Verify if the snapshot name is legal. */
DECL|method|verifySnapshotName (String snapshotName, String path)
name|void
name|verifySnapshotName
parameter_list|(
name|String
name|snapshotName
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|PathComponentTooLongException
block|{
if|if
condition|(
name|snapshotName
operator|.
name|contains
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Snapshot name cannot contain \""
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"\""
argument_list|)
throw|;
block|}
specifier|final
name|byte
index|[]
name|bytes
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|snapshotName
argument_list|)
decl_stmt|;
name|verifyINodeName
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|verifyMaxComponentLength
argument_list|(
name|bytes
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/** Verify if the inode name is legal. */
DECL|method|verifyINodeName (byte[] childName)
name|void
name|verifyINodeName
parameter_list|(
name|byte
index|[]
name|childName
parameter_list|)
throws|throws
name|HadoopIllegalArgumentException
block|{
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR_BYTES
argument_list|,
name|childName
argument_list|)
condition|)
block|{
name|String
name|s
init|=
literal|"\""
operator|+
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|+
literal|"\" is a reserved name."
decl_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
block|{
name|s
operator|+=
literal|"  Please rename it before upgrade."
expr_stmt|;
block|}
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
name|s
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verify child's name for fs limit.    * @throws PathComponentTooLongException child's name is too long.    */
DECL|method|verifyMaxComponentLength (byte[] childName, Object parentPath, int pos)
name|void
name|verifyMaxComponentLength
parameter_list|(
name|byte
index|[]
name|childName
parameter_list|,
name|Object
name|parentPath
parameter_list|,
name|int
name|pos
parameter_list|)
throws|throws
name|PathComponentTooLongException
block|{
if|if
condition|(
name|maxComponentLength
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|int
name|length
init|=
name|childName
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|maxComponentLength
condition|)
block|{
specifier|final
name|String
name|p
init|=
name|parentPath
operator|instanceof
name|INode
index|[]
condition|?
name|getFullPathName
argument_list|(
operator|(
name|INode
index|[]
operator|)
name|parentPath
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
else|:
operator|(
name|String
operator|)
name|parentPath
decl_stmt|;
specifier|final
name|PathComponentTooLongException
name|e
init|=
operator|new
name|PathComponentTooLongException
argument_list|(
name|maxComponentLength
argument_list|,
name|length
argument_list|,
name|p
argument_list|,
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|childName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ready
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// Do not throw if edits log is still being processed
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"ERROR in FSDirectory.verifyINodeName"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Verify children size for fs limit.    * @throws MaxDirectoryItemsExceededException too many children.    */
DECL|method|verifyMaxDirItems (INode[] pathComponents, int pos)
name|void
name|verifyMaxDirItems
parameter_list|(
name|INode
index|[]
name|pathComponents
parameter_list|,
name|int
name|pos
parameter_list|)
throws|throws
name|MaxDirectoryItemsExceededException
block|{
if|if
condition|(
name|maxDirItems
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|INodeDirectory
name|parent
init|=
name|pathComponents
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|parent
operator|.
name|getChildrenList
argument_list|(
literal|null
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>=
name|maxDirItems
condition|)
block|{
specifier|final
name|MaxDirectoryItemsExceededException
name|e
init|=
operator|new
name|MaxDirectoryItemsExceededException
argument_list|(
name|maxDirItems
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|ready
condition|)
block|{
name|e
operator|.
name|setPathName
argument_list|(
name|getFullPathName
argument_list|(
name|pathComponents
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// Do not throw if edits log is still being processed
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"FSDirectory.verifyMaxDirItems: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The same as {@link #addChild(INodesInPath, int, INode, boolean)}    * with pos = length - 1.    */
DECL|method|addLastINode (INodesInPath inodesInPath, INode inode, boolean checkQuota)
specifier|private
name|boolean
name|addLastINode
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|INode
name|inode
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|int
name|pos
init|=
name|inodesInPath
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|-
literal|1
decl_stmt|;
return|return
name|addChild
argument_list|(
name|inodesInPath
argument_list|,
name|pos
argument_list|,
name|inode
argument_list|,
name|checkQuota
argument_list|)
return|;
block|}
comment|/** Add a node child to the inodes at index pos.     * Its ancestors are stored at [0, pos-1].    * @return false if the child with this name already exists;     *         otherwise return true;    * @throw QuotaExceededException is thrown if it violates quota limit    */
DECL|method|addChild (INodesInPath iip, int pos, INode child, boolean checkQuota)
specifier|private
name|boolean
name|addChild
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|int
name|pos
parameter_list|,
name|INode
name|child
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|INode
index|[]
name|inodes
init|=
name|iip
operator|.
name|getINodes
argument_list|()
decl_stmt|;
comment|// Disallow creation of /.reserved. This may be created when loading
comment|// editlog/fsimage during upgrade since /.reserved was a valid name in older
comment|// release. This may also be called when a user tries to create a file
comment|// or directory /.reserved.
if|if
condition|(
name|pos
operator|==
literal|1
operator|&&
name|inodes
index|[
literal|0
index|]
operator|==
name|rootDir
operator|&&
name|isReservedName
argument_list|(
name|child
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"File name \""
operator|+
name|child
operator|.
name|getLocalName
argument_list|()
operator|+
literal|"\" is reserved and cannot "
operator|+
literal|"be created. If this is during upgrade change the name of the "
operator|+
literal|"existing file or directory to another name before upgrading "
operator|+
literal|"to the new release."
argument_list|)
throw|;
block|}
comment|// The filesystem limits are not really quotas, so this check may appear
comment|// odd. It's because a rename operation deletes the src, tries to add
comment|// to the dest, if that fails, re-adds the src from whence it came.
comment|// The rename code disables the quota when it's restoring to the
comment|// original location becase a quota violation would cause the the item
comment|// to go "poof".  The fs limits must be bypassed for the same reason.
if|if
condition|(
name|checkQuota
condition|)
block|{
name|verifyMaxComponentLength
argument_list|(
name|child
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|inodes
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|verifyMaxDirItems
argument_list|(
name|inodes
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
comment|// always verify inode name
name|verifyINodeName
argument_list|(
name|child
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Quota
operator|.
name|Counts
name|counts
init|=
name|child
operator|.
name|computeQuotaUsage
argument_list|()
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
name|pos
argument_list|,
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
specifier|final
name|INodeDirectory
name|parent
init|=
name|inodes
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
try|try
block|{
name|added
operator|=
name|parent
operator|.
name|addChild
argument_list|(
name|child
argument_list|,
literal|true
argument_list|,
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|updateCountNoQuotaCheck
argument_list|(
name|iip
argument_list|,
name|pos
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|updateCountNoQuotaCheck
argument_list|(
name|iip
argument_list|,
name|pos
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iip
operator|.
name|setINode
argument_list|(
name|pos
operator|-
literal|1
argument_list|,
name|child
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
name|addToInodeMap
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
DECL|method|addLastINodeNoQuotaCheck (INodesInPath inodesInPath, INode i)
specifier|private
name|boolean
name|addLastINodeNoQuotaCheck
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|INode
name|i
parameter_list|)
block|{
try|try
block|{
return|return
name|addLastINode
argument_list|(
name|inodesInPath
argument_list|,
name|i
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"FSDirectory.addChildNoQuotaCheck - unexpected"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Remove the last inode in the path from the namespace.    * Count of each ancestor with quota is also updated.    * @return -1 for failing to remove;    *          0 for removing a reference whose referred inode has other     *            reference nodes;    *>0 otherwise.     */
DECL|method|removeLastINode (final INodesInPath iip)
specifier|private
name|long
name|removeLastINode
parameter_list|(
specifier|final
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|Snapshot
name|latestSnapshot
init|=
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|last
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|INodeDirectory
name|parent
init|=
name|iip
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|removeChild
argument_list|(
name|last
argument_list|,
name|latestSnapshot
argument_list|,
name|inodeMap
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|INodeDirectory
name|newParent
init|=
name|last
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
name|newParent
condition|)
block|{
name|iip
operator|.
name|setINode
argument_list|(
operator|-
literal|2
argument_list|,
name|newParent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|last
operator|.
name|isInLatestSnapshot
argument_list|(
name|latestSnapshot
argument_list|)
condition|)
block|{
specifier|final
name|Quota
operator|.
name|Counts
name|counts
init|=
name|last
operator|.
name|computeQuotaUsage
argument_list|()
decl_stmt|;
name|updateCountNoQuotaCheck
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|getINodes
argument_list|()
operator|.
name|length
operator|-
literal|1
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
operator|-
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INodeReference
operator|.
name|tryRemoveReference
argument_list|(
name|last
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/**    */
DECL|method|normalizePath (String src)
name|String
name|normalizePath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|src
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
DECL|method|getContentSummary (String src)
name|ContentSummary
name|getContentSummary
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|targetNode
init|=
name|rootDir
operator|.
name|getNode
argument_list|(
name|srcs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|srcs
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|targetNode
operator|.
name|computeContentSummary
argument_list|()
return|;
block|}
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getINodeMap ()
specifier|public
name|INodeMap
name|getINodeMap
parameter_list|()
block|{
return|return
name|inodeMap
return|;
block|}
comment|/**    * This method is always called with writeLock of FSDirectory held.    */
DECL|method|addToInodeMap (INode inode)
specifier|public
specifier|final
name|void
name|addToInodeMap
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
if|if
condition|(
name|inode
operator|instanceof
name|INodeWithAdditionalFields
condition|)
block|{
name|inodeMap
operator|.
name|put
argument_list|(
operator|(
name|INodeWithAdditionalFields
operator|)
name|inode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method is always called with writeLock of FSDirectory held.    */
DECL|method|removeFromInodeMap (List<? extends INode> inodes)
specifier|public
specifier|final
name|void
name|removeFromInodeMap
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|INode
argument_list|>
name|inodes
parameter_list|)
block|{
if|if
condition|(
name|inodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|INode
name|inode
range|:
name|inodes
control|)
block|{
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|instanceof
name|INodeWithAdditionalFields
condition|)
block|{
name|inodeMap
operator|.
name|remove
argument_list|(
name|inode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Get the inode from inodeMap based on its inode id.    * @param id The given id    * @return The inode associated with the given id    */
DECL|method|getInode (long id)
specifier|public
name|INode
name|getInode
parameter_list|(
name|long
name|id
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|inodeMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getInodeMapSize ()
name|int
name|getInodeMapSize
parameter_list|()
block|{
return|return
name|inodeMap
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * See {@link ClientProtocol#setQuota(String, long, long)} for the contract.    * Sets quota for for a directory.    * @returns INodeDirectory if any of the quotas have changed. null other wise.    * @throws FileNotFoundException if the path does not exist.    * @throws PathIsNotDirectoryException if the path is not a directory.    * @throws QuotaExceededException if the directory tree size is     *                                greater than the given quota    * @throws UnresolvedLinkException if a symlink is encountered in src.    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|unprotectedSetQuota (String src, long nsQuota, long dsQuota)
name|INodeDirectory
name|unprotectedSetQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|PathIsNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
comment|// sanity check
if|if
condition|(
operator|(
name|nsQuota
operator|<
literal|0
operator|&&
name|nsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
operator|&&
name|nsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_RESET
operator|)
operator|||
operator|(
name|dsQuota
operator|<
literal|0
operator|&&
name|dsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
operator|&&
name|dsQuota
operator|!=
name|HdfsConstants
operator|.
name|QUOTA_RESET
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal value for nsQuota or "
operator|+
literal|"dsQuota : "
operator|+
name|nsQuota
operator|+
literal|" and "
operator|+
name|dsQuota
argument_list|)
throw|;
block|}
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|rootDir
operator|.
name|getINodesInPath4Write
argument_list|(
name|srcs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|INodeDirectory
name|dirNode
init|=
name|INodeDirectory
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|srcs
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirNode
operator|.
name|isRoot
argument_list|()
operator|&&
name|nsQuota
operator|==
name|HdfsConstants
operator|.
name|QUOTA_RESET
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot clear namespace quota on root."
argument_list|)
throw|;
block|}
else|else
block|{
comment|// a directory inode
name|long
name|oldNsQuota
init|=
name|dirNode
operator|.
name|getNsQuota
argument_list|()
decl_stmt|;
name|long
name|oldDsQuota
init|=
name|dirNode
operator|.
name|getDsQuota
argument_list|()
decl_stmt|;
if|if
condition|(
name|nsQuota
operator|==
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
condition|)
block|{
name|nsQuota
operator|=
name|oldNsQuota
expr_stmt|;
block|}
if|if
condition|(
name|dsQuota
operator|==
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
condition|)
block|{
name|dsQuota
operator|=
name|oldDsQuota
expr_stmt|;
block|}
specifier|final
name|Snapshot
name|latest
init|=
name|iip
operator|.
name|getLatestSnapshot
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirNode
operator|instanceof
name|INodeDirectoryWithQuota
condition|)
block|{
name|INodeDirectoryWithQuota
name|quotaNode
init|=
operator|(
name|INodeDirectoryWithQuota
operator|)
name|dirNode
decl_stmt|;
name|Quota
operator|.
name|Counts
name|counts
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|quotaNode
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
comment|// dirNode must be an INodeDirectoryWithSnapshot whose quota has not
comment|// been set yet
name|counts
operator|=
name|quotaNode
operator|.
name|computeQuotaUsage
argument_list|()
expr_stmt|;
block|}
comment|// a directory with quota; so set the quota to the new value
name|quotaNode
operator|.
name|setQuota
argument_list|(
name|nsQuota
argument_list|,
name|dsQuota
argument_list|)
expr_stmt|;
if|if
condition|(
name|quotaNode
operator|.
name|isQuotaSet
argument_list|()
operator|&&
name|counts
operator|!=
literal|null
condition|)
block|{
name|quotaNode
operator|.
name|setSpaceConsumed
argument_list|(
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|)
argument_list|,
name|counts
operator|.
name|get
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quotaNode
operator|.
name|isQuotaSet
argument_list|()
operator|&&
name|latest
operator|==
literal|null
condition|)
block|{
comment|// do not replace the node if the node is a snapshottable directory
comment|// without snapshots
if|if
condition|(
operator|!
operator|(
name|quotaNode
operator|instanceof
name|INodeDirectoryWithSnapshot
operator|)
condition|)
block|{
comment|// will not come here for root because root is snapshottable and
comment|// root's nsQuota is always set
return|return
name|quotaNode
operator|.
name|replaceSelf4INodeDirectory
argument_list|(
name|inodeMap
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|// a non-quota directory; so replace it with a directory with quota
return|return
name|dirNode
operator|.
name|replaceSelf4Quota
argument_list|(
name|latest
argument_list|,
name|nsQuota
argument_list|,
name|dsQuota
argument_list|,
name|inodeMap
argument_list|)
return|;
block|}
return|return
operator|(
name|oldNsQuota
operator|!=
name|nsQuota
operator|||
name|oldDsQuota
operator|!=
name|dsQuota
operator|)
condition|?
name|dirNode
else|:
literal|null
return|;
block|}
block|}
comment|/**    * See {@link ClientProtocol#setQuota(String, long, long)} for the contract.    * @throws SnapshotAccessControlException if path is in RO snapshot    * @see #unprotectedSetQuota(String, long, long)    */
DECL|method|setQuota (String src, long nsQuota, long dsQuota)
name|void
name|setQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|PathIsNotDirectoryException
throws|,
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INodeDirectory
name|dir
init|=
name|unprotectedSetQuota
argument_list|(
name|src
argument_list|,
name|nsQuota
argument_list|,
name|dsQuota
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|!=
literal|null
condition|)
block|{
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSetQuota
argument_list|(
name|src
argument_list|,
name|dir
operator|.
name|getNsQuota
argument_list|()
argument_list|,
name|dir
operator|.
name|getDsQuota
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|totalInodes ()
name|long
name|totalInodes
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|rootDir
operator|.
name|numItemsInTree
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Sets the access time on the file/directory. Logs it in the transaction log.    */
DECL|method|setTimes (String src, INode inode, long mtime, long atime, boolean force, Snapshot latest)
name|void
name|setTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|INode
name|inode
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|boolean
name|force
parameter_list|,
name|Snapshot
name|latest
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|boolean
name|status
init|=
literal|false
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|status
operator|=
name|unprotectedSetTimes
argument_list|(
name|inode
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|force
argument_list|,
name|latest
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logTimes
argument_list|(
name|src
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|unprotectedSetTimes (String src, long mtime, long atime, boolean force)
name|boolean
name|unprotectedSetTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodesInPath
name|i
init|=
name|getLastINodeInPath
argument_list|(
name|src
argument_list|)
decl_stmt|;
return|return
name|unprotectedSetTimes
argument_list|(
name|i
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|force
argument_list|,
name|i
operator|.
name|getLatestSnapshot
argument_list|()
argument_list|)
return|;
block|}
DECL|method|unprotectedSetTimes (INode inode, long mtime, long atime, boolean force, Snapshot latest)
specifier|private
name|boolean
name|unprotectedSetTimes
parameter_list|(
name|INode
name|inode
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|boolean
name|force
parameter_list|,
name|Snapshot
name|latest
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
name|boolean
name|status
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|mtime
operator|!=
operator|-
literal|1
condition|)
block|{
name|inode
operator|=
name|inode
operator|.
name|setModificationTime
argument_list|(
name|mtime
argument_list|,
name|latest
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
name|status
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|atime
operator|!=
operator|-
literal|1
condition|)
block|{
name|long
name|inodeTime
init|=
name|inode
operator|.
name|getAccessTime
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|// if the last access time update was within the last precision interval, then
comment|// no need to store access time
if|if
condition|(
name|atime
operator|<=
name|inodeTime
operator|+
name|getFSNamesystem
argument_list|()
operator|.
name|getAccessTimePrecision
argument_list|()
operator|&&
operator|!
name|force
condition|)
block|{
name|status
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|inode
operator|.
name|setAccessTime
argument_list|(
name|atime
argument_list|,
name|latest
argument_list|,
name|inodeMap
argument_list|)
expr_stmt|;
name|status
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
comment|/**    * Reset the entire namespace tree.    */
DECL|method|reset ()
name|void
name|reset
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|setReady
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|rootDir
operator|=
name|createRoot
argument_list|(
name|getFSNamesystem
argument_list|()
argument_list|)
expr_stmt|;
name|inodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|addToInodeMap
argument_list|(
name|rootDir
argument_list|)
expr_stmt|;
name|nameCache
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * create an hdfs file status from an inode    *     * @param path the local name    * @param node inode    * @param needLocation if block locations need to be included or not    * @return a file status    * @throws IOException if any error occurs    */
DECL|method|createFileStatus (byte[] path, INode node, boolean needLocation, Snapshot snapshot)
specifier|private
name|HdfsFileStatus
name|createFileStatus
parameter_list|(
name|byte
index|[]
name|path
parameter_list|,
name|INode
name|node
parameter_list|,
name|boolean
name|needLocation
parameter_list|,
name|Snapshot
name|snapshot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|needLocation
condition|)
block|{
return|return
name|createLocatedFileStatus
argument_list|(
name|path
argument_list|,
name|node
argument_list|,
name|snapshot
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createFileStatus
argument_list|(
name|path
argument_list|,
name|node
argument_list|,
name|snapshot
argument_list|)
return|;
block|}
block|}
comment|/**    * Create FileStatus by file INode     */
DECL|method|createFileStatus (byte[] path, INode node, Snapshot snapshot)
name|HdfsFileStatus
name|createFileStatus
parameter_list|(
name|byte
index|[]
name|path
parameter_list|,
name|INode
name|node
parameter_list|,
name|Snapshot
name|snapshot
parameter_list|)
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
comment|// length is zero for directories
name|short
name|replication
init|=
literal|0
decl_stmt|;
name|long
name|blocksize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isFile
argument_list|()
condition|)
block|{
specifier|final
name|INodeFile
name|fileNode
init|=
name|node
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|size
operator|=
name|fileNode
operator|.
name|computeFileSize
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|replication
operator|=
name|fileNode
operator|.
name|getFileReplication
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
block|}
name|int
name|childrenNum
init|=
name|node
operator|.
name|isDirectory
argument_list|()
condition|?
name|node
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenNum
argument_list|(
name|snapshot
argument_list|)
else|:
literal|0
decl_stmt|;
return|return
operator|new
name|HdfsFileStatus
argument_list|(
name|size
argument_list|,
name|node
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|node
operator|.
name|getModificationTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getAccessTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getFsPermission
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getUserName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getGroupName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|isSymlink
argument_list|()
condition|?
name|node
operator|.
name|asSymlink
argument_list|()
operator|.
name|getSymlink
argument_list|()
else|:
literal|null
argument_list|,
name|path
argument_list|,
name|node
operator|.
name|getId
argument_list|()
argument_list|,
name|childrenNum
argument_list|)
return|;
block|}
comment|/**    * Create FileStatus with location info by file INode    */
DECL|method|createLocatedFileStatus (byte[] path, INode node, Snapshot snapshot)
specifier|private
name|HdfsLocatedFileStatus
name|createLocatedFileStatus
parameter_list|(
name|byte
index|[]
name|path
parameter_list|,
name|INode
name|node
parameter_list|,
name|Snapshot
name|snapshot
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|hasReadLock
argument_list|()
assert|;
name|long
name|size
init|=
literal|0
decl_stmt|;
comment|// length is zero for directories
name|short
name|replication
init|=
literal|0
decl_stmt|;
name|long
name|blocksize
init|=
literal|0
decl_stmt|;
name|LocatedBlocks
name|loc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isFile
argument_list|()
condition|)
block|{
specifier|final
name|INodeFile
name|fileNode
init|=
name|node
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|size
operator|=
name|fileNode
operator|.
name|computeFileSize
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|replication
operator|=
name|fileNode
operator|.
name|getFileReplication
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
specifier|final
name|boolean
name|inSnapshot
init|=
name|snapshot
operator|!=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|isUc
init|=
name|inSnapshot
condition|?
literal|false
else|:
name|fileNode
operator|.
name|isUnderConstruction
argument_list|()
decl_stmt|;
specifier|final
name|long
name|fileSize
init|=
operator|!
name|inSnapshot
operator|&&
name|isUc
condition|?
name|fileNode
operator|.
name|computeFileSizeNotIncludingLastUcBlock
argument_list|()
else|:
name|size
decl_stmt|;
name|loc
operator|=
name|getFSNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
operator|.
name|createLocatedBlocks
argument_list|(
name|fileNode
operator|.
name|getBlocks
argument_list|()
argument_list|,
name|fileSize
argument_list|,
name|isUc
argument_list|,
literal|0L
argument_list|,
name|size
argument_list|,
literal|false
argument_list|,
name|inSnapshot
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
literal|null
condition|)
block|{
name|loc
operator|=
operator|new
name|LocatedBlocks
argument_list|()
expr_stmt|;
block|}
block|}
name|int
name|childrenNum
init|=
name|node
operator|.
name|isDirectory
argument_list|()
condition|?
name|node
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenNum
argument_list|(
name|snapshot
argument_list|)
else|:
literal|0
decl_stmt|;
name|HdfsLocatedFileStatus
name|status
init|=
operator|new
name|HdfsLocatedFileStatus
argument_list|(
name|size
argument_list|,
name|node
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|node
operator|.
name|getModificationTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getAccessTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getFsPermission
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getUserName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getGroupName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|isSymlink
argument_list|()
condition|?
name|node
operator|.
name|asSymlink
argument_list|()
operator|.
name|getSymlink
argument_list|()
else|:
literal|null
argument_list|,
name|path
argument_list|,
name|node
operator|.
name|getId
argument_list|()
argument_list|,
name|loc
argument_list|,
name|childrenNum
argument_list|)
decl_stmt|;
comment|// Set caching information for the located blocks.
if|if
condition|(
name|loc
operator|!=
literal|null
condition|)
block|{
name|CacheManager
name|cacheManager
init|=
name|namesystem
operator|.
name|getCacheManager
argument_list|()
decl_stmt|;
for|for
control|(
name|LocatedBlock
name|lb
range|:
name|loc
operator|.
name|getLocatedBlocks
argument_list|()
control|)
block|{
name|cacheManager
operator|.
name|setCachedLocations
argument_list|(
name|lb
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
comment|/**    * Add the given symbolic link to the fs. Record it in the edits log.    */
DECL|method|addSymlink (String path, String target, PermissionStatus dirPerms, boolean createParent, boolean logRetryCache)
name|INodeSymlink
name|addSymlink
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|target
parameter_list|,
name|PermissionStatus
name|dirPerms
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|boolean
name|logRetryCache
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|FileAlreadyExistsException
throws|,
name|QuotaExceededException
throws|,
name|SnapshotAccessControlException
block|{
name|waitForReady
argument_list|()
expr_stmt|;
specifier|final
name|long
name|modTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|createParent
condition|)
block|{
specifier|final
name|String
name|parent
init|=
operator|new
name|Path
argument_list|(
name|path
argument_list|)
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|mkdirs
argument_list|(
name|parent
argument_list|,
name|dirPerms
argument_list|,
literal|true
argument_list|,
name|modTime
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|String
name|userName
init|=
name|dirPerms
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|INodeSymlink
name|newNode
init|=
literal|null
decl_stmt|;
name|long
name|id
init|=
name|namesystem
operator|.
name|allocateNewInodeId
argument_list|()
decl_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|newNode
operator|=
name|unprotectedAddSymlink
argument_list|(
name|id
argument_list|,
name|path
argument_list|,
name|target
argument_list|,
name|modTime
argument_list|,
name|modTime
argument_list|,
operator|new
name|PermissionStatus
argument_list|(
name|userName
argument_list|,
literal|null
argument_list|,
name|FsPermission
operator|.
name|getDefault
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|newNode
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"DIR* addSymlink: failed to add "
operator|+
name|path
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|logSymlink
argument_list|(
name|path
argument_list|,
name|target
argument_list|,
name|modTime
argument_list|,
name|modTime
argument_list|,
name|newNode
argument_list|,
name|logRetryCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"DIR* addSymlink: "
operator|+
name|path
operator|+
literal|" is added"
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
block|}
comment|/**    * Add the specified path into the namespace. Invoked from edit log processing.    */
DECL|method|unprotectedAddSymlink (long id, String path, String target, long mtime, long atime, PermissionStatus perm)
name|INodeSymlink
name|unprotectedAddSymlink
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|path
parameter_list|,
name|String
name|target
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|PermissionStatus
name|perm
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|INodeSymlink
name|symlink
init|=
operator|new
name|INodeSymlink
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|perm
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|target
argument_list|)
decl_stmt|;
return|return
name|addINode
argument_list|(
name|path
argument_list|,
name|symlink
argument_list|)
condition|?
name|symlink
else|:
literal|null
return|;
block|}
comment|/**    * Caches frequently used file names to reuse file name objects and    * reduce heap size.    */
DECL|method|cacheName (INode inode)
name|void
name|cacheName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
comment|// Name is cached only for files
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return;
block|}
name|ByteArray
name|name
init|=
operator|new
name|ByteArray
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
decl_stmt|;
name|name
operator|=
name|nameCache
operator|.
name|put
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|inode
operator|.
name|setLocalName
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
name|nameCache
operator|.
name|reset
argument_list|()
expr_stmt|;
name|inodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Given an INode get all the path complents leading to it from the root.    * If an Inode corresponding to C is given in /A/B/C, the returned    * patch components will be {root, A, B, C}    */
DECL|method|getPathComponents (INode inode)
specifier|static
name|byte
index|[]
index|[]
name|getPathComponents
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|components
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|components
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|inode
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|components
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|inode
operator|.
name|getParent
argument_list|()
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
name|inode
operator|=
name|inode
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
name|components
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|components
operator|.
name|size
argument_list|()
index|]
index|[]
argument_list|)
return|;
block|}
comment|/**    * @return path components for reserved path, else null.    */
DECL|method|getPathComponentsForReservedPath (String src)
specifier|static
name|byte
index|[]
index|[]
name|getPathComponentsForReservedPath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
operator|!
name|isReservedName
argument_list|(
name|src
argument_list|)
condition|?
literal|null
else|:
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
return|;
block|}
comment|/**    * Resolve the path of /.reserved/.inodes/<inodeid>/... to a regular path    *     * @param src path that is being processed    * @param pathComponents path components corresponding to the path    * @param fsd FSDirectory    * @return if the path indicates an inode, return path after replacing upto    *<inodeid> with the corresponding path of the inode, else the path    *         in {@code src} as is.    * @throws FileNotFoundException if inodeid is invalid    */
DECL|method|resolvePath (String src, byte[][] pathComponents, FSDirectory fsd)
specifier|static
name|String
name|resolvePath
parameter_list|(
name|String
name|src
parameter_list|,
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|,
name|FSDirectory
name|fsd
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
if|if
condition|(
name|pathComponents
operator|==
literal|null
operator|||
name|pathComponents
operator|.
name|length
operator|<=
literal|3
condition|)
block|{
return|return
name|src
return|;
block|}
comment|// Not /.reserved/.inodes
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|DOT_RESERVED
argument_list|,
name|pathComponents
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|DOT_INODES
argument_list|,
name|pathComponents
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|// Not .inodes path
return|return
name|src
return|;
block|}
specifier|final
name|String
name|inodeId
init|=
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|long
name|id
init|=
literal|0
decl_stmt|;
try|try
block|{
name|id
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Invalid inode path: "
operator|+
name|src
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
operator|&&
name|pathComponents
operator|.
name|length
operator|==
literal|4
condition|)
block|{
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
name|INode
name|inode
init|=
name|fsd
operator|.
name|getInode
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File for given inode path does not exist: "
operator|+
name|src
argument_list|)
throw|;
block|}
comment|// Handle single ".." for NFS lookup support.
if|if
condition|(
operator|(
name|pathComponents
operator|.
name|length
operator|>
literal|4
operator|)
operator|&&
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
literal|4
index|]
argument_list|)
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
condition|)
block|{
name|INode
name|parent
init|=
name|inode
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
operator|||
name|parent
operator|.
name|getId
argument_list|()
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|)
block|{
comment|// inode is root, or its parent is root.
return|return
name|Path
operator|.
name|SEPARATOR
return|;
block|}
else|else
block|{
return|return
name|parent
operator|.
name|getFullPathName
argument_list|()
return|;
block|}
block|}
name|StringBuilder
name|path
init|=
name|id
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|?
operator|new
name|StringBuilder
argument_list|()
else|:
operator|new
name|StringBuilder
argument_list|(
name|inode
operator|.
name|getFullPathName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|4
init|;
name|i
operator|<
name|pathComponents
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|path
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Resolved path is "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|path
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Check if a given inode name is reserved */
DECL|method|isReservedName (INode inode)
specifier|public
specifier|static
name|boolean
name|isReservedName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
return|return
name|CHECK_RESERVED_FILE_NAMES
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|DOT_RESERVED
argument_list|)
return|;
block|}
comment|/** Check if a given path is reserved */
DECL|method|isReservedName (String src)
specifier|public
specifier|static
name|boolean
name|isReservedName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|src
operator|.
name|startsWith
argument_list|(
name|DOT_RESERVED_PATH_PREFIX
argument_list|)
return|;
block|}
block|}
end_class

end_unit

