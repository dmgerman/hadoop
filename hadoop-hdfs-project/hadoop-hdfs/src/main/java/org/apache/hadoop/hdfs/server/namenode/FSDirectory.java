begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|key
operator|.
name|KeyProviderCryptoExtension
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|InvalidPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnresolvedLinkException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|XAttr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|MaxDirectoryItemsExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSLimitException
operator|.
name|PathComponentTooLongException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotAccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnresolvedPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HdfsProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|HdfsProtos
operator|.
name|ReencryptionInfoProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|PBHelperClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoStriped
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockStoragePolicySuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapUpdateInfo
operator|.
name|UpdatedReplicationInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|sps
operator|.
name|StoragePolicySatisfyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|EnumCounters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ReadOnlyList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ForkJoinPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RecursiveAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|FS_PROTECTED_DIRECTORIES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACCESSTIME_PRECISION_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACCESSTIME_PRECISION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_QUOTA_BY_STORAGETYPE_ENABLED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_QUOTA_BY_STORAGETYPE_ENABLED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|CRYPTO_XATTR_ENCRYPTION_ZONE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|SECURITY_XATTR_UNREADABLE_BY_SUPERUSER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|XATTR_SATISFY_STORAGE_POLICY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
operator|.
name|CURRENT_STATE_ID
import|;
end_import

begin_comment
comment|/**  * Both FSDirectory and FSNamesystem manage the state of the namespace.  * FSDirectory is a pure in-memory data structure, all of whose operations  * happen entirely in memory. In contrast, FSNamesystem persists the operations  * to the disk.  * @see org.apache.hadoop.hdfs.server.namenode.FSNamesystem  **/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|FSDirectory
specifier|public
class|class
name|FSDirectory
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|createRoot (FSNamesystem namesystem)
specifier|private
specifier|static
name|INodeDirectory
name|createRoot
parameter_list|(
name|FSNamesystem
name|namesystem
parameter_list|)
block|{
specifier|final
name|INodeDirectory
name|r
init|=
operator|new
name|INodeDirectory
argument_list|(
name|INodeId
operator|.
name|ROOT_INODE_ID
argument_list|,
name|INodeDirectory
operator|.
name|ROOT_NAME
argument_list|,
name|namesystem
operator|.
name|createFsOwnerPermissions
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0755
argument_list|)
argument_list|)
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
name|r
operator|.
name|addDirectoryWithQuotaFeature
argument_list|(
operator|new
name|DirectoryWithQuotaFeature
operator|.
name|Builder
argument_list|()
operator|.
name|nameSpaceQuota
argument_list|(
name|DirectoryWithQuotaFeature
operator|.
name|DEFAULT_NAMESPACE_QUOTA
argument_list|)
operator|.
name|storageSpaceQuota
argument_list|(
name|DirectoryWithQuotaFeature
operator|.
name|DEFAULT_STORAGE_SPACE_QUOTA
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|addSnapshottableFeature
argument_list|()
expr_stmt|;
name|r
operator|.
name|setSnapshotQuota
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|field|CHECK_RESERVED_FILE_NAMES
specifier|static
name|boolean
name|CHECK_RESERVED_FILE_NAMES
init|=
literal|true
decl_stmt|;
DECL|field|DOT_RESERVED_STRING
specifier|public
specifier|final
specifier|static
name|String
name|DOT_RESERVED_STRING
init|=
name|HdfsConstants
operator|.
name|DOT_RESERVED_STRING
decl_stmt|;
DECL|field|DOT_RESERVED_PATH_PREFIX
specifier|public
specifier|final
specifier|static
name|String
name|DOT_RESERVED_PATH_PREFIX
init|=
name|HdfsConstants
operator|.
name|DOT_RESERVED_PATH_PREFIX
decl_stmt|;
DECL|field|DOT_RESERVED
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|DOT_RESERVED
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|DOT_RESERVED_STRING
argument_list|)
decl_stmt|;
DECL|field|RAW_STRING
specifier|private
specifier|final
specifier|static
name|String
name|RAW_STRING
init|=
literal|"raw"
decl_stmt|;
DECL|field|RAW
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|RAW
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|RAW_STRING
argument_list|)
decl_stmt|;
DECL|field|DOT_INODES_STRING
specifier|public
specifier|final
specifier|static
name|String
name|DOT_INODES_STRING
init|=
name|HdfsConstants
operator|.
name|DOT_INODES_STRING
decl_stmt|;
DECL|field|DOT_INODES
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|DOT_INODES
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
name|DOT_INODES_STRING
argument_list|)
decl_stmt|;
DECL|field|DOT_DOT
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|DOT_DOT
init|=
name|DFSUtil
operator|.
name|string2Bytes
argument_list|(
literal|".."
argument_list|)
decl_stmt|;
DECL|field|DOT_RESERVED_STATUS
specifier|public
specifier|final
specifier|static
name|HdfsFileStatus
name|DOT_RESERVED_STATUS
init|=
operator|new
name|HdfsFileStatus
operator|.
name|Builder
argument_list|()
operator|.
name|isdir
argument_list|(
literal|true
argument_list|)
operator|.
name|perm
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|01770
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
DECL|field|DOT_SNAPSHOT_DIR_STATUS
specifier|public
specifier|final
specifier|static
name|HdfsFileStatus
name|DOT_SNAPSHOT_DIR_STATUS
init|=
operator|new
name|HdfsFileStatus
operator|.
name|Builder
argument_list|()
operator|.
name|isdir
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
DECL|field|rootDir
name|INodeDirectory
name|rootDir
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|skipQuotaCheck
specifier|private
specifier|volatile
name|boolean
name|skipQuotaCheck
init|=
literal|false
decl_stmt|;
comment|//skip while consuming edits
DECL|field|maxComponentLength
specifier|private
specifier|final
name|int
name|maxComponentLength
decl_stmt|;
DECL|field|maxDirItems
specifier|private
specifier|final
name|int
name|maxDirItems
decl_stmt|;
DECL|field|lsLimit
specifier|private
specifier|final
name|int
name|lsLimit
decl_stmt|;
comment|// max list limit
DECL|field|contentCountLimit
specifier|private
specifier|final
name|int
name|contentCountLimit
decl_stmt|;
comment|// max content summary counts per run
DECL|field|contentSleepMicroSec
specifier|private
specifier|final
name|long
name|contentSleepMicroSec
decl_stmt|;
DECL|field|inodeMap
specifier|private
specifier|final
name|INodeMap
name|inodeMap
decl_stmt|;
comment|// Synchronized by dirLock
DECL|field|yieldCount
specifier|private
name|long
name|yieldCount
init|=
literal|0
decl_stmt|;
comment|// keep track of lock yield count.
DECL|field|quotaInitThreads
specifier|private
name|int
name|quotaInitThreads
decl_stmt|;
DECL|field|inodeXAttrsLimit
specifier|private
specifier|final
name|int
name|inodeXAttrsLimit
decl_stmt|;
comment|//inode xattrs max limit
comment|// A set of directories that have been protected using the
comment|// dfs.namenode.protected.directories setting. These directories cannot
comment|// be deleted unless they are empty.
comment|//
comment|// Each entry in this set must be a normalized path.
DECL|field|protectedDirectories
specifier|private
specifier|volatile
name|SortedSet
argument_list|<
name|String
argument_list|>
name|protectedDirectories
decl_stmt|;
comment|// lock to protect the directory and BlockMap
DECL|field|dirLock
specifier|private
specifier|final
name|ReentrantReadWriteLock
name|dirLock
decl_stmt|;
DECL|field|isPermissionEnabled
specifier|private
specifier|final
name|boolean
name|isPermissionEnabled
decl_stmt|;
DECL|field|isPermissionContentSummarySubAccess
specifier|private
specifier|final
name|boolean
name|isPermissionContentSummarySubAccess
decl_stmt|;
comment|/**    * Support for ACLs is controlled by a configuration flag. If the    * configuration flag is false, then the NameNode will reject all    * ACL-related operations.    */
DECL|field|aclsEnabled
specifier|private
specifier|final
name|boolean
name|aclsEnabled
decl_stmt|;
comment|/**    * Support for POSIX ACL inheritance. Not final for testing purpose.    */
DECL|field|posixAclInheritanceEnabled
specifier|private
name|boolean
name|posixAclInheritanceEnabled
decl_stmt|;
DECL|field|xattrsEnabled
specifier|private
specifier|final
name|boolean
name|xattrsEnabled
decl_stmt|;
DECL|field|xattrMaxSize
specifier|private
specifier|final
name|int
name|xattrMaxSize
decl_stmt|;
comment|// precision of access times.
DECL|field|accessTimePrecision
specifier|private
specifier|final
name|long
name|accessTimePrecision
decl_stmt|;
comment|// whether setStoragePolicy is allowed.
DECL|field|storagePolicyEnabled
specifier|private
specifier|final
name|boolean
name|storagePolicyEnabled
decl_stmt|;
comment|// whether quota by storage type is allowed
DECL|field|quotaByStorageTypeEnabled
specifier|private
specifier|final
name|boolean
name|quotaByStorageTypeEnabled
decl_stmt|;
DECL|field|fsOwnerShortUserName
specifier|private
specifier|final
name|String
name|fsOwnerShortUserName
decl_stmt|;
DECL|field|supergroup
specifier|private
specifier|final
name|String
name|supergroup
decl_stmt|;
DECL|field|inodeId
specifier|private
specifier|final
name|INodeId
name|inodeId
decl_stmt|;
DECL|field|editLog
specifier|private
specifier|final
name|FSEditLog
name|editLog
decl_stmt|;
DECL|field|reservedStatuses
specifier|private
name|HdfsFileStatus
index|[]
name|reservedStatuses
decl_stmt|;
DECL|field|attributeProvider
specifier|private
name|INodeAttributeProvider
name|attributeProvider
decl_stmt|;
comment|// A HashSet of principals of users for whom the external attribute provider
comment|// will be bypassed
DECL|field|usersToBypassExtAttrProvider
specifier|private
name|HashSet
argument_list|<
name|String
argument_list|>
name|usersToBypassExtAttrProvider
init|=
literal|null
decl_stmt|;
DECL|method|setINodeAttributeProvider (INodeAttributeProvider provider)
specifier|public
name|void
name|setINodeAttributeProvider
parameter_list|(
name|INodeAttributeProvider
name|provider
parameter_list|)
block|{
name|attributeProvider
operator|=
name|provider
expr_stmt|;
block|}
comment|// utility methods to acquire and release read lock and write lock
DECL|method|readLock ()
name|void
name|readLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|readUnlock ()
name|void
name|readUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeLock ()
name|void
name|writeLock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
DECL|method|writeUnlock ()
name|void
name|writeUnlock
parameter_list|()
block|{
name|this
operator|.
name|dirLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|method|hasWriteLock ()
name|boolean
name|hasWriteLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|isWriteLockedByCurrentThread
argument_list|()
return|;
block|}
DECL|method|hasReadLock ()
name|boolean
name|hasReadLock
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getReadHoldCount
argument_list|()
operator|>
literal|0
operator|||
name|hasWriteLock
argument_list|()
return|;
block|}
DECL|method|getReadHoldCount ()
specifier|public
name|int
name|getReadHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getReadHoldCount
argument_list|()
return|;
block|}
DECL|method|getWriteHoldCount ()
specifier|public
name|int
name|getWriteHoldCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|dirLock
operator|.
name|getWriteHoldCount
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|field|ezManager
specifier|public
specifier|final
name|EncryptionZoneManager
name|ezManager
decl_stmt|;
comment|/**    * Caches frequently used file names used in {@link INode} to reuse     * byte[] objects and reduce heap usage.    */
DECL|field|nameCache
specifier|private
specifier|final
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
name|nameCache
decl_stmt|;
comment|// used to specify path resolution type. *_LINK will return symlinks instead
comment|// of throwing an unresolved exception
DECL|enum|DirOp
specifier|public
enum|enum
name|DirOp
block|{
DECL|enumConstant|READ
name|READ
block|,
DECL|enumConstant|READ_LINK
name|READ_LINK
block|,
DECL|enumConstant|WRITE
name|WRITE
block|,
comment|// disallows snapshot paths.
DECL|enumConstant|WRITE_LINK
name|WRITE_LINK
block|,
DECL|enumConstant|CREATE
name|CREATE
block|,
comment|// like write, but also blocks invalid path names.
DECL|enumConstant|CREATE_LINK
name|CREATE_LINK
block|;   }
empty_stmt|;
DECL|method|FSDirectory (FSNamesystem ns, Configuration conf)
name|FSDirectory
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|dirLock
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// fair
name|this
operator|.
name|inodeId
operator|=
operator|new
name|INodeId
argument_list|()
expr_stmt|;
name|rootDir
operator|=
name|createRoot
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|inodeMap
operator|=
name|INodeMap
operator|.
name|newInstance
argument_list|(
name|rootDir
argument_list|)
expr_stmt|;
name|this
operator|.
name|isPermissionEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|isPermissionContentSummarySubAccess
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_CONTENT_SUMMARY_SUBACCESS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_CONTENT_SUMMARY_SUBACCESS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsOwnerShortUserName
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
name|this
operator|.
name|supergroup
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|aclsEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACLS_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_ACLS_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"ACLs enabled? "
operator|+
name|aclsEnabled
argument_list|)
expr_stmt|;
name|this
operator|.
name|posixAclInheritanceEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_POSIX_ACL_INHERITANCE_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_POSIX_ACL_INHERITANCE_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"POSIX ACL inheritance enabled? "
operator|+
name|posixAclInheritanceEnabled
argument_list|)
expr_stmt|;
name|this
operator|.
name|xattrsEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_XATTRS_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_XATTRS_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"XAttrs enabled? "
operator|+
name|xattrsEnabled
argument_list|)
expr_stmt|;
name|this
operator|.
name|xattrMaxSize
operator|=
operator|(
name|int
operator|)
name|conf
operator|.
name|getLongBytes
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTR_SIZE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTR_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|xattrMaxSize
operator|>
literal|0
argument_list|,
literal|"The maximum size of an xattr should be> 0: (%s)."
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTR_SIZE_KEY
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|xattrMaxSize
operator|<=
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTR_SIZE_HARD_LIMIT
argument_list|,
literal|"The maximum size of an xattr should be<= maximum size"
operator|+
literal|" hard limit "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTR_SIZE_HARD_LIMIT
operator|+
literal|": (%s)."
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTR_SIZE_KEY
argument_list|)
expr_stmt|;
name|this
operator|.
name|accessTimePrecision
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_ACCESSTIME_PRECISION_KEY
argument_list|,
name|DFS_NAMENODE_ACCESSTIME_PRECISION_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|storagePolicyEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_STORAGE_POLICY_ENABLED_KEY
argument_list|,
name|DFS_STORAGE_POLICY_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|quotaByStorageTypeEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_QUOTA_BY_STORAGETYPE_ENABLED_KEY
argument_list|,
name|DFS_QUOTA_BY_STORAGETYPE_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|int
name|configuredLimit
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
argument_list|)
decl_stmt|;
name|this
operator|.
name|lsLimit
operator|=
name|configuredLimit
operator|>
literal|0
condition|?
name|configuredLimit
else|:
name|DFSConfigKeys
operator|.
name|DFS_LIST_LIMIT_DEFAULT
expr_stmt|;
name|this
operator|.
name|contentCountLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CONTENT_SUMMARY_LIMIT_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CONTENT_SUMMARY_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|contentSleepMicroSec
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_CONTENT_SUMMARY_SLEEP_MICROSEC_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_CONTENT_SUMMARY_SLEEP_MICROSEC_DEFAULT
argument_list|)
expr_stmt|;
comment|// filesystem limits
name|this
operator|.
name|maxComponentLength
operator|=
operator|(
name|int
operator|)
name|conf
operator|.
name|getLongBytes
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_COMPONENT_LENGTH_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxDirItems
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|inodeXAttrsLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTRS_PER_INODE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTRS_PER_INODE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|protectedDirectories
operator|=
name|parseProtectedDirectories
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|this
operator|.
name|inodeXAttrsLimit
operator|>=
literal|0
argument_list|,
literal|"Cannot set a negative limit on the number of xattrs per inode (%s)."
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_XATTRS_PER_INODE_KEY
argument_list|)
expr_stmt|;
comment|// We need a maximum maximum because by default, PB limits message sizes
comment|// to 64MB. This means we can only store approximately 6.7 million entries
comment|// per directory, but let's use 6.4 million for some safety.
specifier|final
name|int
name|MAX_DIR_ITEMS
init|=
literal|64
operator|*
literal|100
operator|*
literal|1000
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|maxDirItems
operator|>
literal|0
operator|&&
name|maxDirItems
operator|<=
name|MAX_DIR_ITEMS
argument_list|,
literal|"Cannot set "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAX_DIRECTORY_ITEMS_KEY
operator|+
literal|" to a value less than 1 or greater than "
operator|+
name|MAX_DIR_ITEMS
argument_list|)
expr_stmt|;
name|int
name|threshold
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_CACHE_THRESHOLD_DEFAULT
argument_list|)
decl_stmt|;
name|NameNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Caching file names occurring more than "
operator|+
name|threshold
operator|+
literal|" times"
argument_list|)
expr_stmt|;
name|nameCache
operator|=
operator|new
name|NameCache
argument_list|<
name|ByteArray
argument_list|>
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|namesystem
operator|=
name|ns
expr_stmt|;
name|this
operator|.
name|editLog
operator|=
name|ns
operator|.
name|getEditLog
argument_list|()
expr_stmt|;
name|ezManager
operator|=
operator|new
name|EncryptionZoneManager
argument_list|(
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|quotaInitThreads
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_QUOTA_INIT_THREADS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_QUOTA_INIT_THREADS_DEFAULT
argument_list|)
expr_stmt|;
name|initUsersToBypassExtProvider
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|initUsersToBypassExtProvider (Configuration conf)
specifier|private
name|void
name|initUsersToBypassExtProvider
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
index|[]
name|bypassUsers
init|=
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_INODE_ATTRIBUTES_PROVIDER_BYPASS_USERS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_INODE_ATTRIBUTES_PROVIDER_BYPASS_USERS_DEFAULT
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bypassUsers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|tmp
init|=
name|bypassUsers
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|usersToBypassExtAttrProvider
operator|==
literal|null
condition|)
block|{
name|usersToBypassExtAttrProvider
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Add user "
operator|+
name|tmp
operator|+
literal|" to the list that will bypass external"
operator|+
literal|" attribute provider."
argument_list|)
expr_stmt|;
name|usersToBypassExtAttrProvider
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check if a given user is configured to bypass external attribute provider.    * @param user user principal    * @return true if the user is to bypass external attribute provider    */
DECL|method|isUserBypassingExtAttrProvider (final String user)
specifier|private
name|boolean
name|isUserBypassingExtAttrProvider
parameter_list|(
specifier|final
name|String
name|user
parameter_list|)
block|{
return|return
operator|(
name|usersToBypassExtAttrProvider
operator|!=
literal|null
operator|)
operator|&&
name|usersToBypassExtAttrProvider
operator|.
name|contains
argument_list|(
name|user
argument_list|)
return|;
block|}
comment|/**    * Return attributeProvider or null if ugi is to bypass attributeProvider.    * @param ugi    * @return configured attributeProvider or null    */
DECL|method|getUserFilteredAttributeProvider ( UserGroupInformation ugi)
specifier|private
name|INodeAttributeProvider
name|getUserFilteredAttributeProvider
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
if|if
condition|(
name|attributeProvider
operator|==
literal|null
operator|||
operator|(
name|ugi
operator|!=
literal|null
operator|&&
name|isUserBypassingExtAttrProvider
argument_list|(
name|ugi
operator|.
name|getUserName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|attributeProvider
return|;
block|}
comment|/**    * Get HdfsFileStatuses of the reserved paths: .inodes and raw.    *    * @return Array of HdfsFileStatus    */
DECL|method|getReservedStatuses ()
name|HdfsFileStatus
index|[]
name|getReservedStatuses
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|reservedStatuses
argument_list|,
literal|"reservedStatuses should "
operator|+
literal|" not be null. It is populated when FSNamesystem loads FS image."
operator|+
literal|" It has to be set at this time instead of initialization time"
operator|+
literal|" because CTime is loaded during FSNamesystem#loadFromDisk."
argument_list|)
expr_stmt|;
return|return
name|reservedStatuses
return|;
block|}
comment|/**    * Create HdfsFileStatuses of the reserved paths: .inodes and raw.    * These statuses are solely for listing purpose. All other operations    * on the reserved dirs are disallowed.    * Operations on sub directories are resolved by    * {@link FSDirectory#resolvePath(String, byte[][], FSDirectory)}    * and conducted directly, without the need to check the reserved dirs.    *    * This method should only be invoked once during namenode initialization.    *    * @param cTime CTime of the file system    * @return Array of HdfsFileStatus    */
DECL|method|createReservedStatuses (long cTime)
name|void
name|createReservedStatuses
parameter_list|(
name|long
name|cTime
parameter_list|)
block|{
name|HdfsFileStatus
name|inodes
init|=
operator|new
name|HdfsFileStatus
operator|.
name|Builder
argument_list|()
operator|.
name|isdir
argument_list|(
literal|true
argument_list|)
operator|.
name|mtime
argument_list|(
name|cTime
argument_list|)
operator|.
name|atime
argument_list|(
name|cTime
argument_list|)
operator|.
name|perm
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0770
argument_list|)
argument_list|)
operator|.
name|group
argument_list|(
name|supergroup
argument_list|)
operator|.
name|path
argument_list|(
name|DOT_INODES
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HdfsFileStatus
name|raw
init|=
operator|new
name|HdfsFileStatus
operator|.
name|Builder
argument_list|()
operator|.
name|isdir
argument_list|(
literal|true
argument_list|)
operator|.
name|mtime
argument_list|(
name|cTime
argument_list|)
operator|.
name|atime
argument_list|(
name|cTime
argument_list|)
operator|.
name|perm
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0770
argument_list|)
argument_list|)
operator|.
name|group
argument_list|(
name|supergroup
argument_list|)
operator|.
name|path
argument_list|(
name|RAW
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|reservedStatuses
operator|=
operator|new
name|HdfsFileStatus
index|[]
block|{
name|inodes
block|,
name|raw
block|}
expr_stmt|;
block|}
DECL|method|getFSNamesystem ()
name|FSNamesystem
name|getFSNamesystem
parameter_list|()
block|{
return|return
name|namesystem
return|;
block|}
comment|/**    * Parse configuration setting dfs.namenode.protected.directories to    * retrieve the set of protected directories.    *    * @param conf    * @return a TreeSet    */
annotation|@
name|VisibleForTesting
DECL|method|parseProtectedDirectories (Configuration conf)
specifier|static
name|SortedSet
argument_list|<
name|String
argument_list|>
name|parseProtectedDirectories
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|parseProtectedDirectories
argument_list|(
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|FS_PROTECTED_DIRECTORIES
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Parse configuration setting dfs.namenode.protected.directories to retrieve    * the set of protected directories.    *    * @param protectedDirsString    *          a comma separated String representing a bunch of paths.    * @return a TreeSet    */
annotation|@
name|VisibleForTesting
DECL|method|parseProtectedDirectories ( final String protectedDirsString)
specifier|static
name|SortedSet
argument_list|<
name|String
argument_list|>
name|parseProtectedDirectories
parameter_list|(
specifier|final
name|String
name|protectedDirsString
parameter_list|)
block|{
return|return
name|parseProtectedDirectories
argument_list|(
name|StringUtils
operator|.
name|getTrimmedStringCollection
argument_list|(
name|protectedDirsString
argument_list|)
argument_list|)
return|;
block|}
DECL|method|parseProtectedDirectories ( final Collection<String> protectedDirs)
specifier|private
specifier|static
name|SortedSet
argument_list|<
name|String
argument_list|>
name|parseProtectedDirectories
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|protectedDirs
parameter_list|)
block|{
comment|// Normalize each input path to guard against administrator error.
return|return
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|normalizePaths
argument_list|(
name|protectedDirs
argument_list|,
name|FS_PROTECTED_DIRECTORIES
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getProtectedDirectories ()
name|SortedSet
argument_list|<
name|String
argument_list|>
name|getProtectedDirectories
parameter_list|()
block|{
return|return
name|protectedDirectories
return|;
block|}
comment|/**    * Set directories that cannot be removed unless empty, even by an    * administrator.    *    * @param protectedDirsString    *          comma separated list of protected directories    */
DECL|method|setProtectedDirectories (String protectedDirsString)
name|String
name|setProtectedDirectories
parameter_list|(
name|String
name|protectedDirsString
parameter_list|)
block|{
if|if
condition|(
name|protectedDirsString
operator|==
literal|null
condition|)
block|{
name|protectedDirectories
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|protectedDirectories
operator|=
name|parseProtectedDirectories
argument_list|(
name|protectedDirsString
argument_list|)
expr_stmt|;
block|}
return|return
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|skipNulls
argument_list|()
operator|.
name|join
argument_list|(
name|protectedDirectories
argument_list|)
return|;
block|}
DECL|method|getBlockManager ()
name|BlockManager
name|getBlockManager
parameter_list|()
block|{
return|return
name|getFSNamesystem
argument_list|()
operator|.
name|getBlockManager
argument_list|()
return|;
block|}
DECL|method|getProvider ()
name|KeyProviderCryptoExtension
name|getProvider
parameter_list|()
block|{
return|return
name|getFSNamesystem
argument_list|()
operator|.
name|getProvider
argument_list|()
return|;
block|}
comment|/** @return the root directory inode. */
DECL|method|getRoot ()
specifier|public
name|INodeDirectory
name|getRoot
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
DECL|method|getBlockStoragePolicySuite ()
specifier|public
name|BlockStoragePolicySuite
name|getBlockStoragePolicySuite
parameter_list|()
block|{
return|return
name|getBlockManager
argument_list|()
operator|.
name|getStoragePolicySuite
argument_list|()
return|;
block|}
DECL|method|isPermissionEnabled ()
name|boolean
name|isPermissionEnabled
parameter_list|()
block|{
return|return
name|isPermissionEnabled
return|;
block|}
DECL|method|isAclsEnabled ()
name|boolean
name|isAclsEnabled
parameter_list|()
block|{
return|return
name|aclsEnabled
return|;
block|}
DECL|method|isPermissionContentSummarySubAccess ()
name|boolean
name|isPermissionContentSummarySubAccess
parameter_list|()
block|{
return|return
name|isPermissionContentSummarySubAccess
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|isPosixAclInheritanceEnabled ()
specifier|public
name|boolean
name|isPosixAclInheritanceEnabled
parameter_list|()
block|{
return|return
name|posixAclInheritanceEnabled
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setPosixAclInheritanceEnabled ( boolean posixAclInheritanceEnabled)
specifier|public
name|void
name|setPosixAclInheritanceEnabled
parameter_list|(
name|boolean
name|posixAclInheritanceEnabled
parameter_list|)
block|{
name|this
operator|.
name|posixAclInheritanceEnabled
operator|=
name|posixAclInheritanceEnabled
expr_stmt|;
block|}
DECL|method|isXattrsEnabled ()
name|boolean
name|isXattrsEnabled
parameter_list|()
block|{
return|return
name|xattrsEnabled
return|;
block|}
DECL|method|getXattrMaxSize ()
name|int
name|getXattrMaxSize
parameter_list|()
block|{
return|return
name|xattrMaxSize
return|;
block|}
DECL|method|isStoragePolicyEnabled ()
name|boolean
name|isStoragePolicyEnabled
parameter_list|()
block|{
return|return
name|storagePolicyEnabled
return|;
block|}
DECL|method|isAccessTimeSupported ()
name|boolean
name|isAccessTimeSupported
parameter_list|()
block|{
return|return
name|accessTimePrecision
operator|>
literal|0
return|;
block|}
DECL|method|getAccessTimePrecision ()
name|long
name|getAccessTimePrecision
parameter_list|()
block|{
return|return
name|accessTimePrecision
return|;
block|}
DECL|method|isQuotaByStorageTypeEnabled ()
name|boolean
name|isQuotaByStorageTypeEnabled
parameter_list|()
block|{
return|return
name|quotaByStorageTypeEnabled
return|;
block|}
DECL|method|getLsLimit ()
name|int
name|getLsLimit
parameter_list|()
block|{
return|return
name|lsLimit
return|;
block|}
DECL|method|getContentCountLimit ()
name|int
name|getContentCountLimit
parameter_list|()
block|{
return|return
name|contentCountLimit
return|;
block|}
DECL|method|getContentSleepMicroSec ()
name|long
name|getContentSleepMicroSec
parameter_list|()
block|{
return|return
name|contentSleepMicroSec
return|;
block|}
DECL|method|getInodeXAttrsLimit ()
name|int
name|getInodeXAttrsLimit
parameter_list|()
block|{
return|return
name|inodeXAttrsLimit
return|;
block|}
DECL|method|getEditLog ()
name|FSEditLog
name|getEditLog
parameter_list|()
block|{
return|return
name|editLog
return|;
block|}
comment|/**    * Shutdown the filestore    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{}
DECL|method|markNameCacheInitialized ()
name|void
name|markNameCacheInitialized
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|nameCache
operator|.
name|initialized
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|shouldSkipQuotaChecks ()
name|boolean
name|shouldSkipQuotaChecks
parameter_list|()
block|{
return|return
name|skipQuotaCheck
return|;
block|}
comment|/** Enable quota verification */
DECL|method|enableQuotaChecks ()
name|void
name|enableQuotaChecks
parameter_list|()
block|{
name|skipQuotaCheck
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Disable quota verification */
DECL|method|disableQuotaChecks ()
name|void
name|disableQuotaChecks
parameter_list|()
block|{
name|skipQuotaCheck
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Resolves a given path into an INodesInPath.  All ancestor inodes that    * exist are validated as traversable directories.  Symlinks in the ancestry    * will generate an UnresolvedLinkException.  The returned IIP will be an    * accessible path that also passed additional sanity checks based on how    * the path will be used as specified by the DirOp.    *   READ:   Expands reserved paths and performs permission checks    *           during traversal.  Raw paths are only accessible by a superuser.    *   WRITE:  In addition to READ checks, ensures the path is not a    *           snapshot path.    *   CREATE: In addition to WRITE checks, ensures path does not contain    *           illegal character sequences.    *    * @param pc  A permission checker for traversal checks.  Pass null for    *            no permission checks.    * @param src The path to resolve.    * @param dirOp The {@link DirOp} that controls additional checks.    * @return if the path indicates an inode, return path after replacing up to    *        {@code<inodeid>} with the corresponding path of the inode, else    *        the path in {@code src} as is. If the path refers to a path in    *        the "raw" directory, return the non-raw pathname.    * @throws FileNotFoundException    * @throws AccessControlException    * @throws ParentNotDirectoryException    * @throws UnresolvedLinkException    */
annotation|@
name|VisibleForTesting
DECL|method|resolvePath (FSPermissionChecker pc, String src, DirOp dirOp)
specifier|public
name|INodesInPath
name|resolvePath
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|String
name|src
parameter_list|,
name|DirOp
name|dirOp
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|AccessControlException
throws|,
name|ParentNotDirectoryException
block|{
name|boolean
name|isCreate
init|=
operator|(
name|dirOp
operator|==
name|DirOp
operator|.
name|CREATE
operator|||
name|dirOp
operator|==
name|DirOp
operator|.
name|CREATE_LINK
operator|)
decl_stmt|;
comment|// prevent creation of new invalid paths
if|if
condition|(
name|isCreate
operator|&&
operator|!
name|DFSUtil
operator|.
name|isValidName
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
literal|"Invalid file name: "
operator|+
name|src
argument_list|)
throw|;
block|}
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|boolean
name|isRaw
init|=
name|isReservedRawName
argument_list|(
name|components
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPermissionEnabled
operator|&&
name|pc
operator|!=
literal|null
operator|&&
name|isRaw
condition|)
block|{
switch|switch
condition|(
name|dirOp
condition|)
block|{
case|case
name|READ_LINK
case|:
case|case
name|READ
case|:
break|break;
default|default:
name|pc
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|components
operator|=
name|resolveComponents
argument_list|(
name|components
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|INodesInPath
name|iip
init|=
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|components
argument_list|,
name|isRaw
argument_list|)
decl_stmt|;
comment|// verify all ancestors are dirs and traversable.  note that only
comment|// methods that create new namespace items have the signature to throw
comment|// PNDE
try|try
block|{
name|checkTraverse
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|dirOp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParentNotDirectoryException
name|pnde
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isCreate
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
name|pnde
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
name|pnde
throw|;
block|}
return|return
name|iip
return|;
block|}
DECL|method|resolvePath (FSPermissionChecker pc, String src, long fileId)
name|INodesInPath
name|resolvePath
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|fileId
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|FileNotFoundException
throws|,
name|AccessControlException
throws|,
name|ParentNotDirectoryException
block|{
comment|// Older clients may not have given us an inode ID to work with.
comment|// In this case, we have to try to resolve the path and hope it
comment|// hasn't changed or been deleted since the file was opened for write.
name|INodesInPath
name|iip
decl_stmt|;
if|if
condition|(
name|fileId
operator|==
name|HdfsConstants
operator|.
name|GRANDFATHER_INODE_ID
condition|)
block|{
name|iip
operator|=
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|DirOp
operator|.
name|WRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INode
name|inode
init|=
name|getInode
argument_list|(
name|fileId
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
name|iip
operator|=
name|INodesInPath
operator|.
name|fromComponents
argument_list|(
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iip
operator|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|iip
return|;
block|}
comment|// this method can be removed after IIP is used more extensively
DECL|method|resolvePath (String src, FSDirectory fsd)
specifier|static
name|String
name|resolvePath
parameter_list|(
name|String
name|src
parameter_list|,
name|FSDirectory
name|fsd
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|byte
index|[]
index|[]
name|pathComponents
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|pathComponents
operator|=
name|resolveComponents
argument_list|(
name|pathComponents
argument_list|,
name|fsd
argument_list|)
expr_stmt|;
return|return
name|DFSUtil
operator|.
name|byteArray2PathString
argument_list|(
name|pathComponents
argument_list|)
return|;
block|}
comment|/**    * @return true if the path is a non-empty directory; otherwise, return false.    */
DECL|method|isNonEmptyDirectory (INodesInPath inodesInPath)
name|boolean
name|isNonEmptyDirectory
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INode
name|inode
init|=
name|inodesInPath
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
operator|||
operator|!
name|inode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//not found or not a directory
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|s
init|=
name|inodesInPath
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
return|return
operator|!
name|inode
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenList
argument_list|(
name|s
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check whether the filepath could be created    * @throws SnapshotAccessControlException if path is in RO snapshot    */
DECL|method|isValidToCreate (String src, INodesInPath iip)
name|boolean
name|isValidToCreate
parameter_list|(
name|String
name|src
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|SnapshotAccessControlException
block|{
name|String
name|srcs
init|=
name|normalizePath
argument_list|(
name|src
argument_list|)
decl_stmt|;
return|return
name|srcs
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
operator|!
name|srcs
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|&&
name|iip
operator|.
name|getLastINode
argument_list|()
operator|==
literal|null
return|;
block|}
comment|/**    * Tell the block manager to update the replication factors when delete    * happens. Deleting a file or a snapshot might decrease the replication    * factor of the blocks as the blocks are always replicated to the highest    * replication factor among all snapshots.    */
DECL|method|updateReplicationFactor (Collection<UpdatedReplicationInfo> blocks)
name|void
name|updateReplicationFactor
parameter_list|(
name|Collection
argument_list|<
name|UpdatedReplicationInfo
argument_list|>
name|blocks
parameter_list|)
block|{
name|BlockManager
name|bm
init|=
name|getBlockManager
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdatedReplicationInfo
name|e
range|:
name|blocks
control|)
block|{
name|BlockInfo
name|b
init|=
name|e
operator|.
name|block
argument_list|()
decl_stmt|;
name|bm
operator|.
name|setReplication
argument_list|(
name|b
operator|.
name|getReplication
argument_list|()
argument_list|,
name|e
operator|.
name|targetReplication
argument_list|()
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update the count of each directory with quota in the namespace.    * A directory's count is defined as the total number inodes in the tree    * rooted at the directory.    *    * This is an update of existing state of the filesystem and does not    * throw QuotaExceededException.    */
DECL|method|updateCountForQuota (int initThreads)
name|void
name|updateCountForQuota
parameter_list|(
name|int
name|initThreads
parameter_list|)
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|threads
init|=
operator|(
name|initThreads
operator|<
literal|1
operator|)
condition|?
literal|1
else|:
name|initThreads
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing quota with "
operator|+
name|threads
operator|+
literal|" thread(s)"
argument_list|)
expr_stmt|;
name|long
name|start
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|QuotaCounts
name|counts
init|=
operator|new
name|QuotaCounts
operator|.
name|Builder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|ForkJoinPool
name|p
init|=
operator|new
name|ForkJoinPool
argument_list|(
name|threads
argument_list|)
decl_stmt|;
name|RecursiveAction
name|task
init|=
operator|new
name|InitQuotaTask
argument_list|(
name|getBlockStoragePolicySuite
argument_list|()
argument_list|,
name|rootDir
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|,
name|rootDir
argument_list|,
name|counts
argument_list|)
decl_stmt|;
name|p
operator|.
name|execute
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|task
operator|.
name|join
argument_list|()
expr_stmt|;
name|p
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Quota initialization completed in "
operator|+
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|start
operator|)
operator|+
literal|" milliseconds\n"
operator|+
name|counts
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateCountForQuota ()
name|void
name|updateCountForQuota
parameter_list|()
block|{
name|updateCountForQuota
argument_list|(
name|quotaInitThreads
argument_list|)
expr_stmt|;
block|}
comment|/**    * parallel initialization using fork-join.    */
DECL|class|InitQuotaTask
specifier|private
specifier|static
class|class
name|InitQuotaTask
extends|extends
name|RecursiveAction
block|{
DECL|field|dir
specifier|private
specifier|final
name|INodeDirectory
name|dir
decl_stmt|;
DECL|field|counts
specifier|private
specifier|final
name|QuotaCounts
name|counts
decl_stmt|;
DECL|field|bsps
specifier|private
specifier|final
name|BlockStoragePolicySuite
name|bsps
decl_stmt|;
DECL|field|blockStoragePolicyId
specifier|private
specifier|final
name|byte
name|blockStoragePolicyId
decl_stmt|;
DECL|method|InitQuotaTask (BlockStoragePolicySuite bsps, byte blockStoragePolicyId, INodeDirectory dir, QuotaCounts counts)
specifier|public
name|InitQuotaTask
parameter_list|(
name|BlockStoragePolicySuite
name|bsps
parameter_list|,
name|byte
name|blockStoragePolicyId
parameter_list|,
name|INodeDirectory
name|dir
parameter_list|,
name|QuotaCounts
name|counts
parameter_list|)
block|{
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|this
operator|.
name|counts
operator|=
name|counts
expr_stmt|;
name|this
operator|.
name|bsps
operator|=
name|bsps
expr_stmt|;
name|this
operator|.
name|blockStoragePolicyId
operator|=
name|blockStoragePolicyId
expr_stmt|;
block|}
DECL|method|compute ()
specifier|public
name|void
name|compute
parameter_list|()
block|{
name|QuotaCounts
name|myCounts
init|=
operator|new
name|QuotaCounts
operator|.
name|Builder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|dir
operator|.
name|computeQuotaUsage4CurrentDirectory
argument_list|(
name|bsps
argument_list|,
name|blockStoragePolicyId
argument_list|,
name|myCounts
argument_list|)
expr_stmt|;
name|ReadOnlyList
argument_list|<
name|INode
argument_list|>
name|children
init|=
name|dir
operator|.
name|getChildrenList
argument_list|(
name|CURRENT_STATE_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|InitQuotaTask
argument_list|>
name|subtasks
init|=
operator|new
name|ArrayList
argument_list|<
name|InitQuotaTask
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|INode
name|child
range|:
name|children
control|)
block|{
specifier|final
name|byte
name|childPolicyId
init|=
name|child
operator|.
name|getStoragePolicyIDForQuota
argument_list|(
name|blockStoragePolicyId
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|subtasks
operator|.
name|add
argument_list|(
operator|new
name|InitQuotaTask
argument_list|(
name|bsps
argument_list|,
name|childPolicyId
argument_list|,
name|child
operator|.
name|asDirectory
argument_list|()
argument_list|,
name|myCounts
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// file or symlink. count using the local counts variable
name|myCounts
operator|.
name|add
argument_list|(
name|child
operator|.
name|computeQuotaUsage
argument_list|(
name|bsps
argument_list|,
name|childPolicyId
argument_list|,
literal|false
argument_list|,
name|CURRENT_STATE_ID
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// invoke and wait for completion
name|invokeAll
argument_list|(
name|subtasks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
comment|// check if quota is violated. It indicates a software bug.
specifier|final
name|QuotaCounts
name|q
init|=
name|dir
operator|.
name|getQuotaCounts
argument_list|()
decl_stmt|;
specifier|final
name|long
name|nsConsumed
init|=
name|myCounts
operator|.
name|getNameSpace
argument_list|()
decl_stmt|;
specifier|final
name|long
name|nsQuota
init|=
name|q
operator|.
name|getNameSpace
argument_list|()
decl_stmt|;
if|if
condition|(
name|Quota
operator|.
name|isViolated
argument_list|(
name|nsQuota
argument_list|,
name|nsConsumed
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Namespace quota violation in image for "
operator|+
name|dir
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" quota = "
operator|+
name|nsQuota
operator|+
literal|"< consumed = "
operator|+
name|nsConsumed
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|ssConsumed
init|=
name|myCounts
operator|.
name|getStorageSpace
argument_list|()
decl_stmt|;
specifier|final
name|long
name|ssQuota
init|=
name|q
operator|.
name|getStorageSpace
argument_list|()
decl_stmt|;
if|if
condition|(
name|Quota
operator|.
name|isViolated
argument_list|(
name|ssQuota
argument_list|,
name|ssConsumed
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Storagespace quota violation in image for "
operator|+
name|dir
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" quota = "
operator|+
name|ssQuota
operator|+
literal|"< consumed = "
operator|+
name|ssConsumed
argument_list|)
expr_stmt|;
block|}
specifier|final
name|EnumCounters
argument_list|<
name|StorageType
argument_list|>
name|tsConsumed
init|=
name|myCounts
operator|.
name|getTypeSpaces
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|StorageType
operator|.
name|getTypesSupportingQuota
argument_list|()
control|)
block|{
specifier|final
name|long
name|typeSpace
init|=
name|tsConsumed
operator|.
name|get
argument_list|(
name|t
argument_list|)
decl_stmt|;
specifier|final
name|long
name|typeQuota
init|=
name|q
operator|.
name|getTypeSpaces
argument_list|()
operator|.
name|get
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|Quota
operator|.
name|isViolated
argument_list|(
name|typeQuota
argument_list|,
name|typeSpace
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Storage type quota violation in image for "
operator|+
name|dir
operator|.
name|getFullPathName
argument_list|()
operator|+
literal|" type = "
operator|+
name|t
operator|.
name|toString
argument_list|()
operator|+
literal|" quota = "
operator|+
name|typeQuota
operator|+
literal|"< consumed "
operator|+
name|typeSpace
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting quota for "
operator|+
name|dir
operator|+
literal|"\n"
operator|+
name|myCounts
argument_list|)
expr_stmt|;
block|}
name|dir
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
operator|.
name|setSpaceConsumed
argument_list|(
name|nsConsumed
argument_list|,
name|ssConsumed
argument_list|,
name|tsConsumed
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|counts
init|)
block|{
name|counts
operator|.
name|add
argument_list|(
name|myCounts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Updates namespace, storagespace and typespaces consumed for all    * directories until the parent directory of file represented by path.    *    * @param iip the INodesInPath instance containing all the INodes for    *            updating quota usage    * @param nsDelta the delta change of namespace    * @param ssDelta the delta change of storage space consumed without replication    * @param replication the replication factor of the block consumption change    * @throws QuotaExceededException if the new count violates any quota limit    * @throws FileNotFoundException if path does not exist.    */
DECL|method|updateSpaceConsumed (INodesInPath iip, long nsDelta, long ssDelta, short replication)
name|void
name|updateSpaceConsumed
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|ssDelta
parameter_list|,
name|short
name|replication
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|SnapshotAccessControlException
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|iip
operator|.
name|getLastINode
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Path not found: "
operator|+
name|iip
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|updateCount
argument_list|(
name|iip
argument_list|,
name|nsDelta
argument_list|,
name|ssDelta
argument_list|,
name|replication
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateCount (INodesInPath iip, INode.QuotaDelta quotaDelta, boolean check)
specifier|public
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|INode
operator|.
name|QuotaDelta
name|quotaDelta
parameter_list|,
name|boolean
name|check
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|QuotaCounts
name|counts
init|=
name|quotaDelta
operator|.
name|getCountsCopy
argument_list|()
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|counts
operator|.
name|negation
argument_list|()
argument_list|,
name|check
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|INode
argument_list|,
name|QuotaCounts
argument_list|>
name|deltaInOtherPaths
init|=
name|quotaDelta
operator|.
name|getUpdateMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|INode
argument_list|,
name|QuotaCounts
argument_list|>
name|entry
range|:
name|deltaInOtherPaths
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|INodesInPath
name|path
init|=
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|updateCount
argument_list|(
name|path
argument_list|,
name|path
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|negation
argument_list|()
argument_list|,
name|check
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|INodeDirectory
argument_list|,
name|QuotaCounts
argument_list|>
name|entry
range|:
name|quotaDelta
operator|.
name|getQuotaDirMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|INodeDirectory
name|quotaDir
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|quotaDir
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
operator|.
name|addSpaceConsumed2Cache
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|negation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update the quota usage after deletion. The quota update is only necessary    * when image/edits have been loaded and the file/dir to be deleted is not    * contained in snapshots.    */
DECL|method|updateCountForDelete (final INode inode, final INodesInPath iip)
name|void
name|updateCountForDelete
parameter_list|(
specifier|final
name|INode
name|inode
parameter_list|,
specifier|final
name|INodesInPath
name|iip
parameter_list|)
block|{
if|if
condition|(
name|getFSNamesystem
argument_list|()
operator|.
name|isImageLoaded
argument_list|()
operator|&&
operator|!
name|inode
operator|.
name|isInLatestSnapshot
argument_list|(
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
condition|)
block|{
name|QuotaCounts
name|counts
init|=
name|inode
operator|.
name|computeQuotaUsage
argument_list|(
name|getBlockStoragePolicySuite
argument_list|()
argument_list|)
decl_stmt|;
name|unprotectedUpdateCount
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
name|counts
operator|.
name|negation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update usage count without replication factor change    */
DECL|method|updateCount (INodesInPath iip, long nsDelta, long ssDelta, short replication, boolean checkQuota)
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|ssDelta
parameter_list|,
name|short
name|replication
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|INodeFile
name|fileINode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|EnumCounters
argument_list|<
name|StorageType
argument_list|>
name|typeSpaceDeltas
init|=
name|getStorageTypeDeltas
argument_list|(
name|fileINode
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|,
name|ssDelta
argument_list|,
name|replication
argument_list|,
name|replication
argument_list|)
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
operator|new
name|QuotaCounts
operator|.
name|Builder
argument_list|()
operator|.
name|nameSpace
argument_list|(
name|nsDelta
argument_list|)
operator|.
name|storageSpace
argument_list|(
name|ssDelta
operator|*
name|replication
argument_list|)
operator|.
name|typeSpaces
argument_list|(
name|typeSpaceDeltas
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update usage count with replication factor change due to setReplication    */
DECL|method|updateCount (INodesInPath iip, long nsDelta, long ssDelta, short oldRep, short newRep, boolean checkQuota)
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|long
name|nsDelta
parameter_list|,
name|long
name|ssDelta
parameter_list|,
name|short
name|oldRep
parameter_list|,
name|short
name|newRep
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|INodeFile
name|fileINode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|EnumCounters
argument_list|<
name|StorageType
argument_list|>
name|typeSpaceDeltas
init|=
name|getStorageTypeDeltas
argument_list|(
name|fileINode
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|,
name|ssDelta
argument_list|,
name|oldRep
argument_list|,
name|newRep
argument_list|)
decl_stmt|;
name|updateCount
argument_list|(
name|iip
argument_list|,
name|iip
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
operator|new
name|QuotaCounts
operator|.
name|Builder
argument_list|()
operator|.
name|nameSpace
argument_list|(
name|nsDelta
argument_list|)
operator|.
name|storageSpace
argument_list|(
name|ssDelta
operator|*
operator|(
name|newRep
operator|-
name|oldRep
operator|)
argument_list|)
operator|.
name|typeSpaces
argument_list|(
name|typeSpaceDeltas
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
block|}
comment|/** update count of each inode with quota    *     * @param iip inodes in a path    * @param numOfINodes the number of inodes to update starting from index 0    * @param counts the count of space/namespace/type usage to be update    * @param checkQuota if true then check if quota is exceeded    * @throws QuotaExceededException if the new count violates any quota limit    */
DECL|method|updateCount (INodesInPath iip, int numOfINodes, QuotaCounts counts, boolean checkQuota)
name|void
name|updateCount
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|QuotaCounts
name|counts
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
comment|//still initializing. do not check or update quotas.
return|return;
block|}
if|if
condition|(
name|numOfINodes
operator|>
name|iip
operator|.
name|length
argument_list|()
condition|)
block|{
name|numOfINodes
operator|=
name|iip
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|checkQuota
operator|&&
operator|!
name|skipQuotaCheck
condition|)
block|{
name|verifyQuota
argument_list|(
name|iip
argument_list|,
name|numOfINodes
argument_list|,
name|counts
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|unprotectedUpdateCount
argument_list|(
name|iip
argument_list|,
name|numOfINodes
argument_list|,
name|counts
argument_list|)
expr_stmt|;
block|}
comment|/**     * update quota of each inode and check to see if quota is exceeded.     * See {@link #updateCount(INodesInPath, int, QuotaCounts, boolean)}    */
DECL|method|updateCountNoQuotaCheck (INodesInPath inodesInPath, int numOfINodes, QuotaCounts counts)
name|void
name|updateCountNoQuotaCheck
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|QuotaCounts
name|counts
parameter_list|)
block|{
assert|assert
name|hasWriteLock
argument_list|()
assert|;
try|try
block|{
name|updateCount
argument_list|(
name|inodesInPath
argument_list|,
name|numOfINodes
argument_list|,
name|counts
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"BUG: unexpected exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * updates quota without verification    * callers responsibility is to make sure quota is not exceeded    */
DECL|method|unprotectedUpdateCount (INodesInPath inodesInPath, int numOfINodes, QuotaCounts counts)
specifier|static
name|void
name|unprotectedUpdateCount
parameter_list|(
name|INodesInPath
name|inodesInPath
parameter_list|,
name|int
name|numOfINodes
parameter_list|,
name|QuotaCounts
name|counts
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfINodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inodesInPath
operator|.
name|getINode
argument_list|(
name|i
argument_list|)
operator|.
name|isQuotaSet
argument_list|()
condition|)
block|{
comment|// a directory with quota
name|inodesInPath
operator|.
name|getINode
argument_list|(
name|i
argument_list|)
operator|.
name|asDirectory
argument_list|()
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
operator|.
name|addSpaceConsumed2Cache
argument_list|(
name|counts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Update the cached quota space for a block that is being completed.    * Must only be called once, as the block is being completed.    * @param completeBlk - Completed block for which to update space    * @param inodes - INodes in path to file containing completeBlk; if null    *                 this will be resolved internally    */
DECL|method|updateSpaceForCompleteBlock (BlockInfo completeBlk, INodesInPath inodes)
specifier|public
name|void
name|updateSpaceForCompleteBlock
parameter_list|(
name|BlockInfo
name|completeBlk
parameter_list|,
name|INodesInPath
name|inodes
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|INodesInPath
name|iip
init|=
name|inodes
operator|!=
literal|null
condition|?
name|inodes
else|:
name|INodesInPath
operator|.
name|fromINode
argument_list|(
name|namesystem
operator|.
name|getBlockCollection
argument_list|(
name|completeBlk
argument_list|)
argument_list|)
decl_stmt|;
name|INodeFile
name|fileINode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|asFile
argument_list|()
decl_stmt|;
comment|// Adjust disk space consumption if required
specifier|final
name|long
name|diff
decl_stmt|;
specifier|final
name|short
name|replicationFactor
decl_stmt|;
if|if
condition|(
name|fileINode
operator|.
name|isStriped
argument_list|()
condition|)
block|{
specifier|final
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|FSDirErasureCodingOp
operator|.
name|unprotectedGetErasureCodingPolicy
argument_list|(
name|namesystem
argument_list|,
name|iip
argument_list|)
decl_stmt|;
specifier|final
name|short
name|numDataUnits
init|=
operator|(
name|short
operator|)
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
specifier|final
name|short
name|numParityUnits
init|=
operator|(
name|short
operator|)
name|ecPolicy
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
specifier|final
name|long
name|numBlocks
init|=
name|numDataUnits
operator|+
name|numParityUnits
decl_stmt|;
specifier|final
name|long
name|fullBlockGroupSize
init|=
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
operator|*
name|numBlocks
decl_stmt|;
specifier|final
name|BlockInfoStriped
name|striped
init|=
operator|new
name|BlockInfoStriped
argument_list|(
name|completeBlk
argument_list|,
name|ecPolicy
argument_list|)
decl_stmt|;
specifier|final
name|long
name|actualBlockGroupSize
init|=
name|striped
operator|.
name|spaceConsumed
argument_list|()
decl_stmt|;
name|diff
operator|=
name|fullBlockGroupSize
operator|-
name|actualBlockGroupSize
expr_stmt|;
name|replicationFactor
operator|=
operator|(
name|short
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
name|diff
operator|=
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
operator|-
name|completeBlk
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
name|replicationFactor
operator|=
name|fileINode
operator|.
name|getFileReplication
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|updateSpaceConsumed
argument_list|(
name|iip
argument_list|,
literal|0
argument_list|,
operator|-
name|diff
argument_list|,
name|replicationFactor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected exception while updating disk space."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getStorageTypeDeltas (byte storagePolicyID, long dsDelta, short oldRep, short newRep)
specifier|public
name|EnumCounters
argument_list|<
name|StorageType
argument_list|>
name|getStorageTypeDeltas
parameter_list|(
name|byte
name|storagePolicyID
parameter_list|,
name|long
name|dsDelta
parameter_list|,
name|short
name|oldRep
parameter_list|,
name|short
name|newRep
parameter_list|)
block|{
name|EnumCounters
argument_list|<
name|StorageType
argument_list|>
name|typeSpaceDeltas
init|=
operator|new
name|EnumCounters
argument_list|<
name|StorageType
argument_list|>
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// empty file
if|if
condition|(
name|dsDelta
operator|==
literal|0
condition|)
block|{
return|return
name|typeSpaceDeltas
return|;
block|}
comment|// Storage type and its quota are only available when storage policy is set
if|if
condition|(
name|storagePolicyID
operator|!=
name|HdfsConstants
operator|.
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
condition|)
block|{
name|BlockStoragePolicy
name|storagePolicy
init|=
name|getBlockManager
argument_list|()
operator|.
name|getStoragePolicy
argument_list|(
name|storagePolicyID
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldRep
operator|!=
name|newRep
condition|)
block|{
name|List
argument_list|<
name|StorageType
argument_list|>
name|oldChosenStorageTypes
init|=
name|storagePolicy
operator|.
name|chooseStorageTypes
argument_list|(
name|oldRep
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|oldChosenStorageTypes
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|supportTypeQuota
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|dsDelta
operator|>
literal|0
argument_list|)
expr_stmt|;
name|typeSpaceDeltas
operator|.
name|add
argument_list|(
name|t
argument_list|,
operator|-
name|dsDelta
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|StorageType
argument_list|>
name|newChosenStorageTypes
init|=
name|storagePolicy
operator|.
name|chooseStorageTypes
argument_list|(
name|newRep
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|newChosenStorageTypes
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|supportTypeQuota
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|typeSpaceDeltas
operator|.
name|add
argument_list|(
name|t
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|typeSpaceDeltas
return|;
block|}
comment|/**    * Add the given child to the namespace.    * @param existing the INodesInPath containing all the ancestral INodes    * @param child the new INode to add    * @param modes create modes    * @return a new INodesInPath instance containing the new child INode. Null    * if the adding fails.    * @throws QuotaExceededException is thrown if it violates quota limit    */
DECL|method|addINode (INodesInPath existing, INode child, FsPermission modes)
name|INodesInPath
name|addINode
parameter_list|(
name|INodesInPath
name|existing
parameter_list|,
name|INode
name|child
parameter_list|,
name|FsPermission
name|modes
parameter_list|)
throws|throws
name|QuotaExceededException
throws|,
name|UnresolvedLinkException
block|{
name|cacheName
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|addLastINode
argument_list|(
name|existing
argument_list|,
name|child
argument_list|,
name|modes
argument_list|,
literal|true
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Verify quota for adding or moving a new INode with required     * namespace and storagespace to a given position.    *      * @param iip INodes corresponding to a path    * @param pos position where a new INode will be added    * @param deltas needed namespace, storagespace and storage types    * @param commonAncestor Last node in inodes array that is a common ancestor    *          for a INode that is being moved from one location to the other.    *          Pass null if a node is not being moved.    * @throws QuotaExceededException if quota limit is exceeded.    */
DECL|method|verifyQuota (INodesInPath iip, int pos, QuotaCounts deltas, INode commonAncestor)
specifier|static
name|void
name|verifyQuota
parameter_list|(
name|INodesInPath
name|iip
parameter_list|,
name|int
name|pos
parameter_list|,
name|QuotaCounts
name|deltas
parameter_list|,
name|INode
name|commonAncestor
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
name|deltas
operator|.
name|getNameSpace
argument_list|()
operator|<=
literal|0
operator|&&
name|deltas
operator|.
name|getStorageSpace
argument_list|()
operator|<=
literal|0
operator|&&
name|deltas
operator|.
name|getTypeSpaces
argument_list|()
operator|.
name|allLessOrEqual
argument_list|(
literal|0L
argument_list|)
condition|)
block|{
comment|// if quota is being freed or not being consumed
return|return;
block|}
comment|// check existing components in the path
for|for
control|(
name|int
name|i
init|=
operator|(
name|pos
operator|>
name|iip
operator|.
name|length
argument_list|()
condition|?
name|iip
operator|.
name|length
argument_list|()
else|:
name|pos
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|commonAncestor
operator|==
name|iip
operator|.
name|getINode
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|// Stop checking for quota when common ancestor is reached
return|return;
block|}
specifier|final
name|DirectoryWithQuotaFeature
name|q
init|=
name|iip
operator|.
name|getINode
argument_list|(
name|i
argument_list|)
operator|.
name|asDirectory
argument_list|()
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
comment|// a directory with quota
try|try
block|{
name|q
operator|.
name|verifyQuota
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|e
operator|.
name|setPathName
argument_list|(
name|iip
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
comment|/** Verify if the inode name is legal. */
DECL|method|verifyINodeName (byte[] childName)
name|void
name|verifyINodeName
parameter_list|(
name|byte
index|[]
name|childName
parameter_list|)
throws|throws
name|HadoopIllegalArgumentException
block|{
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|HdfsServerConstants
operator|.
name|DOT_SNAPSHOT_DIR_BYTES
argument_list|,
name|childName
argument_list|)
condition|)
block|{
name|String
name|s
init|=
literal|"\""
operator|+
name|HdfsConstants
operator|.
name|DOT_SNAPSHOT_DIR
operator|+
literal|"\" is a reserved name."
decl_stmt|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
name|s
operator|+=
literal|"  Please rename it before upgrade."
expr_stmt|;
block|}
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
name|s
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verify child's name for fs limit.    *    * @param childName byte[] containing new child name    * @param parentPath String containing parent path    * @throws PathComponentTooLongException child's name is too long.    */
DECL|method|verifyMaxComponentLength (byte[] childName, String parentPath)
name|void
name|verifyMaxComponentLength
parameter_list|(
name|byte
index|[]
name|childName
parameter_list|,
name|String
name|parentPath
parameter_list|)
throws|throws
name|PathComponentTooLongException
block|{
if|if
condition|(
name|maxComponentLength
operator|==
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|int
name|length
init|=
name|childName
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|maxComponentLength
condition|)
block|{
specifier|final
name|PathComponentTooLongException
name|e
init|=
operator|new
name|PathComponentTooLongException
argument_list|(
name|maxComponentLength
argument_list|,
name|length
argument_list|,
name|parentPath
argument_list|,
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|childName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// Do not throw if edits log is still being processed
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"ERROR in FSDirectory.verifyINodeName"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Verify children size for fs limit.    *    * @throws MaxDirectoryItemsExceededException too many children.    */
DECL|method|verifyMaxDirItems (INodeDirectory parent, String parentPath)
name|void
name|verifyMaxDirItems
parameter_list|(
name|INodeDirectory
name|parent
parameter_list|,
name|String
name|parentPath
parameter_list|)
throws|throws
name|MaxDirectoryItemsExceededException
block|{
specifier|final
name|int
name|count
init|=
name|parent
operator|.
name|getChildrenList
argument_list|(
name|CURRENT_STATE_ID
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>=
name|maxDirItems
condition|)
block|{
specifier|final
name|MaxDirectoryItemsExceededException
name|e
init|=
operator|new
name|MaxDirectoryItemsExceededException
argument_list|(
name|parentPath
argument_list|,
name|maxDirItems
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|namesystem
operator|.
name|isImageLoaded
argument_list|()
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
comment|// Do not throw if edits log is still being processed
name|NameNode
operator|.
name|LOG
operator|.
name|error
argument_list|(
literal|"FSDirectory.verifyMaxDirItems: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Turn on HDFS-6962 POSIX ACL inheritance when the property    * {@link DFSConfigKeys#DFS_NAMENODE_POSIX_ACL_INHERITANCE_ENABLED_KEY} is    * true and a compatible client has sent both masked and unmasked create    * modes.    *    * @param child INode newly created child    * @param modes create modes    */
DECL|method|copyINodeDefaultAcl (INode child, FsPermission modes)
specifier|private
name|void
name|copyINodeDefaultAcl
parameter_list|(
name|INode
name|child
parameter_list|,
name|FsPermission
name|modes
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"child: {}, posixAclInheritanceEnabled: {}, modes: {}"
argument_list|,
name|child
argument_list|,
name|posixAclInheritanceEnabled
argument_list|,
name|modes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|posixAclInheritanceEnabled
operator|&&
name|modes
operator|!=
literal|null
operator|&&
name|modes
operator|.
name|getUnmasked
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//
comment|// HDFS-6962: POSIX ACL inheritance
comment|//
name|child
operator|.
name|setPermission
argument_list|(
name|modes
operator|.
name|getUnmasked
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AclStorage
operator|.
name|copyINodeDefaultAcl
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}: no parent default ACL to inherit"
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
name|child
operator|.
name|setPermission
argument_list|(
name|modes
operator|.
name|getMasked
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//
comment|// Old behavior before HDFS-6962
comment|//
name|AclStorage
operator|.
name|copyINodeDefaultAcl
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add a child to the end of the path specified by INodesInPath.    * @param existing the INodesInPath containing all the ancestral INodes    * @param inode the new INode to add    * @param modes create modes    * @param checkQuota whether to check quota    * @return an INodesInPath instance containing the new INode    */
annotation|@
name|VisibleForTesting
DECL|method|addLastINode (INodesInPath existing, INode inode, FsPermission modes, boolean checkQuota)
specifier|public
name|INodesInPath
name|addLastINode
parameter_list|(
name|INodesInPath
name|existing
parameter_list|,
name|INode
name|inode
parameter_list|,
name|FsPermission
name|modes
parameter_list|,
name|boolean
name|checkQuota
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
assert|assert
name|existing
operator|.
name|getLastINode
argument_list|()
operator|!=
literal|null
operator|&&
name|existing
operator|.
name|getLastINode
argument_list|()
operator|.
name|isDirectory
argument_list|()
assert|;
specifier|final
name|int
name|pos
init|=
name|existing
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// Disallow creation of /.reserved. This may be created when loading
comment|// editlog/fsimage during upgrade since /.reserved was a valid name in older
comment|// release. This may also be called when a user tries to create a file
comment|// or directory /.reserved.
if|if
condition|(
name|pos
operator|==
literal|1
operator|&&
name|existing
operator|.
name|getINode
argument_list|(
literal|0
argument_list|)
operator|==
name|rootDir
operator|&&
name|isReservedName
argument_list|(
name|inode
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"File name \""
operator|+
name|inode
operator|.
name|getLocalName
argument_list|()
operator|+
literal|"\" is reserved and cannot "
operator|+
literal|"be created. If this is during upgrade change the name of the "
operator|+
literal|"existing file or directory to another name before upgrading "
operator|+
literal|"to the new release."
argument_list|)
throw|;
block|}
specifier|final
name|INodeDirectory
name|parent
init|=
name|existing
operator|.
name|getINode
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
comment|// The filesystem limits are not really quotas, so this check may appear
comment|// odd. It's because a rename operation deletes the src, tries to add
comment|// to the dest, if that fails, re-adds the src from whence it came.
comment|// The rename code disables the quota when it's restoring to the
comment|// original location because a quota violation would cause the the item
comment|// to go "poof".  The fs limits must be bypassed for the same reason.
if|if
condition|(
name|checkQuota
condition|)
block|{
specifier|final
name|String
name|parentPath
init|=
name|existing
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|verifyMaxComponentLength
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|parentPath
argument_list|)
expr_stmt|;
name|verifyMaxDirItems
argument_list|(
name|parent
argument_list|,
name|parentPath
argument_list|)
expr_stmt|;
block|}
comment|// always verify inode name
name|verifyINodeName
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|QuotaCounts
name|counts
init|=
name|inode
operator|.
name|computeQuotaUsage
argument_list|(
name|getBlockStoragePolicySuite
argument_list|()
argument_list|)
decl_stmt|;
name|updateCount
argument_list|(
name|existing
argument_list|,
name|pos
argument_list|,
name|counts
argument_list|,
name|checkQuota
argument_list|)
expr_stmt|;
name|boolean
name|isRename
init|=
operator|(
name|inode
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
operator|)
decl_stmt|;
specifier|final
name|boolean
name|added
init|=
name|parent
operator|.
name|addChild
argument_list|(
name|inode
argument_list|,
literal|true
argument_list|,
name|existing
operator|.
name|getLatestSnapshotId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|added
condition|)
block|{
name|updateCountNoQuotaCheck
argument_list|(
name|existing
argument_list|,
name|pos
argument_list|,
name|counts
operator|.
name|negation
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isRename
condition|)
block|{
name|copyINodeDefaultAcl
argument_list|(
name|inode
argument_list|,
name|modes
argument_list|)
expr_stmt|;
block|}
name|addToInodeMap
argument_list|(
name|inode
argument_list|)
expr_stmt|;
block|}
return|return
name|INodesInPath
operator|.
name|append
argument_list|(
name|existing
argument_list|,
name|inode
argument_list|,
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
return|;
block|}
DECL|method|addLastINodeNoQuotaCheck (INodesInPath existing, INode i)
name|INodesInPath
name|addLastINodeNoQuotaCheck
parameter_list|(
name|INodesInPath
name|existing
parameter_list|,
name|INode
name|i
parameter_list|)
block|{
try|try
block|{
comment|// All callers do not have create modes to pass.
return|return
name|addLastINode
argument_list|(
name|existing
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|QuotaExceededException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"FSDirectory.addChildNoQuotaCheck - unexpected"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Remove the last inode in the path from the namespace.    * Note: the caller needs to update the ancestors' quota count.    *    * @return -1 for failing to remove;    *          0 for removing a reference whose referred inode has other     *            reference nodes;    *          1 otherwise.    */
annotation|@
name|VisibleForTesting
DECL|method|removeLastINode (final INodesInPath iip)
specifier|public
name|long
name|removeLastINode
parameter_list|(
specifier|final
name|INodesInPath
name|iip
parameter_list|)
block|{
specifier|final
name|int
name|latestSnapshot
init|=
name|iip
operator|.
name|getLatestSnapshotId
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|last
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|INodeDirectory
name|parent
init|=
name|iip
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|removeChild
argument_list|(
name|last
argument_list|,
name|latestSnapshot
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
operator|!
name|last
operator|.
name|isInLatestSnapshot
argument_list|(
name|latestSnapshot
argument_list|)
operator|&&
name|INodeReference
operator|.
name|tryRemoveReference
argument_list|(
name|last
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
comment|/**    * Return a new collection of normalized paths from the given input    * collection. The input collection is unmodified.    *    * Reserved paths, relative paths and paths with scheme are ignored.    *    * @param paths collection whose contents are to be normalized.    * @return collection with all input paths normalized.    */
DECL|method|normalizePaths (Collection<String> paths, String errorString)
specifier|static
name|Collection
argument_list|<
name|String
argument_list|>
name|normalizePaths
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|paths
parameter_list|,
name|String
name|errorString
parameter_list|)
block|{
if|if
condition|(
name|paths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|paths
return|;
block|}
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|normalized
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|paths
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|dir
range|:
name|paths
control|)
block|{
if|if
condition|(
name|isReservedName
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} ignoring reserved path {}"
argument_list|,
name|errorString
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} ignoring relative path {}"
argument_list|,
name|errorString
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} ignoring path {} with scheme"
argument_list|,
name|errorString
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normalized
operator|.
name|add
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|normalized
return|;
block|}
DECL|method|normalizePath (String src)
specifier|static
name|String
name|normalizePath
parameter_list|(
name|String
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|src
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|src
operator|=
name|src
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|src
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|src
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getYieldCount ()
specifier|public
name|long
name|getYieldCount
parameter_list|()
block|{
return|return
name|yieldCount
return|;
block|}
DECL|method|addYieldCount (long value)
name|void
name|addYieldCount
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|yieldCount
operator|+=
name|value
expr_stmt|;
block|}
DECL|method|getINodeMap ()
specifier|public
name|INodeMap
name|getINodeMap
parameter_list|()
block|{
return|return
name|inodeMap
return|;
block|}
comment|/**    * This method is always called with writeLock of FSDirectory held.    */
DECL|method|addToInodeMap (INode inode)
specifier|public
specifier|final
name|void
name|addToInodeMap
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
if|if
condition|(
name|inode
operator|instanceof
name|INodeWithAdditionalFields
condition|)
block|{
name|inodeMap
operator|.
name|put
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inode
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
specifier|final
name|XAttrFeature
name|xaf
init|=
name|inode
operator|.
name|getXAttrFeature
argument_list|()
decl_stmt|;
name|addEncryptionZone
argument_list|(
operator|(
name|INodeWithAdditionalFields
operator|)
name|inode
argument_list|,
name|xaf
argument_list|)
expr_stmt|;
name|StoragePolicySatisfyManager
name|spsManager
init|=
name|namesystem
operator|.
name|getBlockManager
argument_list|()
operator|.
name|getSPSManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|spsManager
operator|!=
literal|null
operator|&&
name|spsManager
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
name|addStoragePolicySatisfier
argument_list|(
operator|(
name|INodeWithAdditionalFields
operator|)
name|inode
argument_list|,
name|xaf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|addStoragePolicySatisfier (INodeWithAdditionalFields inode, XAttrFeature xaf)
specifier|private
name|void
name|addStoragePolicySatisfier
parameter_list|(
name|INodeWithAdditionalFields
name|inode
parameter_list|,
name|XAttrFeature
name|xaf
parameter_list|)
block|{
if|if
condition|(
name|xaf
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|XAttr
name|xattr
init|=
name|xaf
operator|.
name|getXAttr
argument_list|(
name|XATTR_SATISFY_STORAGE_POLICY
argument_list|)
decl_stmt|;
if|if
condition|(
name|xattr
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|FSDirSatisfyStoragePolicyOp
operator|.
name|unprotectedSatisfyStoragePolicy
argument_list|(
name|inode
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|addEncryptionZone (INodeWithAdditionalFields inode, XAttrFeature xaf)
specifier|private
name|void
name|addEncryptionZone
parameter_list|(
name|INodeWithAdditionalFields
name|inode
parameter_list|,
name|XAttrFeature
name|xaf
parameter_list|)
block|{
if|if
condition|(
name|xaf
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|XAttr
name|xattr
init|=
name|xaf
operator|.
name|getXAttr
argument_list|(
name|CRYPTO_XATTR_ENCRYPTION_ZONE
argument_list|)
decl_stmt|;
if|if
condition|(
name|xattr
operator|==
literal|null
condition|)
block|{
return|return;
block|}
try|try
block|{
specifier|final
name|HdfsProtos
operator|.
name|ZoneEncryptionInfoProto
name|ezProto
init|=
name|HdfsProtos
operator|.
name|ZoneEncryptionInfoProto
operator|.
name|parseFrom
argument_list|(
name|xattr
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|ezManager
operator|.
name|unprotectedAddEncryptionZone
argument_list|(
name|inode
operator|.
name|getId
argument_list|()
argument_list|,
name|PBHelperClient
operator|.
name|convert
argument_list|(
name|ezProto
operator|.
name|getSuite
argument_list|()
argument_list|)
argument_list|,
name|PBHelperClient
operator|.
name|convert
argument_list|(
name|ezProto
operator|.
name|getCryptoProtocolVersion
argument_list|()
argument_list|)
argument_list|,
name|ezProto
operator|.
name|getKeyName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ezProto
operator|.
name|hasReencryptionProto
argument_list|()
condition|)
block|{
specifier|final
name|ReencryptionInfoProto
name|reProto
init|=
name|ezProto
operator|.
name|getReencryptionProto
argument_list|()
decl_stmt|;
comment|// inodes parents may not be loaded if this is done during fsimage
comment|// loading so cannot set full path now. Pass in null to indicate that.
name|ezManager
operator|.
name|getReencryptionStatus
argument_list|()
operator|.
name|updateZoneStatus
argument_list|(
name|inode
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|reProto
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error parsing protocol buffer of "
operator|+
literal|"EZ XAttr "
operator|+
name|xattr
operator|.
name|getName
argument_list|()
operator|+
literal|" dir:"
operator|+
name|inode
operator|.
name|getFullPathName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This is to handle encryption zone for rootDir when loading from    * fsimage, and should only be called during NN restart.    */
DECL|method|addRootDirToEncryptionZone (XAttrFeature xaf)
specifier|public
specifier|final
name|void
name|addRootDirToEncryptionZone
parameter_list|(
name|XAttrFeature
name|xaf
parameter_list|)
block|{
name|addEncryptionZone
argument_list|(
name|rootDir
argument_list|,
name|xaf
argument_list|)
expr_stmt|;
block|}
comment|/**    * This method is always called with writeLock of FSDirectory held.    */
DECL|method|removeFromInodeMap (List<? extends INode> inodes)
specifier|public
specifier|final
name|void
name|removeFromInodeMap
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|INode
argument_list|>
name|inodes
parameter_list|)
block|{
if|if
condition|(
name|inodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|INode
name|inode
range|:
name|inodes
control|)
block|{
if|if
condition|(
name|inode
operator|!=
literal|null
operator|&&
name|inode
operator|instanceof
name|INodeWithAdditionalFields
condition|)
block|{
name|inodeMap
operator|.
name|remove
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|ezManager
operator|.
name|removeEncryptionZone
argument_list|(
name|inode
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Get the inode from inodeMap based on its inode id.    * @param id The given id    * @return The inode associated with the given id    */
DECL|method|getInode (long id)
specifier|public
name|INode
name|getInode
parameter_list|(
name|long
name|id
parameter_list|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|inodeMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getInodeMapSize ()
name|int
name|getInodeMapSize
parameter_list|()
block|{
return|return
name|inodeMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|totalInodes ()
name|long
name|totalInodes
parameter_list|()
block|{
return|return
name|getInodeMapSize
argument_list|()
return|;
block|}
comment|/**    * Reset the entire namespace tree.    */
DECL|method|reset ()
name|void
name|reset
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|rootDir
operator|=
name|createRoot
argument_list|(
name|getFSNamesystem
argument_list|()
argument_list|)
expr_stmt|;
name|inodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|addToInodeMap
argument_list|(
name|rootDir
argument_list|)
expr_stmt|;
name|nameCache
operator|.
name|reset
argument_list|()
expr_stmt|;
name|inodeId
operator|.
name|setCurrentValue
argument_list|(
name|INodeId
operator|.
name|LAST_RESERVED_ID
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|resolveLastINode (INodesInPath iip)
specifier|static
name|INode
name|resolveLastINode
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"cannot find "
operator|+
name|iip
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|inode
return|;
block|}
comment|/**    * Caches frequently used file names to reuse file name objects and    * reduce heap size.    */
DECL|method|cacheName (INode inode)
name|void
name|cacheName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
comment|// Name is cached only for files
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return;
block|}
name|ByteArray
name|name
init|=
operator|new
name|ByteArray
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
decl_stmt|;
name|name
operator|=
name|nameCache
operator|.
name|put
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|inode
operator|.
name|setLocalName
argument_list|(
name|name
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shutdown ()
name|void
name|shutdown
parameter_list|()
block|{
name|nameCache
operator|.
name|reset
argument_list|()
expr_stmt|;
name|inodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Given an INode get all the path complents leading to it from the root.    * If an Inode corresponding to C is given in /A/B/C, the returned    * patch components will be {root, A, B, C}.    * Note that this method cannot handle scenarios where the inode is in a    * snapshot.    */
DECL|method|getPathComponents (INode inode)
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|getPathComponents
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|components
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|components
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|inode
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|components
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|inode
operator|.
name|getParent
argument_list|()
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|)
expr_stmt|;
name|inode
operator|=
name|inode
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
name|components
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|components
operator|.
name|size
argument_list|()
index|]
index|[]
argument_list|)
return|;
block|}
comment|/** Check if a given inode name is reserved */
DECL|method|isReservedName (INode inode)
specifier|public
specifier|static
name|boolean
name|isReservedName
parameter_list|(
name|INode
name|inode
parameter_list|)
block|{
return|return
name|CHECK_RESERVED_FILE_NAMES
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|inode
operator|.
name|getLocalNameBytes
argument_list|()
argument_list|,
name|DOT_RESERVED
argument_list|)
return|;
block|}
comment|/** Check if a given path is reserved */
DECL|method|isReservedName (String src)
specifier|public
specifier|static
name|boolean
name|isReservedName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|src
operator|.
name|startsWith
argument_list|(
name|DOT_RESERVED_PATH_PREFIX
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
return|;
block|}
DECL|method|isExactReservedName (String src)
specifier|public
specifier|static
name|boolean
name|isExactReservedName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|CHECK_RESERVED_FILE_NAMES
operator|&&
name|src
operator|.
name|equals
argument_list|(
name|DOT_RESERVED_PATH_PREFIX
argument_list|)
return|;
block|}
DECL|method|isExactReservedName (byte[][] components)
specifier|public
specifier|static
name|boolean
name|isExactReservedName
parameter_list|(
name|byte
index|[]
index|[]
name|components
parameter_list|)
block|{
return|return
name|CHECK_RESERVED_FILE_NAMES
operator|&&
operator|(
name|components
operator|.
name|length
operator|==
literal|2
operator|)
operator|&&
name|isReservedName
argument_list|(
name|components
argument_list|)
return|;
block|}
DECL|method|isReservedRawName (String src)
specifier|static
name|boolean
name|isReservedRawName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|src
operator|.
name|startsWith
argument_list|(
name|DOT_RESERVED_PATH_PREFIX
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|RAW_STRING
argument_list|)
return|;
block|}
DECL|method|isReservedInodesName (String src)
specifier|static
name|boolean
name|isReservedInodesName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
return|return
name|src
operator|.
name|startsWith
argument_list|(
name|DOT_RESERVED_PATH_PREFIX
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|DOT_INODES_STRING
argument_list|)
return|;
block|}
DECL|method|isReservedName (byte[][] components)
specifier|static
name|boolean
name|isReservedName
parameter_list|(
name|byte
index|[]
index|[]
name|components
parameter_list|)
block|{
return|return
operator|(
name|components
operator|.
name|length
operator|>
literal|1
operator|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|INodeDirectory
operator|.
name|ROOT_NAME
argument_list|,
name|components
index|[
literal|0
index|]
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|DOT_RESERVED
argument_list|,
name|components
index|[
literal|1
index|]
argument_list|)
return|;
block|}
DECL|method|isReservedRawName (byte[][] components)
specifier|static
name|boolean
name|isReservedRawName
parameter_list|(
name|byte
index|[]
index|[]
name|components
parameter_list|)
block|{
return|return
operator|(
name|components
operator|.
name|length
operator|>
literal|2
operator|)
operator|&&
name|isReservedName
argument_list|(
name|components
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|RAW
argument_list|,
name|components
index|[
literal|2
index|]
argument_list|)
return|;
block|}
comment|/**    * Resolve a /.reserved/... path to a non-reserved path.    *<p/>    * There are two special hierarchies under /.reserved/:    *<p/>    * /.reserved/.inodes/<inodeid> performs a path lookup by inodeid,    *<p/>    * /.reserved/raw/... returns the encrypted (raw) bytes of a file in an    * encryption zone. For instance, if /ezone is an encryption zone, then    * /ezone/a refers to the decrypted file and /.reserved/raw/ezone/a refers to    * the encrypted (raw) bytes of /ezone/a.    *<p/>    * Pathnames in the /.reserved/raw directory that resolve to files not in an    * encryption zone are equivalent to the corresponding non-raw path. Hence,    * if /a/b/c refers to a file that is not in an encryption zone, then    * /.reserved/raw/a/b/c is equivalent (they both refer to the same    * unencrypted file).    *     * @param pathComponents to be resolved    * @param fsd FSDirectory    * @return if the path indicates an inode, return path after replacing up to    *<inodeid> with the corresponding path of the inode, else the path    *         in {@code pathComponents} as is. If the path refers to a path in    *         the "raw" directory, return the non-raw pathname.    * @throws FileNotFoundException if inodeid is invalid    */
DECL|method|resolveComponents (byte[][] pathComponents, FSDirectory fsd)
specifier|static
name|byte
index|[]
index|[]
name|resolveComponents
parameter_list|(
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|,
name|FSDirectory
name|fsd
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|int
name|nComponents
init|=
name|pathComponents
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|nComponents
operator|<
literal|3
operator|||
operator|!
name|isReservedName
argument_list|(
name|pathComponents
argument_list|)
condition|)
block|{
comment|/* This is not a /.reserved/ path so do nothing. */
block|}
elseif|else
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|DOT_INODES
argument_list|,
name|pathComponents
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* It's a /.reserved/.inodes path. */
if|if
condition|(
name|nComponents
operator|>
literal|3
condition|)
block|{
name|pathComponents
operator|=
name|resolveDotInodesPath
argument_list|(
name|pathComponents
argument_list|,
name|fsd
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|RAW
argument_list|,
name|pathComponents
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* It's /.reserved/raw so strip off the /.reserved/raw prefix. */
if|if
condition|(
name|nComponents
operator|==
literal|3
condition|)
block|{
name|pathComponents
operator|=
operator|new
name|byte
index|[]
index|[]
block|{
name|INodeDirectory
operator|.
name|ROOT_NAME
block|}
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nComponents
operator|==
literal|4
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|DOT_RESERVED
argument_list|,
name|pathComponents
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
comment|/* It's /.reserved/raw/.reserved so don't strip */
block|}
else|else
block|{
name|pathComponents
operator|=
name|constructRemainingPath
argument_list|(
operator|new
name|byte
index|[]
index|[]
block|{
name|INodeDirectory
operator|.
name|ROOT_NAME
block|}
argument_list|,
name|pathComponents
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|pathComponents
return|;
block|}
DECL|method|resolveDotInodesPath ( byte[][] pathComponents, FSDirectory fsd)
specifier|private
specifier|static
name|byte
index|[]
index|[]
name|resolveDotInodesPath
parameter_list|(
name|byte
index|[]
index|[]
name|pathComponents
parameter_list|,
name|FSDirectory
name|fsd
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|String
name|inodeId
init|=
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|pathComponents
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
specifier|final
name|long
name|id
decl_stmt|;
try|try
block|{
name|id
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|inodeId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Invalid inode path: "
operator|+
name|DFSUtil
operator|.
name|byteArray2PathString
argument_list|(
name|pathComponents
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
operator|&&
name|pathComponents
operator|.
name|length
operator|==
literal|4
condition|)
block|{
return|return
operator|new
name|byte
index|[]
index|[]
block|{
name|INodeDirectory
operator|.
name|ROOT_NAME
block|}
return|;
block|}
name|INode
name|inode
init|=
name|fsd
operator|.
name|getInode
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File for given inode path does not exist: "
operator|+
name|DFSUtil
operator|.
name|byteArray2PathString
argument_list|(
name|pathComponents
argument_list|)
argument_list|)
throw|;
block|}
comment|// Handle single ".." for NFS lookup support.
if|if
condition|(
operator|(
name|pathComponents
operator|.
name|length
operator|>
literal|4
operator|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|pathComponents
index|[
literal|4
index|]
argument_list|,
name|DOT_DOT
argument_list|)
condition|)
block|{
name|INode
name|parent
init|=
name|inode
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
operator|||
name|parent
operator|.
name|getId
argument_list|()
operator|==
name|INodeId
operator|.
name|ROOT_INODE_ID
condition|)
block|{
comment|// inode is root, or its parent is root.
return|return
operator|new
name|byte
index|[]
index|[]
block|{
name|INodeDirectory
operator|.
name|ROOT_NAME
block|}
return|;
block|}
return|return
name|parent
operator|.
name|getPathComponents
argument_list|()
return|;
block|}
return|return
name|constructRemainingPath
argument_list|(
name|inode
operator|.
name|getPathComponents
argument_list|()
argument_list|,
name|pathComponents
argument_list|,
literal|4
argument_list|)
return|;
block|}
DECL|method|constructRemainingPath (byte[][] components, byte[][] extraComponents, int startAt)
specifier|private
specifier|static
name|byte
index|[]
index|[]
name|constructRemainingPath
parameter_list|(
name|byte
index|[]
index|[]
name|components
parameter_list|,
name|byte
index|[]
index|[]
name|extraComponents
parameter_list|,
name|int
name|startAt
parameter_list|)
block|{
name|int
name|remainder
init|=
name|extraComponents
operator|.
name|length
operator|-
name|startAt
decl_stmt|;
if|if
condition|(
name|remainder
operator|>
literal|0
condition|)
block|{
comment|// grow the array and copy in the remaining components
name|int
name|pos
init|=
name|components
operator|.
name|length
decl_stmt|;
name|components
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|components
argument_list|,
name|pos
operator|+
name|remainder
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|extraComponents
argument_list|,
name|startAt
argument_list|,
name|components
argument_list|,
name|pos
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Resolved path is "
operator|+
name|DFSUtil
operator|.
name|byteArray2PathString
argument_list|(
name|components
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|components
return|;
block|}
DECL|method|getINode4DotSnapshot (INodesInPath iip)
name|INode
name|getINode4DotSnapshot
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|UnresolvedLinkException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|iip
operator|.
name|isDotSnapshotDir
argument_list|()
argument_list|,
literal|"%s does not end with %s"
argument_list|,
name|iip
operator|.
name|getPath
argument_list|()
argument_list|,
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
expr_stmt|;
specifier|final
name|INode
name|node
init|=
name|iip
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isDirectory
argument_list|()
operator|&&
name|node
operator|.
name|asDirectory
argument_list|()
operator|.
name|isSnapshottable
argument_list|()
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Resolves the given path into inodes.  Reserved paths are not handled and    * permissions are not verified.  Client supplied paths should be    * resolved via {@link #resolvePath(FSPermissionChecker, String, DirOp)}.    * This method should only be used by internal methods.    * @return the {@link INodesInPath} containing all inodes in the path.    * @throws UnresolvedLinkException    * @throws ParentNotDirectoryException    * @throws AccessControlException    */
DECL|method|getINodesInPath (String src, DirOp dirOp)
specifier|public
name|INodesInPath
name|getINodesInPath
parameter_list|(
name|String
name|src
parameter_list|,
name|DirOp
name|dirOp
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|AccessControlException
throws|,
name|ParentNotDirectoryException
block|{
return|return
name|getINodesInPath
argument_list|(
name|INode
operator|.
name|getPathComponents
argument_list|(
name|src
argument_list|)
argument_list|,
name|dirOp
argument_list|)
return|;
block|}
DECL|method|getINodesInPath (byte[][] components, DirOp dirOp)
specifier|public
name|INodesInPath
name|getINodesInPath
parameter_list|(
name|byte
index|[]
index|[]
name|components
parameter_list|,
name|DirOp
name|dirOp
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|AccessControlException
throws|,
name|ParentNotDirectoryException
block|{
name|INodesInPath
name|iip
init|=
name|INodesInPath
operator|.
name|resolve
argument_list|(
name|rootDir
argument_list|,
name|components
argument_list|)
decl_stmt|;
name|checkTraverse
argument_list|(
literal|null
argument_list|,
name|iip
argument_list|,
name|dirOp
argument_list|)
expr_stmt|;
return|return
name|iip
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    * See {@link #getINode(String, DirOp)}    */
annotation|@
name|VisibleForTesting
comment|// should be removed after a lot of tests are updated
DECL|method|getINode (String src)
specifier|public
name|INode
name|getINode
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|AccessControlException
throws|,
name|ParentNotDirectoryException
block|{
return|return
name|getINode
argument_list|(
name|src
argument_list|,
name|DirOp
operator|.
name|READ
argument_list|)
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    * See {@link #getINode(String, DirOp)}    */
annotation|@
name|VisibleForTesting
comment|// should be removed after a lot of tests are updated
DECL|method|getINode4Write (String src)
specifier|public
name|INode
name|getINode4Write
parameter_list|(
name|String
name|src
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
block|{
return|return
name|getINode
argument_list|(
name|src
argument_list|,
name|DirOp
operator|.
name|WRITE
argument_list|)
return|;
block|}
comment|/**    * Get {@link INode} associated with the file / directory.    */
DECL|method|getINode (String src, DirOp dirOp)
specifier|public
name|INode
name|getINode
parameter_list|(
name|String
name|src
parameter_list|,
name|DirOp
name|dirOp
parameter_list|)
throws|throws
name|UnresolvedLinkException
throws|,
name|AccessControlException
throws|,
name|ParentNotDirectoryException
block|{
return|return
name|getINodesInPath
argument_list|(
name|src
argument_list|,
name|dirOp
argument_list|)
operator|.
name|getLastINode
argument_list|()
return|;
block|}
DECL|method|getPermissionChecker ()
name|FSPermissionChecker
name|getPermissionChecker
parameter_list|()
throws|throws
name|AccessControlException
block|{
try|try
block|{
return|return
name|getPermissionChecker
argument_list|(
name|fsOwnerShortUserName
argument_list|,
name|supergroup
argument_list|,
name|NameNode
operator|.
name|getRemoteUser
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getPermissionChecker (String fsOwner, String superGroup, UserGroupInformation ugi)
name|FSPermissionChecker
name|getPermissionChecker
parameter_list|(
name|String
name|fsOwner
parameter_list|,
name|String
name|superGroup
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|AccessControlException
block|{
return|return
operator|new
name|FSPermissionChecker
argument_list|(
name|fsOwner
argument_list|,
name|superGroup
argument_list|,
name|ugi
argument_list|,
name|getUserFilteredAttributeProvider
argument_list|(
name|ugi
argument_list|)
argument_list|)
return|;
block|}
DECL|method|checkOwner (FSPermissionChecker pc, INodesInPath iip)
name|void
name|checkOwner
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
block|{
if|if
condition|(
name|iip
operator|.
name|getLastINode
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Directory/File does not exist "
operator|+
name|iip
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|checkPathAccess (FSPermissionChecker pc, INodesInPath iip, FsAction access)
name|void
name|checkPathAccess
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|FsAction
name|access
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|access
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|checkParentAccess (FSPermissionChecker pc, INodesInPath iip, FsAction access)
name|void
name|checkParentAccess
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|FsAction
name|access
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|access
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|checkAncestorAccess (FSPermissionChecker pc, INodesInPath iip, FsAction access)
name|void
name|checkAncestorAccess
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|FsAction
name|access
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
name|access
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|checkTraverse (FSPermissionChecker pc, INodesInPath iip, boolean resolveLink)
name|void
name|checkTraverse
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedPathException
throws|,
name|ParentNotDirectoryException
block|{
name|FSPermissionChecker
operator|.
name|checkTraverse
argument_list|(
name|isPermissionEnabled
condition|?
name|pc
else|:
literal|null
argument_list|,
name|iip
argument_list|,
name|resolveLink
argument_list|)
expr_stmt|;
block|}
DECL|method|checkTraverse (FSPermissionChecker pc, INodesInPath iip, DirOp dirOp)
name|void
name|checkTraverse
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|DirOp
name|dirOp
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnresolvedPathException
throws|,
name|ParentNotDirectoryException
block|{
specifier|final
name|boolean
name|resolveLink
decl_stmt|;
switch|switch
condition|(
name|dirOp
condition|)
block|{
case|case
name|READ_LINK
case|:
case|case
name|WRITE_LINK
case|:
case|case
name|CREATE_LINK
case|:
name|resolveLink
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
name|resolveLink
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|checkTraverse
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|resolveLink
argument_list|)
expr_stmt|;
name|boolean
name|allowSnapshot
init|=
operator|(
name|dirOp
operator|==
name|DirOp
operator|.
name|READ
operator|||
name|dirOp
operator|==
name|DirOp
operator|.
name|READ_LINK
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowSnapshot
operator|&&
name|iip
operator|.
name|isSnapshot
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SnapshotAccessControlException
argument_list|(
literal|"Modification on a read-only snapshot is disallowed"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Check whether current user have permissions to access the path. For more    * details of the parameters, see    * {@link FSPermissionChecker#checkPermission}.    */
DECL|method|checkPermission (FSPermissionChecker pc, INodesInPath iip, boolean doCheckOwner, FsAction ancestorAccess, FsAction parentAccess, FsAction access, FsAction subAccess)
name|void
name|checkPermission
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|boolean
name|doCheckOwner
parameter_list|,
name|FsAction
name|ancestorAccess
parameter_list|,
name|FsAction
name|parentAccess
parameter_list|,
name|FsAction
name|access
parameter_list|,
name|FsAction
name|subAccess
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|doCheckOwner
argument_list|,
name|ancestorAccess
argument_list|,
name|parentAccess
argument_list|,
name|access
argument_list|,
name|subAccess
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check whether current user have permissions to access the path. For more    * details of the parameters, see    * {@link FSPermissionChecker#checkPermission}.    */
DECL|method|checkPermission (FSPermissionChecker pc, INodesInPath iip, boolean doCheckOwner, FsAction ancestorAccess, FsAction parentAccess, FsAction access, FsAction subAccess, boolean ignoreEmptyDir)
name|void
name|checkPermission
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|boolean
name|doCheckOwner
parameter_list|,
name|FsAction
name|ancestorAccess
parameter_list|,
name|FsAction
name|parentAccess
parameter_list|,
name|FsAction
name|access
parameter_list|,
name|FsAction
name|subAccess
parameter_list|,
name|boolean
name|ignoreEmptyDir
parameter_list|)
throws|throws
name|AccessControlException
block|{
if|if
condition|(
operator|!
name|pc
operator|.
name|isSuperUser
argument_list|()
condition|)
block|{
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|pc
operator|.
name|checkPermission
argument_list|(
name|iip
argument_list|,
name|doCheckOwner
argument_list|,
name|ancestorAccess
argument_list|,
name|parentAccess
argument_list|,
name|access
argument_list|,
name|subAccess
argument_list|,
name|ignoreEmptyDir
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|checkUnreadableBySuperuser (FSPermissionChecker pc, INodesInPath iip)
name|void
name|checkUnreadableBySuperuser
parameter_list|(
name|FSPermissionChecker
name|pc
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pc
operator|.
name|isSuperUser
argument_list|()
condition|)
block|{
if|if
condition|(
name|FSDirXAttrOp
operator|.
name|getXAttrByPrefixedName
argument_list|(
name|this
argument_list|,
name|iip
argument_list|,
name|SECURITY_XATTR_UNREADABLE_BY_SUPERUSER
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Access is denied for "
operator|+
name|pc
operator|.
name|getUser
argument_list|()
operator|+
literal|" since the superuser "
operator|+
literal|"is not allowed to perform this operation."
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|getAuditFileInfo (INodesInPath iip)
name|FileStatus
name|getAuditFileInfo
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isAuditEnabled
argument_list|()
operator|||
operator|!
name|namesystem
operator|.
name|isExternalInvocation
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|INode
name|inode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|snapshot
init|=
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
name|Path
name|symlink
init|=
literal|null
decl_stmt|;
name|long
name|size
init|=
literal|0
decl_stmt|;
comment|// length is zero for directories
name|short
name|replication
init|=
literal|0
decl_stmt|;
name|long
name|blocksize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
specifier|final
name|INodeFile
name|fileNode
init|=
name|inode
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|size
operator|=
name|fileNode
operator|.
name|computeFileSize
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|replication
operator|=
name|fileNode
operator|.
name|getFileReplication
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inode
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
name|symlink
operator|=
operator|new
name|Path
argument_list|(
name|DFSUtilClient
operator|.
name|bytes2String
argument_list|(
name|inode
operator|.
name|asSymlink
argument_list|()
operator|.
name|getSymlink
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FileStatus
argument_list|(
name|size
argument_list|,
name|inode
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|inode
operator|.
name|getModificationTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|inode
operator|.
name|getAccessTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|inode
operator|.
name|getFsPermission
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|inode
operator|.
name|getUserName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|inode
operator|.
name|getGroupName
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|symlink
argument_list|,
operator|new
name|Path
argument_list|(
name|iip
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Verify that parent directory of src exists.    */
DECL|method|verifyParentDir (INodesInPath iip)
name|void
name|verifyParentDir
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
block|{
if|if
condition|(
name|iip
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
block|{
specifier|final
name|INode
name|parentNode
init|=
name|iip
operator|.
name|getINode
argument_list|(
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Parent directory doesn't exist: "
operator|+
name|iip
operator|.
name|getParentPath
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parentNode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
literal|"Parent path is not a directory: "
operator|+
name|iip
operator|.
name|getParentPath
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Allocate a new inode ID. */
DECL|method|allocateNewInodeId ()
name|long
name|allocateNewInodeId
parameter_list|()
block|{
return|return
name|inodeId
operator|.
name|nextValue
argument_list|()
return|;
block|}
comment|/** @return the last inode ID. */
DECL|method|getLastInodeId ()
specifier|public
name|long
name|getLastInodeId
parameter_list|()
block|{
return|return
name|inodeId
operator|.
name|getCurrentValue
argument_list|()
return|;
block|}
comment|/**    * Set the last allocated inode id when fsimage or editlog is loaded.    */
DECL|method|resetLastInodeId (long newValue)
name|void
name|resetLastInodeId
parameter_list|(
name|long
name|newValue
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|inodeId
operator|.
name|skipTo
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|ise
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ise
argument_list|)
throw|;
block|}
block|}
comment|/** Should only be used for tests to reset to any value */
DECL|method|resetLastInodeIdWithoutChecking (long newValue)
name|void
name|resetLastInodeIdWithoutChecking
parameter_list|(
name|long
name|newValue
parameter_list|)
block|{
name|inodeId
operator|.
name|setCurrentValue
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
DECL|method|getAttributes (INodesInPath iip)
name|INodeAttributes
name|getAttributes
parameter_list|(
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
name|INode
name|node
init|=
name|FSDirectory
operator|.
name|resolveLastINode
argument_list|(
name|iip
argument_list|)
decl_stmt|;
name|int
name|snapshot
init|=
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
name|INodeAttributes
name|nodeAttrs
init|=
name|node
operator|.
name|getSnapshotINode
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|NameNode
operator|.
name|getRemoteUser
argument_list|()
decl_stmt|;
name|INodeAttributeProvider
name|ap
init|=
name|this
operator|.
name|getUserFilteredAttributeProvider
argument_list|(
name|ugi
argument_list|)
decl_stmt|;
if|if
condition|(
name|ap
operator|!=
literal|null
condition|)
block|{
comment|// permission checking sends the full components array including the
comment|// first empty component for the root.  however file status
comment|// related calls are expected to strip out the root component according
comment|// to TestINodeAttributeProvider.
name|byte
index|[]
index|[]
name|components
init|=
name|iip
operator|.
name|getPathComponents
argument_list|()
decl_stmt|;
name|components
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|components
argument_list|,
literal|1
argument_list|,
name|components
operator|.
name|length
argument_list|)
expr_stmt|;
name|nodeAttrs
operator|=
name|ap
operator|.
name|getAttributes
argument_list|(
name|components
argument_list|,
name|nodeAttrs
argument_list|)
expr_stmt|;
block|}
return|return
name|nodeAttrs
return|;
block|}
block|}
end_class

end_unit

