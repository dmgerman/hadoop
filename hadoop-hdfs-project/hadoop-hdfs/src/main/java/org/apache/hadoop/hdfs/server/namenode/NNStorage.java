begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|InconsistentFSStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|IncorrectVersionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|StorageErrorReporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|PersistentLongFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eclipse
operator|.
name|jetty
operator|.
name|util
operator|.
name|ajax
operator|.
name|JSON
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * NNStorage is responsible for management of the StorageDirectories used by  * the NameNode.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|NNStorage
specifier|public
class|class
name|NNStorage
extends|extends
name|Storage
implements|implements
name|Closeable
implements|,
name|StorageErrorReporter
block|{
DECL|field|DEPRECATED_MESSAGE_DIGEST_PROPERTY
specifier|static
specifier|final
name|String
name|DEPRECATED_MESSAGE_DIGEST_PROPERTY
init|=
literal|"imageMD5Digest"
decl_stmt|;
DECL|field|LOCAL_URI_SCHEME
specifier|static
specifier|final
name|String
name|LOCAL_URI_SCHEME
init|=
literal|"file"
decl_stmt|;
comment|/**    * The filenames used for storing the images.    */
DECL|enum|NameNodeFile
specifier|public
enum|enum
name|NameNodeFile
block|{
DECL|enumConstant|IMAGE
name|IMAGE
argument_list|(
literal|"fsimage"
argument_list|)
block|,
DECL|enumConstant|TIME
name|TIME
argument_list|(
literal|"fstime"
argument_list|)
block|,
comment|// from "old" pre-HDFS-1073 format
DECL|enumConstant|SEEN_TXID
name|SEEN_TXID
argument_list|(
literal|"seen_txid"
argument_list|)
block|,
DECL|enumConstant|EDITS
name|EDITS
argument_list|(
literal|"edits"
argument_list|)
block|,
DECL|enumConstant|IMAGE_NEW
name|IMAGE_NEW
argument_list|(
literal|"fsimage.ckpt"
argument_list|)
block|,
DECL|enumConstant|IMAGE_ROLLBACK
name|IMAGE_ROLLBACK
argument_list|(
literal|"fsimage_rollback"
argument_list|)
block|,
DECL|enumConstant|EDITS_NEW
name|EDITS_NEW
argument_list|(
literal|"edits.new"
argument_list|)
block|,
comment|// from "old" pre-HDFS-1073 format
DECL|enumConstant|EDITS_INPROGRESS
name|EDITS_INPROGRESS
argument_list|(
literal|"edits_inprogress"
argument_list|)
block|,
DECL|enumConstant|EDITS_TMP
name|EDITS_TMP
argument_list|(
literal|"edits_tmp"
argument_list|)
block|,
DECL|enumConstant|IMAGE_LEGACY_OIV
name|IMAGE_LEGACY_OIV
argument_list|(
literal|"fsimage_legacy_oiv"
argument_list|)
block|;
comment|// For pre-PB format
DECL|field|fileName
specifier|private
name|String
name|fileName
init|=
literal|null
decl_stmt|;
DECL|method|NameNodeFile (String name)
name|NameNodeFile
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|fileName
operator|=
name|name
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|fileName
return|;
block|}
block|}
comment|/**    * Implementation of StorageDirType specific to namenode storage    * A Storage directory could be of type IMAGE which stores only fsimage,    * or of type EDITS which stores edits or of type IMAGE_AND_EDITS which    * stores both fsimage and edits.    */
annotation|@
name|VisibleForTesting
DECL|enum|NameNodeDirType
specifier|public
enum|enum
name|NameNodeDirType
implements|implements
name|StorageDirType
block|{
DECL|enumConstant|UNDEFINED
name|UNDEFINED
block|,
DECL|enumConstant|IMAGE
name|IMAGE
block|,
DECL|enumConstant|EDITS
name|EDITS
block|,
DECL|enumConstant|IMAGE_AND_EDITS
name|IMAGE_AND_EDITS
block|;
annotation|@
name|Override
DECL|method|getStorageDirType ()
specifier|public
name|StorageDirType
name|getStorageDirType
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|isOfType (StorageDirType type)
specifier|public
name|boolean
name|isOfType
parameter_list|(
name|StorageDirType
name|type
parameter_list|)
block|{
return|return
operator|(
name|this
operator|==
name|IMAGE_AND_EDITS
operator|)
operator|&&
operator|(
name|type
operator|==
name|IMAGE
operator|||
name|type
operator|==
name|EDITS
operator|)
operator|||
name|this
operator|==
name|type
return|;
block|}
block|}
DECL|field|blockpoolID
specifier|protected
name|String
name|blockpoolID
init|=
literal|""
decl_stmt|;
comment|// id of the block pool
comment|/**    * Flag that controls if we try to restore failed storages.    */
DECL|field|restoreFailedStorage
specifier|private
name|boolean
name|restoreFailedStorage
init|=
literal|false
decl_stmt|;
DECL|field|restorationLock
specifier|private
specifier|final
name|Object
name|restorationLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|disablePreUpgradableLayoutCheck
specifier|private
name|boolean
name|disablePreUpgradableLayoutCheck
init|=
literal|false
decl_stmt|;
comment|/**    * TxId of the last transaction that was included in the most    * recent fsimage file. This does not include any transactions    * that have since been written to the edit log.    */
DECL|field|mostRecentCheckpointTxId
specifier|protected
specifier|volatile
name|long
name|mostRecentCheckpointTxId
init|=
name|HdfsServerConstants
operator|.
name|INVALID_TXID
decl_stmt|;
comment|/**    * Time of the last checkpoint, in milliseconds since the epoch.    */
DECL|field|mostRecentCheckpointTime
specifier|private
name|long
name|mostRecentCheckpointTime
init|=
literal|0
decl_stmt|;
comment|/**    * List of failed (and thus removed) storages.    */
DECL|field|removedStorageDirs
specifier|final
specifier|protected
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|removedStorageDirs
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Properties from old layout versions that may be needed    * during upgrade only.    */
DECL|field|deprecatedProperties
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|deprecatedProperties
decl_stmt|;
comment|/**    * Name directories size for metric.    */
DECL|field|nameDirSizeMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|nameDirSizeMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Construct the NNStorage.    * @param conf Namenode configuration.    * @param imageDirs Directories the image can be stored in.    * @param editsDirs Directories the editlog can be stored in.    * @throws IOException if any directories are inaccessible.    */
DECL|method|NNStorage (Configuration conf, Collection<URI> imageDirs, Collection<URI> editsDirs)
specifier|public
name|NNStorage
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|imageDirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|NodeType
operator|.
name|NAME_NODE
argument_list|)
expr_stmt|;
name|storageDirs
operator|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
expr_stmt|;
comment|// this may modify the editsDirs, so copy before passing in
name|setStorageDirectories
argument_list|(
name|imageDirs
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|editsDirs
argument_list|)
argument_list|,
name|FSNamesystem
operator|.
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|//Update NameDirSize metric value after NN start
name|updateNameDirSize
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
comment|// Storage
DECL|method|isPreUpgradableLayout (StorageDirectory sd)
specifier|public
name|boolean
name|isPreUpgradableLayout
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|disablePreUpgradableLayoutCheck
condition|)
block|{
return|return
literal|false
return|;
block|}
name|File
name|oldImageDir
init|=
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"image"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldImageDir
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check the layout version inside the image file
name|File
name|oldF
init|=
operator|new
name|File
argument_list|(
name|oldImageDir
argument_list|,
literal|"fsimage"
argument_list|)
decl_stmt|;
name|RandomAccessFile
name|oldFile
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|oldF
argument_list|,
literal|"rws"
argument_list|)
decl_stmt|;
try|try
block|{
name|oldFile
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|oldVersion
init|=
name|oldFile
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|oldFile
operator|.
name|close
argument_list|()
expr_stmt|;
name|oldFile
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|oldVersion
operator|<
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|oldFile
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
comment|// Closeable
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|unlockAll
argument_list|()
expr_stmt|;
name|storageDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Set flag whether an attempt should be made to restore failed storage    * directories at the next available oppurtuinity.    *    * @param val Whether restoration attempt should be made.    */
DECL|method|setRestoreFailedStorage (boolean val)
name|void
name|setRestoreFailedStorage
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"set restore failed storage to "
operator|+
name|val
argument_list|)
expr_stmt|;
name|restoreFailedStorage
operator|=
name|val
expr_stmt|;
block|}
comment|/**    * @return Whether failed storage directories are to be restored.    */
DECL|method|getRestoreFailedStorage ()
name|boolean
name|getRestoreFailedStorage
parameter_list|()
block|{
return|return
name|restoreFailedStorage
return|;
block|}
comment|/**    * See if any of removed storages is "writable" again, and can be returned    * into service.    */
DECL|method|attemptRestoreRemovedStorage ()
name|void
name|attemptRestoreRemovedStorage
parameter_list|()
block|{
comment|// if directory is "alive" - copy the images there...
if|if
condition|(
operator|!
name|restoreFailedStorage
operator|||
name|removedStorageDirs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
comment|//nothing to restore
block|}
comment|/* We don't want more than one thread trying to restore at a time */
synchronized|synchronized
init|(
name|this
operator|.
name|restorationLock
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NNStorage.attemptRestoreRemovedStorage: check removed(failed) "
operator|+
literal|"storage. removedStorages size = "
operator|+
name|removedStorageDirs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|this
operator|.
name|removedStorageDirs
control|)
block|{
name|File
name|root
init|=
name|sd
operator|.
name|getRoot
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"currently disabled dir "
operator|+
name|root
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|"; type="
operator|+
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|+
literal|";canwrite="
operator|+
name|FileUtil
operator|.
name|canWrite
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|.
name|exists
argument_list|()
operator|&&
name|FileUtil
operator|.
name|canWrite
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"restoring dir "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|addStorageDir
argument_list|(
name|sd
argument_list|)
expr_stmt|;
comment|// restore
name|this
operator|.
name|removedStorageDirs
operator|.
name|remove
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * @return A list of storage directories which are in the errored state.    */
DECL|method|getRemovedStorageDirs ()
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|getRemovedStorageDirs
parameter_list|()
block|{
return|return
name|this
operator|.
name|removedStorageDirs
return|;
block|}
comment|/**    * See {@link NNStorage#setStorageDirectories(Collection, Collection, Collection)}.    */
annotation|@
name|VisibleForTesting
DECL|method|setStorageDirectories (Collection<URI> fsNameDirs, Collection<URI> fsEditsDirs)
specifier|synchronized
name|void
name|setStorageDirectories
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|fsNameDirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|fsEditsDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|setStorageDirectories
argument_list|(
name|fsNameDirs
argument_list|,
name|fsEditsDirs
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the storage directories which will be used. This should only ever be    * called from inside NNStorage. However, it needs to remain package private    * for testing, as StorageDirectories need to be reinitialised after using    * Mockito.spy() on this class, as Mockito doesn't work well with inner    * classes, such as StorageDirectory in this case.    *    * Synchronized due to initialization of storageDirs and removedStorageDirs.    *    * @param fsNameDirs Locations to store images.    * @param fsEditsDirs Locations to store edit logs.    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|setStorageDirectories (Collection<URI> fsNameDirs, Collection<URI> fsEditsDirs, Collection<URI> sharedEditsDirs)
specifier|synchronized
name|void
name|setStorageDirectories
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|fsNameDirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|fsEditsDirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|sharedEditsDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|storageDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|removedStorageDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Add all name dirs with appropriate NameNodeDirType
for|for
control|(
name|URI
name|dirName
range|:
name|fsNameDirs
control|)
block|{
name|checkSchemeConsistency
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
name|boolean
name|isAlsoEdits
init|=
literal|false
decl_stmt|;
for|for
control|(
name|URI
name|editsDirName
range|:
name|fsEditsDirs
control|)
block|{
if|if
condition|(
name|editsDirName
operator|.
name|compareTo
argument_list|(
name|dirName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isAlsoEdits
operator|=
literal|true
expr_stmt|;
name|fsEditsDirs
operator|.
name|remove
argument_list|(
name|editsDirName
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|NameNodeDirType
name|dirType
init|=
operator|(
name|isAlsoEdits
operator|)
condition|?
name|NameNodeDirType
operator|.
name|IMAGE_AND_EDITS
else|:
name|NameNodeDirType
operator|.
name|IMAGE
decl_stmt|;
comment|// Add to the list of storage directories, only if the
comment|// URI is of type file://
if|if
condition|(
name|dirName
operator|.
name|getScheme
argument_list|()
operator|.
name|compareTo
argument_list|(
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|addStorageDir
argument_list|(
operator|new
name|StorageDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|dirName
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|dirType
argument_list|,
name|sharedEditsDirs
operator|.
name|contains
argument_list|(
name|dirName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Don't lock the dir if it's shared.
block|}
block|}
comment|// Add edits dirs if they are different from name dirs
for|for
control|(
name|URI
name|dirName
range|:
name|fsEditsDirs
control|)
block|{
name|checkSchemeConsistency
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
comment|// Add to the list of storage directories, only if the
comment|// URI is of type file://
if|if
condition|(
name|dirName
operator|.
name|getScheme
argument_list|()
operator|.
name|compareTo
argument_list|(
literal|"file"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|addStorageDir
argument_list|(
operator|new
name|StorageDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|dirName
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|sharedEditsDirs
operator|.
name|contains
argument_list|(
name|dirName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Return the storage directory corresponding to the passed URI.    * @param uri URI of a storage directory    * @return The matching storage directory or null if none found    */
DECL|method|getStorageDirectory (URI uri)
specifier|public
name|StorageDirectory
name|getStorageDirectory
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
try|try
block|{
name|uri
operator|=
name|Util
operator|.
name|fileAsURI
argument_list|(
operator|new
name|File
argument_list|(
name|uri
argument_list|)
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|Util
operator|.
name|fileAsURI
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|uri
argument_list|)
condition|)
block|{
return|return
name|sd
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error converting file to URI"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Checks the consistency of a URI, in particular if the scheme    * is specified.    * @param u URI whose consistency is being checked.    */
DECL|method|checkSchemeConsistency (URI u)
specifier|private
specifier|static
name|void
name|checkSchemeConsistency
parameter_list|(
name|URI
name|u
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|scheme
init|=
name|u
operator|.
name|getScheme
argument_list|()
decl_stmt|;
comment|// the URI should have a proper scheme
if|if
condition|(
name|scheme
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Undefined scheme for "
operator|+
name|u
argument_list|)
throw|;
block|}
block|}
comment|/**    * Retrieve current directories of type IMAGE.    * @return Collection of URI representing image directories    * @throws IOException in case of URI processing error    */
DECL|method|getImageDirectories ()
name|Collection
argument_list|<
name|URI
argument_list|>
name|getImageDirectories
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getDirectories
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
return|;
block|}
comment|/**    * Retrieve current directories of type EDITS.    * @return Collection of URI representing edits directories    * @throws IOException in case of URI processing error    */
DECL|method|getEditsDirectories ()
name|Collection
argument_list|<
name|URI
argument_list|>
name|getEditsDirectories
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getDirectories
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
return|;
block|}
comment|/**    * Return number of storage directories of the given type.    * @param dirType directory type    * @return number of storage directories of type dirType    */
DECL|method|getNumStorageDirs (NameNodeDirType dirType)
name|int
name|getNumStorageDirs
parameter_list|(
name|NameNodeDirType
name|dirType
parameter_list|)
block|{
if|if
condition|(
name|dirType
operator|==
literal|null
condition|)
block|{
return|return
name|getNumStorageDirs
argument_list|()
return|;
block|}
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
name|dirType
argument_list|)
decl_stmt|;
name|int
name|numDirs
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
name|it
operator|.
name|next
argument_list|()
control|)
block|{
name|numDirs
operator|++
expr_stmt|;
block|}
return|return
name|numDirs
return|;
block|}
comment|/**    * Return the list of locations being used for a specific purpose.    * i.e. Image or edit log storage.    *    * @param dirType Purpose of locations requested.    * @throws IOException    */
DECL|method|getDirectories (NameNodeDirType dirType)
name|Collection
argument_list|<
name|URI
argument_list|>
name|getDirectories
parameter_list|(
name|NameNodeDirType
name|dirType
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|URI
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
operator|(
name|dirType
operator|==
literal|null
operator|)
condition|?
name|dirIterator
argument_list|()
else|:
name|dirIterator
argument_list|(
name|dirType
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|list
operator|.
name|add
argument_list|(
name|Util
operator|.
name|fileAsURI
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Exception while processing "
operator|+
literal|"StorageDirectory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**    * Determine the last transaction ID noted in this storage directory.    * This txid is stored in a special seen_txid file since it might not    * correspond to the latest image or edit log. For example, an image-only    * directory will have this txid incremented when edits logs roll, even    * though the edits logs are in a different directory.    *    * @param sd StorageDirectory to check    * @return If file exists and can be read, last recorded txid. If not, 0L.    * @throws IOException On errors processing file pointed to by sd    */
DECL|method|readTransactionIdFile (StorageDirectory sd)
specifier|static
name|long
name|readTransactionIdFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|txidFile
init|=
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|SEEN_TXID
argument_list|)
decl_stmt|;
return|return
name|PersistentLongFile
operator|.
name|readFile
argument_list|(
name|txidFile
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Write last checkpoint time into a separate file.    * @param sd storage directory    * @throws IOException    */
DECL|method|writeTransactionIdFile (StorageDirectory sd, long txid)
name|void
name|writeTransactionIdFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|long
name|txid
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|txid
operator|>=
literal|0
argument_list|,
literal|"bad txid: "
operator|+
name|txid
argument_list|)
expr_stmt|;
name|File
name|txIdFile
init|=
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|SEEN_TXID
argument_list|)
decl_stmt|;
name|PersistentLongFile
operator|.
name|writeFile
argument_list|(
name|txIdFile
argument_list|,
name|txid
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the transaction ID and time of the last checkpoint.    *     * @param txid transaction id of the last checkpoint    * @param time time of the last checkpoint, in millis since the epoch    */
DECL|method|setMostRecentCheckpointInfo (long txid, long time)
name|void
name|setMostRecentCheckpointInfo
parameter_list|(
name|long
name|txid
parameter_list|,
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|mostRecentCheckpointTxId
operator|=
name|txid
expr_stmt|;
name|this
operator|.
name|mostRecentCheckpointTime
operator|=
name|time
expr_stmt|;
block|}
comment|/**    * @return the transaction ID of the last checkpoint.    */
DECL|method|getMostRecentCheckpointTxId ()
specifier|public
name|long
name|getMostRecentCheckpointTxId
parameter_list|()
block|{
return|return
name|mostRecentCheckpointTxId
return|;
block|}
comment|/**    * @return the time of the most recent checkpoint in millis since the epoch.    */
DECL|method|getMostRecentCheckpointTime ()
name|long
name|getMostRecentCheckpointTime
parameter_list|()
block|{
return|return
name|mostRecentCheckpointTime
return|;
block|}
comment|/**    * Write a small file in all available storage directories that    * indicates that the namespace has reached some given transaction ID.    *     * This is used when the image is loaded to avoid accidental rollbacks    * in the case where an edit log is fully deleted but there is no    * checkpoint. See TestNameEditsConfigs.testNameEditsConfigsFailure()    * @param txid the txid that has been reached    */
DECL|method|writeTransactionIdFileToStorage (long txid)
specifier|public
name|void
name|writeTransactionIdFileToStorage
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
name|writeTransactionIdFileToStorage
argument_list|(
name|txid
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write a small file in all available storage directories that    * indicates that the namespace has reached some given transaction ID.    *    * This is used when the image is loaded to avoid accidental rollbacks    * in the case where an edit log is fully deleted but there is no    * checkpoint. See TestNameEditsConfigs.testNameEditsConfigsFailure()    * @param txid the txid that has been reached    * @param type the type of directory    */
DECL|method|writeTransactionIdFileToStorage (long txid, NameNodeDirType type)
specifier|public
name|void
name|writeTransactionIdFileToStorage
parameter_list|(
name|long
name|txid
parameter_list|,
name|NameNodeDirType
name|type
parameter_list|)
block|{
comment|// Write txid marker in all storage directories
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
name|type
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|writeTransactionIdFile
argument_list|(
name|sd
argument_list|,
name|txid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Close any edits stream associated with this dir and remove directory
name|LOG
operator|.
name|warn
argument_list|(
literal|"writeTransactionIdToStorage failed on "
operator|+
name|sd
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|reportErrorsOnDirectory
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Return the name of the image file that is uploaded by periodic    * checkpointing.    *    * @return List of filenames to save checkpoints to.    */
DECL|method|getFsImageNameCheckpoint (long txid)
specifier|public
name|File
index|[]
name|getFsImageNameCheckpoint
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|getStorageFile
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|,
name|txid
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|File
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * @return The first image file with the given txid and image type.    */
DECL|method|getFsImageName (long txid, NameNodeFile nnf)
specifier|public
name|File
name|getFsImageName
parameter_list|(
name|long
name|txid
parameter_list|,
name|NameNodeFile
name|nnf
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|File
name|fsImage
init|=
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|nnf
argument_list|,
name|txid
argument_list|)
decl_stmt|;
if|if
condition|(
name|FileUtil
operator|.
name|canRead
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
operator|&&
name|fsImage
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|fsImage
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @return The first image file whose txid is the same with the given txid and    * image type is one of the given types.    */
DECL|method|getFsImage (long txid, EnumSet<NameNodeFile> nnfs)
specifier|public
name|File
name|getFsImage
parameter_list|(
name|long
name|txid
parameter_list|,
name|EnumSet
argument_list|<
name|NameNodeFile
argument_list|>
name|nnfs
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|NameNodeFile
name|nnf
range|:
name|nnfs
control|)
block|{
name|File
name|fsImage
init|=
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|nnf
argument_list|,
name|txid
argument_list|)
decl_stmt|;
if|if
condition|(
name|FileUtil
operator|.
name|canRead
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
operator|&&
name|fsImage
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|fsImage
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getFsImageName (long txid)
specifier|public
name|File
name|getFsImageName
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
return|return
name|getFsImageName
argument_list|(
name|txid
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
return|;
block|}
DECL|method|getHighestFsImageName ()
specifier|public
name|File
name|getHighestFsImageName
parameter_list|()
block|{
return|return
name|getFsImageName
argument_list|(
name|getMostRecentCheckpointTxId
argument_list|()
argument_list|)
return|;
block|}
comment|/** Create new dfs name directory.  Caution: this destroys all files    * in this filesystem. */
DECL|method|format (StorageDirectory sd)
specifier|private
name|void
name|format
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|sd
operator|.
name|clearDirectory
argument_list|()
expr_stmt|;
comment|// create currrent dir
name|writeProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|writeTransactionIdFile
argument_list|(
name|sd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" has been successfully formatted."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Format all available storage directories.    */
DECL|method|format (NamespaceInfo nsInfo)
specifier|public
name|void
name|format
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
operator|==
literal|0
operator|||
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
operator|==
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
argument_list|,
literal|"Bad layout version: %s"
argument_list|,
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|setStorageInfo
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockpoolID
operator|=
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|format
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|newNamespaceInfo ()
specifier|public
specifier|static
name|NamespaceInfo
name|newNamespaceInfo
parameter_list|()
throws|throws
name|UnknownHostException
block|{
return|return
operator|new
name|NamespaceInfo
argument_list|(
name|newNamespaceID
argument_list|()
argument_list|,
name|newClusterID
argument_list|()
argument_list|,
name|newBlockPoolID
argument_list|()
argument_list|,
name|Time
operator|.
name|now
argument_list|()
argument_list|)
return|;
block|}
DECL|method|format ()
specifier|public
name|void
name|format
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|layoutVersion
operator|=
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|format
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Generate new namespaceID.    *    * namespaceID is a persistent attribute of the namespace.    * It is generated when the namenode is formatted and remains the same    * during the life cycle of the namenode.    * When a datanodes register they receive it as the registrationID,    * which is checked every time the datanode is communicating with the    * namenode. Datanodes that do not 'know' the namespaceID are rejected.    *    * @return new namespaceID    */
DECL|method|newNamespaceID ()
specifier|private
specifier|static
name|int
name|newNamespaceID
parameter_list|()
block|{
name|int
name|newID
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|newID
operator|==
literal|0
condition|)
block|{
name|newID
operator|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
literal|0x7FFFFFFF
argument_list|)
expr_stmt|;
comment|// use 31 bits
block|}
return|return
name|newID
return|;
block|}
annotation|@
name|Override
comment|// Storage
DECL|method|setFieldsFromProperties ( Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setFieldsFromProperties
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|setFieldsFromProperties
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|layoutVersion
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NameNode directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is not formatted."
argument_list|)
throw|;
block|}
comment|// Set Block pool ID in version with federation support
if|if
condition|(
name|NameNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|LayoutVersion
operator|.
name|Feature
operator|.
name|FEDERATION
argument_list|,
name|getLayoutVersion
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|sbpid
init|=
name|props
operator|.
name|getProperty
argument_list|(
literal|"blockpoolID"
argument_list|)
decl_stmt|;
name|setBlockPoolID
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|sbpid
argument_list|)
expr_stmt|;
block|}
name|setDeprecatedPropertiesForUpgrade
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
DECL|method|readProperties (StorageDirectory sd, StartupOption startupOption)
name|void
name|readProperties
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|StartupOption
name|startupOption
parameter_list|)
throws|throws
name|IOException
block|{
name|Properties
name|props
init|=
name|readPropertiesFile
argument_list|(
name|sd
operator|.
name|getVersionFile
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|HdfsServerConstants
operator|.
name|RollingUpgradeStartupOption
operator|.
name|ROLLBACK
operator|.
name|matches
argument_list|(
name|startupOption
argument_list|)
condition|)
block|{
name|int
name|lv
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|getProperty
argument_list|(
name|props
argument_list|,
name|sd
argument_list|,
literal|"layoutVersion"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lv
operator|>
name|getServiceLayoutVersion
argument_list|()
condition|)
block|{
comment|// we should not use a newer version for rollingUpgrade rollback
throw|throw
operator|new
name|IncorrectVersionException
argument_list|(
name|getServiceLayoutVersion
argument_list|()
argument_list|,
name|lv
argument_list|,
literal|"storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
throw|;
block|}
name|props
operator|.
name|setProperty
argument_list|(
literal|"layoutVersion"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|setFieldsFromProperties
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
comment|/**    * Pull any properties out of the VERSION file that are from older    * versions of HDFS and only necessary during upgrade.    */
DECL|method|setDeprecatedPropertiesForUpgrade (Properties props)
specifier|private
name|void
name|setDeprecatedPropertiesForUpgrade
parameter_list|(
name|Properties
name|props
parameter_list|)
block|{
name|deprecatedProperties
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|String
name|md5
init|=
name|props
operator|.
name|getProperty
argument_list|(
name|DEPRECATED_MESSAGE_DIGEST_PROPERTY
argument_list|)
decl_stmt|;
if|if
condition|(
name|md5
operator|!=
literal|null
condition|)
block|{
name|deprecatedProperties
operator|.
name|put
argument_list|(
name|DEPRECATED_MESSAGE_DIGEST_PROPERTY
argument_list|,
name|md5
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return a property that was stored in an earlier version of HDFS.    *     * This should only be used during upgrades.    */
DECL|method|getDeprecatedProperty (String prop)
name|String
name|getDeprecatedProperty
parameter_list|(
name|String
name|prop
parameter_list|)
block|{
assert|assert
name|getLayoutVersion
argument_list|()
operator|>
name|HdfsServerConstants
operator|.
name|NAMENODE_LAYOUT_VERSION
operator|:
literal|"getDeprecatedProperty should only be done when loading "
operator|+
literal|"storage from past versions during upgrade."
assert|;
return|return
name|deprecatedProperties
operator|.
name|get
argument_list|(
name|prop
argument_list|)
return|;
block|}
comment|/**    * Write version file into the storage directory.    *    * The version file should always be written last.    * Missing or corrupted version file indicates that    * the checkpoint is not valid.    *    * @param sd storage directory    * @throws IOException    */
annotation|@
name|Override
comment|// Storage
DECL|method|setPropertiesFromFields (Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setPropertiesFromFields
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|setPropertiesFromFields
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
comment|// Set blockpoolID in version with federation support
if|if
condition|(
name|NameNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|LayoutVersion
operator|.
name|Feature
operator|.
name|FEDERATION
argument_list|,
name|getLayoutVersion
argument_list|()
argument_list|)
condition|)
block|{
name|props
operator|.
name|setProperty
argument_list|(
literal|"blockpoolID"
argument_list|,
name|blockpoolID
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getStorageFile (StorageDirectory sd, NameNodeFile type, long imageTxId)
specifier|static
name|File
name|getStorageFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|NameNodeFile
name|type
parameter_list|,
name|long
name|imageTxId
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"%s_%019d"
argument_list|,
name|type
operator|.
name|getName
argument_list|()
argument_list|,
name|imageTxId
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get a storage file for one of the files that doesn't need a txid associated    * (e.g version, seen_txid).    */
DECL|method|getStorageFile (StorageDirectory sd, NameNodeFile type)
specifier|static
name|File
name|getStorageFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|NameNodeFile
name|type
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|type
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getCheckpointImageFileName (long txid)
specifier|public
specifier|static
name|String
name|getCheckpointImageFileName
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
return|return
name|getNameNodeFileName
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|,
name|txid
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getImageFileName (long txid)
specifier|public
specifier|static
name|String
name|getImageFileName
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
return|return
name|getNameNodeFileName
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
name|txid
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getRollbackImageFileName (long txid)
specifier|public
specifier|static
name|String
name|getRollbackImageFileName
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
return|return
name|getNameNodeFileName
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE_ROLLBACK
argument_list|,
name|txid
argument_list|)
return|;
block|}
DECL|method|getLegacyOIVImageFileName (long txid)
specifier|public
specifier|static
name|String
name|getLegacyOIVImageFileName
parameter_list|(
name|long
name|txid
parameter_list|)
block|{
return|return
name|getNameNodeFileName
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE_LEGACY_OIV
argument_list|,
name|txid
argument_list|)
return|;
block|}
DECL|method|getNameNodeFileName (NameNodeFile nnf, long txid)
specifier|private
specifier|static
name|String
name|getNameNodeFileName
parameter_list|(
name|NameNodeFile
name|nnf
parameter_list|,
name|long
name|txid
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s_%019d"
argument_list|,
name|nnf
operator|.
name|getName
argument_list|()
argument_list|,
name|txid
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getInProgressEditsFileName (long startTxId)
specifier|public
specifier|static
name|String
name|getInProgressEditsFileName
parameter_list|(
name|long
name|startTxId
parameter_list|)
block|{
return|return
name|getNameNodeFileName
argument_list|(
name|NameNodeFile
operator|.
name|EDITS_INPROGRESS
argument_list|,
name|startTxId
argument_list|)
return|;
block|}
DECL|method|getInProgressEditsFile (StorageDirectory sd, long startTxId)
specifier|static
name|File
name|getInProgressEditsFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|long
name|startTxId
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|getInProgressEditsFileName
argument_list|(
name|startTxId
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getFinalizedEditsFile (StorageDirectory sd, long startTxId, long endTxId)
specifier|static
name|File
name|getFinalizedEditsFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|long
name|startTxId
parameter_list|,
name|long
name|endTxId
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|getFinalizedEditsFileName
argument_list|(
name|startTxId
argument_list|,
name|endTxId
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getTemporaryEditsFile (StorageDirectory sd, long startTxId, long endTxId, long timestamp)
specifier|static
name|File
name|getTemporaryEditsFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|long
name|startTxId
parameter_list|,
name|long
name|endTxId
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|getTemporaryEditsFileName
argument_list|(
name|startTxId
argument_list|,
name|endTxId
argument_list|,
name|timestamp
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getImageFile (StorageDirectory sd, NameNodeFile nnf, long txid)
specifier|static
name|File
name|getImageFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|NameNodeFile
name|nnf
parameter_list|,
name|long
name|txid
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|getNameNodeFileName
argument_list|(
name|nnf
argument_list|,
name|txid
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getFinalizedEditsFileName (long startTxId, long endTxId)
specifier|public
specifier|static
name|String
name|getFinalizedEditsFileName
parameter_list|(
name|long
name|startTxId
parameter_list|,
name|long
name|endTxId
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s_%019d-%019d"
argument_list|,
name|NameNodeFile
operator|.
name|EDITS
operator|.
name|getName
argument_list|()
argument_list|,
name|startTxId
argument_list|,
name|endTxId
argument_list|)
return|;
block|}
DECL|method|getTemporaryEditsFileName (long startTxId, long endTxId, long timestamp)
specifier|public
specifier|static
name|String
name|getTemporaryEditsFileName
parameter_list|(
name|long
name|startTxId
parameter_list|,
name|long
name|endTxId
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s_%019d-%019d_%019d"
argument_list|,
name|NameNodeFile
operator|.
name|EDITS_TMP
operator|.
name|getName
argument_list|()
argument_list|,
name|startTxId
argument_list|,
name|endTxId
argument_list|,
name|timestamp
argument_list|)
return|;
block|}
comment|/**    * Return the first readable finalized edits file for the given txid.    */
DECL|method|findFinalizedEditsFile (long startTxId, long endTxId)
name|File
name|findFinalizedEditsFile
parameter_list|(
name|long
name|startTxId
parameter_list|,
name|long
name|endTxId
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|ret
init|=
name|findFile
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|getFinalizedEditsFileName
argument_list|(
name|startTxId
argument_list|,
name|endTxId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No edits file for txid "
operator|+
name|startTxId
operator|+
literal|"-"
operator|+
name|endTxId
operator|+
literal|" exists!"
argument_list|)
throw|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Return the first readable image file for the given txid and image type, or    * null if no such image can be found.    */
DECL|method|findImageFile (NameNodeFile nnf, long txid)
name|File
name|findImageFile
parameter_list|(
name|NameNodeFile
name|nnf
parameter_list|,
name|long
name|txid
parameter_list|)
block|{
return|return
name|findFile
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|,
name|getNameNodeFileName
argument_list|(
name|nnf
argument_list|,
name|txid
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return the first readable storage file of the given name    * across any of the 'current' directories in SDs of the    * given type, or null if no such file exists.    */
DECL|method|findFile (NameNodeDirType dirType, String name)
specifier|private
name|File
name|findFile
parameter_list|(
name|NameNodeDirType
name|dirType
parameter_list|,
name|String
name|name
parameter_list|)
block|{
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|dirIterable
argument_list|(
name|dirType
argument_list|)
control|)
block|{
name|File
name|candidate
init|=
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|FileUtil
operator|.
name|canRead
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
operator|&&
name|candidate
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|candidate
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Disable the check for pre-upgradable layouts. Needed for BackupImage.    * @param val Whether to disable the preupgradeable layout check.    */
DECL|method|setDisablePreUpgradableLayoutCheck (boolean val)
name|void
name|setDisablePreUpgradableLayoutCheck
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|disablePreUpgradableLayoutCheck
operator|=
name|val
expr_stmt|;
block|}
comment|/**    * Marks a list of directories as having experienced an error.    *    * @param sds A list of storage directories to mark as errored.    */
DECL|method|reportErrorsOnDirectories (List<StorageDirectory> sds)
name|void
name|reportErrorsOnDirectories
parameter_list|(
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|sds
parameter_list|)
block|{
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|sds
control|)
block|{
name|reportErrorsOnDirectory
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Reports that a directory has experienced an error.    * Notifies listeners that the directory is no longer    * available.    *    * @param sd A storage directory to mark as errored.    */
DECL|method|reportErrorsOnDirectory (StorageDirectory sd)
specifier|private
name|void
name|reportErrorsOnDirectory
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error reported on storage directory "
operator|+
name|sd
argument_list|)
expr_stmt|;
name|String
name|lsd
init|=
name|listStorageDirectories
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"current list of storage dirs:"
operator|+
name|lsd
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"About to remove corresponding storage: "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to unlock bad storage directory: "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|storageDirs
operator|.
name|remove
argument_list|(
name|sd
argument_list|)
condition|)
block|{
name|this
operator|.
name|removedStorageDirs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
name|lsd
operator|=
name|listStorageDirectories
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"at the end current list of storage dirs:"
operator|+
name|lsd
argument_list|)
expr_stmt|;
block|}
comment|/**     * Processes the startup options for the clusterid and blockpoolid     * for the upgrade.     * @param startOpt Startup options     * @param layoutVersion Layout version for the upgrade     * @throws IOException    */
DECL|method|processStartupOptionsForUpgrade (StartupOption startOpt, int layoutVersion)
name|void
name|processStartupOptionsForUpgrade
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|int
name|layoutVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADE
operator|||
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADEONLY
condition|)
block|{
comment|// If upgrade from a release that does not support federation,
comment|// if clusterId is provided in the startupOptions use it.
comment|// Else generate a new cluster ID
if|if
condition|(
operator|!
name|NameNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|LayoutVersion
operator|.
name|Feature
operator|.
name|FEDERATION
argument_list|,
name|layoutVersion
argument_list|)
condition|)
block|{
if|if
condition|(
name|startOpt
operator|.
name|getClusterId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|startOpt
operator|.
name|setClusterId
argument_list|(
name|newClusterID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setClusterID
argument_list|(
name|startOpt
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|setBlockPoolID
argument_list|(
name|newBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Upgrade from one version of federation to another supported
comment|// version of federation doesn't require clusterID.
comment|// Warn the user if the current clusterid didn't match with the input
comment|// clusterid.
if|if
condition|(
name|startOpt
operator|.
name|getClusterId
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|startOpt
operator|.
name|getClusterId
argument_list|()
operator|.
name|equals
argument_list|(
name|getClusterID
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Clusterid mismatch - current clusterid: "
operator|+
name|getClusterID
argument_list|()
operator|+
literal|", Ignoring given clusterid: "
operator|+
name|startOpt
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Using clusterid: "
operator|+
name|getClusterID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Report that an IOE has occurred on some file which may    * or may not be within one of the NN image storage directories.    */
annotation|@
name|Override
DECL|method|reportErrorOnFile (File f)
specifier|public
name|void
name|reportErrorOnFile
parameter_list|(
name|File
name|f
parameter_list|)
block|{
comment|// We use getAbsolutePath here instead of getCanonicalPath since we know
comment|// that there is some IO problem on that drive.
comment|// getCanonicalPath may need to call stat() or readlink() and it's likely
comment|// those calls would fail due to the same underlying IO problem.
name|String
name|absPath
init|=
name|f
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storageDirs
control|)
block|{
name|String
name|dirPath
init|=
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dirPath
operator|.
name|endsWith
argument_list|(
name|File
operator|.
name|separator
argument_list|)
condition|)
block|{
name|dirPath
operator|+=
name|File
operator|.
name|separator
expr_stmt|;
block|}
if|if
condition|(
name|absPath
operator|.
name|startsWith
argument_list|(
name|dirPath
argument_list|)
condition|)
block|{
name|reportErrorsOnDirectory
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/**    * Generate new clusterID.    *     * clusterID is a persistent attribute of the cluster.    * It is generated when the cluster is created and remains the same    * during the life cycle of the cluster.  When a new name node is formated,    * if this is a new cluster, a new clusterID is geneated and stored.    * Subsequent name node must be given the same ClusterID during its format to    * be in the same cluster.    * When a datanode register it receive the clusterID and stick with it.    * If at any point, name node or data node tries to join another cluster, it     * will be rejected.    *     * @return new clusterID    */
DECL|method|newClusterID ()
specifier|public
specifier|static
name|String
name|newClusterID
parameter_list|()
block|{
return|return
literal|"CID-"
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|setClusterID (String cid)
name|void
name|setClusterID
parameter_list|(
name|String
name|cid
parameter_list|)
block|{
name|clusterID
operator|=
name|cid
expr_stmt|;
block|}
comment|/**    * Try to find current cluster id in the VERSION files.    * returns first cluster id found in any VERSION file    * null in case none found    * @return clusterId or null in case no cluster id found    */
DECL|method|determineClusterId ()
specifier|public
name|String
name|determineClusterId
parameter_list|()
block|{
name|String
name|cid
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|sdit
init|=
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
decl_stmt|;
while|while
condition|(
name|sdit
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|StorageDirectory
name|sd
init|=
name|sdit
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|Properties
name|props
init|=
name|readPropertiesFile
argument_list|(
name|sd
operator|.
name|getVersionFile
argument_list|()
argument_list|)
decl_stmt|;
name|cid
operator|=
name|props
operator|.
name|getProperty
argument_list|(
literal|"clusterID"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"current cluster id for sd="
operator|+
name|sd
operator|.
name|getCurrentDir
argument_list|()
operator|+
literal|";lv="
operator|+
name|layoutVersion
operator|+
literal|";cid="
operator|+
name|cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cid
operator|!=
literal|null
operator|&&
operator|!
name|cid
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
return|return
name|cid
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"this sd not available: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//ignore
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"couldn't find any VERSION file containing valid ClusterId"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Generate new blockpoolID.    *     * @return new blockpoolID    */
DECL|method|newBlockPoolID ()
specifier|static
name|String
name|newBlockPoolID
parameter_list|()
throws|throws
name|UnknownHostException
block|{
name|String
name|ip
decl_stmt|;
try|try
block|{
name|ip
operator|=
name|DNS
operator|.
name|getDefaultIP
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find ip address of \"default\" inteface."
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|int
name|rand
init|=
name|DFSUtil
operator|.
name|getSecureRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
return|return
literal|"BP-"
operator|+
name|rand
operator|+
literal|"-"
operator|+
name|ip
operator|+
literal|"-"
operator|+
name|Time
operator|.
name|now
argument_list|()
return|;
block|}
comment|/** Validate and set block pool ID. */
DECL|method|setBlockPoolID (String bpid)
specifier|public
name|void
name|setBlockPoolID
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|blockpoolID
operator|=
name|bpid
expr_stmt|;
block|}
comment|/** Validate and set block pool ID. */
DECL|method|setBlockPoolID (File storage, String bpid)
specifier|private
name|void
name|setBlockPoolID
parameter_list|(
name|File
name|storage
parameter_list|,
name|String
name|bpid
parameter_list|)
throws|throws
name|InconsistentFSStateException
block|{
if|if
condition|(
name|bpid
operator|==
literal|null
operator|||
name|bpid
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|storage
argument_list|,
literal|"file "
operator|+
name|Storage
operator|.
name|STORAGE_FILE_VERSION
operator|+
literal|" has no block pool Id."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|blockpoolID
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
operator|!
name|blockpoolID
operator|.
name|equals
argument_list|(
name|bpid
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|storage
argument_list|,
literal|"Unexepcted blockpoolID "
operator|+
name|bpid
operator|+
literal|" . Expected "
operator|+
name|blockpoolID
argument_list|)
throw|;
block|}
name|setBlockPoolID
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
DECL|method|getBlockPoolID ()
specifier|public
name|String
name|getBlockPoolID
parameter_list|()
block|{
return|return
name|blockpoolID
return|;
block|}
comment|/**    * Iterate over all current storage directories, inspecting them    * with the given inspector.    */
DECL|method|inspectStorageDirs (FSImageStorageInspector inspector)
name|void
name|inspectStorageDirs
parameter_list|(
name|FSImageStorageInspector
name|inspector
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Process each of the storage directories to find the pair of
comment|// newest image file and edit file
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|inspector
operator|.
name|inspectDirectory
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Iterate over all of the storage dirs, reading their contents to determine    * their layout versions. Returns an FSImageStorageInspector which has    * inspected each directory.    *     *<b>Note:</b> this can mutate the storage info fields (ctime, version, etc).    * @throws IOException if no valid storage dirs are found or no valid layout    * version    */
DECL|method|readAndInspectDirs (EnumSet<NameNodeFile> fileTypes, StartupOption startupOption)
name|FSImageStorageInspector
name|readAndInspectDirs
parameter_list|(
name|EnumSet
argument_list|<
name|NameNodeFile
argument_list|>
name|fileTypes
parameter_list|,
name|StartupOption
name|startupOption
parameter_list|)
throws|throws
name|IOException
block|{
name|Integer
name|layoutVersion
init|=
literal|null
decl_stmt|;
name|boolean
name|multipleLV
init|=
literal|false
decl_stmt|;
name|StringBuilder
name|layoutVersions
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// First determine what range of layout versions we're going to inspect
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
literal|false
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sd
operator|.
name|getVersionFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
name|FSImage
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Storage directory "
operator|+
name|sd
operator|+
literal|" contains no VERSION file. Skipping..."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|readProperties
argument_list|(
name|sd
argument_list|,
name|startupOption
argument_list|)
expr_stmt|;
comment|// sets layoutVersion
name|int
name|lv
init|=
name|getLayoutVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|layoutVersion
operator|==
literal|null
condition|)
block|{
name|layoutVersion
operator|=
name|lv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|layoutVersion
operator|.
name|equals
argument_list|(
name|lv
argument_list|)
condition|)
block|{
name|multipleLV
operator|=
literal|true
expr_stmt|;
block|}
name|layoutVersions
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|lv
argument_list|)
operator|.
name|append
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|layoutVersion
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No storage directories contained VERSION"
operator|+
literal|" information"
argument_list|)
throw|;
block|}
if|if
condition|(
name|multipleLV
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Storage directories contain multiple layout versions: "
operator|+
name|layoutVersions
argument_list|)
throw|;
block|}
comment|// If the storage directories are with the new layout version
comment|// (ie edits_<txnid>) then use the new inspector, which will ignore
comment|// the old format dirs.
name|FSImageStorageInspector
name|inspector
decl_stmt|;
if|if
condition|(
name|NameNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|LayoutVersion
operator|.
name|Feature
operator|.
name|TXID_BASED_LAYOUT
argument_list|,
name|getLayoutVersion
argument_list|()
argument_list|)
condition|)
block|{
name|inspector
operator|=
operator|new
name|FSImageTransactionalStorageInspector
argument_list|(
name|fileTypes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inspector
operator|=
operator|new
name|FSImagePreTransactionalStorageInspector
argument_list|()
expr_stmt|;
block|}
name|inspectStorageDirs
argument_list|(
name|inspector
argument_list|)
expr_stmt|;
return|return
name|inspector
return|;
block|}
DECL|method|getNamespaceInfo ()
specifier|public
name|NamespaceInfo
name|getNamespaceInfo
parameter_list|()
block|{
return|return
operator|new
name|NamespaceInfo
argument_list|(
name|getNamespaceID
argument_list|()
argument_list|,
name|getClusterID
argument_list|()
argument_list|,
name|getBlockPoolID
argument_list|()
argument_list|,
name|getCTime
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getNNDirectorySize ()
specifier|public
name|String
name|getNNDirectorySize
parameter_list|()
block|{
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|nameDirSizeMap
argument_list|)
return|;
block|}
DECL|method|updateNameDirSize ()
specifier|public
name|void
name|updateNameDirSize
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|nnDirSizeMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sd
operator|.
name|isShared
argument_list|()
condition|)
block|{
name|nnDirSizeMap
operator|.
name|put
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|sd
operator|.
name|getDirecorySize
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|nameDirSizeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nameDirSizeMap
operator|.
name|putAll
argument_list|(
name|nnDirSizeMap
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write all data storage files.    * @throws IOException When all the storage directory fails to write    * VERSION file    */
annotation|@
name|Override
DECL|method|writeAll ()
specifier|public
name|void
name|writeAll
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|layoutVersion
operator|=
name|getServiceLayoutVersion
argument_list|()
expr_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storageDirs
control|)
block|{
try|try
block|{
name|writeProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error during write properties to the VERSION file to "
operator|+
name|sd
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|reportErrorsOnDirectory
argument_list|(
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storageDirs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All the storage failed while writing "
operator|+
literal|"properties to VERSION file"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

