begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|monotonicNow
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|AddBlockFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
operator|.
name|DFSNetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NodeBase
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * The class is responsible for choosing the desired number of targets  * for placing block replicas.  * The replica placement strategy is that if the writer is on a datanode,  * the 1st replica is placed on the local machine by default  * (By passing the {@link org.apache.hadoop.fs.CreateFlag#NO_LOCAL_WRITE} flag  * the client can request not to put a block replica on the local datanode.  * Subsequent replicas will still follow default block placement policy.).  * If the writer is not on a datanode, the 1st replica is placed on a random  * node.  * The 2nd replica is placed on a datanode that is on a different rack.  * The 3rd replica is placed on a datanode which is on a different node of the  * rack as the second replica.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockPlacementPolicyDefault
specifier|public
class|class
name|BlockPlacementPolicyDefault
extends|extends
name|BlockPlacementPolicy
block|{
DECL|field|enableDebugLogging
specifier|private
specifier|static
specifier|final
name|String
name|enableDebugLogging
init|=
literal|"For more information, please enable DEBUG log level on "
operator|+
name|BlockPlacementPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|" and "
operator|+
name|NetworkTopology
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
DECL|field|debugLoggingBuilder
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|StringBuilder
argument_list|>
name|debugLoggingBuilder
init|=
operator|new
name|ThreadLocal
argument_list|<
name|StringBuilder
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|StringBuilder
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|StringBuilder
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|HashMap
argument_list|<
name|NodeNotChosenReason
argument_list|,
name|Integer
argument_list|>
argument_list|>
DECL|field|CHOOSE_RANDOM_REASONS
name|CHOOSE_RANDOM_REASONS
init|=
name|ThreadLocal
operator|.
name|withInitial
argument_list|(
parameter_list|()
lambda|->
operator|new
name|HashMap
argument_list|<
name|NodeNotChosenReason
argument_list|,
name|Integer
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|enum|NodeNotChosenReason
specifier|private
enum|enum
name|NodeNotChosenReason
block|{
DECL|enumConstant|NOT_IN_SERVICE
name|NOT_IN_SERVICE
argument_list|(
literal|"the node is not in service"
argument_list|)
block|,
DECL|enumConstant|NODE_STALE
name|NODE_STALE
argument_list|(
literal|"the node is stale"
argument_list|)
block|,
DECL|enumConstant|NODE_TOO_BUSY
name|NODE_TOO_BUSY
argument_list|(
literal|"the node is too busy"
argument_list|)
block|,
DECL|enumConstant|TOO_MANY_NODES_ON_RACK
name|TOO_MANY_NODES_ON_RACK
argument_list|(
literal|"the rack has too many chosen nodes"
argument_list|)
block|,
DECL|enumConstant|NOT_ENOUGH_STORAGE_SPACE
name|NOT_ENOUGH_STORAGE_SPACE
argument_list|(
literal|"not enough storage space to place the block"
argument_list|)
block|;
DECL|field|text
specifier|private
specifier|final
name|String
name|text
decl_stmt|;
DECL|method|NodeNotChosenReason (final String logText)
name|NodeNotChosenReason
parameter_list|(
specifier|final
name|String
name|logText
parameter_list|)
block|{
name|text
operator|=
name|logText
expr_stmt|;
block|}
DECL|method|getText ()
specifier|private
name|String
name|getText
parameter_list|()
block|{
return|return
name|text
return|;
block|}
block|}
DECL|field|considerLoad
specifier|protected
name|boolean
name|considerLoad
decl_stmt|;
DECL|field|considerLoadFactor
specifier|protected
name|double
name|considerLoadFactor
decl_stmt|;
DECL|field|preferLocalNode
specifier|private
name|boolean
name|preferLocalNode
decl_stmt|;
DECL|field|clusterMap
specifier|protected
name|NetworkTopology
name|clusterMap
decl_stmt|;
DECL|field|host2datanodeMap
specifier|protected
name|Host2NodesMap
name|host2datanodeMap
decl_stmt|;
DECL|field|stats
specifier|private
name|FSClusterStats
name|stats
decl_stmt|;
DECL|field|heartbeatInterval
specifier|protected
name|long
name|heartbeatInterval
decl_stmt|;
comment|// interval for DataNode heartbeats
DECL|field|staleInterval
specifier|private
name|long
name|staleInterval
decl_stmt|;
comment|// interval used to identify stale DataNodes
comment|/**    * A miss of that many heartbeats is tolerated for replica deletion policy.    */
DECL|field|tolerateHeartbeatMultiplier
specifier|protected
name|int
name|tolerateHeartbeatMultiplier
decl_stmt|;
DECL|method|BlockPlacementPolicyDefault ()
specifier|protected
name|BlockPlacementPolicyDefault
parameter_list|()
block|{   }
annotation|@
name|Override
DECL|method|initialize (Configuration conf, FSClusterStats stats, NetworkTopology clusterMap, Host2NodesMap host2datanodeMap)
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSClusterStats
name|stats
parameter_list|,
name|NetworkTopology
name|clusterMap
parameter_list|,
name|Host2NodesMap
name|host2datanodeMap
parameter_list|)
block|{
name|this
operator|.
name|considerLoad
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_CONSIDERLOAD_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_CONSIDERLOAD_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|considerLoadFactor
operator|=
name|conf
operator|.
name|getDouble
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_CONSIDERLOAD_FACTOR
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_CONSIDERLOAD_FACTOR_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|stats
operator|=
name|stats
expr_stmt|;
name|this
operator|.
name|clusterMap
operator|=
name|clusterMap
expr_stmt|;
name|this
operator|.
name|host2datanodeMap
operator|=
name|host2datanodeMap
expr_stmt|;
name|this
operator|.
name|heartbeatInterval
operator|=
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
operator|*
literal|1000
expr_stmt|;
name|this
operator|.
name|tolerateHeartbeatMultiplier
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_TOLERATE_HEARTBEAT_MULTIPLIER_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_TOLERATE_HEARTBEAT_MULTIPLIER_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|staleInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STALE_DATANODE_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STALE_DATANODE_INTERVAL_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|preferLocalNode
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_BLOCKPLACEMENTPOLICY_DEFAULT_PREFER_LOCAL_NODE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_BLOCKPLACEMENTPOLICY_DEFAULT_PREFER_LOCAL_NODE_DEFAULT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|chooseTarget (String srcPath, int numOfReplicas, Node writer, List<DatanodeStorageInfo> chosenNodes, boolean returnChosenNodes, Set<Node> excludedNodes, long blocksize, final BlockStoragePolicy storagePolicy, EnumSet<AddBlockFlag> flags)
specifier|public
name|DatanodeStorageInfo
index|[]
name|chooseTarget
parameter_list|(
name|String
name|srcPath
parameter_list|,
name|int
name|numOfReplicas
parameter_list|,
name|Node
name|writer
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|chosenNodes
parameter_list|,
name|boolean
name|returnChosenNodes
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
specifier|final
name|BlockStoragePolicy
name|storagePolicy
parameter_list|,
name|EnumSet
argument_list|<
name|AddBlockFlag
argument_list|>
name|flags
parameter_list|)
block|{
return|return
name|chooseTarget
argument_list|(
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|chosenNodes
argument_list|,
name|returnChosenNodes
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|storagePolicy
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|chooseTarget (String src, int numOfReplicas, Node writer, Set<Node> excludedNodes, long blocksize, List<DatanodeDescriptor> favoredNodes, BlockStoragePolicy storagePolicy, EnumSet<AddBlockFlag> flags)
name|DatanodeStorageInfo
index|[]
name|chooseTarget
parameter_list|(
name|String
name|src
parameter_list|,
name|int
name|numOfReplicas
parameter_list|,
name|Node
name|writer
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|favoredNodes
parameter_list|,
name|BlockStoragePolicy
name|storagePolicy
parameter_list|,
name|EnumSet
argument_list|<
name|AddBlockFlag
argument_list|>
name|flags
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|favoredNodes
operator|==
literal|null
operator|||
name|favoredNodes
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Favored nodes not specified, fall back to regular block placement.
return|return
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|(
name|numOfReplicas
argument_list|)
argument_list|,
literal|false
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|storagePolicy
argument_list|,
name|flags
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|Node
argument_list|>
name|favoriteAndExcludedNodes
init|=
name|excludedNodes
operator|==
literal|null
condition|?
operator|new
name|HashSet
argument_list|<
name|Node
argument_list|>
argument_list|()
else|:
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|excludedNodes
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|StorageType
argument_list|>
name|requiredStorageTypes
init|=
name|storagePolicy
operator|.
name|chooseStorageTypes
argument_list|(
operator|(
name|short
operator|)
name|numOfReplicas
argument_list|)
decl_stmt|;
specifier|final
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
init|=
name|getRequiredStorageTypes
argument_list|(
name|requiredStorageTypes
argument_list|)
decl_stmt|;
comment|// Choose favored nodes
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|avoidStaleNodes
init|=
name|stats
operator|!=
literal|null
operator|&&
name|stats
operator|.
name|isAvoidingStaleDataNodesForWrite
argument_list|()
decl_stmt|;
name|int
name|maxNodesAndReplicas
index|[]
init|=
name|getMaxNodesPerRack
argument_list|(
literal|0
argument_list|,
name|numOfReplicas
argument_list|)
decl_stmt|;
name|numOfReplicas
operator|=
name|maxNodesAndReplicas
index|[
literal|0
index|]
expr_stmt|;
name|int
name|maxNodesPerRack
init|=
name|maxNodesAndReplicas
index|[
literal|1
index|]
decl_stmt|;
name|chooseFavouredNodes
argument_list|(
name|src
argument_list|,
name|numOfReplicas
argument_list|,
name|favoredNodes
argument_list|,
name|favoriteAndExcludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|size
argument_list|()
operator|<
name|numOfReplicas
condition|)
block|{
comment|// Not enough favored nodes, choose other nodes, based on block
comment|// placement policy (HDFS-9393).
name|numOfReplicas
operator|-=
name|results
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|results
control|)
block|{
comment|// add localMachine and related nodes to favoriteAndExcludedNodes
name|addToExcludedNodes
argument_list|(
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|favoriteAndExcludedNodes
argument_list|)
expr_stmt|;
block|}
name|DatanodeStorageInfo
index|[]
name|remainingTargets
init|=
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|(
name|numOfReplicas
argument_list|)
argument_list|,
literal|false
argument_list|,
name|favoriteAndExcludedNodes
argument_list|,
name|blocksize
argument_list|,
name|storagePolicy
argument_list|,
name|flags
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|remainingTargets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|remainingTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|getPipeline
argument_list|(
name|writer
argument_list|,
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeStorageInfo
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NotEnoughReplicasException
name|nr
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to choose with favored nodes (="
operator|+
name|favoredNodes
operator|+
literal|"), disregard favored nodes hint and retry."
argument_list|,
name|nr
argument_list|)
expr_stmt|;
block|}
comment|// Fall back to regular block placement disregarding favored nodes hint
return|return
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|(
name|numOfReplicas
argument_list|)
argument_list|,
literal|false
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|storagePolicy
argument_list|,
name|flags
argument_list|)
return|;
block|}
block|}
DECL|method|chooseFavouredNodes (String src, int numOfReplicas, List<DatanodeDescriptor> favoredNodes, Set<Node> favoriteAndExcludedNodes, long blocksize, int maxNodesPerRack, List<DatanodeStorageInfo> results, boolean avoidStaleNodes, EnumMap<StorageType, Integer> storageTypes)
specifier|protected
name|void
name|chooseFavouredNodes
parameter_list|(
name|String
name|src
parameter_list|,
name|int
name|numOfReplicas
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|favoredNodes
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|favoriteAndExcludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|int
name|maxNodesPerRack
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|boolean
name|avoidStaleNodes
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
parameter_list|)
throws|throws
name|NotEnoughReplicasException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|favoredNodes
operator|.
name|size
argument_list|()
operator|&&
name|results
operator|.
name|size
argument_list|()
operator|<
name|numOfReplicas
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeDescriptor
name|favoredNode
init|=
name|favoredNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Choose a single node which is local to favoredNode.
comment|// 'results' is updated within chooseLocalNode
specifier|final
name|DatanodeStorageInfo
name|target
init|=
name|chooseLocalStorage
argument_list|(
name|favoredNode
argument_list|,
name|favoriteAndExcludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find a target for file "
operator|+
name|src
operator|+
literal|" with favored node "
operator|+
name|favoredNode
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|favoriteAndExcludedNodes
operator|.
name|add
argument_list|(
name|target
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** This is the implementation. */
DECL|method|chooseTarget (int numOfReplicas, Node writer, List<DatanodeStorageInfo> chosenStorage, boolean returnChosenNodes, Set<Node> excludedNodes, long blocksize, final BlockStoragePolicy storagePolicy, EnumSet<AddBlockFlag> addBlockFlags)
specifier|private
name|DatanodeStorageInfo
index|[]
name|chooseTarget
parameter_list|(
name|int
name|numOfReplicas
parameter_list|,
name|Node
name|writer
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|chosenStorage
parameter_list|,
name|boolean
name|returnChosenNodes
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
specifier|final
name|BlockStoragePolicy
name|storagePolicy
parameter_list|,
name|EnumSet
argument_list|<
name|AddBlockFlag
argument_list|>
name|addBlockFlags
parameter_list|)
block|{
if|if
condition|(
name|numOfReplicas
operator|==
literal|0
operator|||
name|clusterMap
operator|.
name|getNumOfLeaves
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|DatanodeStorageInfo
operator|.
name|EMPTY_ARRAY
return|;
block|}
if|if
condition|(
name|excludedNodes
operator|==
literal|null
condition|)
block|{
name|excludedNodes
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|int
index|[]
name|result
init|=
name|getMaxNodesPerRack
argument_list|(
name|chosenStorage
operator|.
name|size
argument_list|()
argument_list|,
name|numOfReplicas
argument_list|)
decl_stmt|;
name|numOfReplicas
operator|=
name|result
index|[
literal|0
index|]
expr_stmt|;
name|int
name|maxNodesPerRack
init|=
name|result
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|chosenStorage
control|)
block|{
comment|// add localMachine and related nodes to excludedNodes
name|addToExcludedNodes
argument_list|(
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
init|=
literal|null
decl_stmt|;
name|Node
name|localNode
init|=
literal|null
decl_stmt|;
name|boolean
name|avoidStaleNodes
init|=
operator|(
name|stats
operator|!=
literal|null
operator|&&
name|stats
operator|.
name|isAvoidingStaleDataNodesForWrite
argument_list|()
operator|)
decl_stmt|;
name|boolean
name|avoidLocalNode
init|=
operator|(
name|addBlockFlags
operator|!=
literal|null
operator|&&
name|addBlockFlags
operator|.
name|contains
argument_list|(
name|AddBlockFlag
operator|.
name|NO_LOCAL_WRITE
argument_list|)
operator|&&
name|writer
operator|!=
literal|null
operator|&&
operator|!
name|excludedNodes
operator|.
name|contains
argument_list|(
name|writer
argument_list|)
operator|)
decl_stmt|;
comment|// Attempt to exclude local node if the client suggests so. If no enough
comment|// nodes can be obtained, it falls back to the default block placement
comment|// policy.
if|if
condition|(
name|avoidLocalNode
condition|)
block|{
name|results
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|chosenStorage
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodeCopy
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|excludedNodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|excludedNodeCopy
operator|.
name|add
argument_list|(
name|writer
argument_list|)
expr_stmt|;
block|}
name|localNode
operator|=
name|chooseTarget
argument_list|(
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|excludedNodeCopy
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storagePolicy
argument_list|,
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
argument_list|,
name|results
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|size
argument_list|()
operator|<
name|numOfReplicas
condition|)
block|{
comment|// not enough nodes; discard results and fall back
name|results
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|results
operator|==
literal|null
condition|)
block|{
name|results
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|chosenStorage
argument_list|)
expr_stmt|;
name|localNode
operator|=
name|chooseTarget
argument_list|(
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storagePolicy
argument_list|,
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
argument_list|,
name|results
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|returnChosenNodes
condition|)
block|{
name|results
operator|.
name|removeAll
argument_list|(
name|chosenStorage
argument_list|)
expr_stmt|;
block|}
comment|// sorting nodes to form a pipeline
return|return
name|getPipeline
argument_list|(
operator|(
name|writer
operator|!=
literal|null
operator|&&
name|writer
operator|instanceof
name|DatanodeDescriptor
operator|)
condition|?
name|writer
else|:
name|localNode
argument_list|,
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeStorageInfo
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Calculate the maximum number of replicas to allocate per rack. It also    * limits the total number of replicas to the total number of nodes in the    * cluster. Caller should adjust the replica count to the return value.    *    * @param numOfChosen The number of already chosen nodes.    * @param numOfReplicas The number of additional nodes to allocate.    * @return integer array. Index 0: The number of nodes allowed to allocate    *         in addition to already chosen nodes.    *         Index 1: The maximum allowed number of nodes per rack. This    *         is independent of the number of chosen nodes, as it is calculated    *         using the target number of replicas.    */
DECL|method|getMaxNodesPerRack (int numOfChosen, int numOfReplicas)
specifier|protected
name|int
index|[]
name|getMaxNodesPerRack
parameter_list|(
name|int
name|numOfChosen
parameter_list|,
name|int
name|numOfReplicas
parameter_list|)
block|{
name|int
name|clusterSize
init|=
name|clusterMap
operator|.
name|getNumOfLeaves
argument_list|()
decl_stmt|;
name|int
name|totalNumOfReplicas
init|=
name|numOfChosen
operator|+
name|numOfReplicas
decl_stmt|;
if|if
condition|(
name|totalNumOfReplicas
operator|>
name|clusterSize
condition|)
block|{
name|numOfReplicas
operator|-=
operator|(
name|totalNumOfReplicas
operator|-
name|clusterSize
operator|)
expr_stmt|;
name|totalNumOfReplicas
operator|=
name|clusterSize
expr_stmt|;
block|}
comment|// No calculation needed when there is only one rack or picking one node.
name|int
name|numOfRacks
init|=
name|clusterMap
operator|.
name|getNumOfRacks
argument_list|()
decl_stmt|;
if|if
condition|(
name|numOfRacks
operator|==
literal|1
operator|||
name|totalNumOfReplicas
operator|<=
literal|1
condition|)
block|{
return|return
operator|new
name|int
index|[]
block|{
name|numOfReplicas
block|,
name|totalNumOfReplicas
block|}
return|;
block|}
name|int
name|maxNodesPerRack
init|=
operator|(
name|totalNumOfReplicas
operator|-
literal|1
operator|)
operator|/
name|numOfRacks
operator|+
literal|2
decl_stmt|;
comment|// At this point, there are more than one racks and more than one replicas
comment|// to store. Avoid all replicas being in the same rack.
comment|//
comment|// maxNodesPerRack has the following properties at this stage.
comment|//   1) maxNodesPerRack>= 2
comment|//   2) (maxNodesPerRack-1) * numOfRacks> totalNumOfReplicas
comment|//          when numOfRacks> 1
comment|//
comment|// Thus, the following adjustment will still result in a value that forces
comment|// multi-rack allocation and gives enough number of total nodes.
if|if
condition|(
name|maxNodesPerRack
operator|==
name|totalNumOfReplicas
condition|)
block|{
name|maxNodesPerRack
operator|--
expr_stmt|;
block|}
return|return
operator|new
name|int
index|[]
block|{
name|numOfReplicas
block|,
name|maxNodesPerRack
block|}
return|;
block|}
DECL|method|getRequiredStorageTypes ( List<StorageType> types)
specifier|private
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|getRequiredStorageTypes
parameter_list|(
name|List
argument_list|<
name|StorageType
argument_list|>
name|types
parameter_list|)
block|{
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|num
init|=
name|map
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|type
argument_list|,
name|num
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
comment|/**    * choose<i>numOfReplicas</i> from all data nodes    * @param numOfReplicas additional number of replicas wanted    * @param writer the writer's machine, could be a non-DatanodeDescriptor node    * @param excludedNodes datanodes that should not be considered as targets    * @param blocksize size of the data to be written    * @param maxNodesPerRack max nodes allowed per rack    * @param results the target nodes already chosen    * @param avoidStaleNodes avoid stale nodes in replica choosing    * @return local node of writer (not chosen node)    */
DECL|method|chooseTarget (int numOfReplicas, Node writer, final Set<Node> excludedNodes, final long blocksize, final int maxNodesPerRack, final List<DatanodeStorageInfo> results, final boolean avoidStaleNodes, final BlockStoragePolicy storagePolicy, final EnumSet<StorageType> unavailableStorages, final boolean newBlock)
specifier|private
name|Node
name|chooseTarget
parameter_list|(
name|int
name|numOfReplicas
parameter_list|,
name|Node
name|writer
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
specifier|final
name|long
name|blocksize
parameter_list|,
specifier|final
name|int
name|maxNodesPerRack
parameter_list|,
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
specifier|final
name|boolean
name|avoidStaleNodes
parameter_list|,
specifier|final
name|BlockStoragePolicy
name|storagePolicy
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|StorageType
argument_list|>
name|unavailableStorages
parameter_list|,
specifier|final
name|boolean
name|newBlock
parameter_list|)
block|{
if|if
condition|(
name|numOfReplicas
operator|==
literal|0
operator|||
name|clusterMap
operator|.
name|getNumOfLeaves
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|writer
operator|instanceof
name|DatanodeDescriptor
operator|)
condition|?
name|writer
else|:
literal|null
return|;
block|}
specifier|final
name|int
name|numOfResults
init|=
name|results
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|totalReplicasExpected
init|=
name|numOfReplicas
operator|+
name|numOfResults
decl_stmt|;
if|if
condition|(
operator|(
name|writer
operator|==
literal|null
operator|||
operator|!
operator|(
name|writer
operator|instanceof
name|DatanodeDescriptor
operator|)
operator|)
operator|&&
operator|!
name|newBlock
condition|)
block|{
name|writer
operator|=
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getDatanodeDescriptor
argument_list|()
expr_stmt|;
block|}
comment|// Keep a copy of original excludedNodes
specifier|final
name|Set
argument_list|<
name|Node
argument_list|>
name|oldExcludedNodes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|excludedNodes
argument_list|)
decl_stmt|;
comment|// choose storage types; use fallbacks for unavailable storages
specifier|final
name|List
argument_list|<
name|StorageType
argument_list|>
name|requiredStorageTypes
init|=
name|storagePolicy
operator|.
name|chooseStorageTypes
argument_list|(
operator|(
name|short
operator|)
name|totalReplicasExpected
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageTypes
argument_list|(
name|results
argument_list|)
argument_list|,
name|unavailableStorages
argument_list|,
name|newBlock
argument_list|)
decl_stmt|;
specifier|final
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
init|=
name|getRequiredStorageTypes
argument_list|(
name|requiredStorageTypes
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"storageTypes="
operator|+
name|storageTypes
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
operator|(
name|numOfReplicas
operator|=
name|requiredStorageTypes
operator|.
name|size
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|NotEnoughReplicasException
argument_list|(
literal|"All required storage types are unavailable: "
operator|+
literal|" unavailableStorages="
operator|+
name|unavailableStorages
operator|+
literal|", storagePolicy="
operator|+
name|storagePolicy
argument_list|)
throw|;
block|}
name|writer
operator|=
name|chooseTargetInOrder
argument_list|(
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|newBlock
argument_list|,
name|storageTypes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotEnoughReplicasException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Failed to place enough replicas, still in need of "
operator|+
operator|(
name|totalReplicasExpected
operator|-
name|results
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|" to reach "
operator|+
name|totalReplicasExpected
operator|+
literal|" (unavailableStorages="
operator|+
name|unavailableStorages
operator|+
literal|", storagePolicy="
operator|+
name|storagePolicy
operator|+
literal|", newBlock="
operator|+
name|newBlock
operator|+
literal|")"
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|message
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|message
operator|+
literal|" "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|avoidStaleNodes
condition|)
block|{
comment|// Retry chooseTarget again, this time not avoiding stale nodes.
comment|// excludedNodes contains the initial excludedNodes and nodes that were
comment|// not chosen because they were stale, decommissioned, etc.
comment|// We need to additionally exclude the nodes that were added to the
comment|// result list in the successful calls to choose*() above.
for|for
control|(
name|DatanodeStorageInfo
name|resultStorage
range|:
name|results
control|)
block|{
name|addToExcludedNodes
argument_list|(
name|resultStorage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|oldExcludedNodes
argument_list|)
expr_stmt|;
block|}
comment|// Set numOfReplicas, since it can get out of sync with the result list
comment|// if the NotEnoughReplicasException was thrown in chooseRandom().
name|numOfReplicas
operator|=
name|totalReplicasExpected
operator|-
name|results
operator|.
name|size
argument_list|()
expr_stmt|;
return|return
name|chooseTarget
argument_list|(
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|oldExcludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
literal|false
argument_list|,
name|storagePolicy
argument_list|,
name|unavailableStorages
argument_list|,
name|newBlock
argument_list|)
return|;
block|}
name|boolean
name|retry
init|=
literal|false
decl_stmt|;
comment|// simply add all the remaining types into unavailableStorages and give
comment|// another try. No best effort is guaranteed here.
for|for
control|(
name|StorageType
name|type
range|:
name|storageTypes
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|unavailableStorages
operator|.
name|contains
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|unavailableStorages
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|retry
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retry
condition|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|resultStorage
range|:
name|results
control|)
block|{
name|addToExcludedNodes
argument_list|(
name|resultStorage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|oldExcludedNodes
argument_list|)
expr_stmt|;
block|}
name|numOfReplicas
operator|=
name|totalReplicasExpected
operator|-
name|results
operator|.
name|size
argument_list|()
expr_stmt|;
return|return
name|chooseTarget
argument_list|(
name|numOfReplicas
argument_list|,
name|writer
argument_list|,
name|oldExcludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
literal|false
argument_list|,
name|storagePolicy
argument_list|,
name|unavailableStorages
argument_list|,
name|newBlock
argument_list|)
return|;
block|}
block|}
return|return
name|writer
return|;
block|}
DECL|method|chooseTargetInOrder (int numOfReplicas, Node writer, final Set<Node> excludedNodes, final long blocksize, final int maxNodesPerRack, final List<DatanodeStorageInfo> results, final boolean avoidStaleNodes, final boolean newBlock, EnumMap<StorageType, Integer> storageTypes)
specifier|protected
name|Node
name|chooseTargetInOrder
parameter_list|(
name|int
name|numOfReplicas
parameter_list|,
name|Node
name|writer
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
specifier|final
name|long
name|blocksize
parameter_list|,
specifier|final
name|int
name|maxNodesPerRack
parameter_list|,
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
specifier|final
name|boolean
name|avoidStaleNodes
parameter_list|,
specifier|final
name|boolean
name|newBlock
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
parameter_list|)
throws|throws
name|NotEnoughReplicasException
block|{
specifier|final
name|int
name|numOfResults
init|=
name|results
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numOfResults
operator|==
literal|0
condition|)
block|{
name|DatanodeStorageInfo
name|storageInfo
init|=
name|chooseLocalStorage
argument_list|(
name|writer
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|writer
operator|=
operator|(
name|storageInfo
operator|!=
literal|null
operator|)
condition|?
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
else|:
literal|null
expr_stmt|;
if|if
condition|(
operator|--
name|numOfReplicas
operator|==
literal|0
condition|)
block|{
return|return
name|writer
return|;
block|}
block|}
specifier|final
name|DatanodeDescriptor
name|dn0
init|=
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|numOfResults
operator|<=
literal|1
condition|)
block|{
name|chooseRemoteRack
argument_list|(
literal|1
argument_list|,
name|dn0
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|numOfReplicas
operator|==
literal|0
condition|)
block|{
return|return
name|writer
return|;
block|}
block|}
if|if
condition|(
name|numOfResults
operator|<=
literal|2
condition|)
block|{
specifier|final
name|DatanodeDescriptor
name|dn1
init|=
name|results
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterMap
operator|.
name|isOnSameRack
argument_list|(
name|dn0
argument_list|,
name|dn1
argument_list|)
condition|)
block|{
name|chooseRemoteRack
argument_list|(
literal|1
argument_list|,
name|dn0
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newBlock
condition|)
block|{
name|chooseLocalRack
argument_list|(
name|dn1
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chooseLocalRack
argument_list|(
name|writer
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|numOfReplicas
operator|==
literal|0
condition|)
block|{
return|return
name|writer
return|;
block|}
block|}
name|chooseRandom
argument_list|(
name|numOfReplicas
argument_list|,
name|NodeBase
operator|.
name|ROOT
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
expr_stmt|;
return|return
name|writer
return|;
block|}
DECL|method|chooseLocalStorage (Node localMachine, Set<Node> excludedNodes, long blocksize, int maxNodesPerRack, List<DatanodeStorageInfo> results, boolean avoidStaleNodes, EnumMap<StorageType, Integer> storageTypes)
specifier|protected
name|DatanodeStorageInfo
name|chooseLocalStorage
parameter_list|(
name|Node
name|localMachine
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|int
name|maxNodesPerRack
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|boolean
name|avoidStaleNodes
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
parameter_list|)
throws|throws
name|NotEnoughReplicasException
block|{
comment|// if no local machine, randomly choose one node
if|if
condition|(
name|localMachine
operator|==
literal|null
condition|)
block|{
return|return
name|chooseRandom
argument_list|(
name|NodeBase
operator|.
name|ROOT
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
return|;
block|}
if|if
condition|(
name|preferLocalNode
operator|&&
name|localMachine
operator|instanceof
name|DatanodeDescriptor
operator|&&
name|clusterMap
operator|.
name|contains
argument_list|(
name|localMachine
argument_list|)
condition|)
block|{
name|DatanodeDescriptor
name|localDatanode
init|=
operator|(
name|DatanodeDescriptor
operator|)
name|localMachine
decl_stmt|;
comment|// otherwise try local machine first
if|if
condition|(
name|excludedNodes
operator|.
name|add
argument_list|(
name|localMachine
argument_list|)
comment|// was not in the excluded list
operator|&&
name|isGoodDatanode
argument_list|(
name|localDatanode
argument_list|,
name|maxNodesPerRack
argument_list|,
literal|false
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|)
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|storageTypes
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|entry
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|DatanodeStorageInfo
name|localStorage
init|=
name|chooseStorage4Block
argument_list|(
name|localDatanode
argument_list|,
name|blocksize
argument_list|,
name|results
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|localStorage
operator|!=
literal|null
condition|)
block|{
comment|// add node and related nodes to excludedNode
name|addToExcludedNodes
argument_list|(
name|localDatanode
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
name|int
name|num
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|.
name|setValue
argument_list|(
name|num
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|localStorage
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Choose<i>localMachine</i> as the target.    * if<i>localMachine</i> is not available,    * choose a node on the same rack    * @return the chosen storage    */
DECL|method|chooseLocalStorage (Node localMachine, Set<Node> excludedNodes, long blocksize, int maxNodesPerRack, List<DatanodeStorageInfo> results, boolean avoidStaleNodes, EnumMap<StorageType, Integer> storageTypes, boolean fallbackToLocalRack)
specifier|protected
name|DatanodeStorageInfo
name|chooseLocalStorage
parameter_list|(
name|Node
name|localMachine
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|int
name|maxNodesPerRack
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|boolean
name|avoidStaleNodes
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
parameter_list|,
name|boolean
name|fallbackToLocalRack
parameter_list|)
throws|throws
name|NotEnoughReplicasException
block|{
name|DatanodeStorageInfo
name|localStorage
init|=
name|chooseLocalStorage
argument_list|(
name|localMachine
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
decl_stmt|;
if|if
condition|(
name|localStorage
operator|!=
literal|null
condition|)
block|{
return|return
name|localStorage
return|;
block|}
if|if
condition|(
operator|!
name|fallbackToLocalRack
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// try a node on local rack
return|return
name|chooseLocalRack
argument_list|(
name|localMachine
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
return|;
block|}
comment|/**    * Add<i>localMachine</i> and related nodes to<i>excludedNodes</i>    * for next replica choosing. In sub class, we can add more nodes within    * the same failure domain of localMachine    * @return number of new excluded nodes    */
DECL|method|addToExcludedNodes (DatanodeDescriptor localMachine, Set<Node> excludedNodes)
specifier|protected
name|int
name|addToExcludedNodes
parameter_list|(
name|DatanodeDescriptor
name|localMachine
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
block|{
return|return
name|excludedNodes
operator|.
name|add
argument_list|(
name|localMachine
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
comment|/**    * Choose one node from the rack that<i>localMachine</i> is on.    * if no such node is available, choose one node from the rack where    * a second replica is on.    * if still no such node is available, choose a random node     * in the cluster.    * @return the chosen node    */
DECL|method|chooseLocalRack (Node localMachine, Set<Node> excludedNodes, long blocksize, int maxNodesPerRack, List<DatanodeStorageInfo> results, boolean avoidStaleNodes, EnumMap<StorageType, Integer> storageTypes)
specifier|protected
name|DatanodeStorageInfo
name|chooseLocalRack
parameter_list|(
name|Node
name|localMachine
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|int
name|maxNodesPerRack
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|boolean
name|avoidStaleNodes
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
parameter_list|)
throws|throws
name|NotEnoughReplicasException
block|{
comment|// no local machine, so choose a random machine
if|if
condition|(
name|localMachine
operator|==
literal|null
condition|)
block|{
return|return
name|chooseRandom
argument_list|(
name|NodeBase
operator|.
name|ROOT
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
return|;
block|}
specifier|final
name|String
name|localRack
init|=
name|localMachine
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
try|try
block|{
comment|// choose one from the local rack
return|return
name|chooseRandom
argument_list|(
name|localRack
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NotEnoughReplicasException
name|e
parameter_list|)
block|{
comment|// find the next replica and retry with its rack
for|for
control|(
name|DatanodeStorageInfo
name|resultStorage
range|:
name|results
control|)
block|{
name|DatanodeDescriptor
name|nextNode
init|=
name|resultStorage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextNode
operator|!=
name|localMachine
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to choose from local rack (location = "
operator|+
name|localRack
operator|+
literal|"), retry with the rack of the next replica (location = "
operator|+
name|nextNode
operator|.
name|getNetworkLocation
argument_list|()
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|chooseFromNextRack
argument_list|(
name|nextNode
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to choose from local rack (location = "
operator|+
name|localRack
operator|+
literal|"); the second replica is not found, retry choosing randomly"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|//the second replica is not found, randomly choose one from the network
return|return
name|chooseRandom
argument_list|(
name|NodeBase
operator|.
name|ROOT
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
return|;
block|}
block|}
DECL|method|chooseFromNextRack (Node next, Set<Node> excludedNodes, long blocksize, int maxNodesPerRack, List<DatanodeStorageInfo> results, boolean avoidStaleNodes, EnumMap<StorageType, Integer> storageTypes)
specifier|private
name|DatanodeStorageInfo
name|chooseFromNextRack
parameter_list|(
name|Node
name|next
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|int
name|maxNodesPerRack
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|boolean
name|avoidStaleNodes
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
parameter_list|)
throws|throws
name|NotEnoughReplicasException
block|{
specifier|final
name|String
name|nextRack
init|=
name|next
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|chooseRandom
argument_list|(
name|nextRack
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NotEnoughReplicasException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to choose from the next rack (location = "
operator|+
name|nextRack
operator|+
literal|"), retry choosing randomly"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|//otherwise randomly choose one from the network
return|return
name|chooseRandom
argument_list|(
name|NodeBase
operator|.
name|ROOT
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
return|;
block|}
block|}
comment|/**     * Choose<i>numOfReplicas</i> nodes from the racks     * that<i>localMachine</i> is NOT on.    * If not enough nodes are available, choose the remaining ones    * from the local rack    */
DECL|method|chooseRemoteRack (int numOfReplicas, DatanodeDescriptor localMachine, Set<Node> excludedNodes, long blocksize, int maxReplicasPerRack, List<DatanodeStorageInfo> results, boolean avoidStaleNodes, EnumMap<StorageType, Integer> storageTypes)
specifier|protected
name|void
name|chooseRemoteRack
parameter_list|(
name|int
name|numOfReplicas
parameter_list|,
name|DatanodeDescriptor
name|localMachine
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|int
name|maxReplicasPerRack
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|boolean
name|avoidStaleNodes
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
parameter_list|)
throws|throws
name|NotEnoughReplicasException
block|{
name|int
name|oldNumOfReplicas
init|=
name|results
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// randomly choose one node from remote racks
try|try
block|{
name|chooseRandom
argument_list|(
name|numOfReplicas
argument_list|,
literal|"~"
operator|+
name|localMachine
operator|.
name|getNetworkLocation
argument_list|()
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxReplicasPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotEnoughReplicasException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to choose remote rack (location = ~"
operator|+
name|localMachine
operator|.
name|getNetworkLocation
argument_list|()
operator|+
literal|"), fallback to local rack"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|chooseRandom
argument_list|(
name|numOfReplicas
operator|-
operator|(
name|results
operator|.
name|size
argument_list|()
operator|-
name|oldNumOfReplicas
operator|)
argument_list|,
name|localMachine
operator|.
name|getNetworkLocation
argument_list|()
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxReplicasPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Randomly choose one target from the given<i>scope</i>.    * @return the chosen storage, if there is any.    */
DECL|method|chooseRandom (String scope, Set<Node> excludedNodes, long blocksize, int maxNodesPerRack, List<DatanodeStorageInfo> results, boolean avoidStaleNodes, EnumMap<StorageType, Integer> storageTypes)
specifier|protected
name|DatanodeStorageInfo
name|chooseRandom
parameter_list|(
name|String
name|scope
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|int
name|maxNodesPerRack
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|boolean
name|avoidStaleNodes
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
parameter_list|)
throws|throws
name|NotEnoughReplicasException
block|{
return|return
name|chooseRandom
argument_list|(
literal|1
argument_list|,
name|scope
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|maxNodesPerRack
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|,
name|storageTypes
argument_list|)
return|;
block|}
comment|/**    * Randomly choose<i>numOfReplicas</i> targets from the given<i>scope</i>.    * @return the first chosen node, if there is any.    */
DECL|method|chooseRandom (int numOfReplicas, String scope, Set<Node> excludedNodes, long blocksize, int maxNodesPerRack, List<DatanodeStorageInfo> results, boolean avoidStaleNodes, EnumMap<StorageType, Integer> storageTypes)
specifier|protected
name|DatanodeStorageInfo
name|chooseRandom
parameter_list|(
name|int
name|numOfReplicas
parameter_list|,
name|String
name|scope
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|int
name|maxNodesPerRack
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|boolean
name|avoidStaleNodes
parameter_list|,
name|EnumMap
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|storageTypes
parameter_list|)
throws|throws
name|NotEnoughReplicasException
block|{
name|StringBuilder
name|builder
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|builder
operator|=
name|debugLoggingBuilder
operator|.
name|get
argument_list|()
expr_stmt|;
name|builder
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
block|}
name|CHOOSE_RANDOM_REASONS
operator|.
name|get
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|boolean
name|badTarget
init|=
literal|false
decl_stmt|;
name|DatanodeStorageInfo
name|firstChosen
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|numOfReplicas
operator|>
literal|0
condition|)
block|{
comment|// the storage type that current node has
name|StorageType
name|includeType
init|=
literal|null
decl_stmt|;
name|DatanodeDescriptor
name|chosenNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|clusterMap
operator|instanceof
name|DFSNetworkTopology
condition|)
block|{
for|for
control|(
name|StorageType
name|type
range|:
name|storageTypes
operator|.
name|keySet
argument_list|()
control|)
block|{
name|chosenNode
operator|=
name|chooseDataNode
argument_list|(
name|scope
argument_list|,
name|excludedNodes
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosenNode
operator|!=
literal|null
condition|)
block|{
name|includeType
operator|=
name|type
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|chosenNode
operator|=
name|chooseDataNode
argument_list|(
name|scope
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chosenNode
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
name|excludedNodes
operator|.
name|add
argument_list|(
name|chosenNode
argument_list|)
argument_list|,
literal|"chosenNode "
operator|+
name|chosenNode
operator|+
literal|" is already in excludedNodes "
operator|+
name|excludedNodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|builder
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"\nNode "
argument_list|)
operator|.
name|append
argument_list|(
name|NodeBase
operator|.
name|getPath
argument_list|(
name|chosenNode
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" ["
argument_list|)
expr_stmt|;
block|}
name|DatanodeStorageInfo
name|storage
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isGoodDatanode
argument_list|(
name|chosenNode
argument_list|,
name|maxNodesPerRack
argument_list|,
name|considerLoad
argument_list|,
name|results
argument_list|,
name|avoidStaleNodes
argument_list|)
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|iter
init|=
name|storageTypes
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|StorageType
argument_list|,
name|Integer
argument_list|>
name|entry
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// If there is one storage type the node has already contained,
comment|// then no need to loop through other storage type.
if|if
condition|(
name|includeType
operator|!=
literal|null
operator|&&
name|entry
operator|.
name|getKey
argument_list|()
operator|!=
name|includeType
condition|)
block|{
continue|continue;
block|}
name|storage
operator|=
name|chooseStorage4Block
argument_list|(
name|chosenNode
argument_list|,
name|blocksize
argument_list|,
name|results
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|!=
literal|null
condition|)
block|{
name|numOfReplicas
operator|--
expr_stmt|;
if|if
condition|(
name|firstChosen
operator|==
literal|null
condition|)
block|{
name|firstChosen
operator|=
name|storage
expr_stmt|;
block|}
comment|// add node (subclasses may also add related nodes) to excludedNode
name|addToExcludedNodes
argument_list|(
name|chosenNode
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
name|int
name|num
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|.
name|setValue
argument_list|(
name|num
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|builder
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"\n]"
argument_list|)
expr_stmt|;
block|}
comment|// If no candidate storage was found on this DN then set badTarget.
name|badTarget
operator|=
operator|(
name|storage
operator|==
literal|null
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numOfReplicas
operator|>
literal|0
condition|)
block|{
name|String
name|detail
init|=
name|enableDebugLogging
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|builder
operator|!=
literal|null
condition|)
block|{
name|detail
operator|=
name|builder
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|badTarget
condition|)
block|{
name|builder
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|detail
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// only log if there's more than "[", which is always appended at
comment|// the beginning of this method.
name|LOG
operator|.
name|debug
argument_list|(
name|detail
argument_list|)
expr_stmt|;
block|}
name|detail
operator|=
literal|""
expr_stmt|;
block|}
block|}
specifier|final
name|HashMap
argument_list|<
name|NodeNotChosenReason
argument_list|,
name|Integer
argument_list|>
name|reasonMap
init|=
name|CHOOSE_RANDOM_REASONS
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|reasonMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Not enough replicas was chosen. Reason:{}"
argument_list|,
name|reasonMap
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|NotEnoughReplicasException
argument_list|(
name|detail
argument_list|)
throw|;
block|}
return|return
name|firstChosen
return|;
block|}
comment|/**    * Choose a datanode from the given<i>scope</i>.    * @return the chosen node, if there is any.    */
DECL|method|chooseDataNode (final String scope, final Collection<Node> excludedNodes)
specifier|protected
name|DatanodeDescriptor
name|chooseDataNode
parameter_list|(
specifier|final
name|String
name|scope
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
block|{
return|return
operator|(
name|DatanodeDescriptor
operator|)
name|clusterMap
operator|.
name|chooseRandom
argument_list|(
name|scope
argument_list|,
name|excludedNodes
argument_list|)
return|;
block|}
comment|/**    * Choose a datanode from the given<i>scope</i> with specified    * storage type.    * @return the chosen node, if there is any.    */
DECL|method|chooseDataNode (final String scope, final Collection<Node> excludedNodes, StorageType type)
specifier|protected
name|DatanodeDescriptor
name|chooseDataNode
parameter_list|(
specifier|final
name|String
name|scope
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
name|StorageType
name|type
parameter_list|)
block|{
return|return
call|(
name|DatanodeDescriptor
call|)
argument_list|(
operator|(
name|DFSNetworkTopology
operator|)
name|clusterMap
argument_list|)
operator|.
name|chooseRandomWithStorageTypeTwoTrial
argument_list|(
name|scope
argument_list|,
name|excludedNodes
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * Choose a good storage of given storage type from datanode, and add it to    * the result list.    *    * @param dnd datanode descriptor    * @param blockSize requested block size    * @param results the result storages    * @param storageType requested storage type    * @return the chosen datanode storage    */
DECL|method|chooseStorage4Block (DatanodeDescriptor dnd, long blockSize, List<DatanodeStorageInfo> results, StorageType storageType)
name|DatanodeStorageInfo
name|chooseStorage4Block
parameter_list|(
name|DatanodeDescriptor
name|dnd
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|StorageType
name|storageType
parameter_list|)
block|{
name|DatanodeStorageInfo
name|storage
init|=
name|dnd
operator|.
name|chooseStorage4Block
argument_list|(
name|storageType
argument_list|,
name|blockSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|storage
operator|!=
literal|null
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logNodeIsNotChosen
argument_list|(
name|dnd
argument_list|,
name|NodeNotChosenReason
operator|.
name|NOT_ENOUGH_STORAGE_SPACE
argument_list|,
literal|" for storage type "
operator|+
name|storageType
argument_list|)
expr_stmt|;
block|}
return|return
name|storage
return|;
block|}
DECL|method|logNodeIsNotChosen (DatanodeDescriptor node, NodeNotChosenReason reason)
specifier|private
specifier|static
name|void
name|logNodeIsNotChosen
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|,
name|NodeNotChosenReason
name|reason
parameter_list|)
block|{
name|logNodeIsNotChosen
argument_list|(
name|node
argument_list|,
name|reason
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|logNodeIsNotChosen (DatanodeDescriptor node, NodeNotChosenReason reason, String reasonDetails)
specifier|private
specifier|static
name|void
name|logNodeIsNotChosen
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|,
name|NodeNotChosenReason
name|reason
parameter_list|,
name|String
name|reasonDetails
parameter_list|)
block|{
assert|assert
name|reason
operator|!=
literal|null
assert|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// build the error message for later use.
name|debugLoggingBuilder
operator|.
name|get
argument_list|()
operator|.
name|append
argument_list|(
literal|"\n  Datanode "
argument_list|)
operator|.
name|append
argument_list|(
name|node
argument_list|)
operator|.
name|append
argument_list|(
literal|" is not chosen since "
argument_list|)
operator|.
name|append
argument_list|(
name|reason
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|reasonDetails
operator|!=
literal|null
condition|)
block|{
name|debugLoggingBuilder
operator|.
name|get
argument_list|()
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|reasonDetails
argument_list|)
expr_stmt|;
block|}
name|debugLoggingBuilder
operator|.
name|get
argument_list|()
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|// always populate reason map to log high level reasons.
specifier|final
name|HashMap
argument_list|<
name|NodeNotChosenReason
argument_list|,
name|Integer
argument_list|>
name|reasonMap
init|=
name|CHOOSE_RANDOM_REASONS
operator|.
name|get
argument_list|()
decl_stmt|;
name|Integer
name|base
init|=
name|reasonMap
operator|.
name|get
argument_list|(
name|reason
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|==
literal|null
condition|)
block|{
name|base
operator|=
literal|0
expr_stmt|;
block|}
name|reasonMap
operator|.
name|put
argument_list|(
name|reason
argument_list|,
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine if a datanode should be chosen based on current workload.    *    * @param node The target datanode    * @return Return true if the datanode should be excluded, otherwise false    */
DECL|method|excludeNodeByLoad (DatanodeDescriptor node)
name|boolean
name|excludeNodeByLoad
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
specifier|final
name|double
name|maxLoad
init|=
name|considerLoadFactor
operator|*
name|stats
operator|.
name|getInServiceXceiverAverage
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nodeLoad
init|=
name|node
operator|.
name|getXceiverCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|nodeLoad
operator|>
name|maxLoad
operator|)
operator|&&
operator|(
name|maxLoad
operator|>
literal|0
operator|)
condition|)
block|{
name|logNodeIsNotChosen
argument_list|(
name|node
argument_list|,
name|NodeNotChosenReason
operator|.
name|NODE_TOO_BUSY
argument_list|,
literal|"(load: "
operator|+
name|nodeLoad
operator|+
literal|"> "
operator|+
name|maxLoad
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Determine if a datanode is good for placing block.    *    * @param node The target datanode    * @param maxTargetPerRack Maximum number of targets per rack. The value of    *                       this parameter depends on the number of racks in    *                       the cluster and total number of replicas for a block    * @param considerLoad whether or not to consider load of the target node    * @param results A list containing currently chosen nodes. Used to check if    *                too many nodes has been chosen in the target rack.    * @param avoidStaleNodes Whether or not to avoid choosing stale nodes    * @return Return true if the datanode is good candidate, otherwise false    */
DECL|method|isGoodDatanode (DatanodeDescriptor node, int maxTargetPerRack, boolean considerLoad, List<DatanodeStorageInfo> results, boolean avoidStaleNodes)
name|boolean
name|isGoodDatanode
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|,
name|int
name|maxTargetPerRack
parameter_list|,
name|boolean
name|considerLoad
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|results
parameter_list|,
name|boolean
name|avoidStaleNodes
parameter_list|)
block|{
comment|// check if the node is (being) decommissioned
if|if
condition|(
operator|!
name|node
operator|.
name|isInService
argument_list|()
condition|)
block|{
name|logNodeIsNotChosen
argument_list|(
name|node
argument_list|,
name|NodeNotChosenReason
operator|.
name|NOT_IN_SERVICE
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|avoidStaleNodes
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isStale
argument_list|(
name|this
operator|.
name|staleInterval
argument_list|)
condition|)
block|{
name|logNodeIsNotChosen
argument_list|(
name|node
argument_list|,
name|NodeNotChosenReason
operator|.
name|NODE_STALE
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// check the communication traffic of the target machine
if|if
condition|(
name|considerLoad
condition|)
block|{
if|if
condition|(
name|excludeNodeByLoad
argument_list|(
name|node
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// check if the target rack has chosen too many nodes
name|String
name|rackname
init|=
name|node
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
name|int
name|counter
init|=
literal|1
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|resultStorage
range|:
name|results
control|)
block|{
if|if
condition|(
name|rackname
operator|.
name|equals
argument_list|(
name|resultStorage
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
condition|)
block|{
name|counter
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|counter
operator|>
name|maxTargetPerRack
condition|)
block|{
name|logNodeIsNotChosen
argument_list|(
name|node
argument_list|,
name|NodeNotChosenReason
operator|.
name|TOO_MANY_NODES_ON_RACK
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Return a pipeline of nodes.    * The pipeline is formed finding a shortest path that     * starts from the writer and traverses all<i>nodes</i>    * This is basically a traveling salesman problem.    */
DECL|method|getPipeline (Node writer, DatanodeStorageInfo[] storages)
specifier|private
name|DatanodeStorageInfo
index|[]
name|getPipeline
parameter_list|(
name|Node
name|writer
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|storages
parameter_list|)
block|{
if|if
condition|(
name|storages
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|storages
return|;
block|}
synchronized|synchronized
init|(
name|clusterMap
init|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|writer
operator|==
literal|null
operator|||
operator|!
name|clusterMap
operator|.
name|contains
argument_list|(
name|writer
argument_list|)
condition|)
block|{
name|writer
operator|=
name|storages
index|[
literal|0
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|index
operator|<
name|storages
operator|.
name|length
condition|;
name|index
operator|++
control|)
block|{
name|DatanodeStorageInfo
name|shortestStorage
init|=
name|storages
index|[
name|index
index|]
decl_stmt|;
name|int
name|shortestDistance
init|=
name|clusterMap
operator|.
name|getDistance
argument_list|(
name|writer
argument_list|,
name|shortestStorage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|shortestIndex
init|=
name|index
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|index
operator|+
literal|1
init|;
name|i
operator|<
name|storages
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|currentDistance
init|=
name|clusterMap
operator|.
name|getDistance
argument_list|(
name|writer
argument_list|,
name|storages
index|[
name|i
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shortestDistance
operator|>
name|currentDistance
condition|)
block|{
name|shortestDistance
operator|=
name|currentDistance
expr_stmt|;
name|shortestStorage
operator|=
name|storages
index|[
name|i
index|]
expr_stmt|;
name|shortestIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|//switch position index& shortestIndex
if|if
condition|(
name|index
operator|!=
name|shortestIndex
condition|)
block|{
name|storages
index|[
name|shortestIndex
index|]
operator|=
name|storages
index|[
name|index
index|]
expr_stmt|;
name|storages
index|[
name|index
index|]
operator|=
name|shortestStorage
expr_stmt|;
block|}
name|writer
operator|=
name|shortestStorage
operator|.
name|getDatanodeDescriptor
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|storages
return|;
block|}
annotation|@
name|Override
DECL|method|verifyBlockPlacement (DatanodeInfo[] locs, int numberOfReplicas)
specifier|public
name|BlockPlacementStatus
name|verifyBlockPlacement
parameter_list|(
name|DatanodeInfo
index|[]
name|locs
parameter_list|,
name|int
name|numberOfReplicas
parameter_list|)
block|{
if|if
condition|(
name|locs
operator|==
literal|null
condition|)
name|locs
operator|=
name|DatanodeDescriptor
operator|.
name|EMPTY_ARRAY
expr_stmt|;
if|if
condition|(
operator|!
name|clusterMap
operator|.
name|hasClusterEverBeenMultiRack
argument_list|()
condition|)
block|{
comment|// only one rack
return|return
operator|new
name|BlockPlacementStatusDefault
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
name|int
name|minRacks
init|=
literal|2
decl_stmt|;
name|minRacks
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minRacks
argument_list|,
name|numberOfReplicas
argument_list|)
expr_stmt|;
comment|// 1. Check that all locations are different.
comment|// 2. Count locations on different racks.
name|Set
argument_list|<
name|String
argument_list|>
name|racks
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeInfo
name|dn
range|:
name|locs
control|)
name|racks
operator|.
name|add
argument_list|(
name|dn
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlockPlacementStatusDefault
argument_list|(
name|racks
operator|.
name|size
argument_list|()
argument_list|,
name|minRacks
argument_list|,
name|clusterMap
operator|.
name|getNumOfRacks
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Decide whether deleting the specified replica of the block still makes    * the block conform to the configured block placement policy.    * @param moreThanOne The replica locations of this block that are present    *                    on more than one unique racks.    * @param exactlyOne Replica locations of this block that  are present    *                    on exactly one unique racks.    * @param excessTypes The excess {@link StorageType}s according to the    *                    {@link BlockStoragePolicy}.    *    * @return the replica that is the best candidate for deletion    */
annotation|@
name|VisibleForTesting
DECL|method|chooseReplicaToDelete ( Collection<DatanodeStorageInfo> moreThanOne, Collection<DatanodeStorageInfo> exactlyOne, final List<StorageType> excessTypes, Map<String, List<DatanodeStorageInfo>> rackMap)
specifier|public
name|DatanodeStorageInfo
name|chooseReplicaToDelete
parameter_list|(
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|moreThanOne
parameter_list|,
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|exactlyOne
parameter_list|,
specifier|final
name|List
argument_list|<
name|StorageType
argument_list|>
name|excessTypes
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|>
name|rackMap
parameter_list|)
block|{
name|long
name|oldestHeartbeat
init|=
name|monotonicNow
argument_list|()
operator|-
name|heartbeatInterval
operator|*
name|tolerateHeartbeatMultiplier
decl_stmt|;
name|DatanodeStorageInfo
name|oldestHeartbeatStorage
init|=
literal|null
decl_stmt|;
name|long
name|minSpace
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|DatanodeStorageInfo
name|minSpaceStorage
init|=
literal|null
decl_stmt|;
comment|// Pick the node with the oldest heartbeat or with the least free space,
comment|// if all hearbeats are within the tolerable heartbeat interval
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|pickupReplicaSet
argument_list|(
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|,
name|rackMap
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|excessTypes
operator|.
name|contains
argument_list|(
name|storage
operator|.
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|long
name|free
init|=
name|storage
operator|.
name|getRemaining
argument_list|()
decl_stmt|;
name|long
name|lastHeartbeat
init|=
name|node
operator|.
name|getLastUpdateMonotonic
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastHeartbeat
operator|<
name|oldestHeartbeat
condition|)
block|{
name|oldestHeartbeat
operator|=
name|lastHeartbeat
expr_stmt|;
name|oldestHeartbeatStorage
operator|=
name|storage
expr_stmt|;
block|}
if|if
condition|(
name|minSpace
operator|>
name|free
condition|)
block|{
name|minSpace
operator|=
name|free
expr_stmt|;
name|minSpaceStorage
operator|=
name|storage
expr_stmt|;
block|}
block|}
specifier|final
name|DatanodeStorageInfo
name|storage
decl_stmt|;
if|if
condition|(
name|oldestHeartbeatStorage
operator|!=
literal|null
condition|)
block|{
name|storage
operator|=
name|oldestHeartbeatStorage
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minSpaceStorage
operator|!=
literal|null
condition|)
block|{
name|storage
operator|=
name|minSpaceStorage
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
name|excessTypes
operator|.
name|remove
argument_list|(
name|storage
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|storage
return|;
block|}
annotation|@
name|Override
DECL|method|chooseReplicasToDelete ( Collection<DatanodeStorageInfo> availableReplicas, Collection<DatanodeStorageInfo> delCandidates, int expectedNumOfReplicas, List<StorageType> excessTypes, DatanodeDescriptor addedNode, DatanodeDescriptor delNodeHint)
specifier|public
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|chooseReplicasToDelete
parameter_list|(
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|availableReplicas
parameter_list|,
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|delCandidates
parameter_list|,
name|int
name|expectedNumOfReplicas
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|excessTypes
parameter_list|,
name|DatanodeDescriptor
name|addedNode
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|excessReplicas
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|>
name|rackMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|moreThanOne
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|exactlyOne
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// split candidate nodes for deletion into two sets
comment|// moreThanOne contains nodes on rack with more than one replica
comment|// exactlyOne contains the remaining nodes
name|splitNodesWithRack
argument_list|(
name|availableReplicas
argument_list|,
name|delCandidates
argument_list|,
name|rackMap
argument_list|,
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|)
expr_stmt|;
comment|// pick one node to delete that favors the delete hint
comment|// otherwise pick one with least space from priSet if it is not empty
comment|// otherwise one node with least space from remains
name|boolean
name|firstOne
init|=
literal|true
decl_stmt|;
specifier|final
name|DatanodeStorageInfo
name|delNodeHintStorage
init|=
name|DatanodeStorageInfo
operator|.
name|getDatanodeStorageInfo
argument_list|(
name|delCandidates
argument_list|,
name|delNodeHint
argument_list|)
decl_stmt|;
specifier|final
name|DatanodeStorageInfo
name|addedNodeStorage
init|=
name|DatanodeStorageInfo
operator|.
name|getDatanodeStorageInfo
argument_list|(
name|delCandidates
argument_list|,
name|addedNode
argument_list|)
decl_stmt|;
while|while
condition|(
name|delCandidates
operator|.
name|size
argument_list|()
operator|-
name|expectedNumOfReplicas
operator|>
name|excessReplicas
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|final
name|DatanodeStorageInfo
name|cur
decl_stmt|;
if|if
condition|(
name|firstOne
operator|&&
name|useDelHint
argument_list|(
name|delNodeHintStorage
argument_list|,
name|addedNodeStorage
argument_list|,
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|,
name|excessTypes
argument_list|)
condition|)
block|{
name|cur
operator|=
name|delNodeHintStorage
expr_stmt|;
block|}
else|else
block|{
comment|// regular excessive replica removal
name|cur
operator|=
name|chooseReplicaToDelete
argument_list|(
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|,
name|excessTypes
argument_list|,
name|rackMap
argument_list|)
expr_stmt|;
block|}
name|firstOne
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|cur
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No excess replica can be found. excessTypes: {}."
operator|+
literal|" moreThanOne: {}. exactlyOne: {}."
argument_list|,
name|excessTypes
argument_list|,
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|// adjust rackmap, moreThanOne, and exactlyOne
name|adjustSetsWithChosenReplica
argument_list|(
name|rackMap
argument_list|,
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|excessReplicas
operator|.
name|add
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
return|return
name|excessReplicas
return|;
block|}
comment|/** Check if we can use delHint. */
annotation|@
name|VisibleForTesting
DECL|method|useDelHint (DatanodeStorageInfo delHint, DatanodeStorageInfo added, List<DatanodeStorageInfo> moreThanOne, Collection<DatanodeStorageInfo> exactlyOne, List<StorageType> excessTypes)
name|boolean
name|useDelHint
parameter_list|(
name|DatanodeStorageInfo
name|delHint
parameter_list|,
name|DatanodeStorageInfo
name|added
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|moreThanOne
parameter_list|,
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|exactlyOne
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|excessTypes
parameter_list|)
block|{
if|if
condition|(
name|delHint
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
comment|// no delHint
block|}
elseif|else
if|if
condition|(
operator|!
name|excessTypes
operator|.
name|contains
argument_list|(
name|delHint
operator|.
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// delHint storage type is not an excess type
block|}
else|else
block|{
comment|// check if removing delHint reduces the number of racks
return|return
name|notReduceNumOfGroups
argument_list|(
name|moreThanOne
argument_list|,
name|delHint
argument_list|,
name|added
argument_list|)
return|;
block|}
block|}
comment|// Check if moving from source to target will reduce the number of
comment|// groups. The groups could be based on racks or upgrade domains.
DECL|method|notReduceNumOfGroups (List<T> moreThanOne, T source, T target)
parameter_list|<
name|T
parameter_list|>
name|boolean
name|notReduceNumOfGroups
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|moreThanOne
parameter_list|,
name|T
name|source
parameter_list|,
name|T
name|target
parameter_list|)
block|{
if|if
condition|(
name|moreThanOne
operator|.
name|contains
argument_list|(
name|source
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// source and some other nodes are under the same group.
block|}
elseif|else
if|if
condition|(
name|target
operator|!=
literal|null
operator|&&
operator|!
name|moreThanOne
operator|.
name|contains
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// the added node adds a new group.
block|}
return|return
literal|false
return|;
comment|// removing delHint reduces the number of groups.
block|}
annotation|@
name|Override
DECL|method|isMovable (Collection<DatanodeInfo> locs, DatanodeInfo source, DatanodeInfo target)
specifier|public
name|boolean
name|isMovable
parameter_list|(
name|Collection
argument_list|<
name|DatanodeInfo
argument_list|>
name|locs
parameter_list|,
name|DatanodeInfo
name|source
parameter_list|,
name|DatanodeInfo
name|target
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
argument_list|>
name|rackMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|moreThanOne
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|exactlyOne
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|splitNodesWithRack
argument_list|(
name|locs
argument_list|,
name|locs
argument_list|,
name|rackMap
argument_list|,
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|)
expr_stmt|;
return|return
name|notReduceNumOfGroups
argument_list|(
name|moreThanOne
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
return|;
block|}
comment|/**    * Pick up replica node set for deleting replica as over-replicated.     * First set contains replica nodes on rack with more than one    * replica while second set contains remaining replica nodes.    * If only 1 rack, pick all. If 2 racks, pick all that have more than    * 1 replicas on the same rack; if no such replicas, pick all.    * If 3 or more racks, pick all.    */
DECL|method|pickupReplicaSet ( Collection<DatanodeStorageInfo> moreThanOne, Collection<DatanodeStorageInfo> exactlyOne, Map<String, List<DatanodeStorageInfo>> rackMap)
specifier|protected
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|pickupReplicaSet
parameter_list|(
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|moreThanOne
parameter_list|,
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|exactlyOne
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|>
name|rackMap
parameter_list|)
block|{
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|rackMap
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|dsi
range|:
name|rackMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|dsi
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|ret
operator|.
name|addAll
argument_list|(
name|dsi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Return all replicas if rackMap.size() != 2
comment|// or rackMap.size() == 2 but no shared replicas on any rack
name|ret
operator|.
name|addAll
argument_list|(
name|moreThanOne
argument_list|)
expr_stmt|;
name|ret
operator|.
name|addAll
argument_list|(
name|exactlyOne
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setPreferLocalNode (boolean prefer)
name|void
name|setPreferLocalNode
parameter_list|(
name|boolean
name|prefer
parameter_list|)
block|{
name|this
operator|.
name|preferLocalNode
operator|=
name|prefer
expr_stmt|;
block|}
block|}
end_class

end_unit

