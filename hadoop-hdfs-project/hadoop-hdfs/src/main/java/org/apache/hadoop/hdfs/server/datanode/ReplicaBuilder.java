begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|FileRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_comment
comment|/**  * This class is to be used as a builder for {@link ReplicaInfo} objects.  * The state of the replica is used to determine which object is instantiated.  */
end_comment

begin_class
DECL|class|ReplicaBuilder
specifier|public
class|class
name|ReplicaBuilder
block|{
DECL|field|state
specifier|private
name|ReplicaState
name|state
decl_stmt|;
DECL|field|blockId
specifier|private
name|long
name|blockId
decl_stmt|;
DECL|field|genStamp
specifier|private
name|long
name|genStamp
decl_stmt|;
DECL|field|length
specifier|private
name|long
name|length
decl_stmt|;
DECL|field|volume
specifier|private
name|FsVolumeSpi
name|volume
decl_stmt|;
DECL|field|directoryUsed
specifier|private
name|File
name|directoryUsed
decl_stmt|;
DECL|field|bytesToReserve
specifier|private
name|long
name|bytesToReserve
decl_stmt|;
DECL|field|writer
specifier|private
name|Thread
name|writer
decl_stmt|;
DECL|field|recoveryId
specifier|private
name|long
name|recoveryId
decl_stmt|;
DECL|field|block
specifier|private
name|Block
name|block
decl_stmt|;
DECL|field|lastPartialChunkChecksum
specifier|private
name|byte
index|[]
name|lastPartialChunkChecksum
decl_stmt|;
DECL|field|fromReplica
specifier|private
name|ReplicaInfo
name|fromReplica
decl_stmt|;
DECL|field|uri
specifier|private
name|URI
name|uri
decl_stmt|;
DECL|field|offset
specifier|private
name|long
name|offset
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|fileRegion
specifier|private
name|FileRegion
name|fileRegion
decl_stmt|;
DECL|field|remoteFS
specifier|private
name|FileSystem
name|remoteFS
decl_stmt|;
DECL|field|pathHandle
specifier|private
name|PathHandle
name|pathHandle
decl_stmt|;
DECL|field|pathSuffix
specifier|private
name|String
name|pathSuffix
decl_stmt|;
DECL|field|pathPrefix
specifier|private
name|Path
name|pathPrefix
decl_stmt|;
DECL|method|ReplicaBuilder (ReplicaState state)
specifier|public
name|ReplicaBuilder
parameter_list|(
name|ReplicaState
name|state
parameter_list|)
block|{
name|volume
operator|=
literal|null
expr_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
name|block
operator|=
literal|null
expr_stmt|;
name|length
operator|=
operator|-
literal|1
expr_stmt|;
name|fileRegion
operator|=
literal|null
expr_stmt|;
name|conf
operator|=
literal|null
expr_stmt|;
name|fromReplica
operator|=
literal|null
expr_stmt|;
name|uri
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|pathHandle
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|setState (ReplicaState state)
specifier|public
name|ReplicaBuilder
name|setState
parameter_list|(
name|ReplicaState
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBlockId (long blockId)
specifier|public
name|ReplicaBuilder
name|setBlockId
parameter_list|(
name|long
name|blockId
parameter_list|)
block|{
name|this
operator|.
name|blockId
operator|=
name|blockId
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setGenerationStamp (long genStamp)
specifier|public
name|ReplicaBuilder
name|setGenerationStamp
parameter_list|(
name|long
name|genStamp
parameter_list|)
block|{
name|this
operator|.
name|genStamp
operator|=
name|genStamp
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setLength (long length)
specifier|public
name|ReplicaBuilder
name|setLength
parameter_list|(
name|long
name|length
parameter_list|)
block|{
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setFsVolume (FsVolumeSpi volume)
specifier|public
name|ReplicaBuilder
name|setFsVolume
parameter_list|(
name|FsVolumeSpi
name|volume
parameter_list|)
block|{
name|this
operator|.
name|volume
operator|=
name|volume
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setDirectoryToUse (File dir)
specifier|public
name|ReplicaBuilder
name|setDirectoryToUse
parameter_list|(
name|File
name|dir
parameter_list|)
block|{
name|this
operator|.
name|directoryUsed
operator|=
name|dir
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBytesToReserve (long bytesToReserve)
specifier|public
name|ReplicaBuilder
name|setBytesToReserve
parameter_list|(
name|long
name|bytesToReserve
parameter_list|)
block|{
name|this
operator|.
name|bytesToReserve
operator|=
name|bytesToReserve
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setWriterThread (Thread writer)
specifier|public
name|ReplicaBuilder
name|setWriterThread
parameter_list|(
name|Thread
name|writer
parameter_list|)
block|{
name|this
operator|.
name|writer
operator|=
name|writer
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|from (ReplicaInfo fromReplica)
specifier|public
name|ReplicaBuilder
name|from
parameter_list|(
name|ReplicaInfo
name|fromReplica
parameter_list|)
block|{
name|this
operator|.
name|fromReplica
operator|=
name|fromReplica
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setRecoveryId (long recoveryId)
specifier|public
name|ReplicaBuilder
name|setRecoveryId
parameter_list|(
name|long
name|recoveryId
parameter_list|)
block|{
name|this
operator|.
name|recoveryId
operator|=
name|recoveryId
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setBlock (Block block)
specifier|public
name|ReplicaBuilder
name|setBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setURI (URI uri)
specifier|public
name|ReplicaBuilder
name|setURI
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
name|this
operator|.
name|uri
operator|=
name|uri
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setConf (Configuration conf)
specifier|public
name|ReplicaBuilder
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setOffset (long offset)
specifier|public
name|ReplicaBuilder
name|setOffset
parameter_list|(
name|long
name|offset
parameter_list|)
block|{
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setFileRegion (FileRegion fileRegion)
specifier|public
name|ReplicaBuilder
name|setFileRegion
parameter_list|(
name|FileRegion
name|fileRegion
parameter_list|)
block|{
name|this
operator|.
name|fileRegion
operator|=
name|fileRegion
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setRemoteFS (FileSystem remoteFS)
specifier|public
name|ReplicaBuilder
name|setRemoteFS
parameter_list|(
name|FileSystem
name|remoteFS
parameter_list|)
block|{
name|this
operator|.
name|remoteFS
operator|=
name|remoteFS
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Set the suffix of the {@link Path} associated with the replica.    * Intended to be use only for {@link ProvidedReplica}s.    * @param suffix the path suffix.    * @return the builder with the path suffix set.    */
DECL|method|setPathSuffix (String suffix)
specifier|public
name|ReplicaBuilder
name|setPathSuffix
parameter_list|(
name|String
name|suffix
parameter_list|)
block|{
name|this
operator|.
name|pathSuffix
operator|=
name|suffix
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Set the prefix of the {@link Path} associated with the replica.    * Intended to be use only for {@link ProvidedReplica}s.    * @param prefix the path prefix.    * @return the builder with the path prefix set.    */
DECL|method|setPathPrefix (Path prefix)
specifier|public
name|ReplicaBuilder
name|setPathPrefix
parameter_list|(
name|Path
name|prefix
parameter_list|)
block|{
name|this
operator|.
name|pathPrefix
operator|=
name|prefix
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setPathHandle (PathHandle pathHandle)
specifier|public
name|ReplicaBuilder
name|setPathHandle
parameter_list|(
name|PathHandle
name|pathHandle
parameter_list|)
block|{
name|this
operator|.
name|pathHandle
operator|=
name|pathHandle
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|setLastPartialChunkChecksum (byte[] checksum)
specifier|public
name|ReplicaBuilder
name|setLastPartialChunkChecksum
parameter_list|(
name|byte
index|[]
name|checksum
parameter_list|)
block|{
name|this
operator|.
name|lastPartialChunkChecksum
operator|=
name|checksum
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|buildLocalReplicaInPipeline ()
specifier|public
name|LocalReplicaInPipeline
name|buildLocalReplicaInPipeline
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|LocalReplicaInPipeline
name|info
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RBW
case|:
name|info
operator|=
name|buildRBW
argument_list|()
expr_stmt|;
break|break;
case|case
name|TEMPORARY
case|:
name|info
operator|=
name|buildTemporaryReplica
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown replica state "
operator|+
name|state
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
DECL|method|buildRBW ()
specifier|private
name|LocalReplicaInPipeline
name|buildRBW
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
literal|null
operator|!=
name|fromReplica
operator|&&
name|fromReplica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
return|return
operator|new
name|ReplicaBeingWritten
argument_list|(
operator|(
name|ReplicaBeingWritten
operator|)
name|fromReplica
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
literal|null
operator|!=
name|fromReplica
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incompatible fromReplica "
operator|+
literal|"state: "
operator|+
name|fromReplica
operator|.
name|getState
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
literal|null
operator|!=
name|block
condition|)
block|{
if|if
condition|(
literal|null
operator|==
name|writer
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"A valid writer is "
operator|+
literal|"required for constructing a RBW from block "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|ReplicaBeingWritten
argument_list|(
name|block
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|,
name|writer
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|length
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
operator|new
name|ReplicaBeingWritten
argument_list|(
name|blockId
argument_list|,
name|length
argument_list|,
name|genStamp
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|,
name|writer
argument_list|,
name|bytesToReserve
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ReplicaBeingWritten
argument_list|(
name|blockId
argument_list|,
name|genStamp
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|,
name|bytesToReserve
argument_list|)
return|;
block|}
block|}
block|}
block|}
DECL|method|buildTemporaryReplica ()
specifier|private
name|LocalReplicaInPipeline
name|buildTemporaryReplica
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
literal|null
operator|!=
name|fromReplica
operator|&&
name|fromReplica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|TEMPORARY
condition|)
block|{
return|return
operator|new
name|LocalReplicaInPipeline
argument_list|(
operator|(
name|LocalReplicaInPipeline
operator|)
name|fromReplica
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
literal|null
operator|!=
name|fromReplica
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incompatible fromReplica "
operator|+
literal|"state: "
operator|+
name|fromReplica
operator|.
name|getState
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
literal|null
operator|!=
name|block
condition|)
block|{
if|if
condition|(
literal|null
operator|==
name|writer
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"A valid writer is "
operator|+
literal|"required for constructing a Replica from block "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|LocalReplicaInPipeline
argument_list|(
name|block
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|,
name|writer
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|length
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
operator|new
name|LocalReplicaInPipeline
argument_list|(
name|blockId
argument_list|,
name|length
argument_list|,
name|genStamp
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|,
name|writer
argument_list|,
name|bytesToReserve
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|LocalReplicaInPipeline
argument_list|(
name|blockId
argument_list|,
name|genStamp
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|,
name|bytesToReserve
argument_list|)
return|;
block|}
block|}
block|}
block|}
DECL|method|buildFinalizedReplica ()
specifier|private
name|LocalReplica
name|buildFinalizedReplica
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
literal|null
operator|!=
name|fromReplica
operator|&&
name|fromReplica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
return|return
operator|new
name|FinalizedReplica
argument_list|(
operator|(
name|FinalizedReplica
operator|)
name|fromReplica
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
literal|null
operator|!=
name|this
operator|.
name|fromReplica
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incompatible fromReplica "
operator|+
literal|"state: "
operator|+
name|fromReplica
operator|.
name|getState
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
literal|null
operator|!=
name|block
condition|)
block|{
return|return
operator|new
name|FinalizedReplica
argument_list|(
name|block
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|,
name|lastPartialChunkChecksum
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|FinalizedReplica
argument_list|(
name|blockId
argument_list|,
name|length
argument_list|,
name|genStamp
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|,
name|lastPartialChunkChecksum
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|buildRWR ()
specifier|private
name|LocalReplica
name|buildRWR
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
literal|null
operator|!=
name|fromReplica
operator|&&
name|fromReplica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RWR
condition|)
block|{
return|return
operator|new
name|ReplicaWaitingToBeRecovered
argument_list|(
operator|(
name|ReplicaWaitingToBeRecovered
operator|)
name|fromReplica
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
literal|null
operator|!=
name|fromReplica
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incompatible fromReplica "
operator|+
literal|"state: "
operator|+
name|fromReplica
operator|.
name|getState
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
literal|null
operator|!=
name|block
condition|)
block|{
return|return
operator|new
name|ReplicaWaitingToBeRecovered
argument_list|(
name|block
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ReplicaWaitingToBeRecovered
argument_list|(
name|blockId
argument_list|,
name|length
argument_list|,
name|genStamp
argument_list|,
name|volume
argument_list|,
name|directoryUsed
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|buildRUR ()
specifier|private
name|LocalReplica
name|buildRUR
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
literal|null
operator|==
name|fromReplica
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing a valid replica to recover from"
argument_list|)
throw|;
block|}
if|if
condition|(
literal|null
operator|!=
name|writer
operator|||
literal|null
operator|!=
name|block
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid state for "
operator|+
literal|"recovering from replica with blk id "
operator|+
name|fromReplica
operator|.
name|getBlockId
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|fromReplica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RUR
condition|)
block|{
return|return
operator|new
name|ReplicaUnderRecovery
argument_list|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|fromReplica
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ReplicaUnderRecovery
argument_list|(
name|fromReplica
argument_list|,
name|recoveryId
argument_list|)
return|;
block|}
block|}
DECL|method|buildProvidedFinalizedReplica ()
specifier|private
name|ProvidedReplica
name|buildProvidedFinalizedReplica
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|ProvidedReplica
name|info
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fromReplica
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Finalized PROVIDED replica "
operator|+
literal|"cannot be constructed from another replica"
argument_list|)
throw|;
block|}
if|if
condition|(
name|fileRegion
operator|==
literal|null
operator|&&
name|uri
operator|==
literal|null
operator|&&
operator|(
name|pathPrefix
operator|==
literal|null
operator|||
name|pathSuffix
operator|==
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Trying to construct a provided replica on "
operator|+
name|volume
operator|+
literal|" without enough information"
argument_list|)
throw|;
block|}
if|if
condition|(
name|fileRegion
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
name|info
operator|=
operator|new
name|FinalizedProvidedReplica
argument_list|(
name|blockId
argument_list|,
name|uri
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|genStamp
argument_list|,
name|pathHandle
argument_list|,
name|volume
argument_list|,
name|conf
argument_list|,
name|remoteFS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|=
operator|new
name|FinalizedProvidedReplica
argument_list|(
name|blockId
argument_list|,
name|pathPrefix
argument_list|,
name|pathSuffix
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|genStamp
argument_list|,
name|pathHandle
argument_list|,
name|volume
argument_list|,
name|conf
argument_list|,
name|remoteFS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|info
operator|=
operator|new
name|FinalizedProvidedReplica
argument_list|(
name|fileRegion
argument_list|,
name|volume
argument_list|,
name|conf
argument_list|,
name|remoteFS
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
DECL|method|buildProvidedReplica ()
specifier|private
name|ProvidedReplica
name|buildProvidedReplica
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|ProvidedReplica
name|info
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|this
operator|.
name|state
condition|)
block|{
case|case
name|FINALIZED
case|:
name|info
operator|=
name|buildProvidedFinalizedReplica
argument_list|()
expr_stmt|;
break|break;
case|case
name|RWR
case|:
case|case
name|RUR
case|:
case|case
name|RBW
case|:
case|case
name|TEMPORARY
case|:
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown replica state "
operator|+
name|state
operator|+
literal|" for PROVIDED replica"
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
DECL|method|buildLocalReplica ()
specifier|private
name|LocalReplica
name|buildLocalReplica
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|LocalReplica
name|info
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|this
operator|.
name|state
condition|)
block|{
case|case
name|FINALIZED
case|:
name|info
operator|=
name|buildFinalizedReplica
argument_list|()
expr_stmt|;
break|break;
case|case
name|RWR
case|:
name|info
operator|=
name|buildRWR
argument_list|()
expr_stmt|;
break|break;
case|case
name|RUR
case|:
name|info
operator|=
name|buildRUR
argument_list|()
expr_stmt|;
break|break;
case|case
name|RBW
case|:
case|case
name|TEMPORARY
case|:
name|info
operator|=
name|buildLocalReplicaInPipeline
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown replica state "
operator|+
name|state
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
DECL|method|build ()
specifier|public
name|ReplicaInfo
name|build
parameter_list|()
throws|throws
name|IllegalArgumentException
block|{
name|ReplicaInfo
name|info
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|volume
operator|!=
literal|null
operator|&&
name|volume
operator|.
name|getStorageType
argument_list|()
operator|==
name|StorageType
operator|.
name|PROVIDED
condition|)
block|{
name|info
operator|=
name|buildProvidedReplica
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|info
operator|=
name|buildLocalReplica
argument_list|()
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
block|}
end_class

end_unit

