begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode.metrics
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|metrics
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * A utility class to help detect resources (nodes/ disks) whose aggregate  * latency is an outlier within a given set.  *  * We use the median absolute deviation for outlier detection as  * described in the following publication:  *  * Leys, C., et al., Detecting outliers: Do not use standard deviation  * around the mean, use absolute deviation around the median.  * http://dx.doi.org/10.1016/j.jesp.2013.03.013  *  * We augment the above scheme with the following heuristics to be even  * more conservative:  *  *  1. Skip outlier detection if the sample size is too small.  *  2. Never flag resources whose aggregate latency is below a low threshold.  *  3. Never flag resources whose aggregate latency is less than a small  *     multiple of the median.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|OutlierDetector
specifier|public
class|class
name|OutlierDetector
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|OutlierDetector
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Minimum number of resources to run outlier detection.    */
DECL|field|minNumResources
specifier|private
specifier|final
name|long
name|minNumResources
decl_stmt|;
comment|/**    * The multiplier is from Leys, C. et al.    */
DECL|field|MAD_MULTIPLIER
specifier|private
specifier|static
specifier|final
name|double
name|MAD_MULTIPLIER
init|=
operator|(
name|double
operator|)
literal|1.4826
decl_stmt|;
comment|/**    * Threshold in milliseconds below which a node/ disk is definitely not slow.    */
DECL|field|lowThresholdMs
specifier|private
specifier|final
name|long
name|lowThresholdMs
decl_stmt|;
comment|/**    * Deviation multiplier. A sample is considered to be an outlier if it    * exceeds the median by (multiplier * median abs. deviation). 3 is a    * conservative choice.    */
DECL|field|DEVIATION_MULTIPLIER
specifier|private
specifier|static
specifier|final
name|int
name|DEVIATION_MULTIPLIER
init|=
literal|3
decl_stmt|;
comment|/**    * If most of the samples are clustered together, the MAD can be    * low. The median multiplier introduces another safeguard to avoid    * overaggressive outlier detection.    */
annotation|@
name|VisibleForTesting
DECL|field|MEDIAN_MULTIPLIER
specifier|static
specifier|final
name|int
name|MEDIAN_MULTIPLIER
init|=
literal|3
decl_stmt|;
DECL|method|OutlierDetector (long minNumResources, long lowThresholdMs)
specifier|public
name|OutlierDetector
parameter_list|(
name|long
name|minNumResources
parameter_list|,
name|long
name|lowThresholdMs
parameter_list|)
block|{
name|this
operator|.
name|minNumResources
operator|=
name|minNumResources
expr_stmt|;
name|this
operator|.
name|lowThresholdMs
operator|=
name|lowThresholdMs
expr_stmt|;
block|}
comment|/**    * Return a set of nodes/ disks whose latency is much higher than    * their counterparts. The input is a map of (resource {@literal ->} aggregate    * latency)    * entries.    *    * The aggregate may be an arithmetic mean or a percentile e.g.    * 90th percentile. Percentiles are a better choice than median    * since latency is usually not a normal distribution.    *    * This method allocates temporary memory O(n) and    * has run time O(n.log(n)), where n = stats.size().    *    * @return    */
DECL|method|getOutliers (Map<String, Double> stats)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|getOutliers
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|stats
parameter_list|)
block|{
if|if
condition|(
name|stats
operator|.
name|size
argument_list|()
operator|<
name|minNumResources
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping statistical outlier detection as we don't have "
operator|+
literal|"latency data for enough resources. Have {}, need at least {}"
argument_list|,
name|stats
operator|.
name|size
argument_list|()
argument_list|,
name|minNumResources
argument_list|)
expr_stmt|;
return|return
name|ImmutableMap
operator|.
name|of
argument_list|()
return|;
block|}
comment|// Compute the median absolute deviation of the aggregates.
specifier|final
name|List
argument_list|<
name|Double
argument_list|>
name|sorted
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|stats
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
specifier|final
name|Double
name|median
init|=
name|computeMedian
argument_list|(
name|sorted
argument_list|)
decl_stmt|;
specifier|final
name|Double
name|mad
init|=
name|computeMad
argument_list|(
name|sorted
argument_list|)
decl_stmt|;
name|Double
name|upperLimitLatency
init|=
name|Math
operator|.
name|max
argument_list|(
name|lowThresholdMs
argument_list|,
name|median
operator|*
name|MEDIAN_MULTIPLIER
argument_list|)
decl_stmt|;
name|upperLimitLatency
operator|=
name|Math
operator|.
name|max
argument_list|(
name|upperLimitLatency
argument_list|,
name|median
operator|+
operator|(
name|DEVIATION_MULTIPLIER
operator|*
name|mad
operator|)
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|slowResources
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"getOutliers: List={}, MedianLatency={}, "
operator|+
literal|"MedianAbsoluteDeviation={}, upperLimitLatency={}"
argument_list|,
name|sorted
argument_list|,
name|median
argument_list|,
name|mad
argument_list|,
name|upperLimitLatency
argument_list|)
expr_stmt|;
comment|// Find resources whose latency exceeds the threshold.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Double
argument_list|>
name|entry
range|:
name|stats
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|>
name|upperLimitLatency
condition|)
block|{
name|slowResources
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|slowResources
return|;
block|}
comment|/**    * Compute the Median Absolute Deviation of a sorted list.    */
DECL|method|computeMad (List<Double> sortedValues)
specifier|public
specifier|static
name|Double
name|computeMad
parameter_list|(
name|List
argument_list|<
name|Double
argument_list|>
name|sortedValues
parameter_list|)
block|{
if|if
condition|(
name|sortedValues
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot compute the Median Absolute Deviation "
operator|+
literal|"of an empty list."
argument_list|)
throw|;
block|}
comment|// First get the median of the values.
name|Double
name|median
init|=
name|computeMedian
argument_list|(
name|sortedValues
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Double
argument_list|>
name|deviations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|sortedValues
argument_list|)
decl_stmt|;
comment|// Then update the list to store deviation from the median.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedValues
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|deviations
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|Math
operator|.
name|abs
argument_list|(
name|sortedValues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|-
name|median
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Finally get the median absolute deviation.
name|Collections
operator|.
name|sort
argument_list|(
name|deviations
argument_list|)
expr_stmt|;
return|return
name|computeMedian
argument_list|(
name|deviations
argument_list|)
operator|*
name|MAD_MULTIPLIER
return|;
block|}
comment|/**    * Compute the median of a sorted list.    */
DECL|method|computeMedian (List<Double> sortedValues)
specifier|public
specifier|static
name|Double
name|computeMedian
parameter_list|(
name|List
argument_list|<
name|Double
argument_list|>
name|sortedValues
parameter_list|)
block|{
if|if
condition|(
name|sortedValues
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot compute the median of an empty list."
argument_list|)
throw|;
block|}
name|Double
name|median
init|=
name|sortedValues
operator|.
name|get
argument_list|(
name|sortedValues
operator|.
name|size
argument_list|()
operator|/
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortedValues
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|median
operator|+=
name|sortedValues
operator|.
name|get
argument_list|(
operator|(
name|sortedValues
operator|.
name|size
argument_list|()
operator|/
literal|2
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|median
operator|/=
literal|2
expr_stmt|;
block|}
return|return
name|median
return|;
block|}
block|}
end_class

end_unit

