begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|rawcoder
operator|.
name|RSRawEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|rawcoder
operator|.
name|RawErasureEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Sampler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|TraceScope
import|;
end_import

begin_comment
comment|/****************************************************************  * The DFSStripedOutputStream class supports writing files in striped  * layout. Each stripe contains a sequence of cells and multiple  * {@link StripedDataStreamer}s in DFSStripedOutputStream are responsible  * for writing the cells to different datanodes.  *  ****************************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|DFSStripedOutputStream
specifier|public
class|class
name|DFSStripedOutputStream
extends|extends
name|DFSOutputStream
block|{
DECL|field|streamers
specifier|private
specifier|final
name|List
argument_list|<
name|StripedDataStreamer
argument_list|>
name|streamers
decl_stmt|;
comment|/**    * Size of each striping cell, must be a multiple of bytesPerChecksum    */
DECL|field|cellSize
specifier|private
name|int
name|cellSize
init|=
name|HdfsConstants
operator|.
name|BLOCK_STRIPED_CELL_SIZE
decl_stmt|;
DECL|field|cellBuffers
specifier|private
name|ByteBuffer
index|[]
name|cellBuffers
decl_stmt|;
DECL|field|blockGroupBlocks
specifier|private
specifier|final
name|short
name|blockGroupBlocks
init|=
name|HdfsConstants
operator|.
name|NUM_DATA_BLOCKS
operator|+
name|HdfsConstants
operator|.
name|NUM_PARITY_BLOCKS
decl_stmt|;
DECL|field|blockGroupDataBlocks
specifier|private
specifier|final
name|short
name|blockGroupDataBlocks
init|=
name|HdfsConstants
operator|.
name|NUM_DATA_BLOCKS
decl_stmt|;
DECL|field|curIdx
specifier|private
name|int
name|curIdx
init|=
literal|0
decl_stmt|;
comment|/* bytes written in current block group */
DECL|field|currentBlockGroupBytes
specifier|private
name|long
name|currentBlockGroupBytes
init|=
literal|0
decl_stmt|;
comment|//TODO: Use ErasureCoder interface (HDFS-7781)
DECL|field|encoder
specifier|private
name|RawErasureEncoder
name|encoder
decl_stmt|;
DECL|method|getLeadingStreamer ()
specifier|private
name|StripedDataStreamer
name|getLeadingStreamer
parameter_list|()
block|{
return|return
name|streamers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
DECL|method|getBlockGroupSize ()
specifier|private
name|long
name|getBlockGroupSize
parameter_list|()
block|{
return|return
name|blockSize
operator|*
name|HdfsConstants
operator|.
name|NUM_DATA_BLOCKS
return|;
block|}
comment|/** Construct a new output stream for creating a file. */
DECL|method|DFSStripedOutputStream (DFSClient dfsClient, String src, HdfsFileStatus stat, EnumSet<CreateFlag> flag, Progressable progress, DataChecksum checksum, String[] favoredNodes)
name|DFSStripedOutputStream
parameter_list|(
name|DFSClient
name|dfsClient
parameter_list|,
name|String
name|src
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|DataChecksum
name|checksum
parameter_list|,
name|String
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|dfsClient
argument_list|,
name|src
argument_list|,
name|stat
argument_list|,
name|flag
argument_list|,
name|progress
argument_list|,
name|checksum
argument_list|,
name|favoredNodes
argument_list|)
expr_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating striped output stream"
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockGroupBlocks
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The block group must contain more than one block."
argument_list|)
throw|;
block|}
name|cellBuffers
operator|=
operator|new
name|ByteBuffer
index|[
name|blockGroupBlocks
index|]
expr_stmt|;
name|List
argument_list|<
name|BlockingQueue
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|>
name|stripeBlocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockGroupBlocks
condition|;
name|i
operator|++
control|)
block|{
name|stripeBlocks
operator|.
name|add
argument_list|(
operator|new
name|LinkedBlockingQueue
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|(
name|blockGroupBlocks
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|cellBuffers
index|[
name|i
index|]
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|byteArrayManager
operator|.
name|newByteArray
argument_list|(
name|cellSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
specifier|final
name|InterruptedIOException
name|iioe
init|=
operator|new
name|InterruptedIOException
argument_list|(
literal|"create cell buffers"
argument_list|)
decl_stmt|;
name|iioe
operator|.
name|initCause
argument_list|(
name|ie
argument_list|)
expr_stmt|;
throw|throw
name|iioe
throw|;
block|}
block|}
name|encoder
operator|=
operator|new
name|RSRawEncoder
argument_list|()
expr_stmt|;
name|encoder
operator|.
name|initialize
argument_list|(
name|blockGroupDataBlocks
argument_list|,
name|blockGroupBlocks
operator|-
name|blockGroupDataBlocks
argument_list|,
name|cellSize
argument_list|)
expr_stmt|;
name|streamers
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|blockGroupBlocks
argument_list|)
expr_stmt|;
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockGroupBlocks
condition|;
name|i
operator|++
control|)
block|{
name|StripedDataStreamer
name|streamer
init|=
operator|new
name|StripedDataStreamer
argument_list|(
name|stat
argument_list|,
literal|null
argument_list|,
name|dfsClient
argument_list|,
name|src
argument_list|,
name|progress
argument_list|,
name|checksum
argument_list|,
name|cachingStrategy
argument_list|,
name|byteArrayManager
argument_list|,
name|i
argument_list|,
name|stripeBlocks
argument_list|)
decl_stmt|;
if|if
condition|(
name|favoredNodes
operator|!=
literal|null
operator|&&
name|favoredNodes
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|streamer
operator|.
name|setFavoredNodes
argument_list|(
name|favoredNodes
argument_list|)
expr_stmt|;
block|}
name|streamers
operator|.
name|add
argument_list|(
name|streamer
argument_list|)
expr_stmt|;
block|}
name|refreshStreamer
argument_list|()
expr_stmt|;
block|}
DECL|method|refreshStreamer ()
specifier|private
name|void
name|refreshStreamer
parameter_list|()
block|{
name|streamer
operator|=
name|streamers
operator|.
name|get
argument_list|(
name|curIdx
argument_list|)
expr_stmt|;
block|}
DECL|method|moveToNextStreamer ()
specifier|private
name|void
name|moveToNextStreamer
parameter_list|()
block|{
name|curIdx
operator|=
operator|(
name|curIdx
operator|+
literal|1
operator|)
operator|%
name|blockGroupBlocks
expr_stmt|;
name|refreshStreamer
argument_list|()
expr_stmt|;
block|}
comment|/**    * encode the buffers.    * After encoding, flip each buffer.    *    * @param buffers data buffers + parity buffers    */
DECL|method|encode (ByteBuffer[] buffers)
specifier|private
name|void
name|encode
parameter_list|(
name|ByteBuffer
index|[]
name|buffers
parameter_list|)
block|{
name|ByteBuffer
index|[]
name|dataBuffers
init|=
operator|new
name|ByteBuffer
index|[
name|blockGroupDataBlocks
index|]
decl_stmt|;
name|ByteBuffer
index|[]
name|parityBuffers
init|=
operator|new
name|ByteBuffer
index|[
name|blockGroupBlocks
operator|-
name|blockGroupDataBlocks
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockGroupBlocks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|blockGroupDataBlocks
condition|)
block|{
name|dataBuffers
index|[
name|i
index|]
operator|=
name|buffers
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|parityBuffers
index|[
name|i
operator|-
name|blockGroupDataBlocks
index|]
operator|=
name|buffers
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|encoder
operator|.
name|encode
argument_list|(
name|dataBuffers
argument_list|,
name|parityBuffers
argument_list|)
expr_stmt|;
block|}
comment|/**    * Generate packets from a given buffer    *    * @param byteBuffer the given buffer to generate packets    * @return packets generated    * @throws IOException    */
DECL|method|generatePackets (ByteBuffer byteBuffer)
specifier|private
name|List
argument_list|<
name|DFSPacket
argument_list|>
name|generatePackets
parameter_list|(
name|ByteBuffer
name|byteBuffer
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|DFSPacket
argument_list|>
name|packets
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|byteBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
name|DFSPacket
name|p
init|=
name|createPacket
argument_list|(
name|packetSize
argument_list|,
name|chunksPerPacket
argument_list|,
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|,
name|streamer
operator|.
name|getAndIncCurrentSeqno
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|maxBytesToPacket
init|=
name|p
operator|.
name|getMaxChunks
argument_list|()
operator|*
name|bytesPerChecksum
decl_stmt|;
name|int
name|toWrite
init|=
name|byteBuffer
operator|.
name|remaining
argument_list|()
operator|>
name|maxBytesToPacket
condition|?
name|maxBytesToPacket
else|:
name|byteBuffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|p
operator|.
name|writeData
argument_list|(
name|byteBuffer
argument_list|,
name|toWrite
argument_list|)
expr_stmt|;
name|streamer
operator|.
name|incBytesCurBlock
argument_list|(
name|toWrite
argument_list|)
expr_stmt|;
name|packets
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|packets
return|;
block|}
annotation|@
name|Override
DECL|method|writeChunk (byte[] b, int offset, int len, byte[] checksum, int ckoff, int cklen)
specifier|protected
specifier|synchronized
name|void
name|writeChunk
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|byte
index|[]
name|checksum
parameter_list|,
name|int
name|ckoff
parameter_list|,
name|int
name|cklen
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeChunk
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|checksum
argument_list|,
name|ckoff
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|getSizeOfCellnBuffer
argument_list|(
name|curIdx
argument_list|)
operator|<=
name|cellSize
condition|)
block|{
name|addToCellBuffer
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Writing a chunk should not overflow the cell buffer."
decl_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
comment|// If current packet has not been enqueued for transmission,
comment|// but the cell buffer is full, we need to enqueue the packet
if|if
condition|(
name|currentPacket
operator|!=
literal|null
operator|&&
name|getSizeOfCellnBuffer
argument_list|(
name|curIdx
argument_list|)
operator|==
name|cellSize
condition|)
block|{
if|if
condition|(
name|DFSClient
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"DFSClient writeChunk cell buffer full seqno="
operator|+
name|currentPacket
operator|.
name|getSeqno
argument_list|()
operator|+
literal|", curIdx="
operator|+
name|curIdx
operator|+
literal|", src="
operator|+
name|src
operator|+
literal|", bytesCurBlock="
operator|+
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|+
literal|", blockSize="
operator|+
name|blockSize
operator|+
literal|", appendChunk="
operator|+
name|streamer
operator|.
name|getAppendChunk
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|streamer
operator|.
name|waitAndQueuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
name|adjustChunkBoundary
argument_list|()
expr_stmt|;
name|endBlock
argument_list|()
expr_stmt|;
block|}
comment|// Two extra steps are needed when a striping cell is full:
comment|// 1. Forward the current index pointer
comment|// 2. Generate parity packets if a full stripe of data cells are present
if|if
condition|(
name|getSizeOfCellnBuffer
argument_list|(
name|curIdx
argument_list|)
operator|==
name|cellSize
condition|)
block|{
comment|//move curIdx to next cell
name|moveToNextStreamer
argument_list|()
expr_stmt|;
comment|//When all data cells in a stripe are ready, we need to encode
comment|//them and generate some parity cells. These cells will be
comment|//converted to packets and put to their DataStreamer's queue.
if|if
condition|(
name|curIdx
operator|==
name|blockGroupDataBlocks
condition|)
block|{
comment|//encode the data cells
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|blockGroupDataBlocks
condition|;
name|k
operator|++
control|)
block|{
name|cellBuffers
index|[
name|k
index|]
operator|.
name|flip
argument_list|()
expr_stmt|;
block|}
name|encode
argument_list|(
name|cellBuffers
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|blockGroupDataBlocks
init|;
name|i
operator|<
name|blockGroupBlocks
condition|;
name|i
operator|++
control|)
block|{
name|ByteBuffer
name|parityBuffer
init|=
name|cellBuffers
index|[
name|i
index|]
decl_stmt|;
name|List
argument_list|<
name|DFSPacket
argument_list|>
name|packets
init|=
name|generatePackets
argument_list|(
name|parityBuffer
argument_list|)
decl_stmt|;
for|for
control|(
name|DFSPacket
name|p
range|:
name|packets
control|)
block|{
name|currentPacket
operator|=
name|p
expr_stmt|;
name|streamer
operator|.
name|waitAndQueuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
block|}
name|endBlock
argument_list|()
expr_stmt|;
name|moveToNextStreamer
argument_list|()
expr_stmt|;
block|}
comment|//read next stripe to cellBuffers
name|clearCellBuffers
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|addToCellBuffer (byte[] b, int off, int len)
specifier|private
name|void
name|addToCellBuffer
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|cellBuffers
index|[
name|curIdx
index|]
operator|.
name|put
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
DECL|method|getSizeOfCellnBuffer (int cellIndex)
specifier|private
name|int
name|getSizeOfCellnBuffer
parameter_list|(
name|int
name|cellIndex
parameter_list|)
block|{
return|return
name|cellBuffers
index|[
name|cellIndex
index|]
operator|.
name|position
argument_list|()
return|;
block|}
DECL|method|clearCellBuffers ()
specifier|private
name|void
name|clearCellBuffers
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockGroupBlocks
condition|;
name|i
operator|++
control|)
block|{
name|cellBuffers
index|[
name|i
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|stripeDataSize ()
specifier|private
name|int
name|stripeDataSize
parameter_list|()
block|{
return|return
name|blockGroupDataBlocks
operator|*
name|cellSize
return|;
block|}
DECL|method|notSupported (String headMsg)
specifier|private
name|void
name|notSupported
parameter_list|(
name|String
name|headMsg
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|headMsg
operator|+
literal|" is now not supported for striping layout."
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|hflush ()
specifier|public
name|void
name|hflush
parameter_list|()
throws|throws
name|IOException
block|{
name|notSupported
argument_list|(
literal|"hflush"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hsync ()
specifier|public
name|void
name|hsync
parameter_list|()
throws|throws
name|IOException
block|{
name|notSupported
argument_list|(
literal|"hsync"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|start ()
specifier|protected
specifier|synchronized
name|void
name|start
parameter_list|()
block|{
for|for
control|(
name|StripedDataStreamer
name|streamer
range|:
name|streamers
control|)
block|{
name|streamer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|abort ()
specifier|synchronized
name|void
name|abort
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|StripedDataStreamer
name|streamer
range|:
name|streamers
control|)
block|{
name|streamer
operator|.
name|setLastException
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Lease timeout of "
operator|+
operator|(
name|dfsClient
operator|.
name|getHdfsTimeout
argument_list|()
operator|/
literal|1000
operator|)
operator|+
literal|" seconds expired."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|closeThreads
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|endFileLease
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
block|}
comment|//TODO: Handle slow writers (HDFS-7786)
comment|//Cuurently only check if the leading streamer is terminated
DECL|method|isClosed ()
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|closed
operator|||
name|getLeadingStreamer
argument_list|()
operator|.
name|streamerClosed
argument_list|()
return|;
block|}
comment|// shutdown datastreamer and responseprocessor threads.
comment|// interrupt datastreamer if force is true
annotation|@
name|Override
DECL|method|closeThreads (boolean force)
specifier|protected
name|void
name|closeThreads
parameter_list|(
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|StripedDataStreamer
name|leadingStreamer
init|=
literal|null
decl_stmt|;
for|for
control|(
name|StripedDataStreamer
name|streamer
range|:
name|streamers
control|)
block|{
try|try
block|{
name|streamer
operator|.
name|close
argument_list|(
name|force
argument_list|)
expr_stmt|;
name|streamer
operator|.
name|join
argument_list|()
expr_stmt|;
name|streamer
operator|.
name|closeSocket
argument_list|()
expr_stmt|;
if|if
condition|(
name|streamer
operator|.
name|isLeadingStreamer
argument_list|()
condition|)
block|{
name|leadingStreamer
operator|=
name|streamer
expr_stmt|;
block|}
else|else
block|{
name|streamer
operator|.
name|countTailingBlockGroupBytes
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to shutdown streamer"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|streamer
operator|.
name|setSocketToNull
argument_list|()
expr_stmt|;
name|setClosed
argument_list|()
expr_stmt|;
block|}
block|}
name|leadingStreamer
operator|.
name|countTailingBlockGroupBytes
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
specifier|synchronized
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|currentBlockGroupBytes
operator|=
operator|(
name|currentBlockGroupBytes
operator|+
literal|1
operator|)
operator|%
name|getBlockGroupSize
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write (byte b[], int off, int len)
specifier|public
specifier|synchronized
name|void
name|write
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|currentBlockGroupBytes
operator|=
operator|(
name|currentBlockGroupBytes
operator|+
name|len
operator|)
operator|%
name|getBlockGroupSize
argument_list|()
expr_stmt|;
block|}
DECL|method|writeParityCellsForLastStripe ()
specifier|private
name|void
name|writeParityCellsForLastStripe
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentBlockGroupBytes
operator|==
literal|0
operator|||
name|currentBlockGroupBytes
operator|%
name|stripeDataSize
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|int
name|lastStripeLen
init|=
call|(
name|int
call|)
argument_list|(
name|currentBlockGroupBytes
operator|%
name|stripeDataSize
argument_list|()
argument_list|)
decl_stmt|;
comment|// Size of parity cells should equal the size of the first cell, if it
comment|// is not full.
name|int
name|parityCellSize
init|=
name|cellSize
decl_stmt|;
name|int
name|index
init|=
name|lastStripeLen
operator|/
name|cellSize
decl_stmt|;
if|if
condition|(
name|lastStripeLen
operator|<
name|cellSize
condition|)
block|{
name|parityCellSize
operator|=
name|lastStripeLen
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockGroupBlocks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|index
condition|)
block|{
name|int
name|position
init|=
name|cellBuffers
index|[
name|i
index|]
operator|.
name|position
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|parityCellSize
operator|-
name|position
condition|;
name|j
operator|++
control|)
block|{
name|cellBuffers
index|[
name|i
index|]
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|cellBuffers
index|[
name|i
index|]
operator|.
name|flip
argument_list|()
expr_stmt|;
block|}
name|encode
argument_list|(
name|cellBuffers
argument_list|)
expr_stmt|;
comment|//write parity cells
name|curIdx
operator|=
name|blockGroupDataBlocks
expr_stmt|;
name|refreshStreamer
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|blockGroupDataBlocks
init|;
name|i
operator|<
name|blockGroupBlocks
condition|;
name|i
operator|++
control|)
block|{
name|ByteBuffer
name|parityBuffer
init|=
name|cellBuffers
index|[
name|i
index|]
decl_stmt|;
name|List
argument_list|<
name|DFSPacket
argument_list|>
name|packets
init|=
name|generatePackets
argument_list|(
name|parityBuffer
argument_list|)
decl_stmt|;
for|for
control|(
name|DFSPacket
name|p
range|:
name|packets
control|)
block|{
name|currentPacket
operator|=
name|p
expr_stmt|;
name|streamer
operator|.
name|waitAndQueuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
block|}
name|endBlock
argument_list|()
expr_stmt|;
name|moveToNextStreamer
argument_list|()
expr_stmt|;
block|}
name|clearCellBuffers
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setClosed ()
name|void
name|setClosed
parameter_list|()
block|{
name|super
operator|.
name|setClosed
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockGroupBlocks
condition|;
name|i
operator|++
control|)
block|{
name|byteArrayManager
operator|.
name|release
argument_list|(
name|cellBuffers
index|[
name|i
index|]
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
name|streamers
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|closeImpl ()
specifier|protected
specifier|synchronized
name|void
name|closeImpl
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
name|IOException
name|e
init|=
name|getLeadingStreamer
argument_list|()
operator|.
name|getLastException
argument_list|()
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
return|return;
else|else
throw|throw
name|e
throw|;
block|}
try|try
block|{
comment|// flush from all upper layers
name|flushBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentPacket
operator|!=
literal|null
condition|)
block|{
name|streamer
operator|.
name|waitAndQueuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
block|}
comment|//if the last stripe is incomplete, generate and write parity cells
name|writeParityCellsForLastStripe
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockGroupBlocks
condition|;
name|i
operator|++
control|)
block|{
name|curIdx
operator|=
name|i
expr_stmt|;
name|refreshStreamer
argument_list|()
expr_stmt|;
if|if
condition|(
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|!=
literal|0
operator|||
name|currentBlockGroupBytes
operator|<
name|getBlockGroupSize
argument_list|()
condition|)
block|{
comment|// send an empty packet to mark the end of the block
name|currentPacket
operator|=
name|createPacket
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|,
name|streamer
operator|.
name|getAndIncCurrentSeqno
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|currentPacket
operator|.
name|setSyncBlock
argument_list|(
name|shouldSyncBlock
argument_list|)
expr_stmt|;
block|}
comment|// flush all data to Datanode
name|flushInternal
argument_list|()
expr_stmt|;
block|}
comment|// get last block before destroying the streamer
name|ExtendedBlock
name|lastBlock
init|=
name|streamers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|closeThreads
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"completeFile"
argument_list|,
name|Sampler
operator|.
name|NEVER
argument_list|)
decl_stmt|;
try|try
block|{
name|completeFile
argument_list|(
name|lastBlock
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|dfsClient
operator|.
name|endFileLease
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{     }
finally|finally
block|{
name|setClosed
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

