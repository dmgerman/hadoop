begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode.sps
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|sps
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|StoragePolicySatisfierMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|StoragePolicySatisfyPathStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|Namesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|sps
operator|.
name|ExternalStoragePolicySatisfier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This manages satisfy storage policy invoked path ids and expose methods to  * process these path ids. It maintains sps mode(INTERNAL/EXTERNAL/NONE)  * configured by the administrator.  *  *<p>  * If the configured mode is {@link StoragePolicySatisfierMode.INTERNAL}, then  * it will start internal sps daemon service inside namenode and process sps  * invoked path ids to satisfy the storage policy.  *  *<p>  * If the configured mode is {@link StoragePolicySatisfierMode.EXTERNAL}, then  * it won't do anything, just maintains the sps invoked path ids. Administrator  * requires to start external sps service explicitly, to fetch the sps invoked  * path ids from namenode, then do necessary computations and block movement in  * order to satisfy the storage policy. Please refer  * {@link ExternalStoragePolicySatisfier} class to understand more about the  * external sps service functionality.  *  *<p>  * If the configured mode is {@link StoragePolicySatisfierMode.NONE}, then it  * will disable the sps feature completely by clearing all queued up sps path's  * hint.  *  * This class is instantiated by the BlockManager.  */
end_comment

begin_class
DECL|class|StoragePolicySatisfyManager
specifier|public
class|class
name|StoragePolicySatisfyManager
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StoragePolicySatisfyManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|spsService
specifier|private
specifier|final
name|StoragePolicySatisfier
name|spsService
decl_stmt|;
DECL|field|storagePolicyEnabled
specifier|private
specifier|final
name|boolean
name|storagePolicyEnabled
decl_stmt|;
DECL|field|mode
specifier|private
specifier|volatile
name|StoragePolicySatisfierMode
name|mode
decl_stmt|;
DECL|field|pathsToBeTraveresed
specifier|private
specifier|final
name|Queue
argument_list|<
name|Long
argument_list|>
name|pathsToBeTraveresed
decl_stmt|;
DECL|field|outstandingPathsLimit
specifier|private
specifier|final
name|int
name|outstandingPathsLimit
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|Namesystem
name|namesystem
decl_stmt|;
DECL|field|blkMgr
specifier|private
specifier|final
name|BlockManager
name|blkMgr
decl_stmt|;
DECL|method|StoragePolicySatisfyManager (Configuration conf, Namesystem namesystem, BlockManager blkMgr)
specifier|public
name|StoragePolicySatisfyManager
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Namesystem
name|namesystem
parameter_list|,
name|BlockManager
name|blkMgr
parameter_list|)
block|{
comment|// StoragePolicySatisfier(SPS) configs
name|storagePolicyEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|String
name|modeVal
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_SATISFIER_MODE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_SATISFIER_MODE_DEFAULT
argument_list|)
decl_stmt|;
name|outstandingPathsLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_SPS_MAX_OUTSTANDING_PATHS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_SPS_MAX_OUTSTANDING_PATHS_DEFAULT
argument_list|)
expr_stmt|;
name|mode
operator|=
name|StoragePolicySatisfierMode
operator|.
name|fromString
argument_list|(
name|modeVal
argument_list|)
expr_stmt|;
name|pathsToBeTraveresed
operator|=
operator|new
name|LinkedList
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
comment|// instantiate SPS service by just keeps config reference and not starting
comment|// any supporting threads.
name|spsService
operator|=
operator|new
name|StoragePolicySatisfier
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
name|this
operator|.
name|blkMgr
operator|=
name|blkMgr
expr_stmt|;
block|}
comment|/**    * This function will do following logic based on the configured sps mode:    *    *<p>    * If the configured mode is {@link StoragePolicySatisfierMode.INTERNAL}, then    * starts internal daemon service inside namenode.    *    *<p>    * If the configured mode is {@link StoragePolicySatisfierMode.EXTERNAL}, then    * it won't do anything. Administrator requires to start external sps service    * explicitly.    *    *<p>    * If the configured mode is {@link StoragePolicySatisfierMode.NONE}, then the    * service is disabled and won't do any action.    */
DECL|method|start ()
specifier|public
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
operator|!
name|storagePolicyEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabling StoragePolicySatisfier service as {} set to {}."
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_KEY
argument_list|,
name|storagePolicyEnabled
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|INTERNAL
case|:
if|if
condition|(
name|spsService
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage policy satisfier is already running"
operator|+
literal|" as internal daemon service inside namenode."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// starts internal daemon service inside namenode
name|spsService
operator|.
name|init
argument_list|(
operator|new
name|IntraSPSNameNodeContext
argument_list|(
name|namesystem
argument_list|,
name|blkMgr
argument_list|,
name|spsService
argument_list|)
argument_list|)
expr_stmt|;
name|spsService
operator|.
name|start
argument_list|(
literal|false
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTERNAL
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage policy satisfier is configured as external, "
operator|+
literal|"please start external sps service explicitly to satisfy policy"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NONE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage policy satisfier is disabled"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|info
argument_list|(
literal|"Given mode: {} is invalid"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/**    * This function will do following logic based on the configured sps mode:    *    *<p>    * If the configured mode is {@link StoragePolicySatisfierMode.INTERNAL}, then    * stops internal daemon service inside namenode.    *    *<p>    * If the configured mode is {@link StoragePolicySatisfierMode.EXTERNAL}, then    * it won't do anything. Administrator requires to stop external sps service    * explicitly, if needed.    *    *<p>    * If the configured mode is {@link StoragePolicySatisfierMode.NONE}, then the    * service is disabled and won't do any action.    */
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|storagePolicyEnabled
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storage policy is not enabled, ignoring"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|INTERNAL
case|:
name|removeAllPathIds
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|spsService
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Internal storage policy satisfier daemon service"
operator|+
literal|" is not running"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// stops internal daemon service running inside namenode
name|spsService
operator|.
name|stop
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTERNAL
case|:
name|removeAllPathIds
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storage policy satisfier service is running outside namenode"
operator|+
literal|", ignoring"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NONE
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storage policy satisfier is not enabled, ignoring"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Invalid mode:{}, ignoring"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/**    * Sets new sps mode. If the new mode is internal, then it will start internal    * sps service inside namenode. If the new mode is external, then stops    * internal sps service running(if any) inside namenode. If the new mode is    * none, then it will disable the sps feature completely by clearing all    * queued up sps path's hint.    */
DECL|method|changeModeEvent (StoragePolicySatisfierMode newMode)
specifier|public
name|void
name|changeModeEvent
parameter_list|(
name|StoragePolicySatisfierMode
name|newMode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|storagePolicyEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to change storage policy satisfier as {} set to {}."
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_KEY
argument_list|,
name|storagePolicyEnabled
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating SPS service status, current mode:{}, new mode:{}"
argument_list|,
name|mode
argument_list|,
name|newMode
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|newMode
condition|)
block|{
case|case
name|INTERNAL
case|:
if|if
condition|(
name|spsService
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage policy satisfier is already running as {} mode."
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
name|spsService
operator|.
name|init
argument_list|(
operator|new
name|IntraSPSNameNodeContext
argument_list|(
name|this
operator|.
name|namesystem
argument_list|,
name|this
operator|.
name|blkMgr
argument_list|,
name|spsService
argument_list|)
argument_list|)
expr_stmt|;
name|spsService
operator|.
name|start
argument_list|(
literal|true
argument_list|,
name|newMode
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTERNAL
case|:
if|if
condition|(
name|mode
operator|==
name|newMode
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage policy satisfier is already in mode:{},"
operator|+
literal|" so ignoring change mode event."
argument_list|,
name|newMode
argument_list|)
expr_stmt|;
return|return;
block|}
name|spsService
operator|.
name|stopGracefully
argument_list|()
expr_stmt|;
break|break;
case|case
name|NONE
case|:
if|if
condition|(
name|mode
operator|==
name|newMode
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage policy satisfier is already disabled, mode:{}"
operator|+
literal|" so ignoring change mode event."
argument_list|,
name|newMode
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabling StoragePolicySatisfier, mode:{}"
argument_list|,
name|newMode
argument_list|)
expr_stmt|;
name|spsService
operator|.
name|stop
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|removeAllPathIds
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Given mode: {} is invalid"
argument_list|,
name|newMode
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|// update sps mode
name|mode
operator|=
name|newMode
expr_stmt|;
block|}
comment|/**    * This function will do following logic based on the configured sps mode:    *    *<p>    * If the configured mode is {@link StoragePolicySatisfierMode.INTERNAL}, then    * timed wait to stop internal storage policy satisfier daemon threads.    *    *<p>    * If the configured mode is {@link StoragePolicySatisfierMode.EXTERNAL}, then    * it won't do anything, just ignore it.    *    *<p>    * If the configured mode is {@link StoragePolicySatisfierMode.NONE}, then the    * service is disabled. It won't do any action, just ignore it.    */
DECL|method|stopGracefully ()
specifier|public
name|void
name|stopGracefully
parameter_list|()
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|INTERNAL
case|:
name|spsService
operator|.
name|stopGracefully
argument_list|()
expr_stmt|;
break|break;
case|case
name|EXTERNAL
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring, StoragePolicySatisfier feature is running"
operator|+
literal|" outside namenode"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NONE
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring, StoragePolicySatisfier feature is disabled"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Invalid mode:{}"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/**    * @return true if the internal storage policy satisfier daemon is running,    *         false otherwise.    */
DECL|method|isInternalSatisfierRunning ()
specifier|public
name|boolean
name|isInternalSatisfierRunning
parameter_list|()
block|{
return|return
name|spsService
operator|.
name|isRunning
argument_list|()
return|;
block|}
comment|/**    * @return internal SPS service instance.    */
DECL|method|getInternalSPSService ()
specifier|public
name|SPSService
name|getInternalSPSService
parameter_list|()
block|{
return|return
name|this
operator|.
name|spsService
return|;
block|}
comment|/**    * @return status Storage policy satisfy status of the path. It is supported    *         only for the internal sps daemon service.    * @throws IOException    *           if the Satisfier is not running inside namenode.    */
DECL|method|checkStoragePolicySatisfyPathStatus ( String path)
specifier|public
name|StoragePolicySatisfyPathStatus
name|checkStoragePolicySatisfyPathStatus
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|mode
operator|!=
name|StoragePolicySatisfierMode
operator|.
name|INTERNAL
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Satisfier is not running inside namenode, so status "
operator|+
literal|"can't be returned."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Satisfier is not running inside namenode, "
operator|+
literal|"so status can't be returned."
argument_list|)
throw|;
block|}
return|return
name|spsService
operator|.
name|checkStoragePolicySatisfyPathStatus
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**    * @return the next SPS path id, on which path users has invoked to satisfy    *         storages.    */
DECL|method|getNextPathId ()
specifier|public
name|Long
name|getNextPathId
parameter_list|()
block|{
synchronized|synchronized
init|(
name|pathsToBeTraveresed
init|)
block|{
return|return
name|pathsToBeTraveresed
operator|.
name|poll
argument_list|()
return|;
block|}
block|}
comment|/**    * Verify that satisfier queue limit exceeds allowed outstanding limit.    */
DECL|method|verifyOutstandingPathQLimit ()
specifier|public
name|void
name|verifyOutstandingPathQLimit
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|size
init|=
name|pathsToBeTraveresed
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Checking that the SPS call Q exceeds the allowed limit.
if|if
condition|(
name|outstandingPathsLimit
operator|-
name|size
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Satisifer Q - outstanding limit:{}, current size:{}"
argument_list|,
name|outstandingPathsLimit
argument_list|,
name|size
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Outstanding satisfier queue limit: "
operator|+
name|outstandingPathsLimit
operator|+
literal|" exceeded, try later!"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Removes the SPS path id from the list of sps paths.    */
DECL|method|removePathId (long trackId)
specifier|public
name|void
name|removePathId
parameter_list|(
name|long
name|trackId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|pathsToBeTraveresed
init|)
block|{
name|pathsToBeTraveresed
operator|.
name|remove
argument_list|(
name|trackId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Clean up all sps path ids.    */
DECL|method|removeAllPathIds ()
specifier|public
name|void
name|removeAllPathIds
parameter_list|()
block|{
synchronized|synchronized
init|(
name|pathsToBeTraveresed
init|)
block|{
name|pathsToBeTraveresed
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Adds the sps path to SPSPathIds list.    */
DECL|method|addPathId (long id)
specifier|public
name|void
name|addPathId
parameter_list|(
name|long
name|id
parameter_list|)
block|{
synchronized|synchronized
init|(
name|pathsToBeTraveresed
init|)
block|{
name|pathsToBeTraveresed
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return true if sps is configured as an internal service or external    *         service, false otherwise.    */
DECL|method|isEnabled ()
specifier|public
name|boolean
name|isEnabled
parameter_list|()
block|{
return|return
name|mode
operator|==
name|StoragePolicySatisfierMode
operator|.
name|INTERNAL
operator|||
name|mode
operator|==
name|StoragePolicySatisfierMode
operator|.
name|EXTERNAL
return|;
block|}
comment|/**    * @return sps service mode.    */
DECL|method|getMode ()
specifier|public
name|StoragePolicySatisfierMode
name|getMode
parameter_list|()
block|{
return|return
name|mode
return|;
block|}
block|}
end_class

end_unit

