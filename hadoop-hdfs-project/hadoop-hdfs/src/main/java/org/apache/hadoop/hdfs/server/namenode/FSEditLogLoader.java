begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|AddCloseOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|BlockListUpdatingOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|CancelDelegationTokenOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|ClearNSQuotaOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|ConcatDeleteOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|DeleteOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|GetDelegationTokenOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|MkdirOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|ReassignLeaseOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|RenameOldOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|RenameOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|RenewDelegationTokenOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetGenstampOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetNSQuotaOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetOwnerOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetPermissionsOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetQuotaOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SetReplicationOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|SymlinkOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|TimesOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|UpdateBlocksOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|UpdateMasterKeyOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|LeaseManager
operator|.
name|Lease
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|FSEditLogLoader
specifier|public
class|class
name|FSEditLogLoader
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSEditLogLoader
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|REPLAY_TRANSACTION_LOG_INTERVAL
specifier|static
name|long
name|REPLAY_TRANSACTION_LOG_INTERVAL
init|=
literal|1000
decl_stmt|;
comment|// 1sec
DECL|field|fsNamesys
specifier|private
specifier|final
name|FSNamesystem
name|fsNamesys
decl_stmt|;
DECL|field|lastAppliedTxId
specifier|private
name|long
name|lastAppliedTxId
decl_stmt|;
DECL|method|FSEditLogLoader (FSNamesystem fsNamesys, long lastAppliedTxId)
specifier|public
name|FSEditLogLoader
parameter_list|(
name|FSNamesystem
name|fsNamesys
parameter_list|,
name|long
name|lastAppliedTxId
parameter_list|)
block|{
name|this
operator|.
name|fsNamesys
operator|=
name|fsNamesys
expr_stmt|;
name|this
operator|.
name|lastAppliedTxId
operator|=
name|lastAppliedTxId
expr_stmt|;
block|}
comment|/**    * Load an edit log, and apply the changes to the in-memory structure    * This is where we apply edits that we've been writing to disk all    * along.    */
DECL|method|loadFSEdits (EditLogInputStream edits, long expectedStartingTxId, MetaRecoveryContext recovery)
name|long
name|loadFSEdits
parameter_list|(
name|EditLogInputStream
name|edits
parameter_list|,
name|long
name|expectedStartingTxId
parameter_list|,
name|MetaRecoveryContext
name|recovery
parameter_list|)
throws|throws
name|IOException
block|{
name|fsNamesys
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
name|long
name|numEdits
init|=
name|loadEditRecords
argument_list|(
name|edits
argument_list|,
literal|false
argument_list|,
name|expectedStartingTxId
argument_list|,
name|recovery
argument_list|)
decl_stmt|;
name|FSImage
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Edits file "
operator|+
name|edits
operator|.
name|getName
argument_list|()
operator|+
literal|" of size "
operator|+
name|edits
operator|.
name|length
argument_list|()
operator|+
literal|" edits # "
operator|+
name|numEdits
operator|+
literal|" loaded in "
operator|+
operator|(
name|now
argument_list|()
operator|-
name|startTime
operator|)
operator|/
literal|1000
operator|+
literal|" seconds."
argument_list|)
expr_stmt|;
return|return
name|numEdits
return|;
block|}
finally|finally
block|{
name|edits
operator|.
name|close
argument_list|()
expr_stmt|;
name|fsNamesys
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|loadEditRecords (EditLogInputStream in, boolean closeOnExit, long expectedStartingTxId, MetaRecoveryContext recovery)
name|long
name|loadEditRecords
parameter_list|(
name|EditLogInputStream
name|in
parameter_list|,
name|boolean
name|closeOnExit
parameter_list|,
name|long
name|expectedStartingTxId
parameter_list|,
name|MetaRecoveryContext
name|recovery
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDirectory
name|fsDir
init|=
name|fsNamesys
operator|.
name|dir
decl_stmt|;
name|EnumMap
argument_list|<
name|FSEditLogOpCodes
argument_list|,
name|Holder
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|opCounts
init|=
operator|new
name|EnumMap
argument_list|<
name|FSEditLogOpCodes
argument_list|,
name|Holder
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|(
name|FSEditLogOpCodes
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Acquiring write lock to replay edit log"
argument_list|)
expr_stmt|;
block|}
name|fsNamesys
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|fsDir
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|long
name|recentOpcodeOffsets
index|[]
init|=
operator|new
name|long
index|[
literal|4
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|recentOpcodeOffsets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|long
name|expectedTxId
init|=
name|expectedStartingTxId
decl_stmt|;
name|long
name|numEdits
init|=
literal|0
decl_stmt|;
name|long
name|lastTxId
init|=
name|in
operator|.
name|getLastTxId
argument_list|()
decl_stmt|;
name|long
name|numTxns
init|=
operator|(
name|lastTxId
operator|-
name|expectedStartingTxId
operator|)
operator|+
literal|1
decl_stmt|;
name|long
name|lastLogTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"edit log length: "
operator|+
name|in
operator|.
name|length
argument_list|()
operator|+
literal|", start txid: "
operator|+
name|expectedStartingTxId
operator|+
literal|", last txid: "
operator|+
name|lastTxId
argument_list|)
expr_stmt|;
block|}
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|FSEditLogOp
name|op
decl_stmt|;
try|try
block|{
name|op
operator|=
name|in
operator|.
name|readOp
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// Handle a problem with our input
name|check203UpgradeFailure
argument_list|(
name|in
operator|.
name|getVersion
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|String
name|errorMessage
init|=
name|formatEditLogReplayError
argument_list|(
name|in
argument_list|,
name|recentOpcodeOffsets
argument_list|,
name|expectedTxId
argument_list|)
decl_stmt|;
name|FSImage
operator|.
name|LOG
operator|.
name|error
argument_list|(
name|errorMessage
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|recovery
operator|==
literal|null
condition|)
block|{
comment|// We will only try to skip over problematic opcodes when in
comment|// recovery mode.
throw|throw
operator|new
name|EditLogInputException
argument_list|(
name|errorMessage
argument_list|,
name|e
argument_list|,
name|numEdits
argument_list|)
throw|;
block|}
name|MetaRecoveryContext
operator|.
name|editLogLoaderPrompt
argument_list|(
literal|"We failed to read txId "
operator|+
name|expectedTxId
argument_list|,
name|recovery
argument_list|,
literal|"skipping the bad section in the log"
argument_list|)
expr_stmt|;
name|in
operator|.
name|resync
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|recentOpcodeOffsets
index|[
call|(
name|int
call|)
argument_list|(
name|numEdits
operator|%
name|recentOpcodeOffsets
operator|.
name|length
argument_list|)
index|]
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|hasTransactionId
argument_list|()
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getTransactionId
argument_list|()
operator|>
name|expectedTxId
condition|)
block|{
name|MetaRecoveryContext
operator|.
name|editLogLoaderPrompt
argument_list|(
literal|"There appears "
operator|+
literal|"to be a gap in the edit log.  We expected txid "
operator|+
name|expectedTxId
operator|+
literal|", but got txid "
operator|+
name|op
operator|.
name|getTransactionId
argument_list|()
operator|+
literal|"."
argument_list|,
name|recovery
argument_list|,
literal|"ignoring missing "
operator|+
literal|" transaction IDs"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|getTransactionId
argument_list|()
operator|<
name|expectedTxId
condition|)
block|{
name|MetaRecoveryContext
operator|.
name|editLogLoaderPrompt
argument_list|(
literal|"There appears "
operator|+
literal|"to be an out-of-order edit in the edit log.  We "
operator|+
literal|"expected txid "
operator|+
name|expectedTxId
operator|+
literal|", but got txid "
operator|+
name|op
operator|.
name|getTransactionId
argument_list|()
operator|+
literal|"."
argument_list|,
name|recovery
argument_list|,
literal|"skipping the out-of-order edit"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
try|try
block|{
name|applyEditLogOp
argument_list|(
name|op
argument_list|,
name|fsDir
argument_list|,
name|in
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Encountered exception on operation "
operator|+
name|op
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|MetaRecoveryContext
operator|.
name|editLogLoaderPrompt
argument_list|(
literal|"Failed to "
operator|+
literal|"apply edit log operation "
operator|+
name|op
operator|+
literal|": error "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|recovery
argument_list|,
literal|"applying edits"
argument_list|)
expr_stmt|;
block|}
comment|// Now that the operation has been successfully decoded and
comment|// applied, update our bookkeeping.
name|incrOpCount
argument_list|(
name|op
operator|.
name|opCode
argument_list|,
name|opCounts
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|hasTransactionId
argument_list|()
condition|)
block|{
name|lastAppliedTxId
operator|=
name|op
operator|.
name|getTransactionId
argument_list|()
expr_stmt|;
name|expectedTxId
operator|=
name|lastAppliedTxId
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|expectedTxId
operator|=
name|lastAppliedTxId
operator|=
name|expectedStartingTxId
expr_stmt|;
block|}
comment|// log progress
if|if
condition|(
name|op
operator|.
name|hasTransactionId
argument_list|()
condition|)
block|{
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|lastLogTime
operator|>
name|REPLAY_TRANSACTION_LOG_INTERVAL
condition|)
block|{
name|long
name|deltaTxId
init|=
name|lastAppliedTxId
operator|-
name|expectedStartingTxId
operator|+
literal|1
decl_stmt|;
name|int
name|percent
init|=
name|Math
operator|.
name|round
argument_list|(
operator|(
name|float
operator|)
name|deltaTxId
operator|/
name|numTxns
operator|*
literal|100
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"replaying edit log: "
operator|+
name|deltaTxId
operator|+
literal|"/"
operator|+
name|numTxns
operator|+
literal|" transactions completed. ("
operator|+
name|percent
operator|+
literal|"%)"
argument_list|)
expr_stmt|;
name|lastLogTime
operator|=
name|now
expr_stmt|;
block|}
block|}
name|numEdits
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaRecoveryContext
operator|.
name|RequestStopException
name|e
parameter_list|)
block|{
name|MetaRecoveryContext
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Stopped reading edit log at "
operator|+
name|in
operator|.
name|getPosition
argument_list|()
operator|+
literal|"/"
operator|+
name|in
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|closeOnExit
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|fsDir
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|fsNamesys
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"replaying edit log finished"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FSImage
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|dumpOpCounts
argument_list|(
name|opCounts
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|numEdits
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|applyEditLogOp (FSEditLogOp op, FSDirectory fsDir, int logVersion)
specifier|private
name|void
name|applyEditLogOp
parameter_list|(
name|FSEditLogOp
name|op
parameter_list|,
name|FSDirectory
name|fsDir
parameter_list|,
name|int
name|logVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"replaying edit log: "
operator|+
name|op
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
operator|.
name|opCode
condition|)
block|{
case|case
name|OP_ADD
case|:
block|{
name|AddCloseOp
name|addCloseOp
init|=
operator|(
name|AddCloseOp
operator|)
name|op
decl_stmt|;
if|if
condition|(
name|FSNamesystem
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|debug
argument_list|(
name|op
operator|.
name|opCode
operator|+
literal|": "
operator|+
name|addCloseOp
operator|.
name|path
operator|+
literal|" numblocks : "
operator|+
name|addCloseOp
operator|.
name|blocks
operator|.
name|length
operator|+
literal|" clientHolder "
operator|+
name|addCloseOp
operator|.
name|clientName
operator|+
literal|" clientMachine "
operator|+
name|addCloseOp
operator|.
name|clientMachine
argument_list|)
expr_stmt|;
block|}
comment|// There three cases here:
comment|// 1. OP_ADD to create a new file
comment|// 2. OP_ADD to update file blocks
comment|// 3. OP_ADD to open file for append
comment|// See if the file already exists (persistBlocks call)
name|INodeFile
name|oldFile
init|=
name|getINodeFile
argument_list|(
name|fsDir
argument_list|,
name|addCloseOp
operator|.
name|path
argument_list|)
decl_stmt|;
name|INodeFile
name|newFile
init|=
name|oldFile
decl_stmt|;
if|if
condition|(
name|oldFile
operator|==
literal|null
condition|)
block|{
comment|// this is OP_ADD on a new file (case 1)
comment|// versions> 0 support per file replication
comment|// get name and replication
specifier|final
name|short
name|replication
init|=
name|fsNamesys
operator|.
name|getBlockManager
argument_list|(             )
operator|.
name|adjustReplication
argument_list|(
name|addCloseOp
operator|.
name|replication
argument_list|)
decl_stmt|;
assert|assert
name|addCloseOp
operator|.
name|blocks
operator|.
name|length
operator|==
literal|0
assert|;
comment|// add to the file tree
name|newFile
operator|=
operator|(
name|INodeFile
operator|)
name|fsDir
operator|.
name|unprotectedAddFile
argument_list|(
name|addCloseOp
operator|.
name|path
argument_list|,
name|addCloseOp
operator|.
name|permissions
argument_list|,
name|replication
argument_list|,
name|addCloseOp
operator|.
name|mtime
argument_list|,
name|addCloseOp
operator|.
name|atime
argument_list|,
name|addCloseOp
operator|.
name|blockSize
argument_list|,
literal|true
argument_list|,
name|addCloseOp
operator|.
name|clientName
argument_list|,
name|addCloseOp
operator|.
name|clientMachine
argument_list|)
expr_stmt|;
name|fsNamesys
operator|.
name|leaseManager
operator|.
name|addLease
argument_list|(
name|addCloseOp
operator|.
name|clientName
argument_list|,
name|addCloseOp
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This is OP_ADD on an existing file
if|if
condition|(
operator|!
name|oldFile
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
comment|// This is case 3: a call to append() on an already-closed file.
if|if
condition|(
name|FSNamesystem
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reopening an already-closed file "
operator|+
literal|"for append"
argument_list|)
expr_stmt|;
block|}
name|fsNamesys
operator|.
name|prepareFileForWrite
argument_list|(
name|addCloseOp
operator|.
name|path
argument_list|,
name|oldFile
argument_list|,
name|addCloseOp
operator|.
name|clientName
argument_list|,
name|addCloseOp
operator|.
name|clientMachine
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|newFile
operator|=
name|getINodeFile
argument_list|(
name|fsDir
argument_list|,
name|addCloseOp
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Fall-through for case 2.
comment|// Regardless of whether it's a new file or an updated file,
comment|// update the block list.
comment|// Update the salient file attributes.
name|newFile
operator|.
name|setAccessTime
argument_list|(
name|addCloseOp
operator|.
name|atime
argument_list|)
expr_stmt|;
name|newFile
operator|.
name|setModificationTimeForce
argument_list|(
name|addCloseOp
operator|.
name|mtime
argument_list|)
expr_stmt|;
name|updateBlocks
argument_list|(
name|fsDir
argument_list|,
name|addCloseOp
argument_list|,
name|newFile
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_CLOSE
case|:
block|{
name|AddCloseOp
name|addCloseOp
init|=
operator|(
name|AddCloseOp
operator|)
name|op
decl_stmt|;
if|if
condition|(
name|FSNamesystem
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|debug
argument_list|(
name|op
operator|.
name|opCode
operator|+
literal|": "
operator|+
name|addCloseOp
operator|.
name|path
operator|+
literal|" numblocks : "
operator|+
name|addCloseOp
operator|.
name|blocks
operator|.
name|length
operator|+
literal|" clientHolder "
operator|+
name|addCloseOp
operator|.
name|clientName
operator|+
literal|" clientMachine "
operator|+
name|addCloseOp
operator|.
name|clientMachine
argument_list|)
expr_stmt|;
block|}
name|INodeFile
name|oldFile
init|=
name|getINodeFile
argument_list|(
name|fsDir
argument_list|,
name|addCloseOp
operator|.
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Operation trying to close non-existent file "
operator|+
name|addCloseOp
operator|.
name|path
argument_list|)
throw|;
block|}
comment|// Update the salient file attributes.
name|oldFile
operator|.
name|setAccessTime
argument_list|(
name|addCloseOp
operator|.
name|atime
argument_list|)
expr_stmt|;
name|oldFile
operator|.
name|setModificationTimeForce
argument_list|(
name|addCloseOp
operator|.
name|mtime
argument_list|)
expr_stmt|;
name|updateBlocks
argument_list|(
name|fsDir
argument_list|,
name|addCloseOp
argument_list|,
name|oldFile
argument_list|)
expr_stmt|;
comment|// Now close the file
if|if
condition|(
operator|!
name|oldFile
operator|.
name|isUnderConstruction
argument_list|()
operator|&&
name|logVersion
operator|<=
name|LayoutVersion
operator|.
name|BUGFIX_HDFS_2991_VERSION
condition|)
block|{
comment|// There was a bug (HDFS-2991) in hadoop< 0.23.1 where OP_CLOSE
comment|// could show up twice in a row. But after that version, this
comment|// should be fixed, so we should treat it as an error.
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File is not under construction: "
operator|+
name|addCloseOp
operator|.
name|path
argument_list|)
throw|;
block|}
comment|// One might expect that you could use removeLease(holder, path) here,
comment|// but OP_CLOSE doesn't serialize the holder. So, remove by path.
if|if
condition|(
name|oldFile
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|INodeFileUnderConstruction
name|ucFile
init|=
operator|(
name|INodeFileUnderConstruction
operator|)
name|oldFile
decl_stmt|;
name|fsNamesys
operator|.
name|leaseManager
operator|.
name|removeLeaseWithPrefixPath
argument_list|(
name|addCloseOp
operator|.
name|path
argument_list|)
expr_stmt|;
name|INodeFile
name|newFile
init|=
name|ucFile
operator|.
name|convertToInodeFile
argument_list|()
decl_stmt|;
name|fsDir
operator|.
name|replaceNode
argument_list|(
name|addCloseOp
operator|.
name|path
argument_list|,
name|ucFile
argument_list|,
name|newFile
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|OP_UPDATE_BLOCKS
case|:
block|{
name|UpdateBlocksOp
name|updateOp
init|=
operator|(
name|UpdateBlocksOp
operator|)
name|op
decl_stmt|;
if|if
condition|(
name|FSNamesystem
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|FSNamesystem
operator|.
name|LOG
operator|.
name|debug
argument_list|(
name|op
operator|.
name|opCode
operator|+
literal|": "
operator|+
name|updateOp
operator|.
name|path
operator|+
literal|" numblocks : "
operator|+
name|updateOp
operator|.
name|blocks
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|INodeFile
name|oldFile
init|=
name|getINodeFile
argument_list|(
name|fsDir
argument_list|,
name|updateOp
operator|.
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Operation trying to update blocks in non-existent file "
operator|+
name|updateOp
operator|.
name|path
argument_list|)
throw|;
block|}
comment|// Update in-memory data structures
name|updateBlocks
argument_list|(
name|fsDir
argument_list|,
name|updateOp
argument_list|,
name|oldFile
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_SET_REPLICATION
case|:
block|{
name|SetReplicationOp
name|setReplicationOp
init|=
operator|(
name|SetReplicationOp
operator|)
name|op
decl_stmt|;
name|short
name|replication
init|=
name|fsNamesys
operator|.
name|getBlockManager
argument_list|()
operator|.
name|adjustReplication
argument_list|(
name|setReplicationOp
operator|.
name|replication
argument_list|)
decl_stmt|;
name|fsDir
operator|.
name|unprotectedSetReplication
argument_list|(
name|setReplicationOp
operator|.
name|path
argument_list|,
name|replication
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_CONCAT_DELETE
case|:
block|{
name|ConcatDeleteOp
name|concatDeleteOp
init|=
operator|(
name|ConcatDeleteOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedConcat
argument_list|(
name|concatDeleteOp
operator|.
name|trg
argument_list|,
name|concatDeleteOp
operator|.
name|srcs
argument_list|,
name|concatDeleteOp
operator|.
name|timestamp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_RENAME_OLD
case|:
block|{
name|RenameOldOp
name|renameOp
init|=
operator|(
name|RenameOldOp
operator|)
name|op
decl_stmt|;
name|HdfsFileStatus
name|dinfo
init|=
name|fsDir
operator|.
name|getFileInfo
argument_list|(
name|renameOp
operator|.
name|dst
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|fsDir
operator|.
name|unprotectedRenameTo
argument_list|(
name|renameOp
operator|.
name|src
argument_list|,
name|renameOp
operator|.
name|dst
argument_list|,
name|renameOp
operator|.
name|timestamp
argument_list|)
expr_stmt|;
name|fsNamesys
operator|.
name|unprotectedChangeLease
argument_list|(
name|renameOp
operator|.
name|src
argument_list|,
name|renameOp
operator|.
name|dst
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_DELETE
case|:
block|{
name|DeleteOp
name|deleteOp
init|=
operator|(
name|DeleteOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedDelete
argument_list|(
name|deleteOp
operator|.
name|path
argument_list|,
name|deleteOp
operator|.
name|timestamp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_MKDIR
case|:
block|{
name|MkdirOp
name|mkdirOp
init|=
operator|(
name|MkdirOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedMkdir
argument_list|(
name|mkdirOp
operator|.
name|path
argument_list|,
name|mkdirOp
operator|.
name|permissions
argument_list|,
name|mkdirOp
operator|.
name|timestamp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_SET_GENSTAMP
case|:
block|{
name|SetGenstampOp
name|setGenstampOp
init|=
operator|(
name|SetGenstampOp
operator|)
name|op
decl_stmt|;
name|fsNamesys
operator|.
name|setGenerationStamp
argument_list|(
name|setGenstampOp
operator|.
name|genStamp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_SET_PERMISSIONS
case|:
block|{
name|SetPermissionsOp
name|setPermissionsOp
init|=
operator|(
name|SetPermissionsOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedSetPermission
argument_list|(
name|setPermissionsOp
operator|.
name|src
argument_list|,
name|setPermissionsOp
operator|.
name|permissions
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_SET_OWNER
case|:
block|{
name|SetOwnerOp
name|setOwnerOp
init|=
operator|(
name|SetOwnerOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedSetOwner
argument_list|(
name|setOwnerOp
operator|.
name|src
argument_list|,
name|setOwnerOp
operator|.
name|username
argument_list|,
name|setOwnerOp
operator|.
name|groupname
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_SET_NS_QUOTA
case|:
block|{
name|SetNSQuotaOp
name|setNSQuotaOp
init|=
operator|(
name|SetNSQuotaOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedSetQuota
argument_list|(
name|setNSQuotaOp
operator|.
name|src
argument_list|,
name|setNSQuotaOp
operator|.
name|nsQuota
argument_list|,
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_CLEAR_NS_QUOTA
case|:
block|{
name|ClearNSQuotaOp
name|clearNSQuotaOp
init|=
operator|(
name|ClearNSQuotaOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedSetQuota
argument_list|(
name|clearNSQuotaOp
operator|.
name|src
argument_list|,
name|HdfsConstants
operator|.
name|QUOTA_RESET
argument_list|,
name|HdfsConstants
operator|.
name|QUOTA_DONT_SET
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_SET_QUOTA
case|:
name|SetQuotaOp
name|setQuotaOp
init|=
operator|(
name|SetQuotaOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedSetQuota
argument_list|(
name|setQuotaOp
operator|.
name|src
argument_list|,
name|setQuotaOp
operator|.
name|nsQuota
argument_list|,
name|setQuotaOp
operator|.
name|dsQuota
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_TIMES
case|:
block|{
name|TimesOp
name|timesOp
init|=
operator|(
name|TimesOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedSetTimes
argument_list|(
name|timesOp
operator|.
name|path
argument_list|,
name|timesOp
operator|.
name|mtime
argument_list|,
name|timesOp
operator|.
name|atime
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_SYMLINK
case|:
block|{
name|SymlinkOp
name|symlinkOp
init|=
operator|(
name|SymlinkOp
operator|)
name|op
decl_stmt|;
name|fsDir
operator|.
name|unprotectedSymlink
argument_list|(
name|symlinkOp
operator|.
name|path
argument_list|,
name|symlinkOp
operator|.
name|value
argument_list|,
name|symlinkOp
operator|.
name|mtime
argument_list|,
name|symlinkOp
operator|.
name|atime
argument_list|,
name|symlinkOp
operator|.
name|permissionStatus
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_RENAME
case|:
block|{
name|RenameOp
name|renameOp
init|=
operator|(
name|RenameOp
operator|)
name|op
decl_stmt|;
name|HdfsFileStatus
name|dinfo
init|=
name|fsDir
operator|.
name|getFileInfo
argument_list|(
name|renameOp
operator|.
name|dst
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|fsDir
operator|.
name|unprotectedRenameTo
argument_list|(
name|renameOp
operator|.
name|src
argument_list|,
name|renameOp
operator|.
name|dst
argument_list|,
name|renameOp
operator|.
name|timestamp
argument_list|,
name|renameOp
operator|.
name|options
argument_list|)
expr_stmt|;
name|fsNamesys
operator|.
name|unprotectedChangeLease
argument_list|(
name|renameOp
operator|.
name|src
argument_list|,
name|renameOp
operator|.
name|dst
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_GET_DELEGATION_TOKEN
case|:
block|{
name|GetDelegationTokenOp
name|getDelegationTokenOp
init|=
operator|(
name|GetDelegationTokenOp
operator|)
name|op
decl_stmt|;
name|fsNamesys
operator|.
name|getDelegationTokenSecretManager
argument_list|()
operator|.
name|addPersistedDelegationToken
argument_list|(
name|getDelegationTokenOp
operator|.
name|token
argument_list|,
name|getDelegationTokenOp
operator|.
name|expiryTime
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_RENEW_DELEGATION_TOKEN
case|:
block|{
name|RenewDelegationTokenOp
name|renewDelegationTokenOp
init|=
operator|(
name|RenewDelegationTokenOp
operator|)
name|op
decl_stmt|;
name|fsNamesys
operator|.
name|getDelegationTokenSecretManager
argument_list|()
operator|.
name|updatePersistedTokenRenewal
argument_list|(
name|renewDelegationTokenOp
operator|.
name|token
argument_list|,
name|renewDelegationTokenOp
operator|.
name|expiryTime
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_CANCEL_DELEGATION_TOKEN
case|:
block|{
name|CancelDelegationTokenOp
name|cancelDelegationTokenOp
init|=
operator|(
name|CancelDelegationTokenOp
operator|)
name|op
decl_stmt|;
name|fsNamesys
operator|.
name|getDelegationTokenSecretManager
argument_list|()
operator|.
name|updatePersistedTokenCancellation
argument_list|(
name|cancelDelegationTokenOp
operator|.
name|token
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_UPDATE_MASTER_KEY
case|:
block|{
name|UpdateMasterKeyOp
name|updateMasterKeyOp
init|=
operator|(
name|UpdateMasterKeyOp
operator|)
name|op
decl_stmt|;
name|fsNamesys
operator|.
name|getDelegationTokenSecretManager
argument_list|()
operator|.
name|updatePersistedMasterKey
argument_list|(
name|updateMasterKeyOp
operator|.
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_REASSIGN_LEASE
case|:
block|{
name|ReassignLeaseOp
name|reassignLeaseOp
init|=
operator|(
name|ReassignLeaseOp
operator|)
name|op
decl_stmt|;
name|Lease
name|lease
init|=
name|fsNamesys
operator|.
name|leaseManager
operator|.
name|getLease
argument_list|(
name|reassignLeaseOp
operator|.
name|leaseHolder
argument_list|)
decl_stmt|;
name|INodeFileUnderConstruction
name|pendingFile
init|=
name|INodeFileUnderConstruction
operator|.
name|valueOf
argument_list|(
name|fsDir
operator|.
name|getINode
argument_list|(
name|reassignLeaseOp
operator|.
name|path
argument_list|)
argument_list|,
name|reassignLeaseOp
operator|.
name|path
argument_list|)
decl_stmt|;
name|fsNamesys
operator|.
name|reassignLeaseInternal
argument_list|(
name|lease
argument_list|,
name|reassignLeaseOp
operator|.
name|path
argument_list|,
name|reassignLeaseOp
operator|.
name|newHolder
argument_list|,
name|pendingFile
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_START_LOG_SEGMENT
case|:
case|case
name|OP_END_LOG_SEGMENT
case|:
block|{
comment|// no data in here currently.
break|break;
block|}
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid operation read "
operator|+
name|op
operator|.
name|opCode
argument_list|)
throw|;
block|}
block|}
DECL|method|formatEditLogReplayError (EditLogInputStream in, long recentOpcodeOffsets[], long txid)
specifier|private
specifier|static
name|String
name|formatEditLogReplayError
parameter_list|(
name|EditLogInputStream
name|in
parameter_list|,
name|long
name|recentOpcodeOffsets
index|[]
parameter_list|,
name|long
name|txid
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Error replaying edit log at offset "
operator|+
name|in
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|".  Expected transaction ID was "
argument_list|)
operator|.
name|append
argument_list|(
name|txid
argument_list|)
expr_stmt|;
if|if
condition|(
name|recentOpcodeOffsets
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|recentOpcodeOffsets
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\nRecent opcode offsets:"
argument_list|)
expr_stmt|;
for|for
control|(
name|long
name|offset
range|:
name|recentOpcodeOffsets
control|)
block|{
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getINodeFile (FSDirectory fsDir, String path)
specifier|private
specifier|static
name|INodeFile
name|getINodeFile
parameter_list|(
name|FSDirectory
name|fsDir
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|INode
name|inode
init|=
name|fsDir
operator|.
name|getINode
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|inode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|inode
operator|instanceof
name|INodeFile
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Operation trying to get non-file "
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
return|return
operator|(
name|INodeFile
operator|)
name|inode
return|;
block|}
comment|/**    * Update in-memory data structures with new block information.    * @throws IOException    */
DECL|method|updateBlocks (FSDirectory fsDir, BlockListUpdatingOp op, INodeFile file)
specifier|private
name|void
name|updateBlocks
parameter_list|(
name|FSDirectory
name|fsDir
parameter_list|,
name|BlockListUpdatingOp
name|op
parameter_list|,
name|INodeFile
name|file
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Update its block list
name|BlockInfo
index|[]
name|oldBlocks
init|=
name|file
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
name|Block
index|[]
name|newBlocks
init|=
name|op
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|op
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// Are we only updating the last block's gen stamp.
name|boolean
name|isGenStampUpdate
init|=
name|oldBlocks
operator|.
name|length
operator|==
name|newBlocks
operator|.
name|length
decl_stmt|;
comment|// First, update blocks in common
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldBlocks
operator|.
name|length
operator|&&
name|i
operator|<
name|newBlocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|BlockInfo
name|oldBlock
init|=
name|oldBlocks
index|[
name|i
index|]
decl_stmt|;
name|Block
name|newBlock
init|=
name|newBlocks
index|[
name|i
index|]
decl_stmt|;
name|boolean
name|isLastBlock
init|=
name|i
operator|==
name|newBlocks
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|!=
name|newBlock
operator|.
name|getBlockId
argument_list|()
operator|||
operator|(
name|oldBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
operator|!
operator|(
name|isGenStampUpdate
operator|&&
name|isLastBlock
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mismatched block IDs or generation stamps, "
operator|+
literal|"attempting to replace block "
operator|+
name|oldBlock
operator|+
literal|" with "
operator|+
name|newBlock
operator|+
literal|" as block # "
operator|+
name|i
operator|+
literal|"/"
operator|+
name|newBlocks
operator|.
name|length
operator|+
literal|" of "
operator|+
name|path
argument_list|)
throw|;
block|}
name|oldBlock
operator|.
name|setNumBytes
argument_list|(
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|changeMade
init|=
name|oldBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
name|oldBlock
operator|.
name|setGenerationStamp
argument_list|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldBlock
operator|instanceof
name|BlockInfoUnderConstruction
operator|&&
operator|(
operator|!
name|isLastBlock
operator|||
name|op
operator|.
name|shouldCompleteLastBlock
argument_list|()
operator|)
condition|)
block|{
name|changeMade
operator|=
literal|true
expr_stmt|;
name|fsNamesys
operator|.
name|getBlockManager
argument_list|()
operator|.
name|forceCompleteBlock
argument_list|(
operator|(
name|INodeFileUnderConstruction
operator|)
name|file
argument_list|,
operator|(
name|BlockInfoUnderConstruction
operator|)
name|oldBlock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changeMade
condition|)
block|{
comment|// The state or gen-stamp of the block has changed. So, we may be
comment|// able to process some messages from datanodes that we previously
comment|// were unable to process.
name|fsNamesys
operator|.
name|getBlockManager
argument_list|()
operator|.
name|processQueuedMessagesForBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newBlocks
operator|.
name|length
operator|<
name|oldBlocks
operator|.
name|length
condition|)
block|{
comment|// We're removing a block from the file, e.g. abandonBlock(...)
if|if
condition|(
operator|!
name|file
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Trying to remove a block from file "
operator|+
name|path
operator|+
literal|" which is not under construction."
argument_list|)
throw|;
block|}
if|if
condition|(
name|newBlocks
operator|.
name|length
operator|!=
name|oldBlocks
operator|.
name|length
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Trying to remove more than one block from file "
operator|+
name|path
argument_list|)
throw|;
block|}
name|fsDir
operator|.
name|unprotectedRemoveBlock
argument_list|(
name|path
argument_list|,
operator|(
name|INodeFileUnderConstruction
operator|)
name|file
argument_list|,
name|oldBlocks
index|[
name|oldBlocks
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newBlocks
operator|.
name|length
operator|>
name|oldBlocks
operator|.
name|length
condition|)
block|{
comment|// We're adding blocks
for|for
control|(
name|int
name|i
init|=
name|oldBlocks
operator|.
name|length
init|;
name|i
operator|<
name|newBlocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Block
name|newBlock
init|=
name|newBlocks
index|[
name|i
index|]
decl_stmt|;
name|BlockInfo
name|newBI
decl_stmt|;
if|if
condition|(
operator|!
name|op
operator|.
name|shouldCompleteLastBlock
argument_list|()
condition|)
block|{
comment|// TODO: shouldn't this only be true for the last block?
comment|// what about an old-version fsync() where fsync isn't called
comment|// until several blocks in?
name|newBI
operator|=
operator|new
name|BlockInfoUnderConstruction
argument_list|(
name|newBlock
argument_list|,
name|file
operator|.
name|getBlockReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// OP_CLOSE should add finalized blocks. This code path
comment|// is only executed when loading edits written by prior
comment|// versions of Hadoop. Current versions always log
comment|// OP_ADD operations as each block is allocated.
name|newBI
operator|=
operator|new
name|BlockInfo
argument_list|(
name|newBlock
argument_list|,
name|file
operator|.
name|getBlockReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fsNamesys
operator|.
name|getBlockManager
argument_list|()
operator|.
name|addBlockCollection
argument_list|(
name|newBI
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|file
operator|.
name|addBlock
argument_list|(
name|newBI
argument_list|)
expr_stmt|;
name|fsNamesys
operator|.
name|getBlockManager
argument_list|()
operator|.
name|processQueuedMessagesForBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|dumpOpCounts ( EnumMap<FSEditLogOpCodes, Holder<Integer>> opCounts)
specifier|private
specifier|static
name|void
name|dumpOpCounts
parameter_list|(
name|EnumMap
argument_list|<
name|FSEditLogOpCodes
argument_list|,
name|Holder
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|opCounts
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Summary of operations loaded from edit log:\n  "
argument_list|)
expr_stmt|;
name|Joiner
operator|.
name|on
argument_list|(
literal|"\n  "
argument_list|)
operator|.
name|withKeyValueSeparator
argument_list|(
literal|"="
argument_list|)
operator|.
name|appendTo
argument_list|(
name|sb
argument_list|,
name|opCounts
argument_list|)
expr_stmt|;
name|FSImage
operator|.
name|LOG
operator|.
name|debug
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|incrOpCount (FSEditLogOpCodes opCode, EnumMap<FSEditLogOpCodes, Holder<Integer>> opCounts)
specifier|private
name|void
name|incrOpCount
parameter_list|(
name|FSEditLogOpCodes
name|opCode
parameter_list|,
name|EnumMap
argument_list|<
name|FSEditLogOpCodes
argument_list|,
name|Holder
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|opCounts
parameter_list|)
block|{
name|Holder
argument_list|<
name|Integer
argument_list|>
name|holder
init|=
name|opCounts
operator|.
name|get
argument_list|(
name|opCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|holder
operator|==
literal|null
condition|)
block|{
name|holder
operator|=
operator|new
name|Holder
argument_list|<
name|Integer
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|opCounts
operator|.
name|put
argument_list|(
name|opCode
argument_list|,
name|holder
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|holder
operator|.
name|held
operator|++
expr_stmt|;
block|}
block|}
comment|/**    * Throw appropriate exception during upgrade from 203, when editlog loading    * could fail due to opcode conflicts.    */
DECL|method|check203UpgradeFailure (int logVersion, Throwable e)
specifier|private
name|void
name|check203UpgradeFailure
parameter_list|(
name|int
name|logVersion
parameter_list|,
name|Throwable
name|e
parameter_list|)
throws|throws
name|IOException
block|{
comment|// 0.20.203 version version has conflicting opcodes with the later releases.
comment|// The editlog must be emptied by restarting the namenode, before proceeding
comment|// with the upgrade.
if|if
condition|(
name|Storage
operator|.
name|is203LayoutVersion
argument_list|(
name|logVersion
argument_list|)
operator|&&
name|logVersion
operator|!=
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
condition|)
block|{
name|String
name|msg
init|=
literal|"During upgrade failed to load the editlog version "
operator|+
name|logVersion
operator|+
literal|" from release 0.20.203. Please go back to the old "
operator|+
literal|" release and restart the namenode. This empties the editlog "
operator|+
literal|" and saves the namespace. Resume the upgrade after this step."
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Find the last valid transaction ID in the stream.    * If there are invalid or corrupt transactions in the middle of the stream,    * validateEditLog will skip over them.    * This reads through the stream but does not close it.    *    * @throws IOException if the stream cannot be read due to an IO error (eg    *                     if the log does not exist)    */
DECL|method|validateEditLog (EditLogInputStream in)
specifier|static
name|EditLogValidation
name|validateEditLog
parameter_list|(
name|EditLogInputStream
name|in
parameter_list|)
block|{
name|long
name|lastPos
init|=
literal|0
decl_stmt|;
name|long
name|lastTxId
init|=
name|HdfsConstants
operator|.
name|INVALID_TXID
decl_stmt|;
name|long
name|numValid
init|=
literal|0
decl_stmt|;
name|FSEditLogOp
name|op
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|lastPos
operator|=
name|in
operator|.
name|getPosition
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|op
operator|=
name|in
operator|.
name|readOp
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|FSImage
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception after reading "
operator|+
name|numValid
operator|+
literal|" ops from "
operator|+
name|in
operator|+
literal|" while determining its valid length."
operator|+
literal|"Position was "
operator|+
name|lastPos
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|in
operator|.
name|resync
argument_list|()
expr_stmt|;
name|FSImage
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"After resync, position is "
operator|+
name|in
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lastTxId
operator|==
name|HdfsConstants
operator|.
name|INVALID_TXID
operator|||
name|op
operator|.
name|getTransactionId
argument_list|()
operator|>
name|lastTxId
condition|)
block|{
name|lastTxId
operator|=
name|op
operator|.
name|getTransactionId
argument_list|()
expr_stmt|;
block|}
name|numValid
operator|++
expr_stmt|;
block|}
return|return
operator|new
name|EditLogValidation
argument_list|(
name|lastPos
argument_list|,
name|lastTxId
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|class|EditLogValidation
specifier|static
class|class
name|EditLogValidation
block|{
DECL|field|validLength
specifier|private
specifier|final
name|long
name|validLength
decl_stmt|;
DECL|field|endTxId
specifier|private
specifier|final
name|long
name|endTxId
decl_stmt|;
DECL|field|hasCorruptHeader
specifier|private
specifier|final
name|boolean
name|hasCorruptHeader
decl_stmt|;
DECL|method|EditLogValidation (long validLength, long endTxId, boolean hasCorruptHeader)
name|EditLogValidation
parameter_list|(
name|long
name|validLength
parameter_list|,
name|long
name|endTxId
parameter_list|,
name|boolean
name|hasCorruptHeader
parameter_list|)
block|{
name|this
operator|.
name|validLength
operator|=
name|validLength
expr_stmt|;
name|this
operator|.
name|endTxId
operator|=
name|endTxId
expr_stmt|;
name|this
operator|.
name|hasCorruptHeader
operator|=
name|hasCorruptHeader
expr_stmt|;
block|}
DECL|method|getValidLength ()
name|long
name|getValidLength
parameter_list|()
block|{
return|return
name|validLength
return|;
block|}
DECL|method|getEndTxId ()
name|long
name|getEndTxId
parameter_list|()
block|{
return|return
name|endTxId
return|;
block|}
DECL|method|hasCorruptHeader ()
name|boolean
name|hasCorruptHeader
parameter_list|()
block|{
return|return
name|hasCorruptHeader
return|;
block|}
block|}
comment|/**    * Stream wrapper that keeps track of the current stream position.    *     * This stream also allows us to set a limit on how many bytes we can read    * without getting an exception.    */
DECL|class|PositionTrackingInputStream
specifier|public
specifier|static
class|class
name|PositionTrackingInputStream
extends|extends
name|FilterInputStream
implements|implements
name|StreamLimiter
block|{
DECL|field|curPos
specifier|private
name|long
name|curPos
init|=
literal|0
decl_stmt|;
DECL|field|markPos
specifier|private
name|long
name|markPos
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|limitPos
specifier|private
name|long
name|limitPos
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|method|PositionTrackingInputStream (InputStream is)
specifier|public
name|PositionTrackingInputStream
parameter_list|(
name|InputStream
name|is
parameter_list|)
block|{
name|super
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
DECL|method|checkLimit (long amt)
specifier|private
name|void
name|checkLimit
parameter_list|(
name|long
name|amt
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|extra
init|=
operator|(
name|curPos
operator|+
name|amt
operator|)
operator|-
name|limitPos
decl_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Tried to read "
operator|+
name|amt
operator|+
literal|" byte(s) past "
operator|+
literal|"the limit at offset "
operator|+
name|limitPos
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|checkLimit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|super
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|curPos
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|read (byte[] data)
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|checkLimit
argument_list|(
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|super
operator|.
name|read
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|curPos
operator|+=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|read (byte[] data, int offset, int length)
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|checkLimit
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|super
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|curPos
operator|+=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|setLimit (long limit)
specifier|public
name|void
name|setLimit
parameter_list|(
name|long
name|limit
parameter_list|)
block|{
name|limitPos
operator|=
name|curPos
operator|+
name|limit
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clearLimit ()
specifier|public
name|void
name|clearLimit
parameter_list|()
block|{
name|limitPos
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|mark (int limit)
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|super
operator|.
name|mark
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|markPos
operator|=
name|curPos
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|markPos
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not marked!"
argument_list|)
throw|;
block|}
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|curPos
operator|=
name|markPos
expr_stmt|;
name|markPos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|getPos ()
specifier|public
name|long
name|getPos
parameter_list|()
block|{
return|return
name|curPos
return|;
block|}
annotation|@
name|Override
DECL|method|skip (long amt)
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|amt
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|extra
init|=
operator|(
name|curPos
operator|+
name|amt
operator|)
operator|-
name|limitPos
decl_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Tried to skip "
operator|+
name|extra
operator|+
literal|" bytes past "
operator|+
literal|"the limit at offset "
operator|+
name|limitPos
argument_list|)
throw|;
block|}
name|long
name|ret
init|=
name|super
operator|.
name|skip
argument_list|(
name|amt
argument_list|)
decl_stmt|;
name|curPos
operator|+=
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
DECL|method|getLastAppliedTxId ()
specifier|public
name|long
name|getLastAppliedTxId
parameter_list|()
block|{
return|return
name|lastAppliedTxId
return|;
block|}
block|}
end_class

end_unit

