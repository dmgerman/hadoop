begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|DatanodeProtocolClientSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|InterDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReplicaRecoveryInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * This class handles the block recovery work commands.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockRecoveryWorker
specifier|public
class|class
name|BlockRecoveryWorker
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|dnConf
specifier|private
specifier|final
name|DNConf
name|dnConf
decl_stmt|;
DECL|method|BlockRecoveryWorker (DataNode datanode)
name|BlockRecoveryWorker
parameter_list|(
name|DataNode
name|datanode
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|conf
operator|=
name|datanode
operator|.
name|getConf
argument_list|()
expr_stmt|;
name|dnConf
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
expr_stmt|;
block|}
comment|/** A convenient class used in block recovery. */
DECL|class|BlockRecord
specifier|static
class|class
name|BlockRecord
block|{
DECL|field|id
specifier|private
specifier|final
name|DatanodeID
name|id
decl_stmt|;
DECL|field|datanode
specifier|private
specifier|final
name|InterDatanodeProtocol
name|datanode
decl_stmt|;
DECL|field|rInfo
specifier|private
specifier|final
name|ReplicaRecoveryInfo
name|rInfo
decl_stmt|;
DECL|field|storageID
specifier|private
name|String
name|storageID
decl_stmt|;
DECL|method|BlockRecord (DatanodeID id, InterDatanodeProtocol datanode, ReplicaRecoveryInfo rInfo)
name|BlockRecord
parameter_list|(
name|DatanodeID
name|id
parameter_list|,
name|InterDatanodeProtocol
name|datanode
parameter_list|,
name|ReplicaRecoveryInfo
name|rInfo
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|rInfo
operator|=
name|rInfo
expr_stmt|;
block|}
DECL|method|updateReplicaUnderRecovery (String bpid, long recoveryId, long newBlockId, long newLength)
specifier|private
name|void
name|updateReplicaUnderRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|newBlockId
parameter_list|,
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ExtendedBlock
name|b
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|rInfo
argument_list|)
decl_stmt|;
name|storageID
operator|=
name|datanode
operator|.
name|updateReplicaUnderRecovery
argument_list|(
name|b
argument_list|,
name|recoveryId
argument_list|,
name|newBlockId
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"block:"
operator|+
name|rInfo
operator|+
literal|" node:"
operator|+
name|id
return|;
block|}
block|}
comment|/** A block recovery task for a contiguous block. */
DECL|class|RecoveryTaskContiguous
class|class
name|RecoveryTaskContiguous
block|{
DECL|field|rBlock
specifier|private
specifier|final
name|RecoveringBlock
name|rBlock
decl_stmt|;
DECL|field|block
specifier|private
specifier|final
name|ExtendedBlock
name|block
decl_stmt|;
DECL|field|bpid
specifier|private
specifier|final
name|String
name|bpid
decl_stmt|;
DECL|field|locs
specifier|private
specifier|final
name|DatanodeInfo
index|[]
name|locs
decl_stmt|;
DECL|field|recoveryId
specifier|private
specifier|final
name|long
name|recoveryId
decl_stmt|;
DECL|method|RecoveryTaskContiguous (RecoveringBlock rBlock)
name|RecoveryTaskContiguous
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
block|{
name|this
operator|.
name|rBlock
operator|=
name|rBlock
expr_stmt|;
name|block
operator|=
name|rBlock
operator|.
name|getBlock
argument_list|()
expr_stmt|;
name|bpid
operator|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
expr_stmt|;
name|locs
operator|=
name|rBlock
operator|.
name|getLocations
argument_list|()
expr_stmt|;
name|recoveryId
operator|=
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
expr_stmt|;
block|}
DECL|method|recover ()
specifier|protected
name|void
name|recover
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|syncList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|locs
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|errorCount
init|=
literal|0
decl_stmt|;
comment|//check generation stamps
for|for
control|(
name|DatanodeID
name|id
range|:
name|locs
control|)
block|{
try|try
block|{
name|DatanodeID
name|bpReg
init|=
name|datanode
operator|.
name|getBPOfferService
argument_list|(
name|bpid
argument_list|)
operator|.
name|bpRegistration
decl_stmt|;
name|InterDatanodeProtocol
name|proxyDN
init|=
name|bpReg
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|?
name|datanode
else|:
name|DataNode
operator|.
name|createInterDataNodeProtocolProxy
argument_list|(
name|id
argument_list|,
name|conf
argument_list|,
name|dnConf
operator|.
name|socketTimeout
argument_list|,
name|dnConf
operator|.
name|connectToDnViaHostname
argument_list|)
decl_stmt|;
name|ReplicaRecoveryInfo
name|info
init|=
name|callInitReplicaRecovery
argument_list|(
name|proxyDN
argument_list|,
name|rBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getGenerationStamp
argument_list|()
operator|>=
name|block
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|info
operator|.
name|getNumBytes
argument_list|()
operator|>
literal|0
condition|)
block|{
name|syncList
operator|.
name|add
argument_list|(
operator|new
name|BlockRecord
argument_list|(
name|id
argument_list|,
name|proxyDN
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RecoveryInProgressException
name|ripE
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Recovery for replica "
operator|+
name|block
operator|+
literal|" on data-node "
operator|+
name|id
operator|+
literal|" is already in progress. Recovery id = "
operator|+
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
operator|+
literal|" is aborted."
argument_list|,
name|ripE
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
operator|++
name|errorCount
expr_stmt|;
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to obtain replica info for block (="
operator|+
name|block
operator|+
literal|") from datanode (="
operator|+
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errorCount
operator|==
name|locs
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All datanodes failed: block="
operator|+
name|block
operator|+
literal|", datanodeids="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|locs
argument_list|)
argument_list|)
throw|;
block|}
name|syncBlock
argument_list|(
name|syncList
argument_list|)
expr_stmt|;
block|}
comment|/** Block synchronization. */
DECL|method|syncBlock (List<BlockRecord> syncList)
name|void
name|syncBlock
parameter_list|(
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|syncList
parameter_list|)
throws|throws
name|IOException
block|{
name|DatanodeProtocolClientSideTranslatorPB
name|nn
init|=
name|getActiveNamenodeForBP
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isTruncateRecovery
init|=
name|rBlock
operator|.
name|getNewBlock
argument_list|()
operator|!=
literal|null
decl_stmt|;
name|long
name|blockId
init|=
operator|(
name|isTruncateRecovery
operator|)
condition|?
name|rBlock
operator|.
name|getNewBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
else|:
name|block
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"block="
operator|+
name|block
operator|+
literal|", (length="
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|"), syncList="
operator|+
name|syncList
argument_list|)
expr_stmt|;
block|}
comment|// syncList.isEmpty() means that all data-nodes do not have the block
comment|// or their replicas have 0 length.
comment|// The block can be deleted.
if|if
condition|(
name|syncList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|nn
operator|.
name|commitBlockSynchronization
argument_list|(
name|block
argument_list|,
name|recoveryId
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|DatanodeID
operator|.
name|EMPTY_ARRAY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Calculate the best available replica state.
name|ReplicaState
name|bestState
init|=
name|ReplicaState
operator|.
name|RWR
decl_stmt|;
name|long
name|finalizedLength
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
assert|assert
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|>
literal|0
operator|:
literal|"zero length replica"
assert|;
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|.
name|getValue
argument_list|()
operator|<
name|bestState
operator|.
name|getValue
argument_list|()
condition|)
block|{
name|bestState
operator|=
name|rState
expr_stmt|;
block|}
if|if
condition|(
name|rState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
if|if
condition|(
name|finalizedLength
operator|>
literal|0
operator|&&
name|finalizedLength
operator|!=
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent size of finalized replicas. "
operator|+
literal|"Replica "
operator|+
name|r
operator|.
name|rInfo
operator|+
literal|" expected size: "
operator|+
name|finalizedLength
argument_list|)
throw|;
block|}
name|finalizedLength
operator|=
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Calculate list of nodes that will participate in the recovery
comment|// and the new block size
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|participatingList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|ExtendedBlock
name|newBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|,
operator|-
literal|1
argument_list|,
name|recoveryId
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|bestState
condition|)
block|{
case|case
name|FINALIZED
case|:
assert|assert
name|finalizedLength
operator|>
literal|0
operator|:
literal|"finalizedLength is not positive"
assert|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|||
name|rState
operator|==
name|ReplicaState
operator|.
name|RBW
operator|&&
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|==
name|finalizedLength
condition|)
block|{
name|participatingList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|finalizedLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|RBW
case|:
case|case
name|RWR
case|:
name|long
name|minLength
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|==
name|bestState
condition|)
block|{
name|minLength
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minLength
argument_list|,
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|participatingList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|minLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUR
case|:
case|case
name|TEMPORARY
case|:
assert|assert
literal|false
operator|:
literal|"bad replica state: "
operator|+
name|bestState
assert|;
default|default:
break|break;
comment|// we have 'case' all enum values
block|}
if|if
condition|(
name|isTruncateRecovery
condition|)
block|{
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|rBlock
operator|.
name|getNewBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|DatanodeID
argument_list|>
name|failedList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|successList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|participatingList
control|)
block|{
try|try
block|{
name|r
operator|.
name|updateReplicaUnderRecovery
argument_list|(
name|bpid
argument_list|,
name|recoveryId
argument_list|,
name|blockId
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|successList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to updateBlock (newblock="
operator|+
name|newBlock
operator|+
literal|", datanode="
operator|+
name|r
operator|.
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|failedList
operator|.
name|add
argument_list|(
name|r
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If any of the data-nodes failed, the recovery fails, because
comment|// we never know the actual state of the replica on failed data-nodes.
comment|// The recovery should be started over.
if|if
condition|(
operator|!
name|failedList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeID
name|id
range|:
name|failedList
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"\n  "
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot recover "
operator|+
name|block
operator|+
literal|", the following "
operator|+
name|failedList
operator|.
name|size
argument_list|()
operator|+
literal|" data-nodes failed {"
operator|+
name|b
operator|+
literal|"\n}"
argument_list|)
throw|;
block|}
comment|// Notify the name-node about successfully recovered replicas.
specifier|final
name|DatanodeID
index|[]
name|datanodes
init|=
operator|new
name|DatanodeID
index|[
name|successList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|String
index|[]
name|storages
init|=
operator|new
name|String
index|[
name|datanodes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|datanodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|BlockRecord
name|r
init|=
name|successList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|datanodes
index|[
name|i
index|]
operator|=
name|r
operator|.
name|id
expr_stmt|;
name|storages
index|[
name|i
index|]
operator|=
name|r
operator|.
name|storageID
expr_stmt|;
block|}
name|nn
operator|.
name|commitBlockSynchronization
argument_list|(
name|block
argument_list|,
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|datanodes
argument_list|,
name|storages
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|logRecoverBlock (String who, RecoveringBlock rb)
specifier|private
specifier|static
name|void
name|logRecoverBlock
parameter_list|(
name|String
name|who
parameter_list|,
name|RecoveringBlock
name|rb
parameter_list|)
block|{
name|ExtendedBlock
name|block
init|=
name|rb
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|DatanodeInfo
index|[]
name|targets
init|=
name|rb
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|who
operator|+
literal|" calls recoverBlock("
operator|+
name|block
operator|+
literal|", targets=["
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|targets
argument_list|)
operator|+
literal|"]"
operator|+
literal|", newGenerationStamp="
operator|+
name|rb
operator|.
name|getNewGenerationStamp
argument_list|()
operator|+
literal|", newBlock="
operator|+
name|rb
operator|.
name|getNewBlock
argument_list|()
operator|+
literal|", isStriped="
operator|+
name|rb
operator|.
name|isStriped
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convenience method, which unwraps RemoteException.    * @throws IOException not a RemoteException.    */
DECL|method|callInitReplicaRecovery ( InterDatanodeProtocol datanode, RecoveringBlock rBlock)
specifier|private
specifier|static
name|ReplicaRecoveryInfo
name|callInitReplicaRecovery
parameter_list|(
name|InterDatanodeProtocol
name|datanode
parameter_list|,
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|datanode
operator|.
name|initReplicaRecovery
argument_list|(
name|rBlock
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Get the NameNode corresponding to the given block pool.    *    * @param bpid Block pool Id    * @return Namenode corresponding to the bpid    * @throws IOException if unable to get the corresponding NameNode    */
DECL|method|getActiveNamenodeForBP ( String bpid)
name|DatanodeProtocolClientSideTranslatorPB
name|getActiveNamenodeForBP
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|datanode
operator|.
name|getBPOfferService
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No block pool offer service for bpid="
operator|+
name|bpid
argument_list|)
throw|;
block|}
name|DatanodeProtocolClientSideTranslatorPB
name|activeNN
init|=
name|bpos
operator|.
name|getActiveNN
argument_list|()
decl_stmt|;
if|if
condition|(
name|activeNN
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block pool "
operator|+
name|bpid
operator|+
literal|" has not recognized an active NN"
argument_list|)
throw|;
block|}
return|return
name|activeNN
return|;
block|}
DECL|method|recoverBlocks (final String who, final Collection<RecoveringBlock> blocks)
specifier|public
name|Daemon
name|recoverBlocks
parameter_list|(
specifier|final
name|String
name|who
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|RecoveringBlock
argument_list|>
name|blocks
parameter_list|)
block|{
name|Daemon
name|d
init|=
operator|new
name|Daemon
argument_list|(
name|datanode
operator|.
name|threadGroup
argument_list|,
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
name|RecoveringBlock
name|b
range|:
name|blocks
control|)
block|{
try|try
block|{
name|logRecoverBlock
argument_list|(
name|who
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|RecoveryTaskContiguous
name|task
init|=
operator|new
name|RecoveryTaskContiguous
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|task
operator|.
name|recover
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"recoverBlocks FAILED: "
operator|+
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
decl_stmt|;
name|d
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|d
return|;
block|}
block|}
end_class

end_unit

