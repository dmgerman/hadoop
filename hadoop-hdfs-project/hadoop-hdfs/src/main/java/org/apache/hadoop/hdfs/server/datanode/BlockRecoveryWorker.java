begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|DatanodeProtocolClientSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringStripedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|InterDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReplicaRecoveryInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|StripedBlockUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BLOCK_GROUP_INDEX_MASK
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|StripedBlockUtil
operator|.
name|getInternalBlockLength
import|;
end_import

begin_comment
comment|/**  * This class handles the block recovery work commands.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockRecoveryWorker
specifier|public
class|class
name|BlockRecoveryWorker
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|dnConf
specifier|private
specifier|final
name|DNConf
name|dnConf
decl_stmt|;
DECL|method|BlockRecoveryWorker (DataNode datanode)
name|BlockRecoveryWorker
parameter_list|(
name|DataNode
name|datanode
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|conf
operator|=
name|datanode
operator|.
name|getConf
argument_list|()
expr_stmt|;
name|dnConf
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
expr_stmt|;
block|}
comment|/** A convenient class used in block recovery. */
DECL|class|BlockRecord
specifier|static
class|class
name|BlockRecord
block|{
DECL|field|id
specifier|private
specifier|final
name|DatanodeID
name|id
decl_stmt|;
DECL|field|datanode
specifier|private
specifier|final
name|InterDatanodeProtocol
name|datanode
decl_stmt|;
DECL|field|rInfo
specifier|private
specifier|final
name|ReplicaRecoveryInfo
name|rInfo
decl_stmt|;
DECL|field|storageID
specifier|private
name|String
name|storageID
decl_stmt|;
DECL|method|BlockRecord (DatanodeID id, InterDatanodeProtocol datanode, ReplicaRecoveryInfo rInfo)
name|BlockRecord
parameter_list|(
name|DatanodeID
name|id
parameter_list|,
name|InterDatanodeProtocol
name|datanode
parameter_list|,
name|ReplicaRecoveryInfo
name|rInfo
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|rInfo
operator|=
name|rInfo
expr_stmt|;
block|}
DECL|method|updateReplicaUnderRecovery (String bpid, long recoveryId, long newBlockId, long newLength)
specifier|private
name|void
name|updateReplicaUnderRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|newBlockId
parameter_list|,
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ExtendedBlock
name|b
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|rInfo
argument_list|)
decl_stmt|;
name|storageID
operator|=
name|datanode
operator|.
name|updateReplicaUnderRecovery
argument_list|(
name|b
argument_list|,
name|recoveryId
argument_list|,
name|newBlockId
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
block|}
DECL|method|getReplicaRecoveryInfo ()
specifier|public
name|ReplicaRecoveryInfo
name|getReplicaRecoveryInfo
parameter_list|()
block|{
return|return
name|rInfo
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"block:"
operator|+
name|rInfo
operator|+
literal|" node:"
operator|+
name|id
return|;
block|}
block|}
comment|/** A block recovery task for a contiguous block. */
DECL|class|RecoveryTaskContiguous
class|class
name|RecoveryTaskContiguous
block|{
DECL|field|rBlock
specifier|private
specifier|final
name|RecoveringBlock
name|rBlock
decl_stmt|;
DECL|field|block
specifier|private
specifier|final
name|ExtendedBlock
name|block
decl_stmt|;
DECL|field|bpid
specifier|private
specifier|final
name|String
name|bpid
decl_stmt|;
DECL|field|locs
specifier|private
specifier|final
name|DatanodeInfo
index|[]
name|locs
decl_stmt|;
DECL|field|recoveryId
specifier|private
specifier|final
name|long
name|recoveryId
decl_stmt|;
DECL|method|RecoveryTaskContiguous (RecoveringBlock rBlock)
name|RecoveryTaskContiguous
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
block|{
name|this
operator|.
name|rBlock
operator|=
name|rBlock
expr_stmt|;
name|block
operator|=
name|rBlock
operator|.
name|getBlock
argument_list|()
expr_stmt|;
name|bpid
operator|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
expr_stmt|;
name|locs
operator|=
name|rBlock
operator|.
name|getLocations
argument_list|()
expr_stmt|;
name|recoveryId
operator|=
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
expr_stmt|;
block|}
DECL|method|recover ()
specifier|protected
name|void
name|recover
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|syncList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|locs
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|errorCount
init|=
literal|0
decl_stmt|;
name|int
name|candidateReplicaCnt
init|=
literal|0
decl_stmt|;
comment|// Check generation stamps, replica size and state. Replica must satisfy
comment|// the following criteria to be included in syncList for recovery:
comment|// - Valid generation stamp
comment|// - Non-zero length
comment|// - Original state is RWR or better
for|for
control|(
name|DatanodeID
name|id
range|:
name|locs
control|)
block|{
try|try
block|{
name|DatanodeID
name|bpReg
init|=
name|getDatanodeID
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|InterDatanodeProtocol
name|proxyDN
init|=
name|bpReg
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|?
name|datanode
else|:
name|DataNode
operator|.
name|createInterDataNodeProtocolProxy
argument_list|(
name|id
argument_list|,
name|conf
argument_list|,
name|dnConf
operator|.
name|socketTimeout
argument_list|,
name|dnConf
operator|.
name|connectToDnViaHostname
argument_list|)
decl_stmt|;
name|ReplicaRecoveryInfo
name|info
init|=
name|callInitReplicaRecovery
argument_list|(
name|proxyDN
argument_list|,
name|rBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getGenerationStamp
argument_list|()
operator|>=
name|block
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|info
operator|.
name|getNumBytes
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Count the number of candidate replicas received.
operator|++
name|candidateReplicaCnt
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|getOriginalReplicaState
argument_list|()
operator|.
name|getValue
argument_list|()
operator|<=
name|ReplicaState
operator|.
name|RWR
operator|.
name|getValue
argument_list|()
condition|)
block|{
name|syncList
operator|.
name|add
argument_list|(
operator|new
name|BlockRecord
argument_list|(
name|id
argument_list|,
name|proxyDN
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block recovery: Ignored replica with invalid "
operator|+
literal|"original state: "
operator|+
name|info
operator|+
literal|" from DataNode: "
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block recovery: DataNode: "
operator|+
name|id
operator|+
literal|" does not have "
operator|+
literal|"replica for block: "
operator|+
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block recovery: Ignored replica with invalid "
operator|+
literal|"generation stamp or length: "
operator|+
name|info
operator|+
literal|" from "
operator|+
literal|"DataNode: "
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|RecoveryInProgressException
name|ripE
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Recovery for replica "
operator|+
name|block
operator|+
literal|" on data-node "
operator|+
name|id
operator|+
literal|" is already in progress. Recovery id = "
operator|+
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
operator|+
literal|" is aborted."
argument_list|,
name|ripE
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
operator|++
name|errorCount
expr_stmt|;
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to recover block (block="
operator|+
name|block
operator|+
literal|", datanode="
operator|+
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errorCount
operator|==
name|locs
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All datanodes failed: block="
operator|+
name|block
operator|+
literal|", datanodeids="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|locs
argument_list|)
argument_list|)
throw|;
block|}
comment|// None of the replicas reported by DataNodes has the required original
comment|// state, report the error.
if|if
condition|(
name|candidateReplicaCnt
operator|>
literal|0
operator|&&
name|syncList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Found "
operator|+
name|candidateReplicaCnt
operator|+
literal|" replica(s) for block "
operator|+
name|block
operator|+
literal|" but none is in "
operator|+
name|ReplicaState
operator|.
name|RWR
operator|.
name|name
argument_list|()
operator|+
literal|" or better state. datanodeids="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|locs
argument_list|)
argument_list|)
throw|;
block|}
name|syncBlock
argument_list|(
name|syncList
argument_list|)
expr_stmt|;
block|}
comment|/** Block synchronization. */
DECL|method|syncBlock (List<BlockRecord> syncList)
name|void
name|syncBlock
parameter_list|(
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|syncList
parameter_list|)
throws|throws
name|IOException
block|{
name|DatanodeProtocolClientSideTranslatorPB
name|nn
init|=
name|getActiveNamenodeForBP
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isTruncateRecovery
init|=
name|rBlock
operator|.
name|getNewBlock
argument_list|()
operator|!=
literal|null
decl_stmt|;
name|long
name|blockId
init|=
operator|(
name|isTruncateRecovery
operator|)
condition|?
name|rBlock
operator|.
name|getNewBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
else|:
name|block
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"BlockRecoveryWorker: block={} (length={}),"
operator|+
literal|" isTruncateRecovery={}, syncList={}"
argument_list|,
name|block
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|isTruncateRecovery
argument_list|,
name|syncList
argument_list|)
expr_stmt|;
comment|// syncList.isEmpty() means that all data-nodes do not have the block
comment|// or their replicas have 0 length.
comment|// The block can be deleted.
if|if
condition|(
name|syncList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"syncBlock for block "
operator|+
name|block
operator|+
literal|", all datanodes don't "
operator|+
literal|"have the block or their replicas have 0 length. The block can "
operator|+
literal|"be deleted."
argument_list|)
expr_stmt|;
block|}
name|nn
operator|.
name|commitBlockSynchronization
argument_list|(
name|block
argument_list|,
name|recoveryId
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|DatanodeID
operator|.
name|EMPTY_ARRAY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Calculate the best available replica state.
name|ReplicaState
name|bestState
init|=
name|ReplicaState
operator|.
name|RWR
decl_stmt|;
name|long
name|finalizedLength
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
assert|assert
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|>
literal|0
operator|:
literal|"zero length replica"
assert|;
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|.
name|getValue
argument_list|()
operator|<
name|bestState
operator|.
name|getValue
argument_list|()
condition|)
block|{
name|bestState
operator|=
name|rState
expr_stmt|;
block|}
if|if
condition|(
name|rState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
if|if
condition|(
name|finalizedLength
operator|>
literal|0
operator|&&
name|finalizedLength
operator|!=
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent size of finalized replicas. "
operator|+
literal|"Replica "
operator|+
name|r
operator|.
name|rInfo
operator|+
literal|" expected size: "
operator|+
name|finalizedLength
argument_list|)
throw|;
block|}
name|finalizedLength
operator|=
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Calculate list of nodes that will participate in the recovery
comment|// and the new block size
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|participatingList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|ExtendedBlock
name|newBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|,
operator|-
literal|1
argument_list|,
name|recoveryId
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|bestState
condition|)
block|{
case|case
name|FINALIZED
case|:
assert|assert
name|finalizedLength
operator|>
literal|0
operator|:
literal|"finalizedLength is not positive"
assert|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|||
name|rState
operator|==
name|ReplicaState
operator|.
name|RBW
operator|&&
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|==
name|finalizedLength
condition|)
block|{
name|participatingList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"syncBlock replicaInfo: block="
operator|+
name|block
operator|+
literal|", from datanode "
operator|+
name|r
operator|.
name|id
operator|+
literal|", receivedState="
operator|+
name|rState
operator|.
name|name
argument_list|()
operator|+
literal|", receivedLength="
operator|+
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|", bestState=FINALIZED, finalizedLength="
operator|+
name|finalizedLength
argument_list|)
expr_stmt|;
block|}
block|}
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|finalizedLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|RBW
case|:
case|case
name|RWR
case|:
name|long
name|minLength
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|==
name|bestState
condition|)
block|{
name|minLength
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minLength
argument_list|,
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|participatingList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"syncBlock replicaInfo: block="
operator|+
name|block
operator|+
literal|", from datanode "
operator|+
name|r
operator|.
name|id
operator|+
literal|", receivedState="
operator|+
name|rState
operator|.
name|name
argument_list|()
operator|+
literal|", receivedLength="
operator|+
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|", bestState="
operator|+
name|bestState
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// recover() guarantees syncList will have at least one replica with RWR
comment|// or better state.
assert|assert
name|minLength
operator|!=
name|Long
operator|.
name|MAX_VALUE
operator|:
literal|"wrong minLength"
assert|;
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|minLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUR
case|:
case|case
name|TEMPORARY
case|:
assert|assert
literal|false
operator|:
literal|"bad replica state: "
operator|+
name|bestState
assert|;
default|default:
break|break;
comment|// we have 'case' all enum values
block|}
if|if
condition|(
name|isTruncateRecovery
condition|)
block|{
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|rBlock
operator|.
name|getNewBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"BlockRecoveryWorker: block={} (length={}), bestState={},"
operator|+
literal|" newBlock={} (length={}), participatingList={}"
argument_list|,
name|block
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|bestState
operator|.
name|name
argument_list|()
argument_list|,
name|newBlock
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|participatingList
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|DatanodeID
argument_list|>
name|failedList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|successList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|participatingList
control|)
block|{
try|try
block|{
name|r
operator|.
name|updateReplicaUnderRecovery
argument_list|(
name|bpid
argument_list|,
name|recoveryId
argument_list|,
name|blockId
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|successList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to updateBlock (newblock="
operator|+
name|newBlock
operator|+
literal|", datanode="
operator|+
name|r
operator|.
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|failedList
operator|.
name|add
argument_list|(
name|r
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Abort if all failed.
if|if
condition|(
name|successList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot recover "
operator|+
name|block
operator|+
literal|", the following datanodes failed: "
operator|+
name|failedList
argument_list|)
throw|;
block|}
comment|// Notify the name-node about successfully recovered replicas.
specifier|final
name|DatanodeID
index|[]
name|datanodes
init|=
operator|new
name|DatanodeID
index|[
name|successList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|String
index|[]
name|storages
init|=
operator|new
name|String
index|[
name|datanodes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|datanodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|BlockRecord
name|r
init|=
name|successList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|datanodes
index|[
name|i
index|]
operator|=
name|r
operator|.
name|id
expr_stmt|;
name|storages
index|[
name|i
index|]
operator|=
name|r
operator|.
name|storageID
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Datanode triggering commitBlockSynchronization, block="
operator|+
name|block
operator|+
literal|", newGs="
operator|+
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", newLength="
operator|+
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nn
operator|.
name|commitBlockSynchronization
argument_list|(
name|block
argument_list|,
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|datanodes
argument_list|,
name|storages
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * blk_0  blk_1  blk_2  blk_3  blk_4  blk_5  blk_6  blk_7  blk_8    *  64k    64k    64k    64k    64k    64k    64k    64k    64k<-- stripe_0    *  64k    64k    64k    64k    64k    64k    64k    64k    64k    *  64k    64k    64k    64k    64k    64k    64k    61k<-- startStripeIdx    *  64k    64k    64k    64k    64k    64k    64k    *  64k    64k    64k    64k    64k    64k    59k    *  64k    64k    64k    64k    64k    64k    *  64k    64k    64k    64k    64k    64k<-- last full stripe    *  64k    64k    13k    64k    55k     3k<-- target last stripe    *  64k    64k           64k     1k    *  64k    64k           58k    *  64k    64k    *  64k    19k    *  64k<-- total visible stripe    *    *  Due to different speed of streamers, the internal blocks in a block group    *  could have different lengths when the block group isn't ended normally.    *  The purpose of this class is to recover the UnderConstruction block group,    *  so all internal blocks end at the same stripe.    *    * The steps:    * 1. get all blocks lengths from DataNodes.    * 2. calculate safe length, which is at the target last stripe.    * 3. decode and feed blk_6~8, make them end at last full stripe. (the last    * full stripe means the last decodable stripe.)    * 4. encode the target last stripe, with the remaining sequential data. In    * this case, the sequential data is 64k+64k+13k. Feed blk_6~8 the parity cells.    * Overwrite the parity cell if have to.    * 5. truncate the stripes from visible stripe, to target last stripe.    * TODO: implement step 3,4    */
DECL|class|RecoveryTaskStriped
specifier|public
class|class
name|RecoveryTaskStriped
block|{
DECL|field|rBlock
specifier|private
specifier|final
name|RecoveringBlock
name|rBlock
decl_stmt|;
DECL|field|block
specifier|private
specifier|final
name|ExtendedBlock
name|block
decl_stmt|;
DECL|field|bpid
specifier|private
specifier|final
name|String
name|bpid
decl_stmt|;
DECL|field|locs
specifier|private
specifier|final
name|DatanodeInfo
index|[]
name|locs
decl_stmt|;
DECL|field|recoveryId
specifier|private
specifier|final
name|long
name|recoveryId
decl_stmt|;
DECL|field|blockIndices
specifier|private
specifier|final
name|byte
index|[]
name|blockIndices
decl_stmt|;
DECL|field|ecPolicy
specifier|private
specifier|final
name|ErasureCodingPolicy
name|ecPolicy
decl_stmt|;
DECL|method|RecoveryTaskStriped (RecoveringStripedBlock rBlock)
name|RecoveryTaskStriped
parameter_list|(
name|RecoveringStripedBlock
name|rBlock
parameter_list|)
block|{
name|this
operator|.
name|rBlock
operator|=
name|rBlock
expr_stmt|;
comment|// TODO: support truncate
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|rBlock
operator|.
name|getNewBlock
argument_list|()
operator|==
literal|null
argument_list|)
expr_stmt|;
name|block
operator|=
name|rBlock
operator|.
name|getBlock
argument_list|()
expr_stmt|;
name|bpid
operator|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
expr_stmt|;
name|locs
operator|=
name|rBlock
operator|.
name|getLocations
argument_list|()
expr_stmt|;
name|recoveryId
operator|=
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
expr_stmt|;
name|blockIndices
operator|=
name|rBlock
operator|.
name|getBlockIndices
argument_list|()
expr_stmt|;
name|ecPolicy
operator|=
name|rBlock
operator|.
name|getErasureCodingPolicy
argument_list|()
expr_stmt|;
block|}
DECL|method|recover ()
specifier|protected
name|void
name|recover
parameter_list|()
throws|throws
name|IOException
block|{
name|checkLocations
argument_list|(
name|locs
operator|.
name|length
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Long
argument_list|,
name|BlockRecord
argument_list|>
name|syncBlocks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|locs
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|int
name|dataBlkNum
init|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
specifier|final
name|int
name|totalBlkNum
init|=
name|dataBlkNum
operator|+
name|ecPolicy
operator|.
name|getNumParityUnits
argument_list|()
decl_stmt|;
comment|//check generation stamps
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeID
name|id
init|=
name|locs
index|[
name|i
index|]
decl_stmt|;
try|try
block|{
name|DatanodeID
name|bpReg
init|=
name|getDatanodeID
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|InterDatanodeProtocol
name|proxyDN
init|=
name|bpReg
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|?
name|datanode
else|:
name|DataNode
operator|.
name|createInterDataNodeProtocolProxy
argument_list|(
name|id
argument_list|,
name|conf
argument_list|,
name|dnConf
operator|.
name|socketTimeout
argument_list|,
name|dnConf
operator|.
name|connectToDnViaHostname
argument_list|)
decl_stmt|;
name|ExtendedBlock
name|internalBlk
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|final
name|long
name|blockId
init|=
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
name|blockIndices
index|[
name|i
index|]
decl_stmt|;
name|internalBlk
operator|.
name|setBlockId
argument_list|(
name|blockId
argument_list|)
expr_stmt|;
name|ReplicaRecoveryInfo
name|info
init|=
name|callInitReplicaRecovery
argument_list|(
name|proxyDN
argument_list|,
operator|new
name|RecoveringBlock
argument_list|(
name|internalBlk
argument_list|,
literal|null
argument_list|,
name|recoveryId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getGenerationStamp
argument_list|()
operator|>=
name|block
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|info
operator|.
name|getNumBytes
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|BlockRecord
name|existing
init|=
name|syncBlocks
operator|.
name|get
argument_list|(
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|==
literal|null
operator|||
name|info
operator|.
name|getNumBytes
argument_list|()
operator|>
name|existing
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
comment|// if we have>1 replicas for the same internal block, we
comment|// simply choose the one with larger length.
comment|// TODO: better usage of redundant replicas
name|syncBlocks
operator|.
name|put
argument_list|(
name|blockId
argument_list|,
operator|new
name|BlockRecord
argument_list|(
name|id
argument_list|,
name|proxyDN
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|RecoveryInProgressException
name|ripE
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Recovery for replica "
operator|+
name|block
operator|+
literal|" on data-node "
operator|+
name|id
operator|+
literal|" is already in progress. Recovery id = "
operator|+
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
operator|+
literal|" is aborted."
argument_list|,
name|ripE
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to recover block (block="
operator|+
name|block
operator|+
literal|", datanode="
operator|+
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|checkLocations
argument_list|(
name|syncBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|safeLength
init|=
name|getSafeLength
argument_list|(
name|syncBlocks
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Recovering block "
operator|+
name|block
operator|+
literal|", length="
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|", safeLength="
operator|+
name|safeLength
operator|+
literal|", syncList="
operator|+
name|syncBlocks
argument_list|)
expr_stmt|;
block|}
comment|// If some internal blocks reach the safe length, convert them to RUR
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|rurList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|locs
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncBlocks
operator|.
name|values
argument_list|()
control|)
block|{
name|int
name|blockIndex
init|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|rInfo
operator|.
name|getBlockId
argument_list|()
operator|&
name|BLOCK_GROUP_INDEX_MASK
argument_list|)
decl_stmt|;
name|long
name|newSize
init|=
name|getInternalBlockLength
argument_list|(
name|safeLength
argument_list|,
name|ecPolicy
operator|.
name|getCellSize
argument_list|()
argument_list|,
name|dataBlkNum
argument_list|,
name|blockIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|>=
name|newSize
condition|)
block|{
name|rurList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|rurList
operator|.
name|size
argument_list|()
operator|>=
name|dataBlkNum
operator|:
literal|"incorrect safe length"
assert|;
comment|// Recovery the striped block by truncating internal blocks to the safe
comment|// length. Abort if there is any failure in this step.
name|truncatePartialBlock
argument_list|(
name|rurList
argument_list|,
name|safeLength
argument_list|)
expr_stmt|;
comment|// notify Namenode the new size and locations
specifier|final
name|DatanodeID
index|[]
name|newLocs
init|=
operator|new
name|DatanodeID
index|[
name|totalBlkNum
index|]
decl_stmt|;
specifier|final
name|String
index|[]
name|newStorages
init|=
operator|new
name|String
index|[
name|totalBlkNum
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|totalBlkNum
condition|;
name|i
operator|++
control|)
block|{
name|newLocs
index|[
name|blockIndices
index|[
name|i
index|]
index|]
operator|=
name|DatanodeID
operator|.
name|EMPTY_DATANODE_ID
expr_stmt|;
name|newStorages
index|[
name|blockIndices
index|[
name|i
index|]
index|]
operator|=
literal|""
expr_stmt|;
block|}
for|for
control|(
name|BlockRecord
name|r
range|:
name|rurList
control|)
block|{
name|int
name|index
init|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|rInfo
operator|.
name|getBlockId
argument_list|()
operator|&
name|HdfsServerConstants
operator|.
name|BLOCK_GROUP_INDEX_MASK
argument_list|)
decl_stmt|;
name|newLocs
index|[
name|index
index|]
operator|=
name|r
operator|.
name|id
expr_stmt|;
name|newStorages
index|[
name|index
index|]
operator|=
name|r
operator|.
name|storageID
expr_stmt|;
block|}
name|ExtendedBlock
name|newBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|safeLength
argument_list|,
name|recoveryId
argument_list|)
decl_stmt|;
name|DatanodeProtocolClientSideTranslatorPB
name|nn
init|=
name|getActiveNamenodeForBP
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|nn
operator|.
name|commitBlockSynchronization
argument_list|(
name|block
argument_list|,
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|newLocs
argument_list|,
name|newStorages
argument_list|)
expr_stmt|;
block|}
DECL|method|truncatePartialBlock (List<BlockRecord> rurList, long safeLength)
specifier|private
name|void
name|truncatePartialBlock
parameter_list|(
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|rurList
parameter_list|,
name|long
name|safeLength
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|cellSize
init|=
name|ecPolicy
operator|.
name|getCellSize
argument_list|()
decl_stmt|;
name|int
name|dataBlkNum
init|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeID
argument_list|>
name|failedList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|rurList
control|)
block|{
name|int
name|blockIndex
init|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|rInfo
operator|.
name|getBlockId
argument_list|()
operator|&
name|BLOCK_GROUP_INDEX_MASK
argument_list|)
decl_stmt|;
name|long
name|newSize
init|=
name|getInternalBlockLength
argument_list|(
name|safeLength
argument_list|,
name|cellSize
argument_list|,
name|dataBlkNum
argument_list|,
name|blockIndex
argument_list|)
decl_stmt|;
try|try
block|{
name|r
operator|.
name|updateReplicaUnderRecovery
argument_list|(
name|bpid
argument_list|,
name|recoveryId
argument_list|,
name|r
operator|.
name|rInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|newSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to updateBlock (newblock="
operator|+
literal|", datanode="
operator|+
name|r
operator|.
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|failedList
operator|.
name|add
argument_list|(
name|r
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If any of the data-nodes failed, the recovery fails, because
comment|// we never know the actual state of the replica on failed data-nodes.
comment|// The recovery should be started over.
if|if
condition|(
operator|!
name|failedList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot recover "
operator|+
name|block
operator|+
literal|", the following datanodes failed: "
operator|+
name|failedList
argument_list|)
throw|;
block|}
block|}
comment|/**      * TODO: the current implementation depends on the assumption that the      * parity cells are only generated based on the full stripe. This is not      * true after we support hflush.      */
annotation|@
name|VisibleForTesting
DECL|method|getSafeLength (Map<Long, BlockRecord> syncBlocks)
name|long
name|getSafeLength
parameter_list|(
name|Map
argument_list|<
name|Long
argument_list|,
name|BlockRecord
argument_list|>
name|syncBlocks
parameter_list|)
block|{
specifier|final
name|int
name|dataBlkNum
init|=
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|syncBlocks
operator|.
name|size
argument_list|()
operator|>=
name|dataBlkNum
argument_list|)
expr_stmt|;
name|long
index|[]
name|blockLengths
init|=
operator|new
name|long
index|[
name|syncBlocks
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncBlocks
operator|.
name|values
argument_list|()
control|)
block|{
name|ReplicaRecoveryInfo
name|rInfo
init|=
name|r
operator|.
name|getReplicaRecoveryInfo
argument_list|()
decl_stmt|;
name|blockLengths
index|[
name|i
operator|++
index|]
operator|=
name|rInfo
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
return|return
name|StripedBlockUtil
operator|.
name|getSafeLength
argument_list|(
name|ecPolicy
argument_list|,
name|blockLengths
argument_list|)
return|;
block|}
DECL|method|checkLocations (int locationCount)
specifier|private
name|void
name|checkLocations
parameter_list|(
name|int
name|locationCount
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|locationCount
operator|<
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|block
operator|+
literal|" has no enough internal blocks"
operator|+
literal|", unable to start recovery. Locations="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|locs
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|getDatanodeID (String bpid)
specifier|private
name|DatanodeID
name|getDatanodeID
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|datanode
operator|.
name|getBPOfferService
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No block pool offer service for bpid="
operator|+
name|bpid
argument_list|)
throw|;
block|}
return|return
operator|new
name|DatanodeID
argument_list|(
name|bpos
operator|.
name|bpRegistration
argument_list|)
return|;
block|}
DECL|method|logRecoverBlock (String who, RecoveringBlock rb)
specifier|private
specifier|static
name|void
name|logRecoverBlock
parameter_list|(
name|String
name|who
parameter_list|,
name|RecoveringBlock
name|rb
parameter_list|)
block|{
name|ExtendedBlock
name|block
init|=
name|rb
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|DatanodeInfo
index|[]
name|targets
init|=
name|rb
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"BlockRecoveryWorker: "
operator|+
name|who
operator|+
literal|" calls recoverBlock("
operator|+
name|block
operator|+
literal|", targets=["
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|targets
argument_list|)
operator|+
literal|"]"
operator|+
literal|", newGenerationStamp="
operator|+
name|rb
operator|.
name|getNewGenerationStamp
argument_list|()
operator|+
literal|", newBlock="
operator|+
name|rb
operator|.
name|getNewBlock
argument_list|()
operator|+
literal|", isStriped="
operator|+
name|rb
operator|.
name|isStriped
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convenience method, which unwraps RemoteException.    * @throws IOException not a RemoteException.    */
DECL|method|callInitReplicaRecovery ( InterDatanodeProtocol datanode, RecoveringBlock rBlock)
specifier|private
specifier|static
name|ReplicaRecoveryInfo
name|callInitReplicaRecovery
parameter_list|(
name|InterDatanodeProtocol
name|datanode
parameter_list|,
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|datanode
operator|.
name|initReplicaRecovery
argument_list|(
name|rBlock
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Get the NameNode corresponding to the given block pool.    *    * @param bpid Block pool Id    * @return Namenode corresponding to the bpid    * @throws IOException if unable to get the corresponding NameNode    */
DECL|method|getActiveNamenodeForBP ( String bpid)
name|DatanodeProtocolClientSideTranslatorPB
name|getActiveNamenodeForBP
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|datanode
operator|.
name|getBPOfferService
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No block pool offer service for bpid="
operator|+
name|bpid
argument_list|)
throw|;
block|}
name|DatanodeProtocolClientSideTranslatorPB
name|activeNN
init|=
name|bpos
operator|.
name|getActiveNN
argument_list|()
decl_stmt|;
if|if
condition|(
name|activeNN
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block pool "
operator|+
name|bpid
operator|+
literal|" has not recognized an active NN"
argument_list|)
throw|;
block|}
return|return
name|activeNN
return|;
block|}
DECL|method|recoverBlocks (final String who, final Collection<RecoveringBlock> blocks)
specifier|public
name|Daemon
name|recoverBlocks
parameter_list|(
specifier|final
name|String
name|who
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|RecoveringBlock
argument_list|>
name|blocks
parameter_list|)
block|{
name|Daemon
name|d
init|=
operator|new
name|Daemon
argument_list|(
name|datanode
operator|.
name|threadGroup
argument_list|,
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
name|RecoveringBlock
name|b
range|:
name|blocks
control|)
block|{
try|try
block|{
name|logRecoverBlock
argument_list|(
name|who
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|isStriped
argument_list|()
condition|)
block|{
operator|new
name|RecoveryTaskStriped
argument_list|(
operator|(
name|RecoveringStripedBlock
operator|)
name|b
argument_list|)
operator|.
name|recover
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|new
name|RecoveryTaskContiguous
argument_list|(
name|b
argument_list|)
operator|.
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"recoverBlocks FAILED: "
operator|+
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
decl_stmt|;
name|d
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|d
return|;
block|}
block|}
end_class

end_unit

