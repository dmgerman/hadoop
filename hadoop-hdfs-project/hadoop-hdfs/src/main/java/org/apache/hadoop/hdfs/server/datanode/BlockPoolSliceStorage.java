begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HardLink
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|InconsistentFSStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|StorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * Manages storage for the set of BlockPoolSlices which share a particular   * block pool id, on this DataNode.  *   * This class supports the following functionality:  *<ol>  *<li> Formatting a new block pool storage</li>  *<li> Recovering a storage state to a consistent state (if possible></li>  *<li> Taking a snapshot of the block pool during upgrade</li>  *<li> Rolling back a block pool to a previous snapshot</li>  *<li> Finalizing block storage by deletion of a snapshot</li>  *</ul>  *   * @see Storage  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockPoolSliceStorage
specifier|public
class|class
name|BlockPoolSliceStorage
extends|extends
name|Storage
block|{
DECL|field|TRASH_ROOT_DIR
specifier|static
specifier|final
name|String
name|TRASH_ROOT_DIR
init|=
literal|"trash"
decl_stmt|;
comment|/**    * A marker file that is created on each root directory if a rolling upgrade    * is in progress. The NN does not inform the DN when a rolling upgrade is    * finalized. All the DN can infer is whether or not a rolling upgrade is    * currently in progress. When the rolling upgrade is not in progress:    *   1. If the marker file is present, then a rolling upgrade just completed.    *      If a 'previous' directory exists, it can be deleted now.    *   2. If the marker file is absent, then a regular upgrade may be in    *      progress. Do not delete the 'previous' directory.    */
DECL|field|ROLLING_UPGRADE_MARKER_FILE
specifier|static
specifier|final
name|String
name|ROLLING_UPGRADE_MARKER_FILE
init|=
literal|"RollingUpgradeInProgress"
decl_stmt|;
DECL|field|BLOCK_POOL_ID_PATTERN_BASE
specifier|private
specifier|static
specifier|final
name|String
name|BLOCK_POOL_ID_PATTERN_BASE
init|=
name|Pattern
operator|.
name|quote
argument_list|(
name|File
operator|.
name|separator
argument_list|)
operator|+
literal|"BP-\\d+-\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}-\\d+"
operator|+
name|Pattern
operator|.
name|quote
argument_list|(
name|File
operator|.
name|separator
argument_list|)
decl_stmt|;
DECL|field|BLOCK_POOL_PATH_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|BLOCK_POOL_PATH_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(.*)("
operator|+
name|BLOCK_POOL_ID_PATTERN_BASE
operator|+
literal|")(.*)$"
argument_list|)
decl_stmt|;
DECL|field|BLOCK_POOL_CURRENT_PATH_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|BLOCK_POOL_CURRENT_PATH_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(.*)("
operator|+
name|BLOCK_POOL_ID_PATTERN_BASE
operator|+
literal|")("
operator|+
name|STORAGE_DIR_CURRENT
operator|+
literal|")(.*)$"
argument_list|)
decl_stmt|;
DECL|field|BLOCK_POOL_TRASH_PATH_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|BLOCK_POOL_TRASH_PATH_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(.*)("
operator|+
name|BLOCK_POOL_ID_PATTERN_BASE
operator|+
literal|")("
operator|+
name|TRASH_ROOT_DIR
operator|+
literal|")(.*)$"
argument_list|)
decl_stmt|;
DECL|field|blockpoolID
specifier|private
name|String
name|blockpoolID
init|=
literal|""
decl_stmt|;
comment|// id of the blockpool
DECL|field|trashCleaner
specifier|private
name|Daemon
name|trashCleaner
decl_stmt|;
DECL|method|BlockPoolSliceStorage (StorageInfo storageInfo, String bpid)
specifier|public
name|BlockPoolSliceStorage
parameter_list|(
name|StorageInfo
name|storageInfo
parameter_list|,
name|String
name|bpid
parameter_list|)
block|{
name|super
argument_list|(
name|storageInfo
argument_list|)
expr_stmt|;
name|blockpoolID
operator|=
name|bpid
expr_stmt|;
block|}
comment|/**    * These maps are used as an optimization to avoid one filesystem operation    * per storage on each heartbeat response.    */
DECL|field|storagesWithRollingUpgradeMarker
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|storagesWithRollingUpgradeMarker
decl_stmt|;
DECL|field|storagesWithoutRollingUpgradeMarker
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|storagesWithoutRollingUpgradeMarker
decl_stmt|;
DECL|method|BlockPoolSliceStorage (int namespaceID, String bpID, long cTime, String clusterId)
name|BlockPoolSliceStorage
parameter_list|(
name|int
name|namespaceID
parameter_list|,
name|String
name|bpID
parameter_list|,
name|long
name|cTime
parameter_list|,
name|String
name|clusterId
parameter_list|)
block|{
name|super
argument_list|(
name|NodeType
operator|.
name|DATA_NODE
argument_list|)
expr_stmt|;
name|this
operator|.
name|namespaceID
operator|=
name|namespaceID
expr_stmt|;
name|this
operator|.
name|blockpoolID
operator|=
name|bpID
expr_stmt|;
name|this
operator|.
name|cTime
operator|=
name|cTime
expr_stmt|;
name|this
operator|.
name|clusterID
operator|=
name|clusterId
expr_stmt|;
name|storagesWithRollingUpgradeMarker
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|storagesWithoutRollingUpgradeMarker
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|BlockPoolSliceStorage ()
specifier|private
name|BlockPoolSliceStorage
parameter_list|()
block|{
name|super
argument_list|(
name|NodeType
operator|.
name|DATA_NODE
argument_list|)
expr_stmt|;
name|storagesWithRollingUpgradeMarker
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|storagesWithoutRollingUpgradeMarker
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Expose visibility for VolumeBuilder#commit().
DECL|method|addStorageDir (StorageDirectory sd)
specifier|public
name|void
name|addStorageDir
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
name|super
operator|.
name|addStorageDir
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
comment|/**    * Load one storage directory. Recover from previous transitions if required.    *    * @param nsInfo namespace information    * @param dataDir the root path of the storage directory    * @param startOpt startup option    * @return the StorageDirectory successfully loaded.    * @throws IOException    */
DECL|method|loadStorageDirectory (NamespaceInfo nsInfo, StorageLocation location, StartupOption startOpt, List<Callable<StorageDirectory>> callables, Configuration conf)
specifier|private
name|StorageDirectory
name|loadStorageDirectory
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|,
name|StorageLocation
name|location
parameter_list|,
name|StartupOption
name|startOpt
parameter_list|,
name|List
argument_list|<
name|Callable
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|>
name|callables
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|StorageDirectory
name|sd
init|=
operator|new
name|StorageDirectory
argument_list|(
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
name|location
argument_list|)
decl_stmt|;
try|try
block|{
name|StorageState
name|curState
init|=
name|sd
operator|.
name|analyzeStorage
argument_list|(
name|startOpt
argument_list|,
name|this
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// sd is locked but not opened
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|NORMAL
case|:
break|break;
case|case
name|NON_EXISTENT
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Block pool storage directory for location "
operator|+
name|location
operator|+
literal|" and block pool id "
operator|+
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
operator|+
literal|" does not exist"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Storage directory for location "
operator|+
name|location
operator|+
literal|" and block pool id "
operator|+
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
operator|+
literal|" does not exist"
argument_list|)
throw|;
case|case
name|NOT_FORMATTED
case|:
comment|// format
name|LOG
operator|.
name|info
argument_list|(
literal|"Block pool storage directory for location "
operator|+
name|location
operator|+
literal|" and block pool id "
operator|+
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
operator|+
literal|" is not formatted for "
operator|+
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
operator|+
literal|". Formatting ..."
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|sd
argument_list|,
name|nsInfo
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// recovery part is common
name|sd
operator|.
name|doRecover
argument_list|(
name|curState
argument_list|)
expr_stmt|;
block|}
comment|// 2. Do transitions
comment|// Each storage directory is treated individually.
comment|// During startup some of them can upgrade or roll back
comment|// while others could be up-to-date for the regular startup.
if|if
condition|(
operator|!
name|doTransition
argument_list|(
name|sd
argument_list|,
name|nsInfo
argument_list|,
name|startOpt
argument_list|,
name|callables
argument_list|,
name|conf
argument_list|)
condition|)
block|{
comment|// 3. Check CTime and update successfully loaded storage.
if|if
condition|(
name|getCTime
argument_list|()
operator|!=
name|nsInfo
operator|.
name|getCTime
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Datanode CTime (="
operator|+
name|getCTime
argument_list|()
operator|+
literal|") is not equal to namenode CTime (="
operator|+
name|nsInfo
operator|.
name|getCTime
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|setServiceLayoutVersion
argument_list|(
name|getServiceLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
name|writeProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
return|return
name|sd
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
comment|/**    * Analyze and load storage directories. Recover from previous transitions if    * required.    *    * The block pool storages are either all analyzed or none of them is loaded.    * Therefore, a failure on loading any block pool storage results a faulty    * data volume.    *    * @param nsInfo namespace information    * @param dataDirs storage directories of block pool    * @param startOpt startup option    * @return an array of loaded block pool directories.    * @throws IOException on error    */
DECL|method|loadBpStorageDirectories (NamespaceInfo nsInfo, StorageLocation location, StartupOption startOpt, List<Callable<StorageDirectory>> callables, Configuration conf)
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|loadBpStorageDirectories
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|,
name|StorageLocation
name|location
parameter_list|,
name|StartupOption
name|startOpt
parameter_list|,
name|List
argument_list|<
name|Callable
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|>
name|callables
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|succeedDirs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|containsStorageDir
argument_list|(
name|location
argument_list|,
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"BlockPoolSliceStorage.recoverTransitionRead: "
operator|+
literal|"attempt to load an used block storage: "
operator|+
name|location
argument_list|)
throw|;
block|}
specifier|final
name|StorageDirectory
name|sd
init|=
name|loadStorageDirectory
argument_list|(
name|nsInfo
argument_list|,
name|location
argument_list|,
name|startOpt
argument_list|,
name|callables
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|succeedDirs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to analyze storage directories for block pool "
operator|+
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|succeedDirs
return|;
block|}
comment|/**    * Analyze storage directories. Recover from previous transitions if required.    *    * The block pool storages are either all analyzed or none of them is loaded.    * Therefore, a failure on loading any block pool storage results a faulty    * data volume.    *    * @param nsInfo namespace information    * @param dataDirs storage directories of block pool    * @param startOpt startup option    * @throws IOException on error    */
DECL|method|recoverTransitionRead (NamespaceInfo nsInfo, StorageLocation location, StartupOption startOpt, List<Callable<StorageDirectory>> callables, Configuration conf)
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|recoverTransitionRead
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|,
name|StorageLocation
name|location
parameter_list|,
name|StartupOption
name|startOpt
parameter_list|,
name|List
argument_list|<
name|Callable
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|>
name|callables
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Analyzing storage directories for bpid "
operator|+
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|loaded
init|=
name|loadBpStorageDirectories
argument_list|(
name|nsInfo
argument_list|,
name|location
argument_list|,
name|startOpt
argument_list|,
name|callables
argument_list|,
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|loaded
control|)
block|{
name|addStorageDir
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
return|return
name|loaded
return|;
block|}
comment|/**    * Format a block pool slice storage.     * @param dnCurDir DataStorage current directory    * @param nsInfo the name space info    * @throws IOException Signals that an I/O exception has occurred.    */
DECL|method|format (File dnCurDir, NamespaceInfo nsInfo)
name|void
name|format
parameter_list|(
name|File
name|dnCurDir
parameter_list|,
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|curBpDir
init|=
name|getBpRoot
argument_list|(
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
argument_list|,
name|dnCurDir
argument_list|)
decl_stmt|;
name|StorageDirectory
name|bpSdir
init|=
operator|new
name|StorageDirectory
argument_list|(
name|curBpDir
argument_list|)
decl_stmt|;
name|format
argument_list|(
name|bpSdir
argument_list|,
name|nsInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * Format a block pool slice storage.     * @param bpSdir the block pool storage    * @param nsInfo the name space info    * @throws IOException Signals that an I/O exception has occurred.    */
DECL|method|format (StorageDirectory bpSdir, NamespaceInfo nsInfo)
specifier|private
name|void
name|format
parameter_list|(
name|StorageDirectory
name|bpSdir
parameter_list|,
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Formatting block pool "
operator|+
name|blockpoolID
operator|+
literal|" directory "
operator|+
name|bpSdir
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
expr_stmt|;
name|bpSdir
operator|.
name|clearDirectory
argument_list|()
expr_stmt|;
comment|// create directory
name|this
operator|.
name|layoutVersion
operator|=
name|HdfsServerConstants
operator|.
name|DATANODE_LAYOUT_VERSION
expr_stmt|;
name|this
operator|.
name|cTime
operator|=
name|nsInfo
operator|.
name|getCTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|namespaceID
operator|=
name|nsInfo
operator|.
name|getNamespaceID
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockpoolID
operator|=
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
expr_stmt|;
name|writeProperties
argument_list|(
name|bpSdir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove block pool level storage directory.    * @param absPathToRemove the absolute path of the root for the block pool    *                        level storage to remove.    */
DECL|method|remove (File absPathToRemove)
name|void
name|remove
parameter_list|(
name|File
name|absPathToRemove
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|absPathToRemove
operator|.
name|isAbsolute
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing block level storage: "
operator|+
name|absPathToRemove
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|getStorageDirs
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|equals
argument_list|(
name|absPathToRemove
argument_list|)
condition|)
block|{
name|this
operator|.
name|storageDirs
operator|.
name|remove
argument_list|(
name|sd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/**    * Set layoutVersion, namespaceID and blockpoolID into block pool storage    * VERSION file    */
annotation|@
name|Override
DECL|method|setPropertiesFromFields (Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setPropertiesFromFields
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|props
operator|.
name|setProperty
argument_list|(
literal|"layoutVersion"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|layoutVersion
argument_list|)
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
literal|"namespaceID"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|namespaceID
argument_list|)
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
literal|"blockpoolID"
argument_list|,
name|blockpoolID
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
literal|"cTime"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|cTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Validate and set block pool ID */
DECL|method|setBlockPoolID (File storage, String bpid)
specifier|private
name|void
name|setBlockPoolID
parameter_list|(
name|File
name|storage
parameter_list|,
name|String
name|bpid
parameter_list|)
throws|throws
name|InconsistentFSStateException
block|{
if|if
condition|(
name|bpid
operator|==
literal|null
operator|||
name|bpid
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|storage
argument_list|,
literal|"file "
operator|+
name|STORAGE_FILE_VERSION
operator|+
literal|" is invalid."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|blockpoolID
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
operator|!
name|blockpoolID
operator|.
name|equals
argument_list|(
name|bpid
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|storage
argument_list|,
literal|"Unexpected blockpoolID "
operator|+
name|bpid
operator|+
literal|". Expected "
operator|+
name|blockpoolID
argument_list|)
throw|;
block|}
name|blockpoolID
operator|=
name|bpid
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setFieldsFromProperties (Properties props, StorageDirectory sd)
specifier|protected
name|void
name|setFieldsFromProperties
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|setLayoutVersion
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|setNamespaceID
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|setcTime
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|String
name|sbpid
init|=
name|props
operator|.
name|getProperty
argument_list|(
literal|"blockpoolID"
argument_list|)
decl_stmt|;
name|setBlockPoolID
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|sbpid
argument_list|)
expr_stmt|;
block|}
comment|/**    * Analyze whether a transition of the BP state is required and    * perform it if necessary.    *<br>    * Rollback if previousLV>= LAYOUT_VERSION&& prevCTime<= namenode.cTime.    * Upgrade if this.LV> LAYOUT_VERSION || this.cTime< namenode.cTime Regular    * startup if this.LV = LAYOUT_VERSION&& this.cTime = namenode.cTime    *     * @param sd storage directory<SD>/current/<bpid>    * @param nsInfo namespace info    * @param startOpt startup option    * @return true if the new properties has been written.    */
DECL|method|doTransition (StorageDirectory sd, NamespaceInfo nsInfo, StartupOption startOpt, List<Callable<StorageDirectory>> callables, Configuration conf)
specifier|private
name|boolean
name|doTransition
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|NamespaceInfo
name|nsInfo
parameter_list|,
name|StartupOption
name|startOpt
parameter_list|,
name|List
argument_list|<
name|Callable
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|>
name|callables
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|ROLLBACK
operator|&&
name|sd
operator|.
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|getTrashRootDir
argument_list|(
name|sd
argument_list|)
operator|.
name|exists
argument_list|()
argument_list|,
name|sd
operator|.
name|getPreviousDir
argument_list|()
operator|+
literal|" and "
operator|+
name|getTrashRootDir
argument_list|(
name|sd
argument_list|)
operator|+
literal|" should not "
operator|+
literal|" both be present."
argument_list|)
expr_stmt|;
name|doRollback
argument_list|(
name|sd
argument_list|,
name|nsInfo
argument_list|)
expr_stmt|;
comment|// rollback if applicable
block|}
elseif|else
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|ROLLBACK
operator|&&
operator|!
name|sd
operator|.
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// Restore all the files in the trash. The restored files are retained
comment|// during rolling upgrade rollback. They are deleted during rolling
comment|// upgrade downgrade.
name|int
name|restored
init|=
name|restoreBlockFilesFromTrash
argument_list|(
name|getTrashRootDir
argument_list|(
name|sd
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Restored "
operator|+
name|restored
operator|+
literal|" block files from trash."
argument_list|)
expr_stmt|;
block|}
name|readProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|checkVersionUpgradable
argument_list|(
name|this
operator|.
name|layoutVersion
argument_list|)
expr_stmt|;
assert|assert
name|this
operator|.
name|layoutVersion
operator|>=
name|HdfsServerConstants
operator|.
name|DATANODE_LAYOUT_VERSION
operator|:
literal|"Future version is not allowed"
assert|;
if|if
condition|(
name|getNamespaceID
argument_list|()
operator|!=
name|nsInfo
operator|.
name|getNamespaceID
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incompatible namespaceIDs in "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getCanonicalPath
argument_list|()
operator|+
literal|": namenode namespaceID = "
operator|+
name|nsInfo
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|"; datanode namespaceID = "
operator|+
name|getNamespaceID
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|blockpoolID
operator|.
name|equals
argument_list|(
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incompatible blockpoolIDs in "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getCanonicalPath
argument_list|()
operator|+
literal|": namenode blockpoolID = "
operator|+
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
operator|+
literal|"; datanode blockpoolID = "
operator|+
name|blockpoolID
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|layoutVersion
operator|==
name|HdfsServerConstants
operator|.
name|DATANODE_LAYOUT_VERSION
operator|&&
name|this
operator|.
name|cTime
operator|==
name|nsInfo
operator|.
name|getCTime
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
comment|// regular startup
block|}
if|if
condition|(
name|this
operator|.
name|layoutVersion
operator|>
name|HdfsServerConstants
operator|.
name|DATANODE_LAYOUT_VERSION
condition|)
block|{
name|int
name|restored
init|=
name|restoreBlockFilesFromTrash
argument_list|(
name|getTrashRootDir
argument_list|(
name|sd
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Restored "
operator|+
name|restored
operator|+
literal|" block files from trash "
operator|+
literal|"before the layout upgrade. These blocks will be moved to "
operator|+
literal|"the previous directory during the upgrade"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|layoutVersion
operator|>
name|HdfsServerConstants
operator|.
name|DATANODE_LAYOUT_VERSION
operator|||
name|this
operator|.
name|cTime
operator|<
name|nsInfo
operator|.
name|getCTime
argument_list|()
condition|)
block|{
name|doUpgrade
argument_list|(
name|sd
argument_list|,
name|nsInfo
argument_list|,
name|callables
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// upgrade
return|return
literal|true
return|;
block|}
comment|// layoutVersion == LAYOUT_VERSION&& this.cTime> nsInfo.cTime
comment|// must shutdown
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Datanode state: LV = "
operator|+
name|this
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" CTime = "
operator|+
name|this
operator|.
name|getCTime
argument_list|()
operator|+
literal|" is newer than the namespace state: LV = "
operator|+
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" CTime = "
operator|+
name|nsInfo
operator|.
name|getCTime
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Upgrade to any release after 0.22 (0.22 included) release e.g. 0.22 => 0.23    * Upgrade procedure is as follows:    *<ol>    *<li>If<SD>/current/<bpid>/previous exists then delete it</li>    *<li>Rename<SD>/current/<bpid>/current to    *<SD>/current/bpid/current/previous.tmp</li>    *<li>Create new<SD>current/<bpid>/current directory</li>    *<ol>    *<li>Hard links for block files are created from previous.tmp to current</li>    *<li>Save new version file in current directory</li>    *</ol>    *<li>Rename previous.tmp to previous</li></ol>    *     * @param bpSd storage directory<SD>/current/<bpid>    * @param nsInfo Namespace Info from the namenode    * @throws IOException on error    */
DECL|method|doUpgrade (final StorageDirectory bpSd, final NamespaceInfo nsInfo, final List<Callable<StorageDirectory>> callables, final Configuration conf)
specifier|private
name|void
name|doUpgrade
parameter_list|(
specifier|final
name|StorageDirectory
name|bpSd
parameter_list|,
specifier|final
name|NamespaceInfo
name|nsInfo
parameter_list|,
specifier|final
name|List
argument_list|<
name|Callable
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|>
name|callables
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Upgrading is applicable only to release with federation or after
if|if
condition|(
operator|!
name|DataNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|LayoutVersion
operator|.
name|Feature
operator|.
name|FEDERATION
argument_list|,
name|layoutVersion
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|int
name|oldLV
init|=
name|getLayoutVersion
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Upgrading block pool storage directory "
operator|+
name|bpSd
operator|.
name|getRoot
argument_list|()
operator|+
literal|".\n   old LV = "
operator|+
name|oldLV
operator|+
literal|"; old CTime = "
operator|+
name|this
operator|.
name|getCTime
argument_list|()
operator|+
literal|".\n   new LV = "
operator|+
name|HdfsServerConstants
operator|.
name|DATANODE_LAYOUT_VERSION
operator|+
literal|"; new CTime = "
operator|+
name|nsInfo
operator|.
name|getCTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// get<SD>/previous directory
name|String
name|dnRoot
init|=
name|getDataNodeStorageRoot
argument_list|(
name|bpSd
operator|.
name|getRoot
argument_list|()
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
decl_stmt|;
name|StorageDirectory
name|dnSdStorage
init|=
operator|new
name|StorageDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|dnRoot
argument_list|)
argument_list|)
decl_stmt|;
name|File
name|dnPrevDir
init|=
name|dnSdStorage
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
comment|// If<SD>/previous directory exists delete it
if|if
condition|(
name|dnPrevDir
operator|.
name|exists
argument_list|()
condition|)
block|{
name|deleteDir
argument_list|(
name|dnPrevDir
argument_list|)
expr_stmt|;
block|}
specifier|final
name|File
name|bpCurDir
init|=
name|bpSd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
specifier|final
name|File
name|bpPrevDir
init|=
name|bpSd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
assert|assert
name|bpCurDir
operator|.
name|exists
argument_list|()
operator|:
literal|"BP level current directory must exist."
assert|;
name|cleanupDetachDir
argument_list|(
operator|new
name|File
argument_list|(
name|bpCurDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_DETACHED
argument_list|)
argument_list|)
expr_stmt|;
comment|// 1. Delete<SD>/current/<bpid>/previous dir before upgrading
if|if
condition|(
name|bpPrevDir
operator|.
name|exists
argument_list|()
condition|)
block|{
name|deleteDir
argument_list|(
name|bpPrevDir
argument_list|)
expr_stmt|;
block|}
specifier|final
name|File
name|bpTmpDir
init|=
name|bpSd
operator|.
name|getPreviousTmp
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|bpTmpDir
operator|.
name|exists
argument_list|()
operator|:
literal|"previous.tmp directory must not exist."
assert|;
comment|// 2. Rename<SD>/current/<bpid>/current to
comment|//<SD>/current/<bpid>/previous.tmp
name|rename
argument_list|(
name|bpCurDir
argument_list|,
name|bpTmpDir
argument_list|)
expr_stmt|;
specifier|final
name|String
name|name
init|=
literal|"block pool "
operator|+
name|blockpoolID
operator|+
literal|" at "
operator|+
name|bpSd
operator|.
name|getRoot
argument_list|()
decl_stmt|;
if|if
condition|(
name|callables
operator|==
literal|null
condition|)
block|{
name|doUpgrade
argument_list|(
name|name
argument_list|,
name|bpSd
argument_list|,
name|nsInfo
argument_list|,
name|bpPrevDir
argument_list|,
name|bpTmpDir
argument_list|,
name|bpCurDir
argument_list|,
name|oldLV
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callables
operator|.
name|add
argument_list|(
operator|new
name|Callable
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|StorageDirectory
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|doUpgrade
argument_list|(
name|name
argument_list|,
name|bpSd
argument_list|,
name|nsInfo
argument_list|,
name|bpPrevDir
argument_list|,
name|bpTmpDir
argument_list|,
name|bpCurDir
argument_list|,
name|oldLV
argument_list|,
name|conf
argument_list|)
expr_stmt|;
return|return
name|bpSd
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doUpgrade (String name, final StorageDirectory bpSd, NamespaceInfo nsInfo, final File bpPrevDir, final File bpTmpDir, final File bpCurDir, final int oldLV, Configuration conf)
specifier|private
name|void
name|doUpgrade
parameter_list|(
name|String
name|name
parameter_list|,
specifier|final
name|StorageDirectory
name|bpSd
parameter_list|,
name|NamespaceInfo
name|nsInfo
parameter_list|,
specifier|final
name|File
name|bpPrevDir
parameter_list|,
specifier|final
name|File
name|bpTmpDir
parameter_list|,
specifier|final
name|File
name|bpCurDir
parameter_list|,
specifier|final
name|int
name|oldLV
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// 3. Create new<SD>/current with block files hardlinks and VERSION
name|linkAllBlocks
argument_list|(
name|bpTmpDir
argument_list|,
name|bpCurDir
argument_list|,
name|oldLV
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|layoutVersion
operator|=
name|HdfsServerConstants
operator|.
name|DATANODE_LAYOUT_VERSION
expr_stmt|;
assert|assert
name|this
operator|.
name|namespaceID
operator|==
name|nsInfo
operator|.
name|getNamespaceID
argument_list|()
operator|:
literal|"Data-node and name-node layout versions must be the same."
assert|;
name|this
operator|.
name|cTime
operator|=
name|nsInfo
operator|.
name|getCTime
argument_list|()
expr_stmt|;
name|writeProperties
argument_list|(
name|bpSd
argument_list|)
expr_stmt|;
comment|// 4.rename<SD>/current/<bpid>/previous.tmp to
comment|//<SD>/current/<bpid>/previous
name|rename
argument_list|(
name|bpTmpDir
argument_list|,
name|bpPrevDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Upgrade of "
operator|+
name|name
operator|+
literal|" is complete"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Cleanup the detachDir.    *     * If the directory is not empty report an error; Otherwise remove the    * directory.    *     * @param detachDir detach directory    * @throws IOException if the directory is not empty or it can not be removed    */
DECL|method|cleanupDetachDir (File detachDir)
specifier|private
name|void
name|cleanupDetachDir
parameter_list|(
name|File
name|detachDir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|DataNodeLayoutVersion
operator|.
name|supports
argument_list|(
name|LayoutVersion
operator|.
name|Feature
operator|.
name|APPEND_RBW_DIR
argument_list|,
name|layoutVersion
argument_list|)
operator|&&
name|detachDir
operator|.
name|exists
argument_list|()
operator|&&
name|detachDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
name|FileUtil
operator|.
name|list
argument_list|(
name|detachDir
argument_list|)
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Detached directory "
operator|+
name|detachDir
operator|+
literal|" is not empty. Please manually move each file under this "
operator|+
literal|"directory to the finalized directory if the finalized "
operator|+
literal|"directory tree does not have the file."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|detachDir
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot remove directory "
operator|+
name|detachDir
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Restore all files from the trash directory to their corresponding    * locations under current/    */
DECL|method|restoreBlockFilesFromTrash (File trashRoot)
specifier|private
name|int
name|restoreBlockFilesFromTrash
parameter_list|(
name|File
name|trashRoot
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|filesRestored
init|=
literal|0
decl_stmt|;
name|File
index|[]
name|children
init|=
name|trashRoot
operator|.
name|exists
argument_list|()
condition|?
name|trashRoot
operator|.
name|listFiles
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|File
name|restoreDirectory
init|=
literal|null
decl_stmt|;
for|for
control|(
name|File
name|child
range|:
name|children
control|)
block|{
if|if
condition|(
name|child
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// Recurse to process subdirectories.
name|filesRestored
operator|+=
name|restoreBlockFilesFromTrash
argument_list|(
name|child
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|restoreDirectory
operator|==
literal|null
condition|)
block|{
name|restoreDirectory
operator|=
operator|new
name|File
argument_list|(
name|getRestoreDirectory
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|restoreDirectory
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|restoreDirectory
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to create directory "
operator|+
name|restoreDirectory
argument_list|)
throw|;
block|}
block|}
specifier|final
name|File
name|newChild
init|=
operator|new
name|File
argument_list|(
name|restoreDirectory
argument_list|,
name|child
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newChild
operator|.
name|exists
argument_list|()
operator|&&
name|newChild
operator|.
name|length
argument_list|()
operator|>=
name|child
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// Failsafe - we should not hit this case but let's make sure
comment|// we never overwrite a newer version of a block file with an
comment|// older version.
name|LOG
operator|.
name|info
argument_list|(
literal|"Not overwriting "
operator|+
name|newChild
operator|+
literal|" with smaller file from "
operator|+
literal|"trash directory. This message can be safely ignored."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|child
operator|.
name|renameTo
argument_list|(
name|newChild
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to rename "
operator|+
name|child
operator|+
literal|" to "
operator|+
name|newChild
argument_list|)
throw|;
block|}
else|else
block|{
operator|++
name|filesRestored
expr_stmt|;
block|}
block|}
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|trashRoot
argument_list|)
expr_stmt|;
return|return
name|filesRestored
return|;
block|}
comment|/*    * Roll back to old snapshot at the block pool level    * If previous directory exists:     *<ol>    *<li>Rename<SD>/current/<bpid>/current to removed.tmp</li>    *<li>Rename *<SD>/current/<bpid>/previous to current</li>    *<li>Remove removed.tmp</li>    *</ol>    *     * Do nothing if previous directory does not exist.    * @param bpSd Block pool storage directory at<SD>/current/<bpid>    */
DECL|method|doRollback (StorageDirectory bpSd, NamespaceInfo nsInfo)
name|void
name|doRollback
parameter_list|(
name|StorageDirectory
name|bpSd
parameter_list|,
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|prevDir
init|=
name|bpSd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
comment|// regular startup if previous dir does not exist
if|if
condition|(
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
condition|)
return|return;
comment|// read attributes out of the VERSION file of previous directory
name|BlockPoolSliceStorage
name|prevInfo
init|=
operator|new
name|BlockPoolSliceStorage
argument_list|()
decl_stmt|;
name|prevInfo
operator|.
name|readPreviousVersionProperties
argument_list|(
name|bpSd
argument_list|)
expr_stmt|;
comment|// We allow rollback to a state, which is either consistent with
comment|// the namespace state or can be further upgraded to it.
comment|// In another word, we can only roll back when ( storedLV>= software LV)
comment|//&& ( DN.previousCTime<= NN.ctime)
if|if
condition|(
operator|!
operator|(
name|prevInfo
operator|.
name|getLayoutVersion
argument_list|()
operator|>=
name|HdfsServerConstants
operator|.
name|DATANODE_LAYOUT_VERSION
operator|&&
name|prevInfo
operator|.
name|getCTime
argument_list|()
operator|<=
name|nsInfo
operator|.
name|getCTime
argument_list|()
operator|)
condition|)
block|{
comment|// cannot rollback
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|bpSd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"Cannot rollback to a newer state.\nDatanode previous state: LV = "
operator|+
name|prevInfo
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" CTime = "
operator|+
name|prevInfo
operator|.
name|getCTime
argument_list|()
operator|+
literal|" is newer than the namespace state: LV = "
operator|+
name|HdfsServerConstants
operator|.
name|DATANODE_LAYOUT_VERSION
operator|+
literal|" CTime = "
operator|+
name|nsInfo
operator|.
name|getCTime
argument_list|()
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Rolling back storage directory "
operator|+
name|bpSd
operator|.
name|getRoot
argument_list|()
operator|+
literal|".\n   target LV = "
operator|+
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; target CTime = "
operator|+
name|nsInfo
operator|.
name|getCTime
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|tmpDir
init|=
name|bpSd
operator|.
name|getRemovedTmp
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|tmpDir
operator|.
name|exists
argument_list|()
operator|:
literal|"removed.tmp directory must not exist."
assert|;
comment|// 1. rename current to tmp
name|File
name|curDir
init|=
name|bpSd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
assert|assert
name|curDir
operator|.
name|exists
argument_list|()
operator|:
literal|"Current directory must exist."
assert|;
name|rename
argument_list|(
name|curDir
argument_list|,
name|tmpDir
argument_list|)
expr_stmt|;
comment|// 2. rename previous to current
name|rename
argument_list|(
name|prevDir
argument_list|,
name|curDir
argument_list|)
expr_stmt|;
comment|// 3. delete removed.tmp dir
name|deleteDir
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rollback of "
operator|+
name|bpSd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is complete"
argument_list|)
expr_stmt|;
block|}
comment|/*    * Finalize the block pool storage by deleting<BP>/previous directory    * that holds the snapshot.    */
DECL|method|doFinalize (File dnCurDir)
name|void
name|doFinalize
parameter_list|(
name|File
name|dnCurDir
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|bpRoot
init|=
name|getBpRoot
argument_list|(
name|blockpoolID
argument_list|,
name|dnCurDir
argument_list|)
decl_stmt|;
name|StorageDirectory
name|bpSd
init|=
operator|new
name|StorageDirectory
argument_list|(
name|bpRoot
argument_list|)
decl_stmt|;
comment|// block pool level previous directory
name|File
name|prevDir
init|=
name|bpSd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return;
comment|// already finalized
block|}
specifier|final
name|String
name|dataDirPath
init|=
name|bpSd
operator|.
name|getRoot
argument_list|()
operator|.
name|getCanonicalPath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalizing upgrade for storage directory "
operator|+
name|dataDirPath
operator|+
literal|".\n   cur LV = "
operator|+
name|this
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; cur CTime = "
operator|+
name|this
operator|.
name|getCTime
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|bpSd
operator|.
name|getCurrentDir
argument_list|()
operator|.
name|exists
argument_list|()
operator|:
literal|"Current directory must exist."
assert|;
comment|// rename previous to finalized.tmp
specifier|final
name|File
name|tmpDir
init|=
name|bpSd
operator|.
name|getFinalizedTmp
argument_list|()
decl_stmt|;
name|rename
argument_list|(
name|prevDir
argument_list|,
name|tmpDir
argument_list|)
expr_stmt|;
comment|// delete finalized.tmp dir in a separate thread
operator|new
name|Daemon
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|deleteDir
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Finalize upgrade for "
operator|+
name|dataDirPath
operator|+
literal|" failed."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalize upgrade for "
operator|+
name|dataDirPath
operator|+
literal|" is complete."
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Finalize "
operator|+
name|dataDirPath
return|;
block|}
block|}
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Hardlink all finalized and RBW blocks in fromDir to toDir    *     * @param fromDir directory where the snapshot is stored    * @param toDir the current data directory    * @throws IOException if error occurs during hardlink    */
DECL|method|linkAllBlocks (File fromDir, File toDir, int diskLayoutVersion, Configuration conf)
specifier|private
specifier|static
name|void
name|linkAllBlocks
parameter_list|(
name|File
name|fromDir
parameter_list|,
name|File
name|toDir
parameter_list|,
name|int
name|diskLayoutVersion
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// do the link
comment|// hardlink finalized blocks in tmpDir
name|HardLink
name|hardLink
init|=
operator|new
name|HardLink
argument_list|()
decl_stmt|;
name|DataStorage
operator|.
name|linkBlocks
argument_list|(
name|fromDir
argument_list|,
name|toDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_FINALIZED
argument_list|,
name|diskLayoutVersion
argument_list|,
name|hardLink
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|DataStorage
operator|.
name|linkBlocks
argument_list|(
name|fromDir
argument_list|,
name|toDir
argument_list|,
name|DataStorage
operator|.
name|STORAGE_DIR_RBW
argument_list|,
name|diskLayoutVersion
argument_list|,
name|hardLink
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Linked blocks from "
operator|+
name|fromDir
operator|+
literal|" to "
operator|+
name|toDir
operator|+
literal|". "
operator|+
name|hardLink
operator|.
name|linkStats
operator|.
name|report
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * gets the data node storage directory based on block pool storage    */
DECL|method|getDataNodeStorageRoot (String bpRoot)
specifier|private
specifier|static
name|String
name|getDataNodeStorageRoot
parameter_list|(
name|String
name|bpRoot
parameter_list|)
block|{
name|Matcher
name|matcher
init|=
name|BLOCK_POOL_PATH_PATTERN
operator|.
name|matcher
argument_list|(
name|bpRoot
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|// return the data node root directory
return|return
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
return|;
block|}
return|return
name|bpRoot
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|";bpid="
operator|+
name|blockpoolID
return|;
block|}
comment|/**    * Get a block pool storage root based on data node storage root    * @param bpID block pool ID    * @param dnCurDir data node storage root directory    * @return root directory for block pool storage    */
DECL|method|getBpRoot (String bpID, File dnCurDir)
specifier|public
specifier|static
name|File
name|getBpRoot
parameter_list|(
name|String
name|bpID
parameter_list|,
name|File
name|dnCurDir
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|dnCurDir
argument_list|,
name|bpID
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isPreUpgradableLayout (StorageDirectory sd)
specifier|public
name|boolean
name|isPreUpgradableLayout
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|false
return|;
block|}
DECL|method|getTrashRootDir (StorageDirectory sd)
specifier|private
name|File
name|getTrashRootDir
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|TRASH_ROOT_DIR
argument_list|)
return|;
block|}
comment|/**    * Determine whether we can use trash for the given blockFile. Trash    * is disallowed if a 'previous' directory exists for the    * storage directory containing the block.    */
annotation|@
name|VisibleForTesting
DECL|method|isTrashAllowed (File blockFile)
specifier|public
name|boolean
name|isTrashAllowed
parameter_list|(
name|File
name|blockFile
parameter_list|)
block|{
name|Matcher
name|matcher
init|=
name|BLOCK_POOL_CURRENT_PATH_PATTERN
operator|.
name|matcher
argument_list|(
name|blockFile
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|previousDir
init|=
name|matcher
operator|.
name|replaceFirst
argument_list|(
literal|"$1$2"
operator|+
name|STORAGE_DIR_PREVIOUS
argument_list|)
decl_stmt|;
return|return
operator|!
operator|(
operator|new
name|File
argument_list|(
name|previousDir
argument_list|)
operator|)
operator|.
name|exists
argument_list|()
return|;
block|}
comment|/**    * Get a target subdirectory under trash/ for a given block file that is being    * deleted.    *    * The subdirectory structure under trash/ mirrors that under current/ to keep    * implicit memory of where the files are to be restored (if necessary).    *    * @return the trash directory for a given block file that is being deleted.    */
DECL|method|getTrashDirectory (ReplicaInfo info)
specifier|public
name|String
name|getTrashDirectory
parameter_list|(
name|ReplicaInfo
name|info
parameter_list|)
block|{
name|URI
name|blockURI
init|=
name|info
operator|.
name|getBlockURI
argument_list|()
decl_stmt|;
try|try
block|{
name|File
name|blockFile
init|=
operator|new
name|File
argument_list|(
name|blockURI
argument_list|)
decl_stmt|;
return|return
name|getTrashDirectory
argument_list|(
name|blockFile
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get block file for replica "
operator|+
name|info
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|getTrashDirectory (File blockFile)
specifier|private
name|String
name|getTrashDirectory
parameter_list|(
name|File
name|blockFile
parameter_list|)
block|{
if|if
condition|(
name|isTrashAllowed
argument_list|(
name|blockFile
argument_list|)
condition|)
block|{
name|Matcher
name|matcher
init|=
name|BLOCK_POOL_CURRENT_PATH_PATTERN
operator|.
name|matcher
argument_list|(
name|blockFile
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|trashDirectory
init|=
name|matcher
operator|.
name|replaceFirst
argument_list|(
literal|"$1$2"
operator|+
name|TRASH_ROOT_DIR
operator|+
literal|"$4"
argument_list|)
decl_stmt|;
return|return
name|trashDirectory
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get a target subdirectory under current/ for a given block file that is being    * restored from trash.    *    * The subdirectory structure under trash/ mirrors that under current/ to keep    * implicit memory of where the files are to be restored.    *    * @return the target directory to restore a previously deleted block file.    */
annotation|@
name|VisibleForTesting
DECL|method|getRestoreDirectory (File blockFile)
name|String
name|getRestoreDirectory
parameter_list|(
name|File
name|blockFile
parameter_list|)
block|{
name|Matcher
name|matcher
init|=
name|BLOCK_POOL_TRASH_PATH_PATTERN
operator|.
name|matcher
argument_list|(
name|blockFile
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|restoreDirectory
init|=
name|matcher
operator|.
name|replaceFirst
argument_list|(
literal|"$1$2"
operator|+
name|STORAGE_DIR_CURRENT
operator|+
literal|"$4"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Restoring "
operator|+
name|blockFile
operator|+
literal|" to "
operator|+
name|restoreDirectory
argument_list|)
expr_stmt|;
return|return
name|restoreDirectory
return|;
block|}
comment|/**    * Delete all files and directories in the trash directories.    */
DECL|method|clearTrash ()
specifier|public
name|void
name|clearTrash
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|File
argument_list|>
name|trashRoots
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|getStorageDirs
argument_list|()
control|)
block|{
name|File
name|trashRoot
init|=
name|getTrashRootDir
argument_list|(
name|sd
argument_list|)
decl_stmt|;
if|if
condition|(
name|trashRoot
operator|.
name|exists
argument_list|()
operator|&&
name|sd
operator|.
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Trash and PreviousDir shouldn't both exist for storage "
operator|+
literal|"directory "
operator|+
name|sd
argument_list|)
expr_stmt|;
assert|assert
literal|false
assert|;
block|}
else|else
block|{
name|trashRoots
operator|.
name|add
argument_list|(
name|trashRoot
argument_list|)
expr_stmt|;
block|}
block|}
name|stopTrashCleaner
argument_list|()
expr_stmt|;
name|trashCleaner
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
name|File
name|trashRoot
range|:
name|trashRoots
control|)
block|{
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|trashRoot
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleared trash for storage directory "
operator|+
name|trashRoot
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"clearTrash() for "
operator|+
name|blockpoolID
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|trashCleaner
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|stopTrashCleaner ()
specifier|public
name|void
name|stopTrashCleaner
parameter_list|()
block|{
if|if
condition|(
name|trashCleaner
operator|!=
literal|null
condition|)
block|{
name|trashCleaner
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** trash is enabled if at least one storage directory contains trash root */
annotation|@
name|VisibleForTesting
DECL|method|trashEnabled ()
specifier|public
name|boolean
name|trashEnabled
parameter_list|()
block|{
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|getStorageDirs
argument_list|()
control|)
block|{
if|if
condition|(
name|getTrashRootDir
argument_list|(
name|sd
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Create a rolling upgrade marker file for each BP storage root, if it    * does not exist already.    */
DECL|method|setRollingUpgradeMarkers (List<StorageDirectory> dnStorageDirs)
specifier|public
name|void
name|setRollingUpgradeMarkers
parameter_list|(
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|dnStorageDirs
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|dnStorageDirs
control|)
block|{
name|File
name|bpRoot
init|=
name|getBpRoot
argument_list|(
name|blockpoolID
argument_list|,
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|markerFile
init|=
operator|new
name|File
argument_list|(
name|bpRoot
argument_list|,
name|ROLLING_UPGRADE_MARKER_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storagesWithRollingUpgradeMarker
operator|.
name|contains
argument_list|(
name|bpRoot
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|markerFile
operator|.
name|exists
argument_list|()
operator|&&
name|markerFile
operator|.
name|createNewFile
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Created "
operator|+
name|markerFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
name|markerFile
operator|+
literal|" already exists."
argument_list|)
expr_stmt|;
block|}
name|storagesWithRollingUpgradeMarker
operator|.
name|add
argument_list|(
name|bpRoot
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|storagesWithoutRollingUpgradeMarker
operator|.
name|remove
argument_list|(
name|bpRoot
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check whether the rolling upgrade marker file exists for each BP storage    * root. If it does exist, then the marker file is cleared and more    * importantly the layout upgrade is finalized.    */
DECL|method|clearRollingUpgradeMarkers (List<StorageDirectory> dnStorageDirs)
specifier|public
name|void
name|clearRollingUpgradeMarkers
parameter_list|(
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|dnStorageDirs
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|dnStorageDirs
control|)
block|{
name|File
name|bpRoot
init|=
name|getBpRoot
argument_list|(
name|blockpoolID
argument_list|,
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|markerFile
init|=
operator|new
name|File
argument_list|(
name|bpRoot
argument_list|,
name|ROLLING_UPGRADE_MARKER_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storagesWithoutRollingUpgradeMarker
operator|.
name|contains
argument_list|(
name|bpRoot
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|markerFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting "
operator|+
name|markerFile
argument_list|)
expr_stmt|;
name|doFinalize
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|markerFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete "
operator|+
name|markerFile
argument_list|)
expr_stmt|;
block|}
block|}
name|storagesWithoutRollingUpgradeMarker
operator|.
name|add
argument_list|(
name|bpRoot
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|storagesWithRollingUpgradeMarker
operator|.
name|remove
argument_list|(
name|bpRoot
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

