begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.cblock.jscsiHelper
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|jscsiHelper
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Longs
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|jscsiHelper
operator|.
name|cache
operator|.
name|LogicalBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|jscsiHelper
operator|.
name|cache
operator|.
name|impl
operator|.
name|AsyncBlockWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|jscsiHelper
operator|.
name|cache
operator|.
name|impl
operator|.
name|DiskBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ozone
operator|.
name|OzoneConsts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|scm
operator|.
name|XceiverClientManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|scm
operator|.
name|container
operator|.
name|common
operator|.
name|helpers
operator|.
name|Pipeline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|utils
operator|.
name|LevelDBStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_BLOCK_BUFFER_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_BLOCK_BUFFER_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_CORE_POOL_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_CORE_POOL_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_KEEP_ALIVE_SECONDS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_KEEP_ALIVE_SECONDS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_MAX_POOL_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_MAX_POOL_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_QUEUE_SIZE_KB
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_QUEUE_SIZE_KB_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_THREAD_PRIORITY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_THREAD_PRIORITY_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_LEVELDB_CACHE_SIZE_MB_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|cblock
operator|.
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_LEVELDB_CACHE_SIZE_MB_DEFAULT
import|;
end_import

begin_comment
comment|/**  * Class that writes to remote containers.  */
end_comment

begin_class
DECL|class|ContainerCacheFlusher
specifier|public
class|class
name|ContainerCacheFlusher
implements|implements
name|Runnable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContainerCacheFlusher
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|messageQueue
specifier|private
specifier|final
name|LinkedBlockingQueue
argument_list|<
name|Message
argument_list|>
name|messageQueue
decl_stmt|;
DECL|field|threadPoolExecutor
specifier|private
specifier|final
name|ThreadPoolExecutor
name|threadPoolExecutor
decl_stmt|;
DECL|field|workQueue
specifier|private
specifier|final
name|ArrayBlockingQueue
argument_list|<
name|Runnable
argument_list|>
name|workQueue
decl_stmt|;
DECL|field|dbMap
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|RefCountedDB
argument_list|>
name|dbMap
decl_stmt|;
DECL|field|blockIDBuffer
specifier|private
specifier|final
name|ByteBuffer
name|blockIDBuffer
decl_stmt|;
DECL|field|pipelineMap
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|Pipeline
index|[]
argument_list|>
name|pipelineMap
decl_stmt|;
DECL|field|remoteIO
specifier|private
specifier|final
name|AtomicLong
name|remoteIO
decl_stmt|;
DECL|field|xceiverClientManager
specifier|private
specifier|final
name|XceiverClientManager
name|xceiverClientManager
decl_stmt|;
DECL|field|metrics
specifier|private
specifier|final
name|CBlockTargetMetrics
name|metrics
decl_stmt|;
DECL|field|shutdown
specifier|private
name|AtomicBoolean
name|shutdown
decl_stmt|;
DECL|field|levelDBCacheSize
specifier|private
specifier|final
name|long
name|levelDBCacheSize
decl_stmt|;
DECL|field|maxRetryCount
specifier|private
specifier|final
name|int
name|maxRetryCount
decl_stmt|;
DECL|field|finishCountMap
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|FinishCounter
argument_list|>
name|finishCountMap
decl_stmt|;
comment|/**    * Constructs the writers to remote queue.    */
DECL|method|ContainerCacheFlusher (Configuration config, XceiverClientManager xceiverClientManager, CBlockTargetMetrics metrics)
specifier|public
name|ContainerCacheFlusher
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|XceiverClientManager
name|xceiverClientManager
parameter_list|,
name|CBlockTargetMetrics
name|metrics
parameter_list|)
block|{
name|int
name|queueSize
init|=
name|config
operator|.
name|getInt
argument_list|(
name|DFS_CBLOCK_CACHE_QUEUE_SIZE_KB
argument_list|,
name|DFS_CBLOCK_CACHE_QUEUE_SIZE_KB_DEFAULT
argument_list|)
operator|*
literal|1024
decl_stmt|;
name|int
name|corePoolSize
init|=
name|config
operator|.
name|getInt
argument_list|(
name|DFS_CBLOCK_CACHE_CORE_POOL_SIZE
argument_list|,
name|DFS_CBLOCK_CACHE_CORE_POOL_SIZE_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|maxPoolSize
init|=
name|config
operator|.
name|getInt
argument_list|(
name|DFS_CBLOCK_CACHE_MAX_POOL_SIZE
argument_list|,
name|DFS_CBLOCK_CACHE_MAX_POOL_SIZE_DEFAULT
argument_list|)
decl_stmt|;
name|long
name|keepAlive
init|=
name|config
operator|.
name|getLong
argument_list|(
name|DFS_CBLOCK_CACHE_KEEP_ALIVE_SECONDS
argument_list|,
name|DFS_CBLOCK_CACHE_KEEP_ALIVE_SECONDS_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|threadPri
init|=
name|config
operator|.
name|getInt
argument_list|(
name|DFS_CBLOCK_CACHE_THREAD_PRIORITY
argument_list|,
name|DFS_CBLOCK_CACHE_THREAD_PRIORITY_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|blockBufferSize
init|=
name|config
operator|.
name|getInt
argument_list|(
name|DFS_CBLOCK_CACHE_BLOCK_BUFFER_SIZE
argument_list|,
name|DFS_CBLOCK_CACHE_BLOCK_BUFFER_SIZE_DEFAULT
argument_list|)
operator|*
operator|(
name|Long
operator|.
name|SIZE
operator|/
name|Byte
operator|.
name|SIZE
operator|)
decl_stmt|;
name|levelDBCacheSize
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|DFS_CBLOCK_CACHE_LEVELDB_CACHE_SIZE_MB_KEY
argument_list|,
name|DFS_CBLOCK_CACHE_LEVELDB_CACHE_SIZE_MB_DEFAULT
argument_list|)
operator|*
name|OzoneConsts
operator|.
name|MB
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cache: Core Pool Size: {}"
argument_list|,
name|corePoolSize
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cache: Keep Alive: {}"
argument_list|,
name|keepAlive
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cache: Max Pool Size: {}"
argument_list|,
name|maxPoolSize
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cache: Thread Pri: {}"
argument_list|,
name|threadPri
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cache: BlockBuffer Size: {}"
argument_list|,
name|blockBufferSize
argument_list|)
expr_stmt|;
name|shutdown
operator|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|messageQueue
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|()
expr_stmt|;
name|workQueue
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<>
argument_list|(
name|queueSize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|ThreadFactory
name|workerThreadFactory
init|=
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"Cache Block Writer Thread #%d"
argument_list|)
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setPriority
argument_list|(
name|threadPri
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|threadPoolExecutor
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|corePoolSize
argument_list|,
name|maxPoolSize
argument_list|,
name|keepAlive
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|workQueue
argument_list|,
name|workerThreadFactory
argument_list|,
operator|new
name|ThreadPoolExecutor
operator|.
name|AbortPolicy
argument_list|()
argument_list|)
expr_stmt|;
name|threadPoolExecutor
operator|.
name|prestartAllCoreThreads
argument_list|()
expr_stmt|;
name|dbMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|pipelineMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|blockIDBuffer
operator|=
name|ByteBuffer
operator|.
name|allocateDirect
argument_list|(
name|blockBufferSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|xceiverClientManager
operator|=
name|xceiverClientManager
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
name|this
operator|.
name|remoteIO
operator|=
operator|new
name|AtomicLong
argument_list|()
expr_stmt|;
name|this
operator|.
name|finishCountMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxRetryCount
operator|=
name|config
operator|.
name|getInt
argument_list|(
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_MAX_RETRY_KEY
argument_list|,
name|CBlockConfigKeys
operator|.
name|DFS_CBLOCK_CACHE_MAX_RETRY_DEFAULT
argument_list|)
expr_stmt|;
block|}
DECL|method|checkExistingLog (String prefixFileName, File dbPath)
specifier|private
name|void
name|checkExistingLog
parameter_list|(
name|String
name|prefixFileName
parameter_list|,
name|File
name|dbPath
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dbPath
operator|.
name|exists
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No existing dirty log found at {}"
argument_list|,
name|dbPath
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Need to check and requeue existing dirty log {}"
argument_list|,
name|dbPath
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|allFiles
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|traverse
argument_list|(
name|prefixFileName
argument_list|,
name|dbPath
argument_list|,
name|allFiles
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|allFiles
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|parentPath
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"found {} {} with prefix {}"
argument_list|,
name|parentPath
argument_list|,
name|fileName
argument_list|,
name|prefixFileName
argument_list|)
expr_stmt|;
name|processDirtyBlocks
argument_list|(
name|parentPath
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|traverse (String prefixFileName, File path, HashMap<String, ArrayList<String>> files)
specifier|private
name|void
name|traverse
parameter_list|(
name|String
name|prefixFileName
parameter_list|,
name|File
name|path
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|files
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isFile
argument_list|()
condition|)
block|{
if|if
condition|(
name|path
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefixFileName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"found this {} with {}"
argument_list|,
name|path
operator|.
name|getParent
argument_list|()
argument_list|,
name|path
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|files
operator|.
name|containsKey
argument_list|(
name|path
operator|.
name|getParent
argument_list|()
argument_list|)
condition|)
block|{
name|files
operator|.
name|put
argument_list|(
name|path
operator|.
name|getParent
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|files
operator|.
name|get
argument_list|(
name|path
operator|.
name|getParent
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|path
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|File
index|[]
name|listFiles
init|=
name|path
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|listFiles
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|File
name|subPath
range|:
name|listFiles
control|)
block|{
name|traverse
argument_list|(
name|prefixFileName
argument_list|,
name|subPath
argument_list|,
name|files
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Gets the CBlockTargetMetrics.    *    * @return CBlockTargetMetrics    */
DECL|method|getTargetMetrics ()
specifier|public
name|CBlockTargetMetrics
name|getTargetMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
comment|/**    * Gets the  getXceiverClientManager.    *    * @return XceiverClientManager    */
DECL|method|getXceiverClientManager ()
specifier|public
name|XceiverClientManager
name|getXceiverClientManager
parameter_list|()
block|{
return|return
name|xceiverClientManager
return|;
block|}
comment|/**    * Shutdown this instance.    */
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|this
operator|.
name|shutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|threadPoolExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
DECL|method|incrementRemoteIO ()
specifier|public
name|long
name|incrementRemoteIO
parameter_list|()
block|{
return|return
name|remoteIO
operator|.
name|incrementAndGet
argument_list|()
return|;
block|}
comment|/**    * Processes a block cache file and queues those blocks for the remote I/O.    *    * @param dbPath - Location where the DB can be found.    * @param fileName - Block Cache File Name    */
DECL|method|processDirtyBlocks (String dbPath, String fileName)
specifier|public
name|void
name|processDirtyBlocks
parameter_list|(
name|String
name|dbPath
parameter_list|,
name|String
name|fileName
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding {}/{} to queue. Queue Length: {}"
argument_list|,
name|dbPath
argument_list|,
name|fileName
argument_list|,
name|messageQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|messageQueue
operator|.
name|add
argument_list|(
operator|new
name|Message
argument_list|(
name|dbPath
argument_list|,
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getLOG ()
specifier|public
name|Logger
name|getLOG
parameter_list|()
block|{
return|return
name|LOG
return|;
block|}
comment|/**    * Opens a DB if needed or returns a handle to an already open DB.    *    * @param dbPath -- dbPath    * @return the levelDB on the given path.    * @throws IOException    */
DECL|method|openDB (String dbPath)
specifier|public
specifier|synchronized
name|LevelDBStore
name|openDB
parameter_list|(
name|String
name|dbPath
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dbMap
operator|.
name|containsKey
argument_list|(
name|dbPath
argument_list|)
condition|)
block|{
name|RefCountedDB
name|refDB
init|=
name|dbMap
operator|.
name|get
argument_list|(
name|dbPath
argument_list|)
decl_stmt|;
name|refDB
operator|.
name|open
argument_list|()
expr_stmt|;
return|return
name|refDB
operator|.
name|db
return|;
block|}
else|else
block|{
name|Options
name|options
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|options
operator|.
name|cacheSize
argument_list|(
name|levelDBCacheSize
argument_list|)
expr_stmt|;
name|options
operator|.
name|createIfMissing
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|LevelDBStore
name|cacheDB
init|=
operator|new
name|LevelDBStore
argument_list|(
operator|new
name|File
argument_list|(
name|getDBFileName
argument_list|(
name|dbPath
argument_list|)
argument_list|)
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|RefCountedDB
name|refDB
init|=
operator|new
name|RefCountedDB
argument_list|(
name|dbPath
argument_list|,
name|cacheDB
argument_list|)
decl_stmt|;
name|dbMap
operator|.
name|put
argument_list|(
name|dbPath
argument_list|,
name|refDB
argument_list|)
expr_stmt|;
return|return
name|cacheDB
return|;
block|}
block|}
comment|/**    * Updates the container map. This data never changes so we will update this    * during restarts and it should not hurt us.    *    * Once a CBlockLocalCache cache is registered, requeue dirty/retry log files    * for the volume    *    * @param dbPath - DbPath    * @param containerList - Container List.    */
DECL|method|register (String dbPath, Pipeline[] containerList)
specifier|public
name|void
name|register
parameter_list|(
name|String
name|dbPath
parameter_list|,
name|Pipeline
index|[]
name|containerList
parameter_list|)
block|{
name|File
name|dbFile
init|=
name|Paths
operator|.
name|get
argument_list|(
name|dbPath
argument_list|)
operator|.
name|toFile
argument_list|()
decl_stmt|;
name|pipelineMap
operator|.
name|put
argument_list|(
name|dbPath
argument_list|,
name|containerList
argument_list|)
expr_stmt|;
name|checkExistingLog
argument_list|(
name|AsyncBlockWriter
operator|.
name|DIRTY_LOG_PREFIX
argument_list|,
name|dbFile
argument_list|)
expr_stmt|;
name|checkExistingLog
argument_list|(
name|AsyncBlockWriter
operator|.
name|RETRY_LOG_PREFIX
argument_list|,
name|dbFile
argument_list|)
expr_stmt|;
block|}
DECL|method|getDBFileName (String dbPath)
specifier|private
name|String
name|getDBFileName
parameter_list|(
name|String
name|dbPath
parameter_list|)
block|{
return|return
name|dbPath
operator|+
literal|".db"
return|;
block|}
DECL|method|getCacheDB (String dbPath)
specifier|public
name|LevelDBStore
name|getCacheDB
parameter_list|(
name|String
name|dbPath
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|openDB
argument_list|(
name|dbPath
argument_list|)
return|;
block|}
DECL|method|releaseCacheDB (String dbPath)
specifier|public
name|void
name|releaseCacheDB
parameter_list|(
name|String
name|dbPath
parameter_list|)
block|{
try|try
block|{
name|closeDB
argument_list|(
name|dbPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|metrics
operator|.
name|incNumFailedReleaseLevelDB
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"LevelDB close failed, dbPath:"
operator|+
name|dbPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Close the DB if we don't have any outstanding references.    *    * @param dbPath - dbPath    * @throws IOException    */
DECL|method|closeDB (String dbPath)
specifier|public
specifier|synchronized
name|void
name|closeDB
parameter_list|(
name|String
name|dbPath
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dbMap
operator|.
name|containsKey
argument_list|(
name|dbPath
argument_list|)
condition|)
block|{
name|RefCountedDB
name|refDB
init|=
name|dbMap
operator|.
name|get
argument_list|(
name|dbPath
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|refDB
operator|.
name|close
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|dbMap
operator|.
name|remove
argument_list|(
name|dbPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getPipeline (String dbPath, long blockId)
name|Pipeline
name|getPipeline
parameter_list|(
name|String
name|dbPath
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|Pipeline
index|[]
name|containerList
init|=
name|pipelineMap
operator|.
name|get
argument_list|(
name|dbPath
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|containerList
argument_list|)
expr_stmt|;
name|int
name|containerIdx
init|=
operator|(
name|int
operator|)
name|blockId
operator|%
name|containerList
operator|.
name|length
decl_stmt|;
name|long
name|cBlockIndex
init|=
name|Longs
operator|.
name|fromByteArray
argument_list|(
name|containerList
index|[
name|containerIdx
index|]
operator|.
name|getData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cBlockIndex
operator|>
literal|0
condition|)
block|{
comment|// This catches the case when we get a wrong container in the ordering
comment|// of the containers.
name|Preconditions
operator|.
name|checkState
argument_list|(
name|containerIdx
operator|%
name|cBlockIndex
operator|==
literal|0
argument_list|,
literal|"The container ID computed should match with the container index "
operator|+
literal|"returned from cBlock Server."
argument_list|)
expr_stmt|;
block|}
return|return
name|containerList
index|[
name|containerIdx
index|]
return|;
block|}
DECL|method|incFinishCount (String fileName)
specifier|public
name|void
name|incFinishCount
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|finishCountMap
operator|.
name|containsKey
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No record for such file:"
operator|+
name|fileName
argument_list|)
expr_stmt|;
return|return;
block|}
name|finishCountMap
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
operator|.
name|incCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|finishCountMap
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
operator|.
name|isFileDeleted
argument_list|()
condition|)
block|{
name|finishCountMap
operator|.
name|remove
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * When an object implementing interface<code>Runnable</code> is used    * to create a thread, starting the thread causes the object's    *<code>run</code> method to be called in that separately executing    * thread.    *<p>    * The general contract of the method<code>run</code> is that it may    * take any action whatsoever.    *    * @see Thread#run()    */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|shutdown
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
name|Message
name|message
init|=
name|messageQueue
operator|.
name|take
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got message to process -- DB Path : {} , FileName; {}"
argument_list|,
name|message
operator|.
name|getDbPath
argument_list|()
argument_list|,
name|message
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|fullPath
init|=
name|Paths
operator|.
name|get
argument_list|(
name|message
operator|.
name|getDbPath
argument_list|()
argument_list|,
name|message
operator|.
name|getFileName
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
index|[]
name|fileNameParts
init|=
name|message
operator|.
name|getFileName
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|fileNameParts
operator|.
name|length
operator|>
literal|1
argument_list|)
expr_stmt|;
name|String
name|fileType
init|=
name|fileNameParts
index|[
literal|0
index|]
decl_stmt|;
name|boolean
name|isDirtyLogFile
init|=
name|fileType
operator|.
name|equalsIgnoreCase
argument_list|(
name|AsyncBlockWriter
operator|.
name|DIRTY_LOG_PREFIX
argument_list|)
decl_stmt|;
name|ReadableByteChannel
name|fileChannel
init|=
operator|new
name|FileInputStream
argument_list|(
name|fullPath
argument_list|)
operator|.
name|getChannel
argument_list|()
decl_stmt|;
comment|// TODO: We can batch and unique the IOs here. First getting the code
comment|// to work, we will add those later.
name|int
name|bytesRead
init|=
name|fileChannel
operator|.
name|read
argument_list|(
name|blockIDBuffer
argument_list|)
decl_stmt|;
name|fileChannel
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Read blockID log of size: {} position {} remaining {}"
argument_list|,
name|bytesRead
argument_list|,
name|blockIDBuffer
operator|.
name|position
argument_list|()
argument_list|,
name|blockIDBuffer
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
comment|// current position of in the buffer in bytes, divided by number of
comment|// bytes per long (which is calculated by number of bits per long
comment|// divided by number of bits per byte) gives the number of blocks
name|int
name|blockCount
init|=
name|blockIDBuffer
operator|.
name|position
argument_list|()
operator|/
operator|(
name|Long
operator|.
name|SIZE
operator|/
name|Byte
operator|.
name|SIZE
operator|)
decl_stmt|;
if|if
condition|(
name|isDirtyLogFile
condition|)
block|{
name|getTargetMetrics
argument_list|()
operator|.
name|incNumBytesDirtyLogRead
argument_list|(
name|bytesRead
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getTargetMetrics
argument_list|()
operator|.
name|incNumBytesRetryLogRead
argument_list|(
name|bytesRead
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finishCountMap
operator|.
name|containsKey
argument_list|(
name|message
operator|.
name|getFileName
argument_list|()
argument_list|)
condition|)
block|{
comment|// In theory this should never happen. But if it happened,
comment|// we need to know it...
name|getTargetMetrics
argument_list|()
operator|.
name|incNumIllegalDirtyLogFiles
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Adding DirtyLog file again {} current count {} new {}"
argument_list|,
name|message
operator|.
name|getFileName
argument_list|()
argument_list|,
name|finishCountMap
operator|.
name|get
argument_list|(
name|message
operator|.
name|getFileName
argument_list|()
argument_list|)
operator|.
name|expectedCount
argument_list|,
name|blockCount
argument_list|)
expr_stmt|;
block|}
name|finishCountMap
operator|.
name|put
argument_list|(
name|message
operator|.
name|getFileName
argument_list|()
argument_list|,
operator|new
name|FinishCounter
argument_list|(
name|blockCount
argument_list|,
name|message
operator|.
name|getDbPath
argument_list|()
argument_list|,
name|message
operator|.
name|getFileName
argument_list|()
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// should be flip instead of rewind, because we also need to make sure
comment|// the end position is correct.
name|blockIDBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Remaining blocks count {} and {}"
argument_list|,
name|blockIDBuffer
operator|.
name|remaining
argument_list|()
argument_list|,
name|blockCount
argument_list|)
expr_stmt|;
while|while
condition|(
name|blockIDBuffer
operator|.
name|remaining
argument_list|()
operator|>=
operator|(
name|Long
operator|.
name|SIZE
operator|/
name|Byte
operator|.
name|SIZE
operator|)
condition|)
block|{
name|long
name|blockID
init|=
name|blockIDBuffer
operator|.
name|getLong
argument_list|()
decl_stmt|;
name|int
name|retryCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isDirtyLogFile
condition|)
block|{
name|getTargetMetrics
argument_list|()
operator|.
name|incNumDirtyLogBlockRead
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|getTargetMetrics
argument_list|()
operator|.
name|incNumRetryLogBlockRead
argument_list|()
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|fileNameParts
operator|.
name|length
operator|==
literal|4
argument_list|)
expr_stmt|;
name|retryCount
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|fileNameParts
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|LogicalBlock
name|block
init|=
operator|new
name|DiskBlock
argument_list|(
name|blockID
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|BlockWriterTask
name|blockWriterTask
init|=
operator|new
name|BlockWriterTask
argument_list|(
name|block
argument_list|,
name|this
argument_list|,
name|message
operator|.
name|getDbPath
argument_list|()
argument_list|,
name|retryCount
argument_list|,
name|message
operator|.
name|getFileName
argument_list|()
argument_list|,
name|maxRetryCount
argument_list|)
decl_stmt|;
name|threadPoolExecutor
operator|.
name|submit
argument_list|(
name|blockWriterTask
argument_list|)
expr_stmt|;
block|}
name|blockIDBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ContainerCacheFlusher is interrupted."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to find the dirty blocks file. This will cause "
operator|+
literal|"data errors. Please stop using this volume."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to read the dirty blocks file. This will cause "
operator|+
literal|"data errors. Please stop using this volume."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Generic exception."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Exiting flusher"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Keeps a Reference counted DB that we close only when the total Reference    * has gone to zero.    */
DECL|class|RefCountedDB
specifier|private
specifier|static
class|class
name|RefCountedDB
block|{
DECL|field|db
specifier|private
name|LevelDBStore
name|db
decl_stmt|;
DECL|field|refcount
specifier|private
name|AtomicInteger
name|refcount
decl_stmt|;
DECL|field|dbPath
specifier|private
name|String
name|dbPath
decl_stmt|;
comment|/**      * RefCountedDB DB ctor.      *      * @param dbPath - DB path.      * @param db - LevelDBStore db      */
DECL|method|RefCountedDB (String dbPath, LevelDBStore db)
name|RefCountedDB
parameter_list|(
name|String
name|dbPath
parameter_list|,
name|LevelDBStore
name|db
parameter_list|)
block|{
name|this
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|this
operator|.
name|refcount
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|dbPath
operator|=
name|dbPath
expr_stmt|;
block|}
comment|/**      * close the DB if possible.      */
DECL|method|close ()
specifier|public
name|int
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|count
init|=
name|this
operator|.
name|refcount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing the LevelDB. {} "
argument_list|,
name|this
operator|.
name|dbPath
argument_list|)
expr_stmt|;
name|db
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
DECL|method|open ()
specifier|public
name|void
name|open
parameter_list|()
block|{
name|this
operator|.
name|refcount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * The message held in processing queue.    */
DECL|class|Message
specifier|private
specifier|static
class|class
name|Message
block|{
DECL|field|dbPath
specifier|private
name|String
name|dbPath
decl_stmt|;
DECL|field|fileName
specifier|private
name|String
name|fileName
decl_stmt|;
comment|/**      * A message that holds the info about which path dirty blocks log and      * which path contains db.      *      * @param dbPath      * @param fileName      */
DECL|method|Message (String dbPath, String fileName)
name|Message
parameter_list|(
name|String
name|dbPath
parameter_list|,
name|String
name|fileName
parameter_list|)
block|{
name|this
operator|.
name|dbPath
operator|=
name|dbPath
expr_stmt|;
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
DECL|method|getDbPath ()
specifier|public
name|String
name|getDbPath
parameter_list|()
block|{
return|return
name|dbPath
return|;
block|}
DECL|method|setDbPath (String dbPath)
specifier|public
name|void
name|setDbPath
parameter_list|(
name|String
name|dbPath
parameter_list|)
block|{
name|this
operator|.
name|dbPath
operator|=
name|dbPath
expr_stmt|;
block|}
DECL|method|getFileName ()
specifier|public
name|String
name|getFileName
parameter_list|()
block|{
return|return
name|fileName
return|;
block|}
DECL|method|setFileName (String fileName)
specifier|public
name|void
name|setFileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
block|}
DECL|class|FinishCounter
specifier|private
specifier|static
class|class
name|FinishCounter
block|{
DECL|field|expectedCount
specifier|private
specifier|final
name|long
name|expectedCount
decl_stmt|;
DECL|field|dbPath
specifier|private
specifier|final
name|String
name|dbPath
decl_stmt|;
DECL|field|dirtyLogPath
specifier|private
specifier|final
name|String
name|dirtyLogPath
decl_stmt|;
DECL|field|currentCount
specifier|private
specifier|final
name|AtomicLong
name|currentCount
decl_stmt|;
DECL|field|fileDeleted
specifier|private
name|AtomicBoolean
name|fileDeleted
decl_stmt|;
DECL|field|flusher
specifier|private
specifier|final
name|ContainerCacheFlusher
name|flusher
decl_stmt|;
DECL|method|FinishCounter (long expectedCount, String dbPath, String dirtyLogPath, ContainerCacheFlusher flusher)
name|FinishCounter
parameter_list|(
name|long
name|expectedCount
parameter_list|,
name|String
name|dbPath
parameter_list|,
name|String
name|dirtyLogPath
parameter_list|,
name|ContainerCacheFlusher
name|flusher
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|expectedCount
operator|=
name|expectedCount
expr_stmt|;
name|this
operator|.
name|dbPath
operator|=
name|dbPath
expr_stmt|;
name|this
operator|.
name|dirtyLogPath
operator|=
name|dirtyLogPath
expr_stmt|;
name|this
operator|.
name|currentCount
operator|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileDeleted
operator|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|flusher
operator|=
name|flusher
expr_stmt|;
block|}
DECL|method|isFileDeleted ()
specifier|public
name|boolean
name|isFileDeleted
parameter_list|()
block|{
return|return
name|fileDeleted
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|incCount ()
specifier|public
name|void
name|incCount
parameter_list|()
block|{
name|long
name|count
init|=
name|this
operator|.
name|currentCount
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>=
name|expectedCount
condition|)
block|{
name|String
name|filePath
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s/%s"
argument_list|,
name|dbPath
argument_list|,
name|dirtyLogPath
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleting {} with count {} {}"
argument_list|,
name|filePath
argument_list|,
name|count
argument_list|,
name|expectedCount
argument_list|)
expr_stmt|;
try|try
block|{
name|Path
name|path
init|=
name|Paths
operator|.
name|get
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|Files
operator|.
name|delete
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|// the following part tries to remove the directory if it is empty
comment|// but not sufficient, because the .db directory still exists....
comment|// TODO how to handle the .db directory?
comment|/*Path parent = path.getParent();           if (parent.toFile().listFiles().length == 0) {             Files.delete(parent);           }*/
name|fileDeleted
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|flusher
operator|.
name|getTargetMetrics
argument_list|()
operator|.
name|incNumFailedDirtyLogFileDeletes
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Error deleting dirty log file:"
operator|+
name|filePath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

