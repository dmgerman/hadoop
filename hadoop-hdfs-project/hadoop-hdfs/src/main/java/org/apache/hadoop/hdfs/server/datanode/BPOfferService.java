begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnregisteredNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocolPB
operator|.
name|DatanodeProtocolClientSideTranslatorPB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|IncorrectVersionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BalancerBandwidthCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DisallowedDatanodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|FinalizeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|KeyUpdateCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReceivedDeletedBlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageBlockReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReceivedDeletedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|UpgradeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * A thread per namenode to perform:  *<ul>  *<li> Pre-registration handshake with namenode</li>  *<li> Registration with namenode</li>  *<li> Send periodic heartbeats to the namenode</li>  *<li> Handle commands received from the namenode</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BPOfferService
class|class
name|BPOfferService
implements|implements
name|Runnable
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|nnAddr
specifier|final
name|InetSocketAddress
name|nnAddr
decl_stmt|;
comment|/**    * Information about the namespace that this service    * is registering with. This is assigned after    * the first phase of the handshake.    */
DECL|field|bpNSInfo
name|NamespaceInfo
name|bpNSInfo
decl_stmt|;
comment|/**    * The registration information for this block pool.    * This is assigned after the second phase of the    * handshake.    */
DECL|field|bpRegistration
name|DatanodeRegistration
name|bpRegistration
decl_stmt|;
DECL|field|lastBlockReport
name|long
name|lastBlockReport
init|=
literal|0
decl_stmt|;
DECL|field|lastDeletedReport
name|long
name|lastDeletedReport
init|=
literal|0
decl_stmt|;
DECL|field|resetBlockReportTime
name|boolean
name|resetBlockReportTime
init|=
literal|true
decl_stmt|;
DECL|field|bpThread
name|Thread
name|bpThread
decl_stmt|;
DECL|field|bpNamenode
name|DatanodeProtocolClientSideTranslatorPB
name|bpNamenode
decl_stmt|;
DECL|field|lastHeartbeat
specifier|private
name|long
name|lastHeartbeat
init|=
literal|0
decl_stmt|;
DECL|field|initialized
specifier|private
specifier|volatile
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
DECL|field|receivedAndDeletedBlockList
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|ReceivedDeletedBlockInfo
argument_list|>
name|receivedAndDeletedBlockList
init|=
operator|new
name|LinkedList
argument_list|<
name|ReceivedDeletedBlockInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|pendingReceivedRequests
specifier|private
specifier|volatile
name|int
name|pendingReceivedRequests
init|=
literal|0
decl_stmt|;
DECL|field|shouldServiceRun
specifier|private
specifier|volatile
name|boolean
name|shouldServiceRun
init|=
literal|true
decl_stmt|;
DECL|field|upgradeManager
name|UpgradeManagerDatanode
name|upgradeManager
init|=
literal|null
decl_stmt|;
DECL|field|dn
specifier|private
specifier|final
name|DataNode
name|dn
decl_stmt|;
DECL|field|dnConf
specifier|private
specifier|final
name|DNConf
name|dnConf
decl_stmt|;
DECL|method|BPOfferService (InetSocketAddress nnAddr, DataNode dn)
name|BPOfferService
parameter_list|(
name|InetSocketAddress
name|nnAddr
parameter_list|,
name|DataNode
name|dn
parameter_list|)
block|{
name|this
operator|.
name|dn
operator|=
name|dn
expr_stmt|;
name|this
operator|.
name|nnAddr
operator|=
name|nnAddr
expr_stmt|;
name|this
operator|.
name|dnConf
operator|=
name|dn
operator|.
name|getDnConf
argument_list|()
expr_stmt|;
block|}
comment|/**    * returns true if BP thread has completed initialization of storage    * and has registered with the corresponding namenode    * @return true if initialized    */
DECL|method|isInitialized ()
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|initialized
return|;
block|}
DECL|method|isAlive ()
specifier|public
name|boolean
name|isAlive
parameter_list|()
block|{
return|return
name|shouldServiceRun
operator|&&
name|bpThread
operator|.
name|isAlive
argument_list|()
return|;
block|}
DECL|method|getBlockPoolId ()
specifier|public
name|String
name|getBlockPoolId
parameter_list|()
block|{
if|if
condition|(
name|bpNSInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|bpNSInfo
operator|.
name|getBlockPoolID
argument_list|()
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block pool ID needed, but service not yet registered with NN"
argument_list|,
operator|new
name|Exception
argument_list|(
literal|"trace"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
DECL|method|getNamespaceInfo ()
specifier|public
name|NamespaceInfo
name|getNamespaceInfo
parameter_list|()
block|{
return|return
name|bpNSInfo
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|bpNSInfo
operator|==
literal|null
condition|)
block|{
comment|// If we haven't yet connected to our NN, we don't yet know our
comment|// own block pool ID.
comment|// If _none_ of the block pools have connected yet, we don't even
comment|// know the storage ID of this DN.
name|String
name|storageId
init|=
name|dn
operator|.
name|getStorageId
argument_list|()
decl_stmt|;
if|if
condition|(
name|storageId
operator|==
literal|null
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|storageId
argument_list|)
condition|)
block|{
name|storageId
operator|=
literal|"unknown"
expr_stmt|;
block|}
return|return
literal|"Block pool<registering> (storage id "
operator|+
name|storageId
operator|+
literal|") connecting to "
operator|+
name|nnAddr
return|;
block|}
else|else
block|{
return|return
literal|"Block pool "
operator|+
name|getBlockPoolId
argument_list|()
operator|+
literal|" (storage id "
operator|+
name|dn
operator|.
name|getStorageId
argument_list|()
operator|+
literal|") registered with "
operator|+
name|nnAddr
return|;
block|}
block|}
DECL|method|getNNSocketAddress ()
name|InetSocketAddress
name|getNNSocketAddress
parameter_list|()
block|{
return|return
name|nnAddr
return|;
block|}
comment|/**    * Used to inject a spy NN in the unit tests.    */
annotation|@
name|VisibleForTesting
DECL|method|setNameNode (DatanodeProtocolClientSideTranslatorPB dnProtocol)
name|void
name|setNameNode
parameter_list|(
name|DatanodeProtocolClientSideTranslatorPB
name|dnProtocol
parameter_list|)
block|{
name|bpNamenode
operator|=
name|dnProtocol
expr_stmt|;
block|}
comment|/**    * Perform the first part of the handshake with the NameNode.    * This calls<code>versionRequest</code> to determine the NN's    * namespace and version info. It automatically retries until    * the NN responds or the DN is shutting down.    *     * @return the NamespaceInfo    * @throws IncorrectVersionException if the remote NN does not match    * this DN's version    */
DECL|method|retrieveNamespaceInfo ()
name|NamespaceInfo
name|retrieveNamespaceInfo
parameter_list|()
throws|throws
name|IncorrectVersionException
block|{
name|NamespaceInfo
name|nsInfo
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
name|nsInfo
operator|=
name|bpNamenode
operator|.
name|versionRequest
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|+
literal|" received versionRequest response: "
operator|+
name|nsInfo
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
comment|// namenode is busy
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// namenode is not available
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
block|}
comment|// try again in a second
name|sleepAndLogInterrupts
argument_list|(
literal|5000
argument_list|,
literal|"requesting version info from NN"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nsInfo
operator|!=
literal|null
condition|)
block|{
name|checkNNVersion
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|nsInfo
return|;
block|}
DECL|method|checkNNVersion (NamespaceInfo nsInfo)
specifier|private
name|void
name|checkNNVersion
parameter_list|(
name|NamespaceInfo
name|nsInfo
parameter_list|)
throws|throws
name|IncorrectVersionException
block|{
comment|// build and layout versions should match
name|String
name|nsBuildVer
init|=
name|nsInfo
operator|.
name|getBuildVersion
argument_list|()
decl_stmt|;
name|String
name|stBuildVer
init|=
name|Storage
operator|.
name|getBuildVersion
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nsBuildVer
operator|.
name|equals
argument_list|(
name|stBuildVer
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Data-node and name-node Build versions must be the same. "
operator|+
literal|"Namenode build version: "
operator|+
name|nsBuildVer
operator|+
literal|"Datanode "
operator|+
literal|"build version: "
operator|+
name|stBuildVer
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IncorrectVersionException
argument_list|(
name|nsBuildVer
argument_list|,
literal|"namenode"
argument_list|,
name|stBuildVer
argument_list|)
throw|;
block|}
if|if
condition|(
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
operator|!=
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Data-node and name-node layout versions must be the same."
operator|+
literal|" Expected: "
operator|+
name|HdfsConstants
operator|.
name|LAYOUT_VERSION
operator|+
literal|" actual "
operator|+
name|bpNSInfo
operator|.
name|getLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IncorrectVersionException
argument_list|(
name|bpNSInfo
operator|.
name|getLayoutVersion
argument_list|()
argument_list|,
literal|"namenode"
argument_list|)
throw|;
block|}
block|}
DECL|method|connectToNNAndHandshake ()
specifier|private
name|void
name|connectToNNAndHandshake
parameter_list|()
throws|throws
name|IOException
block|{
comment|// get NN proxy
name|bpNamenode
operator|=
name|dn
operator|.
name|connectToNN
argument_list|(
name|nnAddr
argument_list|)
expr_stmt|;
comment|// First phase of the handshake with NN - get the namespace
comment|// info.
name|bpNSInfo
operator|=
name|retrieveNamespaceInfo
argument_list|()
expr_stmt|;
comment|// Now that we know the namespace ID, etc, we can pass this to the DN.
comment|// The DN can now initialize its local storage if we are the
comment|// first BP to handshake, etc.
name|dn
operator|.
name|initBlockPool
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Second phase of the handshake with the NN.
name|register
argument_list|()
expr_stmt|;
block|}
comment|/**    * This methods  arranges for the data node to send the block report at     * the next heartbeat.    */
DECL|method|scheduleBlockReport (long delay)
name|void
name|scheduleBlockReport
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
block|{
comment|// send BR after random delay
name|lastBlockReport
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
operator|(
name|dnConf
operator|.
name|blockReportInterval
operator|-
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|delay
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// send at next heartbeat
name|lastBlockReport
operator|=
name|lastHeartbeat
operator|-
name|dnConf
operator|.
name|blockReportInterval
expr_stmt|;
block|}
name|resetBlockReportTime
operator|=
literal|true
expr_stmt|;
comment|// reset future BRs for randomness
block|}
DECL|method|reportBadBlocks (ExtendedBlock block)
name|void
name|reportBadBlocks
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|DatanodeInfo
index|[]
name|dnArr
init|=
block|{
operator|new
name|DatanodeInfo
argument_list|(
name|bpRegistration
argument_list|)
block|}
decl_stmt|;
name|LocatedBlock
index|[]
name|blocks
init|=
block|{
operator|new
name|LocatedBlock
argument_list|(
name|block
argument_list|,
name|dnArr
argument_list|)
block|}
decl_stmt|;
try|try
block|{
name|bpNamenode
operator|.
name|reportBadBlocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|/* One common reason is that NameNode could be in safe mode.        * Should we keep on retrying in that case?        */
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to report bad block "
operator|+
name|block
operator|+
literal|" to namenode : "
operator|+
literal|" Exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Report received blocks and delete hints to the Namenode    *     * @throws IOException    */
DECL|method|reportReceivedDeletedBlocks ()
specifier|private
name|void
name|reportReceivedDeletedBlocks
parameter_list|()
throws|throws
name|IOException
block|{
comment|// check if there are newly received blocks
name|ReceivedDeletedBlockInfo
index|[]
name|receivedAndDeletedBlockArray
init|=
literal|null
decl_stmt|;
name|int
name|currentReceivedRequestsCounter
decl_stmt|;
synchronized|synchronized
init|(
name|receivedAndDeletedBlockList
init|)
block|{
name|currentReceivedRequestsCounter
operator|=
name|pendingReceivedRequests
expr_stmt|;
name|int
name|numBlocks
init|=
name|receivedAndDeletedBlockList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBlocks
operator|>
literal|0
condition|)
block|{
comment|//
comment|// Send newly-received and deleted blockids to namenode
comment|//
name|receivedAndDeletedBlockArray
operator|=
name|receivedAndDeletedBlockList
operator|.
name|toArray
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
index|[
name|numBlocks
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|receivedAndDeletedBlockArray
operator|!=
literal|null
condition|)
block|{
name|StorageReceivedDeletedBlocks
index|[]
name|report
init|=
block|{
operator|new
name|StorageReceivedDeletedBlocks
argument_list|(
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|receivedAndDeletedBlockArray
argument_list|)
block|}
decl_stmt|;
name|bpNamenode
operator|.
name|blockReceivedAndDeleted
argument_list|(
name|bpRegistration
argument_list|,
name|getBlockPoolId
argument_list|()
argument_list|,
name|report
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|receivedAndDeletedBlockList
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|receivedAndDeletedBlockArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|receivedAndDeletedBlockList
operator|.
name|remove
argument_list|(
name|receivedAndDeletedBlockArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|pendingReceivedRequests
operator|-=
name|currentReceivedRequestsCounter
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Informing the name node could take a long long time! Should we wait    * till namenode is informed before responding with success to the    * client? For now we don't.    */
DECL|method|notifyNamenodeReceivedBlock (ExtendedBlock block, String delHint)
name|void
name|notifyNamenodeReceivedBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|delHint
parameter_list|)
block|{
if|if
condition|(
name|block
operator|==
literal|null
operator|||
name|delHint
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|block
operator|==
literal|null
condition|?
literal|"Block is null"
else|:
literal|"delHint is null"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|.
name|equals
argument_list|(
name|getBlockPoolId
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"BlockPool mismatch "
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" vs. "
operator|+
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|receivedAndDeletedBlockList
init|)
block|{
name|receivedAndDeletedBlockList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|delHint
argument_list|)
argument_list|)
expr_stmt|;
name|pendingReceivedRequests
operator|++
expr_stmt|;
name|receivedAndDeletedBlockList
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|notifyNamenodeDeletedBlock (ExtendedBlock block)
name|void
name|notifyNamenodeDeletedBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Block is null"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|.
name|equals
argument_list|(
name|getBlockPoolId
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"BlockPool mismatch "
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" vs. "
operator|+
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|receivedAndDeletedBlockList
init|)
block|{
name|receivedAndDeletedBlockList
operator|.
name|add
argument_list|(
operator|new
name|ReceivedDeletedBlockInfo
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|ReceivedDeletedBlockInfo
operator|.
name|TODELETE_HINT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Report the list blocks to the Namenode    * @throws IOException    */
DECL|method|blockReport ()
name|DatanodeCommand
name|blockReport
parameter_list|()
throws|throws
name|IOException
block|{
comment|// send block report if timer has expired.
name|DatanodeCommand
name|cmd
init|=
literal|null
decl_stmt|;
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|startTime
operator|-
name|lastBlockReport
operator|>
name|dnConf
operator|.
name|blockReportInterval
condition|)
block|{
comment|// Create block report
name|long
name|brCreateStartTime
init|=
name|now
argument_list|()
decl_stmt|;
name|BlockListAsLongs
name|bReport
init|=
name|dn
operator|.
name|data
operator|.
name|getBlockReport
argument_list|(
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
comment|// Send block report
name|long
name|brSendStartTime
init|=
name|now
argument_list|()
decl_stmt|;
name|StorageBlockReport
index|[]
name|report
init|=
block|{
operator|new
name|StorageBlockReport
argument_list|(
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|bReport
operator|.
name|getBlockListAsLongs
argument_list|()
argument_list|)
block|}
decl_stmt|;
name|cmd
operator|=
name|bpNamenode
operator|.
name|blockReport
argument_list|(
name|bpRegistration
argument_list|,
name|getBlockPoolId
argument_list|()
argument_list|,
name|report
argument_list|)
expr_stmt|;
comment|// Log the block report processing stats from Datanode perspective
name|long
name|brSendCost
init|=
name|now
argument_list|()
operator|-
name|brSendStartTime
decl_stmt|;
name|long
name|brCreateCost
init|=
name|brSendStartTime
operator|-
name|brCreateStartTime
decl_stmt|;
name|dn
operator|.
name|metrics
operator|.
name|addBlockReport
argument_list|(
name|brSendCost
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"BlockReport of "
operator|+
name|bReport
operator|.
name|getNumberOfBlocks
argument_list|()
operator|+
literal|" blocks took "
operator|+
name|brCreateCost
operator|+
literal|" msec to generate and "
operator|+
name|brSendCost
operator|+
literal|" msecs for RPC and NN processing"
argument_list|)
expr_stmt|;
comment|// If we have sent the first block report, then wait a random
comment|// time before we start the periodic block reports.
if|if
condition|(
name|resetBlockReportTime
condition|)
block|{
name|lastBlockReport
operator|=
name|startTime
operator|-
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|dnConf
operator|.
name|blockReportInterval
argument_list|)
argument_list|)
expr_stmt|;
name|resetBlockReportTime
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|/* say the last block report was at 8:20:14. The current report          * should have started around 9:20:14 (default 1 hour interval).          * If current time is :          *   1) normal like 9:20:18, next report should be at 10:20:14          *   2) unexpected like 11:35:43, next report should be at 12:20:14          */
name|lastBlockReport
operator|+=
operator|(
name|now
argument_list|()
operator|-
name|lastBlockReport
operator|)
operator|/
name|dnConf
operator|.
name|blockReportInterval
operator|*
name|dnConf
operator|.
name|blockReportInterval
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"sent block report, processed command:"
operator|+
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
name|cmd
return|;
block|}
DECL|method|sendHeartBeat ()
name|DatanodeCommand
index|[]
name|sendHeartBeat
parameter_list|()
throws|throws
name|IOException
block|{
comment|// reports number of failed volumes
name|StorageReport
index|[]
name|report
init|=
block|{
operator|new
name|StorageReport
argument_list|(
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
argument_list|,
literal|false
argument_list|,
name|dn
operator|.
name|data
operator|.
name|getCapacity
argument_list|()
argument_list|,
name|dn
operator|.
name|data
operator|.
name|getDfsUsed
argument_list|()
argument_list|,
name|dn
operator|.
name|data
operator|.
name|getRemaining
argument_list|()
argument_list|,
name|dn
operator|.
name|data
operator|.
name|getBlockPoolUsed
argument_list|(
name|getBlockPoolId
argument_list|()
argument_list|)
argument_list|)
block|}
decl_stmt|;
return|return
name|bpNamenode
operator|.
name|sendHeartbeat
argument_list|(
name|bpRegistration
argument_list|,
name|report
argument_list|,
name|dn
operator|.
name|xmitsInProgress
operator|.
name|get
argument_list|()
argument_list|,
name|dn
operator|.
name|getXceiverCount
argument_list|()
argument_list|,
name|dn
operator|.
name|data
operator|.
name|getNumFailedVolumes
argument_list|()
argument_list|)
return|;
block|}
comment|//This must be called only by blockPoolManager
DECL|method|start ()
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
operator|(
name|bpThread
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bpThread
operator|.
name|isAlive
argument_list|()
operator|)
condition|)
block|{
comment|//Thread is started already
return|return;
block|}
name|bpThread
operator|=
operator|new
name|Thread
argument_list|(
name|this
argument_list|,
name|formatThreadName
argument_list|()
argument_list|)
expr_stmt|;
name|bpThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// needed for JUnit testing
name|bpThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|formatThreadName ()
specifier|private
name|String
name|formatThreadName
parameter_list|()
block|{
name|Collection
argument_list|<
name|URI
argument_list|>
name|dataDirs
init|=
name|DataNode
operator|.
name|getStorageDirs
argument_list|(
name|dn
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
return|return
literal|"DataNode: ["
operator|+
name|StringUtils
operator|.
name|uriToString
argument_list|(
name|dataDirs
operator|.
name|toArray
argument_list|(
operator|new
name|URI
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|+
literal|"] "
operator|+
literal|" heartbeating to "
operator|+
name|nnAddr
return|;
block|}
comment|//This must be called only by blockPoolManager.
DECL|method|stop ()
name|void
name|stop
parameter_list|()
block|{
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|bpThread
operator|!=
literal|null
condition|)
block|{
name|bpThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|//This must be called only by blockPoolManager
DECL|method|join ()
name|void
name|join
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|bpThread
operator|!=
literal|null
condition|)
block|{
name|bpThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{ }
block|}
comment|//Cleanup method to be called by current thread before exiting.
DECL|method|cleanUp ()
specifier|private
specifier|synchronized
name|void
name|cleanUp
parameter_list|()
block|{
if|if
condition|(
name|upgradeManager
operator|!=
literal|null
condition|)
name|upgradeManager
operator|.
name|shutdownUpgrade
argument_list|()
expr_stmt|;
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|bpNamenode
argument_list|)
expr_stmt|;
name|dn
operator|.
name|shutdownBlockPool
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Main loop for each BP thread. Run until shutdown,    * forever calling remote NameNode functions.    */
DECL|method|offerService ()
specifier|private
name|void
name|offerService
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"For namenode "
operator|+
name|nnAddr
operator|+
literal|" using DELETEREPORT_INTERVAL of "
operator|+
name|dnConf
operator|.
name|deleteReportInterval
operator|+
literal|" msec "
operator|+
literal|" BLOCKREPORT_INTERVAL of "
operator|+
name|dnConf
operator|.
name|blockReportInterval
operator|+
literal|"msec"
operator|+
literal|" Initial delay: "
operator|+
name|dnConf
operator|.
name|initialBlockReportDelay
operator|+
literal|"msec"
operator|+
literal|"; heartBeatInterval="
operator|+
name|dnConf
operator|.
name|heartBeatInterval
argument_list|)
expr_stmt|;
comment|//
comment|// Now loop for a long time....
comment|//
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
comment|//
comment|// Every so often, send heartbeat or block-report
comment|//
if|if
condition|(
name|startTime
operator|-
name|lastHeartbeat
operator|>
name|dnConf
operator|.
name|heartBeatInterval
condition|)
block|{
comment|//
comment|// All heartbeat messages include following info:
comment|// -- Datanode name
comment|// -- data transfer port
comment|// -- Total capacity
comment|// -- Bytes remaining
comment|//
name|lastHeartbeat
operator|=
name|startTime
expr_stmt|;
if|if
condition|(
operator|!
name|dn
operator|.
name|areHeartbeatsDisabledForTests
argument_list|()
condition|)
block|{
name|DatanodeCommand
index|[]
name|cmds
init|=
name|sendHeartBeat
argument_list|()
decl_stmt|;
name|dn
operator|.
name|metrics
operator|.
name|addHeartbeat
argument_list|(
name|now
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
name|long
name|startProcessCommands
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|processCommand
argument_list|(
name|cmds
argument_list|)
condition|)
continue|continue;
name|long
name|endProcessCommands
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|endProcessCommands
operator|-
name|startProcessCommands
operator|>
literal|2000
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Took "
operator|+
operator|(
name|endProcessCommands
operator|-
name|startProcessCommands
operator|)
operator|+
literal|"ms to process "
operator|+
name|cmds
operator|.
name|length
operator|+
literal|" commands from NN"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pendingReceivedRequests
operator|>
literal|0
operator|||
operator|(
name|startTime
operator|-
name|lastDeletedReport
operator|>
name|dnConf
operator|.
name|deleteReportInterval
operator|)
condition|)
block|{
name|reportReceivedDeletedBlocks
argument_list|()
expr_stmt|;
name|lastDeletedReport
operator|=
name|startTime
expr_stmt|;
block|}
name|DatanodeCommand
name|cmd
init|=
name|blockReport
argument_list|()
decl_stmt|;
name|processCommand
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|// Now safe to start scanning the block pool
if|if
condition|(
name|dn
operator|.
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|dn
operator|.
name|blockScanner
operator|.
name|addBlockPool
argument_list|(
name|this
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// There is no work to do;  sleep until hearbeat timer elapses,
comment|// or work arrives, and then iterate again.
comment|//
name|long
name|waitTime
init|=
name|dnConf
operator|.
name|heartBeatInterval
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastHeartbeat
operator|)
decl_stmt|;
synchronized|synchronized
init|(
name|receivedAndDeletedBlockList
init|)
block|{
if|if
condition|(
name|waitTime
operator|>
literal|0
operator|&&
name|pendingReceivedRequests
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|receivedAndDeletedBlockList
operator|.
name|wait
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"BPOfferService for "
operator|+
name|this
operator|+
literal|" interrupted"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// synchronized
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
name|String
name|reClass
init|=
name|re
operator|.
name|getClassName
argument_list|()
decl_stmt|;
if|if
condition|(
name|UnregisteredNodeException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
operator|||
name|DisallowedDatanodeException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
operator|||
name|IncorrectVersionException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|+
literal|" is shutting down"
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"RemoteException in offerService"
argument_list|,
name|re
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|sleepTime
init|=
name|Math
operator|.
name|min
argument_list|(
literal|1000
argument_list|,
name|dnConf
operator|.
name|heartBeatInterval
argument_list|)
decl_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in offerService"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// while (shouldRun())
block|}
comment|// offerService
comment|/**    * Register one bp with the corresponding NameNode    *<p>    * The bpDatanode needs to register with the namenode on startup in order    * 1) to report which storage it is serving now and     * 2) to receive a registrationID    *      * issued by the namenode to recognize registered datanodes.    *     * @see FSNamesystem#registerDatanode(DatanodeRegistration)    * @throws IOException    */
DECL|method|register ()
name|void
name|register
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|bpNSInfo
operator|!=
literal|null
argument_list|,
literal|"register() should be called after handshake()"
argument_list|)
expr_stmt|;
comment|// The handshake() phase loaded the block pool storage
comment|// off disk - so update the bpRegistration object from that info
name|bpRegistration
operator|=
name|dn
operator|.
name|createBPRegistration
argument_list|(
name|bpNSInfo
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|+
literal|" beginning handshake with NN"
argument_list|)
expr_stmt|;
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
comment|// Use returned registration from namenode with updated machine name.
name|bpRegistration
operator|=
name|bpNamenode
operator|.
name|registerDatanode
argument_list|(
name|bpRegistration
argument_list|,
operator|new
name|DatanodeStorage
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
comment|// namenode is busy
name|LOG
operator|.
name|info
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
name|sleepAndLogInterrupts
argument_list|(
literal|1000
argument_list|,
literal|"connecting to server"
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Block pool "
operator|+
name|this
operator|+
literal|" successfully registered with NN"
argument_list|)
expr_stmt|;
name|dn
operator|.
name|bpRegistrationSucceeded
argument_list|(
name|bpRegistration
argument_list|,
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
comment|// random short delay - helps scatter the BR from all DNs
name|scheduleBlockReport
argument_list|(
name|dnConf
operator|.
name|initialBlockReportDelay
argument_list|)
expr_stmt|;
block|}
DECL|method|sleepAndLogInterrupts (int millis, String stateString)
specifier|private
name|void
name|sleepAndLogInterrupts
parameter_list|(
name|int
name|millis
parameter_list|,
name|String
name|stateString
parameter_list|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|millis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"BPOfferService "
operator|+
name|this
operator|+
literal|" interrupted while "
operator|+
name|stateString
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * No matter what kind of exception we get, keep retrying to offerService().    * That's the loop that connects to the NameNode and provides basic DataNode    * functionality.    *    * Only stop when "shouldRun" or "shouldServiceRun" is turned off, which can    * happen either at shutdown or due to refreshNamenodes.    */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|+
literal|" starting to offer service"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// init stuff
try|try
block|{
comment|// setup storage
name|connectToNNAndHandshake
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// Initial handshake, storage recovery or registration failed
comment|// End BPOfferService thread
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Initialization failed for block pool "
operator|+
name|this
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return;
block|}
name|initialized
operator|=
literal|true
expr_stmt|;
comment|// bp is initialized;
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
name|startDistributedUpgradeIfNeeded
argument_list|()
expr_stmt|;
name|offerService
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in BPOfferService for "
operator|+
name|this
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|sleepAndLogInterrupts
argument_list|(
literal|5000
argument_list|,
literal|"offering service"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected exception in block pool "
operator|+
name|this
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ending block pool service for: "
operator|+
name|this
argument_list|)
expr_stmt|;
name|cleanUp
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|shouldRun ()
specifier|private
name|boolean
name|shouldRun
parameter_list|()
block|{
return|return
name|shouldServiceRun
operator|&&
name|dn
operator|.
name|shouldRun
argument_list|()
return|;
block|}
comment|/**    * Process an array of datanode commands    *     * @param cmds an array of datanode commands    * @return true if further processing may be required or false otherwise.     */
DECL|method|processCommand (DatanodeCommand[] cmds)
specifier|private
name|boolean
name|processCommand
parameter_list|(
name|DatanodeCommand
index|[]
name|cmds
parameter_list|)
block|{
if|if
condition|(
name|cmds
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|DatanodeCommand
name|cmd
range|:
name|cmds
control|)
block|{
try|try
block|{
if|if
condition|(
name|processCommand
argument_list|(
name|cmd
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error processing datanode Command"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    *     * @param cmd    * @return true if further processing may be required or false otherwise.     * @throws IOException    */
DECL|method|processCommand (DatanodeCommand cmd)
specifier|private
name|boolean
name|processCommand
parameter_list|(
name|DatanodeCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cmd
operator|==
literal|null
condition|)
return|return
literal|true
return|;
specifier|final
name|BlockCommand
name|bcmd
init|=
name|cmd
operator|instanceof
name|BlockCommand
condition|?
operator|(
name|BlockCommand
operator|)
name|cmd
else|:
literal|null
decl_stmt|;
switch|switch
condition|(
name|cmd
operator|.
name|getAction
argument_list|()
condition|)
block|{
case|case
name|DatanodeProtocol
operator|.
name|DNA_TRANSFER
case|:
comment|// Send a copy of a block to another datanode
name|dn
operator|.
name|transferBlocks
argument_list|(
name|bcmd
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|bcmd
operator|.
name|getBlocks
argument_list|()
argument_list|,
name|bcmd
operator|.
name|getTargets
argument_list|()
argument_list|)
expr_stmt|;
name|dn
operator|.
name|metrics
operator|.
name|incrBlocksReplicated
argument_list|(
name|bcmd
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_INVALIDATE
case|:
comment|//
comment|// Some local block(s) are obsolete and can be
comment|// safely garbage-collected.
comment|//
name|Block
name|toDelete
index|[]
init|=
name|bcmd
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|dn
operator|.
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|dn
operator|.
name|blockScanner
operator|.
name|deleteBlocks
argument_list|(
name|bcmd
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|toDelete
argument_list|)
expr_stmt|;
block|}
comment|// using global fsdataset
name|dn
operator|.
name|data
operator|.
name|invalidate
argument_list|(
name|bcmd
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|toDelete
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|dn
operator|.
name|checkDiskError
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|dn
operator|.
name|metrics
operator|.
name|incrBlocksRemoved
argument_list|(
name|toDelete
operator|.
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_SHUTDOWN
case|:
comment|// shut down the data node
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
case|case
name|DatanodeProtocol
operator|.
name|DNA_REGISTER
case|:
comment|// namenode requested a registration - at start or if NN lost contact
name|LOG
operator|.
name|info
argument_list|(
literal|"DatanodeCommand action: DNA_REGISTER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
comment|// re-retrieve namespace info to make sure that, if the NN
comment|// was restarted, we still match its version (HDFS-2120)
name|retrieveNamespaceInfo
argument_list|()
expr_stmt|;
comment|// and re-register
name|register
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_FINALIZE
case|:
name|String
name|bp
init|=
operator|(
operator|(
name|FinalizeCommand
operator|)
name|cmd
operator|)
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
assert|assert
name|getBlockPoolId
argument_list|()
operator|.
name|equals
argument_list|(
name|bp
argument_list|)
operator|:
literal|"BP "
operator|+
name|getBlockPoolId
argument_list|()
operator|+
literal|" received DNA_FINALIZE "
operator|+
literal|"for other block pool "
operator|+
name|bp
assert|;
name|dn
operator|.
name|finalizeUpgradeForPool
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UpgradeCommand
operator|.
name|UC_ACTION_START_UPGRADE
case|:
comment|// start distributed upgrade here
name|processDistributedUpgradeCommand
argument_list|(
operator|(
name|UpgradeCommand
operator|)
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_RECOVERBLOCK
case|:
name|dn
operator|.
name|recoverBlocks
argument_list|(
operator|(
operator|(
name|BlockRecoveryCommand
operator|)
name|cmd
operator|)
operator|.
name|getRecoveringBlocks
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_ACCESSKEYUPDATE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"DatanodeCommand action: DNA_ACCESSKEYUPDATE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|.
name|isBlockTokenEnabled
condition|)
block|{
name|dn
operator|.
name|blockPoolTokenSecretManager
operator|.
name|setKeys
argument_list|(
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
operator|(
name|KeyUpdateCommand
operator|)
name|cmd
operator|)
operator|.
name|getExportedKeys
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_BALANCERBANDWIDTHUPDATE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"DatanodeCommand action: DNA_BALANCERBANDWIDTHUPDATE"
argument_list|)
expr_stmt|;
name|long
name|bandwidth
init|=
operator|(
operator|(
name|BalancerBandwidthCommand
operator|)
name|cmd
operator|)
operator|.
name|getBalancerBandwidthValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|bandwidth
operator|>
literal|0
condition|)
block|{
name|DataXceiverServer
name|dxcs
init|=
operator|(
name|DataXceiverServer
operator|)
name|dn
operator|.
name|dataXceiverServer
operator|.
name|getRunnable
argument_list|()
decl_stmt|;
name|dxcs
operator|.
name|balanceThrottler
operator|.
name|setBandwidth
argument_list|(
name|bandwidth
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown DatanodeCommand action: "
operator|+
name|cmd
operator|.
name|getAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|processDistributedUpgradeCommand (UpgradeCommand comm)
specifier|private
name|void
name|processDistributedUpgradeCommand
parameter_list|(
name|UpgradeCommand
name|comm
parameter_list|)
throws|throws
name|IOException
block|{
name|UpgradeManagerDatanode
name|upgradeManager
init|=
name|getUpgradeManager
argument_list|()
decl_stmt|;
name|upgradeManager
operator|.
name|processUpgradeCommand
argument_list|(
name|comm
argument_list|)
expr_stmt|;
block|}
DECL|method|getUpgradeManager ()
specifier|synchronized
name|UpgradeManagerDatanode
name|getUpgradeManager
parameter_list|()
block|{
if|if
condition|(
name|upgradeManager
operator|==
literal|null
condition|)
name|upgradeManager
operator|=
operator|new
name|UpgradeManagerDatanode
argument_list|(
name|dn
argument_list|,
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|upgradeManager
return|;
block|}
comment|/**    * Start distributed upgrade if it should be initiated by the data-node.    */
DECL|method|startDistributedUpgradeIfNeeded ()
specifier|private
name|void
name|startDistributedUpgradeIfNeeded
parameter_list|()
throws|throws
name|IOException
block|{
name|UpgradeManagerDatanode
name|um
init|=
name|getUpgradeManager
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|um
operator|.
name|getUpgradeState
argument_list|()
condition|)
return|return;
name|um
operator|.
name|setUpgradeState
argument_list|(
literal|false
argument_list|,
name|um
operator|.
name|getUpgradeVersion
argument_list|()
argument_list|)
expr_stmt|;
name|um
operator|.
name|startUpgrade
argument_list|()
expr_stmt|;
return|return;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getBpNamenode ()
name|DatanodeProtocolClientSideTranslatorPB
name|getBpNamenode
parameter_list|()
block|{
return|return
name|bpNamenode
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setBpNamenode (DatanodeProtocolClientSideTranslatorPB bpNamenode)
name|void
name|setBpNamenode
parameter_list|(
name|DatanodeProtocolClientSideTranslatorPB
name|bpNamenode
parameter_list|)
block|{
name|this
operator|.
name|bpNamenode
operator|=
name|bpNamenode
expr_stmt|;
block|}
block|}
end_class

end_unit

