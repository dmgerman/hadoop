begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfoWithStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|blockaliasmap
operator|.
name|BlockAliasMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|blockaliasmap
operator|.
name|impl
operator|.
name|TextFileRegionAliasMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|BlockAlias
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|RwLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_comment
comment|/**  * This class allows us to manage and multiplex between storages local to  * datanodes, and provided storage.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|ProvidedStorageMap
specifier|public
class|class
name|ProvidedStorageMap
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ProvidedStorageMap
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// limit to a single provider for now
DECL|field|lock
specifier|private
name|RwLock
name|lock
decl_stmt|;
DECL|field|bm
specifier|private
name|BlockManager
name|bm
decl_stmt|;
DECL|field|aliasMap
specifier|private
name|BlockAliasMap
name|aliasMap
decl_stmt|;
DECL|field|storageId
specifier|private
specifier|final
name|String
name|storageId
decl_stmt|;
DECL|field|providedDescriptor
specifier|private
specifier|final
name|ProvidedDescriptor
name|providedDescriptor
decl_stmt|;
DECL|field|providedStorageInfo
specifier|private
specifier|final
name|DatanodeStorageInfo
name|providedStorageInfo
decl_stmt|;
DECL|field|providedEnabled
specifier|private
name|boolean
name|providedEnabled
decl_stmt|;
DECL|field|capacity
specifier|private
name|long
name|capacity
decl_stmt|;
DECL|field|defaultReplication
specifier|private
name|int
name|defaultReplication
decl_stmt|;
DECL|method|ProvidedStorageMap (RwLock lock, BlockManager bm, Configuration conf)
name|ProvidedStorageMap
parameter_list|(
name|RwLock
name|lock
parameter_list|,
name|BlockManager
name|bm
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|storageId
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_PROVIDER_STORAGEUUID
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_PROVIDER_STORAGEUUID_DEFAULT
argument_list|)
expr_stmt|;
name|providedEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_PROVIDED_ENABLED
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_PROVIDED_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|providedEnabled
condition|)
block|{
comment|// disable mapping
name|aliasMap
operator|=
literal|null
expr_stmt|;
name|providedDescriptor
operator|=
literal|null
expr_stmt|;
name|providedStorageInfo
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|DatanodeStorage
name|ds
init|=
operator|new
name|DatanodeStorage
argument_list|(
name|storageId
argument_list|,
name|State
operator|.
name|NORMAL
argument_list|,
name|StorageType
operator|.
name|PROVIDED
argument_list|)
decl_stmt|;
name|providedDescriptor
operator|=
operator|new
name|ProvidedDescriptor
argument_list|()
expr_stmt|;
name|providedStorageInfo
operator|=
name|providedDescriptor
operator|.
name|createProvidedStorage
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|bm
operator|=
name|bm
expr_stmt|;
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
comment|// load block reader into storage
name|Class
argument_list|<
name|?
extends|extends
name|BlockAliasMap
argument_list|>
name|aliasMapClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_PROVIDED_ALIASMAP_CLASS
argument_list|,
name|TextFileRegionAliasMap
operator|.
name|class
argument_list|,
name|BlockAliasMap
operator|.
name|class
argument_list|)
decl_stmt|;
name|aliasMap
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|aliasMapClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Loaded alias map class: "
operator|+
name|aliasMap
operator|.
name|getClass
argument_list|()
operator|+
literal|" storage: "
operator|+
name|providedStorageInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param dn datanode descriptor    * @param s data node storage    * @return the {@link DatanodeStorageInfo} for the specified datanode.    * If {@code s} corresponds to a provided storage, the storage info    * representing provided storage is returned.    * @throws IOException    */
DECL|method|getStorage (DatanodeDescriptor dn, DatanodeStorage s)
name|DatanodeStorageInfo
name|getStorage
parameter_list|(
name|DatanodeDescriptor
name|dn
parameter_list|,
name|DatanodeStorage
name|s
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|providedEnabled
operator|&&
name|storageId
operator|.
name|equals
argument_list|(
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|StorageType
operator|.
name|PROVIDED
operator|.
name|equals
argument_list|(
name|s
operator|.
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|providedStorageInfo
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|FAILED
operator|&&
name|s
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|NORMAL
condition|)
block|{
name|providedStorageInfo
operator|.
name|setState
argument_list|(
name|State
operator|.
name|NORMAL
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Provided storage transitioning to state "
operator|+
name|State
operator|.
name|NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|.
name|getStorageInfo
argument_list|(
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|dn
operator|.
name|injectStorage
argument_list|(
name|providedStorageInfo
argument_list|)
expr_stmt|;
block|}
name|processProvidedStorageReport
argument_list|()
expr_stmt|;
return|return
name|providedDescriptor
operator|.
name|getProvidedStorage
argument_list|(
name|dn
argument_list|,
name|s
argument_list|)
return|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reserved storage {} reported as non-provided from {}"
argument_list|,
name|s
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
return|return
name|dn
operator|.
name|getStorageInfo
argument_list|(
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|)
return|;
block|}
DECL|method|processProvidedStorageReport ()
specifier|private
name|void
name|processProvidedStorageReport
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|lock
operator|.
name|hasWriteLock
argument_list|()
operator|:
literal|"Not holding write lock"
assert|;
if|if
condition|(
name|providedStorageInfo
operator|.
name|getBlockReportCount
argument_list|()
operator|==
literal|0
operator|||
name|providedDescriptor
operator|.
name|activeProvidedDatanodes
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Calling process first blk report from storage: "
operator|+
name|providedStorageInfo
argument_list|)
expr_stmt|;
comment|// first pass; periodic refresh should call bm.processReport
name|BlockAliasMap
operator|.
name|Reader
argument_list|<
name|BlockAlias
argument_list|>
name|reader
init|=
name|aliasMap
operator|.
name|getReader
argument_list|(
literal|null
argument_list|,
name|bm
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|bm
operator|.
name|processFirstBlockReport
argument_list|(
name|providedStorageInfo
argument_list|,
operator|new
name|ProvidedBlockList
argument_list|(
name|reader
operator|.
name|iterator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getProvidedStorageInfo ()
specifier|public
name|DatanodeStorageInfo
name|getProvidedStorageInfo
parameter_list|()
block|{
return|return
name|providedStorageInfo
return|;
block|}
DECL|method|newLocatedBlocks (int maxValue)
specifier|public
name|LocatedBlockBuilder
name|newLocatedBlocks
parameter_list|(
name|int
name|maxValue
parameter_list|)
block|{
if|if
condition|(
operator|!
name|providedEnabled
condition|)
block|{
return|return
operator|new
name|LocatedBlockBuilder
argument_list|(
name|maxValue
argument_list|)
return|;
block|}
return|return
operator|new
name|ProvidedBlocksBuilder
argument_list|(
name|maxValue
argument_list|)
return|;
block|}
DECL|method|removeDatanode (DatanodeDescriptor dnToRemove)
specifier|public
name|void
name|removeDatanode
parameter_list|(
name|DatanodeDescriptor
name|dnToRemove
parameter_list|)
block|{
if|if
condition|(
name|providedEnabled
condition|)
block|{
assert|assert
name|lock
operator|.
name|hasWriteLock
argument_list|()
operator|:
literal|"Not holding write lock"
assert|;
name|providedDescriptor
operator|.
name|remove
argument_list|(
name|dnToRemove
argument_list|)
expr_stmt|;
comment|// if all datanodes fail, set the block report count to 0
if|if
condition|(
name|providedDescriptor
operator|.
name|activeProvidedDatanodes
argument_list|()
operator|==
literal|0
condition|)
block|{
name|providedStorageInfo
operator|.
name|setBlockReportCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getCapacity ()
specifier|public
name|long
name|getCapacity
parameter_list|()
block|{
if|if
condition|(
name|providedStorageInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|providedStorageInfo
operator|.
name|getCapacity
argument_list|()
return|;
block|}
DECL|method|updateStorage (DatanodeDescriptor node, DatanodeStorage storage)
specifier|public
name|void
name|updateStorage
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|,
name|DatanodeStorage
name|storage
parameter_list|)
block|{
if|if
condition|(
name|isProvidedStorage
argument_list|(
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|StorageType
operator|.
name|PROVIDED
operator|.
name|equals
argument_list|(
name|storage
operator|.
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
name|node
operator|.
name|injectStorage
argument_list|(
name|providedStorageInfo
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reserved storage {} reported as non-provided from {}"
argument_list|,
name|storage
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|node
operator|.
name|updateStorage
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
DECL|method|isProvidedStorage (String dnStorageId)
specifier|private
name|boolean
name|isProvidedStorage
parameter_list|(
name|String
name|dnStorageId
parameter_list|)
block|{
return|return
name|providedEnabled
operator|&&
name|storageId
operator|.
name|equals
argument_list|(
name|dnStorageId
argument_list|)
return|;
block|}
comment|/**    * Choose a datanode that reported a volume of {@link StorageType} PROVIDED.    *    * @return the {@link DatanodeDescriptor} corresponding to a datanode that    *         reported a volume with {@link StorageType} PROVIDED. If multiple    *         datanodes report a PROVIDED volume, one is chosen uniformly at    *         random.    */
DECL|method|chooseProvidedDatanode ()
specifier|public
name|DatanodeDescriptor
name|chooseProvidedDatanode
parameter_list|()
block|{
return|return
name|providedDescriptor
operator|.
name|chooseRandom
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAliasMap ()
specifier|public
name|BlockAliasMap
name|getAliasMap
parameter_list|()
block|{
return|return
name|aliasMap
return|;
block|}
comment|/**    * Builder used for creating {@link LocatedBlocks} when a block is provided.    */
DECL|class|ProvidedBlocksBuilder
class|class
name|ProvidedBlocksBuilder
extends|extends
name|LocatedBlockBuilder
block|{
DECL|method|ProvidedBlocksBuilder (int maxBlocks)
name|ProvidedBlocksBuilder
parameter_list|(
name|int
name|maxBlocks
parameter_list|)
block|{
name|super
argument_list|(
name|maxBlocks
argument_list|)
expr_stmt|;
block|}
DECL|method|chooseProvidedDatanode ( Set<String> excludedUUids)
specifier|private
name|DatanodeDescriptor
name|chooseProvidedDatanode
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|excludedUUids
parameter_list|)
block|{
name|DatanodeDescriptor
name|dn
init|=
name|providedDescriptor
operator|.
name|choose
argument_list|(
literal|null
argument_list|,
name|excludedUUids
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|==
literal|null
condition|)
block|{
name|dn
operator|=
name|providedDescriptor
operator|.
name|choose
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|dn
return|;
block|}
annotation|@
name|Override
DECL|method|newLocatedBlock (ExtendedBlock eb, DatanodeStorageInfo[] storages, long pos, boolean isCorrupt)
name|LocatedBlock
name|newLocatedBlock
parameter_list|(
name|ExtendedBlock
name|eb
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|storages
parameter_list|,
name|long
name|pos
parameter_list|,
name|boolean
name|isCorrupt
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeInfoWithStorage
argument_list|>
name|locs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|sids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|StorageType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|isProvidedBlock
init|=
literal|false
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|excludedUUids
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|storages
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|DatanodeStorageInfo
name|currInfo
init|=
name|storages
index|[
name|i
index|]
decl_stmt|;
name|StorageType
name|storageType
init|=
name|currInfo
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
name|sids
operator|.
name|add
argument_list|(
name|currInfo
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|storageType
argument_list|)
expr_stmt|;
if|if
condition|(
name|StorageType
operator|.
name|PROVIDED
operator|.
name|equals
argument_list|(
name|storageType
argument_list|)
condition|)
block|{
comment|// Provided location will be added to the list of locations after
comment|// examining all local locations.
name|isProvidedBlock
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|locs
operator|.
name|add
argument_list|(
operator|new
name|DatanodeInfoWithStorage
argument_list|(
name|currInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|currInfo
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|storageType
argument_list|)
argument_list|)
expr_stmt|;
name|excludedUUids
operator|.
name|add
argument_list|(
name|currInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numLocations
init|=
name|locs
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|isProvidedBlock
condition|)
block|{
comment|// add the first datanode here
name|DatanodeDescriptor
name|dn
init|=
name|chooseProvidedDatanode
argument_list|(
name|excludedUUids
argument_list|)
decl_stmt|;
name|locs
operator|.
name|add
argument_list|(
operator|new
name|DatanodeInfoWithStorage
argument_list|(
name|dn
argument_list|,
name|storageId
argument_list|,
name|StorageType
operator|.
name|PROVIDED
argument_list|)
argument_list|)
expr_stmt|;
name|excludedUUids
operator|.
name|add
argument_list|(
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
name|numLocations
operator|++
expr_stmt|;
comment|// add more replicas until we reach the defaultReplication
for|for
control|(
name|int
name|count
init|=
name|numLocations
operator|+
literal|1
init|;
name|count
operator|<=
name|defaultReplication
operator|&&
name|count
operator|<=
name|providedDescriptor
operator|.
name|activeProvidedDatanodes
argument_list|()
condition|;
name|count
operator|++
control|)
block|{
name|dn
operator|=
name|chooseProvidedDatanode
argument_list|(
name|excludedUUids
argument_list|)
expr_stmt|;
name|locs
operator|.
name|add
argument_list|(
operator|new
name|DatanodeInfoWithStorage
argument_list|(
name|dn
argument_list|,
name|storageId
argument_list|,
name|StorageType
operator|.
name|PROVIDED
argument_list|)
argument_list|)
expr_stmt|;
name|sids
operator|.
name|add
argument_list|(
name|storageId
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|StorageType
operator|.
name|PROVIDED
argument_list|)
expr_stmt|;
name|excludedUUids
operator|.
name|add
argument_list|(
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|LocatedBlock
argument_list|(
name|eb
argument_list|,
name|locs
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeInfoWithStorage
index|[
name|locs
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|sids
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|sids
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|types
operator|.
name|toArray
argument_list|(
operator|new
name|StorageType
index|[
name|types
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|pos
argument_list|,
name|isCorrupt
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|build (DatanodeDescriptor client)
name|LocatedBlocks
name|build
parameter_list|(
name|DatanodeDescriptor
name|client
parameter_list|)
block|{
comment|// TODO choose provided locations close to the client.
return|return
operator|new
name|LocatedBlocks
argument_list|(
name|flen
argument_list|,
name|isUC
argument_list|,
name|blocks
argument_list|,
name|last
argument_list|,
name|lastComplete
argument_list|,
name|feInfo
argument_list|,
name|ecPolicy
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|build ()
name|LocatedBlocks
name|build
parameter_list|()
block|{
return|return
name|build
argument_list|(
name|providedDescriptor
operator|.
name|chooseRandom
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * An abstract DatanodeDescriptor to track datanodes with provided storages.    * NOTE: never resolved through registerDatanode, so not in the topology.    */
DECL|class|ProvidedDescriptor
specifier|public
specifier|static
class|class
name|ProvidedDescriptor
extends|extends
name|DatanodeDescriptor
block|{
DECL|field|dns
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|DatanodeDescriptor
argument_list|>
name|dns
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// maintain a separate list of the datanodes with provided storage
comment|// to efficiently choose Datanodes when required.
DECL|field|dnR
specifier|private
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dnR
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|NETWORK_LOCATION
specifier|public
specifier|final
specifier|static
name|String
name|NETWORK_LOCATION
init|=
literal|"/REMOTE"
decl_stmt|;
DECL|field|NAME
specifier|public
specifier|final
specifier|static
name|String
name|NAME
init|=
literal|"PROVIDED"
decl_stmt|;
DECL|method|ProvidedDescriptor ()
name|ProvidedDescriptor
parameter_list|()
block|{
name|super
argument_list|(
operator|new
name|DatanodeID
argument_list|(
literal|null
argument_list|,
comment|// String ipAddr,
literal|null
argument_list|,
comment|// String hostName,
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
comment|// String datanodeUuid,
literal|0
argument_list|,
comment|// int xferPort,
literal|0
argument_list|,
comment|// int infoPort,
literal|0
argument_list|,
comment|// int infoSecurePort,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// int ipcPort
block|}
DECL|method|getProvidedStorage ( DatanodeDescriptor dn, DatanodeStorage s)
name|DatanodeStorageInfo
name|getProvidedStorage
parameter_list|(
name|DatanodeDescriptor
name|dn
parameter_list|,
name|DatanodeStorage
name|s
parameter_list|)
block|{
name|dns
operator|.
name|put
argument_list|(
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|dnR
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
name|storageMap
operator|.
name|get
argument_list|(
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|)
return|;
block|}
DECL|method|createProvidedStorage (DatanodeStorage ds)
name|DatanodeStorageInfo
name|createProvidedStorage
parameter_list|(
name|DatanodeStorage
name|ds
parameter_list|)
block|{
assert|assert
literal|null
operator|==
name|storageMap
operator|.
name|get
argument_list|(
name|ds
operator|.
name|getStorageID
argument_list|()
argument_list|)
assert|;
name|DatanodeStorageInfo
name|storage
init|=
operator|new
name|ProvidedDatanodeStorageInfo
argument_list|(
name|this
argument_list|,
name|ds
argument_list|)
decl_stmt|;
name|storage
operator|.
name|setHeartbeatedSinceFailover
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|storageMap
operator|.
name|put
argument_list|(
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|storage
argument_list|)
expr_stmt|;
return|return
name|storage
return|;
block|}
DECL|method|choose (DatanodeDescriptor client)
name|DatanodeDescriptor
name|choose
parameter_list|(
name|DatanodeDescriptor
name|client
parameter_list|)
block|{
return|return
name|choose
argument_list|(
name|client
argument_list|,
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptySet
argument_list|()
argument_list|)
return|;
block|}
DECL|method|choose (DatanodeDescriptor client, Set<String> excludedUUids)
name|DatanodeDescriptor
name|choose
parameter_list|(
name|DatanodeDescriptor
name|client
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|excludedUUids
parameter_list|)
block|{
comment|// exact match for now
if|if
condition|(
name|client
operator|!=
literal|null
operator|&&
operator|!
name|excludedUUids
operator|.
name|contains
argument_list|(
name|client
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
condition|)
block|{
name|DatanodeDescriptor
name|dn
init|=
name|dns
operator|.
name|get
argument_list|(
name|client
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|!=
literal|null
condition|)
block|{
return|return
name|dn
return|;
block|}
block|}
comment|// prefer live nodes first.
name|DatanodeDescriptor
name|dn
init|=
name|chooseRandomNode
argument_list|(
name|excludedUUids
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|==
literal|null
condition|)
block|{
name|dn
operator|=
name|chooseRandomNode
argument_list|(
name|excludedUUids
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|dn
return|;
block|}
DECL|method|chooseRandomNode (Set<String> excludedUUids, boolean preferLiveNodes)
specifier|private
name|DatanodeDescriptor
name|chooseRandomNode
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|excludedUUids
parameter_list|,
name|boolean
name|preferLiveNodes
parameter_list|)
block|{
name|Random
name|r
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|dnR
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|pos
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|dnR
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|String
name|uuid
init|=
name|node
operator|.
name|getDatanodeUuid
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|excludedUUids
operator|.
name|contains
argument_list|(
name|uuid
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|preferLiveNodes
operator|||
name|node
operator|.
name|getAdminState
argument_list|()
operator|==
name|AdminStates
operator|.
name|NORMAL
condition|)
block|{
return|return
name|node
return|;
block|}
block|}
name|Collections
operator|.
name|swap
argument_list|(
name|dnR
argument_list|,
name|i
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|chooseRandom (DatanodeStorageInfo... excludedStorages)
name|DatanodeDescriptor
name|chooseRandom
parameter_list|(
name|DatanodeStorageInfo
modifier|...
name|excludedStorages
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|excludedNodes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|excludedStorages
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|excludedStorages
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeDescriptor
name|dn
init|=
name|excludedStorages
index|[
name|i
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|String
name|uuid
init|=
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
decl_stmt|;
name|excludedNodes
operator|.
name|add
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|choose
argument_list|(
literal|null
argument_list|,
name|excludedNodes
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|addBlockToBeReplicated (Block block, DatanodeStorageInfo[] targets)
name|void
name|addBlockToBeReplicated
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
block|{
comment|// pick a random datanode, delegate to it
name|DatanodeDescriptor
name|node
init|=
name|chooseRandom
argument_list|(
name|targets
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|addBlockToBeReplicated
argument_list|(
name|block
argument_list|,
name|targets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot find a source node to replicate block: "
operator|+
name|block
operator|+
literal|" from"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|remove (DatanodeDescriptor dnToRemove)
name|int
name|remove
parameter_list|(
name|DatanodeDescriptor
name|dnToRemove
parameter_list|)
block|{
comment|// this operation happens under the FSNamesystem lock;
comment|// no additional synchronization required.
if|if
condition|(
name|dnToRemove
operator|!=
literal|null
condition|)
block|{
name|DatanodeDescriptor
name|storedDN
init|=
name|dns
operator|.
name|get
argument_list|(
name|dnToRemove
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedDN
operator|!=
literal|null
condition|)
block|{
name|dns
operator|.
name|remove
argument_list|(
name|dnToRemove
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
name|dnR
operator|.
name|remove
argument_list|(
name|dnToRemove
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dns
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|activeProvidedDatanodes ()
name|int
name|activeProvidedDatanodes
parameter_list|()
block|{
return|return
name|dns
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
operator|(
name|this
operator|==
name|obj
operator|)
operator|||
name|super
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|super
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"PROVIDED-LOCATION"
return|;
block|}
annotation|@
name|Override
DECL|method|getNetworkLocation ()
specifier|public
name|String
name|getNetworkLocation
parameter_list|()
block|{
return|return
name|NETWORK_LOCATION
return|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
block|}
comment|/**    * The DatanodeStorageInfo used for the provided storage.    */
DECL|class|ProvidedDatanodeStorageInfo
specifier|static
class|class
name|ProvidedDatanodeStorageInfo
extends|extends
name|DatanodeStorageInfo
block|{
DECL|method|ProvidedDatanodeStorageInfo (ProvidedDescriptor dn, DatanodeStorage ds)
name|ProvidedDatanodeStorageInfo
parameter_list|(
name|ProvidedDescriptor
name|dn
parameter_list|,
name|DatanodeStorage
name|ds
parameter_list|)
block|{
name|super
argument_list|(
name|dn
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeBlock (BlockInfo b)
name|boolean
name|removeBlock
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
name|ProvidedDescriptor
name|dn
init|=
operator|(
name|ProvidedDescriptor
operator|)
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|dn
operator|.
name|activeProvidedDatanodes
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|super
operator|.
name|removeBlock
argument_list|(
name|b
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|setState (DatanodeStorage.State state)
name|void
name|setState
parameter_list|(
name|DatanodeStorage
operator|.
name|State
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|FAILED
condition|)
block|{
comment|// The state should change to FAILED only when there are no active
comment|// datanodes with PROVIDED storage.
name|ProvidedDescriptor
name|dn
init|=
operator|(
name|ProvidedDescriptor
operator|)
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|dn
operator|.
name|activeProvidedDatanodes
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Provided storage {} transitioning to state {}"
argument_list|,
name|this
argument_list|,
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
name|super
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|super
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"PROVIDED-STORAGE"
return|;
block|}
block|}
comment|/**    * Used to emulate block reports for provided blocks.    */
DECL|class|ProvidedBlockList
specifier|static
class|class
name|ProvidedBlockList
extends|extends
name|BlockListAsLongs
block|{
DECL|field|inner
specifier|private
specifier|final
name|Iterator
argument_list|<
name|BlockAlias
argument_list|>
name|inner
decl_stmt|;
DECL|method|ProvidedBlockList (Iterator<BlockAlias> inner)
name|ProvidedBlockList
parameter_list|(
name|Iterator
argument_list|<
name|BlockAlias
argument_list|>
name|inner
parameter_list|)
block|{
name|this
operator|.
name|inner
operator|=
name|inner
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|BlockReportReplica
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|BlockReportReplica
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BlockReportReplica
name|next
parameter_list|()
block|{
return|return
operator|new
name|BlockReportReplica
argument_list|(
name|inner
operator|.
name|next
argument_list|()
operator|.
name|getBlock
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|inner
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|getNumberOfBlocks ()
specifier|public
name|int
name|getNumberOfBlocks
parameter_list|()
block|{
comment|// is ignored for ProvidedBlockList.
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|getBlocksBuffer ()
specifier|public
name|ByteString
name|getBlocksBuffer
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|getBlockListAsLongs ()
specifier|public
name|long
index|[]
name|getBlockListAsLongs
parameter_list|()
block|{
comment|// should only be used for backwards compat, DN.ver> NN.ver
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
block|}
end_class

end_unit

