begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|DirectoryListingStartAfterNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|QuotaUsage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DirectoryListing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FsPermissionExtension
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsLocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSDirectory
operator|.
name|DirOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|DirectorySnapshottableFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ReadOnlyList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_class
DECL|class|FSDirStatAndListingOp
class|class
name|FSDirStatAndListingOp
block|{
DECL|method|getListingInt (FSDirectory fsd, final String srcArg, byte[] startAfter, boolean needLocation)
specifier|static
name|DirectoryListing
name|getListingInt
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
specifier|final
name|String
name|srcArg
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FSPermissionChecker
name|pc
init|=
name|fsd
operator|.
name|getPermissionChecker
argument_list|()
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|fsd
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|srcArg
argument_list|,
name|DirOp
operator|.
name|READ
argument_list|)
decl_stmt|;
comment|// Get file name when startAfter is an INodePath.  This is not the
comment|// common case so avoid any unnecessary processing unless required.
if|if
condition|(
name|startAfter
operator|.
name|length
operator|>
literal|0
operator|&&
name|startAfter
index|[
literal|0
index|]
operator|==
name|Path
operator|.
name|SEPARATOR_CHAR
condition|)
block|{
specifier|final
name|String
name|startAfterString
init|=
name|DFSUtil
operator|.
name|bytes2String
argument_list|(
name|startAfter
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSDirectory
operator|.
name|isReservedName
argument_list|(
name|startAfterString
argument_list|)
condition|)
block|{
try|try
block|{
name|byte
index|[]
index|[]
name|components
init|=
name|INode
operator|.
name|getPathComponents
argument_list|(
name|startAfterString
argument_list|)
decl_stmt|;
name|components
operator|=
name|FSDirectory
operator|.
name|resolveComponents
argument_list|(
name|components
argument_list|,
name|fsd
argument_list|)
expr_stmt|;
name|startAfter
operator|=
name|components
index|[
name|components
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Possibly the inode is deleted
throw|throw
operator|new
name|DirectoryListingStartAfterNotFoundException
argument_list|(
literal|"Can't find startAfter "
operator|+
name|startAfterString
argument_list|)
throw|;
block|}
block|}
block|}
name|boolean
name|isSuperUser
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|fsd
operator|.
name|isPermissionEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|iip
operator|.
name|getLastINode
argument_list|()
operator|!=
literal|null
operator|&&
name|iip
operator|.
name|getLastINode
argument_list|()
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|fsd
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|READ_EXECUTE
argument_list|)
expr_stmt|;
block|}
name|isSuperUser
operator|=
name|pc
operator|.
name|isSuperUser
argument_list|()
expr_stmt|;
block|}
return|return
name|getListing
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
name|startAfter
argument_list|,
name|needLocation
argument_list|,
name|isSuperUser
argument_list|)
return|;
block|}
comment|/**    * Get the file info for a specific file.    *    * @param srcArg The string representation of the path to the file    * @param resolveLink whether to throw UnresolvedLinkException    *        if src refers to a symlink    *    * @return object containing information regarding the file    *         or null if file not found    */
DECL|method|getFileInfo ( FSDirectory fsd, String srcArg, boolean resolveLink)
specifier|static
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|srcArg
parameter_list|,
name|boolean
name|resolveLink
parameter_list|)
throws|throws
name|IOException
block|{
name|DirOp
name|dirOp
init|=
name|resolveLink
condition|?
name|DirOp
operator|.
name|READ
else|:
name|DirOp
operator|.
name|READ_LINK
decl_stmt|;
name|FSPermissionChecker
name|pc
init|=
name|fsd
operator|.
name|getPermissionChecker
argument_list|()
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
if|if
condition|(
name|pc
operator|.
name|isSuperUser
argument_list|()
condition|)
block|{
comment|// superuser can only get an ACE if an existing ancestor is a file.
comment|// right or (almost certainly) wrong, current fs contracts expect
comment|// superuser to receive null instead.
try|try
block|{
name|iip
operator|=
name|fsd
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|srcArg
argument_list|,
name|dirOp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|iip
operator|=
name|fsd
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|srcArg
argument_list|,
name|dirOp
argument_list|)
expr_stmt|;
block|}
return|return
name|getFileInfo
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|)
return|;
block|}
comment|/**    * Returns true if the file is closed    */
DECL|method|isFileClosed (FSDirectory fsd, String src)
specifier|static
name|boolean
name|isFileClosed
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|FSPermissionChecker
name|pc
init|=
name|fsd
operator|.
name|getPermissionChecker
argument_list|()
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|fsd
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|DirOp
operator|.
name|READ
argument_list|)
decl_stmt|;
return|return
operator|!
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|src
argument_list|)
operator|.
name|isUnderConstruction
argument_list|()
return|;
block|}
DECL|method|getContentSummary ( FSDirectory fsd, String src)
specifier|static
name|ContentSummary
name|getContentSummary
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|FSPermissionChecker
name|pc
init|=
name|fsd
operator|.
name|getPermissionChecker
argument_list|()
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
init|=
name|fsd
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|DirOp
operator|.
name|READ_LINK
argument_list|)
decl_stmt|;
if|if
condition|(
name|fsd
operator|.
name|isPermissionEnabled
argument_list|()
condition|)
block|{
name|fsd
operator|.
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|FsAction
operator|.
name|READ_EXECUTE
argument_list|)
expr_stmt|;
block|}
return|return
name|getContentSummaryInt
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|)
return|;
block|}
comment|/**    * Get block locations within the specified range.    * @see ClientProtocol#getBlockLocations(String, long, long)    * @throws IOException    */
DECL|method|getBlockLocations ( FSDirectory fsd, FSPermissionChecker pc, String src, long offset, long length, boolean needBlockToken)
specifier|static
name|GetBlockLocationsResult
name|getBlockLocations
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|FSPermissionChecker
name|pc
parameter_list|,
name|String
name|src
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|,
name|boolean
name|needBlockToken
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|offset
operator|>=
literal|0
argument_list|,
literal|"Negative offset is not supported. File: "
operator|+
name|src
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|length
operator|>=
literal|0
argument_list|,
literal|"Negative length is not supported. File: "
operator|+
name|src
argument_list|)
expr_stmt|;
name|BlockManager
name|bm
init|=
name|fsd
operator|.
name|getBlockManager
argument_list|()
decl_stmt|;
name|fsd
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INodesInPath
name|iip
init|=
name|fsd
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|DirOp
operator|.
name|READ
argument_list|)
decl_stmt|;
name|src
operator|=
name|iip
operator|.
name|getPath
argument_list|()
expr_stmt|;
specifier|final
name|INodeFile
name|inode
init|=
name|INodeFile
operator|.
name|valueOf
argument_list|(
name|iip
operator|.
name|getLastINode
argument_list|()
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|fsd
operator|.
name|isPermissionEnabled
argument_list|()
condition|)
block|{
name|fsd
operator|.
name|checkPathAccess
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
name|FsAction
operator|.
name|READ
argument_list|)
expr_stmt|;
name|fsd
operator|.
name|checkUnreadableBySuperuser
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|fileSize
init|=
name|iip
operator|.
name|isSnapshot
argument_list|()
condition|?
name|inode
operator|.
name|computeFileSize
argument_list|(
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
argument_list|)
else|:
name|inode
operator|.
name|computeFileSizeNotIncludingLastUcBlock
argument_list|()
decl_stmt|;
name|boolean
name|isUc
init|=
name|inode
operator|.
name|isUnderConstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|iip
operator|.
name|isSnapshot
argument_list|()
condition|)
block|{
comment|// if src indicates a snapshot file, we need to make sure the returned
comment|// blocks do not exceed the size of the snapshot file.
name|length
operator|=
name|Math
operator|.
name|min
argument_list|(
name|length
argument_list|,
name|fileSize
operator|-
name|offset
argument_list|)
expr_stmt|;
name|isUc
operator|=
literal|false
expr_stmt|;
block|}
specifier|final
name|FileEncryptionInfo
name|feInfo
init|=
name|FSDirEncryptionZoneOp
operator|.
name|getFileEncryptionInfo
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|)
decl_stmt|;
specifier|final
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|FSDirErasureCodingOp
operator|.
name|getErasureCodingPolicy
argument_list|(
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
argument_list|,
name|iip
argument_list|)
decl_stmt|;
specifier|final
name|LocatedBlocks
name|blocks
init|=
name|bm
operator|.
name|createLocatedBlocks
argument_list|(
name|inode
operator|.
name|getBlocks
argument_list|(
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
argument_list|)
argument_list|,
name|fileSize
argument_list|,
name|isUc
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|needBlockToken
argument_list|,
name|iip
operator|.
name|isSnapshot
argument_list|()
argument_list|,
name|feInfo
argument_list|,
name|ecPolicy
argument_list|)
decl_stmt|;
specifier|final
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
name|boolean
name|updateAccessTime
init|=
name|fsd
operator|.
name|isAccessTimeSupported
argument_list|()
operator|&&
operator|!
name|iip
operator|.
name|isSnapshot
argument_list|()
operator|&&
name|now
operator|>
name|inode
operator|.
name|getAccessTime
argument_list|()
operator|+
name|fsd
operator|.
name|getAccessTimePrecision
argument_list|()
decl_stmt|;
return|return
operator|new
name|GetBlockLocationsResult
argument_list|(
name|updateAccessTime
argument_list|,
name|blocks
argument_list|)
return|;
block|}
finally|finally
block|{
name|fsd
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getStoragePolicyID (byte inodePolicy, byte parentPolicy)
specifier|private
specifier|static
name|byte
name|getStoragePolicyID
parameter_list|(
name|byte
name|inodePolicy
parameter_list|,
name|byte
name|parentPolicy
parameter_list|)
block|{
return|return
name|inodePolicy
operator|!=
name|HdfsConstants
operator|.
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
condition|?
name|inodePolicy
else|:
name|parentPolicy
return|;
block|}
comment|/**    * Get a partial listing of the indicated directory    *    * We will stop when any of the following conditions is met:    * 1) this.lsLimit files have been added    * 2) needLocation is true AND enough files have been added such    * that at least this.lsLimit block locations are in the response    *    * @param fsd FSDirectory    * @param iip the INodesInPath instance containing all the INodes along the    *            path    * @param startAfter the name to start listing after    * @param needLocation if block locations are returned    * @param includeStoragePolicy if storage policy is returned    * @return a partial listing starting after startAfter    */
DECL|method|getListing (FSDirectory fsd, INodesInPath iip, byte[] startAfter, boolean needLocation, boolean includeStoragePolicy)
specifier|private
specifier|static
name|DirectoryListing
name|getListing
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|,
name|boolean
name|needLocation
parameter_list|,
name|boolean
name|includeStoragePolicy
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|FSDirectory
operator|.
name|isExactReservedName
argument_list|(
name|iip
operator|.
name|getPathComponents
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|getReservedListing
argument_list|(
name|fsd
argument_list|)
return|;
block|}
name|fsd
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|iip
operator|.
name|isDotSnapshotDir
argument_list|()
condition|)
block|{
return|return
name|getSnapshotsListing
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
name|startAfter
argument_list|)
return|;
block|}
specifier|final
name|int
name|snapshot
init|=
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|targetNode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|byte
name|parentStoragePolicy
init|=
name|includeStoragePolicy
condition|?
name|targetNode
operator|.
name|getStoragePolicyID
argument_list|()
else|:
name|HdfsConstants
operator|.
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
decl_stmt|;
if|if
condition|(
operator|!
name|targetNode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// return the file's status. note that the iip already includes the
comment|// target INode
return|return
operator|new
name|DirectoryListing
argument_list|(
operator|new
name|HdfsFileStatus
index|[]
block|{
name|createFileStatus
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
literal|null
argument_list|,
name|parentStoragePolicy
argument_list|,
name|needLocation
argument_list|)
block|}
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|final
name|INodeDirectory
name|dirInode
init|=
name|targetNode
operator|.
name|asDirectory
argument_list|()
decl_stmt|;
specifier|final
name|ReadOnlyList
argument_list|<
name|INode
argument_list|>
name|contents
init|=
name|dirInode
operator|.
name|getChildrenList
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|int
name|startChild
init|=
name|INodeDirectory
operator|.
name|nextChild
argument_list|(
name|contents
argument_list|,
name|startAfter
argument_list|)
decl_stmt|;
name|int
name|totalNumChildren
init|=
name|contents
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numOfListing
init|=
name|Math
operator|.
name|min
argument_list|(
name|totalNumChildren
operator|-
name|startChild
argument_list|,
name|fsd
operator|.
name|getLsLimit
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|locationBudget
init|=
name|fsd
operator|.
name|getLsLimit
argument_list|()
decl_stmt|;
name|int
name|listingCnt
init|=
literal|0
decl_stmt|;
name|HdfsFileStatus
name|listing
index|[]
init|=
operator|new
name|HdfsFileStatus
index|[
name|numOfListing
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
argument_list|<
name|numOfListing
operator|&&
name|locationBudget
argument_list|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|INode
name|child
init|=
name|contents
operator|.
name|get
argument_list|(
name|startChild
operator|+
name|i
argument_list|)
decl_stmt|;
name|byte
name|childStoragePolicy
init|=
operator|(
name|includeStoragePolicy
operator|&&
operator|!
name|child
operator|.
name|isSymlink
argument_list|()
operator|)
condition|?
name|getStoragePolicyID
argument_list|(
name|child
operator|.
name|getLocalStoragePolicyID
argument_list|()
argument_list|,
name|parentStoragePolicy
argument_list|)
else|:
name|parentStoragePolicy
decl_stmt|;
name|listing
index|[
name|i
index|]
operator|=
name|createFileStatus
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
name|child
argument_list|,
name|childStoragePolicy
argument_list|,
name|needLocation
argument_list|)
expr_stmt|;
name|listingCnt
operator|++
expr_stmt|;
if|if
condition|(
name|listing
index|[
name|i
index|]
operator|instanceof
name|HdfsLocatedFileStatus
condition|)
block|{
comment|// Once we  hit lsLimit locations, stop.
comment|// This helps to prevent excessively large response payloads.
comment|// Approximate #locations with locatedBlockCount() * repl_factor
name|LocatedBlocks
name|blks
init|=
operator|(
operator|(
name|HdfsLocatedFileStatus
operator|)
name|listing
index|[
name|i
index|]
operator|)
operator|.
name|getBlockLocations
argument_list|()
decl_stmt|;
name|locationBudget
operator|-=
operator|(
name|blks
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|blks
operator|.
name|locatedBlockCount
argument_list|()
operator|*
name|listing
index|[
name|i
index|]
operator|.
name|getReplication
argument_list|()
expr_stmt|;
block|}
block|}
comment|// truncate return array if necessary
if|if
condition|(
name|listingCnt
operator|<
name|numOfListing
condition|)
block|{
name|listing
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|listing
argument_list|,
name|listingCnt
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DirectoryListing
argument_list|(
name|listing
argument_list|,
name|totalNumChildren
operator|-
name|startChild
operator|-
name|listingCnt
argument_list|)
return|;
block|}
finally|finally
block|{
name|fsd
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get a listing of all the snapshots of a snapshottable directory    */
DECL|method|getSnapshotsListing ( FSDirectory fsd, INodesInPath iip, byte[] startAfter)
specifier|private
specifier|static
name|DirectoryListing
name|getSnapshotsListing
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|byte
index|[]
name|startAfter
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|fsd
operator|.
name|hasReadLock
argument_list|()
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|iip
operator|.
name|isDotSnapshotDir
argument_list|()
argument_list|,
literal|"%s does not end with %s"
argument_list|,
name|iip
operator|.
name|getPath
argument_list|()
argument_list|,
name|HdfsConstants
operator|.
name|SEPARATOR_DOT_SNAPSHOT_DIR
argument_list|)
expr_stmt|;
comment|// drop off the null .snapshot component
name|iip
operator|=
name|iip
operator|.
name|getParentINodesInPath
argument_list|()
expr_stmt|;
specifier|final
name|String
name|dirPath
init|=
name|iip
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|INode
name|node
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|INodeDirectory
name|dirNode
init|=
name|INodeDirectory
operator|.
name|valueOf
argument_list|(
name|node
argument_list|,
name|dirPath
argument_list|)
decl_stmt|;
specifier|final
name|DirectorySnapshottableFeature
name|sf
init|=
name|dirNode
operator|.
name|getDirectorySnapshottableFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
literal|"Directory is not a snapshottable directory: "
operator|+
name|dirPath
argument_list|)
throw|;
block|}
specifier|final
name|ReadOnlyList
argument_list|<
name|Snapshot
argument_list|>
name|snapshots
init|=
name|sf
operator|.
name|getSnapshotList
argument_list|()
decl_stmt|;
name|int
name|skipSize
init|=
name|ReadOnlyList
operator|.
name|Util
operator|.
name|binarySearch
argument_list|(
name|snapshots
argument_list|,
name|startAfter
argument_list|)
decl_stmt|;
name|skipSize
operator|=
name|skipSize
operator|<
literal|0
condition|?
operator|-
name|skipSize
operator|-
literal|1
else|:
name|skipSize
operator|+
literal|1
expr_stmt|;
name|int
name|numOfListing
init|=
name|Math
operator|.
name|min
argument_list|(
name|snapshots
operator|.
name|size
argument_list|()
operator|-
name|skipSize
argument_list|,
name|fsd
operator|.
name|getLsLimit
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|HdfsFileStatus
name|listing
index|[]
init|=
operator|new
name|HdfsFileStatus
index|[
name|numOfListing
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfListing
condition|;
name|i
operator|++
control|)
block|{
name|Snapshot
operator|.
name|Root
name|sRoot
init|=
name|snapshots
operator|.
name|get
argument_list|(
name|i
operator|+
name|skipSize
argument_list|)
operator|.
name|getRoot
argument_list|()
decl_stmt|;
name|listing
index|[
name|i
index|]
operator|=
name|createFileStatus
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
name|sRoot
argument_list|,
name|HdfsConstants
operator|.
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DirectoryListing
argument_list|(
name|listing
argument_list|,
name|snapshots
operator|.
name|size
argument_list|()
operator|-
name|skipSize
operator|-
name|numOfListing
argument_list|)
return|;
block|}
comment|/**    * Get a listing of the /.reserved directory.    * @param fsd FSDirectory    * @return listing containing child directories of /.reserved    */
DECL|method|getReservedListing (FSDirectory fsd)
specifier|private
specifier|static
name|DirectoryListing
name|getReservedListing
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|)
block|{
return|return
operator|new
name|DirectoryListing
argument_list|(
name|fsd
operator|.
name|getReservedStatuses
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/** Get the file info for a specific file.    * @param fsd FSDirectory    * @param iip The path to the file, the file is included    * @param includeStoragePolicy whether to include storage policy    * @return object containing information regarding the file    *         or null if file not found    */
DECL|method|getFileInfo (FSDirectory fsd, INodesInPath iip, boolean includeStoragePolicy)
specifier|static
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|boolean
name|includeStoragePolicy
parameter_list|)
throws|throws
name|IOException
block|{
name|fsd
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|INode
name|node
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|byte
name|policy
init|=
operator|(
name|includeStoragePolicy
operator|&&
operator|!
name|node
operator|.
name|isSymlink
argument_list|()
operator|)
condition|?
name|node
operator|.
name|getStoragePolicyID
argument_list|()
else|:
name|HdfsConstants
operator|.
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
decl_stmt|;
return|return
name|createFileStatus
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
literal|null
argument_list|,
name|policy
argument_list|,
literal|false
argument_list|)
return|;
block|}
finally|finally
block|{
name|fsd
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getFileInfo (FSDirectory fsd, INodesInPath iip)
specifier|static
name|HdfsFileStatus
name|getFileInfo
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
name|fsd
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|HdfsFileStatus
name|status
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|FSDirectory
operator|.
name|isExactReservedName
argument_list|(
name|iip
operator|.
name|getPathComponents
argument_list|()
argument_list|)
condition|)
block|{
name|status
operator|=
name|FSDirectory
operator|.
name|DOT_RESERVED_STATUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iip
operator|.
name|isDotSnapshotDir
argument_list|()
condition|)
block|{
if|if
condition|(
name|fsd
operator|.
name|getINode4DotSnapshot
argument_list|(
name|iip
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|status
operator|=
name|FSDirectory
operator|.
name|DOT_SNAPSHOT_DIR_STATUS
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|=
name|getFileInfo
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
finally|finally
block|{
name|fsd
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * create a hdfs file status from an iip.    * @param fsd FSDirectory    * @param iip The INodesInPath containing the INodeFile and its ancestors    * @return HdfsFileStatus without locations or storage policy    */
DECL|method|createFileStatusForEditLog ( FSDirectory fsd, INodesInPath iip)
specifier|static
name|HdfsFileStatus
name|createFileStatusForEditLog
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createFileStatus
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|,
literal|null
argument_list|,
name|HdfsConstants
operator|.
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * create a hdfs file status from an iip.    *    * @param fsd FSDirectory    * @param iip The INodesInPath containing the INodeFile and its ancestors.    * @param child for a directory listing of the iip, else null    * @param storagePolicy for the path or closest ancestor    * @param needLocation if block locations need to be included or not    * @param includeStoragePolicy if storage policy should be returned    * @return a file status    * @throws java.io.IOException if any error occurs    */
DECL|method|createFileStatus ( FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy, boolean needLocation)
specifier|private
specifier|static
name|HdfsFileStatus
name|createFileStatus
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|INode
name|child
parameter_list|,
name|byte
name|storagePolicy
parameter_list|,
name|boolean
name|needLocation
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fsd
operator|.
name|hasReadLock
argument_list|()
assert|;
comment|// only directory listing sets the status name.
name|byte
index|[]
name|name
init|=
name|HdfsFileStatus
operator|.
name|EMPTY_NAME
decl_stmt|;
if|if
condition|(
name|child
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|child
operator|.
name|getLocalNameBytes
argument_list|()
expr_stmt|;
comment|// have to do this for EC and EZ lookups...
name|iip
operator|=
name|INodesInPath
operator|.
name|append
argument_list|(
name|iip
argument_list|,
name|child
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|long
name|size
init|=
literal|0
decl_stmt|;
comment|// length is zero for directories
name|short
name|replication
init|=
literal|0
decl_stmt|;
name|long
name|blocksize
init|=
literal|0
decl_stmt|;
specifier|final
name|INode
name|node
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
specifier|final
name|int
name|snapshot
init|=
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
decl_stmt|;
name|LocatedBlocks
name|loc
init|=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|isEncrypted
init|=
name|FSDirEncryptionZoneOp
operator|.
name|isInAnEZ
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|)
decl_stmt|;
name|FileEncryptionInfo
name|feInfo
init|=
literal|null
decl_stmt|;
specifier|final
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|FSDirErasureCodingOp
operator|.
name|getErasureCodingPolicy
argument_list|(
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
argument_list|,
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isFile
argument_list|()
condition|)
block|{
specifier|final
name|INodeFile
name|fileNode
init|=
name|node
operator|.
name|asFile
argument_list|()
decl_stmt|;
name|size
operator|=
name|fileNode
operator|.
name|computeFileSize
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|replication
operator|=
name|fileNode
operator|.
name|getFileReplication
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|fileNode
operator|.
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEncrypted
condition|)
block|{
name|feInfo
operator|=
name|FSDirEncryptionZoneOp
operator|.
name|getFileEncryptionInfo
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needLocation
condition|)
block|{
specifier|final
name|boolean
name|inSnapshot
init|=
name|snapshot
operator|!=
name|Snapshot
operator|.
name|CURRENT_STATE_ID
decl_stmt|;
specifier|final
name|boolean
name|isUc
init|=
operator|!
name|inSnapshot
operator|&&
name|fileNode
operator|.
name|isUnderConstruction
argument_list|()
decl_stmt|;
specifier|final
name|long
name|fileSize
init|=
operator|!
name|inSnapshot
operator|&&
name|isUc
condition|?
name|fileNode
operator|.
name|computeFileSizeNotIncludingLastUcBlock
argument_list|()
else|:
name|size
decl_stmt|;
name|loc
operator|=
name|fsd
operator|.
name|getBlockManager
argument_list|()
operator|.
name|createLocatedBlocks
argument_list|(
name|fileNode
operator|.
name|getBlocks
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|fileSize
argument_list|,
name|isUc
argument_list|,
literal|0L
argument_list|,
name|size
argument_list|,
literal|false
argument_list|,
name|inSnapshot
argument_list|,
name|feInfo
argument_list|,
name|ecPolicy
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
literal|null
condition|)
block|{
name|loc
operator|=
operator|new
name|LocatedBlocks
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|int
name|childrenNum
init|=
name|node
operator|.
name|isDirectory
argument_list|()
condition|?
name|node
operator|.
name|asDirectory
argument_list|()
operator|.
name|getChildrenNum
argument_list|(
name|snapshot
argument_list|)
else|:
literal|0
decl_stmt|;
name|INodeAttributes
name|nodeAttrs
init|=
name|fsd
operator|.
name|getAttributes
argument_list|(
name|iip
argument_list|)
decl_stmt|;
return|return
name|createFileStatus
argument_list|(
name|size
argument_list|,
name|node
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|node
operator|.
name|getModificationTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|node
operator|.
name|getAccessTime
argument_list|(
name|snapshot
argument_list|)
argument_list|,
name|getPermissionForFileStatus
argument_list|(
name|nodeAttrs
argument_list|,
name|isEncrypted
argument_list|)
argument_list|,
name|nodeAttrs
operator|.
name|getUserName
argument_list|()
argument_list|,
name|nodeAttrs
operator|.
name|getGroupName
argument_list|()
argument_list|,
name|node
operator|.
name|isSymlink
argument_list|()
condition|?
name|node
operator|.
name|asSymlink
argument_list|()
operator|.
name|getSymlink
argument_list|()
else|:
literal|null
argument_list|,
name|name
argument_list|,
name|node
operator|.
name|getId
argument_list|()
argument_list|,
name|childrenNum
argument_list|,
name|feInfo
argument_list|,
name|storagePolicy
argument_list|,
name|ecPolicy
argument_list|,
name|loc
argument_list|)
return|;
block|}
DECL|method|createFileStatus (long length, boolean isdir, int replication, long blocksize, long mtime, long atime, FsPermission permission, String owner, String group, byte[] symlink, byte[] path, long fileId, int childrenNum, FileEncryptionInfo feInfo, byte storagePolicy, ErasureCodingPolicy ecPolicy, LocatedBlocks locations)
specifier|private
specifier|static
name|HdfsFileStatus
name|createFileStatus
parameter_list|(
name|long
name|length
parameter_list|,
name|boolean
name|isdir
parameter_list|,
name|int
name|replication
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|String
name|owner
parameter_list|,
name|String
name|group
parameter_list|,
name|byte
index|[]
name|symlink
parameter_list|,
name|byte
index|[]
name|path
parameter_list|,
name|long
name|fileId
parameter_list|,
name|int
name|childrenNum
parameter_list|,
name|FileEncryptionInfo
name|feInfo
parameter_list|,
name|byte
name|storagePolicy
parameter_list|,
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
name|LocatedBlocks
name|locations
parameter_list|)
block|{
if|if
condition|(
name|locations
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|HdfsFileStatus
argument_list|(
name|length
argument_list|,
name|isdir
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|permission
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|symlink
argument_list|,
name|path
argument_list|,
name|fileId
argument_list|,
name|childrenNum
argument_list|,
name|feInfo
argument_list|,
name|storagePolicy
argument_list|,
name|ecPolicy
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|HdfsLocatedFileStatus
argument_list|(
name|length
argument_list|,
name|isdir
argument_list|,
name|replication
argument_list|,
name|blocksize
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|permission
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|symlink
argument_list|,
name|path
argument_list|,
name|fileId
argument_list|,
name|locations
argument_list|,
name|childrenNum
argument_list|,
name|feInfo
argument_list|,
name|storagePolicy
argument_list|,
name|ecPolicy
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns an inode's FsPermission for use in an outbound FileStatus.  If the    * inode has an ACL or is for an encrypted file/dir, then this method will    * return an FsPermissionExtension.    *    * @param node INode to check    * @param isEncrypted boolean true if the file/dir is encrypted    * @return FsPermission from inode, with ACL bit on if the inode has an ACL    * and encrypted bit on if it represents an encrypted file/dir.    */
DECL|method|getPermissionForFileStatus ( INodeAttributes node, boolean isEncrypted)
specifier|private
specifier|static
name|FsPermission
name|getPermissionForFileStatus
parameter_list|(
name|INodeAttributes
name|node
parameter_list|,
name|boolean
name|isEncrypted
parameter_list|)
block|{
name|FsPermission
name|perm
init|=
name|node
operator|.
name|getFsPermission
argument_list|()
decl_stmt|;
name|boolean
name|hasAcl
init|=
name|node
operator|.
name|getAclFeature
argument_list|()
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|hasAcl
operator|||
name|isEncrypted
condition|)
block|{
name|perm
operator|=
operator|new
name|FsPermissionExtension
argument_list|(
name|perm
argument_list|,
name|hasAcl
argument_list|,
name|isEncrypted
argument_list|)
expr_stmt|;
block|}
return|return
name|perm
return|;
block|}
DECL|method|getContentSummaryInt (FSDirectory fsd, INodesInPath iip)
specifier|private
specifier|static
name|ContentSummary
name|getContentSummaryInt
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
name|fsd
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|targetNode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|iip
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
comment|// Make it relinquish locks everytime contentCountLimit entries are
comment|// processed. 0 means disabled. I.e. blocking for the entire duration.
name|ContentSummaryComputationContext
name|cscc
init|=
operator|new
name|ContentSummaryComputationContext
argument_list|(
name|fsd
argument_list|,
name|fsd
operator|.
name|getFSNamesystem
argument_list|()
argument_list|,
name|fsd
operator|.
name|getContentCountLimit
argument_list|()
argument_list|,
name|fsd
operator|.
name|getContentSleepMicroSec
argument_list|()
argument_list|)
decl_stmt|;
name|ContentSummary
name|cs
init|=
name|targetNode
operator|.
name|computeAndConvertContentSummary
argument_list|(
name|iip
operator|.
name|getPathSnapshotId
argument_list|()
argument_list|,
name|cscc
argument_list|)
decl_stmt|;
name|fsd
operator|.
name|addYieldCount
argument_list|(
name|cscc
operator|.
name|getYieldCount
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|cs
return|;
block|}
block|}
finally|finally
block|{
name|fsd
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getQuotaUsage ( FSDirectory fsd, String src)
specifier|static
name|QuotaUsage
name|getQuotaUsage
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|String
name|src
parameter_list|)
throws|throws
name|IOException
block|{
name|FSPermissionChecker
name|pc
init|=
name|fsd
operator|.
name|getPermissionChecker
argument_list|()
decl_stmt|;
specifier|final
name|INodesInPath
name|iip
decl_stmt|;
name|fsd
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|iip
operator|=
name|fsd
operator|.
name|resolvePath
argument_list|(
name|pc
argument_list|,
name|src
argument_list|,
name|DirOp
operator|.
name|READ_LINK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsd
operator|.
name|isPermissionEnabled
argument_list|()
condition|)
block|{
name|fsd
operator|.
name|checkPermission
argument_list|(
name|pc
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|FsAction
operator|.
name|READ_EXECUTE
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|fsd
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
name|QuotaUsage
name|usage
init|=
name|getQuotaUsageInt
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|)
decl_stmt|;
if|if
condition|(
name|usage
operator|!=
literal|null
condition|)
block|{
return|return
name|usage
return|;
block|}
else|else
block|{
comment|//If quota isn't set, fall back to getContentSummary.
return|return
name|getContentSummaryInt
argument_list|(
name|fsd
argument_list|,
name|iip
argument_list|)
return|;
block|}
block|}
DECL|method|getQuotaUsageInt (FSDirectory fsd, INodesInPath iip)
specifier|private
specifier|static
name|QuotaUsage
name|getQuotaUsageInt
parameter_list|(
name|FSDirectory
name|fsd
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
name|fsd
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|INode
name|targetNode
init|=
name|iip
operator|.
name|getLastINode
argument_list|()
decl_stmt|;
name|QuotaUsage
name|usage
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|targetNode
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|DirectoryWithQuotaFeature
name|feature
init|=
name|targetNode
operator|.
name|asDirectory
argument_list|()
operator|.
name|getDirectoryWithQuotaFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|feature
operator|!=
literal|null
condition|)
block|{
name|QuotaCounts
name|counts
init|=
name|feature
operator|.
name|getSpaceConsumed
argument_list|()
decl_stmt|;
name|QuotaCounts
name|quotas
init|=
name|feature
operator|.
name|getQuota
argument_list|()
decl_stmt|;
name|usage
operator|=
operator|new
name|QuotaUsage
operator|.
name|Builder
argument_list|()
operator|.
name|fileAndDirectoryCount
argument_list|(
name|counts
operator|.
name|getNameSpace
argument_list|()
argument_list|)
operator|.
name|quota
argument_list|(
name|quotas
operator|.
name|getNameSpace
argument_list|()
argument_list|)
operator|.
name|spaceConsumed
argument_list|(
name|counts
operator|.
name|getStorageSpace
argument_list|()
argument_list|)
operator|.
name|spaceQuota
argument_list|(
name|quotas
operator|.
name|getStorageSpace
argument_list|()
argument_list|)
operator|.
name|typeConsumed
argument_list|(
name|counts
operator|.
name|getTypeSpaces
argument_list|()
operator|.
name|asArray
argument_list|()
argument_list|)
operator|.
name|typeQuota
argument_list|(
name|quotas
operator|.
name|getTypeSpaces
argument_list|()
operator|.
name|asArray
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|usage
return|;
block|}
finally|finally
block|{
name|fsd
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|GetBlockLocationsResult
specifier|static
class|class
name|GetBlockLocationsResult
block|{
DECL|field|updateAccessTime
specifier|final
name|boolean
name|updateAccessTime
decl_stmt|;
DECL|field|blocks
specifier|final
name|LocatedBlocks
name|blocks
decl_stmt|;
DECL|method|updateAccessTime ()
name|boolean
name|updateAccessTime
parameter_list|()
block|{
return|return
name|updateAccessTime
return|;
block|}
DECL|method|GetBlockLocationsResult ( boolean updateAccessTime, LocatedBlocks blocks)
specifier|private
name|GetBlockLocationsResult
parameter_list|(
name|boolean
name|updateAccessTime
parameter_list|,
name|LocatedBlocks
name|blocks
parameter_list|)
block|{
name|this
operator|.
name|updateAccessTime
operator|=
name|updateAccessTime
expr_stmt|;
name|this
operator|.
name|blocks
operator|=
name|blocks
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

