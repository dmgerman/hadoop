begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
operator|.
name|BlockReportIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnregisteredNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
operator|.
name|AccessMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|ExportedBlockKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSClusterStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodeFileUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|Namesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
operator|.
name|BlockWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|KeyUpdateCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReceivedDeletedBlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LightWeightLinkedSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Keeps information related to the blocks stored in the Hadoop cluster.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockManager
specifier|public
class|class
name|BlockManager
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BlockManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Default load factor of map */
DECL|field|DEFAULT_MAP_LOAD_FACTOR
specifier|public
specifier|static
specifier|final
name|float
name|DEFAULT_MAP_LOAD_FACTOR
init|=
literal|0.75f
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|Namesystem
name|namesystem
decl_stmt|;
DECL|field|datanodeManager
specifier|private
specifier|final
name|DatanodeManager
name|datanodeManager
decl_stmt|;
DECL|field|heartbeatManager
specifier|private
specifier|final
name|HeartbeatManager
name|heartbeatManager
decl_stmt|;
DECL|field|blockTokenSecretManager
specifier|private
specifier|final
name|BlockTokenSecretManager
name|blockTokenSecretManager
decl_stmt|;
DECL|field|pendingReplicationBlocksCount
specifier|private
specifier|volatile
name|long
name|pendingReplicationBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|corruptReplicaBlocksCount
specifier|private
specifier|volatile
name|long
name|corruptReplicaBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|underReplicatedBlocksCount
specifier|private
specifier|volatile
name|long
name|underReplicatedBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|scheduledReplicationBlocksCount
specifier|private
specifier|volatile
name|long
name|scheduledReplicationBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|excessBlocksCount
specifier|private
specifier|volatile
name|long
name|excessBlocksCount
init|=
literal|0L
decl_stmt|;
comment|/** Used by metrics */
DECL|method|getPendingReplicationBlocksCount ()
specifier|public
name|long
name|getPendingReplicationBlocksCount
parameter_list|()
block|{
return|return
name|pendingReplicationBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getUnderReplicatedBlocksCount ()
specifier|public
name|long
name|getUnderReplicatedBlocksCount
parameter_list|()
block|{
return|return
name|underReplicatedBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getCorruptReplicaBlocksCount ()
specifier|public
name|long
name|getCorruptReplicaBlocksCount
parameter_list|()
block|{
return|return
name|corruptReplicaBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getScheduledReplicationBlocksCount ()
specifier|public
name|long
name|getScheduledReplicationBlocksCount
parameter_list|()
block|{
return|return
name|scheduledReplicationBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getPendingDeletionBlocksCount ()
specifier|public
name|long
name|getPendingDeletionBlocksCount
parameter_list|()
block|{
return|return
name|invalidateBlocks
operator|.
name|numBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics */
DECL|method|getExcessBlocksCount ()
specifier|public
name|long
name|getExcessBlocksCount
parameter_list|()
block|{
return|return
name|excessBlocksCount
return|;
block|}
comment|/**replicationRecheckInterval is how often namenode checks for new replication work*/
DECL|field|replicationRecheckInterval
specifier|private
specifier|final
name|long
name|replicationRecheckInterval
decl_stmt|;
comment|/**    * Mapping: Block -> { INode, datanodes, self ref }    * Updated only in response to client-sent information.    */
DECL|field|blocksMap
specifier|final
name|BlocksMap
name|blocksMap
decl_stmt|;
comment|/** Replication thread. */
DECL|field|replicationThread
specifier|final
name|Daemon
name|replicationThread
init|=
operator|new
name|Daemon
argument_list|(
operator|new
name|ReplicationMonitor
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Store blocks -> datanodedescriptor(s) map of corrupt replicas */
DECL|field|corruptReplicas
specifier|final
name|CorruptReplicasMap
name|corruptReplicas
init|=
operator|new
name|CorruptReplicasMap
argument_list|()
decl_stmt|;
comment|/** Blocks to be invalidated. */
DECL|field|invalidateBlocks
specifier|private
specifier|final
name|InvalidateBlocks
name|invalidateBlocks
decl_stmt|;
comment|//
comment|// Keeps a TreeSet for every named node. Each treeset contains
comment|// a list of the blocks that are "extra" at that location. We'll
comment|// eventually remove these extras.
comment|// Mapping: StorageID -> TreeSet<Block>
comment|//
DECL|field|excessReplicateMap
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
argument_list|>
name|excessReplicateMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|//
comment|// Store set of Blocks that need to be replicated 1 or more times.
comment|// We also store pending replication-orders.
comment|//
DECL|field|neededReplications
specifier|public
specifier|final
name|UnderReplicatedBlocks
name|neededReplications
init|=
operator|new
name|UnderReplicatedBlocks
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|pendingReplications
specifier|final
name|PendingReplicationBlocks
name|pendingReplications
decl_stmt|;
comment|/** The maximum number of replicas allowed for a block */
DECL|field|maxReplication
specifier|public
specifier|final
name|short
name|maxReplication
decl_stmt|;
comment|/** The maximum number of outgoing replication streams    *  a given node should have at one time     */
DECL|field|maxReplicationStreams
name|int
name|maxReplicationStreams
decl_stmt|;
comment|/** Minimum copies needed or else write is disallowed */
DECL|field|minReplication
specifier|public
specifier|final
name|short
name|minReplication
decl_stmt|;
comment|/** Default number of replicas */
DECL|field|defaultReplication
specifier|public
specifier|final
name|int
name|defaultReplication
decl_stmt|;
comment|/** The maximum number of entries returned by getCorruptInodes() */
DECL|field|maxCorruptFilesReturned
specifier|final
name|int
name|maxCorruptFilesReturned
decl_stmt|;
comment|/** variable to enable check for enough racks */
DECL|field|shouldCheckForEnoughRacks
specifier|final
name|boolean
name|shouldCheckForEnoughRacks
decl_stmt|;
comment|/** Last block index used for replication work. */
DECL|field|replIndex
specifier|private
name|int
name|replIndex
init|=
literal|0
decl_stmt|;
comment|/** for block replicas placement */
DECL|field|blockplacement
specifier|private
name|BlockPlacementPolicy
name|blockplacement
decl_stmt|;
DECL|method|BlockManager (final Namesystem namesystem, final FSClusterStats stats, final Configuration conf)
specifier|public
name|BlockManager
parameter_list|(
specifier|final
name|Namesystem
name|namesystem
parameter_list|,
specifier|final
name|FSClusterStats
name|stats
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
name|datanodeManager
operator|=
operator|new
name|DatanodeManager
argument_list|(
name|this
argument_list|,
name|namesystem
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|heartbeatManager
operator|=
name|datanodeManager
operator|.
name|getHeartbeatManager
argument_list|()
expr_stmt|;
name|invalidateBlocks
operator|=
operator|new
name|InvalidateBlocks
argument_list|(
name|datanodeManager
argument_list|)
expr_stmt|;
name|blocksMap
operator|=
operator|new
name|BlocksMap
argument_list|(
name|DEFAULT_MAP_LOAD_FACTOR
argument_list|)
expr_stmt|;
name|blockplacement
operator|=
name|BlockPlacementPolicy
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
name|stats
argument_list|,
name|datanodeManager
operator|.
name|getNetworkTopology
argument_list|()
argument_list|)
expr_stmt|;
name|pendingReplications
operator|=
operator|new
name|PendingReplicationBlocks
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_DEFAULT
argument_list|)
operator|*
literal|1000L
argument_list|)
expr_stmt|;
name|blockTokenSecretManager
operator|=
name|createBlockTokenSecretManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxCorruptFilesReturned
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DEFAULT_MAX_CORRUPT_FILES_RETURNED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DEFAULT_MAX_CORRUPT_FILES_RETURNED
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_DEFAULT
argument_list|)
expr_stmt|;
specifier|final
name|int
name|maxR
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minR
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|minR
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
operator|+
literal|" = "
operator|+
name|minR
operator|+
literal|"<= 0"
argument_list|)
throw|;
if|if
condition|(
name|maxR
operator|>
name|Short
operator|.
name|MAX_VALUE
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_KEY
operator|+
literal|" = "
operator|+
name|maxR
operator|+
literal|"> "
operator|+
name|Short
operator|.
name|MAX_VALUE
argument_list|)
throw|;
if|if
condition|(
name|minR
operator|>
name|maxR
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
operator|+
literal|" = "
operator|+
name|minR
operator|+
literal|"> "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_KEY
operator|+
literal|" = "
operator|+
name|maxR
argument_list|)
throw|;
name|this
operator|.
name|minReplication
operator|=
operator|(
name|short
operator|)
name|minR
expr_stmt|;
name|this
operator|.
name|maxReplication
operator|=
operator|(
name|short
operator|)
name|maxR
expr_stmt|;
name|this
operator|.
name|maxReplicationStreams
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MAX_STREAMS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MAX_STREAMS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|shouldCheckForEnoughRacks
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY
argument_list|)
operator|==
literal|null
condition|?
literal|false
else|:
literal|true
expr_stmt|;
name|this
operator|.
name|replicationRecheckInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT
argument_list|)
operator|*
literal|1000L
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"defaultReplication = "
operator|+
name|defaultReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"maxReplication     = "
operator|+
name|maxReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"minReplication     = "
operator|+
name|minReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"maxReplicationStreams      = "
operator|+
name|maxReplicationStreams
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"shouldCheckForEnoughRacks  = "
operator|+
name|shouldCheckForEnoughRacks
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"replicationRecheckInterval = "
operator|+
name|replicationRecheckInterval
argument_list|)
expr_stmt|;
block|}
DECL|method|createBlockTokenSecretManager ( final Configuration conf)
specifier|private
specifier|static
name|BlockTokenSecretManager
name|createBlockTokenSecretManager
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|isEnabled
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY
operator|+
literal|"="
operator|+
name|isEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isEnabled
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|updateMin
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|long
name|lifetimeMin
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY
operator|+
literal|"="
operator|+
name|updateMin
operator|+
literal|" min(s), "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY
operator|+
literal|"="
operator|+
name|lifetimeMin
operator|+
literal|" min(s)"
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlockTokenSecretManager
argument_list|(
literal|true
argument_list|,
name|updateMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|,
name|lifetimeMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|)
return|;
block|}
comment|/** get the BlockTokenSecretManager */
DECL|method|getBlockTokenSecretManager ()
name|BlockTokenSecretManager
name|getBlockTokenSecretManager
parameter_list|()
block|{
return|return
name|blockTokenSecretManager
return|;
block|}
DECL|method|isBlockTokenEnabled ()
specifier|private
name|boolean
name|isBlockTokenEnabled
parameter_list|()
block|{
return|return
name|blockTokenSecretManager
operator|!=
literal|null
return|;
block|}
comment|/** Should the access keys be updated? */
DECL|method|shouldUpdateBlockKey (final long updateTime)
name|boolean
name|shouldUpdateBlockKey
parameter_list|(
specifier|final
name|long
name|updateTime
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isBlockTokenEnabled
argument_list|()
condition|?
name|blockTokenSecretManager
operator|.
name|updateKeys
argument_list|(
name|updateTime
argument_list|)
else|:
literal|false
return|;
block|}
DECL|method|activate (Configuration conf)
specifier|public
name|void
name|activate
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|pendingReplications
operator|.
name|start
argument_list|()
expr_stmt|;
name|datanodeManager
operator|.
name|activate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|replicationThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|pendingReplications
operator|!=
literal|null
condition|)
name|pendingReplications
operator|.
name|stop
argument_list|()
expr_stmt|;
name|blocksMap
operator|.
name|close
argument_list|()
expr_stmt|;
name|datanodeManager
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|replicationThread
operator|!=
literal|null
condition|)
name|replicationThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|/** @return the datanodeManager */
DECL|method|getDatanodeManager ()
specifier|public
name|DatanodeManager
name|getDatanodeManager
parameter_list|()
block|{
return|return
name|datanodeManager
return|;
block|}
comment|/** @return the BlockPlacementPolicy */
DECL|method|getBlockPlacementPolicy ()
specifier|public
name|BlockPlacementPolicy
name|getBlockPlacementPolicy
parameter_list|()
block|{
return|return
name|blockplacement
return|;
block|}
comment|/** Set BlockPlacementPolicy */
DECL|method|setBlockPlacementPolicy (BlockPlacementPolicy newpolicy)
specifier|public
name|void
name|setBlockPlacementPolicy
parameter_list|(
name|BlockPlacementPolicy
name|newpolicy
parameter_list|)
block|{
if|if
condition|(
name|newpolicy
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"newpolicy == null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|blockplacement
operator|=
name|newpolicy
expr_stmt|;
block|}
comment|/** Dump meta data to out. */
DECL|method|metaSave (PrintWriter out)
specifier|public
name|void
name|metaSave
parameter_list|(
name|PrintWriter
name|out
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|datanodeManager
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
name|dead
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Live Datanodes: "
operator|+
name|live
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Dead Datanodes: "
operator|+
name|dead
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|//
comment|// Dump contents of neededReplication
comment|//
synchronized|synchronized
init|(
name|neededReplications
init|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"Metasave: Blocks waiting for replication: "
operator|+
name|neededReplications
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|neededReplications
control|)
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingLiveReplicasNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|NumberReplicas
name|numReplicas
init|=
operator|new
name|NumberReplicas
argument_list|()
decl_stmt|;
comment|// source node returned is not used
name|chooseSourceDatanode
argument_list|(
name|block
argument_list|,
name|containingNodes
argument_list|,
name|containingLiveReplicasNodes
argument_list|,
name|numReplicas
argument_list|)
expr_stmt|;
assert|assert
name|containingLiveReplicasNodes
operator|.
name|size
argument_list|()
operator|==
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
assert|;
name|int
name|usableReplicas
init|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|numReplicas
operator|.
name|decommissionedReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|instanceof
name|BlockInfo
condition|)
block|{
name|String
name|fileName
init|=
operator|(
operator|(
name|BlockInfo
operator|)
name|block
operator|)
operator|.
name|getINode
argument_list|()
operator|.
name|getFullPathName
argument_list|()
decl_stmt|;
name|out
operator|.
name|print
argument_list|(
name|fileName
operator|+
literal|": "
argument_list|)
expr_stmt|;
block|}
comment|// l: == live:, d: == decommissioned c: == corrupt e: == excess
name|out
operator|.
name|print
argument_list|(
name|block
operator|+
operator|(
operator|(
name|usableReplicas
operator|>
literal|0
operator|)
condition|?
literal|""
else|:
literal|" MISSING"
operator|)
operator|+
literal|" (replicas:"
operator|+
literal|" l: "
operator|+
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
literal|" d: "
operator|+
name|numReplicas
operator|.
name|decommissionedReplicas
argument_list|()
operator|+
literal|" c: "
operator|+
name|numReplicas
operator|.
name|corruptReplicas
argument_list|()
operator|+
literal|" e: "
operator|+
name|numReplicas
operator|.
name|excessReplicas
argument_list|()
operator|+
literal|") "
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|jt
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|block
argument_list|)
init|;
name|jt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|jt
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|state
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|corruptNodes
operator|!=
literal|null
operator|&&
name|corruptNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|state
operator|=
literal|"(corrupt)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissioned
argument_list|()
operator|||
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
name|state
operator|=
literal|"(decommissioned)"
expr_stmt|;
block|}
name|out
operator|.
name|print
argument_list|(
literal|" "
operator|+
name|node
operator|+
name|state
operator|+
literal|" : "
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Dump blocks from pendingReplication
name|pendingReplications
operator|.
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// Dump blocks that are waiting to be deleted
name|invalidateBlocks
operator|.
name|dump
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// Dump all datanodes
name|getDatanodeManager
argument_list|()
operator|.
name|datanodeDump
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/** @return maxReplicationStreams */
DECL|method|getMaxReplicationStreams ()
specifier|public
name|int
name|getMaxReplicationStreams
parameter_list|()
block|{
return|return
name|maxReplicationStreams
return|;
block|}
comment|/**    * @param block    * @return true if the block has minimum replicas    */
DECL|method|checkMinReplication (Block block)
specifier|public
name|boolean
name|checkMinReplication
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
operator|(
name|countNodes
argument_list|(
name|block
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|minReplication
operator|)
return|;
block|}
comment|/**    * Commit a block of a file    *     * @param block block to be committed    * @param commitBlock - contains client reported block length and generation    * @return true if the block is changed to committed state.    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|commitBlock (final BlockInfoUnderConstruction block, final Block commitBlock)
specifier|private
name|boolean
name|commitBlock
parameter_list|(
specifier|final
name|BlockInfoUnderConstruction
name|block
parameter_list|,
specifier|final
name|Block
name|commitBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|block
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|COMMITTED
condition|)
return|return
literal|false
return|;
assert|assert
name|block
operator|.
name|getNumBytes
argument_list|()
operator|<=
name|commitBlock
operator|.
name|getNumBytes
argument_list|()
operator|:
literal|"commitBlock length is less than the stored one "
operator|+
name|commitBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" vs. "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
assert|;
name|block
operator|.
name|commitBlock
argument_list|(
name|commitBlock
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Commit the last block of the file and mark it as complete if it has    * meets the minimum replication requirement    *     * @param fileINode file inode    * @param commitBlock - contains client reported block length and generation    * @return true if the last block is changed to committed state.    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|commitOrCompleteLastBlock (INodeFileUnderConstruction fileINode, Block commitBlock)
specifier|public
name|boolean
name|commitOrCompleteLastBlock
parameter_list|(
name|INodeFileUnderConstruction
name|fileINode
parameter_list|,
name|Block
name|commitBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|commitBlock
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// not committing, this is a block allocation retry
name|BlockInfo
name|lastBlock
init|=
name|fileINode
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// no blocks in file yet
if|if
condition|(
name|lastBlock
operator|.
name|isComplete
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// already completed (e.g. by syncBlock)
specifier|final
name|boolean
name|b
init|=
name|commitBlock
argument_list|(
operator|(
name|BlockInfoUnderConstruction
operator|)
name|lastBlock
argument_list|,
name|commitBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|countNodes
argument_list|(
name|lastBlock
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|minReplication
condition|)
name|completeBlock
argument_list|(
name|fileINode
argument_list|,
name|fileINode
operator|.
name|numBlocks
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/**    * Convert a specified block of the file to a complete block.    * @param fileINode file    * @param blkIndex  block index in the file    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|completeBlock (final INodeFile fileINode, final int blkIndex)
specifier|private
name|BlockInfo
name|completeBlock
parameter_list|(
specifier|final
name|INodeFile
name|fileINode
parameter_list|,
specifier|final
name|int
name|blkIndex
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blkIndex
operator|<
literal|0
condition|)
return|return
literal|null
return|;
name|BlockInfo
name|curBlock
init|=
name|fileINode
operator|.
name|getBlocks
argument_list|()
index|[
name|blkIndex
index|]
decl_stmt|;
if|if
condition|(
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
return|return
name|curBlock
return|;
name|BlockInfoUnderConstruction
name|ucBlock
init|=
operator|(
name|BlockInfoUnderConstruction
operator|)
name|curBlock
decl_stmt|;
if|if
condition|(
name|ucBlock
operator|.
name|numNodes
argument_list|()
operator|<
name|minReplication
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot complete block: "
operator|+
literal|"block does not satisfy minimal replication requirement."
argument_list|)
throw|;
name|BlockInfo
name|completeBlock
init|=
name|ucBlock
operator|.
name|convertToCompleteBlock
argument_list|()
decl_stmt|;
comment|// replace penultimate block in file
name|fileINode
operator|.
name|setBlock
argument_list|(
name|blkIndex
argument_list|,
name|completeBlock
argument_list|)
expr_stmt|;
comment|// replace block in the blocksMap
return|return
name|blocksMap
operator|.
name|replaceBlock
argument_list|(
name|completeBlock
argument_list|)
return|;
block|}
DECL|method|completeBlock (final INodeFile fileINode, final BlockInfo block)
specifier|private
name|BlockInfo
name|completeBlock
parameter_list|(
specifier|final
name|INodeFile
name|fileINode
parameter_list|,
specifier|final
name|BlockInfo
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockInfo
index|[]
name|fileBlocks
init|=
name|fileINode
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|fileBlocks
operator|.
name|length
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|fileBlocks
index|[
name|idx
index|]
operator|==
name|block
condition|)
block|{
return|return
name|completeBlock
argument_list|(
name|fileINode
argument_list|,
name|idx
argument_list|)
return|;
block|}
return|return
name|block
return|;
block|}
comment|/**    * Convert the last block of the file to an under construction block.<p>    * The block is converted only if the file has blocks and the last one    * is a partial block (its size is less than the preferred block size).    * The converted block is returned to the client.    * The client uses the returned block locations to form the data pipeline    * for this block.<br>    * The methods returns null if there is no partial block at the end.    * The client is supposed to allocate a new block with the next call.    *    * @param fileINode file    * @return the last block locations if the block is partial or null otherwise    */
DECL|method|convertLastBlockToUnderConstruction ( INodeFileUnderConstruction fileINode)
specifier|public
name|LocatedBlock
name|convertLastBlockToUnderConstruction
parameter_list|(
name|INodeFileUnderConstruction
name|fileINode
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockInfo
name|oldBlock
init|=
name|fileINode
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldBlock
operator|==
literal|null
operator|||
name|fileINode
operator|.
name|getPreferredBlockSize
argument_list|()
operator|==
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
condition|)
return|return
literal|null
return|;
assert|assert
name|oldBlock
operator|==
name|getStoredBlock
argument_list|(
name|oldBlock
argument_list|)
operator|:
literal|"last block of the file is not in blocksMap"
assert|;
name|DatanodeDescriptor
index|[]
name|targets
init|=
name|getNodes
argument_list|(
name|oldBlock
argument_list|)
decl_stmt|;
name|BlockInfoUnderConstruction
name|ucBlock
init|=
name|fileINode
operator|.
name|setLastBlock
argument_list|(
name|oldBlock
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|blocksMap
operator|.
name|replaceBlock
argument_list|(
name|ucBlock
argument_list|)
expr_stmt|;
comment|// Remove block from replication queue.
name|updateNeededReplications
argument_list|(
name|oldBlock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// remove this block from the list of pending blocks to be deleted.
for|for
control|(
name|DatanodeDescriptor
name|dd
range|:
name|targets
control|)
block|{
name|String
name|datanodeId
init|=
name|dd
operator|.
name|getStorageID
argument_list|()
decl_stmt|;
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|datanodeId
argument_list|,
name|oldBlock
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|fileLength
init|=
name|fileINode
operator|.
name|computeContentSummary
argument_list|()
operator|.
name|getLength
argument_list|()
decl_stmt|;
specifier|final
name|long
name|pos
init|=
name|fileLength
operator|-
name|ucBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
return|return
name|createLocatedBlock
argument_list|(
name|ucBlock
argument_list|,
name|pos
argument_list|,
name|AccessMode
operator|.
name|WRITE
argument_list|)
return|;
block|}
comment|/**    * Get all valid locations of the block    */
DECL|method|getValidLocations (Block block)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getValidLocations
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|machineSet
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|blocksMap
operator|.
name|numNodes
argument_list|(
name|block
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|block
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|storageID
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getStorageID
argument_list|()
decl_stmt|;
comment|// filter invalidate replicas
if|if
condition|(
operator|!
name|invalidateBlocks
operator|.
name|contains
argument_list|(
name|storageID
argument_list|,
name|block
argument_list|)
condition|)
block|{
name|machineSet
operator|.
name|add
argument_list|(
name|storageID
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|machineSet
return|;
block|}
DECL|method|createLocatedBlockList (final BlockInfo[] blocks, final long offset, final long length, final int nrBlocksToReturn, final AccessMode mode)
specifier|private
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|createLocatedBlockList
parameter_list|(
specifier|final
name|BlockInfo
index|[]
name|blocks
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|length
parameter_list|,
specifier|final
name|int
name|nrBlocksToReturn
parameter_list|,
specifier|final
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|curBlk
init|=
literal|0
decl_stmt|;
name|long
name|curPos
init|=
literal|0
decl_stmt|,
name|blkSize
init|=
literal|0
decl_stmt|;
name|int
name|nrBlocks
init|=
operator|(
name|blocks
index|[
literal|0
index|]
operator|.
name|getNumBytes
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|blocks
operator|.
name|length
decl_stmt|;
for|for
control|(
name|curBlk
operator|=
literal|0
init|;
name|curBlk
operator|<
name|nrBlocks
condition|;
name|curBlk
operator|++
control|)
block|{
name|blkSize
operator|=
name|blocks
index|[
name|curBlk
index|]
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
assert|assert
name|blkSize
operator|>
literal|0
operator|:
literal|"Block of size 0"
assert|;
if|if
condition|(
name|curPos
operator|+
name|blkSize
operator|>
name|offset
condition|)
block|{
break|break;
block|}
name|curPos
operator|+=
name|blkSize
expr_stmt|;
block|}
if|if
condition|(
name|nrBlocks
operator|>
literal|0
operator|&&
name|curBlk
operator|==
name|nrBlocks
condition|)
comment|// offset>= end of file
return|return
name|Collections
operator|.
expr|<
name|LocatedBlock
operator|>
name|emptyList
argument_list|()
return|;
name|long
name|endOff
init|=
name|offset
operator|+
name|length
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|(
name|blocks
operator|.
name|length
argument_list|)
decl_stmt|;
do|do
block|{
name|results
operator|.
name|add
argument_list|(
name|createLocatedBlock
argument_list|(
name|blocks
index|[
name|curBlk
index|]
argument_list|,
name|curPos
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|curPos
operator|+=
name|blocks
index|[
name|curBlk
index|]
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
name|curBlk
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|curPos
operator|<
name|endOff
operator|&&
name|curBlk
operator|<
name|blocks
operator|.
name|length
operator|&&
name|results
operator|.
name|size
argument_list|()
operator|<
name|nrBlocksToReturn
condition|)
do|;
return|return
name|results
return|;
block|}
DECL|method|createLocatedBlock (final BlockInfo blk, final long pos, final BlockTokenSecretManager.AccessMode mode)
specifier|private
name|LocatedBlock
name|createLocatedBlock
parameter_list|(
specifier|final
name|BlockInfo
name|blk
parameter_list|,
specifier|final
name|long
name|pos
parameter_list|,
specifier|final
name|BlockTokenSecretManager
operator|.
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|LocatedBlock
name|lb
init|=
name|createLocatedBlock
argument_list|(
name|blk
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|null
condition|)
block|{
name|setBlockToken
argument_list|(
name|lb
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|lb
return|;
block|}
comment|/** @return a LocatedBlock for the given block */
DECL|method|createLocatedBlock (final BlockInfo blk, final long pos )
specifier|private
name|LocatedBlock
name|createLocatedBlock
parameter_list|(
specifier|final
name|BlockInfo
name|blk
parameter_list|,
specifier|final
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blk
operator|instanceof
name|BlockInfoUnderConstruction
condition|)
block|{
if|if
condition|(
name|blk
operator|.
name|isComplete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"blk instanceof BlockInfoUnderConstruction&& blk.isComplete()"
operator|+
literal|", blk="
operator|+
name|blk
argument_list|)
throw|;
block|}
specifier|final
name|BlockInfoUnderConstruction
name|uc
init|=
operator|(
name|BlockInfoUnderConstruction
operator|)
name|blk
decl_stmt|;
specifier|final
name|DatanodeDescriptor
index|[]
name|locations
init|=
name|uc
operator|.
name|getExpectedLocations
argument_list|()
decl_stmt|;
specifier|final
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|namesystem
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blk
argument_list|)
decl_stmt|;
return|return
operator|new
name|LocatedBlock
argument_list|(
name|eb
argument_list|,
name|locations
argument_list|,
name|pos
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// get block locations
specifier|final
name|int
name|numCorruptNodes
init|=
name|countNodes
argument_list|(
name|blk
argument_list|)
operator|.
name|corruptReplicas
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numCorruptReplicas
init|=
name|corruptReplicas
operator|.
name|numCorruptReplicas
argument_list|(
name|blk
argument_list|)
decl_stmt|;
if|if
condition|(
name|numCorruptNodes
operator|!=
name|numCorruptReplicas
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Inconsistent number of corrupt replicas for "
operator|+
name|blk
operator|+
literal|" blockMap has "
operator|+
name|numCorruptNodes
operator|+
literal|" but corrupt replicas map has "
operator|+
name|numCorruptReplicas
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|numNodes
init|=
name|blocksMap
operator|.
name|numNodes
argument_list|(
name|blk
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isCorrupt
init|=
name|numCorruptNodes
operator|==
name|numNodes
decl_stmt|;
specifier|final
name|int
name|numMachines
init|=
name|isCorrupt
condition|?
name|numNodes
else|:
name|numNodes
operator|-
name|numCorruptNodes
decl_stmt|;
specifier|final
name|DatanodeDescriptor
index|[]
name|machines
init|=
operator|new
name|DatanodeDescriptor
index|[
name|numMachines
index|]
decl_stmt|;
if|if
condition|(
name|numMachines
operator|>
literal|0
condition|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|blk
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|d
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|replicaCorrupt
init|=
name|corruptReplicas
operator|.
name|isReplicaCorrupt
argument_list|(
name|blk
argument_list|,
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCorrupt
operator|||
operator|(
operator|!
name|isCorrupt
operator|&&
operator|!
name|replicaCorrupt
operator|)
condition|)
name|machines
index|[
name|j
operator|++
index|]
operator|=
name|d
expr_stmt|;
block|}
block|}
specifier|final
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|namesystem
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blk
argument_list|)
decl_stmt|;
return|return
operator|new
name|LocatedBlock
argument_list|(
name|eb
argument_list|,
name|machines
argument_list|,
name|pos
argument_list|,
name|isCorrupt
argument_list|)
return|;
block|}
comment|/** Create a LocatedBlocks. */
DECL|method|createLocatedBlocks (final BlockInfo[] blocks, final long fileSizeExcludeBlocksUnderConstruction, final boolean isFileUnderConstruction, final long offset, final long length, final boolean needBlockToken )
specifier|public
name|LocatedBlocks
name|createLocatedBlocks
parameter_list|(
specifier|final
name|BlockInfo
index|[]
name|blocks
parameter_list|,
specifier|final
name|long
name|fileSizeExcludeBlocksUnderConstruction
parameter_list|,
specifier|final
name|boolean
name|isFileUnderConstruction
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|length
parameter_list|,
specifier|final
name|boolean
name|needBlockToken
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasReadOrWriteLock
argument_list|()
assert|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|blocks
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|LocatedBlocks
argument_list|(
literal|0
argument_list|,
name|isFileUnderConstruction
argument_list|,
name|Collections
operator|.
expr|<
name|LocatedBlock
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"blocks = "
operator|+
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|AccessMode
name|mode
init|=
name|needBlockToken
condition|?
name|AccessMode
operator|.
name|READ
else|:
literal|null
decl_stmt|;
specifier|final
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|locatedblocks
init|=
name|createLocatedBlockList
argument_list|(
name|blocks
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|mode
argument_list|)
decl_stmt|;
specifier|final
name|BlockInfo
name|last
init|=
name|blocks
index|[
name|blocks
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|long
name|lastPos
init|=
name|last
operator|.
name|isComplete
argument_list|()
condition|?
name|fileSizeExcludeBlocksUnderConstruction
operator|-
name|last
operator|.
name|getNumBytes
argument_list|()
else|:
name|fileSizeExcludeBlocksUnderConstruction
decl_stmt|;
specifier|final
name|LocatedBlock
name|lastlb
init|=
name|createLocatedBlock
argument_list|(
name|last
argument_list|,
name|lastPos
argument_list|,
name|mode
argument_list|)
decl_stmt|;
return|return
operator|new
name|LocatedBlocks
argument_list|(
name|fileSizeExcludeBlocksUnderConstruction
argument_list|,
name|isFileUnderConstruction
argument_list|,
name|locatedblocks
argument_list|,
name|lastlb
argument_list|,
name|last
operator|.
name|isComplete
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** @return current access keys. */
DECL|method|getBlockKeys ()
specifier|public
name|ExportedBlockKeys
name|getBlockKeys
parameter_list|()
block|{
return|return
name|isBlockTokenEnabled
argument_list|()
condition|?
name|blockTokenSecretManager
operator|.
name|exportKeys
argument_list|()
else|:
name|ExportedBlockKeys
operator|.
name|DUMMY_KEYS
return|;
block|}
comment|/** Generate a block token for the located block. */
DECL|method|setBlockToken (final LocatedBlock b, final BlockTokenSecretManager.AccessMode mode)
specifier|public
name|void
name|setBlockToken
parameter_list|(
specifier|final
name|LocatedBlock
name|b
parameter_list|,
specifier|final
name|BlockTokenSecretManager
operator|.
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
condition|)
block|{
name|b
operator|.
name|setBlockToken
argument_list|(
name|blockTokenSecretManager
operator|.
name|generateToken
argument_list|(
name|b
operator|.
name|getBlock
argument_list|()
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addKeyUpdateCommand (final List<DatanodeCommand> cmds, final DatanodeDescriptor nodeinfo)
name|void
name|addKeyUpdateCommand
parameter_list|(
specifier|final
name|List
argument_list|<
name|DatanodeCommand
argument_list|>
name|cmds
parameter_list|,
specifier|final
name|DatanodeDescriptor
name|nodeinfo
parameter_list|)
block|{
comment|// check access key update
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
operator|&&
name|nodeinfo
operator|.
name|needKeyUpdate
condition|)
block|{
name|cmds
operator|.
name|add
argument_list|(
operator|new
name|KeyUpdateCommand
argument_list|(
name|blockTokenSecretManager
operator|.
name|exportKeys
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|nodeinfo
operator|.
name|needKeyUpdate
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**    * Clamp the specified replication between the minimum and the maximum    * replication levels.    */
DECL|method|adjustReplication (short replication)
specifier|public
name|short
name|adjustReplication
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
return|return
name|replication
operator|<
name|minReplication
condition|?
name|minReplication
else|:
name|replication
operator|>
name|maxReplication
condition|?
name|maxReplication
else|:
name|replication
return|;
block|}
comment|/**    * Check whether the replication parameter is within the range    * determined by system configuration.    */
DECL|method|verifyReplication (String src, short replication, String clientName)
specifier|public
name|void
name|verifyReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|,
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|replication
operator|>=
name|minReplication
operator|&&
name|replication
operator|<=
name|maxReplication
condition|)
block|{
comment|//common case. avoid building 'text'
return|return;
block|}
name|String
name|text
init|=
literal|"file "
operator|+
name|src
operator|+
operator|(
operator|(
name|clientName
operator|!=
literal|null
operator|)
condition|?
literal|" on client "
operator|+
name|clientName
else|:
literal|""
operator|)
operator|+
literal|".\n"
operator|+
literal|"Requested replication "
operator|+
name|replication
decl_stmt|;
if|if
condition|(
name|replication
operator|>
name|maxReplication
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|text
operator|+
literal|" exceeds maximum "
operator|+
name|maxReplication
argument_list|)
throw|;
if|if
condition|(
name|replication
operator|<
name|minReplication
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|text
operator|+
literal|" is less than the required minimum "
operator|+
name|minReplication
argument_list|)
throw|;
block|}
comment|/**    * return a list of blocks& their locations on<code>datanode</code> whose    * total size is<code>size</code>    *     * @param datanode on which blocks are located    * @param size total size of blocks    */
DECL|method|getBlocks (DatanodeID datanode, long size )
specifier|public
name|BlocksWithLocations
name|getBlocks
parameter_list|(
name|DatanodeID
name|datanode
parameter_list|,
name|long
name|size
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
return|return
name|getBlocksWithLocations
argument_list|(
name|datanode
argument_list|,
name|size
argument_list|)
return|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Get all blocks with location information from a datanode. */
DECL|method|getBlocksWithLocations (final DatanodeID datanode, final long size)
specifier|private
name|BlocksWithLocations
name|getBlocksWithLocations
parameter_list|(
specifier|final
name|DatanodeID
name|datanode
parameter_list|,
specifier|final
name|long
name|size
parameter_list|)
throws|throws
name|UnregisteredNodeException
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|datanode
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* getBlocks: "
operator|+
literal|"Asking for blocks from an unrecorded node "
operator|+
name|datanode
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Datanode "
operator|+
name|datanode
operator|.
name|getName
argument_list|()
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
name|int
name|numBlocks
init|=
name|node
operator|.
name|numBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBlocks
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|BlocksWithLocations
argument_list|(
operator|new
name|BlockWithLocations
index|[
literal|0
index|]
argument_list|)
return|;
block|}
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|iter
init|=
name|node
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
name|int
name|startBlock
init|=
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|numBlocks
argument_list|)
decl_stmt|;
comment|// starting from a random block
comment|// skip blocks
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|startBlock
condition|;
name|i
operator|++
control|)
block|{
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|BlockWithLocations
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockWithLocations
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
name|BlockInfo
name|curBlock
decl_stmt|;
while|while
condition|(
name|totalSize
operator|<
name|size
operator|&&
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|curBlock
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
continue|continue;
name|totalSize
operator|+=
name|addBlock
argument_list|(
name|curBlock
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totalSize
operator|<
name|size
condition|)
block|{
name|iter
operator|=
name|node
operator|.
name|getBlockIterator
argument_list|()
expr_stmt|;
comment|// start from the beginning
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|startBlock
operator|&&
name|totalSize
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|curBlock
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
continue|continue;
name|totalSize
operator|+=
name|addBlock
argument_list|(
name|curBlock
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|BlocksWithLocations
argument_list|(
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|BlockWithLocations
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/** Remove the blocks associated to the given datanode. */
DECL|method|removeBlocksAssociatedTo (final DatanodeDescriptor node)
name|void
name|removeBlocksAssociatedTo
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|Block
argument_list|>
name|it
init|=
name|node
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|removeStoredBlock
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|resetBlocks
argument_list|()
expr_stmt|;
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|node
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds block to list of blocks which will be invalidated on specified    * datanode and log the operation    */
DECL|method|addToInvalidates (final Block block, final DatanodeInfo datanode)
name|void
name|addToInvalidates
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|,
specifier|final
name|DatanodeInfo
name|datanode
parameter_list|)
block|{
name|invalidateBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|datanode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds block to list of blocks which will be invalidated on all its    * datanodes.    */
DECL|method|addToInvalidates (Block b)
specifier|private
name|void
name|addToInvalidates
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
name|StringBuilder
name|datanodes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|b
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|invalidateBlocks
operator|.
name|add
argument_list|(
name|b
argument_list|,
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|datanodes
operator|.
name|append
argument_list|(
name|node
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datanodes
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* addToInvalidates: "
operator|+
name|b
operator|+
literal|" to "
operator|+
name|datanodes
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Mark the block belonging to datanode as corrupt    * @param blk Block to be marked as corrupt    * @param dn Datanode which holds the corrupt replica    */
DECL|method|findAndMarkBlockAsCorrupt (final ExtendedBlock blk, final DatanodeInfo dn)
specifier|public
name|void
name|findAndMarkBlockAsCorrupt
parameter_list|(
specifier|final
name|ExtendedBlock
name|blk
parameter_list|,
specifier|final
name|DatanodeInfo
name|dn
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|BlockInfo
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|blk
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
comment|// Check if the replica is in the blockMap, if not
comment|// ignore the request for now. This could happen when BlockScanner
comment|// thread of Datanode reports bad block before Block reports are sent
comment|// by the Datanode on startup
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* findAndMarkBlockAsCorrupt: "
operator|+
name|blk
operator|+
literal|" not found."
argument_list|)
expr_stmt|;
return|return;
block|}
name|markBlockAsCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|markBlockAsCorrupt (BlockInfo storedBlock, DatanodeInfo dn)
specifier|private
name|void
name|markBlockAsCorrupt
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|storedBlock
operator|!=
literal|null
operator|:
literal|"storedBlock should not be null"
assert|;
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot mark block "
operator|+
name|storedBlock
operator|.
name|getBlockName
argument_list|()
operator|+
literal|" as corrupt because datanode "
operator|+
name|dn
operator|.
name|getName
argument_list|()
operator|+
literal|" does not exist. "
argument_list|)
throw|;
block|}
name|INodeFile
name|inode
init|=
name|storedBlock
operator|.
name|getINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK markBlockAsCorrupt: "
operator|+
literal|"block "
operator|+
name|storedBlock
operator|+
literal|" could not be marked as corrupt as it"
operator|+
literal|" does not belong to any file"
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Add replica to the data-node if it is not already there
name|node
operator|.
name|addBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
comment|// Add this replica to corruptReplicas Map
name|corruptReplicas
operator|.
name|addToCorruptReplicasMap
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|countNodes
argument_list|(
name|storedBlock
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|inode
operator|.
name|getReplication
argument_list|()
condition|)
block|{
comment|// the block is over-replicated so invalidate the replicas immediately
name|invalidateBlock
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
comment|// add the block to neededReplication
name|updateNeededReplications
argument_list|(
name|storedBlock
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Invalidates the given block on the given datanode.    */
DECL|method|invalidateBlock (Block blk, DatanodeInfo dn)
specifier|private
name|void
name|invalidateBlock
parameter_list|(
name|Block
name|blk
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
throws|throws
name|IOException
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* invalidateBlock: "
operator|+
name|blk
operator|+
literal|" on "
operator|+
name|dn
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot invalidate block "
operator|+
name|blk
operator|+
literal|" because datanode "
operator|+
name|dn
operator|.
name|getName
argument_list|()
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
comment|// Check how many copies we have of the block. If we have at least one
comment|// copy on a live node, then we can delete it.
name|int
name|count
init|=
name|countNodes
argument_list|(
name|blk
argument_list|)
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>=
literal|1
condition|)
block|{
name|addToInvalidates
argument_list|(
name|blk
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|removeStoredBlock
argument_list|(
name|blk
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* invalidateBlocks: "
operator|+
name|blk
operator|+
literal|" on "
operator|+
name|dn
operator|.
name|getName
argument_list|()
operator|+
literal|" listed for deletion."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* invalidateBlocks: "
operator|+
name|blk
operator|+
literal|" on "
operator|+
name|dn
operator|.
name|getName
argument_list|()
operator|+
literal|" is the only copy and was not deleted."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateState ()
name|void
name|updateState
parameter_list|()
block|{
name|pendingReplicationBlocksCount
operator|=
name|pendingReplications
operator|.
name|size
argument_list|()
expr_stmt|;
name|underReplicatedBlocksCount
operator|=
name|neededReplications
operator|.
name|size
argument_list|()
expr_stmt|;
name|corruptReplicaBlocksCount
operator|=
name|corruptReplicas
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|/** Return number of under-replicated but not missing blocks */
DECL|method|getUnderReplicatedNotMissingBlocks ()
specifier|public
name|int
name|getUnderReplicatedNotMissingBlocks
parameter_list|()
block|{
return|return
name|neededReplications
operator|.
name|getUnderReplicatedBlockCount
argument_list|()
return|;
block|}
comment|/**    * Schedule blocks for deletion at datanodes    * @param nodesToProcess number of datanodes to schedule deletion work    * @return total number of block for deletion    */
DECL|method|computeInvalidateWork (int nodesToProcess)
name|int
name|computeInvalidateWork
parameter_list|(
name|int
name|nodesToProcess
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|invalidateBlocks
operator|.
name|getStorageIDs
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|nodesToProcess
operator|=
name|Math
operator|.
name|min
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|,
name|nodesToProcess
argument_list|)
expr_stmt|;
name|int
name|blockCnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|nodeCnt
init|=
literal|0
init|;
name|nodeCnt
operator|<
name|nodesToProcess
condition|;
name|nodeCnt
operator|++
control|)
block|{
name|blockCnt
operator|+=
name|invalidateWorkForOneNode
argument_list|(
name|nodes
operator|.
name|get
argument_list|(
name|nodeCnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|blockCnt
return|;
block|}
comment|/**    * Scan blocks in {@link #neededReplications} and assign replication    * work to data-nodes they belong to.    *    * The number of process blocks equals either twice the number of live    * data-nodes or the number of under-replicated blocks whichever is less.    *    * @return number of blocks scheduled for replication during this iteration.    */
DECL|method|computeReplicationWork (int blocksToProcess)
specifier|private
name|int
name|computeReplicationWork
parameter_list|(
name|int
name|blocksToProcess
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Choose the blocks to be replicated
name|List
argument_list|<
name|List
argument_list|<
name|Block
argument_list|>
argument_list|>
name|blocksToReplicate
init|=
name|chooseUnderReplicatedBlocks
argument_list|(
name|blocksToProcess
argument_list|)
decl_stmt|;
comment|// replicate blocks
return|return
name|computeReplicationWorkForBlocks
argument_list|(
name|blocksToReplicate
argument_list|)
return|;
block|}
comment|/**    * Get a list of block lists to be replicated The index of block lists    * represents the    *    * @param blocksToProcess    * @return Return a list of block lists to be replicated. The block list index    *         represents its replication priority.    */
DECL|method|chooseUnderReplicatedBlocks (int blocksToProcess)
specifier|private
name|List
argument_list|<
name|List
argument_list|<
name|Block
argument_list|>
argument_list|>
name|chooseUnderReplicatedBlocks
parameter_list|(
name|int
name|blocksToProcess
parameter_list|)
block|{
comment|// initialize data structure for the return value
name|List
argument_list|<
name|List
argument_list|<
name|Block
argument_list|>
argument_list|>
name|blocksToReplicate
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Block
argument_list|>
argument_list|>
argument_list|(
name|UnderReplicatedBlocks
operator|.
name|LEVEL
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|UnderReplicatedBlocks
operator|.
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|blocksToReplicate
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Block
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|neededReplications
init|)
block|{
if|if
condition|(
name|neededReplications
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|blocksToReplicate
return|;
block|}
comment|// Go through all blocks that need replications.
name|UnderReplicatedBlocks
operator|.
name|BlockIterator
name|neededReplicationsIterator
init|=
name|neededReplications
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// skip to the first unprocessed block, which is at replIndex
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|replIndex
operator|&&
name|neededReplicationsIterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|neededReplicationsIterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
comment|// # of blocks to process equals either twice the number of live
comment|// data-nodes or the number of under-replicated blocks whichever is less
name|blocksToProcess
operator|=
name|Math
operator|.
name|min
argument_list|(
name|blocksToProcess
argument_list|,
name|neededReplications
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|blkCnt
init|=
literal|0
init|;
name|blkCnt
operator|<
name|blocksToProcess
condition|;
name|blkCnt
operator|++
operator|,
name|replIndex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|neededReplicationsIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// start from the beginning
name|replIndex
operator|=
literal|0
expr_stmt|;
name|blocksToProcess
operator|=
name|Math
operator|.
name|min
argument_list|(
name|blocksToProcess
argument_list|,
name|neededReplications
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkCnt
operator|>=
name|blocksToProcess
condition|)
break|break;
name|neededReplicationsIterator
operator|=
name|neededReplications
operator|.
name|iterator
argument_list|()
expr_stmt|;
assert|assert
name|neededReplicationsIterator
operator|.
name|hasNext
argument_list|()
operator|:
literal|"neededReplications should not be empty."
assert|;
block|}
name|Block
name|block
init|=
name|neededReplicationsIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|priority
init|=
name|neededReplicationsIterator
operator|.
name|getPriority
argument_list|()
decl_stmt|;
if|if
condition|(
name|priority
operator|<
literal|0
operator|||
name|priority
operator|>=
name|blocksToReplicate
operator|.
name|size
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected replication priority: "
operator|+
name|priority
operator|+
literal|" "
operator|+
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blocksToReplicate
operator|.
name|get
argument_list|(
name|priority
argument_list|)
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end for
block|}
comment|// end synchronized neededReplication
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
return|return
name|blocksToReplicate
return|;
block|}
comment|/** Replicate a set of blocks    *    * @param blocksToReplicate blocks to be replicated, for each priority    * @return the number of blocks scheduled for replication    */
annotation|@
name|VisibleForTesting
DECL|method|computeReplicationWorkForBlocks (List<List<Block>> blocksToReplicate)
name|int
name|computeReplicationWorkForBlocks
parameter_list|(
name|List
argument_list|<
name|List
argument_list|<
name|Block
argument_list|>
argument_list|>
name|blocksToReplicate
parameter_list|)
block|{
name|int
name|requiredReplication
decl_stmt|,
name|numEffectiveReplicas
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
decl_stmt|,
name|liveReplicaNodes
decl_stmt|;
name|DatanodeDescriptor
name|srcNode
decl_stmt|;
name|INodeFile
name|fileINode
init|=
literal|null
decl_stmt|;
name|int
name|additionalReplRequired
decl_stmt|;
name|int
name|scheduledWork
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|ReplicationWork
argument_list|>
name|work
init|=
operator|new
name|LinkedList
argument_list|<
name|ReplicationWork
argument_list|>
argument_list|()
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|neededReplications
init|)
block|{
for|for
control|(
name|int
name|priority
init|=
literal|0
init|;
name|priority
operator|<
name|blocksToReplicate
operator|.
name|size
argument_list|()
condition|;
name|priority
operator|++
control|)
block|{
for|for
control|(
name|Block
name|block
range|:
name|blocksToReplicate
operator|.
name|get
argument_list|(
name|priority
argument_list|)
control|)
block|{
comment|// block should belong to a file
name|fileINode
operator|=
name|blocksMap
operator|.
name|getINode
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// abandoned block or block reopened for append
if|if
condition|(
name|fileINode
operator|==
literal|null
operator|||
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
name|replIndex
operator|--
expr_stmt|;
continue|continue;
block|}
name|requiredReplication
operator|=
name|fileINode
operator|.
name|getReplication
argument_list|()
expr_stmt|;
comment|// get a source data-node
name|containingNodes
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
expr_stmt|;
name|liveReplicaNodes
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
expr_stmt|;
name|NumberReplicas
name|numReplicas
init|=
operator|new
name|NumberReplicas
argument_list|()
decl_stmt|;
name|srcNode
operator|=
name|chooseSourceDatanode
argument_list|(
name|block
argument_list|,
name|containingNodes
argument_list|,
name|liveReplicaNodes
argument_list|,
name|numReplicas
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcNode
operator|==
literal|null
condition|)
comment|// block can not be replicated from any node
continue|continue;
assert|assert
name|liveReplicaNodes
operator|.
name|size
argument_list|()
operator|==
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
assert|;
comment|// do not schedule more if enough replicas is already pending
name|numEffectiveReplicas
operator|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|numEffectiveReplicas
operator|>=
name|requiredReplication
condition|)
block|{
if|if
condition|(
operator|(
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|blockHasEnoughRacks
argument_list|(
name|block
argument_list|)
operator|)
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
name|replIndex
operator|--
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* "
operator|+
literal|"Removing block "
operator|+
name|block
operator|+
literal|" from neededReplications as it has enough replicas."
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|<
name|requiredReplication
condition|)
block|{
name|additionalReplRequired
operator|=
name|requiredReplication
operator|-
name|numEffectiveReplicas
expr_stmt|;
block|}
else|else
block|{
name|additionalReplRequired
operator|=
literal|1
expr_stmt|;
comment|// Needed on a new rack
block|}
name|work
operator|.
name|add
argument_list|(
operator|new
name|ReplicationWork
argument_list|(
name|block
argument_list|,
name|fileINode
argument_list|,
name|srcNode
argument_list|,
name|containingNodes
argument_list|,
name|liveReplicaNodes
argument_list|,
name|additionalReplRequired
argument_list|,
name|priority
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
name|excludedNodes
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ReplicationWork
name|rw
range|:
name|work
control|)
block|{
comment|// Exclude all of the containing nodes from being targets.
comment|// This list includes decommissioning or corrupt nodes.
name|excludedNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|rw
operator|.
name|containingNodes
control|)
block|{
name|excludedNodes
operator|.
name|put
argument_list|(
name|dn
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
comment|// choose replication targets: NOT HOLDING THE GLOBAL LOCK
comment|// It is costly to extract the filename for which chooseTargets is called,
comment|// so for now we pass in the Inode itself.
name|rw
operator|.
name|targets
operator|=
name|blockplacement
operator|.
name|chooseTarget
argument_list|(
name|rw
operator|.
name|fileINode
argument_list|,
name|rw
operator|.
name|additionalReplRequired
argument_list|,
name|rw
operator|.
name|srcNode
argument_list|,
name|rw
operator|.
name|liveReplicaNodes
argument_list|,
name|excludedNodes
argument_list|,
name|rw
operator|.
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|ReplicationWork
name|rw
range|:
name|work
control|)
block|{
name|DatanodeDescriptor
index|[]
name|targets
init|=
name|rw
operator|.
name|targets
decl_stmt|;
if|if
condition|(
name|targets
operator|==
literal|null
operator|||
name|targets
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|rw
operator|.
name|targets
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
synchronized|synchronized
init|(
name|neededReplications
init|)
block|{
name|Block
name|block
init|=
name|rw
operator|.
name|block
decl_stmt|;
name|int
name|priority
init|=
name|rw
operator|.
name|priority
decl_stmt|;
comment|// Recheck since global lock was released
comment|// block should belong to a file
name|fileINode
operator|=
name|blocksMap
operator|.
name|getINode
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// abandoned block or block reopened for append
if|if
condition|(
name|fileINode
operator|==
literal|null
operator|||
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
name|rw
operator|.
name|targets
operator|=
literal|null
expr_stmt|;
name|replIndex
operator|--
expr_stmt|;
continue|continue;
block|}
name|requiredReplication
operator|=
name|fileINode
operator|.
name|getReplication
argument_list|()
expr_stmt|;
comment|// do not schedule more if enough replicas is already pending
name|NumberReplicas
name|numReplicas
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|numEffectiveReplicas
operator|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|numEffectiveReplicas
operator|>=
name|requiredReplication
condition|)
block|{
if|if
condition|(
operator|(
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|blockHasEnoughRacks
argument_list|(
name|block
argument_list|)
operator|)
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
name|replIndex
operator|--
expr_stmt|;
name|rw
operator|.
name|targets
operator|=
literal|null
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* "
operator|+
literal|"Removing block "
operator|+
name|block
operator|+
literal|" from neededReplications as it has enough replicas."
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|requiredReplication
operator|)
operator|&&
operator|(
operator|!
name|blockHasEnoughRacks
argument_list|(
name|block
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rw
operator|.
name|srcNode
operator|.
name|getNetworkLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|targets
index|[
literal|0
index|]
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
condition|)
block|{
comment|//No use continuing, unless a new rack in this case
continue|continue;
block|}
block|}
comment|// Add block to the to be replicated list
name|rw
operator|.
name|srcNode
operator|.
name|addBlockToBeReplicated
argument_list|(
name|block
argument_list|,
name|targets
argument_list|)
expr_stmt|;
name|scheduledWork
operator|++
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|targets
control|)
block|{
name|dn
operator|.
name|incBlocksScheduled
argument_list|()
expr_stmt|;
block|}
comment|// Move the block-replication into a "pending" state.
comment|// The reason we use 'pending' is so we can retry
comment|// replications that fail after an appropriate amount of time.
name|pendingReplications
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|targets
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* block "
operator|+
name|block
operator|+
literal|" is moved from neededReplications to pendingReplications"
argument_list|)
expr_stmt|;
block|}
comment|// remove from neededReplications
if|if
condition|(
name|numEffectiveReplicas
operator|+
name|targets
operator|.
name|length
operator|>=
name|requiredReplication
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
name|replIndex
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
comment|// log which blocks have been scheduled for replication
for|for
control|(
name|ReplicationWork
name|rw
range|:
name|work
control|)
block|{
name|DatanodeDescriptor
index|[]
name|targets
init|=
name|rw
operator|.
name|targets
decl_stmt|;
if|if
condition|(
name|targets
operator|!=
literal|null
operator|&&
name|targets
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|StringBuilder
name|targetList
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"datanode(s)"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|targets
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|targetList
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|targetList
operator|.
name|append
argument_list|(
name|targets
index|[
name|k
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* ask "
operator|+
name|rw
operator|.
name|srcNode
operator|.
name|getName
argument_list|()
operator|+
literal|" to replicate "
operator|+
name|rw
operator|.
name|block
operator|+
literal|" to "
operator|+
name|targetList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* neededReplications = "
operator|+
name|neededReplications
operator|.
name|size
argument_list|()
operator|+
literal|" pendingReplications = "
operator|+
name|pendingReplications
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|scheduledWork
return|;
block|}
comment|/**    * Choose target datanodes according to the replication policy.    * @throws IOException if the number of targets< minimum replication.    * @see BlockPlacementPolicy#chooseTarget(String, int, DatanodeDescriptor, HashMap, long)    */
DECL|method|chooseTarget (final String src, final int numOfReplicas, final DatanodeDescriptor client, final HashMap<Node, Node> excludedNodes, final long blocksize)
specifier|public
name|DatanodeDescriptor
index|[]
name|chooseTarget
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|int
name|numOfReplicas
parameter_list|,
specifier|final
name|DatanodeDescriptor
name|client
parameter_list|,
specifier|final
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
specifier|final
name|long
name|blocksize
parameter_list|)
throws|throws
name|IOException
block|{
comment|// choose targets for the new block to be allocated.
specifier|final
name|DatanodeDescriptor
name|targets
index|[]
init|=
name|blockplacement
operator|.
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|numOfReplicas
argument_list|,
name|client
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|)
decl_stmt|;
if|if
condition|(
name|targets
operator|.
name|length
operator|<
name|minReplication
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File "
operator|+
name|src
operator|+
literal|" could only be replicated to "
operator|+
name|targets
operator|.
name|length
operator|+
literal|" nodes instead of minReplication (="
operator|+
name|minReplication
operator|+
literal|").  There are "
operator|+
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
operator|.
name|getNumOfLeaves
argument_list|()
operator|+
literal|" datanode(s) running and "
operator|+
operator|(
name|excludedNodes
operator|==
literal|null
condition|?
literal|"no"
else|:
name|excludedNodes
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|" node(s) are excluded in this operation."
argument_list|)
throw|;
block|}
return|return
name|targets
return|;
block|}
comment|/**    * Parse the data-nodes the block belongs to and choose one,    * which will be the replication source.    *    * We prefer nodes that are in DECOMMISSION_INPROGRESS state to other nodes    * since the former do not have write traffic and hence are less busy.    * We do not use already decommissioned nodes as a source.    * Otherwise we choose a random node among those that did not reach their    * replication limit.    *    * In addition form a list of all nodes containing the block    * and calculate its replication numbers.    */
DECL|method|chooseSourceDatanode ( Block block, List<DatanodeDescriptor> containingNodes, List<DatanodeDescriptor> nodesContainingLiveReplicas, NumberReplicas numReplicas)
specifier|private
name|DatanodeDescriptor
name|chooseSourceDatanode
parameter_list|(
name|Block
name|block
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesContainingLiveReplicas
parameter_list|,
name|NumberReplicas
name|numReplicas
parameter_list|)
block|{
name|containingNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nodesContainingLiveReplicas
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DatanodeDescriptor
name|srcNode
init|=
literal|null
decl_stmt|;
name|int
name|live
init|=
literal|0
decl_stmt|;
name|int
name|decommissioned
init|=
literal|0
decl_stmt|;
name|int
name|corrupt
init|=
literal|0
decl_stmt|;
name|int
name|excess
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesCorrupt
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|excessBlocks
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|node
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|nodesCorrupt
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|nodesCorrupt
operator|.
name|contains
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|corrupt
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
operator|||
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
name|decommissioned
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|excessBlocks
operator|!=
literal|null
operator|&&
name|excessBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|excess
operator|++
expr_stmt|;
block|}
else|else
block|{
name|nodesContainingLiveReplicas
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|live
operator|++
expr_stmt|;
block|}
name|containingNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Check if this replica is corrupt
comment|// If so, do not select the node as src node
if|if
condition|(
operator|(
name|nodesCorrupt
operator|!=
literal|null
operator|)
operator|&&
name|nodesCorrupt
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|node
operator|.
name|getNumberOfBlocksToBeReplicated
argument_list|()
operator|>=
name|maxReplicationStreams
condition|)
continue|continue;
comment|// already reached replication limit
comment|// the block must not be scheduled for removal on srcNode
if|if
condition|(
name|excessBlocks
operator|!=
literal|null
operator|&&
name|excessBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
continue|continue;
comment|// never use already decommissioned nodes
if|if
condition|(
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
continue|continue;
comment|// we prefer nodes that are in DECOMMISSION_INPROGRESS state
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
operator|||
name|srcNode
operator|==
literal|null
condition|)
block|{
name|srcNode
operator|=
name|node
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|srcNode
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
continue|continue;
comment|// switch to a different node randomly
comment|// this to prevent from deterministically selecting the same node even
comment|// if the node failed to replicate the block on previous iterations
if|if
condition|(
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
name|srcNode
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|numReplicas
operator|!=
literal|null
condition|)
name|numReplicas
operator|.
name|initialize
argument_list|(
name|live
argument_list|,
name|decommissioned
argument_list|,
name|corrupt
argument_list|,
name|excess
argument_list|)
expr_stmt|;
return|return
name|srcNode
return|;
block|}
comment|/**    * If there were any replication requests that timed out, reap them    * and put them back into the neededReplication queue    */
DECL|method|processPendingReplications ()
specifier|private
name|void
name|processPendingReplications
parameter_list|()
block|{
name|Block
index|[]
name|timedOutItems
init|=
name|pendingReplications
operator|.
name|getTimedOutBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|timedOutItems
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|timedOutItems
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNeededReplication
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|,
name|getReplication
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|)
argument_list|,
name|num
operator|.
name|liveReplicas
argument_list|()
argument_list|)
condition|)
block|{
name|neededReplications
operator|.
name|add
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|,
name|num
operator|.
name|liveReplicas
argument_list|()
argument_list|,
name|num
operator|.
name|decommissionedReplicas
argument_list|()
argument_list|,
name|getReplication
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|/* If we know the target datanodes where the replication timedout,        * we could invoke decBlocksScheduled() on it. Its ok for now.        */
block|}
block|}
comment|/**    * StatefulBlockInfo is used to build the "toUC" list, which is a list of    * updates to the information about under-construction blocks.    * Besides the block in question, it provides the ReplicaState    * reported by the datanode in the block report.     */
DECL|class|StatefulBlockInfo
specifier|private
specifier|static
class|class
name|StatefulBlockInfo
block|{
DECL|field|storedBlock
specifier|final
name|BlockInfoUnderConstruction
name|storedBlock
decl_stmt|;
DECL|field|reportedState
specifier|final
name|ReplicaState
name|reportedState
decl_stmt|;
DECL|method|StatefulBlockInfo (BlockInfoUnderConstruction storedBlock, ReplicaState reportedState)
name|StatefulBlockInfo
parameter_list|(
name|BlockInfoUnderConstruction
name|storedBlock
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|)
block|{
name|this
operator|.
name|storedBlock
operator|=
name|storedBlock
expr_stmt|;
name|this
operator|.
name|reportedState
operator|=
name|reportedState
expr_stmt|;
block|}
block|}
comment|/**    * The given datanode is reporting all its blocks.    * Update the (machine-->blocklist) and (block-->machinelist) maps.    */
DECL|method|processReport (final DatanodeID nodeID, final String poolId, final BlockListAsLongs newReport)
specifier|public
name|void
name|processReport
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|,
specifier|final
name|String
name|poolId
parameter_list|,
specifier|final
name|BlockListAsLongs
name|newReport
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
specifier|final
name|long
name|startTime
init|=
name|Util
operator|.
name|now
argument_list|()
decl_stmt|;
comment|//after acquiring write lock
specifier|final
name|long
name|endTime
decl_stmt|;
try|try
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|nodeID
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|||
operator|!
name|node
operator|.
name|isAlive
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ProcessReport from dead or unregistered node: "
operator|+
name|nodeID
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|// To minimize startup time, we discard any second (or later) block reports
comment|// that we receive while still in startup phase.
if|if
condition|(
name|namesystem
operator|.
name|isInStartupSafeMode
argument_list|()
operator|&&
name|node
operator|.
name|numBlocks
argument_list|()
operator|>
literal|0
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport: "
operator|+
literal|"discarded non-initial block report from "
operator|+
name|nodeID
operator|.
name|getName
argument_list|()
operator|+
literal|" because namenode still in startup phase"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|node
operator|.
name|numBlocks
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// The first block report can be processed a lot more efficiently than
comment|// ordinary block reports.  This shortens restart times.
name|processFirstBlockReport
argument_list|(
name|node
argument_list|,
name|newReport
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processReport
argument_list|(
name|node
argument_list|,
name|newReport
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|endTime
operator|=
name|Util
operator|.
name|now
argument_list|()
expr_stmt|;
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|// Log the block report processing stats from Namenode perspective
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|addBlockReport
argument_list|(
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport: from "
operator|+
name|nodeID
operator|.
name|getName
argument_list|()
operator|+
literal|", blocks: "
operator|+
name|newReport
operator|.
name|getNumberOfBlocks
argument_list|()
operator|+
literal|", processing time: "
operator|+
operator|(
name|endTime
operator|-
name|startTime
operator|)
operator|+
literal|" msecs"
argument_list|)
expr_stmt|;
block|}
DECL|method|processReport (final DatanodeDescriptor node, final BlockListAsLongs report)
specifier|private
name|void
name|processReport
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|node
parameter_list|,
specifier|final
name|BlockListAsLongs
name|report
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Normal case:
comment|// Modify the (block-->datanode) map, according to the difference
comment|// between the old and new block report.
comment|//
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toAdd
init|=
operator|new
name|LinkedList
argument_list|<
name|BlockInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Block
argument_list|>
name|toRemove
init|=
operator|new
name|LinkedList
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
init|=
operator|new
name|LinkedList
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toCorrupt
init|=
operator|new
name|LinkedList
argument_list|<
name|BlockInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
init|=
operator|new
name|LinkedList
argument_list|<
name|StatefulBlockInfo
argument_list|>
argument_list|()
decl_stmt|;
name|reportDiff
argument_list|(
name|node
argument_list|,
name|report
argument_list|,
name|toAdd
argument_list|,
name|toRemove
argument_list|,
name|toInvalidate
argument_list|,
name|toCorrupt
argument_list|,
name|toUC
argument_list|)
expr_stmt|;
comment|// Process the blocks on each queue
for|for
control|(
name|StatefulBlockInfo
name|b
range|:
name|toUC
control|)
block|{
name|addStoredBlockUnderConstruction
argument_list|(
name|b
operator|.
name|storedBlock
argument_list|,
name|node
argument_list|,
name|b
operator|.
name|reportedState
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Block
name|b
range|:
name|toRemove
control|)
block|{
name|removeStoredBlock
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockInfo
name|b
range|:
name|toAdd
control|)
block|{
name|addStoredBlock
argument_list|(
name|b
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Block
name|b
range|:
name|toInvalidate
control|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport: block "
operator|+
name|b
operator|+
literal|" on "
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|" size "
operator|+
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" does not belong to any file."
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockInfo
name|b
range|:
name|toCorrupt
control|)
block|{
name|markBlockAsCorrupt
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * processFirstBlockReport is intended only for processing "initial" block    * reports, the first block report received from a DN after it registers.    * It just adds all the valid replicas to the datanode, without calculating     * a toRemove list (since there won't be any).  It also silently discards     * any invalid blocks, thereby deferring their processing until     * the next block report.    * @param node - DatanodeDescriptor of the node that sent the report    * @param report - the initial block report, to be processed    * @throws IOException     */
DECL|method|processFirstBlockReport (final DatanodeDescriptor node, final BlockListAsLongs report)
specifier|private
name|void
name|processFirstBlockReport
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|node
parameter_list|,
specifier|final
name|BlockListAsLongs
name|report
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|report
operator|==
literal|null
condition|)
return|return;
assert|assert
operator|(
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
assert|assert
operator|(
name|node
operator|.
name|numBlocks
argument_list|()
operator|==
literal|0
operator|)
assert|;
name|BlockReportIterator
name|itBR
init|=
name|report
operator|.
name|getBlockReportIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itBR
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Block
name|iblk
init|=
name|itBR
operator|.
name|next
argument_list|()
decl_stmt|;
name|ReplicaState
name|reportedState
init|=
name|itBR
operator|.
name|getCurrentReplicaState
argument_list|()
decl_stmt|;
name|BlockInfo
name|storedBlock
init|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|iblk
argument_list|)
decl_stmt|;
comment|// If block does not belong to any file, we are done.
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
continue|continue;
comment|// If block is corrupt, mark it and continue to next block.
name|BlockUCState
name|ucState
init|=
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
if|if
condition|(
name|isReplicaCorrupt
argument_list|(
name|iblk
argument_list|,
name|reportedState
argument_list|,
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|markBlockAsCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// If block is under construction, add this replica to its list
if|if
condition|(
name|isBlockUnderConstruction
argument_list|(
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|reportedState
argument_list|)
condition|)
block|{
operator|(
operator|(
name|BlockInfoUnderConstruction
operator|)
name|storedBlock
operator|)
operator|.
name|addReplicaIfNotPresent
argument_list|(
name|node
argument_list|,
name|iblk
argument_list|,
name|reportedState
argument_list|)
expr_stmt|;
comment|//and fall through to next clause
block|}
comment|//add replica if appropriate
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|addStoredBlockImmediate
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|reportDiff (DatanodeDescriptor dn, BlockListAsLongs newReport, Collection<BlockInfo> toAdd, Collection<Block> toRemove, Collection<Block> toInvalidate, Collection<BlockInfo> toCorrupt, Collection<StatefulBlockInfo> toUC)
specifier|private
name|void
name|reportDiff
parameter_list|(
name|DatanodeDescriptor
name|dn
parameter_list|,
name|BlockListAsLongs
name|newReport
parameter_list|,
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toAdd
parameter_list|,
comment|// add to DatanodeDescriptor
name|Collection
argument_list|<
name|Block
argument_list|>
name|toRemove
parameter_list|,
comment|// remove from DatanodeDescriptor
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
parameter_list|,
comment|// should be removed from DN
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toCorrupt
parameter_list|,
comment|// add to corrupt replicas list
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
parameter_list|)
block|{
comment|// add to under-construction list
comment|// place a delimiter in the list which separates blocks
comment|// that have been reported from those that have not
name|BlockInfo
name|delimiter
init|=
operator|new
name|BlockInfo
argument_list|(
operator|new
name|Block
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|boolean
name|added
init|=
name|dn
operator|.
name|addBlock
argument_list|(
name|delimiter
argument_list|)
decl_stmt|;
assert|assert
name|added
operator|:
literal|"Delimiting block cannot be present in the node"
assert|;
name|int
name|headIndex
init|=
literal|0
decl_stmt|;
comment|//currently the delimiter is in the head of the list
name|int
name|curIndex
decl_stmt|;
if|if
condition|(
name|newReport
operator|==
literal|null
condition|)
name|newReport
operator|=
operator|new
name|BlockListAsLongs
argument_list|()
expr_stmt|;
comment|// scan the report and process newly reported blocks
name|BlockReportIterator
name|itBR
init|=
name|newReport
operator|.
name|getBlockReportIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itBR
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Block
name|iblk
init|=
name|itBR
operator|.
name|next
argument_list|()
decl_stmt|;
name|ReplicaState
name|iState
init|=
name|itBR
operator|.
name|getCurrentReplicaState
argument_list|()
decl_stmt|;
name|BlockInfo
name|storedBlock
init|=
name|processReportedBlock
argument_list|(
name|dn
argument_list|,
name|iblk
argument_list|,
name|iState
argument_list|,
name|toAdd
argument_list|,
name|toInvalidate
argument_list|,
name|toCorrupt
argument_list|,
name|toUC
argument_list|)
decl_stmt|;
comment|// move block to the head of the list
if|if
condition|(
name|storedBlock
operator|!=
literal|null
operator|&&
operator|(
name|curIndex
operator|=
name|storedBlock
operator|.
name|findDatanode
argument_list|(
name|dn
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|headIndex
operator|=
name|dn
operator|.
name|moveBlockToHead
argument_list|(
name|storedBlock
argument_list|,
name|curIndex
argument_list|,
name|headIndex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// collect blocks that have not been reported
comment|// all of them are next to the delimiter
name|Iterator
argument_list|<
name|?
extends|extends
name|Block
argument_list|>
name|it
init|=
operator|new
name|DatanodeDescriptor
operator|.
name|BlockIterator
argument_list|(
name|delimiter
operator|.
name|getNext
argument_list|(
literal|0
argument_list|)
argument_list|,
name|dn
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
name|toRemove
operator|.
name|add
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|dn
operator|.
name|removeBlock
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process a block replica reported by the data-node.    * No side effects except adding to the passed-in Collections.    *     *<ol>    *<li>If the block is not known to the system (not in blocksMap) then the    * data-node should be notified to invalidate this block.</li>    *<li>If the reported replica is valid that is has the same generation stamp    * and length as recorded on the name-node, then the replica location should    * be added to the name-node.</li>    *<li>If the reported replica is not valid, then it is marked as corrupt,    * which triggers replication of the existing valid replicas.    * Corrupt replicas are removed from the system when the block    * is fully replicated.</li>    *<li>If the reported replica is for a block currently marked "under    * construction" in the NN, then it should be added to the     * BlockInfoUnderConstruction's list of replicas.</li>    *</ol>    *     * @param dn descriptor for the datanode that made the report    * @param block reported block replica    * @param reportedState reported replica state    * @param toAdd add to DatanodeDescriptor    * @param toInvalidate missing blocks (not in the blocks map)    *        should be removed from the data-node    * @param toCorrupt replicas with unexpected length or generation stamp;    *        add to corrupt replicas    * @param toUC replicas of blocks currently under construction    * @return    */
DECL|method|processReportedBlock (final DatanodeDescriptor dn, final Block block, final ReplicaState reportedState, final Collection<BlockInfo> toAdd, final Collection<Block> toInvalidate, final Collection<BlockInfo> toCorrupt, final Collection<StatefulBlockInfo> toUC)
specifier|private
name|BlockInfo
name|processReportedBlock
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|dn
parameter_list|,
specifier|final
name|Block
name|block
parameter_list|,
specifier|final
name|ReplicaState
name|reportedState
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toAdd
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toCorrupt
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reported block "
operator|+
name|block
operator|+
literal|" on "
operator|+
name|dn
operator|.
name|getName
argument_list|()
operator|+
literal|" size "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" replicaState = "
operator|+
name|reportedState
argument_list|)
expr_stmt|;
block|}
comment|// find block by blockId
name|BlockInfo
name|storedBlock
init|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
comment|// If blocksMap does not contain reported block id,
comment|// the replica should be removed from the data-node.
name|toInvalidate
operator|.
name|add
argument_list|(
operator|new
name|Block
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|BlockUCState
name|ucState
init|=
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
comment|// Block is on the NN
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"In memory blockUCState = "
operator|+
name|ucState
argument_list|)
expr_stmt|;
block|}
comment|// Ignore replicas already scheduled to be removed from the DN
if|if
condition|(
name|invalidateBlocks
operator|.
name|contains
argument_list|(
name|dn
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|block
argument_list|)
condition|)
block|{
assert|assert
name|storedBlock
operator|.
name|findDatanode
argument_list|(
name|dn
argument_list|)
operator|<
literal|0
operator|:
literal|"Block "
operator|+
name|block
operator|+
literal|" in recentInvalidatesSet should not appear in DN "
operator|+
name|dn
assert|;
return|return
name|storedBlock
return|;
block|}
if|if
condition|(
name|isReplicaCorrupt
argument_list|(
name|block
argument_list|,
name|reportedState
argument_list|,
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|dn
argument_list|)
condition|)
block|{
name|toCorrupt
operator|.
name|add
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
return|return
name|storedBlock
return|;
block|}
if|if
condition|(
name|isBlockUnderConstruction
argument_list|(
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|reportedState
argument_list|)
condition|)
block|{
name|toUC
operator|.
name|add
argument_list|(
operator|new
name|StatefulBlockInfo
argument_list|(
operator|(
name|BlockInfoUnderConstruction
operator|)
name|storedBlock
argument_list|,
name|reportedState
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|storedBlock
return|;
block|}
comment|//add replica if appropriate
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
name|storedBlock
operator|.
name|findDatanode
argument_list|(
name|dn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|toAdd
operator|.
name|add
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
return|return
name|storedBlock
return|;
block|}
comment|/*    * The next two methods test the various cases under which we must conclude    * the replica is corrupt, or under construction.  These are laid out    * as switch statements, on the theory that it is easier to understand    * the combinatorics of reportedState and ucState that way.  It should be    * at least as efficient as boolean expressions.    */
DECL|method|isReplicaCorrupt (Block iblk, ReplicaState reportedState, BlockInfo storedBlock, BlockUCState ucState, DatanodeDescriptor dn)
specifier|private
name|boolean
name|isReplicaCorrupt
parameter_list|(
name|Block
name|iblk
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|,
name|BlockInfo
name|storedBlock
parameter_list|,
name|BlockUCState
name|ucState
parameter_list|,
name|DatanodeDescriptor
name|dn
parameter_list|)
block|{
switch|switch
condition|(
name|reportedState
condition|)
block|{
case|case
name|FINALIZED
case|:
switch|switch
condition|(
name|ucState
condition|)
block|{
case|case
name|COMPLETE
case|:
case|case
name|COMMITTED
case|:
return|return
operator|(
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|iblk
operator|.
name|getGenerationStamp
argument_list|()
operator|||
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|iblk
operator|.
name|getNumBytes
argument_list|()
operator|)
return|;
default|default:
return|return
literal|false
return|;
block|}
case|case
name|RBW
case|:
case|case
name|RWR
case|:
return|return
name|storedBlock
operator|.
name|isComplete
argument_list|()
return|;
case|case
name|RUR
case|:
comment|// should not be reported
case|case
name|TEMPORARY
case|:
comment|// should not be reported
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected replica state "
operator|+
name|reportedState
operator|+
literal|" for block: "
operator|+
name|storedBlock
operator|+
literal|" on "
operator|+
name|dn
operator|.
name|getName
argument_list|()
operator|+
literal|" size "
operator|+
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|method|isBlockUnderConstruction (BlockInfo storedBlock, BlockUCState ucState, ReplicaState reportedState)
specifier|private
name|boolean
name|isBlockUnderConstruction
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|BlockUCState
name|ucState
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|)
block|{
switch|switch
condition|(
name|reportedState
condition|)
block|{
case|case
name|FINALIZED
case|:
switch|switch
condition|(
name|ucState
condition|)
block|{
case|case
name|UNDER_CONSTRUCTION
case|:
case|case
name|UNDER_RECOVERY
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
case|case
name|RBW
case|:
case|case
name|RWR
case|:
return|return
operator|(
operator|!
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|)
return|;
case|case
name|RUR
case|:
comment|// should not be reported
case|case
name|TEMPORARY
case|:
comment|// should not be reported
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|method|addStoredBlockUnderConstruction ( BlockInfoUnderConstruction block, DatanodeDescriptor node, ReplicaState reportedState)
name|void
name|addStoredBlockUnderConstruction
parameter_list|(
name|BlockInfoUnderConstruction
name|block
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|)
throws|throws
name|IOException
block|{
name|block
operator|.
name|addReplicaIfNotPresent
argument_list|(
name|node
argument_list|,
name|block
argument_list|,
name|reportedState
argument_list|)
expr_stmt|;
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
name|block
operator|.
name|findDatanode
argument_list|(
name|node
argument_list|)
operator|<
literal|0
condition|)
block|{
name|addStoredBlock
argument_list|(
name|block
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Faster version of {@link addStoredBlock()}, intended for use with     * initial block report at startup.  If not in startup safe mode, will    * call standard addStoredBlock().    * Assumes this method is called "immediately" so there is no need to    * refresh the storedBlock from blocksMap.    * Doesn't handle underReplication/overReplication, or worry about    * pendingReplications or corruptReplicas, because it's in startup safe mode.    * Doesn't log every block, because there are typically millions of them.    * @throws IOException    */
DECL|method|addStoredBlockImmediate (BlockInfo storedBlock, DatanodeDescriptor node)
specifier|private
name|void
name|addStoredBlockImmediate
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|(
name|storedBlock
operator|!=
literal|null
operator|&&
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isInStartupSafeMode
argument_list|()
operator|||
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
name|addStoredBlock
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// just add it
name|node
operator|.
name|addBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
comment|// Now check for completion of blocks and safe block count
name|int
name|numCurrentReplica
init|=
name|countLiveNodes
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|COMMITTED
operator|&&
name|numCurrentReplica
operator|>=
name|minReplication
condition|)
name|storedBlock
operator|=
name|completeBlock
argument_list|(
name|storedBlock
operator|.
name|getINode
argument_list|()
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
comment|// check whether safe replication is reached for the block
comment|// only complete blocks are counted towards that
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
condition|)
name|namesystem
operator|.
name|incrementSafeBlockCount
argument_list|(
name|numCurrentReplica
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify (block-->datanode) map. Remove block from set of    * needed replications if this takes care of the problem.    * @return the block that is stored in blockMap.    */
DECL|method|addStoredBlock (final BlockInfo block, DatanodeDescriptor node, DatanodeDescriptor delNodeHint, boolean logEveryBlock)
specifier|private
name|Block
name|addStoredBlock
parameter_list|(
specifier|final
name|BlockInfo
name|block
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|,
name|boolean
name|logEveryBlock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|block
operator|!=
literal|null
operator|&&
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|BlockInfo
name|storedBlock
decl_stmt|;
if|if
condition|(
name|block
operator|instanceof
name|BlockInfoUnderConstruction
condition|)
block|{
comment|//refresh our copy in case the block got completed in another thread
name|storedBlock
operator|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storedBlock
operator|=
name|block
expr_stmt|;
block|}
if|if
condition|(
name|storedBlock
operator|==
literal|null
operator|||
name|storedBlock
operator|.
name|getINode
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// If this block does not belong to anyfile, then we are done.
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* addStoredBlock: "
operator|+
name|block
operator|+
literal|" on "
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|" size "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" but it does not belong to any file."
argument_list|)
expr_stmt|;
comment|// we could add this block to invalidate set of this datanode.
comment|// it will happen in next block report otherwise.
return|return
name|block
return|;
block|}
assert|assert
name|storedBlock
operator|!=
literal|null
operator|:
literal|"Block must be stored by now"
assert|;
name|INodeFile
name|fileINode
init|=
name|storedBlock
operator|.
name|getINode
argument_list|()
decl_stmt|;
assert|assert
name|fileINode
operator|!=
literal|null
operator|:
literal|"Block must belong to a file"
assert|;
comment|// add block to the datanode
name|boolean
name|added
init|=
name|node
operator|.
name|addBlock
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
name|int
name|curReplicaDelta
decl_stmt|;
if|if
condition|(
name|added
condition|)
block|{
name|curReplicaDelta
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|logEveryBlock
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* addStoredBlock: "
operator|+
literal|"blockMap updated: "
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|" is added to "
operator|+
name|storedBlock
operator|+
literal|" size "
operator|+
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|curReplicaDelta
operator|=
literal|0
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* addStoredBlock: "
operator|+
literal|"Redundant addStoredBlock request received for "
operator|+
name|storedBlock
operator|+
literal|" on "
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|" size "
operator|+
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Now check for completion of blocks and safe block count
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
name|int
name|numLiveReplicas
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
name|int
name|numCurrentReplica
init|=
name|numLiveReplicas
operator|+
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|COMMITTED
operator|&&
name|numLiveReplicas
operator|>=
name|minReplication
condition|)
name|storedBlock
operator|=
name|completeBlock
argument_list|(
name|fileINode
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
comment|// check whether safe replication is reached for the block
comment|// only complete blocks are counted towards that
comment|// Is no-op if not in safe mode.
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
condition|)
name|namesystem
operator|.
name|incrementSafeBlockCount
argument_list|(
name|numCurrentReplica
argument_list|)
expr_stmt|;
comment|// if file is under construction, then done for now
if|if
condition|(
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
return|return
name|storedBlock
return|;
block|}
comment|// do not try to handle over/under-replicated blocks during safe mode
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return
name|storedBlock
return|;
block|}
comment|// handle underReplication/overReplication
name|short
name|fileReplication
init|=
name|fileINode
operator|.
name|getReplication
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isNeededReplication
argument_list|(
name|storedBlock
argument_list|,
name|fileReplication
argument_list|,
name|numCurrentReplica
argument_list|)
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|storedBlock
argument_list|,
name|numCurrentReplica
argument_list|,
name|num
operator|.
name|decommissionedReplicas
argument_list|()
argument_list|,
name|fileReplication
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updateNeededReplications
argument_list|(
name|storedBlock
argument_list|,
name|curReplicaDelta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numCurrentReplica
operator|>
name|fileReplication
condition|)
block|{
name|processOverReplicatedBlock
argument_list|(
name|storedBlock
argument_list|,
name|fileReplication
argument_list|,
name|node
argument_list|,
name|delNodeHint
argument_list|)
expr_stmt|;
block|}
comment|// If the file replication has reached desired value
comment|// we can remove any corrupt replicas the block may have
name|int
name|corruptReplicasCount
init|=
name|corruptReplicas
operator|.
name|numCorruptReplicas
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
name|int
name|numCorruptNodes
init|=
name|num
operator|.
name|corruptReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|numCorruptNodes
operator|!=
name|corruptReplicasCount
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Inconsistent number of corrupt replicas for "
operator|+
name|storedBlock
operator|+
literal|"blockMap has "
operator|+
name|numCorruptNodes
operator|+
literal|" but corrupt replicas map has "
operator|+
name|corruptReplicasCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|corruptReplicasCount
operator|>
literal|0
operator|)
operator|&&
operator|(
name|numLiveReplicas
operator|>=
name|fileReplication
operator|)
condition|)
name|invalidateCorruptReplicas
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
return|return
name|storedBlock
return|;
block|}
comment|/**    * Invalidate corrupt replicas.    *<p>    * This will remove the replicas from the block's location list,    * add them to {@link #recentInvalidateSets} so that they could be further    * deleted from the respective data-nodes,    * and remove the block from corruptReplicasMap.    *<p>    * This method should be called when the block has sufficient    * number of live replicas.    *    * @param blk Block whose corrupt replicas need to be invalidated    */
DECL|method|invalidateCorruptReplicas (Block blk)
specifier|private
name|void
name|invalidateCorruptReplicas
parameter_list|(
name|Block
name|blk
parameter_list|)
block|{
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|boolean
name|gotException
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
return|return;
comment|// make a copy of the array of nodes in order to avoid
comment|// ConcurrentModificationException, when the block is removed from the node
name|DatanodeDescriptor
index|[]
name|nodesCopy
init|=
name|nodes
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeDescriptor
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|nodesCopy
control|)
block|{
try|try
block|{
name|invalidateBlock
argument_list|(
name|blk
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"NameNode.invalidateCorruptReplicas "
operator|+
literal|"error in deleting bad block "
operator|+
name|blk
operator|+
literal|" on "
operator|+
name|node
operator|+
name|e
argument_list|)
expr_stmt|;
name|gotException
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Remove the block from corruptReplicasMap
if|if
condition|(
operator|!
name|gotException
condition|)
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
comment|/**    * For each block in the name-node verify whether it belongs to any file,    * over or under replicated. Place it into the respective queue.    */
DECL|method|processMisReplicatedBlocks ()
specifier|public
name|void
name|processMisReplicatedBlocks
parameter_list|()
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|long
name|nrInvalid
init|=
literal|0
decl_stmt|,
name|nrOverReplicated
init|=
literal|0
decl_stmt|,
name|nrUnderReplicated
init|=
literal|0
decl_stmt|;
name|neededReplications
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|BlockInfo
name|block
range|:
name|blocksMap
operator|.
name|getBlocks
argument_list|()
control|)
block|{
name|INodeFile
name|fileINode
init|=
name|block
operator|.
name|getINode
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileINode
operator|==
literal|null
condition|)
block|{
comment|// block does not belong to any file
name|nrInvalid
operator|++
expr_stmt|;
name|addToInvalidates
argument_list|(
name|block
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// calculate current replication
name|short
name|expectedReplication
init|=
name|fileINode
operator|.
name|getReplication
argument_list|()
decl_stmt|;
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|numCurrentReplica
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
comment|// add to under-replicated queue if need to be
if|if
condition|(
name|isNeededReplication
argument_list|(
name|block
argument_list|,
name|expectedReplication
argument_list|,
name|numCurrentReplica
argument_list|)
condition|)
block|{
if|if
condition|(
name|neededReplications
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|numCurrentReplica
argument_list|,
name|num
operator|.
name|decommissionedReplicas
argument_list|()
argument_list|,
name|expectedReplication
argument_list|)
condition|)
block|{
name|nrUnderReplicated
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numCurrentReplica
operator|>
name|expectedReplication
condition|)
block|{
comment|// over-replicated block
name|nrOverReplicated
operator|++
expr_stmt|;
name|processOverReplicatedBlock
argument_list|(
name|block
argument_list|,
name|expectedReplication
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Total number of blocks            = "
operator|+
name|blocksMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of invalid blocks          = "
operator|+
name|nrInvalid
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of under-replicated blocks = "
operator|+
name|nrUnderReplicated
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of  over-replicated blocks = "
operator|+
name|nrOverReplicated
argument_list|)
expr_stmt|;
block|}
comment|/** Set replication for the blocks. */
DECL|method|setReplication (final short oldRepl, final short newRepl, final String src, final Block... blocks)
specifier|public
name|void
name|setReplication
parameter_list|(
specifier|final
name|short
name|oldRepl
parameter_list|,
specifier|final
name|short
name|newRepl
parameter_list|,
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|Block
modifier|...
name|blocks
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|newRepl
operator|==
name|oldRepl
condition|)
block|{
return|return;
block|}
comment|// update needReplication priority queues
for|for
control|(
name|Block
name|b
range|:
name|blocks
control|)
block|{
name|updateNeededReplications
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|newRepl
operator|-
name|oldRepl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldRepl
operator|>
name|newRepl
condition|)
block|{
comment|// old replication> the new one; need to remove copies
name|LOG
operator|.
name|info
argument_list|(
literal|"Decreasing replication from "
operator|+
name|oldRepl
operator|+
literal|" to "
operator|+
name|newRepl
operator|+
literal|" for "
operator|+
name|src
argument_list|)
expr_stmt|;
for|for
control|(
name|Block
name|b
range|:
name|blocks
control|)
block|{
name|processOverReplicatedBlock
argument_list|(
name|b
argument_list|,
name|newRepl
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// replication factor is increased
name|LOG
operator|.
name|info
argument_list|(
literal|"Increasing replication from "
operator|+
name|oldRepl
operator|+
literal|" to "
operator|+
name|newRepl
operator|+
literal|" for "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Find how many of the containing nodes are "extra", if any.    * If there are any extras, call chooseExcessReplicates() to    * mark them in the excessReplicateMap.    */
DECL|method|processOverReplicatedBlock (final Block block, final short replication, final DatanodeDescriptor addedNode, DatanodeDescriptor delNodeHint)
specifier|private
name|void
name|processOverReplicatedBlock
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|DatanodeDescriptor
name|addedNode
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|addedNode
operator|==
name|delNodeHint
condition|)
block|{
name|delNodeHint
operator|=
literal|null
expr_stmt|;
block|}
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nonExcess
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|block
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DatanodeDescriptor
name|cur
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|excessBlocks
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|cur
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|excessBlocks
operator|==
literal|null
operator|||
operator|!
name|excessBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cur
operator|.
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|cur
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
comment|// exclude corrupt replicas
if|if
condition|(
name|corruptNodes
operator|==
literal|null
operator|||
operator|!
name|corruptNodes
operator|.
name|contains
argument_list|(
name|cur
argument_list|)
condition|)
block|{
name|nonExcess
operator|.
name|add
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|chooseExcessReplicates
argument_list|(
name|nonExcess
argument_list|,
name|block
argument_list|,
name|replication
argument_list|,
name|addedNode
argument_list|,
name|delNodeHint
argument_list|,
name|blockplacement
argument_list|)
expr_stmt|;
block|}
comment|/**    * We want "replication" replicates for the block, but we now have too many.      * In this method, copy enough nodes from 'srcNodes' into 'dstNodes' such that:    *    * srcNodes.size() - dstNodes.size() == replication    *    * We pick node that make sure that replicas are spread across racks and    * also try hard to pick one with least free space.    * The algorithm is first to pick a node with least free space from nodes    * that are on a rack holding more than one replicas of the block.    * So removing such a replica won't remove a rack.     * If no such a node is available,    * then pick a node with least free space    */
DECL|method|chooseExcessReplicates (Collection<DatanodeDescriptor> nonExcess, Block b, short replication, DatanodeDescriptor addedNode, DatanodeDescriptor delNodeHint, BlockPlacementPolicy replicator)
specifier|private
name|void
name|chooseExcessReplicates
parameter_list|(
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nonExcess
parameter_list|,
name|Block
name|b
parameter_list|,
name|short
name|replication
parameter_list|,
name|DatanodeDescriptor
name|addedNode
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|,
name|BlockPlacementPolicy
name|replicator
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
comment|// first form a rack to datanodes map and
name|INodeFile
name|inode
init|=
name|getINode
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|>
name|rackMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|iter
init|=
name|nonExcess
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|String
name|rackName
init|=
name|node
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|datanodeList
init|=
name|rackMap
operator|.
name|get
argument_list|(
name|rackName
argument_list|)
decl_stmt|;
if|if
condition|(
name|datanodeList
operator|==
literal|null
condition|)
block|{
name|datanodeList
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
expr_stmt|;
name|rackMap
operator|.
name|put
argument_list|(
name|rackName
argument_list|,
name|datanodeList
argument_list|)
expr_stmt|;
block|}
name|datanodeList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|// split nodes into two sets
comment|// priSet contains nodes on rack with more than one replica
comment|// remains contains the remaining nodes
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|priSet
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|remains
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|datanodeList
range|:
name|rackMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|datanodeList
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|remains
operator|.
name|add
argument_list|(
name|datanodeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|priSet
operator|.
name|addAll
argument_list|(
name|datanodeList
argument_list|)
expr_stmt|;
block|}
block|}
comment|// pick one node to delete that favors the delete hint
comment|// otherwise pick one with least space from priSet if it is not empty
comment|// otherwise one node with least space from remains
name|boolean
name|firstOne
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|nonExcess
operator|.
name|size
argument_list|()
operator|-
name|replication
operator|>
literal|0
condition|)
block|{
comment|// check if we can delete delNodeHint
specifier|final
name|DatanodeInfo
name|cur
decl_stmt|;
if|if
condition|(
name|firstOne
operator|&&
name|delNodeHint
operator|!=
literal|null
operator|&&
name|nonExcess
operator|.
name|contains
argument_list|(
name|delNodeHint
argument_list|)
operator|&&
operator|(
name|priSet
operator|.
name|contains
argument_list|(
name|delNodeHint
argument_list|)
operator|||
operator|(
name|addedNode
operator|!=
literal|null
operator|&&
operator|!
name|priSet
operator|.
name|contains
argument_list|(
name|addedNode
argument_list|)
operator|)
operator|)
condition|)
block|{
name|cur
operator|=
name|delNodeHint
expr_stmt|;
block|}
else|else
block|{
comment|// regular excessive replica removal
name|cur
operator|=
name|replicator
operator|.
name|chooseReplicaToDelete
argument_list|(
name|inode
argument_list|,
name|b
argument_list|,
name|replication
argument_list|,
name|priSet
argument_list|,
name|remains
argument_list|)
expr_stmt|;
block|}
name|firstOne
operator|=
literal|false
expr_stmt|;
comment|// adjust rackmap, priSet, and remains
name|String
name|rack
init|=
name|cur
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|datanodes
init|=
name|rackMap
operator|.
name|get
argument_list|(
name|rack
argument_list|)
decl_stmt|;
name|datanodes
operator|.
name|remove
argument_list|(
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rackMap
operator|.
name|remove
argument_list|(
name|rack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|priSet
operator|.
name|remove
argument_list|(
name|cur
argument_list|)
condition|)
block|{
if|if
condition|(
name|datanodes
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|priSet
operator|.
name|remove
argument_list|(
name|datanodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|remains
operator|.
name|add
argument_list|(
name|datanodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|remains
operator|.
name|remove
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
name|nonExcess
operator|.
name|remove
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|addToExcessReplicate
argument_list|(
name|cur
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|//
comment|// The 'excessblocks' tracks blocks until we get confirmation
comment|// that the datanode has deleted them; the only way we remove them
comment|// is when we get a "removeBlock" message.
comment|//
comment|// The 'invalidate' list is used to inform the datanode the block
comment|// should be deleted.  Items are removed from the invalidate list
comment|// upon giving instructions to the namenode.
comment|//
name|addToInvalidates
argument_list|(
name|b
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* chooseExcessReplicates: "
operator|+
literal|"("
operator|+
name|cur
operator|.
name|getName
argument_list|()
operator|+
literal|", "
operator|+
name|b
operator|+
literal|") is added to recentInvalidateSets"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addToExcessReplicate (DatanodeInfo dn, Block block)
specifier|private
name|void
name|addToExcessReplicate
parameter_list|(
name|DatanodeInfo
name|dn
parameter_list|,
name|Block
name|block
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|excessBlocks
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|dn
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|excessBlocks
operator|==
literal|null
condition|)
block|{
name|excessBlocks
operator|=
operator|new
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
argument_list|()
expr_stmt|;
name|excessReplicateMap
operator|.
name|put
argument_list|(
name|dn
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|excessBlocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|excessBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|excessBlocksCount
operator|++
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* addToExcessReplicate:"
operator|+
literal|" ("
operator|+
name|dn
operator|.
name|getName
argument_list|()
operator|+
literal|", "
operator|+
name|block
operator|+
literal|") is added to excessReplicateMap"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Modify (block-->datanode) map. Possibly generate replication tasks, if the    * removed block is still valid.    */
DECL|method|removeStoredBlock (Block block, DatanodeDescriptor node)
specifier|public
name|void
name|removeStoredBlock
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* removeStoredBlock: "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|node
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
operator|(
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
block|{
if|if
condition|(
operator|!
name|blocksMap
operator|.
name|removeNode
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* removeStoredBlock: "
operator|+
name|block
operator|+
literal|" has already been removed from node "
operator|+
name|node
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|//
comment|// It's possible that the block was removed because of a datanode
comment|// failure. If the block is still valid, check if replication is
comment|// necessary. In that case, put block on a possibly-will-
comment|// be-replicated list.
comment|//
name|INode
name|fileINode
init|=
name|blocksMap
operator|.
name|getINode
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileINode
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|decrementSafeBlockCount
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|updateNeededReplications
argument_list|(
name|block
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// We've removed a block from a node, so it's definitely no longer
comment|// in "excess" there.
comment|//
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|excessBlocks
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|node
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|excessBlocks
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|excessBlocks
operator|.
name|remove
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|excessBlocksCount
operator|--
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* removeStoredBlock: "
operator|+
name|block
operator|+
literal|" is removed from excessBlocks"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|excessBlocks
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|excessReplicateMap
operator|.
name|remove
argument_list|(
name|node
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remove the replica from corruptReplicas
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get all valid locations of the block& add the block to results    * return the length of the added block; 0 if the block is not added    */
DECL|method|addBlock (Block block, List<BlockWithLocations> results)
specifier|private
name|long
name|addBlock
parameter_list|(
name|Block
name|block
parameter_list|,
name|List
argument_list|<
name|BlockWithLocations
argument_list|>
name|results
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|machineSet
init|=
name|getValidLocations
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|machineSet
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
name|results
operator|.
name|add
argument_list|(
operator|new
name|BlockWithLocations
argument_list|(
name|block
argument_list|,
name|machineSet
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|machineSet
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|block
operator|.
name|getNumBytes
argument_list|()
return|;
block|}
block|}
comment|/**    * The given node is reporting that it received a certain block.    */
annotation|@
name|VisibleForTesting
DECL|method|addBlock (DatanodeDescriptor node, Block block, String delHint)
name|void
name|addBlock
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|,
name|Block
name|block
parameter_list|,
name|String
name|delHint
parameter_list|)
throws|throws
name|IOException
block|{
comment|// decrement number of blocks scheduled to this datanode.
name|node
operator|.
name|decBlocksScheduled
argument_list|()
expr_stmt|;
comment|// get the deletion hint node
name|DatanodeDescriptor
name|delHintNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|delHint
operator|!=
literal|null
operator|&&
name|delHint
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|delHintNode
operator|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|delHint
argument_list|)
expr_stmt|;
if|if
condition|(
name|delHintNode
operator|==
literal|null
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* blockReceived: "
operator|+
name|block
operator|+
literal|" is expected to be removed from an unrecorded node "
operator|+
name|delHint
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Modify the blocks->datanode map and node's map.
comment|//
name|pendingReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// blockReceived reports a finalized block
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toAdd
init|=
operator|new
name|LinkedList
argument_list|<
name|BlockInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
init|=
operator|new
name|LinkedList
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toCorrupt
init|=
operator|new
name|LinkedList
argument_list|<
name|BlockInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
init|=
operator|new
name|LinkedList
argument_list|<
name|StatefulBlockInfo
argument_list|>
argument_list|()
decl_stmt|;
name|processReportedBlock
argument_list|(
name|node
argument_list|,
name|block
argument_list|,
name|ReplicaState
operator|.
name|FINALIZED
argument_list|,
name|toAdd
argument_list|,
name|toInvalidate
argument_list|,
name|toCorrupt
argument_list|,
name|toUC
argument_list|)
expr_stmt|;
comment|// the block is only in one of the to-do lists
comment|// if it is in none then data-node already has it
assert|assert
name|toUC
operator|.
name|size
argument_list|()
operator|+
name|toAdd
operator|.
name|size
argument_list|()
operator|+
name|toInvalidate
operator|.
name|size
argument_list|()
operator|+
name|toCorrupt
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|:
literal|"The block should be only in one of the lists."
assert|;
for|for
control|(
name|StatefulBlockInfo
name|b
range|:
name|toUC
control|)
block|{
name|addStoredBlockUnderConstruction
argument_list|(
name|b
operator|.
name|storedBlock
argument_list|,
name|node
argument_list|,
name|b
operator|.
name|reportedState
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockInfo
name|b
range|:
name|toAdd
control|)
block|{
name|addStoredBlock
argument_list|(
name|b
argument_list|,
name|node
argument_list|,
name|delHintNode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Block
name|b
range|:
name|toInvalidate
control|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* addBlock: block "
operator|+
name|b
operator|+
literal|" on "
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|" size "
operator|+
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" does not belong to any file."
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockInfo
name|b
range|:
name|toCorrupt
control|)
block|{
name|markBlockAsCorrupt
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** The given node is reporting that it received/deleted certain blocks. */
DECL|method|blockReceivedAndDeleted (final DatanodeID nodeID, final String poolId, final ReceivedDeletedBlockInfo receivedAndDeletedBlocks[] )
specifier|public
name|void
name|blockReceivedAndDeleted
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|,
specifier|final
name|String
name|poolId
parameter_list|,
specifier|final
name|ReceivedDeletedBlockInfo
name|receivedAndDeletedBlocks
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|int
name|received
init|=
literal|0
decl_stmt|;
name|int
name|deleted
init|=
literal|0
decl_stmt|;
try|try
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|nodeID
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|||
operator|!
name|node
operator|.
name|isAlive
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* blockReceivedDeleted"
operator|+
literal|" is received from dead or unregistered node "
operator|+
name|nodeID
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got blockReceivedDeleted message from unregistered or dead node"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|receivedAndDeletedBlocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|receivedAndDeletedBlocks
index|[
name|i
index|]
operator|.
name|isDeletedBlock
argument_list|()
condition|)
block|{
name|removeStoredBlock
argument_list|(
name|receivedAndDeletedBlocks
index|[
name|i
index|]
operator|.
name|getBlock
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|deleted
operator|++
expr_stmt|;
block|}
else|else
block|{
name|addBlock
argument_list|(
name|node
argument_list|,
name|receivedAndDeletedBlocks
index|[
name|i
index|]
operator|.
name|getBlock
argument_list|()
argument_list|,
name|receivedAndDeletedBlocks
index|[
name|i
index|]
operator|.
name|getDelHints
argument_list|()
argument_list|)
expr_stmt|;
name|received
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* block"
operator|+
operator|(
name|receivedAndDeletedBlocks
index|[
name|i
index|]
operator|.
name|isDeletedBlock
argument_list|()
condition|?
literal|"Deleted"
else|:
literal|"Received"
operator|)
operator|+
literal|": "
operator|+
name|receivedAndDeletedBlocks
index|[
name|i
index|]
operator|.
name|getBlock
argument_list|()
operator|+
literal|" is received from "
operator|+
name|nodeID
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"*BLOCK* NameNode.blockReceivedAndDeleted: "
operator|+
literal|"from "
operator|+
name|nodeID
operator|.
name|getName
argument_list|()
operator|+
literal|" received: "
operator|+
name|received
operator|+
literal|", "
operator|+
literal|" deleted: "
operator|+
name|deleted
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return the number of nodes that are live and decommissioned.    */
DECL|method|countNodes (Block b)
specifier|public
name|NumberReplicas
name|countNodes
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|live
init|=
literal|0
decl_stmt|;
name|int
name|corrupt
init|=
literal|0
decl_stmt|;
name|int
name|excess
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodeIter
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesCorrupt
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|b
argument_list|)
decl_stmt|;
while|while
condition|(
name|nodeIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|nodeIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|nodesCorrupt
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|nodesCorrupt
operator|.
name|contains
argument_list|(
name|node
argument_list|)
operator|)
condition|)
block|{
name|corrupt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
operator|||
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|blocksExcess
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|node
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocksExcess
operator|!=
literal|null
operator|&&
name|blocksExcess
operator|.
name|contains
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|excess
operator|++
expr_stmt|;
block|}
else|else
block|{
name|live
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|new
name|NumberReplicas
argument_list|(
name|live
argument_list|,
name|count
argument_list|,
name|corrupt
argument_list|,
name|excess
argument_list|)
return|;
block|}
comment|/**     * Simpler, faster form of {@link countNodes()} that only returns the number    * of live nodes.  If in startup safemode (or its 30-sec extension period),    * then it gains speed by ignoring issues of excess replicas or nodes    * that are decommissioned or in process of becoming decommissioned.    * If not in startup, then it calls {@link countNodes()} instead.    *     * @param b - the block being tested    * @return count of live nodes for this block    */
DECL|method|countLiveNodes (BlockInfo b)
name|int
name|countLiveNodes
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isInStartupSafeMode
argument_list|()
condition|)
block|{
return|return
name|countNodes
argument_list|(
name|b
argument_list|)
operator|.
name|liveReplicas
argument_list|()
return|;
block|}
comment|// else proceed with fast case
name|int
name|live
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodeIter
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesCorrupt
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|b
argument_list|)
decl_stmt|;
while|while
condition|(
name|nodeIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|nodeIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|nodesCorrupt
operator|==
literal|null
operator|)
operator|||
operator|(
operator|!
name|nodesCorrupt
operator|.
name|contains
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|live
operator|++
expr_stmt|;
block|}
return|return
name|live
return|;
block|}
DECL|method|logBlockReplicationInfo (Block block, DatanodeDescriptor srcNode, NumberReplicas num)
specifier|private
name|void
name|logBlockReplicationInfo
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeDescriptor
name|srcNode
parameter_list|,
name|NumberReplicas
name|num
parameter_list|)
block|{
name|int
name|curReplicas
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
name|int
name|curExpectedReplicas
init|=
name|getReplication
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|INode
name|fileINode
init|=
name|blocksMap
operator|.
name|getINode
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodeIter
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|StringBuilder
name|nodeList
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|nodeIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|nodeIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|nodeList
operator|.
name|append
argument_list|(
name|node
operator|.
name|name
argument_list|)
expr_stmt|;
name|nodeList
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Block: "
operator|+
name|block
operator|+
literal|", Expected Replicas: "
operator|+
name|curExpectedReplicas
operator|+
literal|", live replicas: "
operator|+
name|curReplicas
operator|+
literal|", corrupt replicas: "
operator|+
name|num
operator|.
name|corruptReplicas
argument_list|()
operator|+
literal|", decommissioned replicas: "
operator|+
name|num
operator|.
name|decommissionedReplicas
argument_list|()
operator|+
literal|", excess replicas: "
operator|+
name|num
operator|.
name|excessReplicas
argument_list|()
operator|+
literal|", Is Open File: "
operator|+
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
operator|+
literal|", Datanodes having this block: "
operator|+
name|nodeList
operator|+
literal|", Current Datanode: "
operator|+
name|srcNode
operator|.
name|name
operator|+
literal|", Is current datanode decommissioning: "
operator|+
name|srcNode
operator|.
name|isDecommissionInProgress
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * On stopping decommission, check if the node has excess replicas.    * If there are any excess replicas, call processOverReplicatedBlock()    */
DECL|method|processOverReplicatedBlocksOnReCommission ( final DatanodeDescriptor srcNode)
name|void
name|processOverReplicatedBlocksOnReCommission
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|srcNode
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|Block
argument_list|>
name|it
init|=
name|srcNode
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Block
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|INodeFile
name|fileINode
init|=
name|blocksMap
operator|.
name|getINode
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|short
name|expectedReplication
init|=
name|fileINode
operator|.
name|getReplication
argument_list|()
decl_stmt|;
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|numCurrentReplica
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|numCurrentReplica
operator|>
name|expectedReplication
condition|)
block|{
comment|// over-replicated block
name|processOverReplicatedBlock
argument_list|(
name|block
argument_list|,
name|expectedReplication
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Return true if there are any blocks on this node that have not    * yet reached their replication factor. Otherwise returns false.    */
DECL|method|isReplicationInProgress (DatanodeDescriptor srcNode)
name|boolean
name|isReplicationInProgress
parameter_list|(
name|DatanodeDescriptor
name|srcNode
parameter_list|)
block|{
name|boolean
name|status
init|=
literal|false
decl_stmt|;
name|int
name|underReplicatedBlocks
init|=
literal|0
decl_stmt|;
name|int
name|decommissionOnlyReplicas
init|=
literal|0
decl_stmt|;
name|int
name|underReplicatedInOpenFiles
init|=
literal|0
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|Block
argument_list|>
name|it
init|=
name|srcNode
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Block
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|INode
name|fileINode
init|=
name|blocksMap
operator|.
name|getINode
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileINode
operator|!=
literal|null
condition|)
block|{
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|curReplicas
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
name|int
name|curExpectedReplicas
init|=
name|getReplication
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNeededReplication
argument_list|(
name|block
argument_list|,
name|curExpectedReplicas
argument_list|,
name|curReplicas
argument_list|)
condition|)
block|{
if|if
condition|(
name|curExpectedReplicas
operator|>
name|curReplicas
condition|)
block|{
comment|//Log info about one block for this node which needs replication
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|status
operator|=
literal|true
expr_stmt|;
name|logBlockReplicationInfo
argument_list|(
name|block
argument_list|,
name|srcNode
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|underReplicatedBlocks
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|curReplicas
operator|==
literal|0
operator|)
operator|&&
operator|(
name|num
operator|.
name|decommissionedReplicas
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|decommissionOnlyReplicas
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fileINode
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
name|underReplicatedInOpenFiles
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|neededReplications
operator|.
name|contains
argument_list|(
name|block
argument_list|)
operator|&&
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|//
comment|// These blocks have been reported from the datanode
comment|// after the startDecommission method has been executed. These
comment|// blocks were in flight when the decommissioning was started.
comment|//
name|neededReplications
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|curReplicas
argument_list|,
name|num
operator|.
name|decommissionedReplicas
argument_list|()
argument_list|,
name|curExpectedReplicas
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|srcNode
operator|.
name|decommissioningStatus
operator|.
name|set
argument_list|(
name|underReplicatedBlocks
argument_list|,
name|decommissionOnlyReplicas
argument_list|,
name|underReplicatedInOpenFiles
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
DECL|method|getActiveBlockCount ()
specifier|public
name|int
name|getActiveBlockCount
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|size
argument_list|()
operator|-
operator|(
name|int
operator|)
name|invalidateBlocks
operator|.
name|numBlocks
argument_list|()
return|;
block|}
DECL|method|getNodes (BlockInfo block)
specifier|public
name|DatanodeDescriptor
index|[]
name|getNodes
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
name|DatanodeDescriptor
index|[]
name|nodes
init|=
operator|new
name|DatanodeDescriptor
index|[
name|block
operator|.
name|numNodes
argument_list|()
index|]
decl_stmt|;
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|block
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|it
operator|!=
literal|null
operator|&&
name|it
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|nodes
index|[
name|i
index|]
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
return|return
name|nodes
return|;
block|}
DECL|method|getTotalBlocks ()
specifier|public
name|int
name|getTotalBlocks
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|removeBlock (Block block)
specifier|public
name|void
name|removeBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|block
operator|.
name|setNumBytes
argument_list|(
name|BlockCommand
operator|.
name|NO_ACK
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|blocksMap
operator|.
name|removeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
DECL|method|getStoredBlock (Block block)
specifier|public
name|BlockInfo
name|getStoredBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
return|;
block|}
comment|/** updates a block in under replication queue */
DECL|method|updateNeededReplications (final Block block, final int curReplicasDelta, int expectedReplicasDelta)
specifier|private
name|void
name|updateNeededReplications
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|,
specifier|final
name|int
name|curReplicasDelta
parameter_list|,
name|int
name|expectedReplicasDelta
parameter_list|)
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|NumberReplicas
name|repl
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|curExpectedReplicas
init|=
name|getReplication
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNeededReplication
argument_list|(
name|block
argument_list|,
name|curExpectedReplicas
argument_list|,
name|repl
operator|.
name|liveReplicas
argument_list|()
argument_list|)
condition|)
block|{
name|neededReplications
operator|.
name|update
argument_list|(
name|block
argument_list|,
name|repl
operator|.
name|liveReplicas
argument_list|()
argument_list|,
name|repl
operator|.
name|decommissionedReplicas
argument_list|()
argument_list|,
name|curExpectedReplicas
argument_list|,
name|curReplicasDelta
argument_list|,
name|expectedReplicasDelta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|oldReplicas
init|=
name|repl
operator|.
name|liveReplicas
argument_list|()
operator|-
name|curReplicasDelta
decl_stmt|;
name|int
name|oldExpectedReplicas
init|=
name|curExpectedReplicas
operator|-
name|expectedReplicasDelta
decl_stmt|;
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|oldReplicas
argument_list|,
name|repl
operator|.
name|decommissionedReplicas
argument_list|()
argument_list|,
name|oldExpectedReplicas
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|checkReplication (Block block, int numExpectedReplicas)
specifier|public
name|void
name|checkReplication
parameter_list|(
name|Block
name|block
parameter_list|,
name|int
name|numExpectedReplicas
parameter_list|)
block|{
comment|// filter out containingNodes that are marked for decommission.
name|NumberReplicas
name|number
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNeededReplication
argument_list|(
name|block
argument_list|,
name|numExpectedReplicas
argument_list|,
name|number
operator|.
name|liveReplicas
argument_list|()
argument_list|)
condition|)
block|{
name|neededReplications
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|number
operator|.
name|liveReplicas
argument_list|()
argument_list|,
name|number
operator|.
name|decommissionedReplicas
argument_list|()
argument_list|,
name|numExpectedReplicas
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get replication factor of a block */
DECL|method|getReplication (Block block)
specifier|private
name|int
name|getReplication
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|INodeFile
name|fileINode
init|=
name|blocksMap
operator|.
name|getINode
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileINode
operator|==
literal|null
condition|)
block|{
comment|// block does not belong to any file
return|return
literal|0
return|;
block|}
assert|assert
operator|!
name|fileINode
operator|.
name|isDirectory
argument_list|()
operator|:
literal|"Block cannot belong to a directory."
assert|;
return|return
name|fileINode
operator|.
name|getReplication
argument_list|()
return|;
block|}
comment|/**    * Get blocks to invalidate for<i>nodeId</i>    * in {@link #recentInvalidateSets}.    *    * @return number of blocks scheduled for removal during this iteration.    */
DECL|method|invalidateWorkForOneNode (String nodeId)
specifier|private
name|int
name|invalidateWorkForOneNode
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// blocks should not be replicated or removed if safe mode is on
if|if
condition|(
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// get blocks to invalidate for the nodeId
assert|assert
name|nodeId
operator|!=
literal|null
assert|;
return|return
name|invalidateBlocks
operator|.
name|invalidateWork
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|blockHasEnoughRacks (Block b)
name|boolean
name|blockHasEnoughRacks
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|shouldCheckForEnoughRacks
condition|)
block|{
return|return
literal|true
return|;
block|}
name|boolean
name|enoughRacks
init|=
literal|false
decl_stmt|;
empty_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|int
name|numExpectedReplicas
init|=
name|getReplication
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|String
name|rackName
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|b
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DatanodeDescriptor
name|cur
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cur
operator|.
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|cur
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|corruptNodes
operator|==
literal|null
operator|)
operator|||
operator|!
name|corruptNodes
operator|.
name|contains
argument_list|(
name|cur
argument_list|)
condition|)
block|{
if|if
condition|(
name|numExpectedReplicas
operator|==
literal|1
condition|)
block|{
name|enoughRacks
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|String
name|rackNameNew
init|=
name|cur
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|rackName
operator|==
literal|null
condition|)
block|{
name|rackName
operator|=
name|rackNameNew
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rackName
operator|.
name|equals
argument_list|(
name|rackNameNew
argument_list|)
condition|)
block|{
name|enoughRacks
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|enoughRacks
return|;
block|}
DECL|method|isNeededReplication (Block b, int expectedReplication, int curReplicas)
name|boolean
name|isNeededReplication
parameter_list|(
name|Block
name|b
parameter_list|,
name|int
name|expectedReplication
parameter_list|,
name|int
name|curReplicas
parameter_list|)
block|{
if|if
condition|(
operator|(
name|curReplicas
operator|>=
name|expectedReplication
operator|)
operator|&&
operator|(
name|blockHasEnoughRacks
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|method|getMissingBlocksCount ()
specifier|public
name|long
name|getMissingBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|this
operator|.
name|neededReplications
operator|.
name|getCorruptBlockSize
argument_list|()
return|;
block|}
DECL|method|addINode (BlockInfo block, INodeFile iNode)
specifier|public
name|BlockInfo
name|addINode
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|INodeFile
name|iNode
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|addINode
argument_list|(
name|block
argument_list|,
name|iNode
argument_list|)
return|;
block|}
DECL|method|getINode (Block b)
specifier|public
name|INodeFile
name|getINode
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|getINode
argument_list|(
name|b
argument_list|)
return|;
block|}
comment|/** @return an iterator of the datanodes. */
DECL|method|datanodeIterator (final Block block)
specifier|public
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|datanodeIterator
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|nodeIterator
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|numCorruptReplicas (Block block)
specifier|public
name|int
name|numCorruptReplicas
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|numCorruptReplicas
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|removeBlockFromMap (Block block)
specifier|public
name|void
name|removeBlockFromMap
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|blocksMap
operator|.
name|removeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// If block is removed from blocksMap remove it from corruptReplicasMap
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
DECL|method|getCapacity ()
specifier|public
name|int
name|getCapacity
parameter_list|()
block|{
name|namesystem
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|blocksMap
operator|.
name|getCapacity
argument_list|()
return|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return a range of corrupt replica block ids. Up to numExpectedBlocks     * blocks starting at the next block after startingBlockId are returned    * (fewer if numExpectedBlocks blocks are unavailable). If startingBlockId     * is null, up to numExpectedBlocks blocks are returned from the beginning.    * If startingBlockId cannot be found, null is returned.    *    * @param numExpectedBlocks Number of block ids to return.    *  0<= numExpectedBlocks<= 100    * @param startingBlockId Block id from which to start. If null, start at    *  beginning.    * @return Up to numExpectedBlocks blocks from startingBlockId if it exists    *    */
DECL|method|getCorruptReplicaBlockIds (int numExpectedBlocks, Long startingBlockId)
specifier|public
name|long
index|[]
name|getCorruptReplicaBlockIds
parameter_list|(
name|int
name|numExpectedBlocks
parameter_list|,
name|Long
name|startingBlockId
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|getCorruptReplicaBlockIds
argument_list|(
name|numExpectedBlocks
argument_list|,
name|startingBlockId
argument_list|)
return|;
block|}
comment|/**    * Return an iterator over the set of blocks for which there are no replicas.    */
DECL|method|getCorruptReplicaBlockIterator ()
specifier|public
name|Iterator
argument_list|<
name|Block
argument_list|>
name|getCorruptReplicaBlockIterator
parameter_list|()
block|{
return|return
name|neededReplications
operator|.
name|iterator
argument_list|(
name|UnderReplicatedBlocks
operator|.
name|QUEUE_WITH_CORRUPT_BLOCKS
argument_list|)
return|;
block|}
comment|/** @return the size of UnderReplicatedBlocks */
DECL|method|numOfUnderReplicatedBlocks ()
specifier|public
name|int
name|numOfUnderReplicatedBlocks
parameter_list|()
block|{
return|return
name|neededReplications
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Periodically calls computeReplicationWork().    */
DECL|class|ReplicationMonitor
specifier|private
class|class
name|ReplicationMonitor
implements|implements
name|Runnable
block|{
DECL|field|INVALIDATE_WORK_PCT_PER_ITERATION
specifier|private
specifier|static
specifier|final
name|int
name|INVALIDATE_WORK_PCT_PER_ITERATION
init|=
literal|32
decl_stmt|;
DECL|field|REPLICATION_WORK_MULTIPLIER_PER_ITERATION
specifier|private
specifier|static
specifier|final
name|int
name|REPLICATION_WORK_MULTIPLIER_PER_ITERATION
init|=
literal|2
decl_stmt|;
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
try|try
block|{
name|computeDatanodeWork
argument_list|()
expr_stmt|;
name|processPendingReplications
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|replicationRecheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ReplicationMonitor thread received InterruptedException."
argument_list|,
name|ie
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ReplicationMonitor thread received exception. "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ReplicationMonitor thread received Runtime exception. "
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Compute block replication and block invalidation work that can be scheduled    * on data-nodes. The datanode will be informed of this work at the next    * heartbeat.    *     * @return number of blocks scheduled for replication or removal.    * @throws IOException    */
DECL|method|computeDatanodeWork ()
name|int
name|computeDatanodeWork
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|workFound
init|=
literal|0
decl_stmt|;
comment|// Blocks should not be replicated or removed if in safe mode.
comment|// It's OK to check safe mode here w/o holding lock, in the worst
comment|// case extra replications will be scheduled, and these will get
comment|// fixed up later.
if|if
condition|(
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
return|return
name|workFound
return|;
specifier|final
name|int
name|numlive
init|=
name|heartbeatManager
operator|.
name|getLiveDatanodeCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|blocksToProcess
init|=
name|numlive
operator|*
name|ReplicationMonitor
operator|.
name|REPLICATION_WORK_MULTIPLIER_PER_ITERATION
decl_stmt|;
specifier|final
name|int
name|nodesToProcess
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|numlive
operator|*
name|ReplicationMonitor
operator|.
name|INVALIDATE_WORK_PCT_PER_ITERATION
operator|/
literal|100.0
argument_list|)
decl_stmt|;
name|workFound
operator|=
name|this
operator|.
name|computeReplicationWork
argument_list|(
name|blocksToProcess
argument_list|)
expr_stmt|;
comment|// Update counters
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|updateState
argument_list|()
expr_stmt|;
name|this
operator|.
name|scheduledReplicationBlocksCount
operator|=
name|workFound
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|workFound
operator|+=
name|this
operator|.
name|computeInvalidateWork
argument_list|(
name|nodesToProcess
argument_list|)
expr_stmt|;
return|return
name|workFound
return|;
block|}
DECL|class|ReplicationWork
specifier|private
specifier|static
class|class
name|ReplicationWork
block|{
DECL|field|block
specifier|private
name|Block
name|block
decl_stmt|;
DECL|field|fileINode
specifier|private
name|INodeFile
name|fileINode
decl_stmt|;
DECL|field|srcNode
specifier|private
name|DatanodeDescriptor
name|srcNode
decl_stmt|;
DECL|field|containingNodes
specifier|private
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
decl_stmt|;
DECL|field|liveReplicaNodes
specifier|private
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|liveReplicaNodes
decl_stmt|;
DECL|field|additionalReplRequired
specifier|private
name|int
name|additionalReplRequired
decl_stmt|;
DECL|field|targets
specifier|private
name|DatanodeDescriptor
name|targets
index|[]
decl_stmt|;
DECL|field|priority
specifier|private
name|int
name|priority
decl_stmt|;
DECL|method|ReplicationWork (Block block, INodeFile fileINode, DatanodeDescriptor srcNode, List<DatanodeDescriptor> containingNodes, List<DatanodeDescriptor> liveReplicaNodes, int additionalReplRequired, int priority)
specifier|public
name|ReplicationWork
parameter_list|(
name|Block
name|block
parameter_list|,
name|INodeFile
name|fileINode
parameter_list|,
name|DatanodeDescriptor
name|srcNode
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|liveReplicaNodes
parameter_list|,
name|int
name|additionalReplRequired
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|this
operator|.
name|fileINode
operator|=
name|fileINode
expr_stmt|;
name|this
operator|.
name|srcNode
operator|=
name|srcNode
expr_stmt|;
name|this
operator|.
name|containingNodes
operator|=
name|containingNodes
expr_stmt|;
name|this
operator|.
name|liveReplicaNodes
operator|=
name|liveReplicaNodes
expr_stmt|;
name|this
operator|.
name|additionalReplRequired
operator|=
name|additionalReplRequired
expr_stmt|;
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|this
operator|.
name|targets
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

