begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockType
operator|.
name|CONTIGUOUS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockType
operator|.
name|STRIPED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|terminate
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|AddBlockFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
operator|.
name|BlockReportReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|StoragePolicySatisfierMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedStripedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnregisteredNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
operator|.
name|AccessMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|DataEncryptionKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|ExportedBlockKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoStriped
operator|.
name|StorageAndBlockIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|CorruptReplicasMap
operator|.
name|Reason
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
operator|.
name|AddBlockResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|NumberReplicas
operator|.
name|StoredReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|PendingDataNodeMessages
operator|.
name|ReportedBlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|CachedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INode
operator|.
name|BlocksMapUpdateInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|INodesInPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|Namesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|sps
operator|.
name|StoragePolicySatisfyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockReportContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
operator|.
name|BlockWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
operator|.
name|StripedBlockWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|KeyUpdateCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReceivedDeletedBlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReceivedDeletedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|VolumeFailureSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|FoldedTreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|CacheManager
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|StripedBlockUtil
operator|.
name|getInternalBlockLength
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LightWeightGSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Keeps information related to the blocks stored in the Hadoop cluster.  * For block state management, it tries to maintain the  safety  * property of "# of live replicas == # of expected redundancy" under  * any events such as decommission, namenode failover, datanode failure.  *  * The motivation of maintenance mode is to allow admins quickly repair nodes  * without paying the cost of decommission. Thus with maintenance mode,  * # of live replicas doesn't have to be equal to # of expected redundancy.  * If any of the replica is in maintenance mode, the safety property  * is extended as follows. These property still apply for the case of zero  * maintenance replicas, thus we can use these safe property for all scenarios.  * a. # of live replicas&gt;= # of min replication for maintenance.  * b. # of live replicas&lt;= # of expected redundancy.  * c. # of live replicas and maintenance replicas&gt;= # of expected  * redundancy.  *  * For regular replication, # of min live replicas for maintenance is determined  * by DFS_NAMENODE_MAINTENANCE_REPLICATION_MIN_KEY. This number has to&lt;=  * DFS_NAMENODE_REPLICATION_MIN_KEY.  * For erasure encoding, # of min live replicas for maintenance is  * BlockInfoStriped#getRealDataBlockNum.  *  * Another safety property is to satisfy the block placement policy. While the  * policy is configurable, the replicas the policy is applied to are the live  * replicas + maintenance replicas.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockManager
specifier|public
class|class
name|BlockManager
implements|implements
name|BlockStatsMXBean
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BlockManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|blockLog
specifier|public
specifier|static
specifier|final
name|Logger
name|blockLog
init|=
name|NameNode
operator|.
name|blockStateChangeLog
decl_stmt|;
DECL|field|QUEUE_REASON_CORRUPT_STATE
specifier|private
specifier|static
specifier|final
name|String
name|QUEUE_REASON_CORRUPT_STATE
init|=
literal|"it has the wrong state or generation stamp"
decl_stmt|;
DECL|field|QUEUE_REASON_FUTURE_GENSTAMP
specifier|private
specifier|static
specifier|final
name|String
name|QUEUE_REASON_FUTURE_GENSTAMP
init|=
literal|"generation stamp is in the future"
decl_stmt|;
DECL|field|BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
specifier|private
specifier|static
specifier|final
name|long
name|BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
init|=
literal|30
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|Namesystem
name|namesystem
decl_stmt|;
DECL|field|bmSafeMode
specifier|private
specifier|final
name|BlockManagerSafeMode
name|bmSafeMode
decl_stmt|;
DECL|field|datanodeManager
specifier|private
specifier|final
name|DatanodeManager
name|datanodeManager
decl_stmt|;
DECL|field|heartbeatManager
specifier|private
specifier|final
name|HeartbeatManager
name|heartbeatManager
decl_stmt|;
DECL|field|blockTokenSecretManager
specifier|private
specifier|final
name|BlockTokenSecretManager
name|blockTokenSecretManager
decl_stmt|;
comment|// Block pool ID used by this namenode
DECL|field|blockPoolId
specifier|private
name|String
name|blockPoolId
decl_stmt|;
DECL|field|pendingDNMessages
specifier|private
specifier|final
name|PendingDataNodeMessages
name|pendingDNMessages
init|=
operator|new
name|PendingDataNodeMessages
argument_list|()
decl_stmt|;
DECL|field|pendingReconstructionBlocksCount
specifier|private
specifier|volatile
name|long
name|pendingReconstructionBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|corruptReplicaBlocksCount
specifier|private
specifier|volatile
name|long
name|corruptReplicaBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|lowRedundancyBlocksCount
specifier|private
specifier|volatile
name|long
name|lowRedundancyBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|scheduledReplicationBlocksCount
specifier|private
specifier|volatile
name|long
name|scheduledReplicationBlocksCount
init|=
literal|0L
decl_stmt|;
comment|/** flag indicating whether replication queues have been initialized */
DECL|field|initializedReplQueues
specifier|private
name|boolean
name|initializedReplQueues
decl_stmt|;
DECL|field|startupDelayBlockDeletionInMs
specifier|private
specifier|final
name|long
name|startupDelayBlockDeletionInMs
decl_stmt|;
DECL|field|blockReportLeaseManager
specifier|private
specifier|final
name|BlockReportLeaseManager
name|blockReportLeaseManager
decl_stmt|;
DECL|field|mxBeanName
specifier|private
name|ObjectName
name|mxBeanName
decl_stmt|;
comment|/** Used by metrics */
DECL|method|getPendingReconstructionBlocksCount ()
specifier|public
name|long
name|getPendingReconstructionBlocksCount
parameter_list|()
block|{
return|return
name|pendingReconstructionBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getLowRedundancyBlocksCount ()
specifier|public
name|long
name|getLowRedundancyBlocksCount
parameter_list|()
block|{
return|return
name|lowRedundancyBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getCorruptReplicaBlocksCount ()
specifier|public
name|long
name|getCorruptReplicaBlocksCount
parameter_list|()
block|{
return|return
name|corruptReplicaBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getScheduledReplicationBlocksCount ()
specifier|public
name|long
name|getScheduledReplicationBlocksCount
parameter_list|()
block|{
return|return
name|scheduledReplicationBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getPendingDeletionBlocksCount ()
specifier|public
name|long
name|getPendingDeletionBlocksCount
parameter_list|()
block|{
return|return
name|invalidateBlocks
operator|.
name|numBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics */
DECL|method|getStartupDelayBlockDeletionInMs ()
specifier|public
name|long
name|getStartupDelayBlockDeletionInMs
parameter_list|()
block|{
return|return
name|startupDelayBlockDeletionInMs
return|;
block|}
comment|/** Used by metrics */
DECL|method|getExcessBlocksCount ()
specifier|public
name|long
name|getExcessBlocksCount
parameter_list|()
block|{
return|return
name|excessRedundancyMap
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Used by metrics */
DECL|method|getPostponedMisreplicatedBlocksCount ()
specifier|public
name|long
name|getPostponedMisreplicatedBlocksCount
parameter_list|()
block|{
return|return
name|postponedMisreplicatedBlocks
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Used by metrics */
DECL|method|getPendingDataNodeMessageCount ()
specifier|public
name|int
name|getPendingDataNodeMessageCount
parameter_list|()
block|{
return|return
name|pendingDNMessages
operator|.
name|count
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getNumTimedOutPendingReconstructions ()
specifier|public
name|long
name|getNumTimedOutPendingReconstructions
parameter_list|()
block|{
return|return
name|pendingReconstruction
operator|.
name|getNumTimedOuts
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getLowRedundancyBlocks ()
specifier|public
name|long
name|getLowRedundancyBlocks
parameter_list|()
block|{
return|return
name|neededReconstruction
operator|.
name|getLowRedundancyBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getCorruptBlocks ()
specifier|public
name|long
name|getCorruptBlocks
parameter_list|()
block|{
return|return
name|corruptReplicas
operator|.
name|getCorruptBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getMissingBlocks ()
specifier|public
name|long
name|getMissingBlocks
parameter_list|()
block|{
return|return
name|neededReconstruction
operator|.
name|getCorruptBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getMissingReplicationOneBlocks ()
specifier|public
name|long
name|getMissingReplicationOneBlocks
parameter_list|()
block|{
return|return
name|neededReconstruction
operator|.
name|getCorruptReplicationOneBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getPendingDeletionReplicatedBlocks ()
specifier|public
name|long
name|getPendingDeletionReplicatedBlocks
parameter_list|()
block|{
return|return
name|invalidateBlocks
operator|.
name|getBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getTotalReplicatedBlocks ()
specifier|public
name|long
name|getTotalReplicatedBlocks
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|getReplicatedBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getLowRedundancyECBlockGroups ()
specifier|public
name|long
name|getLowRedundancyECBlockGroups
parameter_list|()
block|{
return|return
name|neededReconstruction
operator|.
name|getLowRedundancyECBlockGroups
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getCorruptECBlockGroups ()
specifier|public
name|long
name|getCorruptECBlockGroups
parameter_list|()
block|{
return|return
name|corruptReplicas
operator|.
name|getCorruptECBlockGroups
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getMissingECBlockGroups ()
specifier|public
name|long
name|getMissingECBlockGroups
parameter_list|()
block|{
return|return
name|neededReconstruction
operator|.
name|getCorruptECBlockGroups
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getPendingDeletionECBlocks ()
specifier|public
name|long
name|getPendingDeletionECBlocks
parameter_list|()
block|{
return|return
name|invalidateBlocks
operator|.
name|getECBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics. */
DECL|method|getTotalECBlockGroups ()
specifier|public
name|long
name|getTotalECBlockGroups
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|getECBlockGroups
argument_list|()
return|;
block|}
comment|/**    * redundancyRecheckInterval is how often namenode checks for new    * reconstruction work.    */
DECL|field|redundancyRecheckIntervalMs
specifier|private
specifier|final
name|long
name|redundancyRecheckIntervalMs
decl_stmt|;
comment|/** How often to check and the limit for the storageinfo efficiency. */
DECL|field|storageInfoDefragmentInterval
specifier|private
specifier|final
name|long
name|storageInfoDefragmentInterval
decl_stmt|;
DECL|field|storageInfoDefragmentTimeout
specifier|private
specifier|final
name|long
name|storageInfoDefragmentTimeout
decl_stmt|;
DECL|field|storageInfoDefragmentRatio
specifier|private
specifier|final
name|double
name|storageInfoDefragmentRatio
decl_stmt|;
comment|/**    * Mapping: Block {@literal ->} { BlockCollection, datanodes, self ref }    * Updated only in response to client-sent information.    */
DECL|field|blocksMap
specifier|final
name|BlocksMap
name|blocksMap
decl_stmt|;
comment|/** Redundancy thread. */
DECL|field|redundancyThread
specifier|private
specifier|final
name|Daemon
name|redundancyThread
init|=
operator|new
name|Daemon
argument_list|(
operator|new
name|RedundancyMonitor
argument_list|()
argument_list|)
decl_stmt|;
comment|/** StorageInfoDefragmenter thread. */
DECL|field|storageInfoDefragmenterThread
specifier|private
specifier|final
name|Daemon
name|storageInfoDefragmenterThread
init|=
operator|new
name|Daemon
argument_list|(
operator|new
name|StorageInfoDefragmenter
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Block report thread for handling async reports. */
DECL|field|blockReportThread
specifier|private
specifier|final
name|BlockReportProcessingThread
name|blockReportThread
init|=
operator|new
name|BlockReportProcessingThread
argument_list|()
decl_stmt|;
comment|/**    * Store blocks {@literal ->} datanodedescriptor(s) map of corrupt replicas.    */
DECL|field|corruptReplicas
specifier|final
name|CorruptReplicasMap
name|corruptReplicas
init|=
operator|new
name|CorruptReplicasMap
argument_list|()
decl_stmt|;
comment|/**    * Blocks to be invalidated.    * For a striped block to invalidate, we should track its individual internal    * blocks.    */
DECL|field|invalidateBlocks
specifier|private
specifier|final
name|InvalidateBlocks
name|invalidateBlocks
decl_stmt|;
comment|/**    * After a failover, over-replicated blocks may not be handled    * until all of the replicas have done a block report to the    * new active. This is to make sure that this NameNode has been    * notified of all block deletions that might have been pending    * when the failover happened.    */
DECL|field|postponedMisreplicatedBlocks
specifier|private
specifier|final
name|Set
argument_list|<
name|Block
argument_list|>
name|postponedMisreplicatedBlocks
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|blocksPerPostpondedRescan
specifier|private
specifier|final
name|int
name|blocksPerPostpondedRescan
decl_stmt|;
DECL|field|rescannedMisreplicatedBlocks
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|Block
argument_list|>
name|rescannedMisreplicatedBlocks
decl_stmt|;
comment|/**    * Maps a StorageID to the set of blocks that are "extra" for this    * DataNode. We'll eventually remove these extras.    */
DECL|field|excessRedundancyMap
specifier|private
specifier|final
name|ExcessRedundancyMap
name|excessRedundancyMap
init|=
operator|new
name|ExcessRedundancyMap
argument_list|()
decl_stmt|;
comment|/**    * Store set of Blocks that need to be replicated 1 or more times.    * We also store pending reconstruction-orders.    */
DECL|field|neededReconstruction
specifier|public
specifier|final
name|LowRedundancyBlocks
name|neededReconstruction
init|=
operator|new
name|LowRedundancyBlocks
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|pendingReconstruction
specifier|final
name|PendingReconstructionBlocks
name|pendingReconstruction
decl_stmt|;
comment|/** Stores information about block recovery attempts. */
DECL|field|pendingRecoveryBlocks
specifier|private
specifier|final
name|PendingRecoveryBlocks
name|pendingRecoveryBlocks
decl_stmt|;
comment|/** The maximum number of replicas allowed for a block */
DECL|field|maxReplication
specifier|public
specifier|final
name|short
name|maxReplication
decl_stmt|;
comment|/**    * The maximum number of outgoing replication streams a given node should have    * at one time considering all but the highest priority replications needed.     */
DECL|field|maxReplicationStreams
name|int
name|maxReplicationStreams
decl_stmt|;
comment|/**    * The maximum number of outgoing replication streams a given node should have    * at one time.    */
DECL|field|replicationStreamsHardLimit
name|int
name|replicationStreamsHardLimit
decl_stmt|;
comment|/** Minimum copies needed or else write is disallowed */
DECL|field|minReplication
specifier|public
specifier|final
name|short
name|minReplication
decl_stmt|;
comment|/** Default number of replicas */
DECL|field|defaultReplication
specifier|public
specifier|final
name|int
name|defaultReplication
decl_stmt|;
comment|/** value returned by MAX_CORRUPT_FILES_RETURNED */
DECL|field|maxCorruptFilesReturned
specifier|final
name|int
name|maxCorruptFilesReturned
decl_stmt|;
DECL|field|blocksInvalidateWorkPct
specifier|final
name|float
name|blocksInvalidateWorkPct
decl_stmt|;
DECL|field|blocksReplWorkMultiplier
specifier|final
name|int
name|blocksReplWorkMultiplier
decl_stmt|;
comment|// whether or not to issue block encryption keys.
DECL|field|encryptDataTransfer
specifier|final
name|boolean
name|encryptDataTransfer
decl_stmt|;
comment|// Max number of blocks to log info about during a block report.
DECL|field|maxNumBlocksToLog
specifier|private
specifier|final
name|long
name|maxNumBlocksToLog
decl_stmt|;
comment|/**    * When running inside a Standby node, the node may receive block reports    * from datanodes before receiving the corresponding namespace edits from    * the active NameNode. Thus, it will postpone them for later processing,    * instead of marking the blocks as corrupt.    */
DECL|field|shouldPostponeBlocksFromFuture
specifier|private
name|boolean
name|shouldPostponeBlocksFromFuture
init|=
literal|false
decl_stmt|;
comment|/**    * Process reconstruction queues asynchronously to allow namenode safemode    * exit and failover to be faster. HDFS-5496.    */
DECL|field|reconstructionQueuesInitializer
specifier|private
name|Daemon
name|reconstructionQueuesInitializer
init|=
literal|null
decl_stmt|;
comment|/**    * Number of blocks to process asychronously for reconstruction queues    * initialization once aquired the namesystem lock. Remaining blocks will be    * processed again after aquiring lock again.    */
DECL|field|numBlocksPerIteration
specifier|private
name|int
name|numBlocksPerIteration
decl_stmt|;
comment|/**    * Progress of the Reconstruction queues initialisation.    */
DECL|field|reconstructionQueuesInitProgress
specifier|private
name|double
name|reconstructionQueuesInitProgress
init|=
literal|0.0
decl_stmt|;
comment|/** for block replicas placement */
DECL|field|placementPolicies
specifier|private
name|BlockPlacementPolicies
name|placementPolicies
decl_stmt|;
DECL|field|storagePolicySuite
specifier|private
specifier|final
name|BlockStoragePolicySuite
name|storagePolicySuite
decl_stmt|;
comment|/** Check whether name system is running before terminating */
DECL|field|checkNSRunning
specifier|private
name|boolean
name|checkNSRunning
init|=
literal|true
decl_stmt|;
comment|/** Check whether there are any non-EC blocks using StripedID */
DECL|field|hasNonEcBlockUsingStripedID
specifier|private
name|boolean
name|hasNonEcBlockUsingStripedID
init|=
literal|false
decl_stmt|;
DECL|field|blockIdManager
specifier|private
specifier|final
name|BlockIdManager
name|blockIdManager
decl_stmt|;
comment|/**    * For satisfying block storage policies. Instantiates if sps is enabled    * internally or externally.    */
DECL|field|spsManager
specifier|private
name|StoragePolicySatisfyManager
name|spsManager
decl_stmt|;
comment|/** Minimum live replicas needed for the datanode to be transitioned    * from ENTERING_MAINTENANCE to IN_MAINTENANCE.    */
DECL|field|minReplicationToBeInMaintenance
specifier|private
specifier|final
name|short
name|minReplicationToBeInMaintenance
decl_stmt|;
comment|/** Storages accessible from multiple DNs. */
DECL|field|providedStorageMap
specifier|private
specifier|final
name|ProvidedStorageMap
name|providedStorageMap
decl_stmt|;
DECL|method|BlockManager (final Namesystem namesystem, boolean haEnabled, final Configuration conf)
specifier|public
name|BlockManager
parameter_list|(
specifier|final
name|Namesystem
name|namesystem
parameter_list|,
name|boolean
name|haEnabled
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
name|datanodeManager
operator|=
operator|new
name|DatanodeManager
argument_list|(
name|this
argument_list|,
name|namesystem
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|heartbeatManager
operator|=
name|datanodeManager
operator|.
name|getHeartbeatManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockIdManager
operator|=
operator|new
name|BlockIdManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|blocksPerPostpondedRescan
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|datanodeManager
operator|.
name|getBlocksPerPostponedMisreplicatedBlocksRescan
argument_list|()
argument_list|)
expr_stmt|;
name|rescannedMisreplicatedBlocks
operator|=
operator|new
name|ArrayList
argument_list|<
name|Block
argument_list|>
argument_list|(
name|blocksPerPostpondedRescan
argument_list|)
expr_stmt|;
name|startupDelayBlockDeletionInMs
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STARTUP_DELAY_BLOCK_DELETION_SEC_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STARTUP_DELAY_BLOCK_DELETION_SEC_DEFAULT
argument_list|)
operator|*
literal|1000L
expr_stmt|;
name|invalidateBlocks
operator|=
operator|new
name|InvalidateBlocks
argument_list|(
name|datanodeManager
operator|.
name|getBlockInvalidateLimit
argument_list|()
argument_list|,
name|startupDelayBlockDeletionInMs
argument_list|,
name|blockIdManager
argument_list|)
expr_stmt|;
comment|// Compute the map capacity by allocating 2% of total memory
name|blocksMap
operator|=
operator|new
name|BlocksMap
argument_list|(
name|LightWeightGSet
operator|.
name|computeCapacity
argument_list|(
literal|2.0
argument_list|,
literal|"BlocksMap"
argument_list|)
argument_list|)
expr_stmt|;
name|placementPolicies
operator|=
operator|new
name|BlockPlacementPolicies
argument_list|(
name|conf
argument_list|,
name|datanodeManager
operator|.
name|getFSClusterStats
argument_list|()
argument_list|,
name|datanodeManager
operator|.
name|getNetworkTopology
argument_list|()
argument_list|,
name|datanodeManager
operator|.
name|getHost2DatanodeMap
argument_list|()
argument_list|)
expr_stmt|;
name|storagePolicySuite
operator|=
name|BlockStoragePolicySuite
operator|.
name|createDefaultSuite
argument_list|()
expr_stmt|;
name|pendingReconstruction
operator|=
operator|new
name|PendingReconstructionBlocks
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RECONSTRUCTION_PENDING_TIMEOUT_SEC_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RECONSTRUCTION_PENDING_TIMEOUT_SEC_DEFAULT
argument_list|)
operator|*
literal|1000L
argument_list|)
expr_stmt|;
name|createSPSManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|blockTokenSecretManager
operator|=
name|createBlockTokenSecretManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|providedStorageMap
operator|=
operator|new
name|ProvidedStorageMap
argument_list|(
name|namesystem
argument_list|,
name|this
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxCorruptFilesReturned
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DEFAULT_MAX_CORRUPT_FILES_RETURNED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DEFAULT_MAX_CORRUPT_FILES_RETURNED
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_DEFAULT
argument_list|)
expr_stmt|;
specifier|final
name|int
name|maxR
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minR
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|minR
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
operator|+
literal|" = "
operator|+
name|minR
operator|+
literal|"<= 0"
argument_list|)
throw|;
if|if
condition|(
name|maxR
operator|>
name|Short
operator|.
name|MAX_VALUE
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_KEY
operator|+
literal|" = "
operator|+
name|maxR
operator|+
literal|"> "
operator|+
name|Short
operator|.
name|MAX_VALUE
argument_list|)
throw|;
if|if
condition|(
name|minR
operator|>
name|maxR
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
operator|+
literal|" = "
operator|+
name|minR
operator|+
literal|"> "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_KEY
operator|+
literal|" = "
operator|+
name|maxR
argument_list|)
throw|;
name|this
operator|.
name|minReplication
operator|=
operator|(
name|short
operator|)
name|minR
expr_stmt|;
name|this
operator|.
name|maxReplication
operator|=
operator|(
name|short
operator|)
name|maxR
expr_stmt|;
name|this
operator|.
name|maxReplicationStreams
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MAX_STREAMS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MAX_STREAMS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|replicationStreamsHardLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_STREAMS_HARD_LIMIT_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_STREAMS_HARD_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|blocksInvalidateWorkPct
operator|=
name|DFSUtil
operator|.
name|getInvalidateWorkPctPerIteration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|blocksReplWorkMultiplier
operator|=
name|DFSUtil
operator|.
name|getReplWorkMultiplier
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|redundancyRecheckIntervalMs
operator|=
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REDUNDANCY_INTERVAL_SECONDS_DEFAULT
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|storageInfoDefragmentInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_INTERVAL_MS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_INTERVAL_MS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|storageInfoDefragmentTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_TIMEOUT_MS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_TIMEOUT_MS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|storageInfoDefragmentRatio
operator|=
name|conf
operator|.
name|getDouble
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_RATIO_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STORAGEINFO_DEFRAGMENT_RATIO_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|encryptDataTransfer
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxNumBlocksToLog
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_MAX_NUM_BLOCKS_TO_LOG_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_MAX_NUM_BLOCKS_TO_LOG_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|numBlocksPerIteration
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_MISREPLICATION_PROCESSING_LIMIT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_MISREPLICATION_PROCESSING_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
specifier|final
name|int
name|minMaintenanceR
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAINTENANCE_REPLICATION_MIN_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAINTENANCE_REPLICATION_MIN_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|minMaintenanceR
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAINTENANCE_REPLICATION_MIN_KEY
operator|+
literal|" = "
operator|+
name|minMaintenanceR
operator|+
literal|"< 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|minMaintenanceR
operator|>
name|defaultReplication
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_MAINTENANCE_REPLICATION_MIN_KEY
operator|+
literal|" = "
operator|+
name|minMaintenanceR
operator|+
literal|"> "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_KEY
operator|+
literal|" = "
operator|+
name|defaultReplication
argument_list|)
throw|;
block|}
name|this
operator|.
name|minReplicationToBeInMaintenance
operator|=
operator|(
name|short
operator|)
name|minMaintenanceR
expr_stmt|;
name|long
name|heartbeatIntervalSecs
init|=
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
name|long
name|blockRecoveryTimeout
init|=
name|getBlockRecoveryTimeout
argument_list|(
name|heartbeatIntervalSecs
argument_list|)
decl_stmt|;
name|pendingRecoveryBlocks
operator|=
operator|new
name|PendingRecoveryBlocks
argument_list|(
name|blockRecoveryTimeout
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockReportLeaseManager
operator|=
operator|new
name|BlockReportLeaseManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|=
operator|new
name|BlockManagerSafeMode
argument_list|(
name|this
argument_list|,
name|namesystem
argument_list|,
name|haEnabled
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"defaultReplication         = {}"
argument_list|,
name|defaultReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"maxReplication             = {}"
argument_list|,
name|maxReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"minReplication             = {}"
argument_list|,
name|minReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"maxReplicationStreams      = {}"
argument_list|,
name|maxReplicationStreams
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"redundancyRecheckInterval  = {}ms"
argument_list|,
name|redundancyRecheckIntervalMs
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"encryptDataTransfer        = {}"
argument_list|,
name|encryptDataTransfer
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"maxNumBlocksToLog          = {}"
argument_list|,
name|maxNumBlocksToLog
argument_list|)
expr_stmt|;
block|}
DECL|method|createBlockTokenSecretManager ( final Configuration conf)
specifier|private
specifier|static
name|BlockTokenSecretManager
name|createBlockTokenSecretManager
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|isEnabled
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} = {}"
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY
argument_list|,
name|isEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isEnabled
condition|)
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|String
name|errMessage
init|=
literal|"Security is enabled but block access tokens "
operator|+
literal|"(via "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY
operator|+
literal|") "
operator|+
literal|"aren't enabled. This may cause issues "
operator|+
literal|"when clients attempt to connect to a DataNode. Aborting NameNode"
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|errMessage
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|updateMin
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|long
name|lifetimeMin
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|String
name|encryptionAlgorithm
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATA_ENCRYPTION_ALGORITHM_KEY
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}={} min(s), {}={} min(s), {}={}"
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY
argument_list|,
name|updateMin
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY
argument_list|,
name|lifetimeMin
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATA_ENCRYPTION_ALGORITHM_KEY
argument_list|,
name|encryptionAlgorithm
argument_list|)
expr_stmt|;
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|boolean
name|isHaEnabled
init|=
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|boolean
name|shouldWriteProtobufToken
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|isHaEnabled
condition|)
block|{
comment|// figure out which index we are of the nns
name|Collection
argument_list|<
name|String
argument_list|>
name|nnIds
init|=
name|DFSUtilClient
operator|.
name|getNameNodeIds
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|String
name|nnId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|int
name|nnIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|id
range|:
name|nnIds
control|)
block|{
if|if
condition|(
name|id
operator|.
name|equals
argument_list|(
name|nnId
argument_list|)
condition|)
block|{
break|break;
block|}
name|nnIndex
operator|++
expr_stmt|;
block|}
return|return
operator|new
name|BlockTokenSecretManager
argument_list|(
name|updateMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|,
name|lifetimeMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|,
name|nnIndex
argument_list|,
name|nnIds
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|,
name|encryptionAlgorithm
argument_list|,
name|shouldWriteProtobufToken
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|BlockTokenSecretManager
argument_list|(
name|updateMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|,
name|lifetimeMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|,
name|encryptionAlgorithm
argument_list|,
name|shouldWriteProtobufToken
argument_list|)
return|;
block|}
block|}
DECL|method|getStoragePolicy (final String policyName)
specifier|public
name|BlockStoragePolicy
name|getStoragePolicy
parameter_list|(
specifier|final
name|String
name|policyName
parameter_list|)
block|{
return|return
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|policyName
argument_list|)
return|;
block|}
DECL|method|getStoragePolicy (final byte policyId)
specifier|public
name|BlockStoragePolicy
name|getStoragePolicy
parameter_list|(
specifier|final
name|byte
name|policyId
parameter_list|)
block|{
return|return
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|policyId
argument_list|)
return|;
block|}
DECL|method|getStoragePolicies ()
specifier|public
name|BlockStoragePolicy
index|[]
name|getStoragePolicies
parameter_list|()
block|{
return|return
name|storagePolicySuite
operator|.
name|getAllPolicies
argument_list|()
return|;
block|}
DECL|method|setBlockPoolId (String blockPoolId)
specifier|public
name|void
name|setBlockPoolId
parameter_list|(
name|String
name|blockPoolId
parameter_list|)
block|{
name|this
operator|.
name|blockPoolId
operator|=
name|blockPoolId
expr_stmt|;
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
condition|)
block|{
name|blockTokenSecretManager
operator|.
name|setBlockPoolId
argument_list|(
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getBlockPoolId ()
specifier|public
name|String
name|getBlockPoolId
parameter_list|()
block|{
return|return
name|blockPoolId
return|;
block|}
DECL|method|getStoragePolicySuite ()
specifier|public
name|BlockStoragePolicySuite
name|getStoragePolicySuite
parameter_list|()
block|{
return|return
name|storagePolicySuite
return|;
block|}
comment|/** get the BlockTokenSecretManager */
annotation|@
name|VisibleForTesting
DECL|method|getBlockTokenSecretManager ()
specifier|public
name|BlockTokenSecretManager
name|getBlockTokenSecretManager
parameter_list|()
block|{
return|return
name|blockTokenSecretManager
return|;
block|}
comment|/** Allow silent termination of redundancy monitor for testing. */
annotation|@
name|VisibleForTesting
DECL|method|enableRMTerminationForTesting ()
name|void
name|enableRMTerminationForTesting
parameter_list|()
block|{
name|checkNSRunning
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|isBlockTokenEnabled ()
specifier|private
name|boolean
name|isBlockTokenEnabled
parameter_list|()
block|{
return|return
name|blockTokenSecretManager
operator|!=
literal|null
return|;
block|}
comment|/** Should the access keys be updated? */
DECL|method|shouldUpdateBlockKey (final long updateTime)
name|boolean
name|shouldUpdateBlockKey
parameter_list|(
specifier|final
name|long
name|updateTime
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isBlockTokenEnabled
argument_list|()
operator|&&
name|blockTokenSecretManager
operator|.
name|updateKeys
argument_list|(
name|updateTime
argument_list|)
return|;
block|}
DECL|method|activate (Configuration conf, long blockTotal)
specifier|public
name|void
name|activate
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|long
name|blockTotal
parameter_list|)
block|{
name|pendingReconstruction
operator|.
name|start
argument_list|()
expr_stmt|;
name|datanodeManager
operator|.
name|activate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|redundancyThread
operator|.
name|setName
argument_list|(
literal|"RedundancyMonitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|redundancyThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|storageInfoDefragmenterThread
operator|.
name|setName
argument_list|(
literal|"StorageInfoMonitor"
argument_list|)
expr_stmt|;
name|storageInfoDefragmenterThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockReportThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|mxBeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"NameNode"
argument_list|,
literal|"BlockStats"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|activate
argument_list|(
name|blockTotal
argument_list|)
expr_stmt|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|getSPSManager
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getSPSManager
argument_list|()
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|bmSafeMode
operator|.
name|close
argument_list|()
expr_stmt|;
try|try
block|{
name|redundancyThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|storageInfoDefragmenterThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|blockReportThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|redundancyThread
operator|.
name|join
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|storageInfoDefragmenterThread
operator|.
name|join
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|blockReportThread
operator|.
name|join
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{     }
name|datanodeManager
operator|.
name|close
argument_list|()
expr_stmt|;
name|pendingReconstruction
operator|.
name|stop
argument_list|()
expr_stmt|;
name|blocksMap
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** @return the datanodeManager */
DECL|method|getDatanodeManager ()
specifier|public
name|DatanodeManager
name|getDatanodeManager
parameter_list|()
block|{
return|return
name|datanodeManager
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getBlockPlacementPolicy ()
specifier|public
name|BlockPlacementPolicy
name|getBlockPlacementPolicy
parameter_list|()
block|{
return|return
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|CONTIGUOUS
argument_list|)
return|;
block|}
comment|/** Dump meta data to out. */
DECL|method|metaSave (PrintWriter out)
specifier|public
name|void
name|metaSave
parameter_list|(
name|PrintWriter
name|out
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasReadLock
argument_list|()
assert|;
comment|// TODO: block manager read lock and NS write lock
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|datanodeManager
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
name|dead
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Live Datanodes: "
operator|+
name|live
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Dead Datanodes: "
operator|+
name|dead
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|//
comment|// Need to iterate over all queues from neededReplications
comment|// except for the QUEUE_WITH_CORRUPT_BLOCKS)
comment|//
synchronized|synchronized
init|(
name|neededReconstruction
init|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"Metasave: Blocks waiting for reconstruction: "
operator|+
name|neededReconstruction
operator|.
name|getLowRedundancyBlockCount
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|neededReconstruction
operator|.
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|neededReconstruction
operator|.
name|QUEUE_WITH_CORRUPT_BLOCKS
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|it
init|=
name|neededReconstruction
operator|.
name|iterator
argument_list|(
name|i
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Block
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|dumpBlockMeta
argument_list|(
name|block
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//
comment|// Now prints corrupt blocks separately
comment|//
name|out
operator|.
name|println
argument_list|(
literal|"Metasave: Blocks currently missing: "
operator|+
name|neededReconstruction
operator|.
name|getCorruptBlockSize
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|it
init|=
name|neededReconstruction
operator|.
name|iterator
argument_list|(
name|neededReconstruction
operator|.
name|QUEUE_WITH_CORRUPT_BLOCKS
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Block
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|dumpBlockMeta
argument_list|(
name|block
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Dump any postponed over-replicated blocks
name|out
operator|.
name|println
argument_list|(
literal|"Mis-replicated blocks that have been postponed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|postponedMisreplicatedBlocks
control|)
block|{
name|dumpBlockMeta
argument_list|(
name|block
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|// Dump blocks from pendingReconstruction
name|pendingReconstruction
operator|.
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// Dump blocks that are waiting to be deleted
name|invalidateBlocks
operator|.
name|dump
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|//Dump corrupt blocks and their storageIDs
name|Set
argument_list|<
name|Block
argument_list|>
name|corruptBlocks
init|=
name|corruptReplicas
operator|.
name|getCorruptBlocksSet
argument_list|()
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Corrupt Blocks:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|corruptBlocks
control|)
block|{
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|corruptNodes
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} is corrupt but has no associated node."
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|int
name|numNodesToFind
init|=
name|corruptNodes
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|corruptNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|String
name|storageId
init|=
name|storage
operator|.
name|getStorageID
argument_list|()
decl_stmt|;
name|DatanodeStorageInfo
name|storageInfo
init|=
name|node
operator|.
name|getStorageInfo
argument_list|(
name|storageId
argument_list|)
decl_stmt|;
name|State
name|state
init|=
operator|(
name|storageInfo
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|storageInfo
operator|.
name|getState
argument_list|()
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Block="
operator|+
name|block
operator|.
name|toString
argument_list|()
operator|+
literal|"\tSize="
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|"\tNode="
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|"\tStorageID="
operator|+
name|storageId
operator|+
literal|"\tStorageState="
operator|+
name|state
operator|+
literal|"\tTotalReplicas="
operator|+
name|blocksMap
operator|.
name|numNodes
argument_list|(
name|block
argument_list|)
operator|+
literal|"\tReason="
operator|+
name|corruptReplicas
operator|.
name|getCorruptReason
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|numNodesToFind
operator|--
expr_stmt|;
if|if
condition|(
name|numNodesToFind
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|numNodesToFind
operator|>
literal|0
condition|)
block|{
name|String
index|[]
name|corruptNodesList
init|=
operator|new
name|String
index|[
name|corruptNodes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|d
range|:
name|corruptNodes
control|)
block|{
name|corruptNodesList
index|[
name|i
index|]
operator|=
name|d
operator|.
name|getHostName
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" corrupt on "
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|corruptNodesList
argument_list|)
operator|+
literal|" but not all nodes are"
operator|+
literal|"found in its block locations"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Dump all datanodes
name|getDatanodeManager
argument_list|()
operator|.
name|datanodeDump
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**    * Dump the metadata for the given block in a human-readable    * form.    */
DECL|method|dumpBlockMeta (Block block, PrintWriter out)
specifier|private
name|void
name|dumpBlockMeta
parameter_list|(
name|Block
name|block
parameter_list|,
name|PrintWriter
name|out
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|containingLiveReplicasNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|()
decl_stmt|;
name|NumberReplicas
name|numReplicas
init|=
operator|new
name|NumberReplicas
argument_list|()
decl_stmt|;
name|BlockInfo
name|blockInfo
init|=
name|getStoredBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockInfo
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"Block "
operator|+
name|block
operator|+
literal|" is Null"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// source node returned is not used
name|chooseSourceDatanodes
argument_list|(
name|blockInfo
argument_list|,
name|containingNodes
argument_list|,
name|containingLiveReplicasNodes
argument_list|,
name|numReplicas
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Byte
argument_list|>
argument_list|()
argument_list|,
name|LowRedundancyBlocks
operator|.
name|LEVEL
argument_list|)
expr_stmt|;
comment|// containingLiveReplicasNodes can include READ_ONLY_SHARED replicas which are
comment|// not included in the numReplicas.liveReplicas() count
assert|assert
name|containingLiveReplicasNodes
operator|.
name|size
argument_list|()
operator|>=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
assert|;
name|int
name|usableReplicas
init|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|numReplicas
operator|.
name|decommissionedAndDecommissioning
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|instanceof
name|BlockInfo
condition|)
block|{
name|BlockCollection
name|bc
init|=
name|getBlockCollection
argument_list|(
operator|(
name|BlockInfo
operator|)
name|block
argument_list|)
decl_stmt|;
name|String
name|fileName
init|=
operator|(
name|bc
operator|==
literal|null
operator|)
condition|?
literal|"[orphaned]"
else|:
name|bc
operator|.
name|getName
argument_list|()
decl_stmt|;
name|out
operator|.
name|print
argument_list|(
name|fileName
operator|+
literal|": "
argument_list|)
expr_stmt|;
block|}
comment|// l: == live:, d: == decommissioned c: == corrupt e: == excess
name|out
operator|.
name|print
argument_list|(
name|block
operator|+
operator|(
operator|(
name|usableReplicas
operator|>
literal|0
operator|)
condition|?
literal|""
else|:
literal|" MISSING"
operator|)
operator|+
literal|" (replicas:"
operator|+
literal|" live: "
operator|+
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
literal|" decommissioning and decommissioned: "
operator|+
name|numReplicas
operator|.
name|decommissionedAndDecommissioning
argument_list|()
operator|+
literal|" corrupt: "
operator|+
name|numReplicas
operator|.
name|corruptReplicas
argument_list|()
operator|+
literal|" in excess: "
operator|+
name|numReplicas
operator|.
name|excessReplicas
argument_list|()
operator|+
literal|" maintenance mode: "
operator|+
name|numReplicas
operator|.
name|maintenanceReplicas
argument_list|()
operator|+
literal|") "
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|String
name|state
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|corruptNodes
operator|!=
literal|null
operator|&&
name|corruptNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|state
operator|=
literal|"(corrupt)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissioned
argument_list|()
operator|||
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
name|state
operator|=
literal|"(decommissioned)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isMaintenance
argument_list|()
operator|||
name|node
operator|.
name|isInMaintenance
argument_list|()
condition|)
block|{
name|state
operator|=
literal|"(maintenance)"
expr_stmt|;
block|}
if|if
condition|(
name|storage
operator|.
name|areBlockContentsStale
argument_list|()
condition|)
block|{
name|state
operator|+=
literal|" (block deletions maybe out of date)"
expr_stmt|;
block|}
name|out
operator|.
name|print
argument_list|(
literal|" "
operator|+
name|node
operator|+
name|state
operator|+
literal|" : "
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** @return maxReplicationStreams */
DECL|method|getMaxReplicationStreams ()
specifier|public
name|int
name|getMaxReplicationStreams
parameter_list|()
block|{
return|return
name|maxReplicationStreams
return|;
block|}
DECL|method|getDefaultStorageNum (BlockInfo block)
specifier|public
name|int
name|getDefaultStorageNum
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
switch|switch
condition|(
name|block
operator|.
name|getBlockType
argument_list|()
condition|)
block|{
case|case
name|STRIPED
case|:
return|return
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|block
operator|)
operator|.
name|getRealTotalBlockNum
argument_list|()
return|;
case|case
name|CONTIGUOUS
case|:
return|return
name|defaultReplication
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"getDefaultStorageNum called with unknown BlockType: "
operator|+
name|block
operator|.
name|getBlockType
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|getMinReplication ()
specifier|public
name|short
name|getMinReplication
parameter_list|()
block|{
return|return
name|minReplication
return|;
block|}
DECL|method|getMinStorageNum (BlockInfo block)
specifier|public
name|short
name|getMinStorageNum
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
switch|switch
condition|(
name|block
operator|.
name|getBlockType
argument_list|()
condition|)
block|{
case|case
name|STRIPED
case|:
return|return
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|block
operator|)
operator|.
name|getRealDataBlockNum
argument_list|()
return|;
case|case
name|CONTIGUOUS
case|:
return|return
name|minReplication
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"getMinStorageNum called with unknown BlockType: "
operator|+
name|block
operator|.
name|getBlockType
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|getMinReplicationToBeInMaintenance ()
specifier|public
name|short
name|getMinReplicationToBeInMaintenance
parameter_list|()
block|{
return|return
name|minReplicationToBeInMaintenance
return|;
block|}
DECL|method|getMinMaintenanceStorageNum (BlockInfo block)
specifier|private
name|short
name|getMinMaintenanceStorageNum
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|.
name|isStriped
argument_list|()
condition|)
block|{
return|return
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|block
operator|)
operator|.
name|getRealDataBlockNum
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|short
operator|)
name|Math
operator|.
name|min
argument_list|(
name|minReplicationToBeInMaintenance
argument_list|,
name|block
operator|.
name|getReplication
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|hasMinStorage (BlockInfo block)
specifier|public
name|boolean
name|hasMinStorage
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
return|return
name|countNodes
argument_list|(
name|block
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|getMinStorageNum
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|hasMinStorage (BlockInfo block, int liveNum)
specifier|public
name|boolean
name|hasMinStorage
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|liveNum
parameter_list|)
block|{
return|return
name|liveNum
operator|>=
name|getMinStorageNum
argument_list|(
name|block
argument_list|)
return|;
block|}
comment|/**    * Commit a block of a file    *     * @param block block to be committed    * @param commitBlock - contains client reported block length and generation    * @return true if the block is changed to committed state.    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|commitBlock (final BlockInfo block, final Block commitBlock)
specifier|private
name|boolean
name|commitBlock
parameter_list|(
specifier|final
name|BlockInfo
name|block
parameter_list|,
specifier|final
name|Block
name|commitBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|block
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|COMMITTED
condition|)
return|return
literal|false
return|;
assert|assert
name|block
operator|.
name|getNumBytes
argument_list|()
operator|<=
name|commitBlock
operator|.
name|getNumBytes
argument_list|()
operator|:
literal|"commitBlock length is less than the stored one "
operator|+
name|commitBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" vs. "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
assert|;
if|if
condition|(
name|block
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|commitBlock
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Commit block with mismatching GS. NN has "
operator|+
name|block
operator|+
literal|", client submits "
operator|+
name|commitBlock
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|ReplicaUnderConstruction
argument_list|>
name|staleReplicas
init|=
name|block
operator|.
name|commitBlock
argument_list|(
name|commitBlock
argument_list|)
decl_stmt|;
name|removeStaleReplicas
argument_list|(
name|staleReplicas
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Commit the last block of the file and mark it as complete if it has    * meets the minimum redundancy requirement    *     * @param bc block collection    * @param commitBlock - contains client reported block length and generation    * @param iip - INodes in path to bc    * @return true if the last block is changed to committed state.    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|commitOrCompleteLastBlock (BlockCollection bc, Block commitBlock, INodesInPath iip)
specifier|public
name|boolean
name|commitOrCompleteLastBlock
parameter_list|(
name|BlockCollection
name|bc
parameter_list|,
name|Block
name|commitBlock
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|commitBlock
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// not committing, this is a block allocation retry
name|BlockInfo
name|lastBlock
init|=
name|bc
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// no blocks in file yet
if|if
condition|(
name|lastBlock
operator|.
name|isComplete
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// already completed (e.g. by syncBlock)
if|if
condition|(
name|lastBlock
operator|.
name|isUnderRecovery
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Commit or complete block "
operator|+
name|commitBlock
operator|+
literal|", whereas it is under recovery."
argument_list|)
throw|;
block|}
specifier|final
name|boolean
name|committed
init|=
name|commitBlock
argument_list|(
name|lastBlock
argument_list|,
name|commitBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|committed
operator|&&
name|lastBlock
operator|.
name|isStriped
argument_list|()
condition|)
block|{
comment|// update scheduled size for DatanodeStorages that do not store any
comment|// internal blocks
name|lastBlock
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|updateStorageScheduledSize
argument_list|(
operator|(
name|BlockInfoStriped
operator|)
name|lastBlock
argument_list|)
expr_stmt|;
block|}
comment|// Count replicas on decommissioning nodes, as these will not be
comment|// decommissioned unless recovery/completing last block has finished
name|NumberReplicas
name|numReplicas
init|=
name|countNodes
argument_list|(
name|lastBlock
argument_list|)
decl_stmt|;
name|int
name|numUsableReplicas
init|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|numReplicas
operator|.
name|decommissioning
argument_list|()
operator|+
name|numReplicas
operator|.
name|liveEnteringMaintenanceReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasMinStorage
argument_list|(
name|lastBlock
argument_list|,
name|numUsableReplicas
argument_list|)
condition|)
block|{
if|if
condition|(
name|committed
condition|)
block|{
name|addExpectedReplicasToPending
argument_list|(
name|lastBlock
argument_list|)
expr_stmt|;
block|}
name|completeBlock
argument_list|(
name|lastBlock
argument_list|,
name|iip
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pendingRecoveryBlocks
operator|.
name|isUnderRecovery
argument_list|(
name|lastBlock
argument_list|)
condition|)
block|{
comment|// We've just finished recovery for this block, complete
comment|// the block forcibly disregarding number of replicas.
comment|// This is to ignore minReplication, the block will be closed
comment|// and then replicated out.
name|completeBlock
argument_list|(
name|lastBlock
argument_list|,
name|iip
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|updateNeededReconstructions
argument_list|(
name|lastBlock
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|committed
return|;
block|}
comment|/**    * If IBR is not sent from expected locations yet, add the datanodes to    * pendingReconstruction in order to keep RedundancyMonitor from scheduling    * the block.    */
DECL|method|addExpectedReplicasToPending (BlockInfo blk)
specifier|public
name|void
name|addExpectedReplicasToPending
parameter_list|(
name|BlockInfo
name|blk
parameter_list|)
block|{
if|if
condition|(
operator|!
name|blk
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|DatanodeStorageInfo
index|[]
name|expectedStorages
init|=
name|blk
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|getExpectedStorageLocations
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedStorages
operator|.
name|length
operator|-
name|blk
operator|.
name|numNodes
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|pendingNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|expectedStorages
control|)
block|{
name|DatanodeDescriptor
name|dnd
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|blk
operator|.
name|findStorageInfo
argument_list|(
name|dnd
argument_list|)
operator|==
literal|null
condition|)
block|{
name|pendingNodes
operator|.
name|add
argument_list|(
name|dnd
argument_list|)
expr_stmt|;
block|}
block|}
name|pendingReconstruction
operator|.
name|increment
argument_list|(
name|blk
argument_list|,
name|pendingNodes
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeDescriptor
index|[
name|pendingNodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Convert a specified block of the file to a complete block.    * @param curBlock - block to be completed    * @param iip - INodes in path to file containing curBlock; if null,    *              this will be resolved internally    * @param force - force completion of the block    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|completeBlock (BlockInfo curBlock, INodesInPath iip, boolean force)
specifier|private
name|void
name|completeBlock
parameter_list|(
name|BlockInfo
name|curBlock
parameter_list|,
name|INodesInPath
name|iip
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
block|{
return|return;
block|}
name|int
name|numNodes
init|=
name|curBlock
operator|.
name|numNodes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|hasMinStorage
argument_list|(
name|curBlock
argument_list|,
name|numNodes
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot complete block: "
operator|+
literal|"block does not satisfy minimal replication requirement."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|force
operator|&&
name|curBlock
operator|.
name|getBlockUCState
argument_list|()
operator|!=
name|BlockUCState
operator|.
name|COMMITTED
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot complete block: block has not been COMMITTED by the client"
argument_list|)
throw|;
block|}
name|convertToCompleteBlock
argument_list|(
name|curBlock
argument_list|,
name|iip
argument_list|)
expr_stmt|;
comment|// Since safe-mode only counts complete blocks, and we now have
comment|// one more complete block, we need to adjust the total up, and
comment|// also count it as safe, if we have at least the minimum replica
comment|// count. (We may not have the minimum replica count yet if this is
comment|// a "forced" completion when a file is getting closed by an
comment|// OP_CLOSE edit on the standby).
name|bmSafeMode
operator|.
name|adjustBlockTotals
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|int
name|minStorage
init|=
name|curBlock
operator|.
name|isStriped
argument_list|()
condition|?
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|curBlock
operator|)
operator|.
name|getRealDataBlockNum
argument_list|()
else|:
name|minReplication
decl_stmt|;
name|bmSafeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|numNodes
argument_list|,
name|minStorage
argument_list|)
argument_list|,
name|curBlock
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convert a specified block of the file to a complete block.    * Skips validity checking and safe mode block total updates; use    * {@link BlockManager#completeBlock} to include these.    * @param curBlock - block to be completed    * @param iip - INodes in path to file containing curBlock; if null,    *              this will be resolved internally    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|convertToCompleteBlock (BlockInfo curBlock, INodesInPath iip)
specifier|private
name|void
name|convertToCompleteBlock
parameter_list|(
name|BlockInfo
name|curBlock
parameter_list|,
name|INodesInPath
name|iip
parameter_list|)
throws|throws
name|IOException
block|{
name|curBlock
operator|.
name|convertToCompleteBlock
argument_list|()
expr_stmt|;
name|namesystem
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|updateSpaceForCompleteBlock
argument_list|(
name|curBlock
argument_list|,
name|iip
argument_list|)
expr_stmt|;
block|}
comment|/**    * Force the given block in the given file to be marked as complete,    * regardless of whether enough replicas are present. This is necessary    * when tailing edit logs as a Standby.    */
DECL|method|forceCompleteBlock (final BlockInfo block)
specifier|public
name|void
name|forceCompleteBlock
parameter_list|(
specifier|final
name|BlockInfo
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|ReplicaUnderConstruction
argument_list|>
name|staleReplicas
init|=
name|block
operator|.
name|commitBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|removeStaleReplicas
argument_list|(
name|staleReplicas
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|completeBlock
argument_list|(
name|block
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convert the last block of the file to an under construction block.<p>    * The block is converted only if the file has blocks and the last one    * is a partial block (its size is less than the preferred block size).    * The converted block is returned to the client.    * The client uses the returned block locations to form the data pipeline    * for this block.<br>    * The methods returns null if there is no partial block at the end.    * The client is supposed to allocate a new block with the next call.    *    * @param bc file    * @param bytesToRemove num of bytes to remove from block    * @return the last block locations if the block is partial or null otherwise    */
DECL|method|convertLastBlockToUnderConstruction ( BlockCollection bc, long bytesToRemove)
specifier|public
name|LocatedBlock
name|convertLastBlockToUnderConstruction
parameter_list|(
name|BlockCollection
name|bc
parameter_list|,
name|long
name|bytesToRemove
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockInfo
name|lastBlock
init|=
name|bc
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|==
literal|null
operator|||
name|bc
operator|.
name|getPreferredBlockSize
argument_list|()
operator|==
name|lastBlock
operator|.
name|getNumBytes
argument_list|()
operator|-
name|bytesToRemove
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
name|lastBlock
operator|==
name|getStoredBlock
argument_list|(
name|lastBlock
argument_list|)
operator|:
literal|"last block of the file is not in blocksMap"
assert|;
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|getStorages
argument_list|(
name|lastBlock
argument_list|)
decl_stmt|;
comment|// convert the last block to under construction. note no block replacement
comment|// is happening
name|bc
operator|.
name|convertLastBlockToUC
argument_list|(
name|lastBlock
argument_list|,
name|targets
argument_list|)
expr_stmt|;
comment|// Remove block from reconstruction queue.
name|NumberReplicas
name|replicas
init|=
name|countNodes
argument_list|(
name|lastBlock
argument_list|)
decl_stmt|;
name|neededReconstruction
operator|.
name|remove
argument_list|(
name|lastBlock
argument_list|,
name|replicas
operator|.
name|liveReplicas
argument_list|()
argument_list|,
name|replicas
operator|.
name|readOnlyReplicas
argument_list|()
argument_list|,
name|replicas
operator|.
name|outOfServiceReplicas
argument_list|()
argument_list|,
name|getExpectedRedundancyNum
argument_list|(
name|lastBlock
argument_list|)
argument_list|)
expr_stmt|;
name|pendingReconstruction
operator|.
name|remove
argument_list|(
name|lastBlock
argument_list|)
expr_stmt|;
comment|// remove this block from the list of pending blocks to be deleted.
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|targets
control|)
block|{
specifier|final
name|Block
name|b
init|=
name|getBlockOnStorage
argument_list|(
name|lastBlock
argument_list|,
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
condition|)
block|{
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Adjust safe-mode totals, since under-construction blocks don't
comment|// count in safe-mode.
name|bmSafeMode
operator|.
name|adjustBlockTotals
argument_list|(
comment|// decrement safe if we had enough
name|hasMinStorage
argument_list|(
name|lastBlock
argument_list|,
name|targets
operator|.
name|length
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
comment|// always decrement total blocks
operator|-
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|long
name|fileLength
init|=
name|bc
operator|.
name|computeContentSummary
argument_list|(
name|getStoragePolicySuite
argument_list|()
argument_list|)
operator|.
name|getLength
argument_list|()
decl_stmt|;
specifier|final
name|long
name|pos
init|=
name|fileLength
operator|-
name|lastBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
return|return
name|createLocatedBlock
argument_list|(
literal|null
argument_list|,
name|lastBlock
argument_list|,
name|pos
argument_list|,
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
return|;
block|}
comment|/**    * Get all valid locations of the block    */
DECL|method|getValidLocations (BlockInfo block)
specifier|private
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|getValidLocations
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|locations
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|(
name|blocksMap
operator|.
name|numNodes
argument_list|(
name|block
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
comment|// filter invalidate replicas
name|Block
name|b
init|=
name|getBlockOnStorage
argument_list|(
name|block
argument_list|,
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
operator|&&
operator|!
name|invalidateBlocks
operator|.
name|contains
argument_list|(
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|b
argument_list|)
condition|)
block|{
name|locations
operator|.
name|add
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|locations
return|;
block|}
DECL|method|createLocatedBlockList ( LocatedBlockBuilder locatedBlocks, final BlockInfo[] blocks, final long offset, final long length, final AccessMode mode)
specifier|private
name|void
name|createLocatedBlockList
parameter_list|(
name|LocatedBlockBuilder
name|locatedBlocks
parameter_list|,
specifier|final
name|BlockInfo
index|[]
name|blocks
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|length
parameter_list|,
specifier|final
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|curBlk
decl_stmt|;
name|long
name|curPos
init|=
literal|0
decl_stmt|,
name|blkSize
init|=
literal|0
decl_stmt|;
name|int
name|nrBlocks
init|=
operator|(
name|blocks
index|[
literal|0
index|]
operator|.
name|getNumBytes
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|blocks
operator|.
name|length
decl_stmt|;
for|for
control|(
name|curBlk
operator|=
literal|0
init|;
name|curBlk
operator|<
name|nrBlocks
condition|;
name|curBlk
operator|++
control|)
block|{
name|blkSize
operator|=
name|blocks
index|[
name|curBlk
index|]
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
assert|assert
name|blkSize
operator|>
literal|0
operator|:
literal|"Block of size 0"
assert|;
if|if
condition|(
name|curPos
operator|+
name|blkSize
operator|>
name|offset
condition|)
block|{
break|break;
block|}
name|curPos
operator|+=
name|blkSize
expr_stmt|;
block|}
if|if
condition|(
name|nrBlocks
operator|>
literal|0
operator|&&
name|curBlk
operator|==
name|nrBlocks
condition|)
comment|// offset>= end of file
return|return;
name|long
name|endOff
init|=
name|offset
operator|+
name|length
decl_stmt|;
do|do
block|{
name|locatedBlocks
operator|.
name|addBlock
argument_list|(
name|createLocatedBlock
argument_list|(
name|locatedBlocks
argument_list|,
name|blocks
index|[
name|curBlk
index|]
argument_list|,
name|curPos
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|curPos
operator|+=
name|blocks
index|[
name|curBlk
index|]
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
name|curBlk
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|curPos
operator|<
name|endOff
operator|&&
name|curBlk
operator|<
name|blocks
operator|.
name|length
operator|&&
operator|!
name|locatedBlocks
operator|.
name|isBlockMax
argument_list|()
condition|)
do|;
return|return;
block|}
DECL|method|createLocatedBlock (LocatedBlockBuilder locatedBlocks, final BlockInfo[] blocks, final long endPos, final AccessMode mode)
specifier|private
name|LocatedBlock
name|createLocatedBlock
parameter_list|(
name|LocatedBlockBuilder
name|locatedBlocks
parameter_list|,
specifier|final
name|BlockInfo
index|[]
name|blocks
parameter_list|,
specifier|final
name|long
name|endPos
parameter_list|,
specifier|final
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|curBlk
decl_stmt|;
name|long
name|curPos
init|=
literal|0
decl_stmt|;
name|int
name|nrBlocks
init|=
operator|(
name|blocks
index|[
literal|0
index|]
operator|.
name|getNumBytes
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|blocks
operator|.
name|length
decl_stmt|;
for|for
control|(
name|curBlk
operator|=
literal|0
init|;
name|curBlk
operator|<
name|nrBlocks
condition|;
name|curBlk
operator|++
control|)
block|{
name|long
name|blkSize
init|=
name|blocks
index|[
name|curBlk
index|]
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|curPos
operator|+
name|blkSize
operator|>=
name|endPos
condition|)
block|{
break|break;
block|}
name|curPos
operator|+=
name|blkSize
expr_stmt|;
block|}
return|return
name|createLocatedBlock
argument_list|(
name|locatedBlocks
argument_list|,
name|blocks
index|[
name|curBlk
index|]
argument_list|,
name|curPos
argument_list|,
name|mode
argument_list|)
return|;
block|}
DECL|method|createLocatedBlock (LocatedBlockBuilder locatedBlocks, final BlockInfo blk, final long pos, final AccessMode mode)
specifier|private
name|LocatedBlock
name|createLocatedBlock
parameter_list|(
name|LocatedBlockBuilder
name|locatedBlocks
parameter_list|,
specifier|final
name|BlockInfo
name|blk
parameter_list|,
specifier|final
name|long
name|pos
parameter_list|,
specifier|final
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|LocatedBlock
name|lb
init|=
name|createLocatedBlock
argument_list|(
name|locatedBlocks
argument_list|,
name|blk
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|null
condition|)
block|{
name|setBlockToken
argument_list|(
name|lb
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|lb
return|;
block|}
comment|/** @return a LocatedBlock for the given block */
DECL|method|createLocatedBlock (LocatedBlockBuilder locatedBlocks, final BlockInfo blk, final long pos)
specifier|private
name|LocatedBlock
name|createLocatedBlock
parameter_list|(
name|LocatedBlockBuilder
name|locatedBlocks
parameter_list|,
specifier|final
name|BlockInfo
name|blk
parameter_list|,
specifier|final
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blk
operator|.
name|isComplete
argument_list|()
condition|)
block|{
specifier|final
name|BlockUnderConstructionFeature
name|uc
init|=
name|blk
operator|.
name|getUnderConstructionFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|blk
operator|.
name|isStriped
argument_list|()
condition|)
block|{
specifier|final
name|DatanodeStorageInfo
index|[]
name|storages
init|=
name|uc
operator|.
name|getExpectedStorageLocations
argument_list|()
decl_stmt|;
specifier|final
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|getBlockPoolId
argument_list|()
argument_list|,
name|blk
argument_list|)
decl_stmt|;
return|return
name|newLocatedStripedBlock
argument_list|(
name|eb
argument_list|,
name|storages
argument_list|,
name|uc
operator|.
name|getBlockIndices
argument_list|()
argument_list|,
name|pos
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|DatanodeStorageInfo
index|[]
name|storages
init|=
name|uc
operator|.
name|getExpectedStorageLocations
argument_list|()
decl_stmt|;
specifier|final
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|getBlockPoolId
argument_list|()
argument_list|,
name|blk
argument_list|)
decl_stmt|;
return|return
literal|null
operator|==
name|locatedBlocks
condition|?
name|newLocatedBlock
argument_list|(
name|eb
argument_list|,
name|storages
argument_list|,
name|pos
argument_list|,
literal|false
argument_list|)
else|:
name|locatedBlocks
operator|.
name|newLocatedBlock
argument_list|(
name|eb
argument_list|,
name|storages
argument_list|,
name|pos
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
comment|// get block locations
name|NumberReplicas
name|numReplicas
init|=
name|countNodes
argument_list|(
name|blk
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numCorruptNodes
init|=
name|numReplicas
operator|.
name|corruptReplicas
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numCorruptReplicas
init|=
name|corruptReplicas
operator|.
name|numCorruptReplicas
argument_list|(
name|blk
argument_list|)
decl_stmt|;
if|if
condition|(
name|numCorruptNodes
operator|!=
name|numCorruptReplicas
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Inconsistent number of corrupt replicas for {}"
operator|+
literal|" blockMap has {} but corrupt replicas map has {}"
argument_list|,
name|blk
argument_list|,
name|numCorruptNodes
argument_list|,
name|numCorruptReplicas
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|numNodes
init|=
name|blocksMap
operator|.
name|numNodes
argument_list|(
name|blk
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isCorrupt
decl_stmt|;
if|if
condition|(
name|blk
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|BlockInfoStriped
name|sblk
init|=
operator|(
name|BlockInfoStriped
operator|)
name|blk
decl_stmt|;
name|isCorrupt
operator|=
name|numCorruptReplicas
operator|!=
literal|0
operator|&&
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|<
name|sblk
operator|.
name|getRealDataBlockNum
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|isCorrupt
operator|=
name|numCorruptReplicas
operator|!=
literal|0
operator|&&
name|numCorruptReplicas
operator|==
name|numNodes
expr_stmt|;
block|}
name|int
name|numMachines
init|=
name|isCorrupt
condition|?
name|numNodes
else|:
name|numNodes
operator|-
name|numCorruptReplicas
decl_stmt|;
name|numMachines
operator|-=
name|numReplicas
operator|.
name|maintenanceNotForReadReplicas
argument_list|()
expr_stmt|;
name|DatanodeStorageInfo
index|[]
name|machines
init|=
operator|new
name|DatanodeStorageInfo
index|[
name|numMachines
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|blockIndices
init|=
name|blk
operator|.
name|isStriped
argument_list|()
condition|?
operator|new
name|byte
index|[
name|numMachines
index|]
else|:
literal|null
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numMachines
operator|>
literal|0
condition|)
block|{
specifier|final
name|boolean
name|noCorrupt
init|=
operator|(
name|numCorruptReplicas
operator|==
literal|0
operator|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|blk
argument_list|)
control|)
block|{
if|if
condition|(
name|storage
operator|.
name|getState
argument_list|()
operator|!=
name|State
operator|.
name|FAILED
condition|)
block|{
specifier|final
name|DatanodeDescriptor
name|d
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
comment|// Don't pick IN_MAINTENANCE or dead ENTERING_MAINTENANCE states.
if|if
condition|(
name|d
operator|.
name|isInMaintenance
argument_list|()
operator|||
operator|(
name|d
operator|.
name|isEnteringMaintenance
argument_list|()
operator|&&
operator|!
name|d
operator|.
name|isAlive
argument_list|()
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|noCorrupt
condition|)
block|{
name|machines
index|[
name|j
operator|++
index|]
operator|=
name|storage
expr_stmt|;
name|i
operator|=
name|setBlockIndices
argument_list|(
name|blk
argument_list|,
name|blockIndices
argument_list|,
name|i
argument_list|,
name|storage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|boolean
name|replicaCorrupt
init|=
name|isReplicaCorrupt
argument_list|(
name|blk
argument_list|,
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCorrupt
operator|||
operator|!
name|replicaCorrupt
condition|)
block|{
name|machines
index|[
name|j
operator|++
index|]
operator|=
name|storage
expr_stmt|;
name|i
operator|=
name|setBlockIndices
argument_list|(
name|blk
argument_list|,
name|blockIndices
argument_list|,
name|i
argument_list|,
name|storage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|j
operator|<
name|machines
operator|.
name|length
condition|)
block|{
name|machines
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|machines
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
assert|assert
name|j
operator|==
name|machines
operator|.
name|length
operator|:
literal|"isCorrupt: "
operator|+
name|isCorrupt
operator|+
literal|" numMachines: "
operator|+
name|numMachines
operator|+
literal|" numNodes: "
operator|+
name|numNodes
operator|+
literal|" numCorrupt: "
operator|+
name|numCorruptNodes
operator|+
literal|" numCorruptRepls: "
operator|+
name|numCorruptReplicas
assert|;
specifier|final
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|getBlockPoolId
argument_list|()
argument_list|,
name|blk
argument_list|)
decl_stmt|;
return|return
name|blockIndices
operator|==
literal|null
condition|?
literal|null
operator|==
name|locatedBlocks
condition|?
name|newLocatedBlock
argument_list|(
name|eb
argument_list|,
name|machines
argument_list|,
name|pos
argument_list|,
name|isCorrupt
argument_list|)
else|:
name|locatedBlocks
operator|.
name|newLocatedBlock
argument_list|(
name|eb
argument_list|,
name|machines
argument_list|,
name|pos
argument_list|,
name|isCorrupt
argument_list|)
else|:
name|newLocatedStripedBlock
argument_list|(
name|eb
argument_list|,
name|machines
argument_list|,
name|blockIndices
argument_list|,
name|pos
argument_list|,
name|isCorrupt
argument_list|)
return|;
block|}
comment|/** Create a LocatedBlocks. */
DECL|method|createLocatedBlocks (final BlockInfo[] blocks, final long fileSizeExcludeBlocksUnderConstruction, final boolean isFileUnderConstruction, final long offset, final long length, final boolean needBlockToken, final boolean inSnapshot, FileEncryptionInfo feInfo, ErasureCodingPolicy ecPolicy)
specifier|public
name|LocatedBlocks
name|createLocatedBlocks
parameter_list|(
specifier|final
name|BlockInfo
index|[]
name|blocks
parameter_list|,
specifier|final
name|long
name|fileSizeExcludeBlocksUnderConstruction
parameter_list|,
specifier|final
name|boolean
name|isFileUnderConstruction
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|length
parameter_list|,
specifier|final
name|boolean
name|needBlockToken
parameter_list|,
specifier|final
name|boolean
name|inSnapshot
parameter_list|,
name|FileEncryptionInfo
name|feInfo
parameter_list|,
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasReadLock
argument_list|()
assert|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|blocks
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|LocatedBlocks
argument_list|(
literal|0
argument_list|,
name|isFileUnderConstruction
argument_list|,
name|Collections
operator|.
expr|<
name|LocatedBlock
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|feInfo
argument_list|,
name|ecPolicy
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"blocks = {}"
argument_list|,
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|AccessMode
name|mode
init|=
name|needBlockToken
condition|?
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|READ
else|:
literal|null
decl_stmt|;
name|LocatedBlockBuilder
name|locatedBlocks
init|=
name|providedStorageMap
operator|.
name|newLocatedBlocks
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|fileLength
argument_list|(
name|fileSizeExcludeBlocksUnderConstruction
argument_list|)
operator|.
name|lastUC
argument_list|(
name|isFileUnderConstruction
argument_list|)
operator|.
name|encryption
argument_list|(
name|feInfo
argument_list|)
operator|.
name|erasureCoding
argument_list|(
name|ecPolicy
argument_list|)
decl_stmt|;
name|createLocatedBlockList
argument_list|(
name|locatedBlocks
argument_list|,
name|blocks
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inSnapshot
condition|)
block|{
specifier|final
name|BlockInfo
name|last
init|=
name|blocks
index|[
name|blocks
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|long
name|lastPos
init|=
name|last
operator|.
name|isComplete
argument_list|()
condition|?
name|fileSizeExcludeBlocksUnderConstruction
operator|-
name|last
operator|.
name|getNumBytes
argument_list|()
else|:
name|fileSizeExcludeBlocksUnderConstruction
decl_stmt|;
name|locatedBlocks
operator|.
name|lastBlock
argument_list|(
name|createLocatedBlock
argument_list|(
name|locatedBlocks
argument_list|,
name|last
argument_list|,
name|lastPos
argument_list|,
name|mode
argument_list|)
argument_list|)
operator|.
name|lastComplete
argument_list|(
name|last
operator|.
name|isComplete
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locatedBlocks
operator|.
name|lastBlock
argument_list|(
name|createLocatedBlock
argument_list|(
name|locatedBlocks
argument_list|,
name|blocks
argument_list|,
name|fileSizeExcludeBlocksUnderConstruction
argument_list|,
name|mode
argument_list|)
argument_list|)
operator|.
name|lastComplete
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|LocatedBlocks
name|locations
init|=
name|locatedBlocks
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Set caching information for the located blocks.
name|CacheManager
name|cm
init|=
name|namesystem
operator|.
name|getCacheManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|cm
operator|!=
literal|null
condition|)
block|{
name|cm
operator|.
name|setCachedLocations
argument_list|(
name|locations
argument_list|)
expr_stmt|;
block|}
return|return
name|locations
return|;
block|}
block|}
comment|/** @return current access keys. */
DECL|method|getBlockKeys ()
specifier|public
name|ExportedBlockKeys
name|getBlockKeys
parameter_list|()
block|{
return|return
name|isBlockTokenEnabled
argument_list|()
condition|?
name|blockTokenSecretManager
operator|.
name|exportKeys
argument_list|()
else|:
name|ExportedBlockKeys
operator|.
name|DUMMY_KEYS
return|;
block|}
comment|/** Generate a block token for the located block. */
DECL|method|setBlockToken (final LocatedBlock b, final AccessMode mode)
specifier|public
name|void
name|setBlockToken
parameter_list|(
specifier|final
name|LocatedBlock
name|b
parameter_list|,
specifier|final
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
condition|)
block|{
comment|// Use cached UGI if serving RPC calls.
if|if
condition|(
name|b
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|b
operator|instanceof
name|LocatedStripedBlock
argument_list|)
expr_stmt|;
name|LocatedStripedBlock
name|sb
init|=
operator|(
name|LocatedStripedBlock
operator|)
name|b
decl_stmt|;
name|byte
index|[]
name|indices
init|=
name|sb
operator|.
name|getBlockIndices
argument_list|()
decl_stmt|;
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
index|[]
name|blockTokens
init|=
operator|new
name|Token
index|[
name|indices
operator|.
name|length
index|]
decl_stmt|;
name|ExtendedBlock
name|internalBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|b
operator|.
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indices
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|internalBlock
operator|.
name|setBlockId
argument_list|(
name|b
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
operator|+
name|indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|blockTokens
index|[
name|i
index|]
operator|=
name|blockTokenSecretManager
operator|.
name|generateToken
argument_list|(
name|NameNode
operator|.
name|getRemoteUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|internalBlock
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|mode
argument_list|)
argument_list|,
name|b
operator|.
name|getStorageTypes
argument_list|()
argument_list|,
name|b
operator|.
name|getStorageIDs
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setBlockTokens
argument_list|(
name|blockTokens
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|setBlockToken
argument_list|(
name|blockTokenSecretManager
operator|.
name|generateToken
argument_list|(
name|NameNode
operator|.
name|getRemoteUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|b
operator|.
name|getBlock
argument_list|()
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|mode
argument_list|)
argument_list|,
name|b
operator|.
name|getStorageTypes
argument_list|()
argument_list|,
name|b
operator|.
name|getStorageIDs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addKeyUpdateCommand (final List<DatanodeCommand> cmds, final DatanodeDescriptor nodeinfo)
name|void
name|addKeyUpdateCommand
parameter_list|(
specifier|final
name|List
argument_list|<
name|DatanodeCommand
argument_list|>
name|cmds
parameter_list|,
specifier|final
name|DatanodeDescriptor
name|nodeinfo
parameter_list|)
block|{
comment|// check access key update
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
operator|&&
name|nodeinfo
operator|.
name|needKeyUpdate
argument_list|()
condition|)
block|{
name|cmds
operator|.
name|add
argument_list|(
operator|new
name|KeyUpdateCommand
argument_list|(
name|blockTokenSecretManager
operator|.
name|exportKeys
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|nodeinfo
operator|.
name|setNeedKeyUpdate
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|generateDataEncryptionKey ()
specifier|public
name|DataEncryptionKey
name|generateDataEncryptionKey
parameter_list|()
block|{
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
operator|&&
name|encryptDataTransfer
condition|)
block|{
return|return
name|blockTokenSecretManager
operator|.
name|generateDataEncryptionKey
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Clamp the specified replication between the minimum and the maximum    * replication levels.    */
DECL|method|adjustReplication (short replication)
specifier|public
name|short
name|adjustReplication
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
return|return
name|replication
operator|<
name|minReplication
condition|?
name|minReplication
else|:
name|replication
operator|>
name|maxReplication
condition|?
name|maxReplication
else|:
name|replication
return|;
block|}
comment|/**    * Check whether the replication parameter is within the range    * determined by system configuration and throw an exception if it's not.    *    * @param src the path to the target file    * @param replication the requested replication factor    * @param clientName the name of the client node making the request    * @throws java.io.IOException thrown if the requested replication factor    * is out of bounds    */
DECL|method|verifyReplication (String src, short replication, String clientName)
specifier|public
name|void
name|verifyReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|,
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|err
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|replication
operator|>
name|maxReplication
condition|)
block|{
name|err
operator|=
literal|" exceeds maximum of "
operator|+
name|maxReplication
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|replication
operator|<
name|minReplication
condition|)
block|{
name|err
operator|=
literal|" is less than the required minimum of "
operator|+
name|minReplication
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Requested replication factor of "
operator|+
name|replication
operator|+
name|err
operator|+
literal|" for "
operator|+
name|src
operator|+
operator|(
name|clientName
operator|==
literal|null
condition|?
literal|""
else|:
literal|", clientName="
operator|+
name|clientName
operator|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Check if a block is replicated to at least the minimum replication.    */
DECL|method|isSufficientlyReplicated (BlockInfo b)
specifier|public
name|boolean
name|isSufficientlyReplicated
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
comment|// Compare against the lesser of the minReplication and number of live DNs.
specifier|final
name|int
name|liveReplicas
init|=
name|countNodes
argument_list|(
name|b
argument_list|)
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|liveReplicas
operator|>=
name|minReplication
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// getNumLiveDataNodes() is very expensive and we minimize its use by
comment|// comparing with minReplication first.
return|return
name|liveReplicas
operator|>=
name|getDatanodeManager
argument_list|()
operator|.
name|getNumLiveDataNodes
argument_list|()
return|;
block|}
comment|/** Get all blocks with location information from a datanode. */
DECL|method|getBlocksWithLocations (final DatanodeID datanode, final long size, final long minBlockSize)
specifier|public
name|BlocksWithLocations
name|getBlocksWithLocations
parameter_list|(
specifier|final
name|DatanodeID
name|datanode
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|long
name|minBlockSize
parameter_list|)
throws|throws
name|UnregisteredNodeException
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|datanode
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* getBlocks: Asking for blocks from an"
operator|+
literal|" unrecorded node {}"
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Datanode "
operator|+
name|datanode
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
name|int
name|numBlocks
init|=
name|node
operator|.
name|numBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBlocks
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|BlocksWithLocations
argument_list|(
operator|new
name|BlockWithLocations
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|// starting from a random block
name|int
name|startBlock
init|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
name|numBlocks
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|iter
init|=
name|node
operator|.
name|getBlockIterator
argument_list|(
name|startBlock
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BlockWithLocations
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockWithLocations
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
name|BlockInfo
name|curBlock
decl_stmt|;
while|while
condition|(
name|totalSize
operator|<
name|size
operator|&&
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|curBlock
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|curBlock
operator|.
name|getNumBytes
argument_list|()
operator|<
name|minBlockSize
condition|)
block|{
continue|continue;
block|}
name|totalSize
operator|+=
name|addBlock
argument_list|(
name|curBlock
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totalSize
operator|<
name|size
condition|)
block|{
name|iter
operator|=
name|node
operator|.
name|getBlockIterator
argument_list|()
expr_stmt|;
comment|// start from the beginning
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|startBlock
operator|&&
name|totalSize
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|curBlock
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|curBlock
operator|.
name|getNumBytes
argument_list|()
operator|<
name|minBlockSize
condition|)
block|{
continue|continue;
block|}
name|totalSize
operator|+=
name|addBlock
argument_list|(
name|curBlock
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|BlocksWithLocations
argument_list|(
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|BlockWithLocations
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/** Remove the blocks associated to the given datanode. */
DECL|method|removeBlocksAssociatedTo (final DatanodeDescriptor node)
name|void
name|removeBlocksAssociatedTo
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
name|providedStorageMap
operator|.
name|removeDatanode
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|node
operator|.
name|getStorageInfos
argument_list|()
control|)
block|{
specifier|final
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|it
init|=
name|storage
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
comment|//add the BlockInfos to a new collection as the
comment|//returned iterator is not modifiable.
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockInfo
name|b
range|:
name|toRemove
control|)
block|{
name|removeStoredBlock
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove all pending DN messages referencing this DN.
name|pendingDNMessages
operator|.
name|removeAllMessagesForDatanode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|resetBlocks
argument_list|()
expr_stmt|;
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/** Remove the blocks associated to the given DatanodeStorageInfo. */
DECL|method|removeBlocksAssociatedTo (final DatanodeStorageInfo storageInfo)
name|void
name|removeBlocksAssociatedTo
parameter_list|(
specifier|final
name|DatanodeStorageInfo
name|storageInfo
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|it
init|=
name|storageInfo
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockInfo
name|block
range|:
name|toRemove
control|)
block|{
name|removeStoredBlock
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
expr_stmt|;
specifier|final
name|Block
name|b
init|=
name|getBlockOnStorage
argument_list|(
name|block
argument_list|,
name|storageInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
condition|)
block|{
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|node
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
name|checkSafeMode
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed blocks associated with storage {} from DataNode {}"
argument_list|,
name|storageInfo
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds block to list of blocks which will be invalidated on specified    * datanode and log the operation    */
DECL|method|addToInvalidates (final Block block, final DatanodeInfo datanode)
name|void
name|addToInvalidates
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|,
specifier|final
name|DatanodeInfo
name|datanode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return;
block|}
name|invalidateBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|datanode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds block to list of blocks which will be invalidated on all its    * datanodes.    */
DECL|method|addToInvalidates (BlockInfo storedBlock)
specifier|private
name|void
name|addToInvalidates
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return;
block|}
name|StringBuilder
name|datanodes
init|=
name|blockLog
operator|.
name|isDebugEnabled
argument_list|()
condition|?
operator|new
name|StringBuilder
argument_list|()
else|:
literal|null
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|storedBlock
argument_list|)
control|)
block|{
if|if
condition|(
name|storage
operator|.
name|getState
argument_list|()
operator|!=
name|State
operator|.
name|NORMAL
condition|)
block|{
continue|continue;
block|}
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
specifier|final
name|Block
name|b
init|=
name|getBlockOnStorage
argument_list|(
name|storedBlock
argument_list|,
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
condition|)
block|{
name|invalidateBlocks
operator|.
name|add
argument_list|(
name|b
argument_list|,
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanodes
operator|!=
literal|null
condition|)
block|{
name|datanodes
operator|.
name|append
argument_list|(
name|node
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|datanodes
operator|!=
literal|null
operator|&&
name|datanodes
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* addToInvalidates: {} {}"
argument_list|,
name|storedBlock
argument_list|,
name|datanodes
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getBlockOnStorage (BlockInfo storedBlock, DatanodeStorageInfo storage)
specifier|private
name|Block
name|getBlockOnStorage
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|DatanodeStorageInfo
name|storage
parameter_list|)
block|{
return|return
name|storedBlock
operator|.
name|isStriped
argument_list|()
condition|?
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|storedBlock
operator|)
operator|.
name|getBlockOnStorage
argument_list|(
name|storage
argument_list|)
else|:
name|storedBlock
return|;
block|}
comment|/**    * Mark the block belonging to datanode as corrupt    * @param blk Block to be marked as corrupt    * @param dn Datanode which holds the corrupt replica    * @param storageID if known, null otherwise.    * @param reason a textual reason why the block should be marked corrupt,    * for logging purposes    */
DECL|method|findAndMarkBlockAsCorrupt (final ExtendedBlock blk, final DatanodeInfo dn, String storageID, String reason)
specifier|public
name|void
name|findAndMarkBlockAsCorrupt
parameter_list|(
specifier|final
name|ExtendedBlock
name|blk
parameter_list|,
specifier|final
name|DatanodeInfo
name|dn
parameter_list|,
name|String
name|storageID
parameter_list|,
name|String
name|reason
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|Block
name|reportedBlock
init|=
name|blk
operator|.
name|getLocalBlock
argument_list|()
decl_stmt|;
specifier|final
name|BlockInfo
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|reportedBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
comment|// Check if the replica is in the blockMap, if not
comment|// ignore the request for now. This could happen when BlockScanner
comment|// thread of Datanode reports bad block before Block reports are sent
comment|// by the Datanode on startup
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* findAndMarkBlockAsCorrupt: {} not found"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return;
block|}
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot mark "
operator|+
name|blk
operator|+
literal|" as corrupt because datanode "
operator|+
name|dn
operator|+
literal|" ("
operator|+
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
operator|+
literal|") does not exist"
argument_list|)
throw|;
block|}
name|DatanodeStorageInfo
name|storage
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|storageID
operator|!=
literal|null
condition|)
block|{
name|storage
operator|=
name|node
operator|.
name|getStorageInfo
argument_list|(
name|storageID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|storage
operator|==
literal|null
condition|)
block|{
name|storage
operator|=
name|storedBlock
operator|.
name|findStorageInfo
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|storage
operator|==
literal|null
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* findAndMarkBlockAsCorrupt: {} not found on {}"
argument_list|,
name|blk
argument_list|,
name|dn
argument_list|)
expr_stmt|;
return|return;
block|}
name|markBlockAsCorrupt
argument_list|(
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|reportedBlock
argument_list|,
name|storedBlock
argument_list|,
name|blk
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|reason
argument_list|,
name|Reason
operator|.
name|CORRUPTION_REPORTED
argument_list|)
argument_list|,
name|storage
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|/**    * Mark a replica (of a contiguous block) or an internal block (of a striped    * block group) as corrupt.    * @param b Indicating the reported bad block and the corresponding BlockInfo    *          stored in blocksMap.    * @param storageInfo storage that contains the block, if known. null otherwise.    */
DECL|method|markBlockAsCorrupt (BlockToMarkCorrupt b, DatanodeStorageInfo storageInfo, DatanodeDescriptor node)
specifier|private
name|void
name|markBlockAsCorrupt
parameter_list|(
name|BlockToMarkCorrupt
name|b
parameter_list|,
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|b
operator|.
name|getStored
argument_list|()
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK markBlockAsCorrupt: {} cannot be marked as"
operator|+
literal|" corrupt as it does not belong to any file"
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
name|b
operator|.
name|getCorrupted
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
name|short
name|expectedRedundancies
init|=
name|getExpectedRedundancyNum
argument_list|(
name|b
operator|.
name|getStored
argument_list|()
argument_list|)
decl_stmt|;
comment|// Add replica to the data-node if it is not already there
if|if
condition|(
name|storageInfo
operator|!=
literal|null
condition|)
block|{
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|b
operator|.
name|getStored
argument_list|()
argument_list|,
name|b
operator|.
name|getCorrupted
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Add this replica to corruptReplicas Map. For striped blocks, we always
comment|// use the id of whole striped block group when adding to corruptReplicas
name|Block
name|corrupted
init|=
operator|new
name|Block
argument_list|(
name|b
operator|.
name|getCorrupted
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|.
name|getStored
argument_list|()
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|corrupted
operator|.
name|setBlockId
argument_list|(
name|b
operator|.
name|getStored
argument_list|()
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|corruptReplicas
operator|.
name|addToCorruptReplicasMap
argument_list|(
name|corrupted
argument_list|,
name|node
argument_list|,
name|b
operator|.
name|getReason
argument_list|()
argument_list|,
name|b
operator|.
name|getReasonCode
argument_list|()
argument_list|,
name|b
operator|.
name|getStored
argument_list|()
operator|.
name|isStriped
argument_list|()
argument_list|)
expr_stmt|;
name|NumberReplicas
name|numberOfReplicas
init|=
name|countNodes
argument_list|(
name|b
operator|.
name|getStored
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|hasEnoughLiveReplicas
init|=
name|numberOfReplicas
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|expectedRedundancies
decl_stmt|;
name|boolean
name|minReplicationSatisfied
init|=
name|hasMinStorage
argument_list|(
name|b
operator|.
name|getStored
argument_list|()
argument_list|,
name|numberOfReplicas
operator|.
name|liveReplicas
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|hasMoreCorruptReplicas
init|=
name|minReplicationSatisfied
operator|&&
operator|(
name|numberOfReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|numberOfReplicas
operator|.
name|corruptReplicas
argument_list|()
operator|)
operator|>
name|expectedRedundancies
decl_stmt|;
name|boolean
name|corruptedDuringWrite
init|=
name|minReplicationSatisfied
operator|&&
name|b
operator|.
name|isCorruptedDuringWrite
argument_list|()
decl_stmt|;
comment|// case 1: have enough number of live replicas
comment|// case 2: corrupted replicas + live replicas> Replication factor
comment|// case 3: Block is marked corrupt due to failure while writing. In this
comment|//         case genstamp will be different than that of valid block.
comment|// In all these cases we can delete the replica.
comment|// In case of 3, rbw block will be deleted and valid block can be replicated
if|if
condition|(
name|hasEnoughLiveReplicas
operator|||
name|hasMoreCorruptReplicas
operator|||
name|corruptedDuringWrite
condition|)
block|{
comment|// the block is over-replicated so invalidate the replicas immediately
name|invalidateBlock
argument_list|(
name|b
argument_list|,
name|node
argument_list|,
name|numberOfReplicas
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
comment|// add the block to neededReconstruction
name|updateNeededReconstructions
argument_list|(
name|b
operator|.
name|getStored
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Invalidates the given block on the given datanode.    * @return true if the block was successfully invalidated and no longer    * present in the BlocksMap    */
DECL|method|invalidateBlock (BlockToMarkCorrupt b, DatanodeInfo dn, NumberReplicas nr)
specifier|private
name|boolean
name|invalidateBlock
parameter_list|(
name|BlockToMarkCorrupt
name|b
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|,
name|NumberReplicas
name|nr
parameter_list|)
throws|throws
name|IOException
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* invalidateBlock: {} on {}"
argument_list|,
name|b
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot invalidate "
operator|+
name|b
operator|+
literal|" because datanode "
operator|+
name|dn
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
comment|// Check how many copies we have of the block
if|if
condition|(
name|nr
operator|.
name|replicasOnStaleNodes
argument_list|()
operator|>
literal|0
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* invalidateBlocks: postponing "
operator|+
literal|"invalidation of {} on {} because {} replica(s) are located on "
operator|+
literal|"nodes with potentially out-of-date block reports"
argument_list|,
name|b
argument_list|,
name|dn
argument_list|,
name|nr
operator|.
name|replicasOnStaleNodes
argument_list|()
argument_list|)
expr_stmt|;
name|postponeBlock
argument_list|(
name|b
operator|.
name|getCorrupted
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// we already checked the number of replicas in the caller of this
comment|// function and know there are enough live replicas, so we can delete it.
name|addToInvalidates
argument_list|(
name|b
operator|.
name|getCorrupted
argument_list|()
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|removeStoredBlock
argument_list|(
name|b
operator|.
name|getStored
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* invalidateBlocks: {} on {} listed for deletion."
argument_list|,
name|b
argument_list|,
name|dn
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
DECL|method|setPostponeBlocksFromFuture (boolean postpone)
specifier|public
name|void
name|setPostponeBlocksFromFuture
parameter_list|(
name|boolean
name|postpone
parameter_list|)
block|{
name|this
operator|.
name|shouldPostponeBlocksFromFuture
operator|=
name|postpone
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|postponeBlock (Block blk)
name|void
name|postponeBlock
parameter_list|(
name|Block
name|blk
parameter_list|)
block|{
name|postponedMisreplicatedBlocks
operator|.
name|add
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
DECL|method|updateState ()
name|void
name|updateState
parameter_list|()
block|{
name|pendingReconstructionBlocksCount
operator|=
name|pendingReconstruction
operator|.
name|size
argument_list|()
expr_stmt|;
name|lowRedundancyBlocksCount
operator|=
name|neededReconstruction
operator|.
name|size
argument_list|()
expr_stmt|;
name|corruptReplicaBlocksCount
operator|=
name|corruptReplicas
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|/** Return number of low redundancy blocks but not missing blocks. */
DECL|method|getUnderReplicatedNotMissingBlocks ()
specifier|public
name|int
name|getUnderReplicatedNotMissingBlocks
parameter_list|()
block|{
return|return
name|neededReconstruction
operator|.
name|getLowRedundancyBlockCount
argument_list|()
return|;
block|}
comment|/**    * Schedule blocks for deletion at datanodes    * @param nodesToProcess number of datanodes to schedule deletion work    * @return total number of block for deletion    */
DECL|method|computeInvalidateWork (int nodesToProcess)
name|int
name|computeInvalidateWork
parameter_list|(
name|int
name|nodesToProcess
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|nodes
init|=
name|invalidateBlocks
operator|.
name|getDatanodes
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|nodesToProcess
operator|=
name|Math
operator|.
name|min
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|,
name|nodesToProcess
argument_list|)
expr_stmt|;
name|int
name|blockCnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeInfo
name|dnInfo
range|:
name|nodes
control|)
block|{
name|int
name|blocks
init|=
name|invalidateWorkForOneNode
argument_list|(
name|dnInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|>
literal|0
condition|)
block|{
name|blockCnt
operator|+=
name|blocks
expr_stmt|;
if|if
condition|(
operator|--
name|nodesToProcess
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|blockCnt
return|;
block|}
comment|/**    * Scan blocks in {@link #neededReconstruction} and assign reconstruction    * (replication or erasure coding) work to data-nodes they belong to.    *    * The number of process blocks equals either twice the number of live    * data-nodes or the number of low redundancy blocks whichever is less.    *    * @return number of blocks scheduled for reconstruction during this    *         iteration.    */
DECL|method|computeBlockReconstructionWork (int blocksToProcess)
name|int
name|computeBlockReconstructionWork
parameter_list|(
name|int
name|blocksToProcess
parameter_list|)
block|{
name|List
argument_list|<
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|blocksToReconstruct
init|=
literal|null
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Choose the blocks to be reconstructed
name|blocksToReconstruct
operator|=
name|neededReconstruction
operator|.
name|chooseLowRedundancyBlocks
argument_list|(
name|blocksToProcess
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
return|return
name|computeReconstructionWorkForBlocks
argument_list|(
name|blocksToReconstruct
argument_list|)
return|;
block|}
comment|/**    * Reconstruct a set of blocks to full strength through replication or    * erasure coding    *    * @param blocksToReconstruct blocks to be reconstructed, for each priority    * @return the number of blocks scheduled for replication    */
annotation|@
name|VisibleForTesting
DECL|method|computeReconstructionWorkForBlocks ( List<List<BlockInfo>> blocksToReconstruct)
name|int
name|computeReconstructionWorkForBlocks
parameter_list|(
name|List
argument_list|<
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|blocksToReconstruct
parameter_list|)
block|{
name|int
name|scheduledWork
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|BlockReconstructionWork
argument_list|>
name|reconWork
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Step 1: categorize at-risk blocks into replication and EC tasks
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|neededReconstruction
init|)
block|{
for|for
control|(
name|int
name|priority
init|=
literal|0
init|;
name|priority
operator|<
name|blocksToReconstruct
operator|.
name|size
argument_list|()
condition|;
name|priority
operator|++
control|)
block|{
for|for
control|(
name|BlockInfo
name|block
range|:
name|blocksToReconstruct
operator|.
name|get
argument_list|(
name|priority
argument_list|)
control|)
block|{
name|BlockReconstructionWork
name|rw
init|=
name|scheduleReconstruction
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
decl_stmt|;
if|if
condition|(
name|rw
operator|!=
literal|null
condition|)
block|{
name|reconWork
operator|.
name|add
argument_list|(
name|rw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|// Step 2: choose target nodes for each reconstruction task
for|for
control|(
name|BlockReconstructionWork
name|rw
range|:
name|reconWork
control|)
block|{
comment|// Exclude all of the containing nodes from being targets.
comment|// This list includes decommissioning or corrupt nodes.
specifier|final
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|rw
operator|.
name|getContainingNodes
argument_list|()
argument_list|)
decl_stmt|;
comment|// choose replication targets: NOT HOLDING THE GLOBAL LOCK
specifier|final
name|BlockPlacementPolicy
name|placementPolicy
init|=
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|rw
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockType
argument_list|()
argument_list|)
decl_stmt|;
name|rw
operator|.
name|chooseTargets
argument_list|(
name|placementPolicy
argument_list|,
name|storagePolicySuite
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
block|}
comment|// Step 3: add tasks to the DN
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|BlockReconstructionWork
name|rw
range|:
name|reconWork
control|)
block|{
specifier|final
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|rw
operator|.
name|getTargets
argument_list|()
decl_stmt|;
if|if
condition|(
name|targets
operator|==
literal|null
operator|||
name|targets
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|rw
operator|.
name|resetTargets
argument_list|()
expr_stmt|;
continue|continue;
block|}
synchronized|synchronized
init|(
name|neededReconstruction
init|)
block|{
if|if
condition|(
name|validateReconstructionWork
argument_list|(
name|rw
argument_list|)
condition|)
block|{
name|scheduledWork
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// log which blocks have been scheduled for reconstruction
for|for
control|(
name|BlockReconstructionWork
name|rw
range|:
name|reconWork
control|)
block|{
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|rw
operator|.
name|getTargets
argument_list|()
decl_stmt|;
if|if
condition|(
name|targets
operator|!=
literal|null
operator|&&
name|targets
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|StringBuilder
name|targetList
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"datanode(s)"
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|target
range|:
name|targets
control|)
block|{
name|targetList
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|target
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* ask {} to replicate {} to {}"
argument_list|,
name|rw
operator|.
name|getSrcNodes
argument_list|()
argument_list|,
name|rw
operator|.
name|getBlock
argument_list|()
argument_list|,
name|targetList
argument_list|)
expr_stmt|;
block|}
block|}
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* neededReconstruction = {} pendingReconstruction = {}"
argument_list|,
name|neededReconstruction
operator|.
name|size
argument_list|()
argument_list|,
name|pendingReconstruction
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|scheduledWork
return|;
block|}
comment|// Check if the number of live + pending replicas satisfies
comment|// the expected redundancy.
DECL|method|hasEnoughEffectiveReplicas (BlockInfo block, NumberReplicas numReplicas, int pendingReplicaNum)
name|boolean
name|hasEnoughEffectiveReplicas
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|NumberReplicas
name|numReplicas
parameter_list|,
name|int
name|pendingReplicaNum
parameter_list|)
block|{
name|int
name|required
init|=
name|getExpectedLiveRedundancyNum
argument_list|(
name|block
argument_list|,
name|numReplicas
argument_list|)
decl_stmt|;
name|int
name|numEffectiveReplicas
init|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|pendingReplicaNum
decl_stmt|;
return|return
operator|(
name|numEffectiveReplicas
operator|>=
name|required
operator|)
operator|&&
operator|(
name|pendingReplicaNum
operator|>
literal|0
operator|||
name|isPlacementPolicySatisfied
argument_list|(
name|block
argument_list|)
operator|)
return|;
block|}
DECL|method|scheduleReconstruction (BlockInfo block, int priority)
name|BlockReconstructionWork
name|scheduleReconstruction
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
comment|// skip abandoned block or block reopened for append
if|if
condition|(
name|block
operator|.
name|isDeleted
argument_list|()
operator|||
operator|!
name|block
operator|.
name|isCompleteOrCommitted
argument_list|()
condition|)
block|{
comment|// remove from neededReconstruction
name|neededReconstruction
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// get a source data-node
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|liveReplicaNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|NumberReplicas
name|numReplicas
init|=
operator|new
name|NumberReplicas
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Byte
argument_list|>
name|liveBlockIndices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|DatanodeDescriptor
index|[]
name|srcNodes
init|=
name|chooseSourceDatanodes
argument_list|(
name|block
argument_list|,
name|containingNodes
argument_list|,
name|liveReplicaNodes
argument_list|,
name|numReplicas
argument_list|,
name|liveBlockIndices
argument_list|,
name|priority
argument_list|)
decl_stmt|;
name|short
name|requiredRedundancy
init|=
name|getExpectedLiveRedundancyNum
argument_list|(
name|block
argument_list|,
name|numReplicas
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcNodes
operator|==
literal|null
operator|||
name|srcNodes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// block can not be reconstructed from any node
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block {} cannot be reconstructed from any node"
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|incNumTimesReReplicationNotScheduled
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// liveReplicaNodes can include READ_ONLY_SHARED replicas which are
comment|// not included in the numReplicas.liveReplicas() count
assert|assert
name|liveReplicaNodes
operator|.
name|size
argument_list|()
operator|>=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
assert|;
name|int
name|pendingNum
init|=
name|pendingReconstruction
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasEnoughEffectiveReplicas
argument_list|(
name|block
argument_list|,
name|numReplicas
argument_list|,
name|pendingNum
argument_list|)
condition|)
block|{
name|neededReconstruction
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* Removing {} from neededReconstruction as"
operator|+
literal|" it has enough replicas"
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|incNumTimesReReplicationNotScheduled
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|int
name|additionalReplRequired
decl_stmt|;
if|if
condition|(
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|<
name|requiredRedundancy
condition|)
block|{
name|additionalReplRequired
operator|=
name|requiredRedundancy
operator|-
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|-
name|pendingNum
expr_stmt|;
block|}
else|else
block|{
name|additionalReplRequired
operator|=
literal|1
expr_stmt|;
comment|// Needed on a new rack
block|}
specifier|final
name|BlockCollection
name|bc
init|=
name|getBlockCollection
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|isStriped
argument_list|()
condition|)
block|{
if|if
condition|(
name|pendingNum
operator|>
literal|0
condition|)
block|{
comment|// Wait the previous reconstruction to finish.
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|incNumTimesReReplicationNotScheduled
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// should reconstruct all the internal blocks before scheduling
comment|// replication task for decommissioning node(s).
if|if
condition|(
name|additionalReplRequired
operator|-
name|numReplicas
operator|.
name|decommissioning
argument_list|()
operator|-
name|numReplicas
operator|.
name|liveEnteringMaintenanceReplicas
argument_list|()
operator|>
literal|0
condition|)
block|{
name|additionalReplRequired
operator|=
name|additionalReplRequired
operator|-
name|numReplicas
operator|.
name|decommissioning
argument_list|()
operator|-
name|numReplicas
operator|.
name|liveEnteringMaintenanceReplicas
argument_list|()
expr_stmt|;
block|}
name|byte
index|[]
name|indices
init|=
operator|new
name|byte
index|[
name|liveBlockIndices
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|liveBlockIndices
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|indices
index|[
name|i
index|]
operator|=
name|liveBlockIndices
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ErasureCodingWork
argument_list|(
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
argument_list|,
name|bc
argument_list|,
name|srcNodes
argument_list|,
name|containingNodes
argument_list|,
name|liveReplicaNodes
argument_list|,
name|additionalReplRequired
argument_list|,
name|priority
argument_list|,
name|indices
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ReplicationWork
argument_list|(
name|block
argument_list|,
name|bc
argument_list|,
name|srcNodes
argument_list|,
name|containingNodes
argument_list|,
name|liveReplicaNodes
argument_list|,
name|additionalReplRequired
argument_list|,
name|priority
argument_list|)
return|;
block|}
block|}
DECL|method|isInNewRack (DatanodeDescriptor[] srcs, DatanodeDescriptor target)
specifier|private
name|boolean
name|isInNewRack
parameter_list|(
name|DatanodeDescriptor
index|[]
name|srcs
parameter_list|,
name|DatanodeDescriptor
name|target
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"check if target {} increases racks, srcs={}"
argument_list|,
name|target
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|srcs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|src
range|:
name|srcs
control|)
block|{
if|if
condition|(
operator|!
name|src
operator|.
name|isDecommissionInProgress
argument_list|()
operator|&&
name|src
operator|.
name|getNetworkLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"the target {} is in the same rack with src {}"
argument_list|,
name|target
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|validateReconstructionWork (BlockReconstructionWork rw)
specifier|private
name|boolean
name|validateReconstructionWork
parameter_list|(
name|BlockReconstructionWork
name|rw
parameter_list|)
block|{
name|BlockInfo
name|block
init|=
name|rw
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|int
name|priority
init|=
name|rw
operator|.
name|getPriority
argument_list|()
decl_stmt|;
comment|// Recheck since global lock was released
comment|// skip abandoned block or block reopened for append
if|if
condition|(
name|block
operator|.
name|isDeleted
argument_list|()
operator|||
operator|!
name|block
operator|.
name|isCompleteOrCommitted
argument_list|()
condition|)
block|{
name|neededReconstruction
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|rw
operator|.
name|resetTargets
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// do not schedule more if enough replicas is already pending
name|NumberReplicas
name|numReplicas
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|final
name|short
name|requiredRedundancy
init|=
name|getExpectedLiveRedundancyNum
argument_list|(
name|block
argument_list|,
name|numReplicas
argument_list|)
decl_stmt|;
specifier|final
name|int
name|pendingNum
init|=
name|pendingReconstruction
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasEnoughEffectiveReplicas
argument_list|(
name|block
argument_list|,
name|numReplicas
argument_list|,
name|pendingNum
argument_list|)
condition|)
block|{
name|neededReconstruction
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|rw
operator|.
name|resetTargets
argument_list|()
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* Removing {} from neededReconstruction as"
operator|+
literal|" it has enough replicas"
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|rw
operator|.
name|getTargets
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|requiredRedundancy
operator|)
operator|&&
operator|(
operator|!
name|isPlacementPolicySatisfied
argument_list|(
name|block
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|isInNewRack
argument_list|(
name|rw
operator|.
name|getSrcNodes
argument_list|()
argument_list|,
name|targets
index|[
literal|0
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
condition|)
block|{
comment|// No use continuing, unless a new rack in this case
return|return
literal|false
return|;
block|}
comment|// mark that the reconstruction work is to replicate internal block to a
comment|// new rack.
name|rw
operator|.
name|setNotEnoughRack
argument_list|()
expr_stmt|;
block|}
comment|// Add block to the datanode's task list
name|rw
operator|.
name|addTaskToDatanode
argument_list|(
name|numReplicas
argument_list|)
expr_stmt|;
name|DatanodeStorageInfo
operator|.
name|incrementBlocksScheduled
argument_list|(
name|targets
argument_list|)
expr_stmt|;
comment|// Move the block-replication into a "pending" state.
comment|// The reason we use 'pending' is so we can retry
comment|// reconstructions that fail after an appropriate amount of time.
name|pendingReconstruction
operator|.
name|increment
argument_list|(
name|block
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toDatanodeDescriptors
argument_list|(
name|targets
argument_list|)
argument_list|)
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* block {} is moved from neededReconstruction to "
operator|+
literal|"pendingReconstruction"
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|int
name|numEffectiveReplicas
init|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|pendingNum
decl_stmt|;
comment|// remove from neededReconstruction
if|if
condition|(
name|numEffectiveReplicas
operator|+
name|targets
operator|.
name|length
operator|>=
name|requiredRedundancy
condition|)
block|{
name|neededReconstruction
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Choose target for WebHDFS redirection. */
DECL|method|chooseTarget4WebHDFS (String src, DatanodeDescriptor clientnode, Set<Node> excludes, long blocksize)
specifier|public
name|DatanodeStorageInfo
index|[]
name|chooseTarget4WebHDFS
parameter_list|(
name|String
name|src
parameter_list|,
name|DatanodeDescriptor
name|clientnode
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludes
parameter_list|,
name|long
name|blocksize
parameter_list|)
block|{
return|return
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|CONTIGUOUS
argument_list|)
operator|.
name|chooseTarget
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
name|clientnode
argument_list|,
name|Collections
operator|.
expr|<
name|DatanodeStorageInfo
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|false
argument_list|,
name|excludes
argument_list|,
name|blocksize
argument_list|,
name|storagePolicySuite
operator|.
name|getDefaultPolicy
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Choose target for getting additional datanodes for an existing pipeline. */
DECL|method|chooseTarget4AdditionalDatanode (String src, int numAdditionalNodes, Node clientnode, List<DatanodeStorageInfo> chosen, Set<Node> excludes, long blocksize, byte storagePolicyID, BlockType blockType)
specifier|public
name|DatanodeStorageInfo
index|[]
name|chooseTarget4AdditionalDatanode
parameter_list|(
name|String
name|src
parameter_list|,
name|int
name|numAdditionalNodes
parameter_list|,
name|Node
name|clientnode
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|chosen
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|byte
name|storagePolicyID
parameter_list|,
name|BlockType
name|blockType
parameter_list|)
block|{
specifier|final
name|BlockStoragePolicy
name|storagePolicy
init|=
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|storagePolicyID
argument_list|)
decl_stmt|;
specifier|final
name|BlockPlacementPolicy
name|blockplacement
init|=
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|blockType
argument_list|)
decl_stmt|;
return|return
name|blockplacement
operator|.
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|numAdditionalNodes
argument_list|,
name|clientnode
argument_list|,
name|chosen
argument_list|,
literal|true
argument_list|,
name|excludes
argument_list|,
name|blocksize
argument_list|,
name|storagePolicy
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Choose target datanodes for creating a new block.    *     * @throws IOException    *           if the number of targets {@literal<} minimum replication.    * @see BlockPlacementPolicy#chooseTarget(String, int, Node,    *      Set, long, List, BlockStoragePolicy, EnumSet)    */
DECL|method|chooseTarget4NewBlock (final String src, final int numOfReplicas, final Node client, final Set<Node> excludedNodes, final long blocksize, final List<String> favoredNodes, final byte storagePolicyID, final BlockType blockType, final ErasureCodingPolicy ecPolicy, final EnumSet<AddBlockFlag> flags)
specifier|public
name|DatanodeStorageInfo
index|[]
name|chooseTarget4NewBlock
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|int
name|numOfReplicas
parameter_list|,
specifier|final
name|Node
name|client
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
specifier|final
name|long
name|blocksize
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|favoredNodes
parameter_list|,
specifier|final
name|byte
name|storagePolicyID
parameter_list|,
specifier|final
name|BlockType
name|blockType
parameter_list|,
specifier|final
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|AddBlockFlag
argument_list|>
name|flags
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|favoredDatanodeDescriptors
init|=
name|getDatanodeDescriptors
argument_list|(
name|favoredNodes
argument_list|)
decl_stmt|;
specifier|final
name|BlockStoragePolicy
name|storagePolicy
init|=
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|storagePolicyID
argument_list|)
decl_stmt|;
specifier|final
name|BlockPlacementPolicy
name|blockplacement
init|=
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|blockType
argument_list|)
decl_stmt|;
specifier|final
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|blockplacement
operator|.
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|numOfReplicas
argument_list|,
name|client
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|favoredDatanodeDescriptors
argument_list|,
name|storagePolicy
argument_list|,
name|flags
argument_list|)
decl_stmt|;
specifier|final
name|String
name|errorMessage
init|=
literal|"File %s could only be written to %d of "
operator|+
literal|"the %d %s. There are %d datanode(s) running and %s "
operator|+
literal|"node(s) are excluded in this operation."
decl_stmt|;
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|CONTIGUOUS
operator|&&
name|targets
operator|.
name|length
operator|<
name|minReplication
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|errorMessage
argument_list|,
name|src
argument_list|,
name|targets
operator|.
name|length
argument_list|,
name|minReplication
argument_list|,
literal|"minReplication nodes"
argument_list|,
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
operator|.
name|getNumOfLeaves
argument_list|()
argument_list|,
operator|(
name|excludedNodes
operator|==
literal|null
condition|?
literal|"no"
else|:
name|excludedNodes
operator|.
name|size
argument_list|()
operator|)
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|STRIPED
operator|&&
name|targets
operator|.
name|length
operator|<
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|errorMessage
argument_list|,
name|src
argument_list|,
name|targets
operator|.
name|length
argument_list|,
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"required nodes for %s"
argument_list|,
name|ecPolicy
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
operator|.
name|getNumOfLeaves
argument_list|()
argument_list|,
operator|(
name|excludedNodes
operator|==
literal|null
condition|?
literal|"no"
else|:
name|excludedNodes
operator|.
name|size
argument_list|()
operator|)
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|targets
return|;
block|}
comment|/**    * Get list of datanode descriptors for given list of nodes. Nodes are    * hostaddress:port or just hostaddress.    */
DECL|method|getDatanodeDescriptors (List<String> nodes)
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|getDatanodeDescriptors
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nodes
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|datanodeDescriptors
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
name|datanodeDescriptors
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|datanodeManager
operator|.
name|getDatanodeDescriptor
argument_list|(
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|datanodeDescriptors
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|datanodeDescriptors
return|;
block|}
comment|/**    * Get the associated {@link DatanodeDescriptor} for the storage.    * If the storage is of type PROVIDED, one of the nodes that reported    * PROVIDED storage are returned. If not, this is equivalent to    * {@code storage.getDatanodeDescriptor()}.    * @param storage    * @return the associated {@link DatanodeDescriptor}.    */
DECL|method|getDatanodeDescriptorFromStorage ( DatanodeStorageInfo storage)
specifier|private
name|DatanodeDescriptor
name|getDatanodeDescriptorFromStorage
parameter_list|(
name|DatanodeStorageInfo
name|storage
parameter_list|)
block|{
if|if
condition|(
name|storage
operator|.
name|getStorageType
argument_list|()
operator|==
name|StorageType
operator|.
name|PROVIDED
condition|)
block|{
return|return
name|providedStorageMap
operator|.
name|chooseProvidedDatanode
argument_list|()
return|;
block|}
return|return
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
return|;
block|}
comment|/**    * Parse the data-nodes the block belongs to and choose a certain number    * from them to be the recovery sources.    *    * We prefer nodes that are in DECOMMISSION_INPROGRESS state to other nodes    * since the former do not have write traffic and hence are less busy.    * We do not use already decommissioned nodes as a source, unless there is    * no other choice.    * Otherwise we randomly choose nodes among those that did not reach their    * replication limits. However, if the recovery work is of the highest    * priority and all nodes have reached their replication limits, we will    * randomly choose the desired number of nodes despite the replication limit.    *    * In addition form a list of all nodes containing the block    * and calculate its replication numbers.    *    * @param block Block for which a replication source is needed    * @param containingNodes List to be populated with nodes found to contain    *                        the given block    * @param nodesContainingLiveReplicas List to be populated with nodes found    *                                    to contain live replicas of the given    *                                    block    * @param numReplicas NumberReplicas instance to be initialized with the    *                    counts of live, corrupt, excess, and decommissioned    *                    replicas of the given block.    * @param liveBlockIndices List to be populated with indices of healthy    *                         blocks in a striped block group    * @param priority integer representing replication priority of the given    *                 block    * @return the array of DatanodeDescriptor of the chosen nodes from which to    *         recover the given block    */
annotation|@
name|VisibleForTesting
DECL|method|chooseSourceDatanodes (BlockInfo block, List<DatanodeDescriptor> containingNodes, List<DatanodeStorageInfo> nodesContainingLiveReplicas, NumberReplicas numReplicas, List<Byte> liveBlockIndices, int priority)
name|DatanodeDescriptor
index|[]
name|chooseSourceDatanodes
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|nodesContainingLiveReplicas
parameter_list|,
name|NumberReplicas
name|numReplicas
parameter_list|,
name|List
argument_list|<
name|Byte
argument_list|>
name|liveBlockIndices
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|containingNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nodesContainingLiveReplicas
operator|.
name|clear
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|srcNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|liveBlockIndices
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|final
name|boolean
name|isStriped
init|=
name|block
operator|.
name|isStriped
argument_list|()
decl_stmt|;
name|DatanodeDescriptor
name|decommissionedSrc
init|=
literal|null
decl_stmt|;
name|BitSet
name|bitSet
init|=
name|isStriped
condition|?
operator|new
name|BitSet
argument_list|(
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|block
operator|)
operator|.
name|getTotalBlockNum
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeDescriptorFromStorage
argument_list|(
name|storage
argument_list|)
decl_stmt|;
specifier|final
name|StoredReplicaState
name|state
init|=
name|checkReplicaOnStorage
argument_list|(
name|numReplicas
argument_list|,
name|block
argument_list|,
name|storage
argument_list|,
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|StoredReplicaState
operator|.
name|LIVE
condition|)
block|{
if|if
condition|(
name|storage
operator|.
name|getStorageType
argument_list|()
operator|==
name|StorageType
operator|.
name|PROVIDED
condition|)
block|{
name|storage
operator|=
operator|new
name|DatanodeStorageInfo
argument_list|(
name|node
argument_list|,
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|storage
operator|.
name|getStorageType
argument_list|()
argument_list|,
name|storage
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodesContainingLiveReplicas
operator|.
name|add
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
name|containingNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// do not select the replica if it is corrupt or excess
if|if
condition|(
name|state
operator|==
name|StoredReplicaState
operator|.
name|CORRUPT
operator|||
name|state
operator|==
name|StoredReplicaState
operator|.
name|EXCESS
condition|)
block|{
continue|continue;
block|}
comment|// Never use maintenance node not suitable for read
comment|// or unknown state replicas.
if|if
condition|(
name|state
operator|==
literal|null
operator|||
name|state
operator|==
name|StoredReplicaState
operator|.
name|MAINTENANCE_NOT_FOR_READ
condition|)
block|{
continue|continue;
block|}
comment|// Save the live decommissioned replica in case we need it. Such replicas
comment|// are normally not used for replication, but if nothing else is
comment|// available, one can be selected as a source.
if|if
condition|(
name|state
operator|==
name|StoredReplicaState
operator|.
name|DECOMMISSIONED
condition|)
block|{
if|if
condition|(
name|decommissionedSrc
operator|==
literal|null
operator|||
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|decommissionedSrc
operator|=
name|node
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|priority
operator|!=
name|LowRedundancyBlocks
operator|.
name|QUEUE_HIGHEST_PRIORITY
operator|&&
operator|(
operator|!
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|node
operator|.
name|isEnteringMaintenance
argument_list|()
operator|)
operator|&&
name|node
operator|.
name|getNumberOfBlocksToBeReplicated
argument_list|()
operator|>=
name|maxReplicationStreams
condition|)
block|{
continue|continue;
comment|// already reached replication limit
block|}
if|if
condition|(
name|node
operator|.
name|getNumberOfBlocksToBeReplicated
argument_list|()
operator|>=
name|replicationStreamsHardLimit
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|isStriped
operator|||
name|srcNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|srcNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|isStriped
condition|)
block|{
name|byte
name|blockIndex
init|=
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|block
operator|)
operator|.
name|getStorageBlockIndex
argument_list|(
name|storage
argument_list|)
decl_stmt|;
name|liveBlockIndices
operator|.
name|add
argument_list|(
name|blockIndex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitSet
operator|.
name|get
argument_list|(
name|blockIndex
argument_list|)
condition|)
block|{
name|bitSet
operator|.
name|set
argument_list|(
name|blockIndex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|StoredReplicaState
operator|.
name|LIVE
condition|)
block|{
name|numReplicas
operator|.
name|subtract
argument_list|(
name|StoredReplicaState
operator|.
name|LIVE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|numReplicas
operator|.
name|add
argument_list|(
name|StoredReplicaState
operator|.
name|REDUNDANT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|// for replicated block, switch to a different node randomly
comment|// this to prevent from deterministically selecting the same node even
comment|// if the node failed to replicate the block on previous iterations
if|if
condition|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
block|{
name|srcNodes
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Pick a live decommissioned replica, if nothing else is available.
if|if
condition|(
operator|!
name|isStriped
operator|&&
name|nodesContainingLiveReplicas
operator|.
name|isEmpty
argument_list|()
operator|&&
name|srcNodes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|decommissionedSrc
operator|!=
literal|null
condition|)
block|{
name|srcNodes
operator|.
name|add
argument_list|(
name|decommissionedSrc
argument_list|)
expr_stmt|;
block|}
return|return
name|srcNodes
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeDescriptor
index|[
name|srcNodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * If there were any reconstruction requests that timed out, reap them    * and put them back into the neededReconstruction queue    */
DECL|method|processPendingReconstructions ()
name|void
name|processPendingReconstructions
parameter_list|()
block|{
name|BlockInfo
index|[]
name|timedOutItems
init|=
name|pendingReconstruction
operator|.
name|getTimedOutBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|timedOutItems
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|timedOutItems
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/*            * Use the blockinfo from the blocksmap to be certain we're working            * with the most up-to-date block information (e.g. genstamp).            */
name|BlockInfo
name|bi
init|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|bi
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNeededReconstruction
argument_list|(
name|bi
argument_list|,
name|num
argument_list|)
condition|)
block|{
name|neededReconstruction
operator|.
name|add
argument_list|(
name|bi
argument_list|,
name|num
operator|.
name|liveReplicas
argument_list|()
argument_list|,
name|num
operator|.
name|readOnlyReplicas
argument_list|()
argument_list|,
name|num
operator|.
name|outOfServiceReplicas
argument_list|()
argument_list|,
name|getExpectedRedundancyNum
argument_list|(
name|bi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|/* If we know the target datanodes where the replication timedout,        * we could invoke decBlocksScheduled() on it. Its ok for now.        */
block|}
block|}
DECL|method|requestBlockReportLeaseId (DatanodeRegistration nodeReg)
specifier|public
name|long
name|requestBlockReportLeaseId
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasReadLock
argument_list|()
assert|;
name|DatanodeDescriptor
name|node
init|=
literal|null
decl_stmt|;
try|try
block|{
name|node
operator|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnregisteredNodeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unregistered datanode {}"
argument_list|,
name|nodeReg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to find datanode {}"
argument_list|,
name|nodeReg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// Request a new block report lease.  The BlockReportLeaseManager has
comment|// its own internal locking.
name|long
name|leaseId
init|=
name|blockReportLeaseManager
operator|.
name|requestLease
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|BlockManagerFaultInjector
operator|.
name|getInstance
argument_list|()
operator|.
name|requestBlockReportLease
argument_list|(
name|node
argument_list|,
name|leaseId
argument_list|)
expr_stmt|;
return|return
name|leaseId
return|;
block|}
DECL|method|registerDatanode (DatanodeRegistration nodeReg)
specifier|public
name|void
name|registerDatanode
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|datanodeManager
operator|.
name|registerDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
comment|/**    * Set the total number of blocks in the system.    * If safe mode is not currently on, this is a no-op.    */
DECL|method|setBlockTotal (long total)
specifier|public
name|void
name|setBlockTotal
parameter_list|(
name|long
name|total
parameter_list|)
block|{
if|if
condition|(
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
name|bmSafeMode
operator|.
name|setBlockTotal
argument_list|(
name|total
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|isInSafeMode ()
specifier|public
name|boolean
name|isInSafeMode
parameter_list|()
block|{
return|return
name|bmSafeMode
operator|.
name|isInSafeMode
argument_list|()
return|;
block|}
DECL|method|getSafeModeTip ()
specifier|public
name|String
name|getSafeModeTip
parameter_list|()
block|{
return|return
name|bmSafeMode
operator|.
name|getSafeModeTip
argument_list|()
return|;
block|}
DECL|method|leaveSafeMode (boolean force)
specifier|public
name|boolean
name|leaveSafeMode
parameter_list|(
name|boolean
name|force
parameter_list|)
block|{
return|return
name|bmSafeMode
operator|.
name|leaveSafeMode
argument_list|(
name|force
argument_list|)
return|;
block|}
DECL|method|checkSafeMode ()
specifier|public
name|void
name|checkSafeMode
parameter_list|()
block|{
name|bmSafeMode
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
DECL|method|getBytesInFuture ()
specifier|public
name|long
name|getBytesInFuture
parameter_list|()
block|{
return|return
name|bmSafeMode
operator|.
name|getBytesInFuture
argument_list|()
return|;
block|}
DECL|method|getBytesInFutureReplicatedBlocks ()
specifier|public
name|long
name|getBytesInFutureReplicatedBlocks
parameter_list|()
block|{
return|return
name|bmSafeMode
operator|.
name|getBytesInFutureBlocks
argument_list|()
return|;
block|}
DECL|method|getBytesInFutureECBlockGroups ()
specifier|public
name|long
name|getBytesInFutureECBlockGroups
parameter_list|()
block|{
return|return
name|bmSafeMode
operator|.
name|getBytesInFutureECBlockGroups
argument_list|()
return|;
block|}
comment|/**    * Removes the blocks from blocksmap and updates the safemode blocks total.    * @param blocks An instance of {@link BlocksMapUpdateInfo} which contains a    *               list of blocks that need to be removed from blocksMap    */
DECL|method|removeBlocksAndUpdateSafemodeTotal (BlocksMapUpdateInfo blocks)
specifier|public
name|void
name|removeBlocksAndUpdateSafemodeTotal
parameter_list|(
name|BlocksMapUpdateInfo
name|blocks
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
comment|// In the case that we are a Standby tailing edits from the
comment|// active while in safe-mode, we need to track the total number
comment|// of blocks and safe blocks in the system.
name|boolean
name|trackBlockCounts
init|=
name|bmSafeMode
operator|.
name|isSafeModeTrackingBlocks
argument_list|()
decl_stmt|;
name|int
name|numRemovedComplete
init|=
literal|0
decl_stmt|,
name|numRemovedSafe
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
operator|.
name|getToDeleteList
argument_list|()
control|)
block|{
if|if
condition|(
name|trackBlockCounts
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|numRemovedComplete
operator|++
expr_stmt|;
if|if
condition|(
name|hasMinStorage
argument_list|(
name|b
argument_list|,
name|b
operator|.
name|numNodes
argument_list|()
argument_list|)
condition|)
block|{
name|numRemovedSafe
operator|++
expr_stmt|;
block|}
block|}
block|}
name|removeBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trackBlockCounts
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adjusting safe-mode totals for deletion."
operator|+
literal|"decreasing safeBlocks by {}, totalBlocks by {}"
argument_list|,
name|numRemovedSafe
argument_list|,
name|numRemovedComplete
argument_list|)
expr_stmt|;
name|bmSafeMode
operator|.
name|adjustBlockTotals
argument_list|(
operator|-
name|numRemovedSafe
argument_list|,
operator|-
name|numRemovedComplete
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getProvidedCapacity ()
specifier|public
name|long
name|getProvidedCapacity
parameter_list|()
block|{
return|return
name|providedStorageMap
operator|.
name|getCapacity
argument_list|()
return|;
block|}
DECL|method|updateHeartbeat (DatanodeDescriptor node, StorageReport[] reports, long cacheCapacity, long cacheUsed, int xceiverCount, int failedVolumes, VolumeFailureSummary volumeFailureSummary)
name|void
name|updateHeartbeat
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|,
name|StorageReport
index|[]
name|reports
parameter_list|,
name|long
name|cacheCapacity
parameter_list|,
name|long
name|cacheUsed
parameter_list|,
name|int
name|xceiverCount
parameter_list|,
name|int
name|failedVolumes
parameter_list|,
name|VolumeFailureSummary
name|volumeFailureSummary
parameter_list|)
block|{
for|for
control|(
name|StorageReport
name|report
range|:
name|reports
control|)
block|{
name|providedStorageMap
operator|.
name|updateStorage
argument_list|(
name|node
argument_list|,
name|report
operator|.
name|getStorage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|updateHeartbeat
argument_list|(
name|reports
argument_list|,
name|cacheCapacity
argument_list|,
name|cacheUsed
argument_list|,
name|xceiverCount
argument_list|,
name|failedVolumes
argument_list|,
name|volumeFailureSummary
argument_list|)
expr_stmt|;
block|}
DECL|method|updateHeartbeatState (DatanodeDescriptor node, StorageReport[] reports, long cacheCapacity, long cacheUsed, int xceiverCount, int failedVolumes, VolumeFailureSummary volumeFailureSummary)
name|void
name|updateHeartbeatState
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|,
name|StorageReport
index|[]
name|reports
parameter_list|,
name|long
name|cacheCapacity
parameter_list|,
name|long
name|cacheUsed
parameter_list|,
name|int
name|xceiverCount
parameter_list|,
name|int
name|failedVolumes
parameter_list|,
name|VolumeFailureSummary
name|volumeFailureSummary
parameter_list|)
block|{
for|for
control|(
name|StorageReport
name|report
range|:
name|reports
control|)
block|{
name|providedStorageMap
operator|.
name|updateStorage
argument_list|(
name|node
argument_list|,
name|report
operator|.
name|getStorage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|updateHeartbeatState
argument_list|(
name|reports
argument_list|,
name|cacheCapacity
argument_list|,
name|cacheUsed
argument_list|,
name|xceiverCount
argument_list|,
name|failedVolumes
argument_list|,
name|volumeFailureSummary
argument_list|)
expr_stmt|;
block|}
comment|/**    * StatefulBlockInfo is used to build the "toUC" list, which is a list of    * updates to the information about under-construction blocks.    * Besides the block in question, it provides the ReplicaState    * reported by the datanode in the block report.     */
DECL|class|StatefulBlockInfo
specifier|static
class|class
name|StatefulBlockInfo
block|{
DECL|field|storedBlock
specifier|final
name|BlockInfo
name|storedBlock
decl_stmt|;
comment|// should be UC block
DECL|field|reportedBlock
specifier|final
name|Block
name|reportedBlock
decl_stmt|;
DECL|field|reportedState
specifier|final
name|ReplicaState
name|reportedState
decl_stmt|;
DECL|method|StatefulBlockInfo (BlockInfo storedBlock, Block reportedBlock, ReplicaState reportedState)
name|StatefulBlockInfo
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|Block
name|reportedBlock
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|storedBlock
operator|.
name|isComplete
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|storedBlock
operator|=
name|storedBlock
expr_stmt|;
name|this
operator|.
name|reportedBlock
operator|=
name|reportedBlock
expr_stmt|;
name|this
operator|.
name|reportedState
operator|=
name|reportedState
expr_stmt|;
block|}
block|}
DECL|class|BlockInfoToAdd
specifier|private
specifier|static
class|class
name|BlockInfoToAdd
block|{
DECL|field|stored
specifier|final
name|BlockInfo
name|stored
decl_stmt|;
DECL|field|reported
specifier|final
name|Block
name|reported
decl_stmt|;
DECL|method|BlockInfoToAdd (BlockInfo stored, Block reported)
name|BlockInfoToAdd
parameter_list|(
name|BlockInfo
name|stored
parameter_list|,
name|Block
name|reported
parameter_list|)
block|{
name|this
operator|.
name|stored
operator|=
name|stored
expr_stmt|;
name|this
operator|.
name|reported
operator|=
name|reported
expr_stmt|;
block|}
block|}
comment|/**    * The given storage is reporting all its blocks.    * Update the (storage{@literal -->}block list) and    * (block{@literal -->}storage list) maps.    *    * @return true if all known storages of the given DN have finished reporting.    * @throws IOException    */
DECL|method|processReport (final DatanodeID nodeID, final DatanodeStorage storage, final BlockListAsLongs newReport, BlockReportContext context)
specifier|public
name|boolean
name|processReport
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|,
specifier|final
name|DatanodeStorage
name|storage
parameter_list|,
specifier|final
name|BlockListAsLongs
name|newReport
parameter_list|,
name|BlockReportContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
specifier|final
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|//after acquiring write lock
specifier|final
name|long
name|endTime
decl_stmt|;
name|DatanodeDescriptor
name|node
decl_stmt|;
name|Collection
argument_list|<
name|Block
argument_list|>
name|invalidatedBlocks
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
name|String
name|strBlockReportId
init|=
name|context
operator|!=
literal|null
condition|?
name|Long
operator|.
name|toHexString
argument_list|(
name|context
operator|.
name|getReportId
argument_list|()
argument_list|)
else|:
literal|""
decl_stmt|;
try|try
block|{
name|node
operator|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|nodeID
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|||
operator|!
name|node
operator|.
name|isRegistered
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ProcessReport from dead or unregistered node: "
operator|+
name|nodeID
argument_list|)
throw|;
block|}
comment|// To minimize startup time, we discard any second (or later) block reports
comment|// that we receive while still in startup phase.
comment|// Register DN with provided storage, not with storage owned by DN
comment|// DN should still have a ref to the DNStorageInfo.
name|DatanodeStorageInfo
name|storageInfo
init|=
name|providedStorageMap
operator|.
name|getStorage
argument_list|(
name|node
argument_list|,
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageInfo
operator|==
literal|null
condition|)
block|{
comment|// We handle this for backwards compatibility.
name|storageInfo
operator|=
name|node
operator|.
name|updateStorage
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namesystem
operator|.
name|isInStartupSafeMode
argument_list|()
operator|&&
name|storageInfo
operator|.
name|getBlockReportCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport 0x{}: "
operator|+
literal|"discarded non-initial block report from {}"
operator|+
literal|" because namenode still in startup phase"
argument_list|,
name|strBlockReportId
argument_list|,
name|nodeID
argument_list|)
expr_stmt|;
name|blockReportLeaseManager
operator|.
name|removeLease
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|!
name|node
operator|.
name|hasStaleStorages
argument_list|()
return|;
block|}
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|blockReportLeaseManager
operator|.
name|checkLease
argument_list|(
name|node
argument_list|,
name|startTime
argument_list|,
name|context
operator|.
name|getLeaseId
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|storageInfo
operator|.
name|getBlockReportCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// The first block report can be processed a lot more efficiently than
comment|// ordinary block reports.  This shortens restart times.
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport 0x{}: Processing first "
operator|+
literal|"storage report for {} from datanode {}"
argument_list|,
name|strBlockReportId
argument_list|,
name|storageInfo
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|nodeID
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
name|processFirstBlockReport
argument_list|(
name|storageInfo
argument_list|,
name|newReport
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Block reports for provided storage are not
comment|// maintained by DN heartbeats
if|if
condition|(
operator|!
name|StorageType
operator|.
name|PROVIDED
operator|.
name|equals
argument_list|(
name|storageInfo
operator|.
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
name|invalidatedBlocks
operator|=
name|processReport
argument_list|(
name|storageInfo
argument_list|,
name|newReport
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
name|storageInfo
operator|.
name|receivedBlockReport
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|endTime
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
expr_stmt|;
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Block
name|b
range|:
name|invalidatedBlocks
control|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* processReport 0x{}: {} on node {} size {} does not"
operator|+
literal|" belong to any file"
argument_list|,
name|strBlockReportId
argument_list|,
name|b
argument_list|,
name|node
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Log the block report processing stats from Namenode perspective
specifier|final
name|NameNodeMetrics
name|metrics
init|=
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addStorageBlockReport
argument_list|(
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport 0x{}: from storage {} node {}, "
operator|+
literal|"blocks: {}, hasStaleStorage: {}, processing time: {} msecs, "
operator|+
literal|"invalidatedBlocks: {}"
argument_list|,
name|strBlockReportId
argument_list|,
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|nodeID
argument_list|,
name|newReport
operator|.
name|getNumberOfBlocks
argument_list|()
argument_list|,
name|node
operator|.
name|hasStaleStorages
argument_list|()
argument_list|,
operator|(
name|endTime
operator|-
name|startTime
operator|)
argument_list|,
name|invalidatedBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|!
name|node
operator|.
name|hasStaleStorages
argument_list|()
return|;
block|}
DECL|method|removeBRLeaseIfNeeded (final DatanodeID nodeID, final BlockReportContext context)
specifier|public
name|void
name|removeBRLeaseIfNeeded
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|,
specifier|final
name|BlockReportContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|DatanodeDescriptor
name|node
decl_stmt|;
try|try
block|{
name|node
operator|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|nodeID
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|getTotalRpcs
argument_list|()
operator|==
name|context
operator|.
name|getCurRpc
argument_list|()
operator|+
literal|1
condition|)
block|{
name|long
name|leaseId
init|=
name|this
operator|.
name|getBlockReportLeaseManager
argument_list|()
operator|.
name|removeLease
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|BlockManagerFaultInjector
operator|.
name|getInstance
argument_list|()
operator|.
name|removeBlockReportLease
argument_list|(
name|node
argument_list|,
name|leaseId
argument_list|)
expr_stmt|;
name|node
operator|.
name|setLastBlockReportTime
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|setLastBlockReportMonotonic
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing RPC with index {} out of total {} RPCs in "
operator|+
literal|"processReport 0x{}"
argument_list|,
name|context
operator|.
name|getCurRpc
argument_list|()
argument_list|,
name|context
operator|.
name|getTotalRpcs
argument_list|()
argument_list|,
name|Long
operator|.
name|toHexString
argument_list|(
name|context
operator|.
name|getReportId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Rescan the list of blocks which were previously postponed.    */
DECL|method|rescanPostponedMisreplicatedBlocks ()
name|void
name|rescanPostponedMisreplicatedBlocks
parameter_list|()
block|{
if|if
condition|(
name|getPostponedMisreplicatedBlocksCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|startSize
init|=
name|postponedMisreplicatedBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
try|try
block|{
name|Iterator
argument_list|<
name|Block
argument_list|>
name|it
init|=
name|postponedMisreplicatedBlocks
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocksPerPostpondedRescan
operator|&&
name|it
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Block
name|b
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|BlockInfo
name|bi
init|=
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|bi
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"BLOCK* rescanPostponedMisreplicatedBlocks: "
operator|+
literal|"Postponed mis-replicated block {} no longer found "
operator|+
literal|"in block map."
argument_list|,
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|MisReplicationResult
name|res
init|=
name|processMisReplicatedBlock
argument_list|(
name|bi
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"BLOCK* rescanPostponedMisreplicatedBlocks: "
operator|+
literal|"Re-scanned block {}, result is {}"
argument_list|,
name|b
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|MisReplicationResult
operator|.
name|POSTPONE
condition|)
block|{
name|rescannedMisreplicatedBlocks
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|postponedMisreplicatedBlocks
operator|.
name|addAll
argument_list|(
name|rescannedMisreplicatedBlocks
argument_list|)
expr_stmt|;
name|rescannedMisreplicatedBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|long
name|endSize
init|=
name|postponedMisreplicatedBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rescan of postponedMisreplicatedBlocks completed in {}"
operator|+
literal|" msecs. {} blocks are left. {} blocks were removed."
argument_list|,
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
operator|)
argument_list|,
name|endSize
argument_list|,
operator|(
name|startSize
operator|-
name|endSize
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processReport ( final DatanodeStorageInfo storageInfo, final BlockListAsLongs report, BlockReportContext context)
name|Collection
argument_list|<
name|Block
argument_list|>
name|processReport
parameter_list|(
specifier|final
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
specifier|final
name|BlockListAsLongs
name|report
parameter_list|,
name|BlockReportContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Normal case:
comment|// Modify the (block-->datanode) map, according to the difference
comment|// between the old and new block report.
comment|//
name|Collection
argument_list|<
name|BlockInfoToAdd
argument_list|>
name|toAdd
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toRemove
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|BlockToMarkCorrupt
argument_list|>
name|toCorrupt
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|sorted
init|=
literal|false
decl_stmt|;
name|String
name|strBlockReportId
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|sorted
operator|=
name|context
operator|.
name|isSorted
argument_list|()
expr_stmt|;
name|strBlockReportId
operator|=
name|Long
operator|.
name|toHexString
argument_list|(
name|context
operator|.
name|getReportId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Iterable
argument_list|<
name|BlockReportReplica
argument_list|>
name|sortedReport
decl_stmt|;
if|if
condition|(
operator|!
name|sorted
condition|)
block|{
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* processReport 0x{}: Report from the DataNode ({}) "
operator|+
literal|"is unsorted. This will cause overhead on the NameNode "
operator|+
literal|"which needs to sort the Full BR. Please update the "
operator|+
literal|"DataNode to the same version of Hadoop HDFS as the "
operator|+
literal|"NameNode ({})."
argument_list|,
name|strBlockReportId
argument_list|,
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|BlockReportReplica
argument_list|>
name|set
init|=
operator|new
name|FoldedTreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockReportReplica
name|iblk
range|:
name|report
control|)
block|{
name|set
operator|.
name|add
argument_list|(
operator|new
name|BlockReportReplica
argument_list|(
name|iblk
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sortedReport
operator|=
name|set
expr_stmt|;
block|}
else|else
block|{
name|sortedReport
operator|=
name|report
expr_stmt|;
block|}
name|reportDiffSorted
argument_list|(
name|storageInfo
argument_list|,
name|sortedReport
argument_list|,
name|toAdd
argument_list|,
name|toRemove
argument_list|,
name|toInvalidate
argument_list|,
name|toCorrupt
argument_list|,
name|toUC
argument_list|)
expr_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
comment|// Process the blocks on each queue
for|for
control|(
name|StatefulBlockInfo
name|b
range|:
name|toUC
control|)
block|{
name|addStoredBlockUnderConstruction
argument_list|(
name|b
argument_list|,
name|storageInfo
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockInfo
name|b
range|:
name|toRemove
control|)
block|{
name|removeStoredBlock
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|int
name|numBlocksLogged
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockInfoToAdd
name|b
range|:
name|toAdd
control|)
block|{
name|addStoredBlock
argument_list|(
name|b
operator|.
name|stored
argument_list|,
name|b
operator|.
name|reported
argument_list|,
name|storageInfo
argument_list|,
literal|null
argument_list|,
name|numBlocksLogged
operator|<
name|maxNumBlocksToLog
argument_list|)
expr_stmt|;
name|numBlocksLogged
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|numBlocksLogged
operator|>
name|maxNumBlocksToLog
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport 0x{}: logged info for {} of {} "
operator|+
literal|"reported."
argument_list|,
name|strBlockReportId
argument_list|,
name|maxNumBlocksToLog
argument_list|,
name|numBlocksLogged
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Block
name|b
range|:
name|toInvalidate
control|)
block|{
name|addToInvalidates
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockToMarkCorrupt
name|b
range|:
name|toCorrupt
control|)
block|{
name|markBlockAsCorrupt
argument_list|(
name|b
argument_list|,
name|storageInfo
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|toInvalidate
return|;
block|}
comment|/**    * Mark block replicas as corrupt except those on the storages in     * newStorages list.    */
DECL|method|markBlockReplicasAsCorrupt (Block oldBlock, BlockInfo block, long oldGenerationStamp, long oldNumBytes, DatanodeStorageInfo[] newStorages)
specifier|public
name|void
name|markBlockReplicasAsCorrupt
parameter_list|(
name|Block
name|oldBlock
parameter_list|,
name|BlockInfo
name|block
parameter_list|,
name|long
name|oldGenerationStamp
parameter_list|,
name|long
name|oldNumBytes
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|newStorages
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|BlockToMarkCorrupt
name|b
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|oldGenerationStamp
condition|)
block|{
name|b
operator|=
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|oldBlock
argument_list|,
name|block
argument_list|,
name|oldGenerationStamp
argument_list|,
literal|"genstamp does not match "
operator|+
name|oldGenerationStamp
operator|+
literal|" : "
operator|+
name|block
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|block
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|oldNumBytes
condition|)
block|{
name|b
operator|=
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|oldBlock
argument_list|,
name|block
argument_list|,
literal|"length does not match "
operator|+
name|oldNumBytes
operator|+
literal|" : "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|Reason
operator|.
name|SIZE_MISMATCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
name|boolean
name|isCorrupt
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|newStorages
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|newStorage
range|:
name|newStorages
control|)
block|{
if|if
condition|(
name|newStorage
operator|!=
literal|null
operator|&&
name|storage
operator|.
name|equals
argument_list|(
name|newStorage
argument_list|)
condition|)
block|{
name|isCorrupt
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|isCorrupt
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* markBlockReplicasAsCorrupt: mark block replica"
operator|+
literal|" {} on {} as corrupt because the dn is not in the new committed "
operator|+
literal|"storage list."
argument_list|,
name|b
argument_list|,
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
name|markBlockAsCorrupt
argument_list|(
name|b
argument_list|,
name|storage
argument_list|,
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * processFirstBlockReport is intended only for processing "initial" block    * reports, the first block report received from a DN after it registers.    * It just adds all the valid replicas to the datanode, without calculating     * a toRemove list (since there won't be any).  It also silently discards     * any invalid blocks, thereby deferring their processing until     * the next block report.    * @param storageInfo - DatanodeStorageInfo that sent the report    * @param report - the initial block report, to be processed    * @throws IOException     */
DECL|method|processFirstBlockReport ( final DatanodeStorageInfo storageInfo, final BlockListAsLongs report)
name|void
name|processFirstBlockReport
parameter_list|(
specifier|final
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
specifier|final
name|BlockListAsLongs
name|report
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|report
operator|==
literal|null
condition|)
return|return;
assert|assert
operator|(
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
assert|assert
operator|(
name|storageInfo
operator|.
name|getBlockReportCount
argument_list|()
operator|==
literal|0
operator|)
assert|;
for|for
control|(
name|BlockReportReplica
name|iblk
range|:
name|report
control|)
block|{
name|ReplicaState
name|reportedState
init|=
name|iblk
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initial report of block {} on {} size {} replicaState = {}"
argument_list|,
name|iblk
operator|.
name|getBlockName
argument_list|()
argument_list|,
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|iblk
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|reportedState
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldPostponeBlocksFromFuture
operator|&&
name|isGenStampInFuture
argument_list|(
name|iblk
argument_list|)
condition|)
block|{
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|iblk
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_FUTURE_GENSTAMP
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|BlockInfo
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|iblk
argument_list|)
decl_stmt|;
comment|// If block does not belong to any file, we check if it violates
comment|// an integrity assumption of Name node
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
name|bmSafeMode
operator|.
name|checkBlocksWithFutureGS
argument_list|(
name|iblk
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// If block is corrupt, mark it and continue to next block.
name|BlockUCState
name|ucState
init|=
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
name|BlockToMarkCorrupt
name|c
init|=
name|checkReplicaCorrupt
argument_list|(
name|iblk
argument_list|,
name|reportedState
argument_list|,
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|shouldPostponeBlocksFromFuture
condition|)
block|{
comment|// In the Standby, we may receive a block report for a file that we
comment|// just have an out-of-date gen-stamp or state for, for example.
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|iblk
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_CORRUPT_STATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|markBlockAsCorrupt
argument_list|(
name|c
argument_list|,
name|storageInfo
argument_list|,
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|// If block is under construction, add this replica to its list
if|if
condition|(
name|isBlockUnderConstruction
argument_list|(
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|reportedState
argument_list|)
condition|)
block|{
name|storedBlock
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|addReplicaIfNotPresent
argument_list|(
name|storageInfo
argument_list|,
name|iblk
argument_list|,
name|reportedState
argument_list|)
expr_stmt|;
comment|// OpenFileBlocks only inside snapshots also will be added to safemode
comment|// threshold. So we need to update such blocks to safemode
comment|// refer HDFS-5283
if|if
condition|(
name|namesystem
operator|.
name|isInSnapshot
argument_list|(
name|storedBlock
operator|.
name|getBlockCollectionId
argument_list|()
argument_list|)
condition|)
block|{
name|int
name|numOfReplicas
init|=
name|storedBlock
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|getNumExpectedLocations
argument_list|()
decl_stmt|;
name|bmSafeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
name|numOfReplicas
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
block|}
comment|//and fall through to next clause
block|}
comment|//add replica if appropriate
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|addStoredBlockImmediate
argument_list|(
name|storedBlock
argument_list|,
name|iblk
argument_list|,
name|storageInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|reportDiffSorted (DatanodeStorageInfo storageInfo, Iterable<BlockReportReplica> newReport, Collection<BlockInfoToAdd> toAdd, Collection<BlockInfo> toRemove, Collection<Block> toInvalidate, Collection<BlockToMarkCorrupt> toCorrupt, Collection<StatefulBlockInfo> toUC)
specifier|private
name|void
name|reportDiffSorted
parameter_list|(
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|Iterable
argument_list|<
name|BlockReportReplica
argument_list|>
name|newReport
parameter_list|,
name|Collection
argument_list|<
name|BlockInfoToAdd
argument_list|>
name|toAdd
parameter_list|,
comment|// add to DatanodeDescriptor
name|Collection
argument_list|<
name|BlockInfo
argument_list|>
name|toRemove
parameter_list|,
comment|// remove from DatanodeDescriptor
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
parameter_list|,
comment|// should be removed from DN
name|Collection
argument_list|<
name|BlockToMarkCorrupt
argument_list|>
name|toCorrupt
parameter_list|,
comment|// add to corrupt replicas list
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
parameter_list|)
block|{
comment|// add to under-construction list
comment|// The blocks must be sorted and the storagenodes blocks must be sorted
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|storageBlocksIterator
init|=
name|storageInfo
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
name|DatanodeDescriptor
name|dn
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|BlockInfo
name|storageBlock
init|=
literal|null
decl_stmt|;
for|for
control|(
name|BlockReportReplica
name|replica
range|:
name|newReport
control|)
block|{
name|long
name|replicaID
init|=
name|replica
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
if|if
condition|(
name|BlockIdManager
operator|.
name|isStripedBlockID
argument_list|(
name|replicaID
argument_list|)
operator|&&
operator|(
operator|!
name|hasNonEcBlockUsingStripedID
operator|||
operator|!
name|blocksMap
operator|.
name|containsBlock
argument_list|(
name|replica
argument_list|)
operator|)
condition|)
block|{
name|replicaID
operator|=
name|BlockIdManager
operator|.
name|convertToStripedID
argument_list|(
name|replicaID
argument_list|)
expr_stmt|;
block|}
name|ReplicaState
name|reportedState
init|=
name|replica
operator|.
name|getState
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reported block {} on {} size {} replicaState = {}"
argument_list|,
name|replica
argument_list|,
name|dn
argument_list|,
name|replica
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|reportedState
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldPostponeBlocksFromFuture
operator|&&
name|isGenStampInFuture
argument_list|(
name|replica
argument_list|)
condition|)
block|{
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|replica
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_FUTURE_GENSTAMP
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|storageBlock
operator|==
literal|null
operator|&&
name|storageBlocksIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|storageBlock
operator|=
name|storageBlocksIterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
do|do
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|storageBlock
operator|==
literal|null
operator|||
operator|(
name|cmp
operator|=
name|Long
operator|.
name|compare
argument_list|(
name|replicaID
argument_list|,
name|storageBlock
operator|.
name|getBlockId
argument_list|()
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|// Check if block is available in NN but not yet on this storage
name|BlockInfo
name|nnBlock
init|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|replicaID
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nnBlock
operator|!=
literal|null
condition|)
block|{
name|reportDiffSortedInner
argument_list|(
name|storageInfo
argument_list|,
name|replica
argument_list|,
name|reportedState
argument_list|,
name|nnBlock
argument_list|,
name|toAdd
argument_list|,
name|toCorrupt
argument_list|,
name|toUC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Replica not found anywhere so it should be invalidated
name|toInvalidate
operator|.
name|add
argument_list|(
operator|new
name|Block
argument_list|(
name|replica
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|// Replica matched current storageblock
name|reportDiffSortedInner
argument_list|(
name|storageInfo
argument_list|,
name|replica
argument_list|,
name|reportedState
argument_list|,
name|storageBlock
argument_list|,
name|toAdd
argument_list|,
name|toCorrupt
argument_list|,
name|toUC
argument_list|)
expr_stmt|;
name|storageBlock
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// replica has higher ID than storedBlock
comment|// Remove all stored blocks with IDs lower than replica
do|do
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|storageBlock
argument_list|)
expr_stmt|;
name|storageBlock
operator|=
name|storageBlocksIterator
operator|.
name|hasNext
argument_list|()
condition|?
name|storageBlocksIterator
operator|.
name|next
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
do|while
condition|(
name|storageBlock
operator|!=
literal|null
operator|&&
name|Long
operator|.
name|compare
argument_list|(
name|replicaID
argument_list|,
name|storageBlock
operator|.
name|getBlockId
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
do|;
block|}
block|}
do|while
condition|(
name|storageBlock
operator|!=
literal|null
condition|)
do|;
block|}
comment|// Iterate any remaining blocks that have not been reported and remove them
while|while
condition|(
name|storageBlocksIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|storageBlocksIterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|reportDiffSortedInner ( final DatanodeStorageInfo storageInfo, final BlockReportReplica replica, final ReplicaState reportedState, final BlockInfo storedBlock, final Collection<BlockInfoToAdd> toAdd, final Collection<BlockToMarkCorrupt> toCorrupt, final Collection<StatefulBlockInfo> toUC)
specifier|private
name|void
name|reportDiffSortedInner
parameter_list|(
specifier|final
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
specifier|final
name|BlockReportReplica
name|replica
parameter_list|,
specifier|final
name|ReplicaState
name|reportedState
parameter_list|,
specifier|final
name|BlockInfo
name|storedBlock
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|BlockInfoToAdd
argument_list|>
name|toAdd
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|BlockToMarkCorrupt
argument_list|>
name|toCorrupt
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
parameter_list|)
block|{
assert|assert
name|replica
operator|!=
literal|null
assert|;
assert|assert
name|storedBlock
operator|!=
literal|null
assert|;
name|DatanodeDescriptor
name|dn
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|BlockUCState
name|ucState
init|=
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
comment|// Block is on the NN
name|LOG
operator|.
name|debug
argument_list|(
literal|"In memory blockUCState = {}"
argument_list|,
name|ucState
argument_list|)
expr_stmt|;
comment|// Ignore replicas already scheduled to be removed from the DN
if|if
condition|(
name|invalidateBlocks
operator|.
name|contains
argument_list|(
name|dn
argument_list|,
name|replica
argument_list|)
condition|)
block|{
return|return;
block|}
name|BlockToMarkCorrupt
name|c
init|=
name|checkReplicaCorrupt
argument_list|(
name|replica
argument_list|,
name|reportedState
argument_list|,
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|shouldPostponeBlocksFromFuture
condition|)
block|{
comment|// If the block is an out-of-date generation stamp or state,
comment|// but we're the standby, we shouldn't treat it as corrupt,
comment|// but instead just queue it for later processing.
comment|// TODO: Pretty confident this should be s/storedBlock/block below,
comment|// since we should be postponing the info of the reported block, not
comment|// the stored block. See HDFS-6289 for more context.
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|storedBlock
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_CORRUPT_STATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|toCorrupt
operator|.
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isBlockUnderConstruction
argument_list|(
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|reportedState
argument_list|)
condition|)
block|{
name|toUC
operator|.
name|add
argument_list|(
operator|new
name|StatefulBlockInfo
argument_list|(
name|storedBlock
argument_list|,
operator|new
name|Block
argument_list|(
name|replica
argument_list|)
argument_list|,
name|reportedState
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
operator|(
name|storedBlock
operator|.
name|findStorageInfo
argument_list|(
name|storageInfo
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|corruptReplicas
operator|.
name|isReplicaCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|dn
argument_list|)
operator|)
condition|)
block|{
comment|// Add replica if appropriate. If the replica was previously corrupt
comment|// but now okay, it might need to be updated.
name|toAdd
operator|.
name|add
argument_list|(
operator|new
name|BlockInfoToAdd
argument_list|(
name|storedBlock
argument_list|,
operator|new
name|Block
argument_list|(
name|replica
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Queue the given reported block for later processing in the    * standby node. @see PendingDataNodeMessages.    * @param reason a textual reason to report in the debug logs    */
DECL|method|queueReportedBlock (DatanodeStorageInfo storageInfo, Block block, ReplicaState reportedState, String reason)
specifier|private
name|void
name|queueReportedBlock
parameter_list|(
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|Block
name|block
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
assert|assert
name|shouldPostponeBlocksFromFuture
assert|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Queueing reported block {} in state {}"
operator|+
literal|" from datanode {} for later processing because {}."
argument_list|,
name|block
argument_list|,
name|reportedState
argument_list|,
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|pendingDNMessages
operator|.
name|enqueueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|block
argument_list|,
name|reportedState
argument_list|)
expr_stmt|;
block|}
comment|/**    * Try to process any messages that were previously queued for the given    * block. This is called from FSEditLogLoader whenever a block's state    * in the namespace has changed or a new block has been created.    */
DECL|method|processQueuedMessagesForBlock (Block b)
specifier|public
name|void
name|processQueuedMessagesForBlock
parameter_list|(
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|Queue
argument_list|<
name|ReportedBlockInfo
argument_list|>
name|queue
init|=
name|pendingDNMessages
operator|.
name|takeBlockQueue
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
comment|// Nothing to re-process
return|return;
block|}
name|processQueuedMessages
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
DECL|method|processQueuedMessages (Iterable<ReportedBlockInfo> rbis)
specifier|private
name|void
name|processQueuedMessages
parameter_list|(
name|Iterable
argument_list|<
name|ReportedBlockInfo
argument_list|>
name|rbis
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|ReportedBlockInfo
name|rbi
range|:
name|rbis
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing previouly queued message {}"
argument_list|,
name|rbi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbi
operator|.
name|getReportedState
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// This is a DELETE_BLOCK request
name|DatanodeStorageInfo
name|storageInfo
init|=
name|rbi
operator|.
name|getStorageInfo
argument_list|()
decl_stmt|;
name|removeStoredBlock
argument_list|(
name|getStoredBlock
argument_list|(
name|rbi
operator|.
name|getBlock
argument_list|()
argument_list|)
argument_list|,
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processAndHandleReportedBlock
argument_list|(
name|rbi
operator|.
name|getStorageInfo
argument_list|()
argument_list|,
name|rbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|rbi
operator|.
name|getReportedState
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Process any remaining queued datanode messages after entering    * active state. At this point they will not be re-queued since    * we are the definitive master node and thus should be up-to-date    * with the namespace information.    */
DECL|method|processAllPendingDNMessages ()
specifier|public
name|void
name|processAllPendingDNMessages
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|shouldPostponeBlocksFromFuture
operator|:
literal|"processAllPendingDNMessages() should be called after disabling "
operator|+
literal|"block postponement."
assert|;
name|int
name|count
init|=
name|pendingDNMessages
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing {} messages from DataNodes "
operator|+
literal|"that were previously queued during standby state"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|processQueuedMessages
argument_list|(
name|pendingDNMessages
operator|.
name|takeAll
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|pendingDNMessages
operator|.
name|count
argument_list|()
operator|==
literal|0
assert|;
block|}
comment|/**    * The next two methods test the various cases under which we must conclude    * the replica is corrupt, or under construction.  These are laid out    * as switch statements, on the theory that it is easier to understand    * the combinatorics of reportedState and ucState that way.  It should be    * at least as efficient as boolean expressions.    *     * @return a BlockToMarkCorrupt object, or null if the replica is not corrupt    */
DECL|method|checkReplicaCorrupt ( Block reported, ReplicaState reportedState, BlockInfo storedBlock, BlockUCState ucState, DatanodeDescriptor dn)
specifier|private
name|BlockToMarkCorrupt
name|checkReplicaCorrupt
parameter_list|(
name|Block
name|reported
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|,
name|BlockInfo
name|storedBlock
parameter_list|,
name|BlockUCState
name|ucState
parameter_list|,
name|DatanodeDescriptor
name|dn
parameter_list|)
block|{
switch|switch
condition|(
name|reportedState
condition|)
block|{
case|case
name|FINALIZED
case|:
switch|switch
condition|(
name|ucState
condition|)
block|{
case|case
name|COMPLETE
case|:
case|case
name|COMMITTED
case|:
if|if
condition|(
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
specifier|final
name|long
name|reportedGS
init|=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
operator|new
name|Block
argument_list|(
name|reported
argument_list|)
argument_list|,
name|storedBlock
argument_list|,
name|reportedGS
argument_list|,
literal|"block is "
operator|+
name|ucState
operator|+
literal|" and reported genstamp "
operator|+
name|reportedGS
operator|+
literal|" does not match genstamp in block map "
operator|+
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
return|;
block|}
name|boolean
name|wrongSize
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|isStriped
argument_list|()
condition|)
block|{
assert|assert
name|BlockIdManager
operator|.
name|isStripedBlockID
argument_list|(
name|reported
operator|.
name|getBlockId
argument_list|()
argument_list|)
assert|;
assert|assert
name|storedBlock
operator|.
name|getBlockId
argument_list|()
operator|==
name|BlockIdManager
operator|.
name|convertToStripedID
argument_list|(
name|reported
operator|.
name|getBlockId
argument_list|()
argument_list|)
assert|;
name|BlockInfoStriped
name|stripedBlock
init|=
operator|(
name|BlockInfoStriped
operator|)
name|storedBlock
decl_stmt|;
name|int
name|reportedBlkIdx
init|=
name|BlockIdManager
operator|.
name|getBlockIndex
argument_list|(
name|reported
argument_list|)
decl_stmt|;
name|wrongSize
operator|=
name|reported
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|getInternalBlockLength
argument_list|(
name|stripedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|stripedBlock
operator|.
name|getCellSize
argument_list|()
argument_list|,
name|stripedBlock
operator|.
name|getDataBlockNum
argument_list|()
argument_list|,
name|reportedBlkIdx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrongSize
operator|=
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|reported
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|wrongSize
condition|)
block|{
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
operator|new
name|Block
argument_list|(
name|reported
argument_list|)
argument_list|,
name|storedBlock
argument_list|,
literal|"block is "
operator|+
name|ucState
operator|+
literal|" and reported length "
operator|+
name|reported
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" does not match "
operator|+
literal|"length in block map "
operator|+
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|Reason
operator|.
name|SIZE_MISMATCH
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
comment|// not corrupt
block|}
case|case
name|UNDER_CONSTRUCTION
case|:
if|if
condition|(
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|>
name|reported
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
specifier|final
name|long
name|reportedGS
init|=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
operator|new
name|Block
argument_list|(
name|reported
argument_list|)
argument_list|,
name|storedBlock
argument_list|,
name|reportedGS
argument_list|,
literal|"block is "
operator|+
name|ucState
operator|+
literal|" and reported state "
operator|+
name|reportedState
operator|+
literal|", But reported genstamp "
operator|+
name|reportedGS
operator|+
literal|" does not match genstamp in block map "
operator|+
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
return|;
block|}
return|return
literal|null
return|;
default|default:
return|return
literal|null
return|;
block|}
case|case
name|RBW
case|:
case|case
name|RWR
case|:
specifier|final
name|long
name|reportedGS
init|=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|storedBlock
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|//When DN report lesser GS than the storedBlock then mark it is corrupt,
comment|//As already valid replica will be present.
if|if
condition|(
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|>
name|reported
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
operator|new
name|Block
argument_list|(
name|reported
argument_list|)
argument_list|,
name|storedBlock
argument_list|,
name|reportedGS
argument_list|,
literal|"reported "
operator|+
name|reportedState
operator|+
literal|" replica with genstamp "
operator|+
name|reportedGS
operator|+
literal|" does not match Stored block's genstamp in block map "
operator|+
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
return|;
block|}
return|return
literal|null
return|;
comment|// not corrupt
block|}
elseif|else
if|if
condition|(
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
operator|new
name|Block
argument_list|(
name|reported
argument_list|)
argument_list|,
name|storedBlock
argument_list|,
name|reportedGS
argument_list|,
literal|"reported "
operator|+
name|reportedState
operator|+
literal|" replica with genstamp "
operator|+
name|reportedGS
operator|+
literal|" does not match COMPLETE block's genstamp in block map "
operator|+
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
return|;
block|}
else|else
block|{
comment|// COMPLETE block, same genstamp
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
comment|// If it's a RBW report for a COMPLETE block, it may just be that
comment|// the block report got a little bit delayed after the pipeline
comment|// closed. So, ignore this report, assuming we will get a
comment|// FINALIZED replica later. See HDFS-2791
name|LOG
operator|.
name|info
argument_list|(
literal|"Received an RBW replica for {} on {}: ignoring it, since "
operator|+
literal|"it is complete with the same genstamp"
argument_list|,
name|storedBlock
argument_list|,
name|dn
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
operator|new
name|Block
argument_list|(
name|reported
argument_list|)
argument_list|,
name|storedBlock
argument_list|,
literal|"reported replica has invalid state "
operator|+
name|reportedState
argument_list|,
name|Reason
operator|.
name|INVALID_STATE
argument_list|)
return|;
block|}
block|}
case|case
name|RUR
case|:
comment|// should not be reported
case|case
name|TEMPORARY
case|:
comment|// should not be reported
default|default:
name|String
name|msg
init|=
literal|"Unexpected replica state "
operator|+
name|reportedState
operator|+
literal|" for block: "
operator|+
name|storedBlock
operator|+
literal|" on "
operator|+
name|dn
operator|+
literal|" size "
operator|+
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
comment|// log here at WARN level since this is really a broken HDFS invariant
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
operator|new
name|Block
argument_list|(
name|reported
argument_list|)
argument_list|,
name|storedBlock
argument_list|,
name|msg
argument_list|,
name|Reason
operator|.
name|INVALID_STATE
argument_list|)
return|;
block|}
block|}
DECL|method|isBlockUnderConstruction (BlockInfo storedBlock, BlockUCState ucState, ReplicaState reportedState)
specifier|private
name|boolean
name|isBlockUnderConstruction
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|BlockUCState
name|ucState
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|)
block|{
switch|switch
condition|(
name|reportedState
condition|)
block|{
case|case
name|FINALIZED
case|:
switch|switch
condition|(
name|ucState
condition|)
block|{
case|case
name|UNDER_CONSTRUCTION
case|:
case|case
name|UNDER_RECOVERY
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
case|case
name|RBW
case|:
case|case
name|RWR
case|:
return|return
operator|(
operator|!
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|)
return|;
case|case
name|RUR
case|:
comment|// should not be reported
case|case
name|TEMPORARY
case|:
comment|// should not be reported
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|method|addStoredBlockUnderConstruction (StatefulBlockInfo ucBlock, DatanodeStorageInfo storageInfo)
name|void
name|addStoredBlockUnderConstruction
parameter_list|(
name|StatefulBlockInfo
name|ucBlock
parameter_list|,
name|DatanodeStorageInfo
name|storageInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockInfo
name|block
init|=
name|ucBlock
operator|.
name|storedBlock
decl_stmt|;
name|block
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|addReplicaIfNotPresent
argument_list|(
name|storageInfo
argument_list|,
name|ucBlock
operator|.
name|reportedBlock
argument_list|,
name|ucBlock
operator|.
name|reportedState
argument_list|)
expr_stmt|;
comment|// Add replica if appropriate. If the replica was previously corrupt
comment|// but now okay, it might need to be updated.
if|if
condition|(
name|ucBlock
operator|.
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
operator|(
name|block
operator|.
name|findStorageInfo
argument_list|(
name|storageInfo
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|corruptReplicas
operator|.
name|isReplicaCorrupt
argument_list|(
name|block
argument_list|,
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
condition|)
block|{
name|addStoredBlock
argument_list|(
name|block
argument_list|,
name|ucBlock
operator|.
name|reportedBlock
argument_list|,
name|storageInfo
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Faster version of {@link #addStoredBlock},    * intended for use with initial block report at startup. If not in startup    * safe mode, will call standard addStoredBlock(). Assumes this method is    * called "immediately" so there is no need to refresh the storedBlock from    * blocksMap. Doesn't handle low redundancy/extra redundancy, or worry about    * pendingReplications or corruptReplicas, because it's in startup safe mode.    * Doesn't log every block, because there are typically millions of them.    *     * @throws IOException    */
DECL|method|addStoredBlockImmediate (BlockInfo storedBlock, Block reported, DatanodeStorageInfo storageInfo)
specifier|private
name|void
name|addStoredBlockImmediate
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|Block
name|reported
parameter_list|,
name|DatanodeStorageInfo
name|storageInfo
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|(
name|storedBlock
operator|!=
literal|null
operator|&&
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isInStartupSafeMode
argument_list|()
operator|||
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
name|addStoredBlock
argument_list|(
name|storedBlock
argument_list|,
name|reported
argument_list|,
name|storageInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// just add it
name|AddBlockResult
name|result
init|=
name|storageInfo
operator|.
name|addBlockInitial
argument_list|(
name|storedBlock
argument_list|,
name|reported
argument_list|)
decl_stmt|;
comment|// Now check for completion of blocks and safe block count
name|int
name|numCurrentReplica
init|=
name|countLiveNodes
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|COMMITTED
operator|&&
name|hasMinStorage
argument_list|(
name|storedBlock
argument_list|,
name|numCurrentReplica
argument_list|)
condition|)
block|{
name|completeBlock
argument_list|(
name|storedBlock
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|&&
name|result
operator|==
name|AddBlockResult
operator|.
name|ADDED
condition|)
block|{
comment|// check whether safe replication is reached for the block
comment|// only complete blocks are counted towards that.
comment|// In the case that the block just became complete above, completeBlock()
comment|// handles the safe block count maintenance.
name|bmSafeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
name|numCurrentReplica
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Modify (block-->datanode) map. Remove block from set of    * needed reconstruction if this takes care of the problem.    * @return the block that is stored in blocksMap.    */
DECL|method|addStoredBlock (final BlockInfo block, final Block reportedBlock, DatanodeStorageInfo storageInfo, DatanodeDescriptor delNodeHint, boolean logEveryBlock)
specifier|private
name|Block
name|addStoredBlock
parameter_list|(
specifier|final
name|BlockInfo
name|block
parameter_list|,
specifier|final
name|Block
name|reportedBlock
parameter_list|,
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|,
name|boolean
name|logEveryBlock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|block
operator|!=
literal|null
operator|&&
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|BlockInfo
name|storedBlock
decl_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|block
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|//refresh our copy in case the block got completed in another thread
name|storedBlock
operator|=
name|getStoredBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storedBlock
operator|=
name|block
expr_stmt|;
block|}
if|if
condition|(
name|storedBlock
operator|==
literal|null
operator|||
name|storedBlock
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
comment|// If this block does not belong to anyfile, then we are done.
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* addStoredBlock: {} on {} size {} but it does not"
operator|+
literal|" belong to any file"
argument_list|,
name|block
argument_list|,
name|node
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
comment|// we could add this block to invalidate set of this datanode.
comment|// it will happen in next block report otherwise.
return|return
name|block
return|;
block|}
comment|// add block to the datanode
name|AddBlockResult
name|result
init|=
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|storedBlock
argument_list|,
name|reportedBlock
argument_list|)
decl_stmt|;
name|int
name|curReplicaDelta
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|AddBlockResult
operator|.
name|ADDED
condition|)
block|{
name|curReplicaDelta
operator|=
operator|(
name|node
operator|.
name|isDecommissioned
argument_list|()
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|logEveryBlock
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* addStoredBlock: {} is added to {} (size={})"
argument_list|,
name|node
argument_list|,
name|storedBlock
argument_list|,
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|AddBlockResult
operator|.
name|REPLACED
condition|)
block|{
name|curReplicaDelta
operator|=
literal|0
expr_stmt|;
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* addStoredBlock: block {} moved to storageType "
operator|+
literal|"{} on node {}"
argument_list|,
name|storedBlock
argument_list|,
name|storageInfo
operator|.
name|getStorageType
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if the same block is added again and the replica was corrupt
comment|// previously because of a wrong gen stamp, remove it from the
comment|// corrupt block list.
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|block
argument_list|,
name|node
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
expr_stmt|;
name|curReplicaDelta
operator|=
literal|0
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* addStoredBlock: Redundant addStoredBlock request"
operator|+
literal|" received for {} on node {} size {}"
argument_list|,
name|storedBlock
argument_list|,
name|node
argument_list|,
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Now check for completion of blocks and safe block count
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
name|int
name|numLiveReplicas
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
name|int
name|pendingNum
init|=
name|pendingReconstruction
operator|.
name|getNumReplicas
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
name|int
name|numCurrentReplica
init|=
name|numLiveReplicas
operator|+
name|pendingNum
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|COMMITTED
operator|&&
name|hasMinStorage
argument_list|(
name|storedBlock
argument_list|,
name|numLiveReplicas
argument_list|)
condition|)
block|{
name|addExpectedReplicasToPending
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
name|completeBlock
argument_list|(
name|storedBlock
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|&&
name|result
operator|==
name|AddBlockResult
operator|.
name|ADDED
condition|)
block|{
comment|// check whether safe replication is reached for the block
comment|// only complete blocks are counted towards that
comment|// Is no-op if not in safe mode.
comment|// In the case that the block just became complete above, completeBlock()
comment|// handles the safe block count maintenance.
name|bmSafeMode
operator|.
name|incrementSafeBlockCount
argument_list|(
name|numCurrentReplica
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
block|}
comment|// if block is still under construction, then done for now
if|if
condition|(
operator|!
name|storedBlock
operator|.
name|isCompleteOrCommitted
argument_list|()
condition|)
block|{
return|return
name|storedBlock
return|;
block|}
comment|// do not try to handle extra/low redundancy blocks during first safe mode
if|if
condition|(
operator|!
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return
name|storedBlock
return|;
block|}
comment|// handle low redundancy/extra redundancy
name|short
name|fileRedundancy
init|=
name|getExpectedRedundancyNum
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isNeededReconstruction
argument_list|(
name|storedBlock
argument_list|,
name|num
argument_list|,
name|pendingNum
argument_list|)
condition|)
block|{
name|neededReconstruction
operator|.
name|remove
argument_list|(
name|storedBlock
argument_list|,
name|numCurrentReplica
argument_list|,
name|num
operator|.
name|readOnlyReplicas
argument_list|()
argument_list|,
name|num
operator|.
name|outOfServiceReplicas
argument_list|()
argument_list|,
name|fileRedundancy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updateNeededReconstructions
argument_list|(
name|storedBlock
argument_list|,
name|curReplicaDelta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldProcessExtraRedundancy
argument_list|(
name|num
argument_list|,
name|fileRedundancy
argument_list|)
condition|)
block|{
name|processExtraRedundancyBlock
argument_list|(
name|storedBlock
argument_list|,
name|fileRedundancy
argument_list|,
name|node
argument_list|,
name|delNodeHint
argument_list|)
expr_stmt|;
block|}
comment|// If the file redundancy has reached desired value
comment|// we can remove any corrupt replicas the block may have
name|int
name|corruptReplicasCount
init|=
name|corruptReplicas
operator|.
name|numCorruptReplicas
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
name|int
name|numCorruptNodes
init|=
name|num
operator|.
name|corruptReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|numCorruptNodes
operator|!=
name|corruptReplicasCount
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Inconsistent number of corrupt replicas for {}"
operator|+
literal|". blockMap has {} but corrupt replicas map has {}"
argument_list|,
name|storedBlock
argument_list|,
name|numCorruptNodes
argument_list|,
name|corruptReplicasCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|corruptReplicasCount
operator|>
literal|0
operator|)
operator|&&
operator|(
name|numLiveReplicas
operator|>=
name|fileRedundancy
operator|)
condition|)
block|{
name|invalidateCorruptReplicas
argument_list|(
name|storedBlock
argument_list|,
name|reportedBlock
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
return|return
name|storedBlock
return|;
block|}
comment|// If there is any maintenance replica, we don't have to restore
comment|// the condition of live + maintenance == expected. We allow
comment|// live + maintenance>= expected. The extra redundancy will be removed
comment|// when the maintenance node changes to live.
DECL|method|shouldProcessExtraRedundancy (NumberReplicas num, int expectedNum)
specifier|private
name|boolean
name|shouldProcessExtraRedundancy
parameter_list|(
name|NumberReplicas
name|num
parameter_list|,
name|int
name|expectedNum
parameter_list|)
block|{
specifier|final
name|int
name|numCurrent
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
return|return
name|numCurrent
operator|>
name|expectedNum
operator|||
operator|(
name|numCurrent
operator|==
name|expectedNum
operator|&&
name|num
operator|.
name|redundantInternalBlocks
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
comment|/**    * Invalidate corrupt replicas.    *<p>    * This will remove the replicas from the block's location list,    * add them to {@link #invalidateBlocks} so that they could be further    * deleted from the respective data-nodes,    * and remove the block from corruptReplicasMap.    *<p>    * This method should be called when the block has sufficient    * number of live replicas.    *    * @param blk Block whose corrupt replicas need to be invalidated    */
DECL|method|invalidateCorruptReplicas (BlockInfo blk, Block reported, NumberReplicas numberReplicas)
specifier|private
name|void
name|invalidateCorruptReplicas
parameter_list|(
name|BlockInfo
name|blk
parameter_list|,
name|Block
name|reported
parameter_list|,
name|NumberReplicas
name|numberReplicas
parameter_list|)
block|{
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|boolean
name|removedFromBlocksMap
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
return|return;
comment|// make a copy of the array of nodes in order to avoid
comment|// ConcurrentModificationException, when the block is removed from the node
name|DatanodeDescriptor
index|[]
name|nodesCopy
init|=
name|nodes
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeDescriptor
index|[
name|nodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|nodesCopy
control|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|invalidateBlock
argument_list|(
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|reported
argument_list|,
name|blk
argument_list|,
literal|null
argument_list|,
name|Reason
operator|.
name|ANY
argument_list|)
argument_list|,
name|node
argument_list|,
name|numberReplicas
argument_list|)
condition|)
block|{
name|removedFromBlocksMap
operator|=
literal|false
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"invalidateCorruptReplicas error in deleting bad block"
operator|+
literal|" {} on {}"
argument_list|,
name|blk
argument_list|,
name|node
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|removedFromBlocksMap
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Remove the block from corruptReplicasMap
if|if
condition|(
name|removedFromBlocksMap
condition|)
block|{
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For each block in the name-node verify whether it belongs to any file,    * extra or low redundancy. Place it into the respective queue.    */
DECL|method|processMisReplicatedBlocks ()
specifier|public
name|void
name|processMisReplicatedBlocks
parameter_list|()
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|stopReconstructionInitializer
argument_list|()
expr_stmt|;
name|neededReconstruction
operator|.
name|clear
argument_list|()
expr_stmt|;
name|reconstructionQueuesInitializer
operator|=
operator|new
name|Daemon
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|processMisReplicatesAsync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted while processing reconstruction queues."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while processing reconstruction queues async"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
expr_stmt|;
name|reconstructionQueuesInitializer
operator|.
name|setName
argument_list|(
literal|"Reconstruction Queue Initializer"
argument_list|)
expr_stmt|;
name|reconstructionQueuesInitializer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/*    * Stop the ongoing initialisation of reconstruction queues    */
DECL|method|stopReconstructionInitializer ()
specifier|private
name|void
name|stopReconstructionInitializer
parameter_list|()
block|{
if|if
condition|(
name|reconstructionQueuesInitializer
operator|!=
literal|null
condition|)
block|{
name|reconstructionQueuesInitializer
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|reconstructionQueuesInitializer
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting for "
operator|+
literal|"reconstructionQueueInitializer. Returning.."
argument_list|)
expr_stmt|;
return|return;
block|}
finally|finally
block|{
name|reconstructionQueuesInitializer
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Since the BlocksMapGset does not throw the ConcurrentModificationException    * and supports further iteration after modification to list, there is a    * chance of missing the newly added block while iterating. Since every    * addition to blocksMap will check for mis-replication, missing mis-replication    * check for new blocks will not be a problem.    */
DECL|method|processMisReplicatesAsync ()
specifier|private
name|void
name|processMisReplicatesAsync
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|long
name|nrInvalid
init|=
literal|0
decl_stmt|,
name|nrOverReplicated
init|=
literal|0
decl_stmt|;
name|long
name|nrUnderReplicated
init|=
literal|0
decl_stmt|,
name|nrPostponed
init|=
literal|0
decl_stmt|,
name|nrUnderConstruction
init|=
literal|0
decl_stmt|;
name|long
name|startTimeMisReplicatedScan
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|blocksItr
init|=
name|blocksMap
operator|.
name|getBlocks
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|long
name|totalBlocks
init|=
name|blocksMap
operator|.
name|size
argument_list|()
decl_stmt|;
name|reconstructionQueuesInitProgress
operator|=
literal|0
expr_stmt|;
name|long
name|totalProcessed
init|=
literal|0
decl_stmt|;
name|long
name|sleepDuration
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|numBlocksPerIteration
operator|/
literal|1000
argument_list|,
literal|10000
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|namesystem
operator|.
name|isRunning
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|namesystem
operator|.
name|writeLockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
name|processed
operator|<
name|numBlocksPerIteration
operator|&&
name|blocksItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockInfo
name|block
init|=
name|blocksItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|MisReplicationResult
name|res
init|=
name|processMisReplicatedBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|UNDER_REPLICATED
case|:
name|LOG
operator|.
name|trace
argument_list|(
literal|"under replicated block {}: {}"
argument_list|,
name|block
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nrUnderReplicated
operator|++
expr_stmt|;
break|break;
case|case
name|OVER_REPLICATED
case|:
name|LOG
operator|.
name|trace
argument_list|(
literal|"over replicated block {}: {}"
argument_list|,
name|block
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nrOverReplicated
operator|++
expr_stmt|;
break|break;
case|case
name|INVALID
case|:
name|LOG
operator|.
name|trace
argument_list|(
literal|"invalid block {}: {}"
argument_list|,
name|block
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nrInvalid
operator|++
expr_stmt|;
break|break;
case|case
name|POSTPONE
case|:
name|LOG
operator|.
name|trace
argument_list|(
literal|"postpone block {}: {}"
argument_list|,
name|block
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nrPostponed
operator|++
expr_stmt|;
name|postponeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDER_CONSTRUCTION
case|:
name|LOG
operator|.
name|trace
argument_list|(
literal|"under construction block {}: {}"
argument_list|,
name|block
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nrUnderConstruction
operator|++
expr_stmt|;
break|break;
case|case
name|OK
case|:
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Invalid enum value: "
operator|+
name|res
argument_list|)
throw|;
block|}
name|processed
operator|++
expr_stmt|;
block|}
name|totalProcessed
operator|+=
name|processed
expr_stmt|;
comment|// there is a possibility that if any of the blocks deleted/added during
comment|// initialisation, then progress might be different.
name|reconstructionQueuesInitProgress
operator|=
name|Math
operator|.
name|min
argument_list|(
operator|(
name|double
operator|)
name|totalProcessed
operator|/
name|totalBlocks
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blocksItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Total number of blocks            = {}"
argument_list|,
name|blocksMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of invalid blocks          = {}"
argument_list|,
name|nrInvalid
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of under-replicated blocks = {}"
argument_list|,
name|nrUnderReplicated
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of  over-replicated blocks = {}{}"
argument_list|,
name|nrOverReplicated
argument_list|,
operator|(
operator|(
name|nrPostponed
operator|>
literal|0
operator|)
condition|?
operator|(
literal|" ("
operator|+
name|nrPostponed
operator|+
literal|" postponed)"
operator|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of blocks being written    = {}"
argument_list|,
name|nrUnderConstruction
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Replication Queue initialization "
operator|+
literal|"scan for invalid, over- and under-replicated blocks "
operator|+
literal|"completed in "
operator|+
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTimeMisReplicatedScan
operator|)
operator|+
literal|" msec"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// Make sure it is out of the write lock for sufficiently long time.
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepDuration
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted while processing replication queues."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the progress of the reconstruction queues initialisation    *     * @return Returns values between 0 and 1 for the progress.    */
DECL|method|getReconstructionQueuesInitProgress ()
specifier|public
name|double
name|getReconstructionQueuesInitProgress
parameter_list|()
block|{
return|return
name|reconstructionQueuesInitProgress
return|;
block|}
comment|/**    * Get the value of whether there are any non-EC blocks using StripedID.    *    * @return Returns the value of whether there are any non-EC blocks using StripedID.    */
DECL|method|hasNonEcBlockUsingStripedID ()
specifier|public
name|boolean
name|hasNonEcBlockUsingStripedID
parameter_list|()
block|{
return|return
name|hasNonEcBlockUsingStripedID
return|;
block|}
comment|/**    * Schedule replication work for a specified list of mis-replicated    * blocks and return total number of blocks scheduled for replication.    *    * @param blocks A list of blocks for which replication work needs to    *              be scheduled.    * @return Total number of blocks for which replication work is scheduled.    **/
DECL|method|processMisReplicatedBlocks (List<BlockInfo> blocks)
specifier|public
name|int
name|processMisReplicatedBlocks
parameter_list|(
name|List
argument_list|<
name|BlockInfo
argument_list|>
name|blocks
parameter_list|)
block|{
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|iter
init|=
name|blocks
operator|.
name|iterator
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|isPopulatingReplQueues
argument_list|()
operator|&&
name|namesystem
operator|.
name|isRunning
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
operator|&&
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|limit
init|=
name|processed
operator|+
name|numBlocksPerIteration
decl_stmt|;
name|namesystem
operator|.
name|writeLockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
operator|&&
name|processed
operator|<
name|limit
condition|)
block|{
name|BlockInfo
name|blk
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|MisReplicationResult
name|r
init|=
name|processMisReplicatedBlock
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"BLOCK* processMisReplicatedBlocks: "
operator|+
literal|"Re-scanned block {}, result is {}"
argument_list|,
name|blk
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Caught InterruptedException while scheduling replication work"
operator|+
literal|" for mis-replicated blocks"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
return|return
name|processed
return|;
block|}
comment|/**    * Process a single possibly misreplicated block. This adds it to the    * appropriate queues if necessary, and returns a result code indicating    * what happened with it.    */
DECL|method|processMisReplicatedBlock (BlockInfo block)
specifier|private
name|MisReplicationResult
name|processMisReplicatedBlock
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
comment|// block does not belong to any file
name|addToInvalidates
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|MisReplicationResult
operator|.
name|INVALID
return|;
block|}
if|if
condition|(
operator|!
name|block
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|// Incomplete blocks are never considered mis-replicated --
comment|// they'll be reached when they are completed or recovered.
return|return
name|MisReplicationResult
operator|.
name|UNDER_CONSTRUCTION
return|;
block|}
comment|// calculate current redundancy
name|short
name|expectedRedundancy
init|=
name|getExpectedRedundancyNum
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numCurrentReplica
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
comment|// add to low redundancy queue if need to be
if|if
condition|(
name|isNeededReconstruction
argument_list|(
name|block
argument_list|,
name|num
argument_list|)
condition|)
block|{
if|if
condition|(
name|neededReconstruction
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|numCurrentReplica
argument_list|,
name|num
operator|.
name|readOnlyReplicas
argument_list|()
argument_list|,
name|num
operator|.
name|outOfServiceReplicas
argument_list|()
argument_list|,
name|expectedRedundancy
argument_list|)
condition|)
block|{
return|return
name|MisReplicationResult
operator|.
name|UNDER_REPLICATED
return|;
block|}
block|}
if|if
condition|(
name|shouldProcessExtraRedundancy
argument_list|(
name|num
argument_list|,
name|expectedRedundancy
argument_list|)
condition|)
block|{
if|if
condition|(
name|num
operator|.
name|replicasOnStaleNodes
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// If any of the replicas of this block are on nodes that are
comment|// considered "stale", then these replicas may in fact have
comment|// already been deleted. So, we cannot safely act on the
comment|// over-replication until a later point in time, when
comment|// the "stale" nodes have block reported.
return|return
name|MisReplicationResult
operator|.
name|POSTPONE
return|;
block|}
comment|// extra redundancy block
name|processExtraRedundancyBlock
argument_list|(
name|block
argument_list|,
name|expectedRedundancy
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|MisReplicationResult
operator|.
name|OVER_REPLICATED
return|;
block|}
return|return
name|MisReplicationResult
operator|.
name|OK
return|;
block|}
comment|/** Set replication for the blocks. */
DECL|method|setReplication ( final short oldRepl, final short newRepl, final BlockInfo b)
specifier|public
name|void
name|setReplication
parameter_list|(
specifier|final
name|short
name|oldRepl
parameter_list|,
specifier|final
name|short
name|newRepl
parameter_list|,
specifier|final
name|BlockInfo
name|b
parameter_list|)
block|{
if|if
condition|(
name|newRepl
operator|==
name|oldRepl
condition|)
block|{
return|return;
block|}
comment|// update neededReconstruction priority queues
name|b
operator|.
name|setReplication
argument_list|(
name|newRepl
argument_list|)
expr_stmt|;
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|updateNeededReconstructions
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|newRepl
operator|-
name|oldRepl
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldProcessExtraRedundancy
argument_list|(
name|num
argument_list|,
name|newRepl
argument_list|)
condition|)
block|{
name|processExtraRedundancyBlock
argument_list|(
name|b
argument_list|,
name|newRepl
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Find how many of the containing nodes are "extra", if any.    * If there are any extras, call chooseExcessRedundancies() to    * mark them in the excessRedundancyMap.    */
DECL|method|processExtraRedundancyBlock (final BlockInfo block, final short replication, final DatanodeDescriptor addedNode, DatanodeDescriptor delNodeHint)
specifier|private
name|void
name|processExtraRedundancyBlock
parameter_list|(
specifier|final
name|BlockInfo
name|block
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|DatanodeDescriptor
name|addedNode
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|addedNode
operator|==
name|delNodeHint
condition|)
block|{
name|delNodeHint
operator|=
literal|null
expr_stmt|;
block|}
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|nonExcess
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
if|if
condition|(
name|storage
operator|.
name|getState
argument_list|()
operator|!=
name|State
operator|.
name|NORMAL
condition|)
block|{
continue|continue;
block|}
specifier|final
name|DatanodeDescriptor
name|cur
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|storage
operator|.
name|areBlockContentsStale
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"BLOCK* processExtraRedundancyBlock: Postponing {}"
operator|+
literal|" since storage {} does not yet have up-to-date information."
argument_list|,
name|block
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|postponeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|isExcess
argument_list|(
name|cur
argument_list|,
name|block
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur
operator|.
name|isInService
argument_list|()
condition|)
block|{
comment|// exclude corrupt replicas
if|if
condition|(
name|corruptNodes
operator|==
literal|null
operator|||
operator|!
name|corruptNodes
operator|.
name|contains
argument_list|(
name|cur
argument_list|)
condition|)
block|{
name|nonExcess
operator|.
name|add
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|chooseExcessRedundancies
argument_list|(
name|nonExcess
argument_list|,
name|block
argument_list|,
name|replication
argument_list|,
name|addedNode
argument_list|,
name|delNodeHint
argument_list|)
expr_stmt|;
block|}
DECL|method|chooseExcessRedundancies ( final Collection<DatanodeStorageInfo> nonExcess, BlockInfo storedBlock, short replication, DatanodeDescriptor addedNode, DatanodeDescriptor delNodeHint)
specifier|private
name|void
name|chooseExcessRedundancies
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|nonExcess
parameter_list|,
name|BlockInfo
name|storedBlock
parameter_list|,
name|short
name|replication
parameter_list|,
name|DatanodeDescriptor
name|addedNode
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
comment|// first form a rack to datanodes map and
name|BlockCollection
name|bc
init|=
name|getBlockCollection
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|chooseExcessRedundancyStriped
argument_list|(
name|bc
argument_list|,
name|nonExcess
argument_list|,
name|storedBlock
argument_list|,
name|delNodeHint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|BlockStoragePolicy
name|storagePolicy
init|=
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|bc
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|StorageType
argument_list|>
name|excessTypes
init|=
name|storagePolicy
operator|.
name|chooseExcess
argument_list|(
name|replication
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageTypes
argument_list|(
name|nonExcess
argument_list|)
argument_list|)
decl_stmt|;
name|chooseExcessRedundancyContiguous
argument_list|(
name|nonExcess
argument_list|,
name|storedBlock
argument_list|,
name|replication
argument_list|,
name|addedNode
argument_list|,
name|delNodeHint
argument_list|,
name|excessTypes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * We want sufficient redundancy for the block, but we now have too many.    * In this method, copy enough nodes from 'srcNodes' into 'dstNodes' such that:    *    * srcNodes.size() - dstNodes.size() == replication    *    * We pick node that make sure that replicas are spread across racks and    * also try hard to pick one with least free space.    * The algorithm is first to pick a node with least free space from nodes    * that are on a rack holding more than one replicas of the block.    * So removing such a replica won't remove a rack.     * If no such a node is available,    * then pick a node with least free space    */
DECL|method|chooseExcessRedundancyContiguous ( final Collection<DatanodeStorageInfo> nonExcess, BlockInfo storedBlock, short replication, DatanodeDescriptor addedNode, DatanodeDescriptor delNodeHint, List<StorageType> excessTypes)
specifier|private
name|void
name|chooseExcessRedundancyContiguous
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|nonExcess
parameter_list|,
name|BlockInfo
name|storedBlock
parameter_list|,
name|short
name|replication
parameter_list|,
name|DatanodeDescriptor
name|addedNode
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|excessTypes
parameter_list|)
block|{
name|BlockPlacementPolicy
name|replicator
init|=
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|CONTIGUOUS
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|replicasToDelete
init|=
name|replicator
operator|.
name|chooseReplicasToDelete
argument_list|(
name|nonExcess
argument_list|,
name|nonExcess
argument_list|,
name|replication
argument_list|,
name|excessTypes
argument_list|,
name|addedNode
argument_list|,
name|delNodeHint
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|chosenReplica
range|:
name|replicasToDelete
control|)
block|{
name|processChosenExcessRedundancy
argument_list|(
name|nonExcess
argument_list|,
name|chosenReplica
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * We want block group has every internal block, but we have redundant    * internal blocks (which have the same index).    * In this method, we delete the redundant internal blocks until only one    * left for each index.    *    * The block placement policy will make sure that the left internal blocks are    * spread across racks and also try hard to pick one with least free space.    */
DECL|method|chooseExcessRedundancyStriped (BlockCollection bc, final Collection<DatanodeStorageInfo> nonExcess, BlockInfo storedBlock, DatanodeDescriptor delNodeHint)
specifier|private
name|void
name|chooseExcessRedundancyStriped
parameter_list|(
name|BlockCollection
name|bc
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|nonExcess
parameter_list|,
name|BlockInfo
name|storedBlock
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|)
block|{
assert|assert
name|storedBlock
operator|instanceof
name|BlockInfoStriped
assert|;
name|BlockInfoStriped
name|sblk
init|=
operator|(
name|BlockInfoStriped
operator|)
name|storedBlock
decl_stmt|;
name|short
name|groupSize
init|=
name|sblk
operator|.
name|getTotalBlockNum
argument_list|()
decl_stmt|;
comment|// find all duplicated indices
name|BitSet
name|found
init|=
operator|new
name|BitSet
argument_list|(
name|groupSize
argument_list|)
decl_stmt|;
comment|//indices found
name|BitSet
name|duplicated
init|=
operator|new
name|BitSet
argument_list|(
name|groupSize
argument_list|)
decl_stmt|;
comment|//indices found more than once
name|HashMap
argument_list|<
name|DatanodeStorageInfo
argument_list|,
name|Integer
argument_list|>
name|storage2index
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|nonExcess
control|)
block|{
name|int
name|index
init|=
name|sblk
operator|.
name|getStorageBlockIndex
argument_list|(
name|storage
argument_list|)
decl_stmt|;
assert|assert
name|index
operator|>=
literal|0
assert|;
if|if
condition|(
name|found
operator|.
name|get
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|duplicated
operator|.
name|set
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
name|found
operator|.
name|set
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|storage2index
operator|.
name|put
argument_list|(
name|storage
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// use delHint only if delHint is duplicated
specifier|final
name|DatanodeStorageInfo
name|delStorageHint
init|=
name|DatanodeStorageInfo
operator|.
name|getDatanodeStorageInfo
argument_list|(
name|nonExcess
argument_list|,
name|delNodeHint
argument_list|)
decl_stmt|;
if|if
condition|(
name|delStorageHint
operator|!=
literal|null
condition|)
block|{
name|Integer
name|index
init|=
name|storage2index
operator|.
name|get
argument_list|(
name|delStorageHint
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
operator|&&
name|duplicated
operator|.
name|get
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|processChosenExcessRedundancy
argument_list|(
name|nonExcess
argument_list|,
name|delStorageHint
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
block|}
block|}
comment|// cardinality of found indicates the expected number of internal blocks
specifier|final
name|int
name|numOfTarget
init|=
name|found
operator|.
name|cardinality
argument_list|()
decl_stmt|;
specifier|final
name|BlockStoragePolicy
name|storagePolicy
init|=
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|bc
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|StorageType
argument_list|>
name|excessTypes
init|=
name|storagePolicy
operator|.
name|chooseExcess
argument_list|(
operator|(
name|short
operator|)
name|numOfTarget
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageTypes
argument_list|(
name|nonExcess
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|excessTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"excess types chosen for block {} among storages {} is empty"
argument_list|,
name|storedBlock
argument_list|,
name|nonExcess
argument_list|)
expr_stmt|;
return|return;
block|}
name|BlockPlacementPolicy
name|placementPolicy
init|=
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|STRIPED
argument_list|)
decl_stmt|;
comment|// for each duplicated index, delete some replicas until only one left
for|for
control|(
name|int
name|targetIndex
init|=
name|duplicated
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|targetIndex
operator|>=
literal|0
condition|;
name|targetIndex
operator|=
name|duplicated
operator|.
name|nextSetBit
argument_list|(
name|targetIndex
operator|+
literal|1
argument_list|)
control|)
block|{
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|candidates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|nonExcess
control|)
block|{
name|int
name|index
init|=
name|storage2index
operator|.
name|get
argument_list|(
name|storage
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
name|targetIndex
condition|)
block|{
name|candidates
operator|.
name|add
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|candidates
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|replicasToDelete
init|=
name|placementPolicy
operator|.
name|chooseReplicasToDelete
argument_list|(
name|nonExcess
argument_list|,
name|candidates
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
name|excessTypes
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|chosen
range|:
name|replicasToDelete
control|)
block|{
name|processChosenExcessRedundancy
argument_list|(
name|nonExcess
argument_list|,
name|chosen
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
name|candidates
operator|.
name|remove
argument_list|(
name|chosen
argument_list|)
expr_stmt|;
block|}
block|}
name|duplicated
operator|.
name|clear
argument_list|(
name|targetIndex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processChosenExcessRedundancy ( final Collection<DatanodeStorageInfo> nonExcess, final DatanodeStorageInfo chosen, BlockInfo storedBlock)
specifier|private
name|void
name|processChosenExcessRedundancy
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|nonExcess
parameter_list|,
specifier|final
name|DatanodeStorageInfo
name|chosen
parameter_list|,
name|BlockInfo
name|storedBlock
parameter_list|)
block|{
name|nonExcess
operator|.
name|remove
argument_list|(
name|chosen
argument_list|)
expr_stmt|;
name|excessRedundancyMap
operator|.
name|add
argument_list|(
name|chosen
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
comment|//
comment|// The 'excessblocks' tracks blocks until we get confirmation
comment|// that the datanode has deleted them; the only way we remove them
comment|// is when we get a "removeBlock" message.
comment|//
comment|// The 'invalidate' list is used to inform the datanode the block
comment|// should be deleted.  Items are removed from the invalidate list
comment|// upon giving instructions to the datanodes.
comment|//
specifier|final
name|Block
name|blockToInvalidate
init|=
name|getBlockOnStorage
argument_list|(
name|storedBlock
argument_list|,
name|chosen
argument_list|)
decl_stmt|;
name|addToInvalidates
argument_list|(
name|blockToInvalidate
argument_list|,
name|chosen
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* chooseExcessRedundancies: "
operator|+
literal|"({}, {}) is added to invalidated blocks set"
argument_list|,
name|chosen
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
block|}
DECL|method|removeStoredBlock (DatanodeStorageInfo storageInfo, Block block, DatanodeDescriptor node)
specifier|private
name|void
name|removeStoredBlock
parameter_list|(
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|Block
name|block
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
if|if
condition|(
name|shouldPostponeBlocksFromFuture
operator|&&
name|isGenStampInFuture
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|block
argument_list|,
literal|null
argument_list|,
name|QUEUE_REASON_FUTURE_GENSTAMP
argument_list|)
expr_stmt|;
return|return;
block|}
name|removeStoredBlock
argument_list|(
name|getStoredBlock
argument_list|(
name|block
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify (block{@literal -->}datanode) map. Possibly generate replication    * tasks, if the removed block is still valid.    */
DECL|method|removeStoredBlock (BlockInfo storedBlock, DatanodeDescriptor node)
specifier|public
name|void
name|removeStoredBlock
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* removeStoredBlock: {} from {}"
argument_list|,
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
block|{
if|if
condition|(
name|storedBlock
operator|==
literal|null
operator|||
operator|!
name|blocksMap
operator|.
name|removeNode
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* removeStoredBlock: {} has already been"
operator|+
literal|" removed from node {}"
argument_list|,
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
name|CachedBlock
name|cblock
init|=
name|namesystem
operator|.
name|getCacheManager
argument_list|()
operator|.
name|getCachedBlocks
argument_list|()
operator|.
name|get
argument_list|(
operator|new
name|CachedBlock
argument_list|(
name|storedBlock
operator|.
name|getBlockId
argument_list|()
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cblock
operator|!=
literal|null
condition|)
block|{
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
name|removed
operator||=
name|node
operator|.
name|getPendingCached
argument_list|()
operator|.
name|remove
argument_list|(
name|cblock
argument_list|)
expr_stmt|;
name|removed
operator||=
name|node
operator|.
name|getCached
argument_list|()
operator|.
name|remove
argument_list|(
name|cblock
argument_list|)
expr_stmt|;
name|removed
operator||=
name|node
operator|.
name|getPendingUncached
argument_list|()
operator|.
name|remove
argument_list|(
name|cblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* removeStoredBlock: {} removed from caching "
operator|+
literal|"related lists on node {}"
argument_list|,
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// It's possible that the block was removed because of a datanode
comment|// failure. If the block is still valid, check if replication is
comment|// necessary. In that case, put block on a possibly-will-
comment|// be-replicated list.
comment|//
if|if
condition|(
operator|!
name|storedBlock
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
name|bmSafeMode
operator|.
name|decrementSafeBlockCount
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
name|updateNeededReconstructions
argument_list|(
name|storedBlock
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|excessRedundancyMap
operator|.
name|remove
argument_list|(
name|node
argument_list|,
name|storedBlock
argument_list|)
expr_stmt|;
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeStaleReplicas (List<ReplicaUnderConstruction> staleReplicas, BlockInfo block)
specifier|private
name|void
name|removeStaleReplicas
parameter_list|(
name|List
argument_list|<
name|ReplicaUnderConstruction
argument_list|>
name|staleReplicas
parameter_list|,
name|BlockInfo
name|block
parameter_list|)
block|{
for|for
control|(
name|ReplicaUnderConstruction
name|r
range|:
name|staleReplicas
control|)
block|{
name|removeStoredBlock
argument_list|(
name|block
argument_list|,
name|r
operator|.
name|getExpectedStorageLocation
argument_list|()
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|blockStateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* Removing stale replica {}"
operator|+
literal|" of {}"
argument_list|,
name|r
argument_list|,
name|Block
operator|.
name|toString
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get all valid locations of the block& add the block to results    * @return the length of the added block; 0 if the block is not added. If the    * added block is a block group, return its approximate internal block size    */
DECL|method|addBlock (BlockInfo block, List<BlockWithLocations> results)
specifier|private
name|long
name|addBlock
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|List
argument_list|<
name|BlockWithLocations
argument_list|>
name|results
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|locations
init|=
name|getValidLocations
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|locations
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
specifier|final
name|String
index|[]
name|datanodeUuids
init|=
operator|new
name|String
index|[
name|locations
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|String
index|[]
name|storageIDs
init|=
operator|new
name|String
index|[
name|datanodeUuids
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|StorageType
index|[]
name|storageTypes
init|=
operator|new
name|StorageType
index|[
name|datanodeUuids
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locations
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|DatanodeStorageInfo
name|s
init|=
name|locations
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|datanodeUuids
index|[
name|i
index|]
operator|=
name|s
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|.
name|getDatanodeUuid
argument_list|()
expr_stmt|;
name|storageIDs
index|[
name|i
index|]
operator|=
name|s
operator|.
name|getStorageID
argument_list|()
expr_stmt|;
name|storageTypes
index|[
name|i
index|]
operator|=
name|s
operator|.
name|getStorageType
argument_list|()
expr_stmt|;
block|}
name|BlockWithLocations
name|blkWithLocs
init|=
operator|new
name|BlockWithLocations
argument_list|(
name|block
argument_list|,
name|datanodeUuids
argument_list|,
name|storageIDs
argument_list|,
name|storageTypes
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|BlockInfoStriped
name|blockStriped
init|=
operator|(
name|BlockInfoStriped
operator|)
name|block
decl_stmt|;
name|byte
index|[]
name|indices
init|=
operator|new
name|byte
index|[
name|locations
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locations
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|indices
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|blockStriped
operator|.
name|getStorageBlockIndex
argument_list|(
name|locations
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|results
operator|.
name|add
argument_list|(
operator|new
name|StripedBlockWithLocations
argument_list|(
name|blkWithLocs
argument_list|,
name|indices
argument_list|,
name|blockStriped
operator|.
name|getDataBlockNum
argument_list|()
argument_list|,
name|blockStriped
operator|.
name|getCellSize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// approximate size
return|return
name|block
operator|.
name|getNumBytes
argument_list|()
operator|/
name|blockStriped
operator|.
name|getDataBlockNum
argument_list|()
return|;
block|}
else|else
block|{
name|results
operator|.
name|add
argument_list|(
name|blkWithLocs
argument_list|)
expr_stmt|;
return|return
name|block
operator|.
name|getNumBytes
argument_list|()
return|;
block|}
block|}
block|}
comment|/**    * The given node is reporting that it received a certain block.    */
annotation|@
name|VisibleForTesting
DECL|method|addBlock (DatanodeStorageInfo storageInfo, Block block, String delHint)
specifier|public
name|void
name|addBlock
parameter_list|(
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|Block
name|block
parameter_list|,
name|String
name|delHint
parameter_list|)
throws|throws
name|IOException
block|{
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
comment|// Decrement number of blocks scheduled to this datanode.
comment|// for a retry request (of DatanodeProtocol#blockReceivedAndDeleted with
comment|// RECEIVED_BLOCK), we currently also decrease the approximate number.
name|node
operator|.
name|decrementBlocksScheduled
argument_list|(
name|storageInfo
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
comment|// get the deletion hint node
name|DatanodeDescriptor
name|delHintNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|delHint
operator|!=
literal|null
operator|&&
name|delHint
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|delHintNode
operator|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|delHint
argument_list|)
expr_stmt|;
if|if
condition|(
name|delHintNode
operator|==
literal|null
condition|)
block|{
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* blockReceived: {} is expected to be removed "
operator|+
literal|"from an unrecorded node {}"
argument_list|,
name|block
argument_list|,
name|delHint
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Modify the blocks->datanode map and node's map.
comment|//
name|BlockInfo
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|!=
literal|null
operator|&&
name|block
operator|.
name|getGenerationStamp
argument_list|()
operator|==
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
if|if
condition|(
name|pendingReconstruction
operator|.
name|decrement
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
operator|.
name|incSuccessfulReReplications
argument_list|()
expr_stmt|;
block|}
block|}
name|processAndHandleReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|block
argument_list|,
name|ReplicaState
operator|.
name|FINALIZED
argument_list|,
name|delHintNode
argument_list|)
expr_stmt|;
block|}
DECL|method|processAndHandleReportedBlock ( DatanodeStorageInfo storageInfo, Block block, ReplicaState reportedState, DatanodeDescriptor delHintNode)
specifier|private
name|void
name|processAndHandleReportedBlock
parameter_list|(
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|Block
name|block
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|,
name|DatanodeDescriptor
name|delHintNode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reported block {} on {} size {} replicaState = {}"
argument_list|,
name|block
argument_list|,
name|node
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|reportedState
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldPostponeBlocksFromFuture
operator|&&
name|isGenStampInFuture
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|block
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_FUTURE_GENSTAMP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// find block by blockId
name|BlockInfo
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
comment|// If blocksMap does not contain reported block id,
comment|// the replica should be removed from the data-node.
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* addBlock: block {} on node {} size {} does not "
operator|+
literal|"belong to any file"
argument_list|,
name|block
argument_list|,
name|node
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
operator|new
name|Block
argument_list|(
name|block
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
name|BlockUCState
name|ucState
init|=
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
comment|// Block is on the NN
name|LOG
operator|.
name|debug
argument_list|(
literal|"In memory blockUCState = {}"
argument_list|,
name|ucState
argument_list|)
expr_stmt|;
comment|// Ignore replicas already scheduled to be removed from the DN
if|if
condition|(
name|invalidateBlocks
operator|.
name|contains
argument_list|(
name|node
argument_list|,
name|block
argument_list|)
condition|)
block|{
return|return;
block|}
name|BlockToMarkCorrupt
name|c
init|=
name|checkReplicaCorrupt
argument_list|(
name|block
argument_list|,
name|reportedState
argument_list|,
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|shouldPostponeBlocksFromFuture
condition|)
block|{
comment|// If the block is an out-of-date generation stamp or state,
comment|// but we're the standby, we shouldn't treat it as corrupt,
comment|// but instead just queue it for later processing.
comment|// TODO: Pretty confident this should be s/storedBlock/block below,
comment|// since we should be postponing the info of the reported block, not
comment|// the stored block. See HDFS-6289 for more context.
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|storedBlock
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_CORRUPT_STATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|markBlockAsCorrupt
argument_list|(
name|c
argument_list|,
name|storageInfo
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|isBlockUnderConstruction
argument_list|(
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|reportedState
argument_list|)
condition|)
block|{
name|addStoredBlockUnderConstruction
argument_list|(
operator|new
name|StatefulBlockInfo
argument_list|(
name|storedBlock
argument_list|,
operator|new
name|Block
argument_list|(
name|block
argument_list|)
argument_list|,
name|reportedState
argument_list|)
argument_list|,
name|storageInfo
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Add replica if appropriate. If the replica was previously corrupt
comment|// but now okay, it might need to be updated.
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
operator|(
name|storedBlock
operator|.
name|findStorageInfo
argument_list|(
name|storageInfo
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|corruptReplicas
operator|.
name|isReplicaCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
operator|)
condition|)
block|{
name|addStoredBlock
argument_list|(
name|storedBlock
argument_list|,
name|block
argument_list|,
name|storageInfo
argument_list|,
name|delHintNode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The given node is reporting incremental information about some blocks.    * This includes blocks that are starting to be received, completed being    * received, or deleted.    *     * This method must be called with FSNamesystem lock held.    */
DECL|method|processIncrementalBlockReport (final DatanodeID nodeID, final StorageReceivedDeletedBlocks srdb)
specifier|public
name|void
name|processIncrementalBlockReport
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|,
specifier|final
name|StorageReceivedDeletedBlocks
name|srdb
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|nodeID
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|||
operator|!
name|node
operator|.
name|isRegistered
argument_list|()
condition|)
block|{
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* processIncrementalBlockReport"
operator|+
literal|" is received from dead or unregistered node {}"
argument_list|,
name|nodeID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got incremental block report from unregistered or dead node"
argument_list|)
throw|;
block|}
name|boolean
name|successful
init|=
literal|false
decl_stmt|;
try|try
block|{
name|processIncrementalBlockReport
argument_list|(
name|node
argument_list|,
name|srdb
argument_list|)
expr_stmt|;
name|successful
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|successful
condition|)
block|{
name|node
operator|.
name|setForceRegistration
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|processIncrementalBlockReport (final DatanodeDescriptor node, final StorageReceivedDeletedBlocks srdb)
specifier|private
name|void
name|processIncrementalBlockReport
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|node
parameter_list|,
specifier|final
name|StorageReceivedDeletedBlocks
name|srdb
parameter_list|)
throws|throws
name|IOException
block|{
name|DatanodeStorageInfo
name|storageInfo
init|=
name|node
operator|.
name|getStorageInfo
argument_list|(
name|srdb
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageInfo
operator|==
literal|null
condition|)
block|{
comment|// The DataNode is reporting an unknown storage. Usually the NN learns
comment|// about new storages from heartbeats but during NN restart we may
comment|// receive a block report or incremental report before the heartbeat.
comment|// We must handle this for protocol compatibility. This issue was
comment|// uncovered by HDFS-6094.
name|storageInfo
operator|=
name|node
operator|.
name|updateStorage
argument_list|(
name|srdb
operator|.
name|getStorage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|received
init|=
literal|0
decl_stmt|;
name|int
name|deleted
init|=
literal|0
decl_stmt|;
name|int
name|receiving
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ReceivedDeletedBlockInfo
name|rdbi
range|:
name|srdb
operator|.
name|getBlocks
argument_list|()
control|)
block|{
switch|switch
condition|(
name|rdbi
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|DELETED_BLOCK
case|:
name|removeStoredBlock
argument_list|(
name|storageInfo
argument_list|,
name|rdbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|deleted
operator|++
expr_stmt|;
break|break;
case|case
name|RECEIVED_BLOCK
case|:
name|addBlock
argument_list|(
name|storageInfo
argument_list|,
name|rdbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|rdbi
operator|.
name|getDelHints
argument_list|()
argument_list|)
expr_stmt|;
name|received
operator|++
expr_stmt|;
break|break;
case|case
name|RECEIVING_BLOCK
case|:
name|receiving
operator|++
expr_stmt|;
name|processAndHandleReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|rdbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|ReplicaState
operator|.
name|RBW
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
default|default:
name|String
name|msg
init|=
literal|"Unknown block status code reported by "
operator|+
name|node
operator|+
literal|": "
operator|+
name|rdbi
decl_stmt|;
name|blockLog
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
assert|assert
literal|false
operator|:
name|msg
assert|;
comment|// if assertions are enabled, throw.
break|break;
block|}
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* block {}: {} is received from {}"
argument_list|,
name|rdbi
operator|.
name|getStatus
argument_list|()
argument_list|,
name|rdbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|blockLog
operator|.
name|debug
argument_list|(
literal|"*BLOCK* NameNode.processIncrementalBlockReport: from "
operator|+
literal|"{} receiving: {}, received: {}, deleted: {}"
argument_list|,
name|node
argument_list|,
name|receiving
argument_list|,
name|received
argument_list|,
name|deleted
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the number of nodes hosting a given block, grouped    * by the state of those replicas.    * For a striped block, this includes nodes storing blocks belonging to the    * striped block group. But note we exclude duplicated internal block replicas    * for calculating {@link NumberReplicas#liveReplicas}.    */
DECL|method|countNodes (BlockInfo b)
specifier|public
name|NumberReplicas
name|countNodes
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
return|return
name|countNodes
argument_list|(
name|b
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|countNodes (BlockInfo b, boolean inStartupSafeMode)
name|NumberReplicas
name|countNodes
parameter_list|(
name|BlockInfo
name|b
parameter_list|,
name|boolean
name|inStartupSafeMode
parameter_list|)
block|{
name|NumberReplicas
name|numberReplicas
init|=
operator|new
name|NumberReplicas
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesCorrupt
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|countReplicasForStripedBlock
argument_list|(
name|numberReplicas
argument_list|,
operator|(
name|BlockInfoStriped
operator|)
name|b
argument_list|,
name|nodesCorrupt
argument_list|,
name|inStartupSafeMode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|b
argument_list|)
control|)
block|{
name|checkReplicaOnStorage
argument_list|(
name|numberReplicas
argument_list|,
name|b
argument_list|,
name|storage
argument_list|,
name|nodesCorrupt
argument_list|,
name|inStartupSafeMode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|numberReplicas
return|;
block|}
DECL|method|checkReplicaOnStorage (NumberReplicas counters, BlockInfo b, DatanodeStorageInfo storage, Collection<DatanodeDescriptor> nodesCorrupt, boolean inStartupSafeMode)
specifier|private
name|StoredReplicaState
name|checkReplicaOnStorage
parameter_list|(
name|NumberReplicas
name|counters
parameter_list|,
name|BlockInfo
name|b
parameter_list|,
name|DatanodeStorageInfo
name|storage
parameter_list|,
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesCorrupt
parameter_list|,
name|boolean
name|inStartupSafeMode
parameter_list|)
block|{
specifier|final
name|StoredReplicaState
name|s
decl_stmt|;
if|if
condition|(
name|storage
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|NORMAL
condition|)
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodesCorrupt
operator|!=
literal|null
operator|&&
name|nodesCorrupt
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|s
operator|=
name|StoredReplicaState
operator|.
name|CORRUPT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inStartupSafeMode
condition|)
block|{
name|s
operator|=
name|StoredReplicaState
operator|.
name|LIVE
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
name|s
operator|=
name|StoredReplicaState
operator|.
name|DECOMMISSIONING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
name|s
operator|=
name|StoredReplicaState
operator|.
name|DECOMMISSIONED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isMaintenance
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isInMaintenance
argument_list|()
operator|||
operator|!
name|node
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|s
operator|=
name|StoredReplicaState
operator|.
name|MAINTENANCE_NOT_FOR_READ
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|StoredReplicaState
operator|.
name|MAINTENANCE_FOR_READ
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isExcess
argument_list|(
name|node
argument_list|,
name|b
argument_list|)
condition|)
block|{
name|s
operator|=
name|StoredReplicaState
operator|.
name|EXCESS
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|StoredReplicaState
operator|.
name|LIVE
expr_stmt|;
block|}
name|counters
operator|.
name|add
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|.
name|areBlockContentsStale
argument_list|()
condition|)
block|{
name|counters
operator|.
name|add
argument_list|(
name|StoredReplicaState
operator|.
name|STALESTORAGE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|inStartupSafeMode
operator|&&
name|storage
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|READ_ONLY_SHARED
condition|)
block|{
name|s
operator|=
name|StoredReplicaState
operator|.
name|READONLY
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**    * For a striped block, it is possible it contains full number of internal    * blocks (i.e., 9 by default), but with duplicated replicas of the same    * internal block. E.g., for the following list of internal blocks    * b0, b0, b1, b2, b3, b4, b5, b6, b7    * we have 9 internal blocks but we actually miss b8.    * We should use this method to detect the above scenario and schedule    * necessary reconstruction.    */
DECL|method|countReplicasForStripedBlock (NumberReplicas counters, BlockInfoStriped block, Collection<DatanodeDescriptor> nodesCorrupt, boolean inStartupSafeMode)
specifier|private
name|void
name|countReplicasForStripedBlock
parameter_list|(
name|NumberReplicas
name|counters
parameter_list|,
name|BlockInfoStriped
name|block
parameter_list|,
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesCorrupt
parameter_list|,
name|boolean
name|inStartupSafeMode
parameter_list|)
block|{
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|(
name|block
operator|.
name|getTotalBlockNum
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageAndBlockIndex
name|si
range|:
name|block
operator|.
name|getStorageAndIndexInfos
argument_list|()
control|)
block|{
name|StoredReplicaState
name|state
init|=
name|checkReplicaOnStorage
argument_list|(
name|counters
argument_list|,
name|block
argument_list|,
name|si
operator|.
name|getStorage
argument_list|()
argument_list|,
name|nodesCorrupt
argument_list|,
name|inStartupSafeMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|StoredReplicaState
operator|.
name|LIVE
condition|)
block|{
if|if
condition|(
operator|!
name|bitSet
operator|.
name|get
argument_list|(
name|si
operator|.
name|getBlockIndex
argument_list|()
argument_list|)
condition|)
block|{
name|bitSet
operator|.
name|set
argument_list|(
name|si
operator|.
name|getBlockIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|counters
operator|.
name|subtract
argument_list|(
name|StoredReplicaState
operator|.
name|LIVE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counters
operator|.
name|add
argument_list|(
name|StoredReplicaState
operator|.
name|REDUNDANT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getExcessSize4Testing (String dnUuid)
name|int
name|getExcessSize4Testing
parameter_list|(
name|String
name|dnUuid
parameter_list|)
block|{
return|return
name|excessRedundancyMap
operator|.
name|getSize4Testing
argument_list|(
name|dnUuid
argument_list|)
return|;
block|}
DECL|method|isExcess (DatanodeDescriptor dn, BlockInfo blk)
specifier|public
name|boolean
name|isExcess
parameter_list|(
name|DatanodeDescriptor
name|dn
parameter_list|,
name|BlockInfo
name|blk
parameter_list|)
block|{
return|return
name|excessRedundancyMap
operator|.
name|contains
argument_list|(
name|dn
argument_list|,
name|blk
argument_list|)
return|;
block|}
comment|/**     * Simpler, faster form of {@link #countNodes} that only returns the number    * of live nodes.  If in startup safemode (or its 30-sec extension period),    * then it gains speed by ignoring issues of excess replicas or nodes    * that are decommissioned or in process of becoming decommissioned.    * If not in startup, then it calls {@link #countNodes} instead.    *    * @param b - the block being tested    * @return count of live nodes for this block    */
DECL|method|countLiveNodes (BlockInfo b)
name|int
name|countLiveNodes
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
specifier|final
name|boolean
name|inStartupSafeMode
init|=
name|namesystem
operator|.
name|isInStartupSafeMode
argument_list|()
decl_stmt|;
return|return
name|countNodes
argument_list|(
name|b
argument_list|,
name|inStartupSafeMode
argument_list|)
operator|.
name|liveReplicas
argument_list|()
return|;
block|}
comment|/**    * On putting the node in service, check if the node has excess replicas.    * If there are any excess replicas, call processExtraRedundancyBlock().    * Process extra redundancy blocks only when active NN is out of safe mode.    */
DECL|method|processExtraRedundancyBlocksOnInService ( final DatanodeDescriptor srcNode)
name|void
name|processExtraRedundancyBlocksOnInService
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|srcNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return;
block|}
name|int
name|numExtraRedundancy
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|datanodeStorageInfo
range|:
name|srcNode
operator|.
name|getStorageInfos
argument_list|()
control|)
block|{
comment|// the namesystem lock is released between iterations. Make sure the
comment|// storage is not removed before continuing.
if|if
condition|(
name|srcNode
operator|.
name|getStorageInfo
argument_list|(
name|datanodeStorageInfo
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
specifier|final
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|it
init|=
name|datanodeStorageInfo
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|BlockInfo
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
comment|//Orphan block, will be handled eventually, skip
continue|continue;
block|}
name|int
name|expectedReplication
init|=
name|this
operator|.
name|getExpectedRedundancyNum
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldProcessExtraRedundancy
argument_list|(
name|num
argument_list|,
name|expectedReplication
argument_list|)
condition|)
block|{
comment|// extra redundancy block
name|processExtraRedundancyBlock
argument_list|(
name|block
argument_list|,
operator|(
name|short
operator|)
name|expectedReplication
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|numExtraRedundancy
operator|++
expr_stmt|;
block|}
block|}
comment|// When called by tests like TestDefaultBlockPlacementPolicy.
comment|// testPlacementWithLocalRackNodesDecommissioned, it is not protected by
comment|// lock, only when called by DatanodeManager.refreshNodes have writeLock
if|if
condition|(
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
condition|)
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Invalidated {} extra redundancy blocks on {} after "
operator|+
literal|"it is in service"
argument_list|,
name|numExtraRedundancy
argument_list|,
name|srcNode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns whether a node can be safely decommissioned or in maintenance    * based on its liveness. Dead nodes cannot always be safely decommissioned    * or in maintenance.    */
DECL|method|isNodeHealthyForDecommissionOrMaintenance (DatanodeDescriptor node)
name|boolean
name|isNodeHealthyForDecommissionOrMaintenance
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|.
name|checkBlockReportReceived
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Node {} hasn't sent its first block report."
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|node
operator|.
name|isAlive
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|updateState
argument_list|()
expr_stmt|;
if|if
condition|(
name|pendingReconstructionBlocksCount
operator|==
literal|0
operator|&&
name|lowRedundancyBlocksCount
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Node {} is dead and there are no low redundancy"
operator|+
literal|" blocks or blocks pending reconstruction. Safe to decommission or"
argument_list|,
literal|" put in maintenance."
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Node {} is dead "
operator|+
literal|"while in {}. Cannot be safely "
operator|+
literal|"decommissioned or be in maintenance since there is risk of reduced "
operator|+
literal|"data durability or data loss. Either restart the failed node or "
operator|+
literal|"force decommissioning or maintenance by removing, calling "
operator|+
literal|"refreshNodes, then re-adding to the excludes or host config files."
argument_list|,
name|node
argument_list|,
name|node
operator|.
name|getAdminState
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|getActiveBlockCount ()
specifier|public
name|int
name|getActiveBlockCount
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getStorages (BlockInfo block)
specifier|public
name|DatanodeStorageInfo
index|[]
name|getStorages
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
specifier|final
name|DatanodeStorageInfo
index|[]
name|storages
init|=
operator|new
name|DatanodeStorageInfo
index|[
name|block
operator|.
name|numNodes
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|s
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
name|storages
index|[
name|i
operator|++
index|]
operator|=
name|s
expr_stmt|;
block|}
return|return
name|storages
return|;
block|}
comment|/** @return an iterator of the datanodes. */
DECL|method|getStorages (final Block block)
specifier|public
name|Iterable
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|getStorages
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|getTotalBlocks ()
specifier|public
name|int
name|getTotalBlocks
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|removeBlock (BlockInfo block)
specifier|public
name|void
name|removeBlock
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
comment|// No need to ACK blocks that are being removed entirely
comment|// from the namespace, since the removal of the associated
comment|// file already removes them from the block map below.
name|block
operator|.
name|setNumBytes
argument_list|(
name|BlockCommand
operator|.
name|NO_ACK
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|removeBlockFromMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// Remove the block from pendingReconstruction and neededReconstruction
name|pendingReconstruction
operator|.
name|remove
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|neededReconstruction
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|LowRedundancyBlocks
operator|.
name|LEVEL
argument_list|)
expr_stmt|;
name|postponedMisreplicatedBlocks
operator|.
name|remove
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
DECL|method|getStoredBlock (Block block)
specifier|public
name|BlockInfo
name|getStoredBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
if|if
condition|(
operator|!
name|BlockIdManager
operator|.
name|isStripedBlockID
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|hasNonEcBlockUsingStripedID
condition|)
block|{
return|return
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|BlockIdManager
operator|.
name|convertToStripedID
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|BlockInfo
name|info
init|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
return|return
name|info
return|;
block|}
return|return
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
operator|new
name|Block
argument_list|(
name|BlockIdManager
operator|.
name|convertToStripedID
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|updateLastBlock (BlockInfo lastBlock, ExtendedBlock newBlock)
specifier|public
name|void
name|updateLastBlock
parameter_list|(
name|BlockInfo
name|lastBlock
parameter_list|,
name|ExtendedBlock
name|newBlock
parameter_list|)
block|{
name|lastBlock
operator|.
name|setNumBytes
argument_list|(
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ReplicaUnderConstruction
argument_list|>
name|staleReplicas
init|=
name|lastBlock
operator|.
name|setGenerationStampAndVerifyReplicas
argument_list|(
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
name|removeStaleReplicas
argument_list|(
name|staleReplicas
argument_list|,
name|lastBlock
argument_list|)
expr_stmt|;
block|}
comment|/** updates a block in needed reconstruction queue. */
DECL|method|updateNeededReconstructions (final BlockInfo block, final int curReplicasDelta, int expectedReplicasDelta)
specifier|private
name|void
name|updateNeededReconstructions
parameter_list|(
specifier|final
name|BlockInfo
name|block
parameter_list|,
specifier|final
name|int
name|curReplicasDelta
parameter_list|,
name|int
name|expectedReplicasDelta
parameter_list|)
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isPopulatingReplQueues
argument_list|()
operator|||
operator|!
name|block
operator|.
name|isComplete
argument_list|()
condition|)
block|{
return|return;
block|}
name|NumberReplicas
name|repl
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|pendingNum
init|=
name|pendingReconstruction
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|curExpectedReplicas
init|=
name|getExpectedRedundancyNum
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasEnoughEffectiveReplicas
argument_list|(
name|block
argument_list|,
name|repl
argument_list|,
name|pendingNum
argument_list|)
condition|)
block|{
name|neededReconstruction
operator|.
name|update
argument_list|(
name|block
argument_list|,
name|repl
operator|.
name|liveReplicas
argument_list|()
operator|+
name|pendingNum
argument_list|,
name|repl
operator|.
name|readOnlyReplicas
argument_list|()
argument_list|,
name|repl
operator|.
name|outOfServiceReplicas
argument_list|()
argument_list|,
name|curExpectedReplicas
argument_list|,
name|curReplicasDelta
argument_list|,
name|expectedReplicasDelta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|oldReplicas
init|=
name|repl
operator|.
name|liveReplicas
argument_list|()
operator|+
name|pendingNum
operator|-
name|curReplicasDelta
decl_stmt|;
name|int
name|oldExpectedReplicas
init|=
name|curExpectedReplicas
operator|-
name|expectedReplicasDelta
decl_stmt|;
name|neededReconstruction
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|oldReplicas
argument_list|,
name|repl
operator|.
name|readOnlyReplicas
argument_list|()
argument_list|,
name|repl
operator|.
name|outOfServiceReplicas
argument_list|()
argument_list|,
name|oldExpectedReplicas
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check sufficient redundancy of the blocks in the collection. If any block    * is needed reconstruction, insert it into the reconstruction queue.    * Otherwise, if the block is more than the expected replication factor,    * process it as an extra redundancy block.    */
DECL|method|checkRedundancy (BlockCollection bc)
specifier|public
name|void
name|checkRedundancy
parameter_list|(
name|BlockCollection
name|bc
parameter_list|)
block|{
for|for
control|(
name|BlockInfo
name|block
range|:
name|bc
operator|.
name|getBlocks
argument_list|()
control|)
block|{
name|short
name|expected
init|=
name|getExpectedRedundancyNum
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|final
name|NumberReplicas
name|n
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|final
name|int
name|pending
init|=
name|pendingReconstruction
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasEnoughEffectiveReplicas
argument_list|(
name|block
argument_list|,
name|n
argument_list|,
name|pending
argument_list|)
condition|)
block|{
name|neededReconstruction
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|n
operator|.
name|liveReplicas
argument_list|()
operator|+
name|pending
argument_list|,
name|n
operator|.
name|readOnlyReplicas
argument_list|()
argument_list|,
name|n
operator|.
name|outOfServiceReplicas
argument_list|()
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shouldProcessExtraRedundancy
argument_list|(
name|n
argument_list|,
name|expected
argument_list|)
condition|)
block|{
name|processExtraRedundancyBlock
argument_list|(
name|block
argument_list|,
name|expected
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get blocks to invalidate for {@code nodeId}    * in {@link #invalidateBlocks}.    *    * @return number of blocks scheduled for removal during this iteration.    */
DECL|method|invalidateWorkForOneNode (DatanodeInfo dn)
specifier|private
name|int
name|invalidateWorkForOneNode
parameter_list|(
name|DatanodeInfo
name|dn
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Block
argument_list|>
name|toInvalidate
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// blocks should not be replicated or removed if safe mode is on
if|if
condition|(
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"In safemode, not computing reconstruction work"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
try|try
block|{
name|DatanodeDescriptor
name|dnDescriptor
init|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnDescriptor
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DataNode {} cannot be found with UUID {}"
operator|+
literal|", removing block invalidation work."
argument_list|,
name|dn
argument_list|,
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|toInvalidate
operator|=
name|invalidateBlocks
operator|.
name|invalidateWork
argument_list|(
name|dnDescriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|toInvalidate
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
catch|catch
parameter_list|(
name|UnregisteredNodeException
name|une
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* {}: ask {} to delete {}"
argument_list|,
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|dn
argument_list|,
name|toInvalidate
argument_list|)
expr_stmt|;
return|return
name|toInvalidate
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|containsInvalidateBlock (final DatanodeInfo dn, final Block block)
specifier|public
name|boolean
name|containsInvalidateBlock
parameter_list|(
specifier|final
name|DatanodeInfo
name|dn
parameter_list|,
specifier|final
name|Block
name|block
parameter_list|)
block|{
return|return
name|invalidateBlocks
operator|.
name|contains
argument_list|(
name|dn
argument_list|,
name|block
argument_list|)
return|;
block|}
DECL|method|isPlacementPolicySatisfied (BlockInfo storedBlock)
name|boolean
name|isPlacementPolicySatisfied
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|liveNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|storedBlock
argument_list|)
control|)
block|{
if|if
condition|(
name|storage
operator|.
name|getStorageType
argument_list|()
operator|==
name|StorageType
operator|.
name|PROVIDED
operator|&&
name|storage
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|NORMAL
condition|)
block|{
comment|// assume the policy is satisfied for blocks on PROVIDED storage
comment|// as long as the storage is in normal state.
return|return
literal|true
return|;
block|}
specifier|final
name|DatanodeDescriptor
name|cur
init|=
name|getDatanodeDescriptorFromStorage
argument_list|(
name|storage
argument_list|)
decl_stmt|;
comment|// Nodes under maintenance should be counted as valid replicas from
comment|// rack policy point of view.
if|if
condition|(
operator|!
name|cur
operator|.
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|cur
operator|.
name|isDecommissioned
argument_list|()
operator|&&
operator|(
operator|(
name|corruptNodes
operator|==
literal|null
operator|)
operator|||
operator|!
name|corruptNodes
operator|.
name|contains
argument_list|(
name|cur
argument_list|)
operator|)
condition|)
block|{
name|liveNodes
operator|.
name|add
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
name|DatanodeInfo
index|[]
name|locs
init|=
name|liveNodes
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeInfo
index|[
name|liveNodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|BlockType
name|blockType
init|=
name|storedBlock
operator|.
name|getBlockType
argument_list|()
decl_stmt|;
name|BlockPlacementPolicy
name|placementPolicy
init|=
name|placementPolicies
operator|.
name|getPolicy
argument_list|(
name|blockType
argument_list|)
decl_stmt|;
name|int
name|numReplicas
init|=
name|blockType
operator|==
name|STRIPED
condition|?
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|storedBlock
operator|)
operator|.
name|getRealTotalBlockNum
argument_list|()
else|:
name|storedBlock
operator|.
name|getReplication
argument_list|()
decl_stmt|;
return|return
name|placementPolicy
operator|.
name|verifyBlockPlacement
argument_list|(
name|locs
argument_list|,
name|numReplicas
argument_list|)
operator|.
name|isPlacementPolicySatisfied
argument_list|()
return|;
block|}
DECL|method|isNeededReconstructionForMaintenance (BlockInfo storedBlock, NumberReplicas numberReplicas)
name|boolean
name|isNeededReconstructionForMaintenance
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|NumberReplicas
name|numberReplicas
parameter_list|)
block|{
return|return
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|&&
operator|(
name|numberReplicas
operator|.
name|liveReplicas
argument_list|()
operator|<
name|getMinMaintenanceStorageNum
argument_list|(
name|storedBlock
argument_list|)
operator|||
operator|!
name|isPlacementPolicySatisfied
argument_list|(
name|storedBlock
argument_list|)
operator|)
return|;
block|}
DECL|method|isNeededReconstruction (BlockInfo storedBlock, NumberReplicas numberReplicas)
name|boolean
name|isNeededReconstruction
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|NumberReplicas
name|numberReplicas
parameter_list|)
block|{
return|return
name|isNeededReconstruction
argument_list|(
name|storedBlock
argument_list|,
name|numberReplicas
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * A block needs reconstruction if the number of redundancies is less than    * expected or if it does not have enough racks.    */
DECL|method|isNeededReconstruction (BlockInfo storedBlock, NumberReplicas numberReplicas, int pending)
name|boolean
name|isNeededReconstruction
parameter_list|(
name|BlockInfo
name|storedBlock
parameter_list|,
name|NumberReplicas
name|numberReplicas
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
return|return
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|&&
operator|!
name|hasEnoughEffectiveReplicas
argument_list|(
name|storedBlock
argument_list|,
name|numberReplicas
argument_list|,
name|pending
argument_list|)
return|;
block|}
comment|// Exclude maintenance, but make sure it has minimal live replicas
comment|// to satisfy the maintenance requirement.
DECL|method|getExpectedLiveRedundancyNum (BlockInfo block, NumberReplicas numberReplicas)
specifier|public
name|short
name|getExpectedLiveRedundancyNum
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|NumberReplicas
name|numberReplicas
parameter_list|)
block|{
specifier|final
name|short
name|expectedRedundancy
init|=
name|getExpectedRedundancyNum
argument_list|(
name|block
argument_list|)
decl_stmt|;
return|return
operator|(
name|short
operator|)
name|Math
operator|.
name|max
argument_list|(
name|expectedRedundancy
operator|-
name|numberReplicas
operator|.
name|maintenanceReplicas
argument_list|()
argument_list|,
name|getMinMaintenanceStorageNum
argument_list|(
name|block
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getExpectedRedundancyNum (BlockInfo block)
specifier|public
name|short
name|getExpectedRedundancyNum
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
return|return
name|block
operator|.
name|isStriped
argument_list|()
condition|?
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|block
operator|)
operator|.
name|getRealTotalBlockNum
argument_list|()
else|:
name|block
operator|.
name|getReplication
argument_list|()
return|;
block|}
DECL|method|getMissingBlocksCount ()
specifier|public
name|long
name|getMissingBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|this
operator|.
name|neededReconstruction
operator|.
name|getCorruptBlockSize
argument_list|()
return|;
block|}
DECL|method|getMissingReplOneBlocksCount ()
specifier|public
name|long
name|getMissingReplOneBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|this
operator|.
name|neededReconstruction
operator|.
name|getCorruptReplicationOneBlockSize
argument_list|()
return|;
block|}
DECL|method|getHighestPriorityReplicatedBlockCount ()
specifier|public
name|long
name|getHighestPriorityReplicatedBlockCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|neededReconstruction
operator|.
name|getHighestPriorityReplicatedBlockCount
argument_list|()
return|;
block|}
DECL|method|getHighestPriorityECBlockCount ()
specifier|public
name|long
name|getHighestPriorityECBlockCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|neededReconstruction
operator|.
name|getHighestPriorityECBlockCount
argument_list|()
return|;
block|}
DECL|method|addBlockCollection (BlockInfo block, BlockCollection bc)
specifier|public
name|BlockInfo
name|addBlockCollection
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|BlockCollection
name|bc
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|addBlockCollection
argument_list|(
name|block
argument_list|,
name|bc
argument_list|)
return|;
block|}
comment|/**    * Do some check when adding a block to blocksmap.    * For HDFS-7994 to check whether then block is a NonEcBlockUsingStripedID.    *    */
DECL|method|addBlockCollectionWithCheck ( BlockInfo block, BlockCollection bc)
specifier|public
name|BlockInfo
name|addBlockCollectionWithCheck
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|BlockCollection
name|bc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasNonEcBlockUsingStripedID
operator|&&
operator|!
name|block
operator|.
name|isStriped
argument_list|()
operator|&&
name|BlockIdManager
operator|.
name|isStripedBlockID
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
condition|)
block|{
name|hasNonEcBlockUsingStripedID
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|addBlockCollection
argument_list|(
name|block
argument_list|,
name|bc
argument_list|)
return|;
block|}
DECL|method|getBlockCollection (BlockInfo b)
name|BlockCollection
name|getBlockCollection
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
return|return
name|namesystem
operator|.
name|getBlockCollection
argument_list|(
name|b
operator|.
name|getBlockCollectionId
argument_list|()
argument_list|)
return|;
block|}
DECL|method|numCorruptReplicas (Block block)
specifier|public
name|int
name|numCorruptReplicas
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|numCorruptReplicas
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|removeBlockFromMap (BlockInfo block)
specifier|public
name|void
name|removeBlockFromMap
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|info
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
name|excessRedundancyMap
operator|.
name|remove
argument_list|(
name|info
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
name|blocksMap
operator|.
name|removeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// If block is removed from blocksMap remove it from corruptReplicasMap
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
DECL|method|getCapacity ()
specifier|public
name|int
name|getCapacity
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|getCapacity
argument_list|()
return|;
block|}
comment|/**    * Return an iterator over the set of blocks for which there are no replicas.    */
DECL|method|getCorruptReplicaBlockIterator ()
specifier|public
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|getCorruptReplicaBlockIterator
parameter_list|()
block|{
return|return
name|neededReconstruction
operator|.
name|iterator
argument_list|(
name|LowRedundancyBlocks
operator|.
name|QUEUE_WITH_CORRUPT_BLOCKS
argument_list|)
return|;
block|}
comment|/**    * Get the replicas which are corrupt for a given block.    */
DECL|method|getCorruptReplicas (Block block)
specifier|public
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|getCorruptReplicas
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
return|;
block|}
comment|/**   * Get reason for certain corrupted replicas for a given block and a given dn.   */
DECL|method|getCorruptReason (Block block, DatanodeDescriptor node)
specifier|public
name|String
name|getCorruptReason
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|getCorruptReason
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** @return the size of UnderReplicatedBlocks */
DECL|method|numOfUnderReplicatedBlocks ()
specifier|public
name|int
name|numOfUnderReplicatedBlocks
parameter_list|()
block|{
return|return
name|neededReconstruction
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Periodically calls computeBlockRecoveryWork().    */
DECL|class|RedundancyMonitor
specifier|private
class|class
name|RedundancyMonitor
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
try|try
block|{
comment|// Process recovery work only when active NN is out of safe mode.
if|if
condition|(
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
name|computeDatanodeWork
argument_list|()
expr_stmt|;
name|processPendingReconstructions
argument_list|()
expr_stmt|;
name|rescanPostponedMisreplicatedBlocks
argument_list|()
expr_stmt|;
block|}
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|sleep
argument_list|(
name|redundancyRecheckIntervalMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping RedundancyMonitor."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|instanceof
name|InterruptedException
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"RedundancyMonitor received an exception"
operator|+
literal|" while shutting down."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|checkNSRunning
operator|&&
name|t
operator|instanceof
name|InterruptedException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping RedundancyMonitor for testing."
argument_list|)
expr_stmt|;
break|break;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"RedundancyMonitor thread received Runtime exception. "
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Runnable that monitors the fragmentation of the StorageInfo TreeSet and    * compacts it when it falls under a certain threshold.    */
DECL|class|StorageInfoDefragmenter
specifier|private
class|class
name|StorageInfoDefragmenter
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
try|try
block|{
comment|// Check storage efficiency only when active NN is out of safe mode.
if|if
condition|(
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
name|scanAndCompactStorages
argument_list|()
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|storageInfoDefragmentInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping thread."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|instanceof
name|InterruptedException
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received an exception while shutting down."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|checkNSRunning
operator|&&
name|t
operator|instanceof
name|InterruptedException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping for testing."
argument_list|)
expr_stmt|;
break|break;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Thread received Runtime exception."
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|scanAndCompactStorages ()
specifier|private
name|void
name|scanAndCompactStorages
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|datanodesAndStorages
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|datanodeManager
operator|.
name|getDatanodeListForReport
argument_list|(
name|DatanodeReportType
operator|.
name|ALL
argument_list|)
control|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|node
operator|.
name|getStorageInfos
argument_list|()
control|)
block|{
try|try
block|{
name|namesystem
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|double
name|ratio
init|=
name|storage
operator|.
name|treeSetFillRatio
argument_list|()
decl_stmt|;
if|if
condition|(
name|ratio
operator|<
name|storageInfoDefragmentRatio
condition|)
block|{
name|datanodesAndStorages
operator|.
name|add
argument_list|(
name|node
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
name|datanodesAndStorages
operator|.
name|add
argument_list|(
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"StorageInfo TreeSet fill ratio {} : {}{}"
argument_list|,
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|ratio
argument_list|,
operator|(
name|ratio
operator|<
name|storageInfoDefragmentRatio
operator|)
condition|?
literal|" (queued for defragmentation)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|datanodesAndStorages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|datanodesAndStorages
operator|.
name|size
argument_list|()
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|DatanodeDescriptor
name|dn
init|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|datanodesAndStorages
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
specifier|final
name|DatanodeStorageInfo
name|storage
init|=
name|dn
operator|.
name|getStorageInfo
argument_list|(
name|datanodesAndStorages
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storage
operator|!=
literal|null
condition|)
block|{
name|boolean
name|aborted
init|=
operator|!
name|storage
operator|.
name|treeSetCompact
argument_list|(
name|storageInfoDefragmentTimeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|aborted
condition|)
block|{
comment|// Compaction timed out, reset iterator to continue with
comment|// the same storage next iteration.
name|i
operator|-=
literal|2
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"StorageInfo TreeSet defragmented {} : {}{}"
argument_list|,
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|storage
operator|.
name|treeSetFillRatio
argument_list|()
argument_list|,
name|aborted
condition|?
literal|" (aborted)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|// Wait between each iteration
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Compute block replication and block invalidation work that can be scheduled    * on data-nodes. The datanode will be informed of this work at the next    * heartbeat.    *     * @return number of blocks scheduled for replication or removal.    */
DECL|method|computeDatanodeWork ()
name|int
name|computeDatanodeWork
parameter_list|()
block|{
comment|// Blocks should not be replicated or removed if in safe mode.
comment|// It's OK to check safe mode here w/o holding lock, in the worst
comment|// case extra replications will be scheduled, and these will get
comment|// fixed up later.
if|if
condition|(
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|int
name|numlive
init|=
name|heartbeatManager
operator|.
name|getLiveDatanodeCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|blocksToProcess
init|=
name|numlive
operator|*
name|this
operator|.
name|blocksReplWorkMultiplier
decl_stmt|;
specifier|final
name|int
name|nodesToProcess
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|numlive
operator|*
name|this
operator|.
name|blocksInvalidateWorkPct
argument_list|)
decl_stmt|;
name|int
name|workFound
init|=
name|this
operator|.
name|computeBlockReconstructionWork
argument_list|(
name|blocksToProcess
argument_list|)
decl_stmt|;
comment|// Update counters
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|updateState
argument_list|()
expr_stmt|;
name|this
operator|.
name|scheduledReplicationBlocksCount
operator|=
name|workFound
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|workFound
operator|+=
name|this
operator|.
name|computeInvalidateWork
argument_list|(
name|nodesToProcess
argument_list|)
expr_stmt|;
return|return
name|workFound
return|;
block|}
comment|/**    * Clear all queues that hold decisions previously made by    * this NameNode.    */
DECL|method|clearQueues ()
specifier|public
name|void
name|clearQueues
parameter_list|()
block|{
name|neededReconstruction
operator|.
name|clear
argument_list|()
expr_stmt|;
name|pendingReconstruction
operator|.
name|clear
argument_list|()
expr_stmt|;
name|excessRedundancyMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|invalidateBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|datanodeManager
operator|.
name|clearPendingQueues
argument_list|()
expr_stmt|;
name|postponedMisreplicatedBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
DECL|method|newLocatedBlock ( ExtendedBlock b, DatanodeStorageInfo[] storages, long startOffset, boolean corrupt)
specifier|public
specifier|static
name|LocatedBlock
name|newLocatedBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|storages
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|boolean
name|corrupt
parameter_list|)
block|{
comment|// startOffset is unknown
return|return
operator|new
name|LocatedBlock
argument_list|(
name|b
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toDatanodeInfos
argument_list|(
name|storages
argument_list|)
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageIDs
argument_list|(
name|storages
argument_list|)
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageTypes
argument_list|(
name|storages
argument_list|)
argument_list|,
name|startOffset
argument_list|,
name|corrupt
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|newLocatedStripedBlock ( ExtendedBlock b, DatanodeStorageInfo[] storages, byte[] indices, long startOffset, boolean corrupt)
specifier|public
specifier|static
name|LocatedStripedBlock
name|newLocatedStripedBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|storages
parameter_list|,
name|byte
index|[]
name|indices
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|boolean
name|corrupt
parameter_list|)
block|{
comment|// startOffset is unknown
return|return
operator|new
name|LocatedStripedBlock
argument_list|(
name|b
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toDatanodeInfos
argument_list|(
name|storages
argument_list|)
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageIDs
argument_list|(
name|storages
argument_list|)
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageTypes
argument_list|(
name|storages
argument_list|)
argument_list|,
name|indices
argument_list|,
name|startOffset
argument_list|,
name|corrupt
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|newLocatedBlock (ExtendedBlock eb, BlockInfo info, DatanodeStorageInfo[] locs, long offset)
specifier|public
specifier|static
name|LocatedBlock
name|newLocatedBlock
parameter_list|(
name|ExtendedBlock
name|eb
parameter_list|,
name|BlockInfo
name|info
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|locs
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|LocatedBlock
name|lb
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|isStriped
argument_list|()
condition|)
block|{
name|lb
operator|=
name|newLocatedStripedBlock
argument_list|(
name|eb
argument_list|,
name|locs
argument_list|,
name|info
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|getBlockIndices
argument_list|()
argument_list|,
name|offset
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lb
operator|=
name|newLocatedBlock
argument_list|(
name|eb
argument_list|,
name|locs
argument_list|,
name|offset
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|lb
return|;
block|}
comment|/**    * A simple result enum for the result of    * {@link BlockManager#processMisReplicatedBlock(BlockInfo)}.    */
DECL|enum|MisReplicationResult
enum|enum
name|MisReplicationResult
block|{
comment|/** The block should be invalidated since it belongs to a deleted file. */
DECL|enumConstant|INVALID
name|INVALID
block|,
comment|/** The block is currently under-replicated. */
DECL|enumConstant|UNDER_REPLICATED
name|UNDER_REPLICATED
block|,
comment|/** The block is currently over-replicated. */
DECL|enumConstant|OVER_REPLICATED
name|OVER_REPLICATED
block|,
comment|/** A decision can't currently be made about this block. */
DECL|enumConstant|POSTPONE
name|POSTPONE
block|,
comment|/** The block is under construction, so should be ignored. */
DECL|enumConstant|UNDER_CONSTRUCTION
name|UNDER_CONSTRUCTION
block|,
comment|/** The block is properly replicated. */
DECL|enumConstant|OK
name|OK
block|}
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|stopReconstructionInitializer
argument_list|()
expr_stmt|;
name|blocksMap
operator|.
name|close
argument_list|()
expr_stmt|;
name|MBeans
operator|.
name|unregister
argument_list|(
name|mxBeanName
argument_list|)
expr_stmt|;
name|mxBeanName
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|blockIdManager
operator|.
name|clear
argument_list|()
expr_stmt|;
name|clearQueues
argument_list|()
expr_stmt|;
name|blocksMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|getBlockReportLeaseManager ()
specifier|public
name|BlockReportLeaseManager
name|getBlockReportLeaseManager
parameter_list|()
block|{
return|return
name|blockReportLeaseManager
return|;
block|}
annotation|@
name|Override
comment|// BlockStatsMXBean
DECL|method|getStorageTypeStats ()
specifier|public
name|Map
argument_list|<
name|StorageType
argument_list|,
name|StorageTypeStats
argument_list|>
name|getStorageTypeStats
parameter_list|()
block|{
return|return
name|datanodeManager
operator|.
name|getDatanodeStatistics
argument_list|()
operator|.
name|getStorageTypeStats
argument_list|()
return|;
block|}
comment|/**    * Initialize replication queues.    */
DECL|method|initializeReplQueues ()
specifier|public
name|void
name|initializeReplQueues
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"initializing replication queues"
argument_list|)
expr_stmt|;
name|processMisReplicatedBlocks
argument_list|()
expr_stmt|;
name|initializedReplQueues
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Check if replication queues are to be populated    * @return true when node is HAState.Active and not in the very first safemode    */
DECL|method|isPopulatingReplQueues ()
specifier|public
name|boolean
name|isPopulatingReplQueues
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldPopulateReplQueues
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|initializedReplQueues
return|;
block|}
DECL|method|setInitializedReplQueues (boolean v)
specifier|public
name|void
name|setInitializedReplQueues
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
name|this
operator|.
name|initializedReplQueues
operator|=
name|v
expr_stmt|;
block|}
DECL|method|shouldPopulateReplQueues ()
specifier|public
name|boolean
name|shouldPopulateReplQueues
parameter_list|()
block|{
name|HAContext
name|haContext
init|=
name|namesystem
operator|.
name|getHAContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|haContext
operator|==
literal|null
operator|||
name|haContext
operator|.
name|getState
argument_list|()
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|haContext
operator|.
name|getState
argument_list|()
operator|.
name|shouldPopulateReplQueues
argument_list|()
return|;
block|}
DECL|method|getShouldPostponeBlocksFromFuture ()
name|boolean
name|getShouldPostponeBlocksFromFuture
parameter_list|()
block|{
return|return
name|shouldPostponeBlocksFromFuture
return|;
block|}
comment|// async processing of an action, used for IBRs.
DECL|method|enqueueBlockOp (final Runnable action)
specifier|public
name|void
name|enqueueBlockOp
parameter_list|(
specifier|final
name|Runnable
name|action
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|blockReportThread
operator|.
name|enqueue
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|// sync batch processing for a full BR.
DECL|method|runBlockOp (final Callable<T> action)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|runBlockOp
parameter_list|(
specifier|final
name|Callable
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FutureTask
argument_list|<
name|T
argument_list|>
name|future
init|=
operator|new
name|FutureTask
argument_list|<
name|T
argument_list|>
argument_list|(
name|action
argument_list|)
decl_stmt|;
name|enqueueBlockOp
argument_list|(
name|future
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|ee
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|ee
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|==
literal|null
condition|)
block|{
name|cause
operator|=
name|ee
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|cause
operator|instanceof
name|IOException
operator|)
condition|)
block|{
name|cause
operator|=
operator|new
name|IOException
argument_list|(
name|cause
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|(
name|IOException
operator|)
name|cause
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|/**    * Notification of a successful block recovery.    * @param block for which the recovery succeeded    */
DECL|method|successfulBlockRecovery (BlockInfo block)
specifier|public
name|void
name|successfulBlockRecovery
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
name|pendingRecoveryBlocks
operator|.
name|remove
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks whether a recovery attempt has been made for the given block.    * If so, checks whether that attempt has timed out.    * @param b block for which recovery is being attempted    * @return true if no recovery attempt has been made or    *         the previous attempt timed out    */
DECL|method|addBlockRecoveryAttempt (BlockInfo b)
specifier|public
name|boolean
name|addBlockRecoveryAttempt
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
return|return
name|pendingRecoveryBlocks
operator|.
name|add
argument_list|(
name|b
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|flushBlockOps ()
specifier|public
name|void
name|flushBlockOps
parameter_list|()
throws|throws
name|IOException
block|{
name|runBlockOp
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|getBlockOpQueueLength ()
specifier|public
name|int
name|getBlockOpQueueLength
parameter_list|()
block|{
return|return
name|blockReportThread
operator|.
name|queue
operator|.
name|size
argument_list|()
return|;
block|}
DECL|class|BlockReportProcessingThread
specifier|private
class|class
name|BlockReportProcessingThread
extends|extends
name|Thread
block|{
DECL|field|MAX_LOCK_HOLD_MS
specifier|private
specifier|static
specifier|final
name|long
name|MAX_LOCK_HOLD_MS
init|=
literal|4
decl_stmt|;
DECL|field|lastFull
specifier|private
name|long
name|lastFull
init|=
literal|0
decl_stmt|;
DECL|field|queue
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|Runnable
argument_list|>
name|queue
init|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
DECL|method|BlockReportProcessingThread ()
name|BlockReportProcessingThread
parameter_list|()
block|{
name|super
argument_list|(
literal|"Block report processor"
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|processQueue
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
literal|1
argument_list|,
name|getName
argument_list|()
operator|+
literal|" encountered fatal exception: "
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processQueue ()
specifier|private
name|void
name|processQueue
parameter_list|()
block|{
while|while
condition|(
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|NameNodeMetrics
name|metrics
init|=
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
decl_stmt|;
try|try
block|{
name|Runnable
name|action
init|=
name|queue
operator|.
name|take
argument_list|()
decl_stmt|;
comment|// batch as many operations in the write lock until the queue
comment|// runs dry, or the max lock hold is reached.
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|setBlockOpsQueued
argument_list|(
name|queue
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|start
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
do|do
block|{
name|processed
operator|++
expr_stmt|;
name|action
operator|.
name|run
argument_list|()
expr_stmt|;
if|if
condition|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|start
operator|>
name|MAX_LOCK_HOLD_MS
condition|)
block|{
break|break;
block|}
name|action
operator|=
name|queue
operator|.
name|poll
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|action
operator|!=
literal|null
condition|)
do|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|addBlockOpsBatched
argument_list|(
name|processed
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore unless thread was specifically interrupted.
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
name|queue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|enqueue (Runnable action)
name|void
name|enqueue
parameter_list|(
name|Runnable
name|action
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|queue
operator|.
name|offer
argument_list|(
name|action
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|isAlive
argument_list|()
operator|&&
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
literal|1
argument_list|,
name|getName
argument_list|()
operator|+
literal|" is not running"
argument_list|)
expr_stmt|;
block|}
name|long
name|now
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|lastFull
operator|>
literal|4000
condition|)
block|{
name|lastFull
operator|=
name|now
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Block report queue is full"
argument_list|)
expr_stmt|;
block|}
name|queue
operator|.
name|put
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @return redundancy thread.    */
annotation|@
name|VisibleForTesting
DECL|method|getRedundancyThread ()
name|Daemon
name|getRedundancyThread
parameter_list|()
block|{
return|return
name|redundancyThread
return|;
block|}
DECL|method|getBlockIdManager ()
specifier|public
name|BlockIdManager
name|getBlockIdManager
parameter_list|()
block|{
return|return
name|blockIdManager
return|;
block|}
DECL|method|nextGenerationStamp (boolean legacyBlock)
specifier|public
name|long
name|nextGenerationStamp
parameter_list|(
name|boolean
name|legacyBlock
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|blockIdManager
operator|.
name|nextGenerationStamp
argument_list|(
name|legacyBlock
argument_list|)
return|;
block|}
DECL|method|isLegacyBlock (Block block)
specifier|public
name|boolean
name|isLegacyBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|blockIdManager
operator|.
name|isLegacyBlock
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|nextBlockId (BlockType blockType)
specifier|public
name|long
name|nextBlockId
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
block|{
return|return
name|blockIdManager
operator|.
name|nextBlockId
argument_list|(
name|blockType
argument_list|)
return|;
block|}
DECL|method|isGenStampInFuture (Block block)
name|boolean
name|isGenStampInFuture
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|blockIdManager
operator|.
name|isGenStampInFuture
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|isReplicaCorrupt (BlockInfo blk, DatanodeDescriptor d)
name|boolean
name|isReplicaCorrupt
parameter_list|(
name|BlockInfo
name|blk
parameter_list|,
name|DatanodeDescriptor
name|d
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|isReplicaCorrupt
argument_list|(
name|blk
argument_list|,
name|d
argument_list|)
return|;
block|}
DECL|method|setBlockIndices (BlockInfo blk, byte[] blockIndices, int i, DatanodeStorageInfo storage)
specifier|private
name|int
name|setBlockIndices
parameter_list|(
name|BlockInfo
name|blk
parameter_list|,
name|byte
index|[]
name|blockIndices
parameter_list|,
name|int
name|i
parameter_list|,
name|DatanodeStorageInfo
name|storage
parameter_list|)
block|{
comment|// TODO this can be more efficient
if|if
condition|(
name|blockIndices
operator|!=
literal|null
condition|)
block|{
name|byte
name|index
init|=
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|blk
operator|)
operator|.
name|getStorageBlockIndex
argument_list|(
name|storage
argument_list|)
decl_stmt|;
assert|assert
name|index
operator|>=
literal|0
assert|;
name|blockIndices
index|[
name|i
operator|++
index|]
operator|=
name|index
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
DECL|method|getBlockRecoveryTimeout (long heartbeatIntervalSecs)
specifier|private
specifier|static
name|long
name|getBlockRecoveryTimeout
parameter_list|(
name|long
name|heartbeatIntervalSecs
parameter_list|)
block|{
return|return
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
name|heartbeatIntervalSecs
operator|*
name|BLOCK_RECOVERY_TIMEOUT_MULTIPLIER
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setBlockRecoveryTimeout (long blockRecoveryTimeout)
specifier|public
name|void
name|setBlockRecoveryTimeout
parameter_list|(
name|long
name|blockRecoveryTimeout
parameter_list|)
block|{
name|pendingRecoveryBlocks
operator|.
name|setRecoveryTimeoutInterval
argument_list|(
name|blockRecoveryTimeout
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getProvidedStorageMap ()
specifier|public
name|ProvidedStorageMap
name|getProvidedStorageMap
parameter_list|()
block|{
return|return
name|providedStorageMap
return|;
block|}
comment|/**    * Create SPS manager instance. It manages the user invoked sps paths and does    * the movement.    *    * @param conf    *          configuration    * @return true if the instance is successfully created, false otherwise.    */
DECL|method|createSPSManager (final Configuration conf)
specifier|private
name|boolean
name|createSPSManager
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|createSPSManager
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Create SPS manager instance. It manages the user invoked sps paths and does    * the movement.    *    * @param conf    *          configuration    * @param spsMode    *          satisfier mode    * @return true if the instance is successfully created, false otherwise.    */
DECL|method|createSPSManager (final Configuration conf, final String spsMode)
specifier|public
name|boolean
name|createSPSManager
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|spsMode
parameter_list|)
block|{
comment|// sps manager manages the user invoked sps paths and does the movement.
comment|// StoragePolicySatisfier(SPS) configs
name|boolean
name|storagePolicyEnabled
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_ENABLED_DEFAULT
argument_list|)
decl_stmt|;
name|String
name|modeVal
init|=
name|spsMode
decl_stmt|;
if|if
condition|(
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|modeVal
argument_list|)
condition|)
block|{
name|modeVal
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_SATISFIER_MODE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_STORAGE_POLICY_SATISFIER_MODE_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|StoragePolicySatisfierMode
name|mode
init|=
name|StoragePolicySatisfierMode
operator|.
name|fromString
argument_list|(
name|modeVal
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|storagePolicyEnabled
operator|||
name|mode
operator|==
name|StoragePolicySatisfierMode
operator|.
name|NONE
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage policy satisfier is disabled"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|spsManager
operator|=
operator|new
name|StoragePolicySatisfyManager
argument_list|(
name|conf
argument_list|,
name|namesystem
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Nullify SPS manager as this feature is disabled fully.    */
DECL|method|disableSPS ()
specifier|public
name|void
name|disableSPS
parameter_list|()
block|{
name|spsManager
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * @return sps manager.    */
DECL|method|getSPSManager ()
specifier|public
name|StoragePolicySatisfyManager
name|getSPSManager
parameter_list|()
block|{
return|return
name|spsManager
return|;
block|}
block|}
end_class

end_unit

