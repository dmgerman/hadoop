begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|terminate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
operator|.
name|BlockReportReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnregisteredNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
operator|.
name|AccessMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|DataEncryptionKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|ExportedBlockKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|CorruptReplicasMap
operator|.
name|Reason
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
operator|.
name|AddBlockResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|PendingDataNodeMessages
operator|.
name|ReportedBlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
operator|.
name|OperationCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|Namesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockReportContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
operator|.
name|BlockWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|KeyUpdateCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReceivedDeletedBlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReceivedDeletedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LightWeightLinkedSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|LightWeightGSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Keeps information related to the blocks stored in the Hadoop cluster.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockManager
specifier|public
class|class
name|BlockManager
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BlockManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|blockLog
specifier|public
specifier|static
specifier|final
name|Logger
name|blockLog
init|=
name|NameNode
operator|.
name|blockStateChangeLog
decl_stmt|;
DECL|field|QUEUE_REASON_CORRUPT_STATE
specifier|private
specifier|static
specifier|final
name|String
name|QUEUE_REASON_CORRUPT_STATE
init|=
literal|"it has the wrong state or generation stamp"
decl_stmt|;
DECL|field|QUEUE_REASON_FUTURE_GENSTAMP
specifier|private
specifier|static
specifier|final
name|String
name|QUEUE_REASON_FUTURE_GENSTAMP
init|=
literal|"generation stamp is in the future"
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|Namesystem
name|namesystem
decl_stmt|;
DECL|field|datanodeManager
specifier|private
specifier|final
name|DatanodeManager
name|datanodeManager
decl_stmt|;
DECL|field|heartbeatManager
specifier|private
specifier|final
name|HeartbeatManager
name|heartbeatManager
decl_stmt|;
DECL|field|blockTokenSecretManager
specifier|private
specifier|final
name|BlockTokenSecretManager
name|blockTokenSecretManager
decl_stmt|;
DECL|field|pendingDNMessages
specifier|private
specifier|final
name|PendingDataNodeMessages
name|pendingDNMessages
init|=
operator|new
name|PendingDataNodeMessages
argument_list|()
decl_stmt|;
DECL|field|pendingReplicationBlocksCount
specifier|private
specifier|volatile
name|long
name|pendingReplicationBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|corruptReplicaBlocksCount
specifier|private
specifier|volatile
name|long
name|corruptReplicaBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|underReplicatedBlocksCount
specifier|private
specifier|volatile
name|long
name|underReplicatedBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|scheduledReplicationBlocksCount
specifier|private
specifier|volatile
name|long
name|scheduledReplicationBlocksCount
init|=
literal|0L
decl_stmt|;
DECL|field|excessBlocksCount
specifier|private
specifier|final
name|AtomicLong
name|excessBlocksCount
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0L
argument_list|)
decl_stmt|;
DECL|field|postponedMisreplicatedBlocksCount
specifier|private
specifier|final
name|AtomicLong
name|postponedMisreplicatedBlocksCount
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0L
argument_list|)
decl_stmt|;
DECL|field|startupDelayBlockDeletionInMs
specifier|private
specifier|final
name|long
name|startupDelayBlockDeletionInMs
decl_stmt|;
comment|/** Used by metrics */
DECL|method|getPendingReplicationBlocksCount ()
specifier|public
name|long
name|getPendingReplicationBlocksCount
parameter_list|()
block|{
return|return
name|pendingReplicationBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getUnderReplicatedBlocksCount ()
specifier|public
name|long
name|getUnderReplicatedBlocksCount
parameter_list|()
block|{
return|return
name|underReplicatedBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getCorruptReplicaBlocksCount ()
specifier|public
name|long
name|getCorruptReplicaBlocksCount
parameter_list|()
block|{
return|return
name|corruptReplicaBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getScheduledReplicationBlocksCount ()
specifier|public
name|long
name|getScheduledReplicationBlocksCount
parameter_list|()
block|{
return|return
name|scheduledReplicationBlocksCount
return|;
block|}
comment|/** Used by metrics */
DECL|method|getPendingDeletionBlocksCount ()
specifier|public
name|long
name|getPendingDeletionBlocksCount
parameter_list|()
block|{
return|return
name|invalidateBlocks
operator|.
name|numBlocks
argument_list|()
return|;
block|}
comment|/** Used by metrics */
DECL|method|getStartupDelayBlockDeletionInMs ()
specifier|public
name|long
name|getStartupDelayBlockDeletionInMs
parameter_list|()
block|{
return|return
name|startupDelayBlockDeletionInMs
return|;
block|}
comment|/** Used by metrics */
DECL|method|getExcessBlocksCount ()
specifier|public
name|long
name|getExcessBlocksCount
parameter_list|()
block|{
return|return
name|excessBlocksCount
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** Used by metrics */
DECL|method|getPostponedMisreplicatedBlocksCount ()
specifier|public
name|long
name|getPostponedMisreplicatedBlocksCount
parameter_list|()
block|{
return|return
name|postponedMisreplicatedBlocksCount
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** Used by metrics */
DECL|method|getPendingDataNodeMessageCount ()
specifier|public
name|int
name|getPendingDataNodeMessageCount
parameter_list|()
block|{
return|return
name|pendingDNMessages
operator|.
name|count
argument_list|()
return|;
block|}
comment|/**replicationRecheckInterval is how often namenode checks for new replication work*/
DECL|field|replicationRecheckInterval
specifier|private
specifier|final
name|long
name|replicationRecheckInterval
decl_stmt|;
comment|/**    * Mapping: Block -> { BlockCollection, datanodes, self ref }    * Updated only in response to client-sent information.    */
DECL|field|blocksMap
specifier|final
name|BlocksMap
name|blocksMap
decl_stmt|;
comment|/** Replication thread. */
DECL|field|replicationThread
specifier|final
name|Daemon
name|replicationThread
init|=
operator|new
name|Daemon
argument_list|(
operator|new
name|ReplicationMonitor
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Store blocks -> datanodedescriptor(s) map of corrupt replicas */
DECL|field|corruptReplicas
specifier|final
name|CorruptReplicasMap
name|corruptReplicas
init|=
operator|new
name|CorruptReplicasMap
argument_list|()
decl_stmt|;
comment|/** Blocks to be invalidated. */
DECL|field|invalidateBlocks
specifier|private
specifier|final
name|InvalidateBlocks
name|invalidateBlocks
decl_stmt|;
comment|/**    * After a failover, over-replicated blocks may not be handled    * until all of the replicas have done a block report to the    * new active. This is to make sure that this NameNode has been    * notified of all block deletions that might have been pending    * when the failover happened.    */
DECL|field|postponedMisreplicatedBlocks
specifier|private
specifier|final
name|Set
argument_list|<
name|Block
argument_list|>
name|postponedMisreplicatedBlocks
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
comment|/**    * Maps a StorageID to the set of blocks that are "extra" for this    * DataNode. We'll eventually remove these extras.    */
DECL|field|excessReplicateMap
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
argument_list|>
name|excessReplicateMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Store set of Blocks that need to be replicated 1 or more times.    * We also store pending replication-orders.    */
DECL|field|neededReplications
specifier|public
specifier|final
name|UnderReplicatedBlocks
name|neededReplications
init|=
operator|new
name|UnderReplicatedBlocks
argument_list|()
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|pendingReplications
specifier|final
name|PendingReplicationBlocks
name|pendingReplications
decl_stmt|;
comment|/** The maximum number of replicas allowed for a block */
DECL|field|maxReplication
specifier|public
specifier|final
name|short
name|maxReplication
decl_stmt|;
comment|/**    * The maximum number of outgoing replication streams a given node should have    * at one time considering all but the highest priority replications needed.     */
DECL|field|maxReplicationStreams
name|int
name|maxReplicationStreams
decl_stmt|;
comment|/**    * The maximum number of outgoing replication streams a given node should have    * at one time.    */
DECL|field|replicationStreamsHardLimit
name|int
name|replicationStreamsHardLimit
decl_stmt|;
comment|/** Minimum copies needed or else write is disallowed */
DECL|field|minReplication
specifier|public
specifier|final
name|short
name|minReplication
decl_stmt|;
comment|/** Default number of replicas */
DECL|field|defaultReplication
specifier|public
specifier|final
name|int
name|defaultReplication
decl_stmt|;
comment|/** value returned by MAX_CORRUPT_FILES_RETURNED */
DECL|field|maxCorruptFilesReturned
specifier|final
name|int
name|maxCorruptFilesReturned
decl_stmt|;
DECL|field|blocksInvalidateWorkPct
specifier|final
name|float
name|blocksInvalidateWorkPct
decl_stmt|;
DECL|field|blocksReplWorkMultiplier
specifier|final
name|int
name|blocksReplWorkMultiplier
decl_stmt|;
comment|/** variable to enable check for enough racks */
DECL|field|shouldCheckForEnoughRacks
specifier|final
name|boolean
name|shouldCheckForEnoughRacks
decl_stmt|;
comment|// whether or not to issue block encryption keys.
DECL|field|encryptDataTransfer
specifier|final
name|boolean
name|encryptDataTransfer
decl_stmt|;
comment|// Max number of blocks to log info about during a block report.
DECL|field|maxNumBlocksToLog
specifier|private
specifier|final
name|long
name|maxNumBlocksToLog
decl_stmt|;
comment|/**    * When running inside a Standby node, the node may receive block reports    * from datanodes before receiving the corresponding namespace edits from    * the active NameNode. Thus, it will postpone them for later processing,    * instead of marking the blocks as corrupt.    */
DECL|field|shouldPostponeBlocksFromFuture
specifier|private
name|boolean
name|shouldPostponeBlocksFromFuture
init|=
literal|false
decl_stmt|;
comment|/**    * Process replication queues asynchronously to allow namenode safemode exit    * and failover to be faster. HDFS-5496    */
DECL|field|replicationQueuesInitializer
specifier|private
name|Daemon
name|replicationQueuesInitializer
init|=
literal|null
decl_stmt|;
comment|/**    * Number of blocks to process asychronously for replication queues    * initialization once aquired the namesystem lock. Remaining blocks will be    * processed again after aquiring lock again.    */
DECL|field|numBlocksPerIteration
specifier|private
name|int
name|numBlocksPerIteration
decl_stmt|;
comment|/**    * Progress of the Replication queues initialisation.    */
DECL|field|replicationQueuesInitProgress
specifier|private
name|double
name|replicationQueuesInitProgress
init|=
literal|0.0
decl_stmt|;
comment|/** for block replicas placement */
DECL|field|blockplacement
specifier|private
name|BlockPlacementPolicy
name|blockplacement
decl_stmt|;
DECL|field|storagePolicySuite
specifier|private
specifier|final
name|BlockStoragePolicySuite
name|storagePolicySuite
decl_stmt|;
comment|/** Check whether name system is running before terminating */
DECL|field|checkNSRunning
specifier|private
name|boolean
name|checkNSRunning
init|=
literal|true
decl_stmt|;
DECL|method|BlockManager (final Namesystem namesystem, final Configuration conf)
specifier|public
name|BlockManager
parameter_list|(
specifier|final
name|Namesystem
name|namesystem
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
name|datanodeManager
operator|=
operator|new
name|DatanodeManager
argument_list|(
name|this
argument_list|,
name|namesystem
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|heartbeatManager
operator|=
name|datanodeManager
operator|.
name|getHeartbeatManager
argument_list|()
expr_stmt|;
name|startupDelayBlockDeletionInMs
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STARTUP_DELAY_BLOCK_DELETION_SEC_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STARTUP_DELAY_BLOCK_DELETION_SEC_DEFAULT
argument_list|)
operator|*
literal|1000L
expr_stmt|;
name|invalidateBlocks
operator|=
operator|new
name|InvalidateBlocks
argument_list|(
name|datanodeManager
operator|.
name|blockInvalidateLimit
argument_list|,
name|startupDelayBlockDeletionInMs
argument_list|)
expr_stmt|;
comment|// Compute the map capacity by allocating 2% of total memory
name|blocksMap
operator|=
operator|new
name|BlocksMap
argument_list|(
name|LightWeightGSet
operator|.
name|computeCapacity
argument_list|(
literal|2.0
argument_list|,
literal|"BlocksMap"
argument_list|)
argument_list|)
expr_stmt|;
name|blockplacement
operator|=
name|BlockPlacementPolicy
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
name|datanodeManager
operator|.
name|getFSClusterStats
argument_list|()
argument_list|,
name|datanodeManager
operator|.
name|getNetworkTopology
argument_list|()
argument_list|,
name|datanodeManager
operator|.
name|getHost2DatanodeMap
argument_list|()
argument_list|)
expr_stmt|;
name|storagePolicySuite
operator|=
name|BlockStoragePolicySuite
operator|.
name|createDefaultSuite
argument_list|()
expr_stmt|;
name|pendingReplications
operator|=
operator|new
name|PendingReplicationBlocks
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_DEFAULT
argument_list|)
operator|*
literal|1000L
argument_list|)
expr_stmt|;
name|blockTokenSecretManager
operator|=
name|createBlockTokenSecretManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxCorruptFilesReturned
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DEFAULT_MAX_CORRUPT_FILES_RETURNED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DEFAULT_MAX_CORRUPT_FILES_RETURNED
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultReplication
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_DEFAULT
argument_list|)
expr_stmt|;
specifier|final
name|int
name|maxR
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minR
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|minR
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
operator|+
literal|" = "
operator|+
name|minR
operator|+
literal|"<= 0"
argument_list|)
throw|;
if|if
condition|(
name|maxR
operator|>
name|Short
operator|.
name|MAX_VALUE
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_KEY
operator|+
literal|" = "
operator|+
name|maxR
operator|+
literal|"> "
operator|+
name|Short
operator|.
name|MAX_VALUE
argument_list|)
throw|;
if|if
condition|(
name|minR
operator|>
name|maxR
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected configuration parameters: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MIN_KEY
operator|+
literal|" = "
operator|+
name|minR
operator|+
literal|"> "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_REPLICATION_MAX_KEY
operator|+
literal|" = "
operator|+
name|maxR
argument_list|)
throw|;
name|this
operator|.
name|minReplication
operator|=
operator|(
name|short
operator|)
name|minR
expr_stmt|;
name|this
operator|.
name|maxReplication
operator|=
operator|(
name|short
operator|)
name|maxR
expr_stmt|;
name|this
operator|.
name|maxReplicationStreams
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MAX_STREAMS_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_MAX_STREAMS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|replicationStreamsHardLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_STREAMS_HARD_LIMIT_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_STREAMS_HARD_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|shouldCheckForEnoughRacks
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY
argument_list|)
operator|==
literal|null
condition|?
literal|false
else|:
literal|true
expr_stmt|;
name|this
operator|.
name|blocksInvalidateWorkPct
operator|=
name|DFSUtil
operator|.
name|getInvalidateWorkPctPerIteration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|blocksReplWorkMultiplier
operator|=
name|DFSUtil
operator|.
name|getReplWorkMultiplier
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|replicationRecheckInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_REPLICATION_INTERVAL_DEFAULT
argument_list|)
operator|*
literal|1000L
expr_stmt|;
name|this
operator|.
name|encryptDataTransfer
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_ENCRYPT_DATA_TRANSFER_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxNumBlocksToLog
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_MAX_NUM_BLOCKS_TO_LOG_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_MAX_NUM_BLOCKS_TO_LOG_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|numBlocksPerIteration
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_MISREPLICATION_PROCESSING_LIMIT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_MISREPLICATION_PROCESSING_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"defaultReplication         = "
operator|+
name|defaultReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"maxReplication             = "
operator|+
name|maxReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"minReplication             = "
operator|+
name|minReplication
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"maxReplicationStreams      = "
operator|+
name|maxReplicationStreams
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"shouldCheckForEnoughRacks  = "
operator|+
name|shouldCheckForEnoughRacks
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"replicationRecheckInterval = "
operator|+
name|replicationRecheckInterval
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"encryptDataTransfer        = "
operator|+
name|encryptDataTransfer
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"maxNumBlocksToLog          = "
operator|+
name|maxNumBlocksToLog
argument_list|)
expr_stmt|;
block|}
DECL|method|createBlockTokenSecretManager ( final Configuration conf)
specifier|private
specifier|static
name|BlockTokenSecretManager
name|createBlockTokenSecretManager
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|isEnabled
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY
operator|+
literal|"="
operator|+
name|isEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isEnabled
condition|)
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|String
name|errMessage
init|=
literal|"Security is enabled but block access tokens "
operator|+
literal|"(via "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY
operator|+
literal|") "
operator|+
literal|"aren't enabled. This may cause issues "
operator|+
literal|"when clients attempt to connect to a DataNode. Aborting NameNode"
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|errMessage
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|updateMin
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|long
name|lifetimeMin
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|String
name|encryptionAlgorithm
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATA_ENCRYPTION_ALGORITHM_KEY
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY
operator|+
literal|"="
operator|+
name|updateMin
operator|+
literal|" min(s), "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY
operator|+
literal|"="
operator|+
name|lifetimeMin
operator|+
literal|" min(s), "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_DATA_ENCRYPTION_ALGORITHM_KEY
operator|+
literal|"="
operator|+
name|encryptionAlgorithm
argument_list|)
expr_stmt|;
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|boolean
name|isHaEnabled
init|=
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
if|if
condition|(
name|isHaEnabled
condition|)
block|{
name|String
name|thisNnId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|String
name|otherNnId
init|=
name|HAUtil
operator|.
name|getNameNodeIdOfOtherNode
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
return|return
operator|new
name|BlockTokenSecretManager
argument_list|(
name|updateMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|,
name|lifetimeMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|,
name|thisNnId
operator|.
name|compareTo
argument_list|(
name|otherNnId
argument_list|)
operator|<
literal|0
condition|?
literal|0
else|:
literal|1
argument_list|,
literal|null
argument_list|,
name|encryptionAlgorithm
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|BlockTokenSecretManager
argument_list|(
name|updateMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|,
name|lifetimeMin
operator|*
literal|60
operator|*
literal|1000L
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|encryptionAlgorithm
argument_list|)
return|;
block|}
block|}
DECL|method|getStoragePolicy (final String policyName)
specifier|public
name|BlockStoragePolicy
name|getStoragePolicy
parameter_list|(
specifier|final
name|String
name|policyName
parameter_list|)
block|{
return|return
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|policyName
argument_list|)
return|;
block|}
DECL|method|getStoragePolicy (final byte policyId)
specifier|public
name|BlockStoragePolicy
name|getStoragePolicy
parameter_list|(
specifier|final
name|byte
name|policyId
parameter_list|)
block|{
return|return
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|policyId
argument_list|)
return|;
block|}
DECL|method|getStoragePolicies ()
specifier|public
name|BlockStoragePolicy
index|[]
name|getStoragePolicies
parameter_list|()
block|{
return|return
name|storagePolicySuite
operator|.
name|getAllPolicies
argument_list|()
return|;
block|}
DECL|method|setBlockPoolId (String blockPoolId)
specifier|public
name|void
name|setBlockPoolId
parameter_list|(
name|String
name|blockPoolId
parameter_list|)
block|{
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
condition|)
block|{
name|blockTokenSecretManager
operator|.
name|setBlockPoolId
argument_list|(
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getStoragePolicySuite ()
specifier|public
name|BlockStoragePolicySuite
name|getStoragePolicySuite
parameter_list|()
block|{
return|return
name|storagePolicySuite
return|;
block|}
comment|/** get the BlockTokenSecretManager */
annotation|@
name|VisibleForTesting
DECL|method|getBlockTokenSecretManager ()
specifier|public
name|BlockTokenSecretManager
name|getBlockTokenSecretManager
parameter_list|()
block|{
return|return
name|blockTokenSecretManager
return|;
block|}
comment|/** Allow silent termination of replication monitor for testing */
annotation|@
name|VisibleForTesting
DECL|method|enableRMTerminationForTesting ()
name|void
name|enableRMTerminationForTesting
parameter_list|()
block|{
name|checkNSRunning
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|isBlockTokenEnabled ()
specifier|private
name|boolean
name|isBlockTokenEnabled
parameter_list|()
block|{
return|return
name|blockTokenSecretManager
operator|!=
literal|null
return|;
block|}
comment|/** Should the access keys be updated? */
DECL|method|shouldUpdateBlockKey (final long updateTime)
name|boolean
name|shouldUpdateBlockKey
parameter_list|(
specifier|final
name|long
name|updateTime
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isBlockTokenEnabled
argument_list|()
condition|?
name|blockTokenSecretManager
operator|.
name|updateKeys
argument_list|(
name|updateTime
argument_list|)
else|:
literal|false
return|;
block|}
DECL|method|activate (Configuration conf)
specifier|public
name|void
name|activate
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|pendingReplications
operator|.
name|start
argument_list|()
expr_stmt|;
name|datanodeManager
operator|.
name|activate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|replicationThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|replicationThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|replicationThread
operator|.
name|join
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{     }
name|datanodeManager
operator|.
name|close
argument_list|()
expr_stmt|;
name|pendingReplications
operator|.
name|stop
argument_list|()
expr_stmt|;
name|blocksMap
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** @return the datanodeManager */
DECL|method|getDatanodeManager ()
specifier|public
name|DatanodeManager
name|getDatanodeManager
parameter_list|()
block|{
return|return
name|datanodeManager
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getBlockPlacementPolicy ()
specifier|public
name|BlockPlacementPolicy
name|getBlockPlacementPolicy
parameter_list|()
block|{
return|return
name|blockplacement
return|;
block|}
comment|/** Set BlockPlacementPolicy */
DECL|method|setBlockPlacementPolicy (BlockPlacementPolicy newpolicy)
specifier|public
name|void
name|setBlockPlacementPolicy
parameter_list|(
name|BlockPlacementPolicy
name|newpolicy
parameter_list|)
block|{
if|if
condition|(
name|newpolicy
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"newpolicy == null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|blockplacement
operator|=
name|newpolicy
expr_stmt|;
block|}
comment|/** Dump meta data to out. */
DECL|method|metaSave (PrintWriter out)
specifier|public
name|void
name|metaSave
parameter_list|(
name|PrintWriter
name|out
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|datanodeManager
operator|.
name|fetchDatanodes
argument_list|(
name|live
argument_list|,
name|dead
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Live Datanodes: "
operator|+
name|live
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Dead Datanodes: "
operator|+
name|dead
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|//
comment|// Dump contents of neededReplication
comment|//
synchronized|synchronized
init|(
name|neededReplications
init|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"Metasave: Blocks waiting for replication: "
operator|+
name|neededReplications
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|neededReplications
control|)
block|{
name|dumpBlockMeta
argument_list|(
name|block
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Dump any postponed over-replicated blocks
name|out
operator|.
name|println
argument_list|(
literal|"Mis-replicated blocks that have been postponed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|postponedMisreplicatedBlocks
control|)
block|{
name|dumpBlockMeta
argument_list|(
name|block
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|// Dump blocks from pendingReplication
name|pendingReplications
operator|.
name|metaSave
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// Dump blocks that are waiting to be deleted
name|invalidateBlocks
operator|.
name|dump
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// Dump all datanodes
name|getDatanodeManager
argument_list|()
operator|.
name|datanodeDump
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**    * Dump the metadata for the given block in a human-readable    * form.    */
DECL|method|dumpBlockMeta (Block block, PrintWriter out)
specifier|private
name|void
name|dumpBlockMeta
parameter_list|(
name|Block
name|block
parameter_list|,
name|PrintWriter
name|out
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|containingLiveReplicasNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|()
decl_stmt|;
name|NumberReplicas
name|numReplicas
init|=
operator|new
name|NumberReplicas
argument_list|()
decl_stmt|;
comment|// source node returned is not used
name|chooseSourceDatanode
argument_list|(
name|block
argument_list|,
name|containingNodes
argument_list|,
name|containingLiveReplicasNodes
argument_list|,
name|numReplicas
argument_list|,
name|UnderReplicatedBlocks
operator|.
name|LEVEL
argument_list|)
expr_stmt|;
comment|// containingLiveReplicasNodes can include READ_ONLY_SHARED replicas which are
comment|// not included in the numReplicas.liveReplicas() count
assert|assert
name|containingLiveReplicasNodes
operator|.
name|size
argument_list|()
operator|>=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
assert|;
name|int
name|usableReplicas
init|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|numReplicas
operator|.
name|decommissionedAndDecommissioning
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|instanceof
name|BlockInfoContiguous
condition|)
block|{
name|BlockCollection
name|bc
init|=
operator|(
operator|(
name|BlockInfoContiguous
operator|)
name|block
operator|)
operator|.
name|getBlockCollection
argument_list|()
decl_stmt|;
name|String
name|fileName
init|=
operator|(
name|bc
operator|==
literal|null
operator|)
condition|?
literal|"[orphaned]"
else|:
name|bc
operator|.
name|getName
argument_list|()
decl_stmt|;
name|out
operator|.
name|print
argument_list|(
name|fileName
operator|+
literal|": "
argument_list|)
expr_stmt|;
block|}
comment|// l: == live:, d: == decommissioned c: == corrupt e: == excess
name|out
operator|.
name|print
argument_list|(
name|block
operator|+
operator|(
operator|(
name|usableReplicas
operator|>
literal|0
operator|)
condition|?
literal|""
else|:
literal|" MISSING"
operator|)
operator|+
literal|" (replicas:"
operator|+
literal|" l: "
operator|+
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
literal|" d: "
operator|+
name|numReplicas
operator|.
name|decommissionedAndDecommissioning
argument_list|()
operator|+
literal|" c: "
operator|+
name|numReplicas
operator|.
name|corruptReplicas
argument_list|()
operator|+
literal|" e: "
operator|+
name|numReplicas
operator|.
name|excessReplicas
argument_list|()
operator|+
literal|") "
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|String
name|state
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|corruptNodes
operator|!=
literal|null
operator|&&
name|corruptNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|state
operator|=
literal|"(corrupt)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissioned
argument_list|()
operator|||
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
name|state
operator|=
literal|"(decommissioned)"
expr_stmt|;
block|}
if|if
condition|(
name|storage
operator|.
name|areBlockContentsStale
argument_list|()
condition|)
block|{
name|state
operator|+=
literal|" (block deletions maybe out of date)"
expr_stmt|;
block|}
name|out
operator|.
name|print
argument_list|(
literal|" "
operator|+
name|node
operator|+
name|state
operator|+
literal|" : "
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** @return maxReplicationStreams */
DECL|method|getMaxReplicationStreams ()
specifier|public
name|int
name|getMaxReplicationStreams
parameter_list|()
block|{
return|return
name|maxReplicationStreams
return|;
block|}
comment|/**    * @return true if the block has minimum replicas    */
DECL|method|checkMinReplication (Block block)
specifier|public
name|boolean
name|checkMinReplication
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
operator|(
name|countNodes
argument_list|(
name|block
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|minReplication
operator|)
return|;
block|}
comment|/**    * Commit a block of a file    *     * @param block block to be committed    * @param commitBlock - contains client reported block length and generation    * @return true if the block is changed to committed state.    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|commitBlock ( final BlockInfoContiguousUnderConstruction block, final Block commitBlock)
specifier|private
specifier|static
name|boolean
name|commitBlock
parameter_list|(
specifier|final
name|BlockInfoContiguousUnderConstruction
name|block
parameter_list|,
specifier|final
name|Block
name|commitBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|block
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|COMMITTED
condition|)
return|return
literal|false
return|;
assert|assert
name|block
operator|.
name|getNumBytes
argument_list|()
operator|<=
name|commitBlock
operator|.
name|getNumBytes
argument_list|()
operator|:
literal|"commitBlock length is less than the stored one "
operator|+
name|commitBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" vs. "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
assert|;
name|block
operator|.
name|commitBlock
argument_list|(
name|commitBlock
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Commit the last block of the file and mark it as complete if it has    * meets the minimum replication requirement    *     * @param bc block collection    * @param commitBlock - contains client reported block length and generation    * @return true if the last block is changed to committed state.    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|commitOrCompleteLastBlock (BlockCollection bc, Block commitBlock)
specifier|public
name|boolean
name|commitOrCompleteLastBlock
parameter_list|(
name|BlockCollection
name|bc
parameter_list|,
name|Block
name|commitBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|commitBlock
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// not committing, this is a block allocation retry
name|BlockInfoContiguous
name|lastBlock
init|=
name|bc
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastBlock
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// no blocks in file yet
if|if
condition|(
name|lastBlock
operator|.
name|isComplete
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// already completed (e.g. by syncBlock)
specifier|final
name|boolean
name|b
init|=
name|commitBlock
argument_list|(
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|lastBlock
argument_list|,
name|commitBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|countNodes
argument_list|(
name|lastBlock
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|minReplication
condition|)
name|completeBlock
argument_list|(
name|bc
argument_list|,
name|bc
operator|.
name|numBlocks
argument_list|()
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/**    * Convert a specified block of the file to a complete block.    * @param bc file    * @param blkIndex  block index in the file    * @throws IOException if the block does not have at least a minimal number    * of replicas reported from data-nodes.    */
DECL|method|completeBlock (final BlockCollection bc, final int blkIndex, boolean force)
specifier|private
name|BlockInfoContiguous
name|completeBlock
parameter_list|(
specifier|final
name|BlockCollection
name|bc
parameter_list|,
specifier|final
name|int
name|blkIndex
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blkIndex
operator|<
literal|0
condition|)
return|return
literal|null
return|;
name|BlockInfoContiguous
name|curBlock
init|=
name|bc
operator|.
name|getBlocks
argument_list|()
index|[
name|blkIndex
index|]
decl_stmt|;
if|if
condition|(
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
return|return
name|curBlock
return|;
name|BlockInfoContiguousUnderConstruction
name|ucBlock
init|=
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|curBlock
decl_stmt|;
name|int
name|numNodes
init|=
name|ucBlock
operator|.
name|numNodes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|numNodes
operator|<
name|minReplication
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot complete block: "
operator|+
literal|"block does not satisfy minimal replication requirement."
argument_list|)
throw|;
if|if
condition|(
operator|!
name|force
operator|&&
name|ucBlock
operator|.
name|getBlockUCState
argument_list|()
operator|!=
name|BlockUCState
operator|.
name|COMMITTED
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot complete block: block has not been COMMITTED by the client"
argument_list|)
throw|;
name|BlockInfoContiguous
name|completeBlock
init|=
name|ucBlock
operator|.
name|convertToCompleteBlock
argument_list|()
decl_stmt|;
comment|// replace penultimate block in file
name|bc
operator|.
name|setBlock
argument_list|(
name|blkIndex
argument_list|,
name|completeBlock
argument_list|)
expr_stmt|;
comment|// Since safe-mode only counts complete blocks, and we now have
comment|// one more complete block, we need to adjust the total up, and
comment|// also count it as safe, if we have at least the minimum replica
comment|// count. (We may not have the minimum replica count yet if this is
comment|// a "forced" completion when a file is getting closed by an
comment|// OP_CLOSE edit on the standby).
name|namesystem
operator|.
name|adjustSafeModeBlockTotals
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|incrementSafeBlockCount
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|numNodes
argument_list|,
name|minReplication
argument_list|)
argument_list|)
expr_stmt|;
comment|// replace block in the blocksMap
return|return
name|blocksMap
operator|.
name|replaceBlock
argument_list|(
name|completeBlock
argument_list|)
return|;
block|}
DECL|method|completeBlock (final BlockCollection bc, final BlockInfoContiguous block, boolean force)
specifier|private
name|BlockInfoContiguous
name|completeBlock
parameter_list|(
specifier|final
name|BlockCollection
name|bc
parameter_list|,
specifier|final
name|BlockInfoContiguous
name|block
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockInfoContiguous
index|[]
name|fileBlocks
init|=
name|bc
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|fileBlocks
operator|.
name|length
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|fileBlocks
index|[
name|idx
index|]
operator|==
name|block
condition|)
block|{
return|return
name|completeBlock
argument_list|(
name|bc
argument_list|,
name|idx
argument_list|,
name|force
argument_list|)
return|;
block|}
return|return
name|block
return|;
block|}
comment|/**    * Force the given block in the given file to be marked as complete,    * regardless of whether enough replicas are present. This is necessary    * when tailing edit logs as a Standby.    */
DECL|method|forceCompleteBlock (final BlockCollection bc, final BlockInfoContiguousUnderConstruction block)
specifier|public
name|BlockInfoContiguous
name|forceCompleteBlock
parameter_list|(
specifier|final
name|BlockCollection
name|bc
parameter_list|,
specifier|final
name|BlockInfoContiguousUnderConstruction
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|block
operator|.
name|commitBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|completeBlock
argument_list|(
name|bc
argument_list|,
name|block
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Convert the last block of the file to an under construction block.<p>    * The block is converted only if the file has blocks and the last one    * is a partial block (its size is less than the preferred block size).    * The converted block is returned to the client.    * The client uses the returned block locations to form the data pipeline    * for this block.<br>    * The methods returns null if there is no partial block at the end.    * The client is supposed to allocate a new block with the next call.    *    * @param bc file    * @param bytesToRemove num of bytes to remove from block    * @return the last block locations if the block is partial or null otherwise    */
DECL|method|convertLastBlockToUnderConstruction ( BlockCollection bc, long bytesToRemove)
specifier|public
name|LocatedBlock
name|convertLastBlockToUnderConstruction
parameter_list|(
name|BlockCollection
name|bc
parameter_list|,
name|long
name|bytesToRemove
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockInfoContiguous
name|oldBlock
init|=
name|bc
operator|.
name|getLastBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldBlock
operator|==
literal|null
operator|||
name|bc
operator|.
name|getPreferredBlockSize
argument_list|()
operator|==
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
operator|-
name|bytesToRemove
condition|)
return|return
literal|null
return|;
assert|assert
name|oldBlock
operator|==
name|getStoredBlock
argument_list|(
name|oldBlock
argument_list|)
operator|:
literal|"last block of the file is not in blocksMap"
assert|;
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|getStorages
argument_list|(
name|oldBlock
argument_list|)
decl_stmt|;
name|BlockInfoContiguousUnderConstruction
name|ucBlock
init|=
name|bc
operator|.
name|setLastBlock
argument_list|(
name|oldBlock
argument_list|,
name|targets
argument_list|)
decl_stmt|;
name|blocksMap
operator|.
name|replaceBlock
argument_list|(
name|ucBlock
argument_list|)
expr_stmt|;
comment|// Remove block from replication queue.
name|NumberReplicas
name|replicas
init|=
name|countNodes
argument_list|(
name|ucBlock
argument_list|)
decl_stmt|;
name|neededReplications
operator|.
name|remove
argument_list|(
name|ucBlock
argument_list|,
name|replicas
operator|.
name|liveReplicas
argument_list|()
argument_list|,
name|replicas
operator|.
name|decommissionedAndDecommissioning
argument_list|()
argument_list|,
name|getReplication
argument_list|(
name|ucBlock
argument_list|)
argument_list|)
expr_stmt|;
name|pendingReplications
operator|.
name|remove
argument_list|(
name|ucBlock
argument_list|)
expr_stmt|;
comment|// remove this block from the list of pending blocks to be deleted.
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|targets
control|)
block|{
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|oldBlock
argument_list|)
expr_stmt|;
block|}
comment|// Adjust safe-mode totals, since under-construction blocks don't
comment|// count in safe-mode.
name|namesystem
operator|.
name|adjustSafeModeBlockTotals
argument_list|(
comment|// decrement safe if we had enough
name|targets
operator|.
name|length
operator|>=
name|minReplication
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
comment|// always decrement total blocks
operator|-
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|long
name|fileLength
init|=
name|bc
operator|.
name|computeContentSummary
argument_list|(
name|getStoragePolicySuite
argument_list|()
argument_list|)
operator|.
name|getLength
argument_list|()
decl_stmt|;
specifier|final
name|long
name|pos
init|=
name|fileLength
operator|-
name|ucBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
return|return
name|createLocatedBlock
argument_list|(
name|ucBlock
argument_list|,
name|pos
argument_list|,
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
return|;
block|}
comment|/**    * Get all valid locations of the block    */
DECL|method|getValidLocations (Block block)
specifier|private
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|getValidLocations
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|locations
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|(
name|blocksMap
operator|.
name|numNodes
argument_list|(
name|block
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
comment|// filter invalidate replicas
if|if
condition|(
operator|!
name|invalidateBlocks
operator|.
name|contains
argument_list|(
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|block
argument_list|)
condition|)
block|{
name|locations
operator|.
name|add
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|locations
return|;
block|}
DECL|method|createLocatedBlockList ( final BlockInfoContiguous[] blocks, final long offset, final long length, final int nrBlocksToReturn, final AccessMode mode)
specifier|private
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|createLocatedBlockList
parameter_list|(
specifier|final
name|BlockInfoContiguous
index|[]
name|blocks
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|length
parameter_list|,
specifier|final
name|int
name|nrBlocksToReturn
parameter_list|,
specifier|final
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|curBlk
init|=
literal|0
decl_stmt|;
name|long
name|curPos
init|=
literal|0
decl_stmt|,
name|blkSize
init|=
literal|0
decl_stmt|;
name|int
name|nrBlocks
init|=
operator|(
name|blocks
index|[
literal|0
index|]
operator|.
name|getNumBytes
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|blocks
operator|.
name|length
decl_stmt|;
for|for
control|(
name|curBlk
operator|=
literal|0
init|;
name|curBlk
operator|<
name|nrBlocks
condition|;
name|curBlk
operator|++
control|)
block|{
name|blkSize
operator|=
name|blocks
index|[
name|curBlk
index|]
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
assert|assert
name|blkSize
operator|>
literal|0
operator|:
literal|"Block of size 0"
assert|;
if|if
condition|(
name|curPos
operator|+
name|blkSize
operator|>
name|offset
condition|)
block|{
break|break;
block|}
name|curPos
operator|+=
name|blkSize
expr_stmt|;
block|}
if|if
condition|(
name|nrBlocks
operator|>
literal|0
operator|&&
name|curBlk
operator|==
name|nrBlocks
condition|)
comment|// offset>= end of file
return|return
name|Collections
operator|.
expr|<
name|LocatedBlock
operator|>
name|emptyList
argument_list|()
return|;
name|long
name|endOff
init|=
name|offset
operator|+
name|length
decl_stmt|;
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|LocatedBlock
argument_list|>
argument_list|(
name|blocks
operator|.
name|length
argument_list|)
decl_stmt|;
do|do
block|{
name|results
operator|.
name|add
argument_list|(
name|createLocatedBlock
argument_list|(
name|blocks
index|[
name|curBlk
index|]
argument_list|,
name|curPos
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|curPos
operator|+=
name|blocks
index|[
name|curBlk
index|]
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
name|curBlk
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|curPos
operator|<
name|endOff
operator|&&
name|curBlk
operator|<
name|blocks
operator|.
name|length
operator|&&
name|results
operator|.
name|size
argument_list|()
operator|<
name|nrBlocksToReturn
condition|)
do|;
return|return
name|results
return|;
block|}
DECL|method|createLocatedBlock (final BlockInfoContiguous[] blocks, final long endPos, final AccessMode mode)
specifier|private
name|LocatedBlock
name|createLocatedBlock
parameter_list|(
specifier|final
name|BlockInfoContiguous
index|[]
name|blocks
parameter_list|,
specifier|final
name|long
name|endPos
parameter_list|,
specifier|final
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|curBlk
init|=
literal|0
decl_stmt|;
name|long
name|curPos
init|=
literal|0
decl_stmt|;
name|int
name|nrBlocks
init|=
operator|(
name|blocks
index|[
literal|0
index|]
operator|.
name|getNumBytes
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|blocks
operator|.
name|length
decl_stmt|;
for|for
control|(
name|curBlk
operator|=
literal|0
init|;
name|curBlk
operator|<
name|nrBlocks
condition|;
name|curBlk
operator|++
control|)
block|{
name|long
name|blkSize
init|=
name|blocks
index|[
name|curBlk
index|]
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|curPos
operator|+
name|blkSize
operator|>=
name|endPos
condition|)
block|{
break|break;
block|}
name|curPos
operator|+=
name|blkSize
expr_stmt|;
block|}
return|return
name|createLocatedBlock
argument_list|(
name|blocks
index|[
name|curBlk
index|]
argument_list|,
name|curPos
argument_list|,
name|mode
argument_list|)
return|;
block|}
DECL|method|createLocatedBlock (final BlockInfoContiguous blk, final long pos, final AccessMode mode)
specifier|private
name|LocatedBlock
name|createLocatedBlock
parameter_list|(
specifier|final
name|BlockInfoContiguous
name|blk
parameter_list|,
specifier|final
name|long
name|pos
parameter_list|,
specifier|final
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|LocatedBlock
name|lb
init|=
name|createLocatedBlock
argument_list|(
name|blk
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|null
condition|)
block|{
name|setBlockToken
argument_list|(
name|lb
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|lb
return|;
block|}
comment|/** @return a LocatedBlock for the given block */
DECL|method|createLocatedBlock (final BlockInfoContiguous blk, final long pos )
specifier|private
name|LocatedBlock
name|createLocatedBlock
parameter_list|(
specifier|final
name|BlockInfoContiguous
name|blk
parameter_list|,
specifier|final
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blk
operator|instanceof
name|BlockInfoContiguousUnderConstruction
condition|)
block|{
if|if
condition|(
name|blk
operator|.
name|isComplete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"blk instanceof BlockInfoUnderConstruction&& blk.isComplete()"
operator|+
literal|", blk="
operator|+
name|blk
argument_list|)
throw|;
block|}
specifier|final
name|BlockInfoContiguousUnderConstruction
name|uc
init|=
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|blk
decl_stmt|;
specifier|final
name|DatanodeStorageInfo
index|[]
name|storages
init|=
name|uc
operator|.
name|getExpectedStorageLocations
argument_list|()
decl_stmt|;
specifier|final
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|namesystem
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blk
argument_list|)
decl_stmt|;
return|return
name|newLocatedBlock
argument_list|(
name|eb
argument_list|,
name|storages
argument_list|,
name|pos
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// get block locations
specifier|final
name|int
name|numCorruptNodes
init|=
name|countNodes
argument_list|(
name|blk
argument_list|)
operator|.
name|corruptReplicas
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numCorruptReplicas
init|=
name|corruptReplicas
operator|.
name|numCorruptReplicas
argument_list|(
name|blk
argument_list|)
decl_stmt|;
if|if
condition|(
name|numCorruptNodes
operator|!=
name|numCorruptReplicas
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Inconsistent number of corrupt replicas for "
operator|+
name|blk
operator|+
literal|" blockMap has "
operator|+
name|numCorruptNodes
operator|+
literal|" but corrupt replicas map has "
operator|+
name|numCorruptReplicas
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|numNodes
init|=
name|blocksMap
operator|.
name|numNodes
argument_list|(
name|blk
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isCorrupt
init|=
name|numCorruptNodes
operator|==
name|numNodes
decl_stmt|;
specifier|final
name|int
name|numMachines
init|=
name|isCorrupt
condition|?
name|numNodes
else|:
name|numNodes
operator|-
name|numCorruptNodes
decl_stmt|;
specifier|final
name|DatanodeStorageInfo
index|[]
name|machines
init|=
operator|new
name|DatanodeStorageInfo
index|[
name|numMachines
index|]
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numMachines
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|blk
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|d
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|replicaCorrupt
init|=
name|corruptReplicas
operator|.
name|isReplicaCorrupt
argument_list|(
name|blk
argument_list|,
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCorrupt
operator|||
operator|(
operator|!
name|replicaCorrupt
operator|)
condition|)
name|machines
index|[
name|j
operator|++
index|]
operator|=
name|storage
expr_stmt|;
block|}
block|}
assert|assert
name|j
operator|==
name|machines
operator|.
name|length
operator|:
literal|"isCorrupt: "
operator|+
name|isCorrupt
operator|+
literal|" numMachines: "
operator|+
name|numMachines
operator|+
literal|" numNodes: "
operator|+
name|numNodes
operator|+
literal|" numCorrupt: "
operator|+
name|numCorruptNodes
operator|+
literal|" numCorruptRepls: "
operator|+
name|numCorruptReplicas
assert|;
specifier|final
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|namesystem
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blk
argument_list|)
decl_stmt|;
return|return
name|newLocatedBlock
argument_list|(
name|eb
argument_list|,
name|machines
argument_list|,
name|pos
argument_list|,
name|isCorrupt
argument_list|)
return|;
block|}
comment|/** Create a LocatedBlocks. */
DECL|method|createLocatedBlocks (final BlockInfoContiguous[] blocks, final long fileSizeExcludeBlocksUnderConstruction, final boolean isFileUnderConstruction, final long offset, final long length, final boolean needBlockToken, final boolean inSnapshot, FileEncryptionInfo feInfo)
specifier|public
name|LocatedBlocks
name|createLocatedBlocks
parameter_list|(
specifier|final
name|BlockInfoContiguous
index|[]
name|blocks
parameter_list|,
specifier|final
name|long
name|fileSizeExcludeBlocksUnderConstruction
parameter_list|,
specifier|final
name|boolean
name|isFileUnderConstruction
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|long
name|length
parameter_list|,
specifier|final
name|boolean
name|needBlockToken
parameter_list|,
specifier|final
name|boolean
name|inSnapshot
parameter_list|,
name|FileEncryptionInfo
name|feInfo
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasReadLock
argument_list|()
assert|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|blocks
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|LocatedBlocks
argument_list|(
literal|0
argument_list|,
name|isFileUnderConstruction
argument_list|,
name|Collections
operator|.
expr|<
name|LocatedBlock
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|feInfo
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"blocks = "
operator|+
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|asList
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|AccessMode
name|mode
init|=
name|needBlockToken
condition|?
name|BlockTokenIdentifier
operator|.
name|AccessMode
operator|.
name|READ
else|:
literal|null
decl_stmt|;
specifier|final
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|locatedblocks
init|=
name|createLocatedBlockList
argument_list|(
name|blocks
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|mode
argument_list|)
decl_stmt|;
specifier|final
name|LocatedBlock
name|lastlb
decl_stmt|;
specifier|final
name|boolean
name|isComplete
decl_stmt|;
if|if
condition|(
operator|!
name|inSnapshot
condition|)
block|{
specifier|final
name|BlockInfoContiguous
name|last
init|=
name|blocks
index|[
name|blocks
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
specifier|final
name|long
name|lastPos
init|=
name|last
operator|.
name|isComplete
argument_list|()
condition|?
name|fileSizeExcludeBlocksUnderConstruction
operator|-
name|last
operator|.
name|getNumBytes
argument_list|()
else|:
name|fileSizeExcludeBlocksUnderConstruction
decl_stmt|;
name|lastlb
operator|=
name|createLocatedBlock
argument_list|(
name|last
argument_list|,
name|lastPos
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|isComplete
operator|=
name|last
operator|.
name|isComplete
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|lastlb
operator|=
name|createLocatedBlock
argument_list|(
name|blocks
argument_list|,
name|fileSizeExcludeBlocksUnderConstruction
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|isComplete
operator|=
literal|true
expr_stmt|;
block|}
return|return
operator|new
name|LocatedBlocks
argument_list|(
name|fileSizeExcludeBlocksUnderConstruction
argument_list|,
name|isFileUnderConstruction
argument_list|,
name|locatedblocks
argument_list|,
name|lastlb
argument_list|,
name|isComplete
argument_list|,
name|feInfo
argument_list|)
return|;
block|}
block|}
comment|/** @return current access keys. */
DECL|method|getBlockKeys ()
specifier|public
name|ExportedBlockKeys
name|getBlockKeys
parameter_list|()
block|{
return|return
name|isBlockTokenEnabled
argument_list|()
condition|?
name|blockTokenSecretManager
operator|.
name|exportKeys
argument_list|()
else|:
name|ExportedBlockKeys
operator|.
name|DUMMY_KEYS
return|;
block|}
comment|/** Generate a block token for the located block. */
DECL|method|setBlockToken (final LocatedBlock b, final AccessMode mode)
specifier|public
name|void
name|setBlockToken
parameter_list|(
specifier|final
name|LocatedBlock
name|b
parameter_list|,
specifier|final
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
condition|)
block|{
comment|// Use cached UGI if serving RPC calls.
name|b
operator|.
name|setBlockToken
argument_list|(
name|blockTokenSecretManager
operator|.
name|generateToken
argument_list|(
name|NameNode
operator|.
name|getRemoteUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|b
operator|.
name|getBlock
argument_list|()
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addKeyUpdateCommand (final List<DatanodeCommand> cmds, final DatanodeDescriptor nodeinfo)
name|void
name|addKeyUpdateCommand
parameter_list|(
specifier|final
name|List
argument_list|<
name|DatanodeCommand
argument_list|>
name|cmds
parameter_list|,
specifier|final
name|DatanodeDescriptor
name|nodeinfo
parameter_list|)
block|{
comment|// check access key update
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
operator|&&
name|nodeinfo
operator|.
name|needKeyUpdate
condition|)
block|{
name|cmds
operator|.
name|add
argument_list|(
operator|new
name|KeyUpdateCommand
argument_list|(
name|blockTokenSecretManager
operator|.
name|exportKeys
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|nodeinfo
operator|.
name|needKeyUpdate
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|method|generateDataEncryptionKey ()
specifier|public
name|DataEncryptionKey
name|generateDataEncryptionKey
parameter_list|()
block|{
if|if
condition|(
name|isBlockTokenEnabled
argument_list|()
operator|&&
name|encryptDataTransfer
condition|)
block|{
return|return
name|blockTokenSecretManager
operator|.
name|generateDataEncryptionKey
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Clamp the specified replication between the minimum and the maximum    * replication levels.    */
DECL|method|adjustReplication (short replication)
specifier|public
name|short
name|adjustReplication
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
return|return
name|replication
operator|<
name|minReplication
condition|?
name|minReplication
else|:
name|replication
operator|>
name|maxReplication
condition|?
name|maxReplication
else|:
name|replication
return|;
block|}
comment|/**    * Check whether the replication parameter is within the range    * determined by system configuration.    */
DECL|method|verifyReplication (String src, short replication, String clientName)
specifier|public
name|void
name|verifyReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|,
name|String
name|clientName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|replication
operator|>=
name|minReplication
operator|&&
name|replication
operator|<=
name|maxReplication
condition|)
block|{
comment|//common case. avoid building 'text'
return|return;
block|}
name|String
name|text
init|=
literal|"file "
operator|+
name|src
operator|+
operator|(
operator|(
name|clientName
operator|!=
literal|null
operator|)
condition|?
literal|" on client "
operator|+
name|clientName
else|:
literal|""
operator|)
operator|+
literal|".\n"
operator|+
literal|"Requested replication "
operator|+
name|replication
decl_stmt|;
if|if
condition|(
name|replication
operator|>
name|maxReplication
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|text
operator|+
literal|" exceeds maximum "
operator|+
name|maxReplication
argument_list|)
throw|;
if|if
condition|(
name|replication
operator|<
name|minReplication
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|text
operator|+
literal|" is less than the required minimum "
operator|+
name|minReplication
argument_list|)
throw|;
block|}
comment|/**    * Check if a block is replicated to at least the minimum replication.    */
DECL|method|isSufficientlyReplicated (BlockInfoContiguous b)
specifier|public
name|boolean
name|isSufficientlyReplicated
parameter_list|(
name|BlockInfoContiguous
name|b
parameter_list|)
block|{
comment|// Compare against the lesser of the minReplication and number of live DNs.
specifier|final
name|int
name|replication
init|=
name|Math
operator|.
name|min
argument_list|(
name|minReplication
argument_list|,
name|getDatanodeManager
argument_list|()
operator|.
name|getNumLiveDataNodes
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|countNodes
argument_list|(
name|b
argument_list|)
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|replication
return|;
block|}
comment|/**    * return a list of blocks& their locations on<code>datanode</code> whose    * total size is<code>size</code>    *     * @param datanode on which blocks are located    * @param size total size of blocks    */
DECL|method|getBlocks (DatanodeID datanode, long size )
specifier|public
name|BlocksWithLocations
name|getBlocks
parameter_list|(
name|DatanodeID
name|datanode
parameter_list|,
name|long
name|size
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
name|namesystem
operator|.
name|checkOperation
argument_list|(
name|OperationCategory
operator|.
name|READ
argument_list|)
expr_stmt|;
return|return
name|getBlocksWithLocations
argument_list|(
name|datanode
argument_list|,
name|size
argument_list|)
return|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Get all blocks with location information from a datanode. */
DECL|method|getBlocksWithLocations (final DatanodeID datanode, final long size)
specifier|private
name|BlocksWithLocations
name|getBlocksWithLocations
parameter_list|(
specifier|final
name|DatanodeID
name|datanode
parameter_list|,
specifier|final
name|long
name|size
parameter_list|)
throws|throws
name|UnregisteredNodeException
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|datanode
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* getBlocks: Asking for blocks from an"
operator|+
literal|" unrecorded node {}"
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Datanode "
operator|+
name|datanode
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
name|int
name|numBlocks
init|=
name|node
operator|.
name|numBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBlocks
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|BlocksWithLocations
argument_list|(
operator|new
name|BlockWithLocations
index|[
literal|0
index|]
argument_list|)
return|;
block|}
name|Iterator
argument_list|<
name|BlockInfoContiguous
argument_list|>
name|iter
init|=
name|node
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
name|int
name|startBlock
init|=
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|numBlocks
argument_list|)
decl_stmt|;
comment|// starting from a random block
comment|// skip blocks
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|startBlock
condition|;
name|i
operator|++
control|)
block|{
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|BlockWithLocations
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockWithLocations
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
name|BlockInfoContiguous
name|curBlock
decl_stmt|;
while|while
condition|(
name|totalSize
operator|<
name|size
operator|&&
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|curBlock
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
continue|continue;
name|totalSize
operator|+=
name|addBlock
argument_list|(
name|curBlock
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totalSize
operator|<
name|size
condition|)
block|{
name|iter
operator|=
name|node
operator|.
name|getBlockIterator
argument_list|()
expr_stmt|;
comment|// start from the beginning
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|startBlock
operator|&&
name|totalSize
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|curBlock
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|curBlock
operator|.
name|isComplete
argument_list|()
condition|)
continue|continue;
name|totalSize
operator|+=
name|addBlock
argument_list|(
name|curBlock
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|BlocksWithLocations
argument_list|(
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|BlockWithLocations
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/** Remove the blocks associated to the given datanode. */
DECL|method|removeBlocksAssociatedTo (final DatanodeDescriptor node)
name|void
name|removeBlocksAssociatedTo
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|Block
argument_list|>
name|it
init|=
name|node
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|removeStoredBlock
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|// Remove all pending DN messages referencing this DN.
name|pendingDNMessages
operator|.
name|removeAllMessagesForDatanode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|resetBlocks
argument_list|()
expr_stmt|;
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/** Remove the blocks associated to the given DatanodeStorageInfo. */
DECL|method|removeBlocksAssociatedTo (final DatanodeStorageInfo storageInfo)
name|void
name|removeBlocksAssociatedTo
parameter_list|(
specifier|final
name|DatanodeStorageInfo
name|storageInfo
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|Block
argument_list|>
name|it
init|=
name|storageInfo
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Block
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|removeStoredBlock
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|node
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
name|namesystem
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
comment|/**    * Adds block to list of blocks which will be invalidated on specified    * datanode and log the operation    */
DECL|method|addToInvalidates (final Block block, final DatanodeInfo datanode)
name|void
name|addToInvalidates
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|,
specifier|final
name|DatanodeInfo
name|datanode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return;
block|}
name|invalidateBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|datanode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds block to list of blocks which will be invalidated on all its    * datanodes.    */
DECL|method|addToInvalidates (Block b)
specifier|private
name|void
name|addToInvalidates
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return;
block|}
name|StringBuilder
name|datanodes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|b
argument_list|,
name|State
operator|.
name|NORMAL
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|invalidateBlocks
operator|.
name|add
argument_list|(
name|b
argument_list|,
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|datanodes
operator|.
name|append
argument_list|(
name|node
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datanodes
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* addToInvalidates: {} {}"
argument_list|,
name|b
argument_list|,
name|datanodes
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove all block invalidation tasks under this datanode UUID;    * used when a datanode registers with a new UUID and the old one    * is wiped.    */
DECL|method|removeFromInvalidates (final DatanodeInfo datanode)
name|void
name|removeFromInvalidates
parameter_list|(
specifier|final
name|DatanodeInfo
name|datanode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return;
block|}
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Mark the block belonging to datanode as corrupt    * @param blk Block to be marked as corrupt    * @param dn Datanode which holds the corrupt replica    * @param storageID if known, null otherwise.    * @param reason a textual reason why the block should be marked corrupt,    * for logging purposes    */
DECL|method|findAndMarkBlockAsCorrupt (final ExtendedBlock blk, final DatanodeInfo dn, String storageID, String reason)
specifier|public
name|void
name|findAndMarkBlockAsCorrupt
parameter_list|(
specifier|final
name|ExtendedBlock
name|blk
parameter_list|,
specifier|final
name|DatanodeInfo
name|dn
parameter_list|,
name|String
name|storageID
parameter_list|,
name|String
name|reason
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
specifier|final
name|BlockInfoContiguous
name|storedBlock
init|=
name|getStoredBlock
argument_list|(
name|blk
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
comment|// Check if the replica is in the blockMap, if not
comment|// ignore the request for now. This could happen when BlockScanner
comment|// thread of Datanode reports bad block before Block reports are sent
comment|// by the Datanode on startup
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* findAndMarkBlockAsCorrupt: {} not found"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return;
block|}
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot mark "
operator|+
name|blk
operator|+
literal|" as corrupt because datanode "
operator|+
name|dn
operator|+
literal|" ("
operator|+
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
operator|+
literal|") does not exist"
argument_list|)
throw|;
block|}
name|markBlockAsCorrupt
argument_list|(
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|blk
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|reason
argument_list|,
name|Reason
operator|.
name|CORRUPTION_REPORTED
argument_list|)
argument_list|,
name|storageID
operator|==
literal|null
condition|?
literal|null
else|:
name|node
operator|.
name|getStorageInfo
argument_list|(
name|storageID
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|/**    *     * @param b    * @param storageInfo storage that contains the block, if known. null otherwise.    * @throws IOException    */
DECL|method|markBlockAsCorrupt (BlockToMarkCorrupt b, DatanodeStorageInfo storageInfo, DatanodeDescriptor node)
specifier|private
name|void
name|markBlockAsCorrupt
parameter_list|(
name|BlockToMarkCorrupt
name|b
parameter_list|,
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|b
operator|.
name|corrupted
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK markBlockAsCorrupt: {} cannot be marked as"
operator|+
literal|" corrupt as it does not belong to any file"
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
name|b
operator|.
name|corrupted
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
name|short
name|expectedReplicas
init|=
name|b
operator|.
name|corrupted
operator|.
name|getBlockCollection
argument_list|()
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
comment|// Add replica to the data-node if it is not already there
if|if
condition|(
name|storageInfo
operator|!=
literal|null
condition|)
block|{
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|b
operator|.
name|stored
argument_list|)
expr_stmt|;
block|}
comment|// Add this replica to corruptReplicas Map
name|corruptReplicas
operator|.
name|addToCorruptReplicasMap
argument_list|(
name|b
operator|.
name|corrupted
argument_list|,
name|node
argument_list|,
name|b
operator|.
name|reason
argument_list|,
name|b
operator|.
name|reasonCode
argument_list|)
expr_stmt|;
name|NumberReplicas
name|numberOfReplicas
init|=
name|countNodes
argument_list|(
name|b
operator|.
name|stored
argument_list|)
decl_stmt|;
name|boolean
name|hasEnoughLiveReplicas
init|=
name|numberOfReplicas
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|expectedReplicas
decl_stmt|;
name|boolean
name|minReplicationSatisfied
init|=
name|numberOfReplicas
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|minReplication
decl_stmt|;
name|boolean
name|hasMoreCorruptReplicas
init|=
name|minReplicationSatisfied
operator|&&
operator|(
name|numberOfReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|numberOfReplicas
operator|.
name|corruptReplicas
argument_list|()
operator|)
operator|>
name|expectedReplicas
decl_stmt|;
name|boolean
name|corruptedDuringWrite
init|=
name|minReplicationSatisfied
operator|&&
operator|(
name|b
operator|.
name|stored
operator|.
name|getGenerationStamp
argument_list|()
operator|>
name|b
operator|.
name|corrupted
operator|.
name|getGenerationStamp
argument_list|()
operator|)
decl_stmt|;
comment|// case 1: have enough number of live replicas
comment|// case 2: corrupted replicas + live replicas> Replication factor
comment|// case 3: Block is marked corrupt due to failure while writing. In this
comment|//         case genstamp will be different than that of valid block.
comment|// In all these cases we can delete the replica.
comment|// In case of 3, rbw block will be deleted and valid block can be replicated
if|if
condition|(
name|hasEnoughLiveReplicas
operator|||
name|hasMoreCorruptReplicas
operator|||
name|corruptedDuringWrite
condition|)
block|{
comment|// the block is over-replicated so invalidate the replicas immediately
name|invalidateBlock
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
comment|// add the block to neededReplication
name|updateNeededReplications
argument_list|(
name|b
operator|.
name|stored
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Invalidates the given block on the given datanode.    * @return true if the block was successfully invalidated and no longer    * present in the BlocksMap    */
DECL|method|invalidateBlock (BlockToMarkCorrupt b, DatanodeInfo dn )
specifier|private
name|boolean
name|invalidateBlock
parameter_list|(
name|BlockToMarkCorrupt
name|b
parameter_list|,
name|DatanodeInfo
name|dn
parameter_list|)
throws|throws
name|IOException
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* invalidateBlock: {} on {}"
argument_list|,
name|b
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|getDatanodeManager
argument_list|()
operator|.
name|getDatanode
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot invalidate "
operator|+
name|b
operator|+
literal|" because datanode "
operator|+
name|dn
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
comment|// Check how many copies we have of the block
name|NumberReplicas
name|nr
init|=
name|countNodes
argument_list|(
name|b
operator|.
name|stored
argument_list|)
decl_stmt|;
if|if
condition|(
name|nr
operator|.
name|replicasOnStaleNodes
argument_list|()
operator|>
literal|0
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* invalidateBlocks: postponing "
operator|+
literal|"invalidation of {} on {} because {} replica(s) are located on "
operator|+
literal|"nodes with potentially out-of-date block reports"
argument_list|,
name|b
argument_list|,
name|dn
argument_list|,
name|nr
operator|.
name|replicasOnStaleNodes
argument_list|()
argument_list|)
expr_stmt|;
name|postponeBlock
argument_list|(
name|b
operator|.
name|corrupted
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|nr
operator|.
name|liveReplicas
argument_list|()
operator|>=
literal|1
condition|)
block|{
comment|// If we have at least one copy on a live node, then we can delete it.
name|addToInvalidates
argument_list|(
name|b
operator|.
name|corrupted
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|removeStoredBlock
argument_list|(
name|b
operator|.
name|stored
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* invalidateBlocks: {} on {} listed for deletion."
argument_list|,
name|b
argument_list|,
name|dn
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* invalidateBlocks: {} on {} is the only copy and"
operator|+
literal|" was not deleted"
argument_list|,
name|b
argument_list|,
name|dn
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|method|setPostponeBlocksFromFuture (boolean postpone)
specifier|public
name|void
name|setPostponeBlocksFromFuture
parameter_list|(
name|boolean
name|postpone
parameter_list|)
block|{
name|this
operator|.
name|shouldPostponeBlocksFromFuture
operator|=
name|postpone
expr_stmt|;
block|}
DECL|method|postponeBlock (Block blk)
specifier|private
name|void
name|postponeBlock
parameter_list|(
name|Block
name|blk
parameter_list|)
block|{
if|if
condition|(
name|postponedMisreplicatedBlocks
operator|.
name|add
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|postponedMisreplicatedBlocksCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateState ()
name|void
name|updateState
parameter_list|()
block|{
name|pendingReplicationBlocksCount
operator|=
name|pendingReplications
operator|.
name|size
argument_list|()
expr_stmt|;
name|underReplicatedBlocksCount
operator|=
name|neededReplications
operator|.
name|size
argument_list|()
expr_stmt|;
name|corruptReplicaBlocksCount
operator|=
name|corruptReplicas
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|/** Return number of under-replicated but not missing blocks */
DECL|method|getUnderReplicatedNotMissingBlocks ()
specifier|public
name|int
name|getUnderReplicatedNotMissingBlocks
parameter_list|()
block|{
return|return
name|neededReplications
operator|.
name|getUnderReplicatedBlockCount
argument_list|()
return|;
block|}
comment|/**    * Schedule blocks for deletion at datanodes    * @param nodesToProcess number of datanodes to schedule deletion work    * @return total number of block for deletion    */
DECL|method|computeInvalidateWork (int nodesToProcess)
name|int
name|computeInvalidateWork
parameter_list|(
name|int
name|nodesToProcess
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|DatanodeInfo
argument_list|>
name|nodes
init|=
name|invalidateBlocks
operator|.
name|getDatanodes
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|nodesToProcess
operator|=
name|Math
operator|.
name|min
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|,
name|nodesToProcess
argument_list|)
expr_stmt|;
name|int
name|blockCnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeInfo
name|dnInfo
range|:
name|nodes
control|)
block|{
name|int
name|blocks
init|=
name|invalidateWorkForOneNode
argument_list|(
name|dnInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|>
literal|0
condition|)
block|{
name|blockCnt
operator|+=
name|blocks
expr_stmt|;
if|if
condition|(
operator|--
name|nodesToProcess
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|blockCnt
return|;
block|}
comment|/**    * Scan blocks in {@link #neededReplications} and assign replication    * work to data-nodes they belong to.    *    * The number of process blocks equals either twice the number of live    * data-nodes or the number of under-replicated blocks whichever is less.    *    * @return number of blocks scheduled for replication during this iteration.    */
DECL|method|computeReplicationWork (int blocksToProcess)
name|int
name|computeReplicationWork
parameter_list|(
name|int
name|blocksToProcess
parameter_list|)
block|{
name|List
argument_list|<
name|List
argument_list|<
name|Block
argument_list|>
argument_list|>
name|blocksToReplicate
init|=
literal|null
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Choose the blocks to be replicated
name|blocksToReplicate
operator|=
name|neededReplications
operator|.
name|chooseUnderReplicatedBlocks
argument_list|(
name|blocksToProcess
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
return|return
name|computeReplicationWorkForBlocks
argument_list|(
name|blocksToReplicate
argument_list|)
return|;
block|}
comment|/** Replicate a set of blocks    *    * @param blocksToReplicate blocks to be replicated, for each priority    * @return the number of blocks scheduled for replication    */
annotation|@
name|VisibleForTesting
DECL|method|computeReplicationWorkForBlocks (List<List<Block>> blocksToReplicate)
name|int
name|computeReplicationWorkForBlocks
parameter_list|(
name|List
argument_list|<
name|List
argument_list|<
name|Block
argument_list|>
argument_list|>
name|blocksToReplicate
parameter_list|)
block|{
name|int
name|requiredReplication
decl_stmt|,
name|numEffectiveReplicas
decl_stmt|;
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
decl_stmt|;
name|DatanodeDescriptor
name|srcNode
decl_stmt|;
name|BlockCollection
name|bc
init|=
literal|null
decl_stmt|;
name|int
name|additionalReplRequired
decl_stmt|;
name|int
name|scheduledWork
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|ReplicationWork
argument_list|>
name|work
init|=
operator|new
name|LinkedList
argument_list|<
name|ReplicationWork
argument_list|>
argument_list|()
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|neededReplications
init|)
block|{
for|for
control|(
name|int
name|priority
init|=
literal|0
init|;
name|priority
operator|<
name|blocksToReplicate
operator|.
name|size
argument_list|()
condition|;
name|priority
operator|++
control|)
block|{
for|for
control|(
name|Block
name|block
range|:
name|blocksToReplicate
operator|.
name|get
argument_list|(
name|priority
argument_list|)
control|)
block|{
comment|// block should belong to a file
name|bc
operator|=
name|blocksMap
operator|.
name|getBlockCollection
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// abandoned block or block reopened for append
if|if
condition|(
name|bc
operator|==
literal|null
operator|||
operator|(
name|bc
operator|.
name|isUnderConstruction
argument_list|()
operator|&&
name|block
operator|.
name|equals
argument_list|(
name|bc
operator|.
name|getLastBlock
argument_list|()
argument_list|)
operator|)
condition|)
block|{
comment|// remove from neededReplications
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|requiredReplication
operator|=
name|bc
operator|.
name|getBlockReplication
argument_list|()
expr_stmt|;
comment|// get a source data-node
name|containingNodes
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|liveReplicaNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|()
decl_stmt|;
name|NumberReplicas
name|numReplicas
init|=
operator|new
name|NumberReplicas
argument_list|()
decl_stmt|;
name|srcNode
operator|=
name|chooseSourceDatanode
argument_list|(
name|block
argument_list|,
name|containingNodes
argument_list|,
name|liveReplicaNodes
argument_list|,
name|numReplicas
argument_list|,
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcNode
operator|==
literal|null
condition|)
block|{
comment|// block can not be replicated from any node
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block "
operator|+
name|block
operator|+
literal|" cannot be repl from any node"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// liveReplicaNodes can include READ_ONLY_SHARED replicas which are
comment|// not included in the numReplicas.liveReplicas() count
assert|assert
name|liveReplicaNodes
operator|.
name|size
argument_list|()
operator|>=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
assert|;
comment|// do not schedule more if enough replicas is already pending
name|numEffectiveReplicas
operator|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|numEffectiveReplicas
operator|>=
name|requiredReplication
condition|)
block|{
if|if
condition|(
operator|(
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|blockHasEnoughRacks
argument_list|(
name|block
argument_list|)
operator|)
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* Removing {} from neededReplications as"
operator|+
literal|" it has enough replicas"
argument_list|,
name|block
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|<
name|requiredReplication
condition|)
block|{
name|additionalReplRequired
operator|=
name|requiredReplication
operator|-
name|numEffectiveReplicas
expr_stmt|;
block|}
else|else
block|{
name|additionalReplRequired
operator|=
literal|1
expr_stmt|;
comment|// Needed on a new rack
block|}
name|work
operator|.
name|add
argument_list|(
operator|new
name|ReplicationWork
argument_list|(
name|block
argument_list|,
name|bc
argument_list|,
name|srcNode
argument_list|,
name|containingNodes
argument_list|,
name|liveReplicaNodes
argument_list|,
name|additionalReplRequired
argument_list|,
name|priority
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
init|=
operator|new
name|HashSet
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ReplicationWork
name|rw
range|:
name|work
control|)
block|{
comment|// Exclude all of the containing nodes from being targets.
comment|// This list includes decommissioning or corrupt nodes.
name|excludedNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|rw
operator|.
name|containingNodes
control|)
block|{
name|excludedNodes
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
comment|// choose replication targets: NOT HOLDING THE GLOBAL LOCK
comment|// It is costly to extract the filename for which chooseTargets is called,
comment|// so for now we pass in the block collection itself.
name|rw
operator|.
name|chooseTargets
argument_list|(
name|blockplacement
argument_list|,
name|storagePolicySuite
argument_list|,
name|excludedNodes
argument_list|)
expr_stmt|;
block|}
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|ReplicationWork
name|rw
range|:
name|work
control|)
block|{
specifier|final
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|rw
operator|.
name|targets
decl_stmt|;
if|if
condition|(
name|targets
operator|==
literal|null
operator|||
name|targets
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|rw
operator|.
name|targets
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
synchronized|synchronized
init|(
name|neededReplications
init|)
block|{
name|Block
name|block
init|=
name|rw
operator|.
name|block
decl_stmt|;
name|int
name|priority
init|=
name|rw
operator|.
name|priority
decl_stmt|;
comment|// Recheck since global lock was released
comment|// block should belong to a file
name|bc
operator|=
name|blocksMap
operator|.
name|getBlockCollection
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// abandoned block or block reopened for append
if|if
condition|(
name|bc
operator|==
literal|null
operator|||
operator|(
name|bc
operator|.
name|isUnderConstruction
argument_list|()
operator|&&
name|block
operator|.
name|equals
argument_list|(
name|bc
operator|.
name|getLastBlock
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
name|rw
operator|.
name|targets
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
name|requiredReplication
operator|=
name|bc
operator|.
name|getBlockReplication
argument_list|()
expr_stmt|;
comment|// do not schedule more if enough replicas is already pending
name|NumberReplicas
name|numReplicas
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|numEffectiveReplicas
operator|=
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|+
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|numEffectiveReplicas
operator|>=
name|requiredReplication
condition|)
block|{
if|if
condition|(
operator|(
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|block
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|blockHasEnoughRacks
argument_list|(
name|block
argument_list|)
operator|)
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
name|rw
operator|.
name|targets
operator|=
literal|null
expr_stmt|;
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* Removing {} from neededReplications as"
operator|+
literal|" it has enough replicas"
argument_list|,
name|block
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|numReplicas
operator|.
name|liveReplicas
argument_list|()
operator|>=
name|requiredReplication
operator|)
operator|&&
operator|(
operator|!
name|blockHasEnoughRacks
argument_list|(
name|block
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rw
operator|.
name|srcNode
operator|.
name|getNetworkLocation
argument_list|()
operator|.
name|equals
argument_list|(
name|targets
index|[
literal|0
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|.
name|getNetworkLocation
argument_list|()
argument_list|)
condition|)
block|{
comment|//No use continuing, unless a new rack in this case
continue|continue;
block|}
block|}
comment|// Add block to the to be replicated list
name|rw
operator|.
name|srcNode
operator|.
name|addBlockToBeReplicated
argument_list|(
name|block
argument_list|,
name|targets
argument_list|)
expr_stmt|;
name|scheduledWork
operator|++
expr_stmt|;
name|DatanodeStorageInfo
operator|.
name|incrementBlocksScheduled
argument_list|(
name|targets
argument_list|)
expr_stmt|;
comment|// Move the block-replication into a "pending" state.
comment|// The reason we use 'pending' is so we can retry
comment|// replications that fail after an appropriate amount of time.
name|pendingReplications
operator|.
name|increment
argument_list|(
name|block
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toDatanodeDescriptors
argument_list|(
name|targets
argument_list|)
argument_list|)
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* block {} is moved from neededReplications to "
operator|+
literal|"pendingReplications"
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
if|if
condition|(
name|numEffectiveReplicas
operator|+
name|targets
operator|.
name|length
operator|>=
name|requiredReplication
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|// remove from neededReplications
block|}
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
comment|// log which blocks have been scheduled for replication
for|for
control|(
name|ReplicationWork
name|rw
range|:
name|work
control|)
block|{
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|rw
operator|.
name|targets
decl_stmt|;
if|if
condition|(
name|targets
operator|!=
literal|null
operator|&&
name|targets
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|StringBuilder
name|targetList
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"datanode(s)"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|targets
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|targetList
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|targetList
operator|.
name|append
argument_list|(
name|targets
index|[
name|k
index|]
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* ask {} to replicate {} to {}"
argument_list|,
name|rw
operator|.
name|srcNode
argument_list|,
name|rw
operator|.
name|block
argument_list|,
name|targetList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|blockLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* neededReplications = {} pendingReplications = {}"
argument_list|,
name|neededReplications
operator|.
name|size
argument_list|()
argument_list|,
name|pendingReplications
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|scheduledWork
return|;
block|}
comment|/** Choose target for WebHDFS redirection. */
DECL|method|chooseTarget4WebHDFS (String src, DatanodeDescriptor clientnode, Set<Node> excludes, long blocksize)
specifier|public
name|DatanodeStorageInfo
index|[]
name|chooseTarget4WebHDFS
parameter_list|(
name|String
name|src
parameter_list|,
name|DatanodeDescriptor
name|clientnode
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludes
parameter_list|,
name|long
name|blocksize
parameter_list|)
block|{
return|return
name|blockplacement
operator|.
name|chooseTarget
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
name|clientnode
argument_list|,
name|Collections
operator|.
expr|<
name|DatanodeStorageInfo
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|false
argument_list|,
name|excludes
argument_list|,
name|blocksize
argument_list|,
name|storagePolicySuite
operator|.
name|getDefaultPolicy
argument_list|()
argument_list|)
return|;
block|}
comment|/** Choose target for getting additional datanodes for an existing pipeline. */
DECL|method|chooseTarget4AdditionalDatanode (String src, int numAdditionalNodes, Node clientnode, List<DatanodeStorageInfo> chosen, Set<Node> excludes, long blocksize, byte storagePolicyID)
specifier|public
name|DatanodeStorageInfo
index|[]
name|chooseTarget4AdditionalDatanode
parameter_list|(
name|String
name|src
parameter_list|,
name|int
name|numAdditionalNodes
parameter_list|,
name|Node
name|clientnode
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|chosen
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludes
parameter_list|,
name|long
name|blocksize
parameter_list|,
name|byte
name|storagePolicyID
parameter_list|)
block|{
specifier|final
name|BlockStoragePolicy
name|storagePolicy
init|=
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|storagePolicyID
argument_list|)
decl_stmt|;
return|return
name|blockplacement
operator|.
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|numAdditionalNodes
argument_list|,
name|clientnode
argument_list|,
name|chosen
argument_list|,
literal|true
argument_list|,
name|excludes
argument_list|,
name|blocksize
argument_list|,
name|storagePolicy
argument_list|)
return|;
block|}
comment|/**    * Choose target datanodes for creating a new block.    *     * @throws IOException    *           if the number of targets< minimum replication.    * @see BlockPlacementPolicy#chooseTarget(String, int, Node,    *      Set, long, List, BlockStoragePolicy)    */
DECL|method|chooseTarget4NewBlock (final String src, final int numOfReplicas, final Node client, final Set<Node> excludedNodes, final long blocksize, final List<String> favoredNodes, final byte storagePolicyID)
specifier|public
name|DatanodeStorageInfo
index|[]
name|chooseTarget4NewBlock
parameter_list|(
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|int
name|numOfReplicas
parameter_list|,
specifier|final
name|Node
name|client
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|,
specifier|final
name|long
name|blocksize
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|favoredNodes
parameter_list|,
specifier|final
name|byte
name|storagePolicyID
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|favoredDatanodeDescriptors
init|=
name|getDatanodeDescriptors
argument_list|(
name|favoredNodes
argument_list|)
decl_stmt|;
specifier|final
name|BlockStoragePolicy
name|storagePolicy
init|=
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|storagePolicyID
argument_list|)
decl_stmt|;
specifier|final
name|DatanodeStorageInfo
index|[]
name|targets
init|=
name|blockplacement
operator|.
name|chooseTarget
argument_list|(
name|src
argument_list|,
name|numOfReplicas
argument_list|,
name|client
argument_list|,
name|excludedNodes
argument_list|,
name|blocksize
argument_list|,
name|favoredDatanodeDescriptors
argument_list|,
name|storagePolicy
argument_list|)
decl_stmt|;
if|if
condition|(
name|targets
operator|.
name|length
operator|<
name|minReplication
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File "
operator|+
name|src
operator|+
literal|" could only be replicated to "
operator|+
name|targets
operator|.
name|length
operator|+
literal|" nodes instead of minReplication (="
operator|+
name|minReplication
operator|+
literal|").  There are "
operator|+
name|getDatanodeManager
argument_list|()
operator|.
name|getNetworkTopology
argument_list|()
operator|.
name|getNumOfLeaves
argument_list|()
operator|+
literal|" datanode(s) running and "
operator|+
operator|(
name|excludedNodes
operator|==
literal|null
condition|?
literal|"no"
else|:
name|excludedNodes
operator|.
name|size
argument_list|()
operator|)
operator|+
literal|" node(s) are excluded in this operation."
argument_list|)
throw|;
block|}
return|return
name|targets
return|;
block|}
comment|/**    * Get list of datanode descriptors for given list of nodes. Nodes are    * hostaddress:port or just hostaddress.    */
DECL|method|getDatanodeDescriptors (List<String> nodes)
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|getDatanodeDescriptors
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nodes
parameter_list|)
block|{
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|datanodeDescriptors
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
name|datanodeDescriptors
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|datanodeManager
operator|.
name|getDatanodeDescriptor
argument_list|(
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|datanodeDescriptors
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|datanodeDescriptors
return|;
block|}
comment|/**    * Parse the data-nodes the block belongs to and choose one,    * which will be the replication source.    *    * We prefer nodes that are in DECOMMISSION_INPROGRESS state to other nodes    * since the former do not have write traffic and hence are less busy.    * We do not use already decommissioned nodes as a source.    * Otherwise we choose a random node among those that did not reach their    * replication limits.  However, if the replication is of the highest priority    * and all nodes have reached their replication limits, we will choose a    * random node despite the replication limit.    *    * In addition form a list of all nodes containing the block    * and calculate its replication numbers.    *    * @param block Block for which a replication source is needed    * @param containingNodes List to be populated with nodes found to contain the     *                        given block    * @param nodesContainingLiveReplicas List to be populated with nodes found to    *                                    contain live replicas of the given block    * @param numReplicas NumberReplicas instance to be initialized with the     *                                   counts of live, corrupt, excess, and    *                                   decommissioned replicas of the given    *                                   block.    * @param priority integer representing replication priority of the given    *                 block    * @return the DatanodeDescriptor of the chosen node from which to replicate    *         the given block    */
annotation|@
name|VisibleForTesting
DECL|method|chooseSourceDatanode (Block block, List<DatanodeDescriptor> containingNodes, List<DatanodeStorageInfo> nodesContainingLiveReplicas, NumberReplicas numReplicas, int priority)
name|DatanodeDescriptor
name|chooseSourceDatanode
parameter_list|(
name|Block
name|block
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|nodesContainingLiveReplicas
parameter_list|,
name|NumberReplicas
name|numReplicas
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|containingNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nodesContainingLiveReplicas
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DatanodeDescriptor
name|srcNode
init|=
literal|null
decl_stmt|;
name|int
name|live
init|=
literal|0
decl_stmt|;
name|int
name|decommissioned
init|=
literal|0
decl_stmt|;
name|int
name|decommissioning
init|=
literal|0
decl_stmt|;
name|int
name|corrupt
init|=
literal|0
decl_stmt|;
name|int
name|excess
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesCorrupt
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|excessBlocks
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|node
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|countableReplica
init|=
name|storage
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|NORMAL
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|nodesCorrupt
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|nodesCorrupt
operator|.
name|contains
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|corrupt
operator|+=
name|countableReplica
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
name|decommissioning
operator|+=
name|countableReplica
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
name|decommissioned
operator|+=
name|countableReplica
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|excessBlocks
operator|!=
literal|null
operator|&&
name|excessBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|excess
operator|+=
name|countableReplica
expr_stmt|;
block|}
else|else
block|{
name|nodesContainingLiveReplicas
operator|.
name|add
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|live
operator|+=
name|countableReplica
expr_stmt|;
block|}
name|containingNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Check if this replica is corrupt
comment|// If so, do not select the node as src node
if|if
condition|(
operator|(
name|nodesCorrupt
operator|!=
literal|null
operator|)
operator|&&
name|nodesCorrupt
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|priority
operator|!=
name|UnderReplicatedBlocks
operator|.
name|QUEUE_HIGHEST_PRIORITY
operator|&&
operator|!
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
operator|&&
name|node
operator|.
name|getNumberOfBlocksToBeReplicated
argument_list|()
operator|>=
name|maxReplicationStreams
condition|)
block|{
continue|continue;
comment|// already reached replication limit
block|}
if|if
condition|(
name|node
operator|.
name|getNumberOfBlocksToBeReplicated
argument_list|()
operator|>=
name|replicationStreamsHardLimit
condition|)
block|{
continue|continue;
block|}
comment|// the block must not be scheduled for removal on srcNode
if|if
condition|(
name|excessBlocks
operator|!=
literal|null
operator|&&
name|excessBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
continue|continue;
comment|// never use already decommissioned nodes
if|if
condition|(
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
continue|continue;
comment|// We got this far, current node is a reasonable choice
if|if
condition|(
name|srcNode
operator|==
literal|null
condition|)
block|{
name|srcNode
operator|=
name|node
expr_stmt|;
continue|continue;
block|}
comment|// switch to a different node randomly
comment|// this to prevent from deterministically selecting the same node even
comment|// if the node failed to replicate the block on previous iterations
if|if
condition|(
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextBoolean
argument_list|()
condition|)
name|srcNode
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|numReplicas
operator|!=
literal|null
condition|)
name|numReplicas
operator|.
name|initialize
argument_list|(
name|live
argument_list|,
name|decommissioned
argument_list|,
name|decommissioning
argument_list|,
name|corrupt
argument_list|,
name|excess
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|srcNode
return|;
block|}
comment|/**    * If there were any replication requests that timed out, reap them    * and put them back into the neededReplication queue    */
DECL|method|processPendingReplications ()
specifier|private
name|void
name|processPendingReplications
parameter_list|()
block|{
name|Block
index|[]
name|timedOutItems
init|=
name|pendingReplications
operator|.
name|getTimedOutBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|timedOutItems
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|timedOutItems
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNeededReplication
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|,
name|getReplication
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|)
argument_list|,
name|num
operator|.
name|liveReplicas
argument_list|()
argument_list|)
condition|)
block|{
name|neededReplications
operator|.
name|add
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|,
name|num
operator|.
name|liveReplicas
argument_list|()
argument_list|,
name|num
operator|.
name|decommissionedAndDecommissioning
argument_list|()
argument_list|,
name|getReplication
argument_list|(
name|timedOutItems
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|/* If we know the target datanodes where the replication timedout,        * we could invoke decBlocksScheduled() on it. Its ok for now.        */
block|}
block|}
comment|/**    * StatefulBlockInfo is used to build the "toUC" list, which is a list of    * updates to the information about under-construction blocks.    * Besides the block in question, it provides the ReplicaState    * reported by the datanode in the block report.     */
DECL|class|StatefulBlockInfo
specifier|static
class|class
name|StatefulBlockInfo
block|{
DECL|field|storedBlock
specifier|final
name|BlockInfoContiguousUnderConstruction
name|storedBlock
decl_stmt|;
DECL|field|reportedBlock
specifier|final
name|Block
name|reportedBlock
decl_stmt|;
DECL|field|reportedState
specifier|final
name|ReplicaState
name|reportedState
decl_stmt|;
DECL|method|StatefulBlockInfo (BlockInfoContiguousUnderConstruction storedBlock, Block reportedBlock, ReplicaState reportedState)
name|StatefulBlockInfo
parameter_list|(
name|BlockInfoContiguousUnderConstruction
name|storedBlock
parameter_list|,
name|Block
name|reportedBlock
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|)
block|{
name|this
operator|.
name|storedBlock
operator|=
name|storedBlock
expr_stmt|;
name|this
operator|.
name|reportedBlock
operator|=
name|reportedBlock
expr_stmt|;
name|this
operator|.
name|reportedState
operator|=
name|reportedState
expr_stmt|;
block|}
block|}
comment|/**    * BlockToMarkCorrupt is used to build the "toCorrupt" list, which is a    * list of blocks that should be considered corrupt due to a block report.    */
DECL|class|BlockToMarkCorrupt
specifier|private
specifier|static
class|class
name|BlockToMarkCorrupt
block|{
comment|/** The corrupted block in a datanode. */
DECL|field|corrupted
specifier|final
name|BlockInfoContiguous
name|corrupted
decl_stmt|;
comment|/** The corresponding block stored in the BlockManager. */
DECL|field|stored
specifier|final
name|BlockInfoContiguous
name|stored
decl_stmt|;
comment|/** The reason to mark corrupt. */
DECL|field|reason
specifier|final
name|String
name|reason
decl_stmt|;
comment|/** The reason code to be stored */
DECL|field|reasonCode
specifier|final
name|Reason
name|reasonCode
decl_stmt|;
DECL|method|BlockToMarkCorrupt (BlockInfoContiguous corrupted, BlockInfoContiguous stored, String reason, Reason reasonCode)
name|BlockToMarkCorrupt
parameter_list|(
name|BlockInfoContiguous
name|corrupted
parameter_list|,
name|BlockInfoContiguous
name|stored
parameter_list|,
name|String
name|reason
parameter_list|,
name|Reason
name|reasonCode
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|corrupted
argument_list|,
literal|"corrupted is null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|stored
argument_list|,
literal|"stored is null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|corrupted
operator|=
name|corrupted
expr_stmt|;
name|this
operator|.
name|stored
operator|=
name|stored
expr_stmt|;
name|this
operator|.
name|reason
operator|=
name|reason
expr_stmt|;
name|this
operator|.
name|reasonCode
operator|=
name|reasonCode
expr_stmt|;
block|}
DECL|method|BlockToMarkCorrupt (BlockInfoContiguous stored, String reason, Reason reasonCode)
name|BlockToMarkCorrupt
parameter_list|(
name|BlockInfoContiguous
name|stored
parameter_list|,
name|String
name|reason
parameter_list|,
name|Reason
name|reasonCode
parameter_list|)
block|{
name|this
argument_list|(
name|stored
argument_list|,
name|stored
argument_list|,
name|reason
argument_list|,
name|reasonCode
argument_list|)
expr_stmt|;
block|}
DECL|method|BlockToMarkCorrupt (BlockInfoContiguous stored, long gs, String reason, Reason reasonCode)
name|BlockToMarkCorrupt
parameter_list|(
name|BlockInfoContiguous
name|stored
parameter_list|,
name|long
name|gs
parameter_list|,
name|String
name|reason
parameter_list|,
name|Reason
name|reasonCode
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|BlockInfoContiguous
argument_list|(
name|stored
argument_list|)
argument_list|,
name|stored
argument_list|,
name|reason
argument_list|,
name|reasonCode
argument_list|)
expr_stmt|;
comment|//the corrupted block in datanode has a different generation stamp
name|corrupted
operator|.
name|setGenerationStamp
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|corrupted
operator|+
literal|"("
operator|+
operator|(
name|corrupted
operator|==
name|stored
condition|?
literal|"same as stored"
else|:
literal|"stored="
operator|+
name|stored
operator|)
operator|+
literal|")"
return|;
block|}
block|}
comment|/**    * The given storage is reporting all its blocks.    * Update the (storage-->block list) and (block-->storage list) maps.    *    * @return true if all known storages of the given DN have finished reporting.    * @throws IOException    */
DECL|method|processReport (final DatanodeID nodeID, final DatanodeStorage storage, final BlockListAsLongs newReport, BlockReportContext context, boolean lastStorageInRpc)
specifier|public
name|boolean
name|processReport
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|,
specifier|final
name|DatanodeStorage
name|storage
parameter_list|,
specifier|final
name|BlockListAsLongs
name|newReport
parameter_list|,
name|BlockReportContext
name|context
parameter_list|,
name|boolean
name|lastStorageInRpc
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
specifier|final
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|//after acquiring write lock
specifier|final
name|long
name|endTime
decl_stmt|;
name|DatanodeDescriptor
name|node
decl_stmt|;
name|Collection
argument_list|<
name|Block
argument_list|>
name|invalidatedBlocks
init|=
literal|null
decl_stmt|;
try|try
block|{
name|node
operator|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|nodeID
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|||
operator|!
name|node
operator|.
name|isAlive
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"ProcessReport from dead or unregistered node: "
operator|+
name|nodeID
argument_list|)
throw|;
block|}
comment|// To minimize startup time, we discard any second (or later) block reports
comment|// that we receive while still in startup phase.
name|DatanodeStorageInfo
name|storageInfo
init|=
name|node
operator|.
name|getStorageInfo
argument_list|(
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageInfo
operator|==
literal|null
condition|)
block|{
comment|// We handle this for backwards compatibility.
name|storageInfo
operator|=
name|node
operator|.
name|updateStorage
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namesystem
operator|.
name|isInStartupSafeMode
argument_list|()
operator|&&
name|storageInfo
operator|.
name|getBlockReportCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport: "
operator|+
literal|"discarded non-initial block report from {}"
operator|+
literal|" because namenode still in startup phase"
argument_list|,
name|nodeID
argument_list|)
expr_stmt|;
return|return
operator|!
name|node
operator|.
name|hasStaleStorages
argument_list|()
return|;
block|}
if|if
condition|(
name|storageInfo
operator|.
name|numBlocks
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// The first block report can be processed a lot more efficiently than
comment|// ordinary block reports.  This shortens restart times.
name|processFirstBlockReport
argument_list|(
name|storageInfo
argument_list|,
name|newReport
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|invalidatedBlocks
operator|=
name|processReport
argument_list|(
name|storageInfo
argument_list|,
name|newReport
argument_list|)
expr_stmt|;
block|}
name|storageInfo
operator|.
name|receivedBlockReport
argument_list|()
expr_stmt|;
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|storageInfo
operator|.
name|setLastBlockReportId
argument_list|(
name|context
operator|.
name|getReportId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastStorageInRpc
condition|)
block|{
name|int
name|rpcsSeen
init|=
name|node
operator|.
name|updateBlockReportContext
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpcsSeen
operator|>=
name|context
operator|.
name|getTotalRpcs
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|zombies
init|=
name|node
operator|.
name|removeZombieStorages
argument_list|()
decl_stmt|;
if|if
condition|(
name|zombies
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"processReport 0x{}: no zombie storages found."
argument_list|,
name|Long
operator|.
name|toHexString
argument_list|(
name|context
operator|.
name|getReportId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|DatanodeStorageInfo
name|zombie
range|:
name|zombies
control|)
block|{
name|removeZombieReplicas
argument_list|(
name|context
argument_list|,
name|zombie
argument_list|)
expr_stmt|;
block|}
block|}
name|node
operator|.
name|clearBlockReportContext
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"processReport 0x{}: {} more RPCs remaining in this "
operator|+
literal|"report."
argument_list|,
name|Long
operator|.
name|toHexString
argument_list|(
name|context
operator|.
name|getReportId
argument_list|()
argument_list|)
argument_list|,
operator|(
name|context
operator|.
name|getTotalRpcs
argument_list|()
operator|-
name|rpcsSeen
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|endTime
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
expr_stmt|;
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|invalidatedBlocks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Block
name|b
range|:
name|invalidatedBlocks
control|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport: {} on node {} size {} does not "
operator|+
literal|"belong to any file"
argument_list|,
name|b
argument_list|,
name|node
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Log the block report processing stats from Namenode perspective
specifier|final
name|NameNodeMetrics
name|metrics
init|=
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|addBlockReport
argument_list|(
call|(
name|int
call|)
argument_list|(
name|endTime
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport: from storage {} node {}, "
operator|+
literal|"blocks: {}, hasStaleStorage: {}, processing time: {} msecs"
argument_list|,
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|nodeID
argument_list|,
name|newReport
operator|.
name|getNumberOfBlocks
argument_list|()
argument_list|,
name|node
operator|.
name|hasStaleStorages
argument_list|()
argument_list|,
operator|(
name|endTime
operator|-
name|startTime
operator|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|node
operator|.
name|hasStaleStorages
argument_list|()
return|;
block|}
DECL|method|removeZombieReplicas (BlockReportContext context, DatanodeStorageInfo zombie)
specifier|private
name|void
name|removeZombieReplicas
parameter_list|(
name|BlockReportContext
name|context
parameter_list|,
name|DatanodeStorageInfo
name|zombie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"processReport 0x{}: removing zombie storage {}, which no "
operator|+
literal|"longer exists on the DataNode."
argument_list|,
name|Long
operator|.
name|toHexString
argument_list|(
name|context
operator|.
name|getReportId
argument_list|()
argument_list|)
argument_list|,
name|zombie
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
name|Iterator
argument_list|<
name|BlockInfoContiguous
argument_list|>
name|iter
init|=
name|zombie
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
name|int
name|prevBlocks
init|=
name|zombie
operator|.
name|numBlocks
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockInfoContiguous
name|block
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// We assume that a block can be on only one storage in a DataNode.
comment|// That's why we pass in the DatanodeDescriptor rather than the
comment|// DatanodeStorageInfo.
comment|// TODO: remove this assumption in case we want to put a block on
comment|// more than one storage on a datanode (and because it's a difficult
comment|// assumption to really enforce)
name|removeStoredBlock
argument_list|(
name|block
argument_list|,
name|zombie
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|zombie
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
assert|assert
operator|(
name|zombie
operator|.
name|numBlocks
argument_list|()
operator|==
literal|0
operator|)
assert|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"processReport 0x{}: removed {} replicas from storage {}, "
operator|+
literal|"which no longer exists on the DataNode."
argument_list|,
name|Long
operator|.
name|toHexString
argument_list|(
name|context
operator|.
name|getReportId
argument_list|()
argument_list|)
argument_list|,
name|prevBlocks
argument_list|,
name|zombie
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rescan the list of blocks which were previously postponed.    */
DECL|method|rescanPostponedMisreplicatedBlocks ()
name|void
name|rescanPostponedMisreplicatedBlocks
parameter_list|()
block|{
if|if
condition|(
name|getPostponedMisreplicatedBlocksCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|long
name|startTimeRescanPostponedMisReplicatedBlocks
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|startPostponedMisReplicatedBlocksCount
init|=
name|getPostponedMisreplicatedBlocksCount
argument_list|()
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// blocksPerRescan is the configured number of blocks per rescan.
comment|// Randomly select blocksPerRescan consecutive blocks from the HashSet
comment|// when the number of blocks remaining is larger than blocksPerRescan.
comment|// The reason we don't always pick the first blocksPerRescan blocks is to
comment|// handle the case if for some reason some datanodes remain in
comment|// content stale state for a long time and only impact the first
comment|// blocksPerRescan blocks.
name|int
name|i
init|=
literal|0
decl_stmt|;
name|long
name|startIndex
init|=
literal|0
decl_stmt|;
name|long
name|blocksPerRescan
init|=
name|datanodeManager
operator|.
name|getBlocksPerPostponedMisreplicatedBlocksRescan
argument_list|()
decl_stmt|;
name|long
name|base
init|=
name|getPostponedMisreplicatedBlocksCount
argument_list|()
operator|-
name|blocksPerRescan
decl_stmt|;
if|if
condition|(
name|base
operator|>
literal|0
condition|)
block|{
name|startIndex
operator|=
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextLong
argument_list|()
operator|%
operator|(
name|base
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|startIndex
operator|<
literal|0
condition|)
block|{
name|startIndex
operator|+=
operator|(
name|base
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|Block
argument_list|>
name|it
init|=
name|postponedMisreplicatedBlocks
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tmp
init|=
literal|0
init|;
name|tmp
operator|<
name|startIndex
condition|;
name|tmp
operator|++
control|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Block
name|b
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|blocksPerRescan
condition|)
block|{
break|break;
block|}
name|BlockInfoContiguous
name|bi
init|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|bi
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"BLOCK* rescanPostponedMisreplicatedBlocks: "
operator|+
literal|"Postponed mis-replicated block "
operator|+
name|b
operator|+
literal|" no longer found "
operator|+
literal|"in block map."
argument_list|)
expr_stmt|;
block|}
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|postponedMisreplicatedBlocksCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|MisReplicationResult
name|res
init|=
name|processMisReplicatedBlock
argument_list|(
name|bi
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"BLOCK* rescanPostponedMisreplicatedBlocks: "
operator|+
literal|"Re-scanned block "
operator|+
name|b
operator|+
literal|", result is "
operator|+
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|!=
name|MisReplicationResult
operator|.
name|POSTPONE
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|postponedMisreplicatedBlocksCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|long
name|endPostponedMisReplicatedBlocksCount
init|=
name|getPostponedMisreplicatedBlocksCount
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rescan of postponedMisreplicatedBlocks completed in "
operator|+
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTimeRescanPostponedMisReplicatedBlocks
operator|)
operator|+
literal|" msecs. "
operator|+
name|endPostponedMisReplicatedBlocksCount
operator|+
literal|" blocks are left. "
operator|+
operator|(
name|startPostponedMisReplicatedBlocksCount
operator|-
name|endPostponedMisReplicatedBlocksCount
operator|)
operator|+
literal|" blocks are removed."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processReport ( final DatanodeStorageInfo storageInfo, final BlockListAsLongs report)
specifier|private
name|Collection
argument_list|<
name|Block
argument_list|>
name|processReport
parameter_list|(
specifier|final
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
specifier|final
name|BlockListAsLongs
name|report
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Normal case:
comment|// Modify the (block-->datanode) map, according to the difference
comment|// between the old and new block report.
comment|//
name|Collection
argument_list|<
name|BlockInfoContiguous
argument_list|>
name|toAdd
init|=
operator|new
name|LinkedList
argument_list|<
name|BlockInfoContiguous
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Block
argument_list|>
name|toRemove
init|=
operator|new
name|TreeSet
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
init|=
operator|new
name|LinkedList
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|BlockToMarkCorrupt
argument_list|>
name|toCorrupt
init|=
operator|new
name|LinkedList
argument_list|<
name|BlockToMarkCorrupt
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
init|=
operator|new
name|LinkedList
argument_list|<
name|StatefulBlockInfo
argument_list|>
argument_list|()
decl_stmt|;
name|reportDiff
argument_list|(
name|storageInfo
argument_list|,
name|report
argument_list|,
name|toAdd
argument_list|,
name|toRemove
argument_list|,
name|toInvalidate
argument_list|,
name|toCorrupt
argument_list|,
name|toUC
argument_list|)
expr_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
comment|// Process the blocks on each queue
for|for
control|(
name|StatefulBlockInfo
name|b
range|:
name|toUC
control|)
block|{
name|addStoredBlockUnderConstruction
argument_list|(
name|b
argument_list|,
name|storageInfo
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Block
name|b
range|:
name|toRemove
control|)
block|{
name|removeStoredBlock
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|int
name|numBlocksLogged
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockInfoContiguous
name|b
range|:
name|toAdd
control|)
block|{
name|addStoredBlock
argument_list|(
name|b
argument_list|,
name|storageInfo
argument_list|,
literal|null
argument_list|,
name|numBlocksLogged
operator|<
name|maxNumBlocksToLog
argument_list|)
expr_stmt|;
name|numBlocksLogged
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|numBlocksLogged
operator|>
name|maxNumBlocksToLog
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* processReport: logged info for {} of {} "
operator|+
literal|"reported."
argument_list|,
name|maxNumBlocksToLog
argument_list|,
name|numBlocksLogged
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Block
name|b
range|:
name|toInvalidate
control|)
block|{
name|addToInvalidates
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockToMarkCorrupt
name|b
range|:
name|toCorrupt
control|)
block|{
name|markBlockAsCorrupt
argument_list|(
name|b
argument_list|,
name|storageInfo
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|toInvalidate
return|;
block|}
comment|/**    * Mark block replicas as corrupt except those on the storages in     * newStorages list.    */
DECL|method|markBlockReplicasAsCorrupt (BlockInfoContiguous block, long oldGenerationStamp, long oldNumBytes, DatanodeStorageInfo[] newStorages)
specifier|public
name|void
name|markBlockReplicasAsCorrupt
parameter_list|(
name|BlockInfoContiguous
name|block
parameter_list|,
name|long
name|oldGenerationStamp
parameter_list|,
name|long
name|oldNumBytes
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|newStorages
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|BlockToMarkCorrupt
name|b
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|oldGenerationStamp
condition|)
block|{
name|b
operator|=
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|block
argument_list|,
name|oldGenerationStamp
argument_list|,
literal|"genstamp does not match "
operator|+
name|oldGenerationStamp
operator|+
literal|" : "
operator|+
name|block
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|block
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|oldNumBytes
condition|)
block|{
name|b
operator|=
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|block
argument_list|,
literal|"length does not match "
operator|+
name|oldNumBytes
operator|+
literal|" : "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|Reason
operator|.
name|SIZE_MISMATCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
name|boolean
name|isCorrupt
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|newStorages
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|newStorage
range|:
name|newStorages
control|)
block|{
if|if
condition|(
name|newStorage
operator|!=
literal|null
operator|&&
name|storage
operator|.
name|equals
argument_list|(
name|newStorage
argument_list|)
condition|)
block|{
name|isCorrupt
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|isCorrupt
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* markBlockReplicasAsCorrupt: mark block replica"
operator|+
literal|" {} on {} as corrupt because the dn is not in the new committed "
operator|+
literal|"storage list."
argument_list|,
name|b
argument_list|,
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
name|markBlockAsCorrupt
argument_list|(
name|b
argument_list|,
name|storage
argument_list|,
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * processFirstBlockReport is intended only for processing "initial" block    * reports, the first block report received from a DN after it registers.    * It just adds all the valid replicas to the datanode, without calculating     * a toRemove list (since there won't be any).  It also silently discards     * any invalid blocks, thereby deferring their processing until     * the next block report.    * @param storageInfo - DatanodeStorageInfo that sent the report    * @param report - the initial block report, to be processed    * @throws IOException     */
DECL|method|processFirstBlockReport ( final DatanodeStorageInfo storageInfo, final BlockListAsLongs report)
specifier|private
name|void
name|processFirstBlockReport
parameter_list|(
specifier|final
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
specifier|final
name|BlockListAsLongs
name|report
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|report
operator|==
literal|null
condition|)
return|return;
assert|assert
operator|(
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
assert|assert
operator|(
name|storageInfo
operator|.
name|numBlocks
argument_list|()
operator|==
literal|0
operator|)
assert|;
for|for
control|(
name|BlockReportReplica
name|iblk
range|:
name|report
control|)
block|{
name|ReplicaState
name|reportedState
init|=
name|iblk
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldPostponeBlocksFromFuture
operator|&&
name|namesystem
operator|.
name|isGenStampInFuture
argument_list|(
name|iblk
argument_list|)
condition|)
block|{
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|iblk
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_FUTURE_GENSTAMP
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|BlockInfoContiguous
name|storedBlock
init|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|iblk
argument_list|)
decl_stmt|;
comment|// If block does not belong to any file, we are done.
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
continue|continue;
comment|// If block is corrupt, mark it and continue to next block.
name|BlockUCState
name|ucState
init|=
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
name|BlockToMarkCorrupt
name|c
init|=
name|checkReplicaCorrupt
argument_list|(
name|iblk
argument_list|,
name|reportedState
argument_list|,
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|shouldPostponeBlocksFromFuture
condition|)
block|{
comment|// In the Standby, we may receive a block report for a file that we
comment|// just have an out-of-date gen-stamp or state for, for example.
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|iblk
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_CORRUPT_STATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|markBlockAsCorrupt
argument_list|(
name|c
argument_list|,
name|storageInfo
argument_list|,
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|// If block is under construction, add this replica to its list
if|if
condition|(
name|isBlockUnderConstruction
argument_list|(
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|reportedState
argument_list|)
condition|)
block|{
operator|(
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|storedBlock
operator|)
operator|.
name|addReplicaIfNotPresent
argument_list|(
name|storageInfo
argument_list|,
name|iblk
argument_list|,
name|reportedState
argument_list|)
expr_stmt|;
comment|// OpenFileBlocks only inside snapshots also will be added to safemode
comment|// threshold. So we need to update such blocks to safemode
comment|// refer HDFS-5283
name|BlockInfoContiguousUnderConstruction
name|blockUC
init|=
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|storedBlock
decl_stmt|;
if|if
condition|(
name|namesystem
operator|.
name|isInSnapshot
argument_list|(
name|blockUC
argument_list|)
condition|)
block|{
name|int
name|numOfReplicas
init|=
name|blockUC
operator|.
name|getNumExpectedLocations
argument_list|()
decl_stmt|;
name|namesystem
operator|.
name|incrementSafeBlockCount
argument_list|(
name|numOfReplicas
argument_list|)
expr_stmt|;
block|}
comment|//and fall through to next clause
block|}
comment|//add replica if appropriate
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|addStoredBlockImmediate
argument_list|(
name|storedBlock
argument_list|,
name|storageInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|reportDiff (DatanodeStorageInfo storageInfo, BlockListAsLongs newReport, Collection<BlockInfoContiguous> toAdd, Collection<Block> toRemove, Collection<Block> toInvalidate, Collection<BlockToMarkCorrupt> toCorrupt, Collection<StatefulBlockInfo> toUC)
specifier|private
name|void
name|reportDiff
parameter_list|(
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|BlockListAsLongs
name|newReport
parameter_list|,
name|Collection
argument_list|<
name|BlockInfoContiguous
argument_list|>
name|toAdd
parameter_list|,
comment|// add to DatanodeDescriptor
name|Collection
argument_list|<
name|Block
argument_list|>
name|toRemove
parameter_list|,
comment|// remove from DatanodeDescriptor
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
parameter_list|,
comment|// should be removed from DN
name|Collection
argument_list|<
name|BlockToMarkCorrupt
argument_list|>
name|toCorrupt
parameter_list|,
comment|// add to corrupt replicas list
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
parameter_list|)
block|{
comment|// add to under-construction list
comment|// place a delimiter in the list which separates blocks
comment|// that have been reported from those that have not
name|BlockInfoContiguous
name|delimiter
init|=
operator|new
name|BlockInfoContiguous
argument_list|(
operator|new
name|Block
argument_list|()
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
decl_stmt|;
name|AddBlockResult
name|result
init|=
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|delimiter
argument_list|)
decl_stmt|;
assert|assert
name|result
operator|==
name|AddBlockResult
operator|.
name|ADDED
operator|:
literal|"Delimiting block cannot be present in the node"
assert|;
name|int
name|headIndex
init|=
literal|0
decl_stmt|;
comment|//currently the delimiter is in the head of the list
name|int
name|curIndex
decl_stmt|;
if|if
condition|(
name|newReport
operator|==
literal|null
condition|)
block|{
name|newReport
operator|=
name|BlockListAsLongs
operator|.
name|EMPTY
expr_stmt|;
block|}
comment|// scan the report and process newly reported blocks
for|for
control|(
name|BlockReportReplica
name|iblk
range|:
name|newReport
control|)
block|{
name|ReplicaState
name|iState
init|=
name|iblk
operator|.
name|getState
argument_list|()
decl_stmt|;
name|BlockInfoContiguous
name|storedBlock
init|=
name|processReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|iblk
argument_list|,
name|iState
argument_list|,
name|toAdd
argument_list|,
name|toInvalidate
argument_list|,
name|toCorrupt
argument_list|,
name|toUC
argument_list|)
decl_stmt|;
comment|// move block to the head of the list
if|if
condition|(
name|storedBlock
operator|!=
literal|null
operator|&&
operator|(
name|curIndex
operator|=
name|storedBlock
operator|.
name|findStorageInfo
argument_list|(
name|storageInfo
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|headIndex
operator|=
name|storageInfo
operator|.
name|moveBlockToHead
argument_list|(
name|storedBlock
argument_list|,
name|curIndex
argument_list|,
name|headIndex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// collect blocks that have not been reported
comment|// all of them are next to the delimiter
name|Iterator
argument_list|<
name|BlockInfoContiguous
argument_list|>
name|it
init|=
name|storageInfo
operator|.
expr|new
name|BlockIterator
argument_list|(
name|delimiter
operator|.
name|getNext
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
name|toRemove
operator|.
name|add
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|storageInfo
operator|.
name|removeBlock
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process a block replica reported by the data-node.    * No side effects except adding to the passed-in Collections.    *     *<ol>    *<li>If the block is not known to the system (not in blocksMap) then the    * data-node should be notified to invalidate this block.</li>    *<li>If the reported replica is valid that is has the same generation stamp    * and length as recorded on the name-node, then the replica location should    * be added to the name-node.</li>    *<li>If the reported replica is not valid, then it is marked as corrupt,    * which triggers replication of the existing valid replicas.    * Corrupt replicas are removed from the system when the block    * is fully replicated.</li>    *<li>If the reported replica is for a block currently marked "under    * construction" in the NN, then it should be added to the     * BlockInfoUnderConstruction's list of replicas.</li>    *</ol>    *     * @param storageInfo DatanodeStorageInfo that sent the report.    * @param block reported block replica    * @param reportedState reported replica state    * @param toAdd add to DatanodeDescriptor    * @param toInvalidate missing blocks (not in the blocks map)    *        should be removed from the data-node    * @param toCorrupt replicas with unexpected length or generation stamp;    *        add to corrupt replicas    * @param toUC replicas of blocks currently under construction    * @return the up-to-date stored block, if it should be kept.    *         Otherwise, null.    */
DECL|method|processReportedBlock ( final DatanodeStorageInfo storageInfo, final Block block, final ReplicaState reportedState, final Collection<BlockInfoContiguous> toAdd, final Collection<Block> toInvalidate, final Collection<BlockToMarkCorrupt> toCorrupt, final Collection<StatefulBlockInfo> toUC)
specifier|private
name|BlockInfoContiguous
name|processReportedBlock
parameter_list|(
specifier|final
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
specifier|final
name|Block
name|block
parameter_list|,
specifier|final
name|ReplicaState
name|reportedState
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|BlockInfoContiguous
argument_list|>
name|toAdd
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|BlockToMarkCorrupt
argument_list|>
name|toCorrupt
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
parameter_list|)
block|{
name|DatanodeDescriptor
name|dn
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reported block "
operator|+
name|block
operator|+
literal|" on "
operator|+
name|dn
operator|+
literal|" size "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" replicaState = "
operator|+
name|reportedState
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldPostponeBlocksFromFuture
operator|&&
name|namesystem
operator|.
name|isGenStampInFuture
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|block
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_FUTURE_GENSTAMP
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// find block by blockId
name|BlockInfoContiguous
name|storedBlock
init|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|==
literal|null
condition|)
block|{
comment|// If blocksMap does not contain reported block id,
comment|// the replica should be removed from the data-node.
name|toInvalidate
operator|.
name|add
argument_list|(
operator|new
name|Block
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|BlockUCState
name|ucState
init|=
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
comment|// Block is on the NN
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"In memory blockUCState = "
operator|+
name|ucState
argument_list|)
expr_stmt|;
block|}
comment|// Ignore replicas already scheduled to be removed from the DN
if|if
condition|(
name|invalidateBlocks
operator|.
name|contains
argument_list|(
name|dn
argument_list|,
name|block
argument_list|)
condition|)
block|{
comment|/*        * TODO: following assertion is incorrect, see HDFS-2668 assert        * storedBlock.findDatanode(dn)< 0 : "Block " + block +        * " in recentInvalidatesSet should not appear in DN " + dn;        */
return|return
name|storedBlock
return|;
block|}
name|BlockToMarkCorrupt
name|c
init|=
name|checkReplicaCorrupt
argument_list|(
name|block
argument_list|,
name|reportedState
argument_list|,
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|shouldPostponeBlocksFromFuture
condition|)
block|{
comment|// If the block is an out-of-date generation stamp or state,
comment|// but we're the standby, we shouldn't treat it as corrupt,
comment|// but instead just queue it for later processing.
comment|// TODO: Pretty confident this should be s/storedBlock/block below,
comment|// since we should be postponing the info of the reported block, not
comment|// the stored block. See HDFS-6289 for more context.
name|queueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|storedBlock
argument_list|,
name|reportedState
argument_list|,
name|QUEUE_REASON_CORRUPT_STATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|toCorrupt
operator|.
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|storedBlock
return|;
block|}
if|if
condition|(
name|isBlockUnderConstruction
argument_list|(
name|storedBlock
argument_list|,
name|ucState
argument_list|,
name|reportedState
argument_list|)
condition|)
block|{
name|toUC
operator|.
name|add
argument_list|(
operator|new
name|StatefulBlockInfo
argument_list|(
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|storedBlock
argument_list|,
operator|new
name|Block
argument_list|(
name|block
argument_list|)
argument_list|,
name|reportedState
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|storedBlock
return|;
block|}
comment|// Add replica if appropriate. If the replica was previously corrupt
comment|// but now okay, it might need to be updated.
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
operator|(
name|storedBlock
operator|.
name|findStorageInfo
argument_list|(
name|storageInfo
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|corruptReplicas
operator|.
name|isReplicaCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|dn
argument_list|)
operator|)
condition|)
block|{
name|toAdd
operator|.
name|add
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
block|}
return|return
name|storedBlock
return|;
block|}
comment|/**    * Queue the given reported block for later processing in the    * standby node. @see PendingDataNodeMessages.    * @param reason a textual reason to report in the debug logs    */
DECL|method|queueReportedBlock (DatanodeStorageInfo storageInfo, Block block, ReplicaState reportedState, String reason)
specifier|private
name|void
name|queueReportedBlock
parameter_list|(
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|Block
name|block
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
assert|assert
name|shouldPostponeBlocksFromFuture
assert|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Queueing reported block "
operator|+
name|block
operator|+
literal|" in state "
operator|+
name|reportedState
operator|+
literal|" from datanode "
operator|+
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|+
literal|" for later processing because "
operator|+
name|reason
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
name|pendingDNMessages
operator|.
name|enqueueReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|block
argument_list|,
name|reportedState
argument_list|)
expr_stmt|;
block|}
comment|/**    * Try to process any messages that were previously queued for the given    * block. This is called from FSEditLogLoader whenever a block's state    * in the namespace has changed or a new block has been created.    */
DECL|method|processQueuedMessagesForBlock (Block b)
specifier|public
name|void
name|processQueuedMessagesForBlock
parameter_list|(
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|Queue
argument_list|<
name|ReportedBlockInfo
argument_list|>
name|queue
init|=
name|pendingDNMessages
operator|.
name|takeBlockQueue
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
comment|// Nothing to re-process
return|return;
block|}
name|processQueuedMessages
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
DECL|method|processQueuedMessages (Iterable<ReportedBlockInfo> rbis)
specifier|private
name|void
name|processQueuedMessages
parameter_list|(
name|Iterable
argument_list|<
name|ReportedBlockInfo
argument_list|>
name|rbis
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|ReportedBlockInfo
name|rbi
range|:
name|rbis
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing previouly queued message "
operator|+
name|rbi
argument_list|)
expr_stmt|;
block|}
name|processAndHandleReportedBlock
argument_list|(
name|rbi
operator|.
name|getStorageInfo
argument_list|()
argument_list|,
name|rbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|rbi
operator|.
name|getReportedState
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Process any remaining queued datanode messages after entering    * active state. At this point they will not be re-queued since    * we are the definitive master node and thus should be up-to-date    * with the namespace information.    */
DECL|method|processAllPendingDNMessages ()
specifier|public
name|void
name|processAllPendingDNMessages
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|shouldPostponeBlocksFromFuture
operator|:
literal|"processAllPendingDNMessages() should be called after disabling "
operator|+
literal|"block postponement."
assert|;
name|int
name|count
init|=
name|pendingDNMessages
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing "
operator|+
name|count
operator|+
literal|" messages from DataNodes "
operator|+
literal|"that were previously queued during standby state"
argument_list|)
expr_stmt|;
block|}
name|processQueuedMessages
argument_list|(
name|pendingDNMessages
operator|.
name|takeAll
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|pendingDNMessages
operator|.
name|count
argument_list|()
operator|==
literal|0
assert|;
block|}
comment|/**    * The next two methods test the various cases under which we must conclude    * the replica is corrupt, or under construction.  These are laid out    * as switch statements, on the theory that it is easier to understand    * the combinatorics of reportedState and ucState that way.  It should be    * at least as efficient as boolean expressions.    *     * @return a BlockToMarkCorrupt object, or null if the replica is not corrupt    */
DECL|method|checkReplicaCorrupt ( Block reported, ReplicaState reportedState, BlockInfoContiguous storedBlock, BlockUCState ucState, DatanodeDescriptor dn)
specifier|private
name|BlockToMarkCorrupt
name|checkReplicaCorrupt
parameter_list|(
name|Block
name|reported
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|,
name|BlockInfoContiguous
name|storedBlock
parameter_list|,
name|BlockUCState
name|ucState
parameter_list|,
name|DatanodeDescriptor
name|dn
parameter_list|)
block|{
switch|switch
condition|(
name|reportedState
condition|)
block|{
case|case
name|FINALIZED
case|:
switch|switch
condition|(
name|ucState
condition|)
block|{
case|case
name|COMPLETE
case|:
case|case
name|COMMITTED
case|:
if|if
condition|(
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
specifier|final
name|long
name|reportedGS
init|=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|reportedGS
argument_list|,
literal|"block is "
operator|+
name|ucState
operator|+
literal|" and reported genstamp "
operator|+
name|reportedGS
operator|+
literal|" does not match genstamp in block map "
operator|+
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|reported
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|storedBlock
argument_list|,
literal|"block is "
operator|+
name|ucState
operator|+
literal|" and reported length "
operator|+
name|reported
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" does not match "
operator|+
literal|"length in block map "
operator|+
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|Reason
operator|.
name|SIZE_MISMATCH
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
comment|// not corrupt
block|}
case|case
name|UNDER_CONSTRUCTION
case|:
if|if
condition|(
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|>
name|reported
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
specifier|final
name|long
name|reportedGS
init|=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|reportedGS
argument_list|,
literal|"block is "
operator|+
name|ucState
operator|+
literal|" and reported state "
operator|+
name|reportedState
operator|+
literal|", But reported genstamp "
operator|+
name|reportedGS
operator|+
literal|" does not match genstamp in block map "
operator|+
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
return|;
block|}
return|return
literal|null
return|;
default|default:
return|return
literal|null
return|;
block|}
case|case
name|RBW
case|:
case|case
name|RWR
case|:
if|if
condition|(
operator|!
name|storedBlock
operator|.
name|isComplete
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
comment|// not corrupt
block|}
elseif|else
if|if
condition|(
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
specifier|final
name|long
name|reportedGS
init|=
name|reported
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|reportedGS
argument_list|,
literal|"reported "
operator|+
name|reportedState
operator|+
literal|" replica with genstamp "
operator|+
name|reportedGS
operator|+
literal|" does not match COMPLETE block's genstamp in block map "
operator|+
name|storedBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
return|;
block|}
else|else
block|{
comment|// COMPLETE block, same genstamp
if|if
condition|(
name|reportedState
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
comment|// If it's a RBW report for a COMPLETE block, it may just be that
comment|// the block report got a little bit delayed after the pipeline
comment|// closed. So, ignore this report, assuming we will get a
comment|// FINALIZED replica later. See HDFS-2791
name|LOG
operator|.
name|info
argument_list|(
literal|"Received an RBW replica for "
operator|+
name|storedBlock
operator|+
literal|" on "
operator|+
name|dn
operator|+
literal|": ignoring it, since it is "
operator|+
literal|"complete with the same genstamp"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|storedBlock
argument_list|,
literal|"reported replica has invalid state "
operator|+
name|reportedState
argument_list|,
name|Reason
operator|.
name|INVALID_STATE
argument_list|)
return|;
block|}
block|}
case|case
name|RUR
case|:
comment|// should not be reported
case|case
name|TEMPORARY
case|:
comment|// should not be reported
default|default:
name|String
name|msg
init|=
literal|"Unexpected replica state "
operator|+
name|reportedState
operator|+
literal|" for block: "
operator|+
name|storedBlock
operator|+
literal|" on "
operator|+
name|dn
operator|+
literal|" size "
operator|+
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
comment|// log here at WARN level since this is really a broken HDFS invariant
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|storedBlock
argument_list|,
name|msg
argument_list|,
name|Reason
operator|.
name|INVALID_STATE
argument_list|)
return|;
block|}
block|}
DECL|method|isBlockUnderConstruction (BlockInfoContiguous storedBlock, BlockUCState ucState, ReplicaState reportedState)
specifier|private
name|boolean
name|isBlockUnderConstruction
parameter_list|(
name|BlockInfoContiguous
name|storedBlock
parameter_list|,
name|BlockUCState
name|ucState
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|)
block|{
switch|switch
condition|(
name|reportedState
condition|)
block|{
case|case
name|FINALIZED
case|:
switch|switch
condition|(
name|ucState
condition|)
block|{
case|case
name|UNDER_CONSTRUCTION
case|:
case|case
name|UNDER_RECOVERY
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
case|case
name|RBW
case|:
case|case
name|RWR
case|:
return|return
operator|(
operator|!
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|)
return|;
case|case
name|RUR
case|:
comment|// should not be reported
case|case
name|TEMPORARY
case|:
comment|// should not be reported
default|default:
return|return
literal|false
return|;
block|}
block|}
DECL|method|addStoredBlockUnderConstruction (StatefulBlockInfo ucBlock, DatanodeStorageInfo storageInfo)
name|void
name|addStoredBlockUnderConstruction
parameter_list|(
name|StatefulBlockInfo
name|ucBlock
parameter_list|,
name|DatanodeStorageInfo
name|storageInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockInfoContiguousUnderConstruction
name|block
init|=
name|ucBlock
operator|.
name|storedBlock
decl_stmt|;
name|block
operator|.
name|addReplicaIfNotPresent
argument_list|(
name|storageInfo
argument_list|,
name|ucBlock
operator|.
name|reportedBlock
argument_list|,
name|ucBlock
operator|.
name|reportedState
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucBlock
operator|.
name|reportedState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
operator|!
name|block
operator|.
name|findDatanode
argument_list|(
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
condition|)
block|{
name|addStoredBlock
argument_list|(
name|block
argument_list|,
name|storageInfo
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Faster version of {@link #addStoredBlock},    * intended for use with initial block report at startup. If not in startup    * safe mode, will call standard addStoredBlock(). Assumes this method is    * called "immediately" so there is no need to refresh the storedBlock from    * blocksMap. Doesn't handle underReplication/overReplication, or worry about    * pendingReplications or corruptReplicas, because it's in startup safe mode.    * Doesn't log every block, because there are typically millions of them.    *     * @throws IOException    */
DECL|method|addStoredBlockImmediate (BlockInfoContiguous storedBlock, DatanodeStorageInfo storageInfo)
specifier|private
name|void
name|addStoredBlockImmediate
parameter_list|(
name|BlockInfoContiguous
name|storedBlock
parameter_list|,
name|DatanodeStorageInfo
name|storageInfo
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|(
name|storedBlock
operator|!=
literal|null
operator|&&
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isInStartupSafeMode
argument_list|()
operator|||
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
name|addStoredBlock
argument_list|(
name|storedBlock
argument_list|,
name|storageInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// just add it
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
comment|// Now check for completion of blocks and safe block count
name|int
name|numCurrentReplica
init|=
name|countLiveNodes
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|COMMITTED
operator|&&
name|numCurrentReplica
operator|>=
name|minReplication
condition|)
block|{
name|completeBlock
argument_list|(
name|storedBlock
operator|.
name|getBlockCollection
argument_list|()
argument_list|,
name|storedBlock
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|// check whether safe replication is reached for the block
comment|// only complete blocks are counted towards that.
comment|// In the case that the block just became complete above, completeBlock()
comment|// handles the safe block count maintenance.
name|namesystem
operator|.
name|incrementSafeBlockCount
argument_list|(
name|numCurrentReplica
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Modify (block-->datanode) map. Remove block from set of    * needed replications if this takes care of the problem.    * @return the block that is stored in blockMap.    */
DECL|method|addStoredBlock (final BlockInfoContiguous block, DatanodeStorageInfo storageInfo, DatanodeDescriptor delNodeHint, boolean logEveryBlock)
specifier|private
name|Block
name|addStoredBlock
parameter_list|(
specifier|final
name|BlockInfoContiguous
name|block
parameter_list|,
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|,
name|boolean
name|logEveryBlock
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|block
operator|!=
literal|null
operator|&&
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|BlockInfoContiguous
name|storedBlock
decl_stmt|;
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|instanceof
name|BlockInfoContiguousUnderConstruction
condition|)
block|{
comment|//refresh our copy in case the block got completed in another thread
name|storedBlock
operator|=
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storedBlock
operator|=
name|block
expr_stmt|;
block|}
if|if
condition|(
name|storedBlock
operator|==
literal|null
operator|||
name|storedBlock
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
comment|// If this block does not belong to anyfile, then we are done.
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* addStoredBlock: {} on {} size {} but it does not"
operator|+
literal|" belong to any file"
argument_list|,
name|block
argument_list|,
name|node
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
comment|// we could add this block to invalidate set of this datanode.
comment|// it will happen in next block report otherwise.
return|return
name|block
return|;
block|}
name|BlockCollection
name|bc
init|=
name|storedBlock
operator|.
name|getBlockCollection
argument_list|()
decl_stmt|;
assert|assert
name|bc
operator|!=
literal|null
operator|:
literal|"Block must belong to a file"
assert|;
comment|// add block to the datanode
name|AddBlockResult
name|result
init|=
name|storageInfo
operator|.
name|addBlock
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
name|int
name|curReplicaDelta
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|AddBlockResult
operator|.
name|ADDED
condition|)
block|{
name|curReplicaDelta
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|logEveryBlock
condition|)
block|{
name|logAddStoredBlock
argument_list|(
name|storedBlock
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|AddBlockResult
operator|.
name|REPLACED
condition|)
block|{
name|curReplicaDelta
operator|=
literal|0
expr_stmt|;
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* addStoredBlock: block {} moved to storageType "
operator|+
literal|"{} on node {}"
argument_list|,
name|storedBlock
argument_list|,
name|storageInfo
operator|.
name|getStorageType
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if the same block is added again and the replica was corrupt
comment|// previously because of a wrong gen stamp, remove it from the
comment|// corrupt block list.
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|block
argument_list|,
name|node
argument_list|,
name|Reason
operator|.
name|GENSTAMP_MISMATCH
argument_list|)
expr_stmt|;
name|curReplicaDelta
operator|=
literal|0
expr_stmt|;
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* addStoredBlock: Redundant addStoredBlock request"
operator|+
literal|" received for {} on node {} size {}"
argument_list|,
name|storedBlock
argument_list|,
name|node
argument_list|,
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Now check for completion of blocks and safe block count
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
name|int
name|numLiveReplicas
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
name|int
name|numCurrentReplica
init|=
name|numLiveReplicas
operator|+
name|pendingReplications
operator|.
name|getNumReplicas
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedBlock
operator|.
name|getBlockUCState
argument_list|()
operator|==
name|BlockUCState
operator|.
name|COMMITTED
operator|&&
name|numLiveReplicas
operator|>=
name|minReplication
condition|)
block|{
name|storedBlock
operator|=
name|completeBlock
argument_list|(
name|bc
argument_list|,
name|storedBlock
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storedBlock
operator|.
name|isComplete
argument_list|()
operator|&&
name|result
operator|==
name|AddBlockResult
operator|.
name|ADDED
condition|)
block|{
comment|// check whether safe replication is reached for the block
comment|// only complete blocks are counted towards that
comment|// Is no-op if not in safe mode.
comment|// In the case that the block just became complete above, completeBlock()
comment|// handles the safe block count maintenance.
name|namesystem
operator|.
name|incrementSafeBlockCount
argument_list|(
name|numCurrentReplica
argument_list|)
expr_stmt|;
block|}
comment|// if file is under construction, then done for now
if|if
condition|(
name|bc
operator|.
name|isUnderConstruction
argument_list|()
condition|)
block|{
return|return
name|storedBlock
return|;
block|}
comment|// do not try to handle over/under-replicated blocks during first safe mode
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return
name|storedBlock
return|;
block|}
comment|// handle underReplication/overReplication
name|short
name|fileReplication
init|=
name|bc
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isNeededReplication
argument_list|(
name|storedBlock
argument_list|,
name|fileReplication
argument_list|,
name|numCurrentReplica
argument_list|)
condition|)
block|{
name|neededReplications
operator|.
name|remove
argument_list|(
name|storedBlock
argument_list|,
name|numCurrentReplica
argument_list|,
name|num
operator|.
name|decommissionedAndDecommissioning
argument_list|()
argument_list|,
name|fileReplication
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updateNeededReplications
argument_list|(
name|storedBlock
argument_list|,
name|curReplicaDelta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numCurrentReplica
operator|>
name|fileReplication
condition|)
block|{
name|processOverReplicatedBlock
argument_list|(
name|storedBlock
argument_list|,
name|fileReplication
argument_list|,
name|node
argument_list|,
name|delNodeHint
argument_list|)
expr_stmt|;
block|}
comment|// If the file replication has reached desired value
comment|// we can remove any corrupt replicas the block may have
name|int
name|corruptReplicasCount
init|=
name|corruptReplicas
operator|.
name|numCorruptReplicas
argument_list|(
name|storedBlock
argument_list|)
decl_stmt|;
name|int
name|numCorruptNodes
init|=
name|num
operator|.
name|corruptReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|numCorruptNodes
operator|!=
name|corruptReplicasCount
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Inconsistent number of corrupt replicas for "
operator|+
name|storedBlock
operator|+
literal|"blockMap has "
operator|+
name|numCorruptNodes
operator|+
literal|" but corrupt replicas map has "
operator|+
name|corruptReplicasCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|corruptReplicasCount
operator|>
literal|0
operator|)
operator|&&
operator|(
name|numLiveReplicas
operator|>=
name|fileReplication
operator|)
condition|)
name|invalidateCorruptReplicas
argument_list|(
name|storedBlock
argument_list|)
expr_stmt|;
return|return
name|storedBlock
return|;
block|}
DECL|method|logAddStoredBlock (BlockInfoContiguous storedBlock, DatanodeDescriptor node)
specifier|private
name|void
name|logAddStoredBlock
parameter_list|(
name|BlockInfoContiguous
name|storedBlock
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|blockLog
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|500
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"BLOCK* addStoredBlock: blockMap updated: "
argument_list|)
operator|.
name|append
argument_list|(
name|node
argument_list|)
operator|.
name|append
argument_list|(
literal|" is added to "
argument_list|)
expr_stmt|;
name|storedBlock
operator|.
name|appendStringTo
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" size "
argument_list|)
operator|.
name|append
argument_list|(
name|storedBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|blockLog
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Invalidate corrupt replicas.    *<p>    * This will remove the replicas from the block's location list,    * add them to {@link #invalidateBlocks} so that they could be further    * deleted from the respective data-nodes,    * and remove the block from corruptReplicasMap.    *<p>    * This method should be called when the block has sufficient    * number of live replicas.    *    * @param blk Block whose corrupt replicas need to be invalidated    */
DECL|method|invalidateCorruptReplicas (BlockInfoContiguous blk)
specifier|private
name|void
name|invalidateCorruptReplicas
parameter_list|(
name|BlockInfoContiguous
name|blk
parameter_list|)
block|{
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|blk
argument_list|)
decl_stmt|;
name|boolean
name|removedFromBlocksMap
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|nodes
operator|==
literal|null
condition|)
return|return;
comment|// make a copy of the array of nodes in order to avoid
comment|// ConcurrentModificationException, when the block is removed from the node
name|DatanodeDescriptor
index|[]
name|nodesCopy
init|=
name|nodes
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeDescriptor
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|nodesCopy
control|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|invalidateBlock
argument_list|(
operator|new
name|BlockToMarkCorrupt
argument_list|(
name|blk
argument_list|,
literal|null
argument_list|,
name|Reason
operator|.
name|ANY
argument_list|)
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|removedFromBlocksMap
operator|=
literal|false
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"invalidateCorruptReplicas error in deleting bad block"
operator|+
literal|" {} on {}"
argument_list|,
name|blk
argument_list|,
name|node
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|removedFromBlocksMap
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Remove the block from corruptReplicasMap
if|if
condition|(
name|removedFromBlocksMap
condition|)
block|{
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For each block in the name-node verify whether it belongs to any file,    * over or under replicated. Place it into the respective queue.    */
DECL|method|processMisReplicatedBlocks ()
specifier|public
name|void
name|processMisReplicatedBlocks
parameter_list|()
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|stopReplicationInitializer
argument_list|()
expr_stmt|;
name|neededReplications
operator|.
name|clear
argument_list|()
expr_stmt|;
name|replicationQueuesInitializer
operator|=
operator|new
name|Daemon
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|processMisReplicatesAsync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted while processing replication queues."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while processing replication queues async"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
expr_stmt|;
name|replicationQueuesInitializer
operator|.
name|setName
argument_list|(
literal|"Replication Queue Initializer"
argument_list|)
expr_stmt|;
name|replicationQueuesInitializer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/*    * Stop the ongoing initialisation of replication queues    */
DECL|method|stopReplicationInitializer ()
specifier|private
name|void
name|stopReplicationInitializer
parameter_list|()
block|{
if|if
condition|(
name|replicationQueuesInitializer
operator|!=
literal|null
condition|)
block|{
name|replicationQueuesInitializer
operator|.
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|replicationQueuesInitializer
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting for replicationQueueInitializer. Returning.."
argument_list|)
expr_stmt|;
return|return;
block|}
finally|finally
block|{
name|replicationQueuesInitializer
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Since the BlocksMapGset does not throw the ConcurrentModificationException    * and supports further iteration after modification to list, there is a    * chance of missing the newly added block while iterating. Since every    * addition to blocksMap will check for mis-replication, missing mis-replication    * check for new blocks will not be a problem.    */
DECL|method|processMisReplicatesAsync ()
specifier|private
name|void
name|processMisReplicatesAsync
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|long
name|nrInvalid
init|=
literal|0
decl_stmt|,
name|nrOverReplicated
init|=
literal|0
decl_stmt|;
name|long
name|nrUnderReplicated
init|=
literal|0
decl_stmt|,
name|nrPostponed
init|=
literal|0
decl_stmt|,
name|nrUnderConstruction
init|=
literal|0
decl_stmt|;
name|long
name|startTimeMisReplicatedScan
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|BlockInfoContiguous
argument_list|>
name|blocksItr
init|=
name|blocksMap
operator|.
name|getBlocks
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|long
name|totalBlocks
init|=
name|blocksMap
operator|.
name|size
argument_list|()
decl_stmt|;
name|replicationQueuesInitProgress
operator|=
literal|0
expr_stmt|;
name|long
name|totalProcessed
init|=
literal|0
decl_stmt|;
name|long
name|sleepDuration
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|numBlocksPerIteration
operator|/
literal|1000
argument_list|,
literal|10000
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|namesystem
operator|.
name|isRunning
argument_list|()
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|namesystem
operator|.
name|writeLockInterruptibly
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
name|processed
operator|<
name|numBlocksPerIteration
operator|&&
name|blocksItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockInfoContiguous
name|block
init|=
name|blocksItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|MisReplicationResult
name|res
init|=
name|processMisReplicatedBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"block "
operator|+
name|block
operator|+
literal|": "
operator|+
name|res
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|UNDER_REPLICATED
case|:
name|nrUnderReplicated
operator|++
expr_stmt|;
break|break;
case|case
name|OVER_REPLICATED
case|:
name|nrOverReplicated
operator|++
expr_stmt|;
break|break;
case|case
name|INVALID
case|:
name|nrInvalid
operator|++
expr_stmt|;
break|break;
case|case
name|POSTPONE
case|:
name|nrPostponed
operator|++
expr_stmt|;
name|postponeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDER_CONSTRUCTION
case|:
name|nrUnderConstruction
operator|++
expr_stmt|;
break|break;
case|case
name|OK
case|:
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Invalid enum value: "
operator|+
name|res
argument_list|)
throw|;
block|}
name|processed
operator|++
expr_stmt|;
block|}
name|totalProcessed
operator|+=
name|processed
expr_stmt|;
comment|// there is a possibility that if any of the blocks deleted/added during
comment|// initialisation, then progress might be different.
name|replicationQueuesInitProgress
operator|=
name|Math
operator|.
name|min
argument_list|(
operator|(
name|double
operator|)
name|totalProcessed
operator|/
name|totalBlocks
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blocksItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Total number of blocks            = "
operator|+
name|blocksMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of invalid blocks          = "
operator|+
name|nrInvalid
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of under-replicated blocks = "
operator|+
name|nrUnderReplicated
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of  over-replicated blocks = "
operator|+
name|nrOverReplicated
operator|+
operator|(
operator|(
name|nrPostponed
operator|>
literal|0
operator|)
condition|?
operator|(
literal|" ("
operator|+
name|nrPostponed
operator|+
literal|" postponed)"
operator|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of blocks being written    = "
operator|+
name|nrUnderConstruction
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"STATE* Replication Queue initialization "
operator|+
literal|"scan for invalid, over- and under-replicated blocks "
operator|+
literal|"completed in "
operator|+
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTimeMisReplicatedScan
operator|)
operator|+
literal|" msec"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
comment|// Make sure it is out of the write lock for sufficiently long time.
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepDuration
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted while processing replication queues."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the progress of the Replication queues initialisation    *     * @return Returns values between 0 and 1 for the progress.    */
DECL|method|getReplicationQueuesInitProgress ()
specifier|public
name|double
name|getReplicationQueuesInitProgress
parameter_list|()
block|{
return|return
name|replicationQueuesInitProgress
return|;
block|}
comment|/**    * Process a single possibly misreplicated block. This adds it to the    * appropriate queues if necessary, and returns a result code indicating    * what happened with it.    */
DECL|method|processMisReplicatedBlock (BlockInfoContiguous block)
specifier|private
name|MisReplicationResult
name|processMisReplicatedBlock
parameter_list|(
name|BlockInfoContiguous
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
comment|// block does not belong to any file
name|addToInvalidates
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|MisReplicationResult
operator|.
name|INVALID
return|;
block|}
if|if
condition|(
operator|!
name|block
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|// Incomplete blocks are never considered mis-replicated --
comment|// they'll be reached when they are completed or recovered.
return|return
name|MisReplicationResult
operator|.
name|UNDER_CONSTRUCTION
return|;
block|}
comment|// calculate current replication
name|short
name|expectedReplication
init|=
name|block
operator|.
name|getBlockCollection
argument_list|()
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|numCurrentReplica
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
comment|// add to under-replicated queue if need to be
if|if
condition|(
name|isNeededReplication
argument_list|(
name|block
argument_list|,
name|expectedReplication
argument_list|,
name|numCurrentReplica
argument_list|)
condition|)
block|{
if|if
condition|(
name|neededReplications
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|numCurrentReplica
argument_list|,
name|num
operator|.
name|decommissionedAndDecommissioning
argument_list|()
argument_list|,
name|expectedReplication
argument_list|)
condition|)
block|{
return|return
name|MisReplicationResult
operator|.
name|UNDER_REPLICATED
return|;
block|}
block|}
if|if
condition|(
name|numCurrentReplica
operator|>
name|expectedReplication
condition|)
block|{
if|if
condition|(
name|num
operator|.
name|replicasOnStaleNodes
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// If any of the replicas of this block are on nodes that are
comment|// considered "stale", then these replicas may in fact have
comment|// already been deleted. So, we cannot safely act on the
comment|// over-replication until a later point in time, when
comment|// the "stale" nodes have block reported.
return|return
name|MisReplicationResult
operator|.
name|POSTPONE
return|;
block|}
comment|// over-replicated block
name|processOverReplicatedBlock
argument_list|(
name|block
argument_list|,
name|expectedReplication
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|MisReplicationResult
operator|.
name|OVER_REPLICATED
return|;
block|}
return|return
name|MisReplicationResult
operator|.
name|OK
return|;
block|}
comment|/** Set replication for the blocks. */
DECL|method|setReplication (final short oldRepl, final short newRepl, final String src, final Block... blocks)
specifier|public
name|void
name|setReplication
parameter_list|(
specifier|final
name|short
name|oldRepl
parameter_list|,
specifier|final
name|short
name|newRepl
parameter_list|,
specifier|final
name|String
name|src
parameter_list|,
specifier|final
name|Block
modifier|...
name|blocks
parameter_list|)
block|{
if|if
condition|(
name|newRepl
operator|==
name|oldRepl
condition|)
block|{
return|return;
block|}
comment|// update needReplication priority queues
for|for
control|(
name|Block
name|b
range|:
name|blocks
control|)
block|{
name|updateNeededReplications
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|newRepl
operator|-
name|oldRepl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldRepl
operator|>
name|newRepl
condition|)
block|{
comment|// old replication> the new one; need to remove copies
name|LOG
operator|.
name|info
argument_list|(
literal|"Decreasing replication from "
operator|+
name|oldRepl
operator|+
literal|" to "
operator|+
name|newRepl
operator|+
literal|" for "
operator|+
name|src
argument_list|)
expr_stmt|;
for|for
control|(
name|Block
name|b
range|:
name|blocks
control|)
block|{
name|processOverReplicatedBlock
argument_list|(
name|b
argument_list|,
name|newRepl
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// replication factor is increased
name|LOG
operator|.
name|info
argument_list|(
literal|"Increasing replication from "
operator|+
name|oldRepl
operator|+
literal|" to "
operator|+
name|newRepl
operator|+
literal|" for "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Find how many of the containing nodes are "extra", if any.    * If there are any extras, call chooseExcessReplicates() to    * mark them in the excessReplicateMap.    */
DECL|method|processOverReplicatedBlock (final Block block, final short replication, final DatanodeDescriptor addedNode, DatanodeDescriptor delNodeHint)
specifier|private
name|void
name|processOverReplicatedBlock
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|,
specifier|final
name|DatanodeDescriptor
name|addedNode
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
if|if
condition|(
name|addedNode
operator|==
name|delNodeHint
condition|)
block|{
name|delNodeHint
operator|=
literal|null
expr_stmt|;
block|}
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|nonExcess
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|,
name|State
operator|.
name|NORMAL
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|cur
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|storage
operator|.
name|areBlockContentsStale
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"BLOCK* processOverReplicatedBlock: "
operator|+
literal|"Postponing processing of over-replicated "
operator|+
name|block
operator|+
literal|" since storage + "
operator|+
name|storage
operator|+
literal|"datanode "
operator|+
name|cur
operator|+
literal|" does not yet have up-to-date "
operator|+
literal|"block information."
argument_list|)
expr_stmt|;
name|postponeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return;
block|}
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|excessBlocks
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|cur
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|excessBlocks
operator|==
literal|null
operator|||
operator|!
name|excessBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cur
operator|.
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|cur
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
comment|// exclude corrupt replicas
if|if
condition|(
name|corruptNodes
operator|==
literal|null
operator|||
operator|!
name|corruptNodes
operator|.
name|contains
argument_list|(
name|cur
argument_list|)
condition|)
block|{
name|nonExcess
operator|.
name|add
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|chooseExcessReplicates
argument_list|(
name|nonExcess
argument_list|,
name|block
argument_list|,
name|replication
argument_list|,
name|addedNode
argument_list|,
name|delNodeHint
argument_list|,
name|blockplacement
argument_list|)
expr_stmt|;
block|}
comment|/**    * We want "replication" replicates for the block, but we now have too many.      * In this method, copy enough nodes from 'srcNodes' into 'dstNodes' such that:    *    * srcNodes.size() - dstNodes.size() == replication    *    * We pick node that make sure that replicas are spread across racks and    * also try hard to pick one with least free space.    * The algorithm is first to pick a node with least free space from nodes    * that are on a rack holding more than one replicas of the block.    * So removing such a replica won't remove a rack.     * If no such a node is available,    * then pick a node with least free space    */
DECL|method|chooseExcessReplicates (final Collection<DatanodeStorageInfo> nonExcess, Block b, short replication, DatanodeDescriptor addedNode, DatanodeDescriptor delNodeHint, BlockPlacementPolicy replicator)
specifier|private
name|void
name|chooseExcessReplicates
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|nonExcess
parameter_list|,
name|Block
name|b
parameter_list|,
name|short
name|replication
parameter_list|,
name|DatanodeDescriptor
name|addedNode
parameter_list|,
name|DatanodeDescriptor
name|delNodeHint
parameter_list|,
name|BlockPlacementPolicy
name|replicator
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
comment|// first form a rack to datanodes map and
name|BlockCollection
name|bc
init|=
name|getBlockCollection
argument_list|(
name|b
argument_list|)
decl_stmt|;
specifier|final
name|BlockStoragePolicy
name|storagePolicy
init|=
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|bc
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|StorageType
argument_list|>
name|excessTypes
init|=
name|storagePolicy
operator|.
name|chooseExcess
argument_list|(
name|replication
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageTypes
argument_list|(
name|nonExcess
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|>
name|rackMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|moreThanOne
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|exactlyOne
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeStorageInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// split nodes into two sets
comment|// moreThanOne contains nodes on rack with more than one replica
comment|// exactlyOne contains the remaining nodes
name|replicator
operator|.
name|splitNodesWithRack
argument_list|(
name|nonExcess
argument_list|,
name|rackMap
argument_list|,
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|)
expr_stmt|;
comment|// pick one node to delete that favors the delete hint
comment|// otherwise pick one with least space from priSet if it is not empty
comment|// otherwise one node with least space from remains
name|boolean
name|firstOne
init|=
literal|true
decl_stmt|;
specifier|final
name|DatanodeStorageInfo
name|delNodeHintStorage
init|=
name|DatanodeStorageInfo
operator|.
name|getDatanodeStorageInfo
argument_list|(
name|nonExcess
argument_list|,
name|delNodeHint
argument_list|)
decl_stmt|;
specifier|final
name|DatanodeStorageInfo
name|addedNodeStorage
init|=
name|DatanodeStorageInfo
operator|.
name|getDatanodeStorageInfo
argument_list|(
name|nonExcess
argument_list|,
name|addedNode
argument_list|)
decl_stmt|;
while|while
condition|(
name|nonExcess
operator|.
name|size
argument_list|()
operator|-
name|replication
operator|>
literal|0
condition|)
block|{
specifier|final
name|DatanodeStorageInfo
name|cur
decl_stmt|;
if|if
condition|(
name|useDelHint
argument_list|(
name|firstOne
argument_list|,
name|delNodeHintStorage
argument_list|,
name|addedNodeStorage
argument_list|,
name|moreThanOne
argument_list|,
name|excessTypes
argument_list|)
condition|)
block|{
name|cur
operator|=
name|delNodeHintStorage
expr_stmt|;
block|}
else|else
block|{
comment|// regular excessive replica removal
name|cur
operator|=
name|replicator
operator|.
name|chooseReplicaToDelete
argument_list|(
name|bc
argument_list|,
name|b
argument_list|,
name|replication
argument_list|,
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|,
name|excessTypes
argument_list|)
expr_stmt|;
block|}
name|firstOne
operator|=
literal|false
expr_stmt|;
comment|// adjust rackmap, moreThanOne, and exactlyOne
name|replicator
operator|.
name|adjustSetsWithChosenReplica
argument_list|(
name|rackMap
argument_list|,
name|moreThanOne
argument_list|,
name|exactlyOne
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|nonExcess
operator|.
name|remove
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|addToExcessReplicate
argument_list|(
name|cur
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|//
comment|// The 'excessblocks' tracks blocks until we get confirmation
comment|// that the datanode has deleted them; the only way we remove them
comment|// is when we get a "removeBlock" message.
comment|//
comment|// The 'invalidate' list is used to inform the datanode the block
comment|// should be deleted.  Items are removed from the invalidate list
comment|// upon giving instructions to the namenode.
comment|//
name|addToInvalidates
argument_list|(
name|b
argument_list|,
name|cur
operator|.
name|getDatanodeDescriptor
argument_list|()
argument_list|)
expr_stmt|;
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* chooseExcessReplicates: "
operator|+
literal|"({}, {}) is added to invalidated blocks set"
argument_list|,
name|cur
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Check if we can use delHint */
DECL|method|useDelHint (boolean isFirst, DatanodeStorageInfo delHint, DatanodeStorageInfo added, List<DatanodeStorageInfo> moreThan1Racks, List<StorageType> excessTypes)
specifier|static
name|boolean
name|useDelHint
parameter_list|(
name|boolean
name|isFirst
parameter_list|,
name|DatanodeStorageInfo
name|delHint
parameter_list|,
name|DatanodeStorageInfo
name|added
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|moreThan1Racks
parameter_list|,
name|List
argument_list|<
name|StorageType
argument_list|>
name|excessTypes
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isFirst
condition|)
block|{
return|return
literal|false
return|;
comment|// only consider delHint for the first case
block|}
elseif|else
if|if
condition|(
name|delHint
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
comment|// no delHint
block|}
elseif|else
if|if
condition|(
operator|!
name|excessTypes
operator|.
name|contains
argument_list|(
name|delHint
operator|.
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// delHint storage type is not an excess type
block|}
else|else
block|{
comment|// check if removing delHint reduces the number of racks
if|if
condition|(
name|moreThan1Racks
operator|.
name|contains
argument_list|(
name|delHint
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// delHint and some other nodes are under the same rack
block|}
elseif|else
if|if
condition|(
name|added
operator|!=
literal|null
operator|&&
operator|!
name|moreThan1Racks
operator|.
name|contains
argument_list|(
name|added
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// the added node adds a new rack
block|}
return|return
literal|false
return|;
comment|// removing delHint reduces the number of racks;
block|}
block|}
DECL|method|addToExcessReplicate (DatanodeInfo dn, Block block)
specifier|private
name|void
name|addToExcessReplicate
parameter_list|(
name|DatanodeInfo
name|dn
parameter_list|,
name|Block
name|block
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|excessBlocks
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|excessBlocks
operator|==
literal|null
condition|)
block|{
name|excessBlocks
operator|=
operator|new
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
argument_list|()
expr_stmt|;
name|excessReplicateMap
operator|.
name|put
argument_list|(
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
name|excessBlocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|excessBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|excessBlocksCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* addToExcessReplicate: ({}, {}) is added to"
operator|+
literal|" excessReplicateMap"
argument_list|,
name|dn
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Modify (block-->datanode) map. Possibly generate replication tasks, if the    * removed block is still valid.    */
DECL|method|removeStoredBlock (Block block, DatanodeDescriptor node)
specifier|public
name|void
name|removeStoredBlock
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* removeStoredBlock: {} from {}"
argument_list|,
name|block
argument_list|,
name|node
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
operator|)
assert|;
block|{
if|if
condition|(
operator|!
name|blocksMap
operator|.
name|removeNode
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* removeStoredBlock: {} has already been"
operator|+
literal|" removed from node {}"
argument_list|,
name|block
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//
comment|// It's possible that the block was removed because of a datanode
comment|// failure. If the block is still valid, check if replication is
comment|// necessary. In that case, put block on a possibly-will-
comment|// be-replicated list.
comment|//
name|BlockCollection
name|bc
init|=
name|blocksMap
operator|.
name|getBlockCollection
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|bc
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|decrementSafeBlockCount
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|updateNeededReplications
argument_list|(
name|block
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// We've removed a block from a node, so it's definitely no longer
comment|// in "excess" there.
comment|//
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|excessBlocks
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|node
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|excessBlocks
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|excessBlocks
operator|.
name|remove
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|excessBlocksCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* removeStoredBlock: {} is removed from "
operator|+
literal|"excessBlocks"
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|excessBlocks
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|excessReplicateMap
operator|.
name|remove
argument_list|(
name|node
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remove the replica from corruptReplicas
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get all valid locations of the block& add the block to results    * return the length of the added block; 0 if the block is not added    */
DECL|method|addBlock (Block block, List<BlockWithLocations> results)
specifier|private
name|long
name|addBlock
parameter_list|(
name|Block
name|block
parameter_list|,
name|List
argument_list|<
name|BlockWithLocations
argument_list|>
name|results
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|locations
init|=
name|getValidLocations
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|locations
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
specifier|final
name|String
index|[]
name|datanodeUuids
init|=
operator|new
name|String
index|[
name|locations
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|String
index|[]
name|storageIDs
init|=
operator|new
name|String
index|[
name|datanodeUuids
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|StorageType
index|[]
name|storageTypes
init|=
operator|new
name|StorageType
index|[
name|datanodeUuids
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locations
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|DatanodeStorageInfo
name|s
init|=
name|locations
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|datanodeUuids
index|[
name|i
index|]
operator|=
name|s
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|.
name|getDatanodeUuid
argument_list|()
expr_stmt|;
name|storageIDs
index|[
name|i
index|]
operator|=
name|s
operator|.
name|getStorageID
argument_list|()
expr_stmt|;
name|storageTypes
index|[
name|i
index|]
operator|=
name|s
operator|.
name|getStorageType
argument_list|()
expr_stmt|;
block|}
name|results
operator|.
name|add
argument_list|(
operator|new
name|BlockWithLocations
argument_list|(
name|block
argument_list|,
name|datanodeUuids
argument_list|,
name|storageIDs
argument_list|,
name|storageTypes
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|block
operator|.
name|getNumBytes
argument_list|()
return|;
block|}
block|}
comment|/**    * The given node is reporting that it received a certain block.    */
annotation|@
name|VisibleForTesting
DECL|method|addBlock (DatanodeStorageInfo storageInfo, Block block, String delHint)
name|void
name|addBlock
parameter_list|(
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|Block
name|block
parameter_list|,
name|String
name|delHint
parameter_list|)
throws|throws
name|IOException
block|{
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
comment|// Decrement number of blocks scheduled to this datanode.
comment|// for a retry request (of DatanodeProtocol#blockReceivedAndDeleted with
comment|// RECEIVED_BLOCK), we currently also decrease the approximate number.
name|node
operator|.
name|decrementBlocksScheduled
argument_list|(
name|storageInfo
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
comment|// get the deletion hint node
name|DatanodeDescriptor
name|delHintNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|delHint
operator|!=
literal|null
operator|&&
name|delHint
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|delHintNode
operator|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|delHint
argument_list|)
expr_stmt|;
if|if
condition|(
name|delHintNode
operator|==
literal|null
condition|)
block|{
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* blockReceived: {} is expected to be removed "
operator|+
literal|"from an unrecorded node {}"
argument_list|,
name|block
argument_list|,
name|delHint
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Modify the blocks->datanode map and node's map.
comment|//
name|pendingReplications
operator|.
name|decrement
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|processAndHandleReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|block
argument_list|,
name|ReplicaState
operator|.
name|FINALIZED
argument_list|,
name|delHintNode
argument_list|)
expr_stmt|;
block|}
DECL|method|processAndHandleReportedBlock ( DatanodeStorageInfo storageInfo, Block block, ReplicaState reportedState, DatanodeDescriptor delHintNode)
specifier|private
name|void
name|processAndHandleReportedBlock
parameter_list|(
name|DatanodeStorageInfo
name|storageInfo
parameter_list|,
name|Block
name|block
parameter_list|,
name|ReplicaState
name|reportedState
parameter_list|,
name|DatanodeDescriptor
name|delHintNode
parameter_list|)
throws|throws
name|IOException
block|{
comment|// blockReceived reports a finalized block
name|Collection
argument_list|<
name|BlockInfoContiguous
argument_list|>
name|toAdd
init|=
operator|new
name|LinkedList
argument_list|<
name|BlockInfoContiguous
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Block
argument_list|>
name|toInvalidate
init|=
operator|new
name|LinkedList
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|BlockToMarkCorrupt
argument_list|>
name|toCorrupt
init|=
operator|new
name|LinkedList
argument_list|<
name|BlockToMarkCorrupt
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|StatefulBlockInfo
argument_list|>
name|toUC
init|=
operator|new
name|LinkedList
argument_list|<
name|StatefulBlockInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storageInfo
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
name|processReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|block
argument_list|,
name|reportedState
argument_list|,
name|toAdd
argument_list|,
name|toInvalidate
argument_list|,
name|toCorrupt
argument_list|,
name|toUC
argument_list|)
expr_stmt|;
comment|// the block is only in one of the to-do lists
comment|// if it is in none then data-node already has it
assert|assert
name|toUC
operator|.
name|size
argument_list|()
operator|+
name|toAdd
operator|.
name|size
argument_list|()
operator|+
name|toInvalidate
operator|.
name|size
argument_list|()
operator|+
name|toCorrupt
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|:
literal|"The block should be only in one of the lists."
assert|;
for|for
control|(
name|StatefulBlockInfo
name|b
range|:
name|toUC
control|)
block|{
name|addStoredBlockUnderConstruction
argument_list|(
name|b
argument_list|,
name|storageInfo
argument_list|)
expr_stmt|;
block|}
name|long
name|numBlocksLogged
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockInfoContiguous
name|b
range|:
name|toAdd
control|)
block|{
name|addStoredBlock
argument_list|(
name|b
argument_list|,
name|storageInfo
argument_list|,
name|delHintNode
argument_list|,
name|numBlocksLogged
operator|<
name|maxNumBlocksToLog
argument_list|)
expr_stmt|;
name|numBlocksLogged
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|numBlocksLogged
operator|>
name|maxNumBlocksToLog
condition|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* addBlock: logged info for {} of {} reported."
argument_list|,
name|maxNumBlocksToLog
argument_list|,
name|numBlocksLogged
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Block
name|b
range|:
name|toInvalidate
control|)
block|{
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* addBlock: block {} on node {} size {} does not "
operator|+
literal|"belong to any file"
argument_list|,
name|b
argument_list|,
name|node
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
name|b
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BlockToMarkCorrupt
name|b
range|:
name|toCorrupt
control|)
block|{
name|markBlockAsCorrupt
argument_list|(
name|b
argument_list|,
name|storageInfo
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The given node is reporting incremental information about some blocks.    * This includes blocks that are starting to be received, completed being    * received, or deleted.    *     * This method must be called with FSNamesystem lock held.    */
DECL|method|processIncrementalBlockReport (final DatanodeID nodeID, final StorageReceivedDeletedBlocks srdb)
specifier|public
name|void
name|processIncrementalBlockReport
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|,
specifier|final
name|StorageReceivedDeletedBlocks
name|srdb
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|int
name|received
init|=
literal|0
decl_stmt|;
name|int
name|deleted
init|=
literal|0
decl_stmt|;
name|int
name|receiving
init|=
literal|0
decl_stmt|;
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|nodeID
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|||
operator|!
name|node
operator|.
name|isAlive
condition|)
block|{
name|blockLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* processIncrementalBlockReport"
operator|+
literal|" is received from dead or unregistered node {}"
argument_list|,
name|nodeID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got incremental block report from unregistered or dead node"
argument_list|)
throw|;
block|}
name|DatanodeStorageInfo
name|storageInfo
init|=
name|node
operator|.
name|getStorageInfo
argument_list|(
name|srdb
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageInfo
operator|==
literal|null
condition|)
block|{
comment|// The DataNode is reporting an unknown storage. Usually the NN learns
comment|// about new storages from heartbeats but during NN restart we may
comment|// receive a block report or incremental report before the heartbeat.
comment|// We must handle this for protocol compatibility. This issue was
comment|// uncovered by HDFS-6094.
name|storageInfo
operator|=
name|node
operator|.
name|updateStorage
argument_list|(
name|srdb
operator|.
name|getStorage
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ReceivedDeletedBlockInfo
name|rdbi
range|:
name|srdb
operator|.
name|getBlocks
argument_list|()
control|)
block|{
switch|switch
condition|(
name|rdbi
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|DELETED_BLOCK
case|:
name|removeStoredBlock
argument_list|(
name|rdbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|deleted
operator|++
expr_stmt|;
break|break;
case|case
name|RECEIVED_BLOCK
case|:
name|addBlock
argument_list|(
name|storageInfo
argument_list|,
name|rdbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|rdbi
operator|.
name|getDelHints
argument_list|()
argument_list|)
expr_stmt|;
name|received
operator|++
expr_stmt|;
break|break;
case|case
name|RECEIVING_BLOCK
case|:
name|receiving
operator|++
expr_stmt|;
name|processAndHandleReportedBlock
argument_list|(
name|storageInfo
argument_list|,
name|rdbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|ReplicaState
operator|.
name|RBW
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
default|default:
name|String
name|msg
init|=
literal|"Unknown block status code reported by "
operator|+
name|nodeID
operator|+
literal|": "
operator|+
name|rdbi
decl_stmt|;
name|blockLog
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
assert|assert
literal|false
operator|:
name|msg
assert|;
comment|// if assertions are enabled, throw.
break|break;
block|}
name|blockLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* block {}: {} is received from {}"
argument_list|,
name|rdbi
operator|.
name|getStatus
argument_list|()
argument_list|,
name|rdbi
operator|.
name|getBlock
argument_list|()
argument_list|,
name|nodeID
argument_list|)
expr_stmt|;
block|}
name|blockLog
operator|.
name|debug
argument_list|(
literal|"*BLOCK* NameNode.processIncrementalBlockReport: from "
operator|+
literal|"{} receiving: {}, received: {}, deleted: {}"
argument_list|,
name|nodeID
argument_list|,
name|receiving
argument_list|,
name|received
argument_list|,
name|deleted
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the number of nodes hosting a given block, grouped    * by the state of those replicas.    */
DECL|method|countNodes (Block b)
specifier|public
name|NumberReplicas
name|countNodes
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
name|int
name|decommissioned
init|=
literal|0
decl_stmt|;
name|int
name|decommissioning
init|=
literal|0
decl_stmt|;
name|int
name|live
init|=
literal|0
decl_stmt|;
name|int
name|corrupt
init|=
literal|0
decl_stmt|;
name|int
name|excess
init|=
literal|0
decl_stmt|;
name|int
name|stale
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesCorrupt
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|b
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|b
argument_list|,
name|State
operator|.
name|NORMAL
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|nodesCorrupt
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|nodesCorrupt
operator|.
name|contains
argument_list|(
name|node
argument_list|)
operator|)
condition|)
block|{
name|corrupt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
name|decommissioning
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
name|decommissioned
operator|++
expr_stmt|;
block|}
else|else
block|{
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|blocksExcess
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|node
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocksExcess
operator|!=
literal|null
operator|&&
name|blocksExcess
operator|.
name|contains
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|excess
operator|++
expr_stmt|;
block|}
else|else
block|{
name|live
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|storage
operator|.
name|areBlockContentsStale
argument_list|()
condition|)
block|{
name|stale
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|new
name|NumberReplicas
argument_list|(
name|live
argument_list|,
name|decommissioned
argument_list|,
name|decommissioning
argument_list|,
name|corrupt
argument_list|,
name|excess
argument_list|,
name|stale
argument_list|)
return|;
block|}
comment|/**     * Simpler, faster form of {@link #countNodes(Block)} that only returns the number    * of live nodes.  If in startup safemode (or its 30-sec extension period),    * then it gains speed by ignoring issues of excess replicas or nodes    * that are decommissioned or in process of becoming decommissioned.    * If not in startup, then it calls {@link #countNodes(Block)} instead.    *     * @param b - the block being tested    * @return count of live nodes for this block    */
DECL|method|countLiveNodes (BlockInfoContiguous b)
name|int
name|countLiveNodes
parameter_list|(
name|BlockInfoContiguous
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isInStartupSafeMode
argument_list|()
condition|)
block|{
return|return
name|countNodes
argument_list|(
name|b
argument_list|)
operator|.
name|liveReplicas
argument_list|()
return|;
block|}
comment|// else proceed with fast case
name|int
name|live
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodesCorrupt
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|b
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|b
argument_list|,
name|State
operator|.
name|NORMAL
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|nodesCorrupt
operator|==
literal|null
operator|)
operator|||
operator|(
operator|!
name|nodesCorrupt
operator|.
name|contains
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|live
operator|++
expr_stmt|;
block|}
return|return
name|live
return|;
block|}
comment|/**    * On stopping decommission, check if the node has excess replicas.    * If there are any excess replicas, call processOverReplicatedBlock().    * Process over replicated blocks only when active NN is out of safe mode.    */
DECL|method|processOverReplicatedBlocksOnReCommission ( final DatanodeDescriptor srcNode)
name|void
name|processOverReplicatedBlocksOnReCommission
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|srcNode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|Block
argument_list|>
name|it
init|=
name|srcNode
operator|.
name|getBlockIterator
argument_list|()
decl_stmt|;
name|int
name|numOverReplicated
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|final
name|Block
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|BlockCollection
name|bc
init|=
name|blocksMap
operator|.
name|getBlockCollection
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|short
name|expectedReplication
init|=
name|bc
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
name|NumberReplicas
name|num
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|numCurrentReplica
init|=
name|num
operator|.
name|liveReplicas
argument_list|()
decl_stmt|;
if|if
condition|(
name|numCurrentReplica
operator|>
name|expectedReplication
condition|)
block|{
comment|// over-replicated block
name|processOverReplicatedBlock
argument_list|(
name|block
argument_list|,
name|expectedReplication
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|numOverReplicated
operator|++
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Invalidated "
operator|+
name|numOverReplicated
operator|+
literal|" over-replicated blocks on "
operator|+
name|srcNode
operator|+
literal|" during recommissioning"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns whether a node can be safely decommissioned based on its     * liveness. Dead nodes cannot always be safely decommissioned.    */
DECL|method|isNodeHealthyForDecommission (DatanodeDescriptor node)
name|boolean
name|isNodeHealthyForDecommission
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|.
name|checkBlockReportReceived
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Node {} hasn't sent its first block report."
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|node
operator|.
name|isAlive
condition|)
block|{
return|return
literal|true
return|;
block|}
name|updateState
argument_list|()
expr_stmt|;
if|if
condition|(
name|pendingReplicationBlocksCount
operator|==
literal|0
operator|&&
name|underReplicatedBlocksCount
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Node {} is dead and there are no under-replicated"
operator|+
literal|" blocks or blocks pending replication. Safe to decommission."
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Node {} is dead "
operator|+
literal|"while decommission is in progress. Cannot be safely "
operator|+
literal|"decommissioned since there is risk of reduced "
operator|+
literal|"data durability or data loss. Either restart the failed node or"
operator|+
literal|" force decommissioning by removing, calling refreshNodes, "
operator|+
literal|"then re-adding to the excludes files."
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|getActiveBlockCount ()
specifier|public
name|int
name|getActiveBlockCount
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getStorages (BlockInfoContiguous block)
specifier|public
name|DatanodeStorageInfo
index|[]
name|getStorages
parameter_list|(
name|BlockInfoContiguous
name|block
parameter_list|)
block|{
specifier|final
name|DatanodeStorageInfo
index|[]
name|storages
init|=
operator|new
name|DatanodeStorageInfo
index|[
name|block
operator|.
name|numNodes
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|s
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
name|storages
index|[
name|i
operator|++
index|]
operator|=
name|s
expr_stmt|;
block|}
return|return
name|storages
return|;
block|}
DECL|method|getTotalBlocks ()
specifier|public
name|int
name|getTotalBlocks
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|removeBlock (Block block)
specifier|public
name|void
name|removeBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
comment|// No need to ACK blocks that are being removed entirely
comment|// from the namespace, since the removal of the associated
comment|// file already removes them from the block map below.
name|block
operator|.
name|setNumBytes
argument_list|(
name|BlockCommand
operator|.
name|NO_ACK
argument_list|)
expr_stmt|;
name|addToInvalidates
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|removeBlockFromMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// Remove the block from pendingReplications and neededReplications
name|pendingReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|UnderReplicatedBlocks
operator|.
name|LEVEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|postponedMisreplicatedBlocks
operator|.
name|remove
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|postponedMisreplicatedBlocksCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getStoredBlock (Block block)
specifier|public
name|BlockInfoContiguous
name|getStoredBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|getStoredBlock
argument_list|(
name|block
argument_list|)
return|;
block|}
comment|/** updates a block in under replication queue */
DECL|method|updateNeededReplications (final Block block, final int curReplicasDelta, int expectedReplicasDelta)
specifier|private
name|void
name|updateNeededReplications
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|,
specifier|final
name|int
name|curReplicasDelta
parameter_list|,
name|int
name|expectedReplicasDelta
parameter_list|)
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
return|return;
block|}
name|NumberReplicas
name|repl
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|curExpectedReplicas
init|=
name|getReplication
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNeededReplication
argument_list|(
name|block
argument_list|,
name|curExpectedReplicas
argument_list|,
name|repl
operator|.
name|liveReplicas
argument_list|()
argument_list|)
condition|)
block|{
name|neededReplications
operator|.
name|update
argument_list|(
name|block
argument_list|,
name|repl
operator|.
name|liveReplicas
argument_list|()
argument_list|,
name|repl
operator|.
name|decommissionedAndDecommissioning
argument_list|()
argument_list|,
name|curExpectedReplicas
argument_list|,
name|curReplicasDelta
argument_list|,
name|expectedReplicasDelta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|oldReplicas
init|=
name|repl
operator|.
name|liveReplicas
argument_list|()
operator|-
name|curReplicasDelta
decl_stmt|;
name|int
name|oldExpectedReplicas
init|=
name|curExpectedReplicas
operator|-
name|expectedReplicasDelta
decl_stmt|;
name|neededReplications
operator|.
name|remove
argument_list|(
name|block
argument_list|,
name|oldReplicas
argument_list|,
name|repl
operator|.
name|decommissionedAndDecommissioning
argument_list|()
argument_list|,
name|oldExpectedReplicas
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check replication of the blocks in the collection.    * If any block is needed replication, insert it into the replication queue.    * Otherwise, if the block is more than the expected replication factor,    * process it as an over replicated block.    */
DECL|method|checkReplication (BlockCollection bc)
specifier|public
name|void
name|checkReplication
parameter_list|(
name|BlockCollection
name|bc
parameter_list|)
block|{
specifier|final
name|short
name|expected
init|=
name|bc
operator|.
name|getBlockReplication
argument_list|()
decl_stmt|;
for|for
control|(
name|Block
name|block
range|:
name|bc
operator|.
name|getBlocks
argument_list|()
control|)
block|{
specifier|final
name|NumberReplicas
name|n
init|=
name|countNodes
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNeededReplication
argument_list|(
name|block
argument_list|,
name|expected
argument_list|,
name|n
operator|.
name|liveReplicas
argument_list|()
argument_list|)
condition|)
block|{
name|neededReplications
operator|.
name|add
argument_list|(
name|block
argument_list|,
name|n
operator|.
name|liveReplicas
argument_list|()
argument_list|,
name|n
operator|.
name|decommissionedAndDecommissioning
argument_list|()
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|.
name|liveReplicas
argument_list|()
operator|>
name|expected
condition|)
block|{
name|processOverReplicatedBlock
argument_list|(
name|block
argument_list|,
name|expected
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check that the indicated blocks are present and    * replicated.    */
DECL|method|checkBlocksProperlyReplicated ( String src, BlockInfoContiguous[] blocks)
specifier|public
name|boolean
name|checkBlocksProperlyReplicated
parameter_list|(
name|String
name|src
parameter_list|,
name|BlockInfoContiguous
index|[]
name|blocks
parameter_list|)
block|{
for|for
control|(
name|BlockInfoContiguous
name|b
range|:
name|blocks
control|)
block|{
if|if
condition|(
operator|!
name|b
operator|.
name|isComplete
argument_list|()
condition|)
block|{
specifier|final
name|BlockInfoContiguousUnderConstruction
name|uc
init|=
operator|(
name|BlockInfoContiguousUnderConstruction
operator|)
name|b
decl_stmt|;
specifier|final
name|int
name|numNodes
init|=
name|b
operator|.
name|numNodes
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"BLOCK* "
operator|+
name|b
operator|+
literal|" is not COMPLETE (ucState = "
operator|+
name|uc
operator|.
name|getBlockUCState
argument_list|()
operator|+
literal|", replication# = "
operator|+
name|numNodes
operator|+
operator|(
name|numNodes
operator|<
name|minReplication
condition|?
literal|"< "
else|:
literal|">= "
operator|)
operator|+
literal|" minimum = "
operator|+
name|minReplication
operator|+
literal|") in file "
operator|+
name|src
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**     * @return 0 if the block is not found;    *         otherwise, return the replication factor of the block.    */
DECL|method|getReplication (Block block)
specifier|private
name|int
name|getReplication
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
specifier|final
name|BlockCollection
name|bc
init|=
name|blocksMap
operator|.
name|getBlockCollection
argument_list|(
name|block
argument_list|)
decl_stmt|;
return|return
name|bc
operator|==
literal|null
condition|?
literal|0
else|:
name|bc
operator|.
name|getBlockReplication
argument_list|()
return|;
block|}
comment|/**    * Get blocks to invalidate for<i>nodeId</i>    * in {@link #invalidateBlocks}.    *    * @return number of blocks scheduled for removal during this iteration.    */
DECL|method|invalidateWorkForOneNode (DatanodeInfo dn)
specifier|private
name|int
name|invalidateWorkForOneNode
parameter_list|(
name|DatanodeInfo
name|dn
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Block
argument_list|>
name|toInvalidate
decl_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// blocks should not be replicated or removed if safe mode is on
if|if
condition|(
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"In safemode, not computing replication work"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
try|try
block|{
name|DatanodeDescriptor
name|dnDescriptor
init|=
name|datanodeManager
operator|.
name|getDatanode
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnDescriptor
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DataNode "
operator|+
name|dn
operator|+
literal|" cannot be found with UUID "
operator|+
name|dn
operator|.
name|getDatanodeUuid
argument_list|()
operator|+
literal|", removing block invalidation work."
argument_list|)
expr_stmt|;
name|invalidateBlocks
operator|.
name|remove
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|toInvalidate
operator|=
name|invalidateBlocks
operator|.
name|invalidateWork
argument_list|(
name|dnDescriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|toInvalidate
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
catch|catch
parameter_list|(
name|UnregisteredNodeException
name|une
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|blockLog
operator|.
name|info
argument_list|(
literal|"BLOCK* {}: ask {} to delete {}"
argument_list|,
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|dn
argument_list|,
name|toInvalidate
argument_list|)
expr_stmt|;
return|return
name|toInvalidate
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|blockHasEnoughRacks (Block b)
name|boolean
name|blockHasEnoughRacks
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|shouldCheckForEnoughRacks
condition|)
block|{
return|return
literal|true
return|;
block|}
name|boolean
name|enoughRacks
init|=
literal|false
decl_stmt|;
empty_stmt|;
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|corruptNodes
init|=
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|int
name|numExpectedReplicas
init|=
name|getReplication
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|String
name|rackName
init|=
literal|null
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|b
argument_list|)
control|)
block|{
specifier|final
name|DatanodeDescriptor
name|cur
init|=
name|storage
operator|.
name|getDatanodeDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cur
operator|.
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|cur
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|corruptNodes
operator|==
literal|null
operator|)
operator|||
operator|!
name|corruptNodes
operator|.
name|contains
argument_list|(
name|cur
argument_list|)
condition|)
block|{
if|if
condition|(
name|numExpectedReplicas
operator|==
literal|1
operator|||
operator|(
name|numExpectedReplicas
operator|>
literal|1
operator|&&
operator|!
name|datanodeManager
operator|.
name|hasClusterEverBeenMultiRack
argument_list|()
operator|)
condition|)
block|{
name|enoughRacks
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|String
name|rackNameNew
init|=
name|cur
operator|.
name|getNetworkLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|rackName
operator|==
literal|null
condition|)
block|{
name|rackName
operator|=
name|rackNameNew
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rackName
operator|.
name|equals
argument_list|(
name|rackNameNew
argument_list|)
condition|)
block|{
name|enoughRacks
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|enoughRacks
return|;
block|}
comment|/**    * A block needs replication if the number of replicas is less than expected    * or if it does not have enough racks.    */
DECL|method|isNeededReplication (Block b, int expected, int current)
name|boolean
name|isNeededReplication
parameter_list|(
name|Block
name|b
parameter_list|,
name|int
name|expected
parameter_list|,
name|int
name|current
parameter_list|)
block|{
return|return
name|current
operator|<
name|expected
operator|||
operator|!
name|blockHasEnoughRacks
argument_list|(
name|b
argument_list|)
return|;
block|}
DECL|method|getMissingBlocksCount ()
specifier|public
name|long
name|getMissingBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|this
operator|.
name|neededReplications
operator|.
name|getCorruptBlockSize
argument_list|()
return|;
block|}
DECL|method|getMissingReplOneBlocksCount ()
specifier|public
name|long
name|getMissingReplOneBlocksCount
parameter_list|()
block|{
comment|// not locking
return|return
name|this
operator|.
name|neededReplications
operator|.
name|getCorruptReplOneBlockSize
argument_list|()
return|;
block|}
DECL|method|addBlockCollection (BlockInfoContiguous block, BlockCollection bc)
specifier|public
name|BlockInfoContiguous
name|addBlockCollection
parameter_list|(
name|BlockInfoContiguous
name|block
parameter_list|,
name|BlockCollection
name|bc
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|addBlockCollection
argument_list|(
name|block
argument_list|,
name|bc
argument_list|)
return|;
block|}
DECL|method|getBlockCollection (Block b)
specifier|public
name|BlockCollection
name|getBlockCollection
parameter_list|(
name|Block
name|b
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|getBlockCollection
argument_list|(
name|b
argument_list|)
return|;
block|}
comment|/** @return an iterator of the datanodes. */
DECL|method|getStorages (final Block block)
specifier|public
name|Iterable
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|getStorages
parameter_list|(
specifier|final
name|Block
name|block
parameter_list|)
block|{
return|return
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|numCorruptReplicas (Block block)
specifier|public
name|int
name|numCorruptReplicas
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|numCorruptReplicas
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|removeBlockFromMap (Block block)
specifier|public
name|void
name|removeBlockFromMap
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|removeFromExcessReplicateMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|blocksMap
operator|.
name|removeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|// If block is removed from blocksMap remove it from corruptReplicasMap
name|corruptReplicas
operator|.
name|removeFromCorruptReplicasMap
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/**    * If a block is removed from blocksMap, remove it from excessReplicateMap.    */
DECL|method|removeFromExcessReplicateMap (Block block)
specifier|private
name|void
name|removeFromExcessReplicateMap
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|info
range|:
name|blocksMap
operator|.
name|getStorages
argument_list|(
name|block
argument_list|)
control|)
block|{
name|String
name|uuid
init|=
name|info
operator|.
name|getDatanodeDescriptor
argument_list|()
operator|.
name|getDatanodeUuid
argument_list|()
decl_stmt|;
name|LightWeightLinkedSet
argument_list|<
name|Block
argument_list|>
name|excessReplicas
init|=
name|excessReplicateMap
operator|.
name|get
argument_list|(
name|uuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|excessReplicas
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|excessReplicas
operator|.
name|remove
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|excessBlocksCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|excessReplicas
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|excessReplicateMap
operator|.
name|remove
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|getCapacity ()
specifier|public
name|int
name|getCapacity
parameter_list|()
block|{
return|return
name|blocksMap
operator|.
name|getCapacity
argument_list|()
return|;
block|}
comment|/**    * Return a range of corrupt replica block ids. Up to numExpectedBlocks     * blocks starting at the next block after startingBlockId are returned    * (fewer if numExpectedBlocks blocks are unavailable). If startingBlockId     * is null, up to numExpectedBlocks blocks are returned from the beginning.    * If startingBlockId cannot be found, null is returned.    *    * @param numExpectedBlocks Number of block ids to return.    *  0<= numExpectedBlocks<= 100    * @param startingBlockId Block id from which to start. If null, start at    *  beginning.    * @return Up to numExpectedBlocks blocks from startingBlockId if it exists    *    */
DECL|method|getCorruptReplicaBlockIds (int numExpectedBlocks, Long startingBlockId)
specifier|public
name|long
index|[]
name|getCorruptReplicaBlockIds
parameter_list|(
name|int
name|numExpectedBlocks
parameter_list|,
name|Long
name|startingBlockId
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|getCorruptReplicaBlockIds
argument_list|(
name|numExpectedBlocks
argument_list|,
name|startingBlockId
argument_list|)
return|;
block|}
comment|/**    * Return an iterator over the set of blocks for which there are no replicas.    */
DECL|method|getCorruptReplicaBlockIterator ()
specifier|public
name|Iterator
argument_list|<
name|Block
argument_list|>
name|getCorruptReplicaBlockIterator
parameter_list|()
block|{
return|return
name|neededReplications
operator|.
name|iterator
argument_list|(
name|UnderReplicatedBlocks
operator|.
name|QUEUE_WITH_CORRUPT_BLOCKS
argument_list|)
return|;
block|}
comment|/**    * Get the replicas which are corrupt for a given block.    */
DECL|method|getCorruptReplicas (Block block)
specifier|public
name|Collection
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|getCorruptReplicas
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|getNodes
argument_list|(
name|block
argument_list|)
return|;
block|}
comment|/**   * Get reason for certain corrupted replicas for a given block and a given dn.   */
DECL|method|getCorruptReason (Block block, DatanodeDescriptor node)
specifier|public
name|String
name|getCorruptReason
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
return|return
name|corruptReplicas
operator|.
name|getCorruptReason
argument_list|(
name|block
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** @return the size of UnderReplicatedBlocks */
DECL|method|numOfUnderReplicatedBlocks ()
specifier|public
name|int
name|numOfUnderReplicatedBlocks
parameter_list|()
block|{
return|return
name|neededReplications
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Periodically calls computeReplicationWork().    */
DECL|class|ReplicationMonitor
specifier|private
class|class
name|ReplicationMonitor
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
try|try
block|{
comment|// Process replication work only when active NN is out of safe mode.
if|if
condition|(
name|namesystem
operator|.
name|isPopulatingReplQueues
argument_list|()
condition|)
block|{
name|computeDatanodeWork
argument_list|()
expr_stmt|;
name|processPendingReplications
argument_list|()
expr_stmt|;
name|rescanPostponedMisreplicatedBlocks
argument_list|()
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|replicationRecheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|isRunning
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping ReplicationMonitor."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|instanceof
name|InterruptedException
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ReplicationMonitor received an exception"
operator|+
literal|" while shutting down."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|checkNSRunning
operator|&&
name|t
operator|instanceof
name|InterruptedException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping ReplicationMonitor for testing."
argument_list|)
expr_stmt|;
break|break;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"ReplicationMonitor thread received Runtime exception. "
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Compute block replication and block invalidation work that can be scheduled    * on data-nodes. The datanode will be informed of this work at the next    * heartbeat.    *     * @return number of blocks scheduled for replication or removal.    */
DECL|method|computeDatanodeWork ()
name|int
name|computeDatanodeWork
parameter_list|()
block|{
comment|// Blocks should not be replicated or removed if in safe mode.
comment|// It's OK to check safe mode here w/o holding lock, in the worst
comment|// case extra replications will be scheduled, and these will get
comment|// fixed up later.
if|if
condition|(
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|int
name|numlive
init|=
name|heartbeatManager
operator|.
name|getLiveDatanodeCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|blocksToProcess
init|=
name|numlive
operator|*
name|this
operator|.
name|blocksReplWorkMultiplier
decl_stmt|;
specifier|final
name|int
name|nodesToProcess
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|numlive
operator|*
name|this
operator|.
name|blocksInvalidateWorkPct
argument_list|)
decl_stmt|;
name|int
name|workFound
init|=
name|this
operator|.
name|computeReplicationWork
argument_list|(
name|blocksToProcess
argument_list|)
decl_stmt|;
comment|// Update counters
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|updateState
argument_list|()
expr_stmt|;
name|this
operator|.
name|scheduledReplicationBlocksCount
operator|=
name|workFound
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
name|workFound
operator|+=
name|this
operator|.
name|computeInvalidateWork
argument_list|(
name|nodesToProcess
argument_list|)
expr_stmt|;
return|return
name|workFound
return|;
block|}
comment|/**    * Clear all queues that hold decisions previously made by    * this NameNode.    */
DECL|method|clearQueues ()
specifier|public
name|void
name|clearQueues
parameter_list|()
block|{
name|neededReplications
operator|.
name|clear
argument_list|()
expr_stmt|;
name|pendingReplications
operator|.
name|clear
argument_list|()
expr_stmt|;
name|excessReplicateMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|invalidateBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|datanodeManager
operator|.
name|clearPendingQueues
argument_list|()
expr_stmt|;
name|postponedMisreplicatedBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|postponedMisreplicatedBlocksCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
DECL|method|newLocatedBlock ( ExtendedBlock b, DatanodeStorageInfo[] storages, long startOffset, boolean corrupt)
specifier|public
specifier|static
name|LocatedBlock
name|newLocatedBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|storages
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|boolean
name|corrupt
parameter_list|)
block|{
comment|// startOffset is unknown
return|return
operator|new
name|LocatedBlock
argument_list|(
name|b
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toDatanodeInfos
argument_list|(
name|storages
argument_list|)
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageIDs
argument_list|(
name|storages
argument_list|)
argument_list|,
name|DatanodeStorageInfo
operator|.
name|toStorageTypes
argument_list|(
name|storages
argument_list|)
argument_list|,
name|startOffset
argument_list|,
name|corrupt
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|class|ReplicationWork
specifier|private
specifier|static
class|class
name|ReplicationWork
block|{
DECL|field|block
specifier|private
specifier|final
name|Block
name|block
decl_stmt|;
DECL|field|bc
specifier|private
specifier|final
name|BlockCollection
name|bc
decl_stmt|;
DECL|field|srcNode
specifier|private
specifier|final
name|DatanodeDescriptor
name|srcNode
decl_stmt|;
DECL|field|containingNodes
specifier|private
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
decl_stmt|;
DECL|field|liveReplicaStorages
specifier|private
specifier|final
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|liveReplicaStorages
decl_stmt|;
DECL|field|additionalReplRequired
specifier|private
specifier|final
name|int
name|additionalReplRequired
decl_stmt|;
DECL|field|targets
specifier|private
name|DatanodeStorageInfo
name|targets
index|[]
decl_stmt|;
DECL|field|priority
specifier|private
specifier|final
name|int
name|priority
decl_stmt|;
DECL|method|ReplicationWork (Block block, BlockCollection bc, DatanodeDescriptor srcNode, List<DatanodeDescriptor> containingNodes, List<DatanodeStorageInfo> liveReplicaStorages, int additionalReplRequired, int priority)
specifier|public
name|ReplicationWork
parameter_list|(
name|Block
name|block
parameter_list|,
name|BlockCollection
name|bc
parameter_list|,
name|DatanodeDescriptor
name|srcNode
parameter_list|,
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|containingNodes
parameter_list|,
name|List
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|liveReplicaStorages
parameter_list|,
name|int
name|additionalReplRequired
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|this
operator|.
name|bc
operator|=
name|bc
expr_stmt|;
name|this
operator|.
name|srcNode
operator|=
name|srcNode
expr_stmt|;
name|this
operator|.
name|srcNode
operator|.
name|incrementPendingReplicationWithoutTargets
argument_list|()
expr_stmt|;
name|this
operator|.
name|containingNodes
operator|=
name|containingNodes
expr_stmt|;
name|this
operator|.
name|liveReplicaStorages
operator|=
name|liveReplicaStorages
expr_stmt|;
name|this
operator|.
name|additionalReplRequired
operator|=
name|additionalReplRequired
expr_stmt|;
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|this
operator|.
name|targets
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|chooseTargets (BlockPlacementPolicy blockplacement, BlockStoragePolicySuite storagePolicySuite, Set<Node> excludedNodes)
specifier|private
name|void
name|chooseTargets
parameter_list|(
name|BlockPlacementPolicy
name|blockplacement
parameter_list|,
name|BlockStoragePolicySuite
name|storagePolicySuite
parameter_list|,
name|Set
argument_list|<
name|Node
argument_list|>
name|excludedNodes
parameter_list|)
block|{
try|try
block|{
name|targets
operator|=
name|blockplacement
operator|.
name|chooseTarget
argument_list|(
name|bc
operator|.
name|getName
argument_list|()
argument_list|,
name|additionalReplRequired
argument_list|,
name|srcNode
argument_list|,
name|liveReplicaStorages
argument_list|,
literal|false
argument_list|,
name|excludedNodes
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|storagePolicySuite
operator|.
name|getPolicy
argument_list|(
name|bc
operator|.
name|getStoragePolicyID
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|srcNode
operator|.
name|decrementPendingReplicationWithoutTargets
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A simple result enum for the result of    * {@link BlockManager#processMisReplicatedBlock(BlockInfoContiguous)}.    */
DECL|enum|MisReplicationResult
enum|enum
name|MisReplicationResult
block|{
comment|/** The block should be invalidated since it belongs to a deleted file. */
DECL|enumConstant|INVALID
name|INVALID
block|,
comment|/** The block is currently under-replicated. */
DECL|enumConstant|UNDER_REPLICATED
name|UNDER_REPLICATED
block|,
comment|/** The block is currently over-replicated. */
DECL|enumConstant|OVER_REPLICATED
name|OVER_REPLICATED
block|,
comment|/** A decision can't currently be made about this block. */
DECL|enumConstant|POSTPONE
name|POSTPONE
block|,
comment|/** The block is under construction, so should be ignored */
DECL|enumConstant|UNDER_CONSTRUCTION
name|UNDER_CONSTRUCTION
block|,
comment|/** The block is properly replicated */
DECL|enumConstant|OK
name|OK
block|}
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|stopReplicationInitializer
argument_list|()
expr_stmt|;
name|blocksMap
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|clearQueues
argument_list|()
expr_stmt|;
name|blocksMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

