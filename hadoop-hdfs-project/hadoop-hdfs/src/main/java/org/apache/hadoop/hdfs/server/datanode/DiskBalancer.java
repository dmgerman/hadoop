begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|codec
operator|.
name|digest
operator|.
name|DigestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsDatasetSpi
operator|.
name|FsVolumeReferences
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|AutoCloseableLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DiskBalancerWorkStatus
operator|.
name|DiskBalancerWorkEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DiskBalancerWorkStatus
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsDatasetSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|diskbalancer
operator|.
name|DiskBalancerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|diskbalancer
operator|.
name|DiskBalancerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|diskbalancer
operator|.
name|planner
operator|.
name|NodePlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|diskbalancer
operator|.
name|planner
operator|.
name|Step
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|web
operator|.
name|JsonUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * Worker class for Disk Balancer.  *<p>  * Here is the high level logic executed by this class. Users can submit disk  * balancing plans using submitPlan calls. After a set of sanity checks the plan  * is admitted and put into workMap.  *<p>  * The executePlan launches a thread that picks up work from workMap and hands  * it over to the BlockMover#copyBlocks function.  *<p>  * Constraints :  *<p>  * Only one plan can be executing in a datanode at any given time. This is  * ensured by checking the future handle of the worker thread in submitPlan.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|DiskBalancer
specifier|public
class|class
name|DiskBalancer
block|{
annotation|@
name|VisibleForTesting
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DiskBalancer
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|dataset
specifier|private
specifier|final
name|FsDatasetSpi
argument_list|<
name|?
argument_list|>
name|dataset
decl_stmt|;
DECL|field|dataNodeUUID
specifier|private
specifier|final
name|String
name|dataNodeUUID
decl_stmt|;
DECL|field|blockMover
specifier|private
specifier|final
name|BlockMover
name|blockMover
decl_stmt|;
DECL|field|lock
specifier|private
specifier|final
name|ReentrantLock
name|lock
decl_stmt|;
DECL|field|workMap
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|VolumePair
argument_list|,
name|DiskBalancerWorkItem
argument_list|>
name|workMap
decl_stmt|;
DECL|field|isDiskBalancerEnabled
specifier|private
name|boolean
name|isDiskBalancerEnabled
init|=
literal|false
decl_stmt|;
DECL|field|scheduler
specifier|private
name|ExecutorService
name|scheduler
decl_stmt|;
DECL|field|future
specifier|private
name|Future
name|future
decl_stmt|;
DECL|field|planID
specifier|private
name|String
name|planID
decl_stmt|;
DECL|field|planFile
specifier|private
name|String
name|planFile
decl_stmt|;
DECL|field|currentResult
specifier|private
name|DiskBalancerWorkStatus
operator|.
name|Result
name|currentResult
decl_stmt|;
DECL|field|bandwidth
specifier|private
name|long
name|bandwidth
decl_stmt|;
DECL|field|planValidityInterval
specifier|private
name|long
name|planValidityInterval
decl_stmt|;
DECL|field|config
specifier|private
specifier|final
name|Configuration
name|config
decl_stmt|;
comment|/**    * Constructs a Disk Balancer object. This object takes care of reading a    * NodePlan and executing it against a set of volumes.    *    * @param dataNodeUUID - Data node UUID    * @param conf         - Hdfs Config    * @param blockMover   - Object that supports moving blocks.    */
DECL|method|DiskBalancer (String dataNodeUUID, Configuration conf, BlockMover blockMover)
specifier|public
name|DiskBalancer
parameter_list|(
name|String
name|dataNodeUUID
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|BlockMover
name|blockMover
parameter_list|)
block|{
name|this
operator|.
name|config
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|NO_PLAN
expr_stmt|;
name|this
operator|.
name|blockMover
operator|=
name|blockMover
expr_stmt|;
name|this
operator|.
name|dataset
operator|=
name|this
operator|.
name|blockMover
operator|.
name|getDataset
argument_list|()
expr_stmt|;
name|this
operator|.
name|dataNodeUUID
operator|=
name|dataNodeUUID
expr_stmt|;
name|scheduler
operator|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
expr_stmt|;
name|lock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|workMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|planID
operator|=
literal|""
expr_stmt|;
comment|// to keep protobuf happy.
name|this
operator|.
name|planFile
operator|=
literal|""
expr_stmt|;
comment|// to keep protobuf happy.
name|this
operator|.
name|isDiskBalancerEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_ENABLED
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|bandwidth
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_MAX_DISK_THROUGHPUT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_MAX_DISK_THROUGHPUT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|planValidityInterval
operator|=
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_PLAN_VALID_INTERVAL
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_PLAN_VALID_INTERVAL_DEFAULT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
comment|/**    * Shutdown  disk balancer services.    */
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|boolean
name|needShutdown
init|=
literal|false
decl_stmt|;
try|try
block|{
name|this
operator|.
name|isDiskBalancerEnabled
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|NO_PLAN
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|.
name|future
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|this
operator|.
name|future
operator|.
name|isDone
argument_list|()
operator|)
condition|)
block|{
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|PLAN_CANCELLED
expr_stmt|;
name|this
operator|.
name|blockMover
operator|.
name|setExitFlag
argument_list|()
expr_stmt|;
name|scheduler
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|needShutdown
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// no need to hold lock while shutting down executor.
if|if
condition|(
name|needShutdown
condition|)
block|{
name|shutdownExecutor
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Shutdown the executor.    */
DECL|method|shutdownExecutor ()
specifier|private
name|void
name|shutdownExecutor
parameter_list|()
block|{
specifier|final
name|int
name|secondsTowait
init|=
literal|10
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|scheduler
operator|.
name|awaitTermination
argument_list|(
name|secondsTowait
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|scheduler
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scheduler
operator|.
name|awaitTermination
argument_list|(
name|secondsTowait
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer : Scheduler did not terminate."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|scheduler
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Takes a client submitted plan and converts into a set of work items that    * can be executed by the blockMover.    *    * @param planId      - A SHA-1 of the plan string    * @param planVersion - version of the plan string - for future use.    * @param planFileName    - Plan file name    * @param planData    - Plan data in json format    * @param force       - Skip some validations and execute the plan file.    * @throws DiskBalancerException    */
DECL|method|submitPlan (String planId, long planVersion, String planFileName, String planData, boolean force)
specifier|public
name|void
name|submitPlan
parameter_list|(
name|String
name|planId
parameter_list|,
name|long
name|planVersion
parameter_list|,
name|String
name|planFileName
parameter_list|,
name|String
name|planData
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|.
name|future
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|this
operator|.
name|future
operator|.
name|isDone
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Executing another plan, submitPlan failed."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Executing another plan"
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|PLAN_ALREADY_IN_PROGRESS
argument_list|)
throw|;
block|}
name|NodePlan
name|nodePlan
init|=
name|verifyPlan
argument_list|(
name|planId
argument_list|,
name|planVersion
argument_list|,
name|planData
argument_list|,
name|force
argument_list|)
decl_stmt|;
name|createWorkPlan
argument_list|(
name|nodePlan
argument_list|)
expr_stmt|;
name|this
operator|.
name|planID
operator|=
name|planId
expr_stmt|;
name|this
operator|.
name|planFile
operator|=
name|planFileName
expr_stmt|;
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|PLAN_UNDER_PROGRESS
expr_stmt|;
name|executePlan
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get FsVolume by volume UUID.    * @param fsDataset    * @param volUuid    * @return FsVolumeSpi    */
DECL|method|getFsVolume (final FsDatasetSpi<?> fsDataset, final String volUuid)
specifier|private
specifier|static
name|FsVolumeSpi
name|getFsVolume
parameter_list|(
specifier|final
name|FsDatasetSpi
argument_list|<
name|?
argument_list|>
name|fsDataset
parameter_list|,
specifier|final
name|String
name|volUuid
parameter_list|)
block|{
name|FsVolumeSpi
name|fsVolume
init|=
literal|null
decl_stmt|;
try|try
init|(
name|FsVolumeReferences
name|volumeReferences
init|=
name|fsDataset
operator|.
name|getFsVolumeReferences
argument_list|()
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|volumeReferences
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|volumeReferences
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getStorageID
argument_list|()
operator|.
name|equals
argument_list|(
name|volUuid
argument_list|)
condition|)
block|{
name|fsVolume
operator|=
name|volumeReferences
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Disk Balancer - Error when closing volume references: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|fsVolume
return|;
block|}
comment|/**    * Returns the current work status of a previously submitted Plan.    *    * @return DiskBalancerWorkStatus.    * @throws DiskBalancerException    */
DECL|method|queryWorkStatus ()
specifier|public
name|DiskBalancerWorkStatus
name|queryWorkStatus
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
comment|// if we had a plan in progress, check if it is finished.
if|if
condition|(
name|this
operator|.
name|currentResult
operator|==
name|Result
operator|.
name|PLAN_UNDER_PROGRESS
operator|&&
name|this
operator|.
name|future
operator|!=
literal|null
operator|&&
name|this
operator|.
name|future
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|PLAN_DONE
expr_stmt|;
block|}
name|DiskBalancerWorkStatus
name|status
init|=
operator|new
name|DiskBalancerWorkStatus
argument_list|(
name|this
operator|.
name|currentResult
argument_list|,
name|this
operator|.
name|planID
argument_list|,
name|this
operator|.
name|planFile
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|VolumePair
argument_list|,
name|DiskBalancerWorkItem
argument_list|>
name|entry
range|:
name|workMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|DiskBalancerWorkEntry
name|workEntry
init|=
operator|new
name|DiskBalancerWorkEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getSourceVolBasePath
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getDestVolBasePath
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|status
operator|.
name|addWorkEntry
argument_list|(
name|workEntry
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Cancels a running plan.    *    * @param planID - Hash of the plan to cancel.    * @throws DiskBalancerException    */
DECL|method|cancelPlan (String planID)
specifier|public
name|void
name|cancelPlan
parameter_list|(
name|String
name|planID
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|boolean
name|needShutdown
init|=
literal|false
decl_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|planID
operator|==
literal|null
operator|||
operator|!
name|this
operator|.
name|planID
operator|.
name|equals
argument_list|(
name|planID
argument_list|)
operator|||
name|this
operator|.
name|planID
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - No such plan. Cancel plan failed. PlanID: "
operator|+
name|planID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"No such plan."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|NO_SUCH_PLAN
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|future
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|PLAN_CANCELLED
expr_stmt|;
name|this
operator|.
name|blockMover
operator|.
name|setExitFlag
argument_list|()
expr_stmt|;
name|scheduler
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|needShutdown
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// no need to hold lock while shutting down executor.
if|if
condition|(
name|needShutdown
condition|)
block|{
name|shutdownExecutor
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns a volume ID to Volume base path map.    *    * @return Json string of the volume map.    * @throws DiskBalancerException    */
DECL|method|getVolumeNames ()
specifier|public
name|String
name|getVolumeNames
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
return|return
name|JsonUtil
operator|.
name|toJsonString
argument_list|(
name|getStorageIDToVolumeBasePathMap
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DiskBalancerException
name|ex
parameter_list|)
block|{
throw|throw
name|ex
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Internal error, Unable to "
operator|+
literal|"create JSON string."
argument_list|,
name|e
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INTERNAL_ERROR
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the current bandwidth.    *    * @return string representation of bandwidth.    * @throws DiskBalancerException    */
DECL|method|getBandwidth ()
specifier|public
name|long
name|getBandwidth
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|bandwidth
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Throws if Disk balancer is disabled.    *    * @throws DiskBalancerException    */
DECL|method|checkDiskBalancerEnabled ()
specifier|private
name|void
name|checkDiskBalancerEnabled
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
if|if
condition|(
operator|!
name|isDiskBalancerEnabled
condition|)
block|{
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Disk Balancer is not enabled."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|DISK_BALANCER_NOT_ENABLED
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies that user provided plan is valid.    *    * @param planID      - SHA-1 of the plan.    * @param planVersion - Version of the plan, for future use.    * @param plan        - Plan String in Json.    * @param force       - Skip verifying when the plan was generated.    * @return a NodePlan Object.    * @throws DiskBalancerException    */
DECL|method|verifyPlan (String planID, long planVersion, String plan, boolean force)
specifier|private
name|NodePlan
name|verifyPlan
parameter_list|(
name|String
name|planID
parameter_list|,
name|long
name|planVersion
parameter_list|,
name|String
name|plan
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
name|verifyPlanVersion
argument_list|(
name|planVersion
argument_list|)
expr_stmt|;
name|NodePlan
name|nodePlan
init|=
name|verifyPlanHash
argument_list|(
name|planID
argument_list|,
name|plan
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|verifyTimeStamp
argument_list|(
name|nodePlan
argument_list|)
expr_stmt|;
block|}
name|verifyNodeUUID
argument_list|(
name|nodePlan
argument_list|)
expr_stmt|;
return|return
name|nodePlan
return|;
block|}
comment|/**    * Verifies the plan version is something that we support.    *    * @param planVersion - Long version.    * @throws DiskBalancerException    */
DECL|method|verifyPlanVersion (long planVersion)
specifier|private
name|void
name|verifyPlanVersion
parameter_list|(
name|long
name|planVersion
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
if|if
condition|(
operator|(
name|planVersion
operator|<
name|DiskBalancerConstants
operator|.
name|DISKBALANCER_MIN_VERSION
operator|)
operator|||
operator|(
name|planVersion
operator|>
name|DiskBalancerConstants
operator|.
name|DISKBALANCER_MAX_VERSION
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Invalid plan version."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Invalid plan version."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_PLAN_VERSION
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies that plan matches the SHA-1 provided by the client.    *    * @param planID - SHA-1 Hex Bytes    * @param plan   - Plan String    * @throws DiskBalancerException    */
DECL|method|verifyPlanHash (String planID, String plan)
specifier|private
name|NodePlan
name|verifyPlanHash
parameter_list|(
name|String
name|planID
parameter_list|,
name|String
name|plan
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
specifier|final
name|long
name|sha1Length
init|=
literal|40
decl_stmt|;
if|if
condition|(
name|plan
operator|==
literal|null
operator|||
name|plan
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer -  Invalid plan."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Invalid plan."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_PLAN
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|planID
operator|==
literal|null
operator|)
operator|||
operator|(
name|planID
operator|.
name|length
argument_list|()
operator|!=
name|sha1Length
operator|)
operator|||
operator|!
name|DigestUtils
operator|.
name|shaHex
argument_list|(
name|plan
operator|.
name|getBytes
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
name|planID
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Invalid plan hash."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Invalid or mis-matched hash."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_PLAN_HASH
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|NodePlan
operator|.
name|parseJson
argument_list|(
name|plan
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Parsing plan failed."
argument_list|,
name|ex
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|MALFORMED_PLAN
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies that this plan is not older than 24 hours.    *    * @param plan - Node Plan    */
DECL|method|verifyTimeStamp (NodePlan plan)
specifier|private
name|void
name|verifyTimeStamp
parameter_list|(
name|NodePlan
name|plan
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|long
name|planTime
init|=
name|plan
operator|.
name|getTimeStamp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|planTime
operator|+
name|planValidityInterval
operator|)
operator|<
name|now
condition|)
block|{
name|String
name|planValidity
init|=
name|config
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_PLAN_VALID_INTERVAL
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_PLAN_VALID_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|planValidity
operator|.
name|matches
argument_list|(
literal|"[0-9]$"
argument_list|)
condition|)
block|{
name|planValidity
operator|+=
literal|"ms"
expr_stmt|;
block|}
name|String
name|errorString
init|=
literal|"Plan was generated more than "
operator|+
name|planValidity
operator|+
literal|" ago"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - "
operator|+
name|errorString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
name|errorString
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|OLD_PLAN_SUBMITTED
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verify Node UUID.    *    * @param plan - Node Plan    */
DECL|method|verifyNodeUUID (NodePlan plan)
specifier|private
name|void
name|verifyNodeUUID
parameter_list|(
name|NodePlan
name|plan
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
if|if
condition|(
operator|(
name|plan
operator|.
name|getNodeUUID
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|!
name|plan
operator|.
name|getNodeUUID
argument_list|()
operator|.
name|equals
argument_list|(
name|this
operator|.
name|dataNodeUUID
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Plan was generated for another node."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Plan was generated for another node."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|DATANODE_ID_MISMATCH
argument_list|)
throw|;
block|}
block|}
comment|/**    * Convert a node plan to DiskBalancerWorkItem that Datanode can execute.    *    * @param plan - Node Plan    */
DECL|method|createWorkPlan (NodePlan plan)
specifier|private
name|void
name|createWorkPlan
parameter_list|(
name|NodePlan
name|plan
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|// Cleanup any residual work in the map.
name|workMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|storageIDToVolBasePathMap
init|=
name|getStorageIDToVolumeBasePathMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Step
name|step
range|:
name|plan
operator|.
name|getVolumeSetPlans
argument_list|()
control|)
block|{
name|String
name|sourceVolUuid
init|=
name|step
operator|.
name|getSourceVolume
argument_list|()
operator|.
name|getUuid
argument_list|()
decl_stmt|;
name|String
name|destVolUuid
init|=
name|step
operator|.
name|getDestinationVolume
argument_list|()
operator|.
name|getUuid
argument_list|()
decl_stmt|;
name|String
name|sourceVolBasePath
init|=
name|storageIDToVolBasePathMap
operator|.
name|get
argument_list|(
name|sourceVolUuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceVolBasePath
operator|==
literal|null
condition|)
block|{
specifier|final
name|String
name|errMsg
init|=
literal|"Disk Balancer - Unable to find volume: "
operator|+
name|step
operator|.
name|getSourceVolume
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|". SubmitPlan failed."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
name|errMsg
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_VOLUME
argument_list|)
throw|;
block|}
name|String
name|destVolBasePath
init|=
name|storageIDToVolBasePathMap
operator|.
name|get
argument_list|(
name|destVolUuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|destVolBasePath
operator|==
literal|null
condition|)
block|{
specifier|final
name|String
name|errMsg
init|=
literal|"Disk Balancer - Unable to find volume: "
operator|+
name|step
operator|.
name|getDestinationVolume
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|". SubmitPlan failed."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
name|errMsg
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_VOLUME
argument_list|)
throw|;
block|}
name|VolumePair
name|volumePair
init|=
operator|new
name|VolumePair
argument_list|(
name|sourceVolUuid
argument_list|,
name|sourceVolBasePath
argument_list|,
name|destVolUuid
argument_list|,
name|destVolBasePath
argument_list|)
decl_stmt|;
name|createWorkPlan
argument_list|(
name|volumePair
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns volume UUID to volume base path map.    *    * @return Map    * @throws DiskBalancerException    */
DECL|method|getStorageIDToVolumeBasePathMap ()
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getStorageIDToVolumeBasePathMap
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|storageIDToVolBasePathMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|FsDatasetSpi
operator|.
name|FsVolumeReferences
name|references
decl_stmt|;
try|try
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|this
operator|.
name|dataset
operator|.
name|acquireDatasetLock
argument_list|()
init|)
block|{
name|references
operator|=
name|this
operator|.
name|dataset
operator|.
name|getFsVolumeReferences
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|ndx
init|=
literal|0
init|;
name|ndx
operator|<
name|references
operator|.
name|size
argument_list|()
condition|;
name|ndx
operator|++
control|)
block|{
name|FsVolumeSpi
name|vol
init|=
name|references
operator|.
name|get
argument_list|(
name|ndx
argument_list|)
decl_stmt|;
name|storageIDToVolBasePathMap
operator|.
name|put
argument_list|(
name|vol
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|vol
operator|.
name|getBaseURI
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|references
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Internal Error."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Internal error"
argument_list|,
name|ex
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INTERNAL_ERROR
argument_list|)
throw|;
block|}
return|return
name|storageIDToVolBasePathMap
return|;
block|}
comment|/**    * Starts Executing the plan, exits when the plan is done executing.    */
DECL|method|executePlan ()
specifier|private
name|void
name|executePlan
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockMover
operator|.
name|setRunnable
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|scheduler
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|scheduler
operator|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|future
operator|=
name|scheduler
operator|.
name|submit
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"DiskBalancerThread"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Executing Disk balancer plan. Plan File: {}, Plan ID: {}"
argument_list|,
name|planFile
argument_list|,
name|planID
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|VolumePair
argument_list|,
name|DiskBalancerWorkItem
argument_list|>
name|entry
range|:
name|workMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|blockMover
operator|.
name|setRunnable
argument_list|()
expr_stmt|;
name|blockMover
operator|.
name|copyBlocks
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Insert work items to work map.    * @param volumePair - VolumePair    * @param step - Move Step    */
DECL|method|createWorkPlan (final VolumePair volumePair, Step step)
specifier|private
name|void
name|createWorkPlan
parameter_list|(
specifier|final
name|VolumePair
name|volumePair
parameter_list|,
name|Step
name|step
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
if|if
condition|(
name|volumePair
operator|.
name|getSourceVolUuid
argument_list|()
operator|.
name|equals
argument_list|(
name|volumePair
operator|.
name|getDestVolUuid
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|String
name|errMsg
init|=
literal|"Disk Balancer - Source and destination volumes "
operator|+
literal|"are same: "
operator|+
name|volumePair
operator|.
name|getSourceVolUuid
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
name|errMsg
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_MOVE
argument_list|)
throw|;
block|}
name|long
name|bytesToMove
init|=
name|step
operator|.
name|getBytesToMove
argument_list|()
decl_stmt|;
comment|// In case we have a plan with more than
comment|// one line of same VolumePair
comment|// we compress that into one work order.
if|if
condition|(
name|workMap
operator|.
name|containsKey
argument_list|(
name|volumePair
argument_list|)
condition|)
block|{
name|bytesToMove
operator|+=
name|workMap
operator|.
name|get
argument_list|(
name|volumePair
argument_list|)
operator|.
name|getBytesToCopy
argument_list|()
expr_stmt|;
block|}
name|DiskBalancerWorkItem
name|work
init|=
operator|new
name|DiskBalancerWorkItem
argument_list|(
name|bytesToMove
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// all these values can be zero, if so we will use
comment|// values from configuration.
name|work
operator|.
name|setBandwidth
argument_list|(
name|step
operator|.
name|getBandwidth
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|setTolerancePercent
argument_list|(
name|step
operator|.
name|getTolerancePercent
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|setMaxDiskErrors
argument_list|(
name|step
operator|.
name|getMaxDiskErrors
argument_list|()
argument_list|)
expr_stmt|;
name|workMap
operator|.
name|put
argument_list|(
name|volumePair
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
comment|/**    * BlockMover supports moving blocks across Volumes.    */
DECL|interface|BlockMover
specifier|public
interface|interface
name|BlockMover
block|{
comment|/**      * Copies blocks from a set of volumes.      *      * @param pair - Source and Destination Volumes.      * @param item - Number of bytes to move from volumes.      */
DECL|method|copyBlocks (VolumePair pair, DiskBalancerWorkItem item)
name|void
name|copyBlocks
parameter_list|(
name|VolumePair
name|pair
parameter_list|,
name|DiskBalancerWorkItem
name|item
parameter_list|)
function_decl|;
comment|/**      * Begin the actual copy operations. This is useful in testing.      */
DECL|method|setRunnable ()
name|void
name|setRunnable
parameter_list|()
function_decl|;
comment|/**      * Tells copyBlocks to exit from the copy routine.      */
DECL|method|setExitFlag ()
name|void
name|setExitFlag
parameter_list|()
function_decl|;
comment|/**      * Returns a pointer to the current dataset we are operating against.      *      * @return FsDatasetSpi      */
DECL|method|getDataset ()
name|FsDatasetSpi
name|getDataset
parameter_list|()
function_decl|;
comment|/**      * Returns time when this plan started executing.      *      * @return Start time in milliseconds.      */
DECL|method|getStartTime ()
name|long
name|getStartTime
parameter_list|()
function_decl|;
comment|/**      * Number of seconds elapsed.      *      * @return time in seconds      */
DECL|method|getElapsedSeconds ()
name|long
name|getElapsedSeconds
parameter_list|()
function_decl|;
block|}
comment|/**    * Holds source and dest volumes UUIDs and their BasePaths    * that disk balancer will be operating against.    */
DECL|class|VolumePair
specifier|public
specifier|static
class|class
name|VolumePair
block|{
DECL|field|sourceVolUuid
specifier|private
specifier|final
name|String
name|sourceVolUuid
decl_stmt|;
DECL|field|destVolUuid
specifier|private
specifier|final
name|String
name|destVolUuid
decl_stmt|;
DECL|field|sourceVolBasePath
specifier|private
specifier|final
name|String
name|sourceVolBasePath
decl_stmt|;
DECL|field|destVolBasePath
specifier|private
specifier|final
name|String
name|destVolBasePath
decl_stmt|;
comment|/**      * Constructs a volume pair.      * @param sourceVolUuid     - Source Volume      * @param sourceVolBasePath - Source Volume Base Path      * @param destVolUuid       - Destination Volume      * @param destVolBasePath   - Destination Volume Base Path      */
DECL|method|VolumePair (final String sourceVolUuid, final String sourceVolBasePath, final String destVolUuid, final String destVolBasePath)
specifier|public
name|VolumePair
parameter_list|(
specifier|final
name|String
name|sourceVolUuid
parameter_list|,
specifier|final
name|String
name|sourceVolBasePath
parameter_list|,
specifier|final
name|String
name|destVolUuid
parameter_list|,
specifier|final
name|String
name|destVolBasePath
parameter_list|)
block|{
name|this
operator|.
name|sourceVolUuid
operator|=
name|sourceVolUuid
expr_stmt|;
name|this
operator|.
name|sourceVolBasePath
operator|=
name|sourceVolBasePath
expr_stmt|;
name|this
operator|.
name|destVolUuid
operator|=
name|destVolUuid
expr_stmt|;
name|this
operator|.
name|destVolBasePath
operator|=
name|destVolBasePath
expr_stmt|;
block|}
comment|/**      * Gets source volume UUID.      *      * @return UUID String      */
DECL|method|getSourceVolUuid ()
specifier|public
name|String
name|getSourceVolUuid
parameter_list|()
block|{
return|return
name|sourceVolUuid
return|;
block|}
comment|/**      * Gets source volume base path.      * @return String      */
DECL|method|getSourceVolBasePath ()
specifier|public
name|String
name|getSourceVolBasePath
parameter_list|()
block|{
return|return
name|sourceVolBasePath
return|;
block|}
comment|/**      * Gets destination volume UUID.      *      * @return UUID String      */
DECL|method|getDestVolUuid ()
specifier|public
name|String
name|getDestVolUuid
parameter_list|()
block|{
return|return
name|destVolUuid
return|;
block|}
comment|/**      * Gets desitnation volume base path.      *      * @return String      */
DECL|method|getDestVolBasePath ()
specifier|public
name|String
name|getDestVolBasePath
parameter_list|()
block|{
return|return
name|destVolBasePath
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|VolumePair
name|that
init|=
operator|(
name|VolumePair
operator|)
name|o
decl_stmt|;
return|return
name|sourceVolUuid
operator|.
name|equals
argument_list|(
name|that
operator|.
name|sourceVolUuid
argument_list|)
operator|&&
name|sourceVolBasePath
operator|.
name|equals
argument_list|(
name|that
operator|.
name|sourceVolBasePath
argument_list|)
operator|&&
name|destVolUuid
operator|.
name|equals
argument_list|(
name|that
operator|.
name|destVolUuid
argument_list|)
operator|&&
name|destVolBasePath
operator|.
name|equals
argument_list|(
name|that
operator|.
name|destVolBasePath
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|primeNum
init|=
literal|31
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|volumeStrList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|sourceVolUuid
argument_list|,
name|sourceVolBasePath
argument_list|,
name|destVolUuid
argument_list|,
name|destVolBasePath
argument_list|)
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
for|for
control|(
name|String
name|str
range|:
name|volumeStrList
control|)
block|{
name|result
operator|=
operator|(
name|result
operator|*
name|primeNum
operator|)
operator|+
name|str
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**    * Actual DataMover class for DiskBalancer.    *<p>    */
DECL|class|DiskBalancerMover
specifier|public
specifier|static
class|class
name|DiskBalancerMover
implements|implements
name|BlockMover
block|{
DECL|field|dataset
specifier|private
specifier|final
name|FsDatasetSpi
name|dataset
decl_stmt|;
DECL|field|diskBandwidth
specifier|private
name|long
name|diskBandwidth
decl_stmt|;
DECL|field|blockTolerance
specifier|private
name|long
name|blockTolerance
decl_stmt|;
DECL|field|maxDiskErrors
specifier|private
name|long
name|maxDiskErrors
decl_stmt|;
DECL|field|poolIndex
specifier|private
name|int
name|poolIndex
decl_stmt|;
DECL|field|shouldRun
specifier|private
name|AtomicBoolean
name|shouldRun
decl_stmt|;
DECL|field|startTime
specifier|private
name|long
name|startTime
decl_stmt|;
DECL|field|secondsElapsed
specifier|private
name|long
name|secondsElapsed
decl_stmt|;
comment|/**      * Constructs diskBalancerMover.      *      * @param dataset Dataset      * @param conf    Configuration      */
DECL|method|DiskBalancerMover (FsDatasetSpi dataset, Configuration conf)
specifier|public
name|DiskBalancerMover
parameter_list|(
name|FsDatasetSpi
name|dataset
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|dataset
operator|=
name|dataset
expr_stmt|;
name|shouldRun
operator|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|diskBandwidth
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_MAX_DISK_THROUGHPUT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_MAX_DISK_THROUGHPUT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockTolerance
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_BLOCK_TOLERANCE
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_BLOCK_TOLERANCE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxDiskErrors
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_MAX_DISK_ERRORS
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_MAX_DISK_ERRORS_DEFAULT
argument_list|)
expr_stmt|;
comment|// Since these are user provided values make sure it is sane
comment|// or ignore faulty values.
if|if
condition|(
name|this
operator|.
name|diskBandwidth
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found 0 or less as max disk throughput, ignoring config "
operator|+
literal|"value. value : "
operator|+
name|diskBandwidth
argument_list|)
expr_stmt|;
name|diskBandwidth
operator|=
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_MAX_DISK_THROUGHPUT_DEFAULT
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|blockTolerance
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found 0 or less for block tolerance value, ignoring config"
operator|+
literal|"value. value : "
operator|+
name|blockTolerance
argument_list|)
expr_stmt|;
name|blockTolerance
operator|=
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_BLOCK_TOLERANCE_DEFAULT
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|maxDiskErrors
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found  less than 0 for maxDiskErrors value, ignoring "
operator|+
literal|"config value. value : "
operator|+
name|maxDiskErrors
argument_list|)
expr_stmt|;
name|maxDiskErrors
operator|=
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_MAX_DISK_ERRORS_DEFAULT
expr_stmt|;
block|}
block|}
comment|/**      * Sets Diskmover copyblocks into runnable state.      */
annotation|@
name|Override
DECL|method|setRunnable ()
specifier|public
name|void
name|setRunnable
parameter_list|()
block|{
name|this
operator|.
name|shouldRun
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Signals copy block to exit.      */
annotation|@
name|Override
DECL|method|setExitFlag ()
specifier|public
name|void
name|setExitFlag
parameter_list|()
block|{
name|this
operator|.
name|shouldRun
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the shouldRun boolean flag.      */
DECL|method|shouldRun ()
specifier|public
name|boolean
name|shouldRun
parameter_list|()
block|{
return|return
name|this
operator|.
name|shouldRun
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Checks if a given block is less than needed size to meet our goal.      *      * @param blockSize - block len      * @param item      - Work item      * @return true if this block meets our criteria, false otherwise.      */
DECL|method|isLessThanNeeded (long blockSize, DiskBalancerWorkItem item)
specifier|private
name|boolean
name|isLessThanNeeded
parameter_list|(
name|long
name|blockSize
parameter_list|,
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{
name|long
name|bytesToCopy
init|=
name|item
operator|.
name|getBytesToCopy
argument_list|()
operator|-
name|item
operator|.
name|getBytesCopied
argument_list|()
decl_stmt|;
name|bytesToCopy
operator|=
name|bytesToCopy
operator|+
operator|(
operator|(
name|bytesToCopy
operator|*
name|getBlockTolerancePercentage
argument_list|(
name|item
argument_list|)
operator|)
operator|/
literal|100
operator|)
expr_stmt|;
return|return
operator|(
name|blockSize
operator|<=
name|bytesToCopy
operator|)
condition|?
literal|true
else|:
literal|false
return|;
block|}
comment|/**      * Returns the default block tolerance if the plan does not have value of      * tolerance specified.      *      * @param item - DiskBalancerWorkItem      * @return long      */
DECL|method|getBlockTolerancePercentage (DiskBalancerWorkItem item)
specifier|private
name|long
name|getBlockTolerancePercentage
parameter_list|(
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{
return|return
name|item
operator|.
name|getTolerancePercent
argument_list|()
operator|<=
literal|0
condition|?
name|this
operator|.
name|blockTolerance
else|:
name|item
operator|.
name|getTolerancePercent
argument_list|()
return|;
block|}
comment|/**      * Inflates bytesCopied and returns true or false. This allows us to stop      * copying if we have reached close enough.      *      * @param item DiskBalancerWorkItem      * @return -- false if we need to copy more, true if we are done      */
DECL|method|isCloseEnough (DiskBalancerWorkItem item)
specifier|private
name|boolean
name|isCloseEnough
parameter_list|(
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{
name|long
name|temp
init|=
name|item
operator|.
name|getBytesCopied
argument_list|()
operator|+
operator|(
operator|(
name|item
operator|.
name|getBytesCopied
argument_list|()
operator|*
name|getBlockTolerancePercentage
argument_list|(
name|item
argument_list|)
operator|)
operator|/
literal|100
operator|)
decl_stmt|;
return|return
operator|(
name|item
operator|.
name|getBytesToCopy
argument_list|()
operator|>=
name|temp
operator|)
condition|?
literal|false
else|:
literal|true
return|;
block|}
comment|/**      * Returns disk bandwidth associated with this plan, if none is specified      * returns the global default.      *      * @param item DiskBalancerWorkItem.      * @return MB/s - long      */
DECL|method|getDiskBandwidth (DiskBalancerWorkItem item)
specifier|private
name|long
name|getDiskBandwidth
parameter_list|(
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{
return|return
name|item
operator|.
name|getBandwidth
argument_list|()
operator|<=
literal|0
condition|?
name|this
operator|.
name|diskBandwidth
else|:
name|item
operator|.
name|getBandwidth
argument_list|()
return|;
block|}
comment|/**      * Computes sleep delay needed based on the block that just got copied. we      * copy using a burst mode, that is we let the copy proceed in full      * throttle. Once a copy is done, we compute how many bytes have been      * transferred and try to average it over the user specified bandwidth. In      * other words, This code implements a poor man's token bucket algorithm for      * traffic shaping.      *      * @param bytesCopied - byteCopied.      * @param timeUsed    in milliseconds      * @param item        DiskBalancerWorkItem      * @return sleep delay in Milliseconds.      */
annotation|@
name|VisibleForTesting
DECL|method|computeDelay (long bytesCopied, long timeUsed, DiskBalancerWorkItem item)
specifier|public
name|long
name|computeDelay
parameter_list|(
name|long
name|bytesCopied
parameter_list|,
name|long
name|timeUsed
parameter_list|,
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{
comment|// we had an overflow, ignore this reading and continue.
if|if
condition|(
name|timeUsed
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|int
name|megaByte
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
if|if
condition|(
name|bytesCopied
operator|<
name|megaByte
condition|)
block|{
return|return
literal|0
return|;
block|}
name|long
name|bytesInMB
init|=
name|bytesCopied
operator|/
name|megaByte
decl_stmt|;
comment|// converting disk bandwidth in MB/millisec
name|float
name|bandwidth
init|=
name|getDiskBandwidth
argument_list|(
name|item
argument_list|)
operator|/
literal|1000f
decl_stmt|;
name|float
name|delay
init|=
operator|(
call|(
name|long
call|)
argument_list|(
name|bytesInMB
operator|/
name|bandwidth
argument_list|)
operator|-
name|timeUsed
operator|)
decl_stmt|;
return|return
operator|(
name|delay
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|long
operator|)
name|delay
return|;
block|}
comment|/**      * Returns maximum errors to tolerate for the specific plan or the default.      *      * @param item - DiskBalancerWorkItem      * @return maximum error counts to tolerate.      */
DECL|method|getMaxError (DiskBalancerWorkItem item)
specifier|private
name|long
name|getMaxError
parameter_list|(
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{
return|return
name|item
operator|.
name|getMaxDiskErrors
argument_list|()
operator|<=
literal|0
condition|?
name|this
operator|.
name|maxDiskErrors
else|:
name|item
operator|.
name|getMaxDiskErrors
argument_list|()
return|;
block|}
comment|/**      * Gets the next block that we can copy, returns null if we cannot find a      * block that fits our parameters or if have run out of blocks.      *      * @param iter Block Iter      * @param item - Work item      * @return Extended block or null if no copyable block is found.      */
DECL|method|getBlockToCopy (FsVolumeSpi.BlockIterator iter, DiskBalancerWorkItem item)
specifier|private
name|ExtendedBlock
name|getBlockToCopy
parameter_list|(
name|FsVolumeSpi
operator|.
name|BlockIterator
name|iter
parameter_list|,
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{
while|while
condition|(
operator|!
name|iter
operator|.
name|atEnd
argument_list|()
operator|&&
name|item
operator|.
name|getErrorCount
argument_list|()
operator|<
name|getMaxError
argument_list|(
name|item
argument_list|)
condition|)
block|{
try|try
block|{
name|ExtendedBlock
name|block
init|=
name|iter
operator|.
name|nextBlock
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|block
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NextBlock call returned null.No valid block to copy. {}"
argument_list|,
name|item
operator|.
name|toJson
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// A valid block is a finalized block, we iterate until we get
comment|// finalized blocks
if|if
condition|(
operator|!
name|this
operator|.
name|dataset
operator|.
name|isValidBlock
argument_list|(
name|block
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// We don't look for the best, we just do first fit
if|if
condition|(
name|isLessThanNeeded
argument_list|(
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|item
argument_list|)
condition|)
block|{
return|return
name|block
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|item
operator|.
name|incErrorCount
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|item
operator|.
name|getErrorCount
argument_list|()
operator|>=
name|getMaxError
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|item
operator|.
name|setErrMsg
argument_list|(
literal|"Error count exceeded."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Maximum error count exceeded. Error count: {} Max error:{} "
argument_list|,
name|item
operator|.
name|getErrorCount
argument_list|()
argument_list|,
name|item
operator|.
name|getMaxDiskErrors
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Opens all Block pools on a given volume.      *      * @param source    Source      * @param poolIters List of PoolIters to maintain.      */
DECL|method|openPoolIters (FsVolumeSpi source, List<FsVolumeSpi .BlockIterator> poolIters)
specifier|private
name|void
name|openPoolIters
parameter_list|(
name|FsVolumeSpi
name|source
parameter_list|,
name|List
argument_list|<
name|FsVolumeSpi
operator|.
name|BlockIterator
argument_list|>
name|poolIters
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|poolIters
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|blockPoolID
range|:
name|source
operator|.
name|getBlockPoolList
argument_list|()
control|)
block|{
name|poolIters
operator|.
name|add
argument_list|(
name|source
operator|.
name|newBlockIterator
argument_list|(
name|blockPoolID
argument_list|,
literal|"DiskBalancerSource"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the next block that we copy from all the block pools. This      * function looks across all block pools to find the next block to copy.      *      * @param poolIters - List of BlockIterators      * @return ExtendedBlock.      */
DECL|method|getNextBlock (List<FsVolumeSpi.BlockIterator> poolIters, DiskBalancerWorkItem item)
name|ExtendedBlock
name|getNextBlock
parameter_list|(
name|List
argument_list|<
name|FsVolumeSpi
operator|.
name|BlockIterator
argument_list|>
name|poolIters
parameter_list|,
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|poolIters
argument_list|)
expr_stmt|;
name|int
name|currentCount
init|=
literal|0
decl_stmt|;
name|ExtendedBlock
name|block
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|block
operator|==
literal|null
operator|&&
name|currentCount
operator|<
name|poolIters
operator|.
name|size
argument_list|()
condition|)
block|{
name|currentCount
operator|++
expr_stmt|;
name|int
name|index
init|=
name|poolIndex
operator|++
operator|%
name|poolIters
operator|.
name|size
argument_list|()
decl_stmt|;
name|FsVolumeSpi
operator|.
name|BlockIterator
name|currentPoolIter
init|=
name|poolIters
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|block
operator|=
name|getBlockToCopy
argument_list|(
name|currentPoolIter
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|item
operator|.
name|setErrMsg
argument_list|(
literal|"No source blocks found to move."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"No movable source blocks found. {}"
argument_list|,
name|item
operator|.
name|toJson
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to get json from Item."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|block
return|;
block|}
comment|/**      * Close all Pool Iters.      *      * @param poolIters List of BlockIters      */
DECL|method|closePoolIters (List<FsVolumeSpi.BlockIterator> poolIters)
specifier|private
name|void
name|closePoolIters
parameter_list|(
name|List
argument_list|<
name|FsVolumeSpi
operator|.
name|BlockIterator
argument_list|>
name|poolIters
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|poolIters
argument_list|)
expr_stmt|;
for|for
control|(
name|FsVolumeSpi
operator|.
name|BlockIterator
name|iter
range|:
name|poolIters
control|)
block|{
try|try
block|{
name|iter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error closing a block pool iter. ex: {}"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Copies blocks from a set of volumes.      *      * @param pair - Source and Destination Volumes.      * @param item - Number of bytes to move from volumes.      */
annotation|@
name|Override
DECL|method|copyBlocks (VolumePair pair, DiskBalancerWorkItem item)
specifier|public
name|void
name|copyBlocks
parameter_list|(
name|VolumePair
name|pair
parameter_list|,
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{
name|String
name|sourceVolUuid
init|=
name|pair
operator|.
name|getSourceVolUuid
argument_list|()
decl_stmt|;
name|String
name|destVolUuuid
init|=
name|pair
operator|.
name|getDestVolUuid
argument_list|()
decl_stmt|;
comment|// When any of the DiskBalancerWorkItem volumes are not
comment|// available, return after setting error in item.
name|FsVolumeSpi
name|source
init|=
name|getFsVolume
argument_list|(
name|this
operator|.
name|dataset
argument_list|,
name|sourceVolUuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
specifier|final
name|String
name|errMsg
init|=
literal|"Disk Balancer - Unable to find source volume: "
operator|+
name|pair
operator|.
name|getDestVolBasePath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
name|item
operator|.
name|setErrMsg
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
return|return;
block|}
name|FsVolumeSpi
name|dest
init|=
name|getFsVolume
argument_list|(
name|this
operator|.
name|dataset
argument_list|,
name|destVolUuuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
specifier|final
name|String
name|errMsg
init|=
literal|"Disk Balancer - Unable to find dest volume: "
operator|+
name|pair
operator|.
name|getDestVolBasePath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
name|item
operator|.
name|setErrMsg
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|source
operator|.
name|isTransientStorage
argument_list|()
operator|||
name|dest
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
specifier|final
name|String
name|errMsg
init|=
literal|"Disk Balancer - Unable to support "
operator|+
literal|"transient storage type."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
name|item
operator|.
name|setErrMsg
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
return|return;
block|}
name|List
argument_list|<
name|FsVolumeSpi
operator|.
name|BlockIterator
argument_list|>
name|poolIters
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|startTime
operator|=
name|Time
operator|.
name|now
argument_list|()
expr_stmt|;
name|item
operator|.
name|setStartTime
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
name|secondsElapsed
operator|=
literal|0
expr_stmt|;
try|try
block|{
name|openPoolIters
argument_list|(
name|source
argument_list|,
name|poolIters
argument_list|)
expr_stmt|;
if|if
condition|(
name|poolIters
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No block pools found on volume. volume : {}. Exiting."
argument_list|,
name|source
operator|.
name|getBaseURI
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|shouldRun
argument_list|()
condition|)
block|{
try|try
block|{
comment|// Check for the max error count constraint.
if|if
condition|(
name|item
operator|.
name|getErrorCount
argument_list|()
operator|>
name|getMaxError
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exceeded the max error count. source {}, dest: {} "
operator|+
literal|"error count: {}"
argument_list|,
name|source
operator|.
name|getBaseURI
argument_list|()
argument_list|,
name|dest
operator|.
name|getBaseURI
argument_list|()
argument_list|,
name|item
operator|.
name|getErrorCount
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Check for the block tolerance constraint.
if|if
condition|(
name|isCloseEnough
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Copy from {} to {} done. copied {} bytes and {} "
operator|+
literal|"blocks."
argument_list|,
name|source
operator|.
name|getBaseURI
argument_list|()
argument_list|,
name|dest
operator|.
name|getBaseURI
argument_list|()
argument_list|,
name|item
operator|.
name|getBytesCopied
argument_list|()
argument_list|,
name|item
operator|.
name|getBlocksCopied
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|setExitFlag
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|ExtendedBlock
name|block
init|=
name|getNextBlock
argument_list|(
name|poolIters
argument_list|,
name|item
argument_list|)
decl_stmt|;
comment|// we are not able to find any blocks to copy.
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No source blocks, exiting the copy. Source: {}, "
operator|+
literal|"Dest:{}"
argument_list|,
name|source
operator|.
name|getBaseURI
argument_list|()
argument_list|,
name|dest
operator|.
name|getBaseURI
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|setExitFlag
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// check if someone told us exit, treat this as an interruption
comment|// point
comment|// for the thread, since both getNextBlock and moveBlocAcrossVolume
comment|// can take some time.
if|if
condition|(
operator|!
name|shouldRun
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|long
name|timeUsed
decl_stmt|;
comment|// There is a race condition here, but we will get an IOException
comment|// if dest has no space, which we handle anyway.
if|if
condition|(
name|dest
operator|.
name|getAvailable
argument_list|()
operator|>
name|item
operator|.
name|getBytesToCopy
argument_list|()
condition|)
block|{
name|long
name|begin
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|this
operator|.
name|dataset
operator|.
name|moveBlockAcrossVolumes
argument_list|(
name|block
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|timeUsed
operator|=
operator|(
name|now
operator|-
name|begin
operator|)
operator|>
literal|0
condition|?
name|now
operator|-
name|begin
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Technically it is possible for us to find a smaller block and
comment|// make another copy, but opting for the safer choice of just
comment|// exiting here.
name|LOG
operator|.
name|error
argument_list|(
literal|"Destination volume: {} does not have enough space to"
operator|+
literal|" accommodate a block. Block Size: {} Exiting from"
operator|+
literal|" copyBlocks."
argument_list|,
name|dest
operator|.
name|getBaseURI
argument_list|()
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Moved block with size {} from  {} to {}"
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|source
operator|.
name|getBaseURI
argument_list|()
argument_list|,
name|dest
operator|.
name|getBaseURI
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check for the max throughput constraint.
comment|// We sleep here to keep the promise that we will not
comment|// copy more than Max MB/sec. we sleep enough time
comment|// to make sure that our promise is good on average.
comment|// Because we sleep, if a shutdown or cancel call comes in
comment|// we exit via Thread Interrupted exception.
name|Thread
operator|.
name|sleep
argument_list|(
name|computeDelay
argument_list|(
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|timeUsed
argument_list|)
argument_list|,
name|item
argument_list|)
argument_list|)
expr_stmt|;
comment|// We delay updating the info to avoid confusing the user.
comment|// This way we report the copy only if it is under the
comment|// throughput threshold.
name|item
operator|.
name|incCopiedSoFar
argument_list|(
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|item
operator|.
name|incBlocksCopied
argument_list|()
expr_stmt|;
name|secondsElapsed
operator|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|toSeconds
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
name|item
operator|.
name|setSecondsElapsed
argument_list|(
name|secondsElapsed
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while trying to copy blocks. error: {}"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|item
operator|.
name|incErrorCount
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Copy Block Thread interrupted, exiting the copy."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|item
operator|.
name|incErrorCount
argument_list|()
expr_stmt|;
name|this
operator|.
name|setExitFlag
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|ex
parameter_list|)
block|{
comment|// Exiting if any run time exceptions.
name|LOG
operator|.
name|error
argument_list|(
literal|"Got an unexpected Runtime Exception {}"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|item
operator|.
name|incErrorCount
argument_list|()
expr_stmt|;
name|this
operator|.
name|setExitFlag
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|// Close all Iters.
name|closePoolIters
argument_list|(
name|poolIters
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns a pointer to the current dataset we are operating against.      *      * @return FsDatasetSpi      */
annotation|@
name|Override
DECL|method|getDataset ()
specifier|public
name|FsDatasetSpi
name|getDataset
parameter_list|()
block|{
return|return
name|dataset
return|;
block|}
comment|/**      * Returns time when this plan started executing.      *      * @return Start time in milliseconds.      */
annotation|@
name|Override
DECL|method|getStartTime ()
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
comment|/**      * Number of seconds elapsed.      *      * @return time in seconds      */
annotation|@
name|Override
DECL|method|getElapsedSeconds ()
specifier|public
name|long
name|getElapsedSeconds
parameter_list|()
block|{
return|return
name|secondsElapsed
return|;
block|}
block|}
block|}
end_class

end_unit

