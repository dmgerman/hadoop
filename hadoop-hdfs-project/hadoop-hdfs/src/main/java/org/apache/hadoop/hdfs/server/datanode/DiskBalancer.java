begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  *  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|codec
operator|.
name|digest
operator|.
name|DigestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DiskBalancerWorkStatus
operator|.
name|DiskBalancerWorkEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DiskBalancerWorkStatus
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsDatasetSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|diskbalancer
operator|.
name|DiskBalancerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|diskbalancer
operator|.
name|DiskBalancerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|diskbalancer
operator|.
name|planner
operator|.
name|NodePlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|diskbalancer
operator|.
name|planner
operator|.
name|Step
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * Worker class for Disk Balancer.  *<p/>  * Here is the high level logic executed by this class. Users can submit disk  * balancing plans using submitPlan calls. After a set of sanity checks the plan  * is admitted and put into workMap.  *<p/>  * The executePlan launches a thread that picks up work from workMap and hands  * it over to the BlockMover#copyBlocks function.  *<p/>  * Constraints :  *<p/>  * Only one plan can be executing in a datanode at any given time. This is  * ensured by checking the future handle of the worker thread in submitPlan.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|DiskBalancer
specifier|public
class|class
name|DiskBalancer
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DiskBalancer
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|dataset
specifier|private
specifier|final
name|FsDatasetSpi
argument_list|<
name|?
argument_list|>
name|dataset
decl_stmt|;
DECL|field|dataNodeUUID
specifier|private
specifier|final
name|String
name|dataNodeUUID
decl_stmt|;
DECL|field|blockMover
specifier|private
specifier|final
name|BlockMover
name|blockMover
decl_stmt|;
DECL|field|lock
specifier|private
specifier|final
name|ReentrantLock
name|lock
decl_stmt|;
DECL|field|workMap
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|VolumePair
argument_list|,
name|DiskBalancerWorkItem
argument_list|>
name|workMap
decl_stmt|;
DECL|field|isDiskBalancerEnabled
specifier|private
name|boolean
name|isDiskBalancerEnabled
init|=
literal|false
decl_stmt|;
DECL|field|scheduler
specifier|private
name|ExecutorService
name|scheduler
decl_stmt|;
DECL|field|future
specifier|private
name|Future
name|future
decl_stmt|;
DECL|field|planID
specifier|private
name|String
name|planID
decl_stmt|;
DECL|field|currentResult
specifier|private
name|DiskBalancerWorkStatus
operator|.
name|Result
name|currentResult
decl_stmt|;
DECL|field|bandwidth
specifier|private
name|long
name|bandwidth
decl_stmt|;
comment|/**    * Constructs a Disk Balancer object. This object takes care of reading a    * NodePlan and executing it against a set of volumes.    *    * @param dataNodeUUID - Data node UUID    * @param conf         - Hdfs Config    * @param blockMover   - Object that supports moving blocks.    */
DECL|method|DiskBalancer (String dataNodeUUID, Configuration conf, BlockMover blockMover)
specifier|public
name|DiskBalancer
parameter_list|(
name|String
name|dataNodeUUID
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|BlockMover
name|blockMover
parameter_list|)
block|{
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|NO_PLAN
expr_stmt|;
name|this
operator|.
name|blockMover
operator|=
name|blockMover
expr_stmt|;
name|this
operator|.
name|dataset
operator|=
name|this
operator|.
name|blockMover
operator|.
name|getDataset
argument_list|()
expr_stmt|;
name|this
operator|.
name|dataNodeUUID
operator|=
name|dataNodeUUID
expr_stmt|;
name|scheduler
operator|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
expr_stmt|;
name|lock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|workMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|isDiskBalancerEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_ENABLED
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DISK_BALANCER_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Shutdown  disk balancer services.    */
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|isDiskBalancerEnabled
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|NO_PLAN
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|.
name|future
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|this
operator|.
name|future
operator|.
name|isDone
argument_list|()
operator|)
condition|)
block|{
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|PLAN_CANCELLED
expr_stmt|;
name|this
operator|.
name|blockMover
operator|.
name|setExitFlag
argument_list|()
expr_stmt|;
name|shutdownExecutor
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Shutdown the executor.    */
DECL|method|shutdownExecutor ()
specifier|private
name|void
name|shutdownExecutor
parameter_list|()
block|{
name|scheduler
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|scheduler
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|scheduler
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scheduler
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer : Scheduler did not terminate."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|scheduler
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Takes a client submitted plan and converts into a set of work items that    * can be executed by the blockMover.    *    * @param planID      - A SHA512 of the plan string    * @param planVersion - version of the plan string - for future use.    * @param plan        - Actual Plan    * @param bandwidth   - BytesPerSec to copy    * @param force       - Skip some validations and execute the plan file.    * @throws DiskBalancerException    */
DECL|method|submitPlan (String planID, long planVersion, String plan, long bandwidth, boolean force)
specifier|public
name|void
name|submitPlan
parameter_list|(
name|String
name|planID
parameter_list|,
name|long
name|planVersion
parameter_list|,
name|String
name|plan
parameter_list|,
name|long
name|bandwidth
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|.
name|future
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|this
operator|.
name|future
operator|.
name|isDone
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Executing another plan, submitPlan failed."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Executing another plan"
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|PLAN_ALREADY_IN_PROGRESS
argument_list|)
throw|;
block|}
name|NodePlan
name|nodePlan
init|=
name|verifyPlan
argument_list|(
name|planID
argument_list|,
name|planVersion
argument_list|,
name|plan
argument_list|,
name|bandwidth
argument_list|,
name|force
argument_list|)
decl_stmt|;
name|createWorkPlan
argument_list|(
name|nodePlan
argument_list|)
expr_stmt|;
name|this
operator|.
name|planID
operator|=
name|planID
expr_stmt|;
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|PLAN_UNDER_PROGRESS
expr_stmt|;
name|this
operator|.
name|bandwidth
operator|=
name|bandwidth
expr_stmt|;
name|executePlan
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the Current Work Status of a submitted Plan.    *    * @return DiskBalancerWorkStatus.    * @throws DiskBalancerException    */
DECL|method|queryWorkStatus ()
specifier|public
name|DiskBalancerWorkStatus
name|queryWorkStatus
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
comment|// if we had a plan in progress, check if it is finished.
if|if
condition|(
name|this
operator|.
name|currentResult
operator|==
name|Result
operator|.
name|PLAN_UNDER_PROGRESS
operator|&&
name|this
operator|.
name|future
operator|!=
literal|null
operator|&&
name|this
operator|.
name|future
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|PLAN_DONE
expr_stmt|;
block|}
name|DiskBalancerWorkStatus
name|status
init|=
operator|new
name|DiskBalancerWorkStatus
argument_list|(
name|this
operator|.
name|currentResult
argument_list|,
name|this
operator|.
name|planID
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|VolumePair
argument_list|,
name|DiskBalancerWorkItem
argument_list|>
name|entry
range|:
name|workMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|DiskBalancerWorkEntry
name|workEntry
init|=
operator|new
name|DiskBalancerWorkEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getSource
argument_list|()
operator|.
name|getBasePath
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getDest
argument_list|()
operator|.
name|getBasePath
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|status
operator|.
name|addWorkEntry
argument_list|(
name|workEntry
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Cancels a running plan.    * @param planID - Hash of the plan to cancel.    * @throws DiskBalancerException    */
DECL|method|cancelPlan (String planID)
specifier|public
name|void
name|cancelPlan
parameter_list|(
name|String
name|planID
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|.
name|planID
operator|==
literal|null
operator|)
operator|||
operator|(
operator|!
name|this
operator|.
name|planID
operator|.
name|equals
argument_list|(
name|planID
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - No such plan. Cancel plan failed. PlanID: "
operator|+
name|planID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"No such plan."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|NO_SUCH_PLAN
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|future
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|this
operator|.
name|blockMover
operator|.
name|setExitFlag
argument_list|()
expr_stmt|;
name|shutdownExecutor
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentResult
operator|=
name|Result
operator|.
name|PLAN_CANCELLED
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns a volume ID to Volume base path map.    *    * @return Json string of the volume map.    * @throws DiskBalancerException    */
DECL|method|getVolumeNames ()
specifier|public
name|String
name|getVolumeNames
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|pathMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|FsVolumeSpi
argument_list|>
name|volMap
init|=
name|getStorageIDToVolumeMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|FsVolumeSpi
argument_list|>
name|entry
range|:
name|volMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|pathMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getBasePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
return|return
name|mapper
operator|.
name|writeValueAsString
argument_list|(
name|pathMap
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Internal error, Unable to "
operator|+
literal|"create JSON string."
argument_list|,
name|e
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INTERNAL_ERROR
argument_list|)
throw|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the current bandwidth.    *    * @return string representation of bandwidth.    * @throws DiskBalancerException    */
DECL|method|getBandwidth ()
specifier|public
name|long
name|getBandwidth
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkDiskBalancerEnabled
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|bandwidth
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Throws if Disk balancer is disabled.    *    * @throws DiskBalancerException    */
DECL|method|checkDiskBalancerEnabled ()
specifier|private
name|void
name|checkDiskBalancerEnabled
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
if|if
condition|(
operator|!
name|isDiskBalancerEnabled
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer is not enabled."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Disk Balancer is not enabled."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|DISK_BALANCER_NOT_ENABLED
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies that user provided plan is valid.    *    * @param planID      - SHA 512 of the plan.    * @param planVersion - Version of the plan, for future use.    * @param plan        - Plan String in Json.    * @param bandwidth   - Max disk bandwidth to use per second.    * @param force       - Skip verifying when the plan was generated.    * @return a NodePlan Object.    * @throws DiskBalancerException    */
DECL|method|verifyPlan (String planID, long planVersion, String plan, long bandwidth, boolean force)
specifier|private
name|NodePlan
name|verifyPlan
parameter_list|(
name|String
name|planID
parameter_list|,
name|long
name|planVersion
parameter_list|,
name|String
name|plan
parameter_list|,
name|long
name|bandwidth
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
name|verifyPlanVersion
argument_list|(
name|planVersion
argument_list|)
expr_stmt|;
name|NodePlan
name|nodePlan
init|=
name|verifyPlanHash
argument_list|(
name|planID
argument_list|,
name|plan
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|verifyTimeStamp
argument_list|(
name|nodePlan
argument_list|)
expr_stmt|;
block|}
name|verifyNodeUUID
argument_list|(
name|nodePlan
argument_list|)
expr_stmt|;
return|return
name|nodePlan
return|;
block|}
comment|/**    * Verifies the plan version is something that we support.    *    * @param planVersion - Long version.    * @throws DiskBalancerException    */
DECL|method|verifyPlanVersion (long planVersion)
specifier|private
name|void
name|verifyPlanVersion
parameter_list|(
name|long
name|planVersion
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
if|if
condition|(
operator|(
name|planVersion
operator|<
name|DiskBalancerConstants
operator|.
name|DISKBALANCER_MIN_VERSION
operator|)
operator|||
operator|(
name|planVersion
operator|>
name|DiskBalancerConstants
operator|.
name|DISKBALANCER_MAX_VERSION
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Invalid plan version."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Invalid plan version."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_PLAN_VERSION
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies that plan matches the SHA512 provided by the client.    *    * @param planID - Sha512 Hex Bytes    * @param plan   - Plan String    * @throws DiskBalancerException    */
DECL|method|verifyPlanHash (String planID, String plan)
specifier|private
name|NodePlan
name|verifyPlanHash
parameter_list|(
name|String
name|planID
parameter_list|,
name|String
name|plan
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
specifier|final
name|long
name|sha512Length
init|=
literal|128
decl_stmt|;
if|if
condition|(
name|plan
operator|==
literal|null
operator|||
name|plan
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer -  Invalid plan."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Invalid plan."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_PLAN
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|planID
operator|==
literal|null
operator|)
operator|||
operator|(
name|planID
operator|.
name|length
argument_list|()
operator|!=
name|sha512Length
operator|)
operator|||
operator|!
name|DigestUtils
operator|.
name|sha512Hex
argument_list|(
name|plan
operator|.
name|getBytes
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
name|planID
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Invalid plan hash."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Invalid or mis-matched hash."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_PLAN_HASH
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|NodePlan
operator|.
name|parseJson
argument_list|(
name|plan
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Parsing plan failed."
argument_list|,
name|ex
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|MALFORMED_PLAN
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verifies that this plan is not older than 24 hours.    *    * @param plan - Node Plan    */
DECL|method|verifyTimeStamp (NodePlan plan)
specifier|private
name|void
name|verifyTimeStamp
parameter_list|(
name|NodePlan
name|plan
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|long
name|planTime
init|=
name|plan
operator|.
name|getTimeStamp
argument_list|()
decl_stmt|;
comment|// TODO : Support Valid Plan hours as a user configurable option.
if|if
condition|(
operator|(
name|planTime
operator|+
operator|(
name|TimeUnit
operator|.
name|HOURS
operator|.
name|toMillis
argument_list|(
name|DiskBalancerConstants
operator|.
name|DISKBALANCER_VALID_PLAN_HOURS
argument_list|)
operator|)
operator|)
operator|<
name|now
condition|)
block|{
name|String
name|hourString
init|=
literal|"Plan was generated more than "
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|DiskBalancerConstants
operator|.
name|DISKBALANCER_VALID_PLAN_HOURS
argument_list|)
operator|+
literal|" hours ago."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - "
operator|+
name|hourString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
name|hourString
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|OLD_PLAN_SUBMITTED
argument_list|)
throw|;
block|}
block|}
comment|/**    * Verify Node UUID.    *    * @param plan - Node Plan    */
DECL|method|verifyNodeUUID (NodePlan plan)
specifier|private
name|void
name|verifyNodeUUID
parameter_list|(
name|NodePlan
name|plan
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
if|if
condition|(
operator|(
name|plan
operator|.
name|getNodeUUID
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|!
name|plan
operator|.
name|getNodeUUID
argument_list|()
operator|.
name|equals
argument_list|(
name|this
operator|.
name|dataNodeUUID
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Plan was generated for another node."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Plan was generated for another node."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|DATANODE_ID_MISMATCH
argument_list|)
throw|;
block|}
block|}
comment|/**    * Convert a node plan to DiskBalancerWorkItem that Datanode can execute.    *    * @param plan - Node Plan    */
DECL|method|createWorkPlan (NodePlan plan)
specifier|private
name|void
name|createWorkPlan
parameter_list|(
name|NodePlan
name|plan
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|// Cleanup any residual work in the map.
name|workMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|FsVolumeSpi
argument_list|>
name|pathMap
init|=
name|getStorageIDToVolumeMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Step
name|step
range|:
name|plan
operator|.
name|getVolumeSetPlans
argument_list|()
control|)
block|{
name|String
name|sourceuuid
init|=
name|step
operator|.
name|getSourceVolume
argument_list|()
operator|.
name|getUuid
argument_list|()
decl_stmt|;
name|String
name|destinationuuid
init|=
name|step
operator|.
name|getDestinationVolume
argument_list|()
operator|.
name|getUuid
argument_list|()
decl_stmt|;
name|FsVolumeSpi
name|sourceVol
init|=
name|pathMap
operator|.
name|get
argument_list|(
name|sourceuuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceVol
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Unable to find source volume. submitPlan "
operator|+
literal|"failed."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Unable to find source volume."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_VOLUME
argument_list|)
throw|;
block|}
name|FsVolumeSpi
name|destVol
init|=
name|pathMap
operator|.
name|get
argument_list|(
name|destinationuuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|destVol
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Unable to find destination volume. "
operator|+
literal|"submitPlan failed."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Unable to find destination volume."
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_VOLUME
argument_list|)
throw|;
block|}
name|createWorkPlan
argument_list|(
name|sourceVol
argument_list|,
name|destVol
argument_list|,
name|step
operator|.
name|getBytesToMove
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a path to Volume Map.    *    * @return Map    * @throws DiskBalancerException    */
DECL|method|getStorageIDToVolumeMap ()
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|FsVolumeSpi
argument_list|>
name|getStorageIDToVolumeMap
parameter_list|()
throws|throws
name|DiskBalancerException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|FsVolumeSpi
argument_list|>
name|pathMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|FsDatasetSpi
operator|.
name|FsVolumeReferences
name|references
decl_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|dataset
init|)
block|{
name|references
operator|=
name|this
operator|.
name|dataset
operator|.
name|getFsVolumeReferences
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|ndx
init|=
literal|0
init|;
name|ndx
operator|<
name|references
operator|.
name|size
argument_list|()
condition|;
name|ndx
operator|++
control|)
block|{
name|FsVolumeSpi
name|vol
init|=
name|references
operator|.
name|get
argument_list|(
name|ndx
argument_list|)
decl_stmt|;
name|pathMap
operator|.
name|put
argument_list|(
name|vol
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|vol
argument_list|)
expr_stmt|;
block|}
name|references
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disk Balancer - Internal Error."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Internal error"
argument_list|,
name|ex
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INTERNAL_ERROR
argument_list|)
throw|;
block|}
return|return
name|pathMap
return|;
block|}
comment|/**    * Starts Executing the plan, exits when the plan is done executing.    */
DECL|method|executePlan ()
specifier|private
name|void
name|executePlan
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|lock
operator|.
name|isHeldByCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockMover
operator|.
name|setRunnable
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|scheduler
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|scheduler
operator|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|future
operator|=
name|scheduler
operator|.
name|submit
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"DiskBalancerThread"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Executing Disk balancer plan. Plan ID -  "
operator|+
name|planID
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|VolumePair
argument_list|,
name|DiskBalancerWorkItem
argument_list|>
name|entry
range|:
name|workMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|blockMover
operator|.
name|copyBlocks
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Insert work items to work map.    *    * @param source      - Source vol    * @param dest        - destination volume    * @param bytesToMove - number of bytes to move    */
DECL|method|createWorkPlan (FsVolumeSpi source, FsVolumeSpi dest, long bytesToMove)
specifier|private
name|void
name|createWorkPlan
parameter_list|(
name|FsVolumeSpi
name|source
parameter_list|,
name|FsVolumeSpi
name|dest
parameter_list|,
name|long
name|bytesToMove
parameter_list|)
throws|throws
name|DiskBalancerException
block|{
if|if
condition|(
name|source
operator|.
name|getStorageID
argument_list|()
operator|.
name|equals
argument_list|(
name|dest
operator|.
name|getStorageID
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DiskBalancerException
argument_list|(
literal|"Same source and destination"
argument_list|,
name|DiskBalancerException
operator|.
name|Result
operator|.
name|INVALID_MOVE
argument_list|)
throw|;
block|}
name|VolumePair
name|pair
init|=
operator|new
name|VolumePair
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
decl_stmt|;
comment|// In case we have a plan with more than
comment|// one line of same<source, dest>
comment|// we compress that into one work order.
if|if
condition|(
name|workMap
operator|.
name|containsKey
argument_list|(
name|pair
argument_list|)
condition|)
block|{
name|bytesToMove
operator|+=
name|workMap
operator|.
name|get
argument_list|(
name|pair
argument_list|)
operator|.
name|getBytesToCopy
argument_list|()
expr_stmt|;
block|}
name|DiskBalancerWorkItem
name|work
init|=
operator|new
name|DiskBalancerWorkItem
argument_list|(
name|bytesToMove
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|workMap
operator|.
name|put
argument_list|(
name|pair
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
comment|/**    * BlockMover supports moving blocks across Volumes.    */
DECL|interface|BlockMover
specifier|public
interface|interface
name|BlockMover
block|{
comment|/**      * Copies blocks from a set of volumes.      *      * @param pair - Source and Destination Volumes.      * @param item - Number of bytes to move from volumes.      */
DECL|method|copyBlocks (VolumePair pair, DiskBalancerWorkItem item)
name|void
name|copyBlocks
parameter_list|(
name|VolumePair
name|pair
parameter_list|,
name|DiskBalancerWorkItem
name|item
parameter_list|)
function_decl|;
comment|/**      * Begin the actual copy operations. This is useful in testing.      */
DECL|method|setRunnable ()
name|void
name|setRunnable
parameter_list|()
function_decl|;
comment|/**      * Tells copyBlocks to exit from the copy routine.      */
DECL|method|setExitFlag ()
name|void
name|setExitFlag
parameter_list|()
function_decl|;
comment|/**      * Returns a pointer to the current dataset we are operating against.      *      * @return FsDatasetSpi      */
DECL|method|getDataset ()
name|FsDatasetSpi
name|getDataset
parameter_list|()
function_decl|;
block|}
comment|/**    * Holds references to actual volumes that we will be operating against.    */
DECL|class|VolumePair
specifier|public
specifier|static
class|class
name|VolumePair
block|{
DECL|field|source
specifier|private
specifier|final
name|FsVolumeSpi
name|source
decl_stmt|;
DECL|field|dest
specifier|private
specifier|final
name|FsVolumeSpi
name|dest
decl_stmt|;
comment|/**      * Constructs a volume pair.      *      * @param source - Source Volume      * @param dest   - Destination Volume      */
DECL|method|VolumePair (FsVolumeSpi source, FsVolumeSpi dest)
specifier|public
name|VolumePair
parameter_list|(
name|FsVolumeSpi
name|source
parameter_list|,
name|FsVolumeSpi
name|dest
parameter_list|)
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|this
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
block|}
comment|/**      * gets source volume.      *      * @return volume      */
DECL|method|getSource ()
specifier|public
name|FsVolumeSpi
name|getSource
parameter_list|()
block|{
return|return
name|source
return|;
block|}
comment|/**      * Gets Destination volume.      *      * @return volume.      */
DECL|method|getDest ()
specifier|public
name|FsVolumeSpi
name|getDest
parameter_list|()
block|{
return|return
name|dest
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|VolumePair
name|that
init|=
operator|(
name|VolumePair
operator|)
name|o
decl_stmt|;
return|return
name|source
operator|.
name|equals
argument_list|(
name|that
operator|.
name|source
argument_list|)
operator|&&
name|dest
operator|.
name|equals
argument_list|(
name|that
operator|.
name|dest
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|source
operator|.
name|getBasePath
argument_list|()
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|dest
operator|.
name|getBasePath
argument_list|()
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/**    * Actual DataMover class for DiskBalancer.    *<p/>    * TODO : Add implementation for this class. This is here as a place holder so    * that Datanode can make calls into this class.    */
DECL|class|DiskBalancerMover
specifier|public
specifier|static
class|class
name|DiskBalancerMover
implements|implements
name|BlockMover
block|{
DECL|field|dataset
specifier|private
specifier|final
name|FsDatasetSpi
name|dataset
decl_stmt|;
comment|/**      * Constructs diskBalancerMover.      *      * @param dataset Dataset      * @param conf    Configuration      */
DECL|method|DiskBalancerMover (FsDatasetSpi dataset, Configuration conf)
specifier|public
name|DiskBalancerMover
parameter_list|(
name|FsDatasetSpi
name|dataset
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|dataset
operator|=
name|dataset
expr_stmt|;
comment|// TODO : Read Config values.
block|}
comment|/**      * Copies blocks from a set of volumes.      *      * @param pair - Source and Destination Volumes.      * @param item - Number of bytes to move from volumes.      */
annotation|@
name|Override
DECL|method|copyBlocks (VolumePair pair, DiskBalancerWorkItem item)
specifier|public
name|void
name|copyBlocks
parameter_list|(
name|VolumePair
name|pair
parameter_list|,
name|DiskBalancerWorkItem
name|item
parameter_list|)
block|{      }
comment|/**      * Begin the actual copy operations. This is useful in testing.      */
annotation|@
name|Override
DECL|method|setRunnable ()
specifier|public
name|void
name|setRunnable
parameter_list|()
block|{      }
comment|/**      * Tells copyBlocks to exit from the copy routine.      */
annotation|@
name|Override
DECL|method|setExitFlag ()
specifier|public
name|void
name|setExitFlag
parameter_list|()
block|{      }
comment|/**      * Returns a pointer to the current dataset we are operating against.      *      * @return FsDatasetSpi      */
annotation|@
name|Override
DECL|method|getDataset ()
specifier|public
name|FsDatasetSpi
name|getDataset
parameter_list|()
block|{
return|return
name|dataset
return|;
block|}
block|}
block|}
end_class

end_unit

