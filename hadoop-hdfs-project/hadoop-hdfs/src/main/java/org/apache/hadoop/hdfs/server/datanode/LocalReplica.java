begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
operator|.
name|ScanInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|LengthInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * This class is used for all replicas which are on local storage media  * and hence, are backed by files.  */
end_comment

begin_class
DECL|class|LocalReplica
specifier|abstract
specifier|public
class|class
name|LocalReplica
extends|extends
name|ReplicaInfo
block|{
comment|/**    * Base directory containing numerically-identified sub directories and    * possibly blocks.    */
DECL|field|baseDir
specifier|private
name|File
name|baseDir
decl_stmt|;
comment|/**    * Whether or not this replica's parent directory includes subdirs, in which    * case we can generate them based on the replica's block ID    */
DECL|field|hasSubdirs
specifier|private
name|boolean
name|hasSubdirs
decl_stmt|;
DECL|field|internedBaseDirs
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|File
argument_list|>
name|internedBaseDirs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|File
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LocalReplica
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Constructor    * @param block a block    * @param vol volume where replica is located    * @param dir directory path where block and meta files are located    */
DECL|method|LocalReplica (Block block, FsVolumeSpi vol, File dir)
name|LocalReplica
parameter_list|(
name|Block
name|block
parameter_list|,
name|FsVolumeSpi
name|vol
parameter_list|,
name|File
name|dir
parameter_list|)
block|{
name|this
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|block
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|vol
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor    * @param blockId block id    * @param len replica length    * @param genStamp replica generation stamp    * @param vol volume where replica is located    * @param dir directory path where block and meta files are located    */
DECL|method|LocalReplica (long blockId, long len, long genStamp, FsVolumeSpi vol, File dir)
name|LocalReplica
parameter_list|(
name|long
name|blockId
parameter_list|,
name|long
name|len
parameter_list|,
name|long
name|genStamp
parameter_list|,
name|FsVolumeSpi
name|vol
parameter_list|,
name|File
name|dir
parameter_list|)
block|{
name|super
argument_list|(
name|vol
argument_list|,
name|blockId
argument_list|,
name|len
argument_list|,
name|genStamp
argument_list|)
expr_stmt|;
name|setDirInternal
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copy constructor.    * @param from the source replica    */
DECL|method|LocalReplica (LocalReplica from)
name|LocalReplica
parameter_list|(
name|LocalReplica
name|from
parameter_list|)
block|{
name|this
argument_list|(
name|from
argument_list|,
name|from
operator|.
name|getVolume
argument_list|()
argument_list|,
name|from
operator|.
name|getDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the full path of this replica's data file.    * @return the full path of this replica's data file    */
annotation|@
name|VisibleForTesting
DECL|method|getBlockFile ()
specifier|public
name|File
name|getBlockFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|getDir
argument_list|()
argument_list|,
name|getBlockName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the full path of this replica's meta file.    * @return the full path of this replica's meta file    */
annotation|@
name|VisibleForTesting
DECL|method|getMetaFile ()
specifier|public
name|File
name|getMetaFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|getDir
argument_list|()
argument_list|,
name|DatanodeUtil
operator|.
name|getMetaName
argument_list|(
name|getBlockName
argument_list|()
argument_list|,
name|getGenerationStamp
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return the parent directory path where this replica is located.    * @return the parent directory path where this replica is located    */
DECL|method|getDir ()
specifier|protected
name|File
name|getDir
parameter_list|()
block|{
return|return
name|hasSubdirs
condition|?
name|DatanodeUtil
operator|.
name|idToBlockDir
argument_list|(
name|baseDir
argument_list|,
name|getBlockId
argument_list|()
argument_list|)
else|:
name|baseDir
return|;
block|}
comment|/**    * Set the parent directory where this replica is located.    * @param dir the parent directory where the replica is located    */
DECL|method|setDirInternal (File dir)
specifier|private
name|void
name|setDirInternal
parameter_list|(
name|File
name|dir
parameter_list|)
block|{
if|if
condition|(
name|dir
operator|==
literal|null
condition|)
block|{
name|baseDir
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|ReplicaDirInfo
name|dirInfo
init|=
name|parseBaseDir
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|this
operator|.
name|hasSubdirs
operator|=
name|dirInfo
operator|.
name|hasSubidrs
expr_stmt|;
synchronized|synchronized
init|(
name|internedBaseDirs
init|)
block|{
if|if
condition|(
operator|!
name|internedBaseDirs
operator|.
name|containsKey
argument_list|(
name|dirInfo
operator|.
name|baseDirPath
argument_list|)
condition|)
block|{
comment|// Create a new String path of this file and make a brand new File object
comment|// to guarantee we drop the reference to the underlying char[] storage.
name|File
name|baseDir
init|=
operator|new
name|File
argument_list|(
name|dirInfo
operator|.
name|baseDirPath
argument_list|)
decl_stmt|;
name|internedBaseDirs
operator|.
name|put
argument_list|(
name|dirInfo
operator|.
name|baseDirPath
argument_list|,
name|baseDir
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|baseDir
operator|=
name|internedBaseDirs
operator|.
name|get
argument_list|(
name|dirInfo
operator|.
name|baseDirPath
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|class|ReplicaDirInfo
specifier|public
specifier|static
class|class
name|ReplicaDirInfo
block|{
DECL|field|baseDirPath
specifier|public
name|String
name|baseDirPath
decl_stmt|;
DECL|field|hasSubidrs
specifier|public
name|boolean
name|hasSubidrs
decl_stmt|;
DECL|method|ReplicaDirInfo (String baseDirPath, boolean hasSubidrs)
specifier|public
name|ReplicaDirInfo
parameter_list|(
name|String
name|baseDirPath
parameter_list|,
name|boolean
name|hasSubidrs
parameter_list|)
block|{
name|this
operator|.
name|baseDirPath
operator|=
name|baseDirPath
expr_stmt|;
name|this
operator|.
name|hasSubidrs
operator|=
name|hasSubidrs
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|parseBaseDir (File dir)
specifier|public
specifier|static
name|ReplicaDirInfo
name|parseBaseDir
parameter_list|(
name|File
name|dir
parameter_list|)
block|{
name|File
name|currentDir
init|=
name|dir
decl_stmt|;
name|boolean
name|hasSubdirs
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|currentDir
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|DataStorage
operator|.
name|BLOCK_SUBDIR_PREFIX
argument_list|)
condition|)
block|{
name|hasSubdirs
operator|=
literal|true
expr_stmt|;
name|currentDir
operator|=
name|currentDir
operator|.
name|getParentFile
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|ReplicaDirInfo
argument_list|(
name|currentDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|hasSubdirs
argument_list|)
return|;
block|}
comment|/**    * Copy specified file into a temporary file. Then rename the    * temporary file to the original name. This will cause any    * hardlinks to the original file to be removed. The temporary    * files are created in the same directory. The temporary files will    * be recovered (especially on Windows) on datanode restart.    */
DECL|method|breakHardlinks (File file, Block b)
specifier|private
name|void
name|breakHardlinks
parameter_list|(
name|File
name|file
parameter_list|,
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FileIoProvider
name|fileIoProvider
init|=
name|getFileIoProvider
argument_list|()
decl_stmt|;
specifier|final
name|File
name|tmpFile
init|=
name|DatanodeUtil
operator|.
name|createFileWithExistsCheck
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|b
argument_list|,
name|DatanodeUtil
operator|.
name|getUnlinkTmpFile
argument_list|(
name|file
argument_list|)
argument_list|,
name|fileIoProvider
argument_list|)
decl_stmt|;
try|try
block|{
try|try
init|(
name|FileInputStream
name|in
init|=
name|fileIoProvider
operator|.
name|getFileInputStream
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|file
argument_list|)
init|)
block|{
try|try
init|(
name|FileOutputStream
name|out
init|=
name|fileIoProvider
operator|.
name|getFileOutputStream
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|tmpFile
argument_list|)
init|)
block|{
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
literal|16
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|file
operator|.
name|length
argument_list|()
operator|!=
name|tmpFile
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Copy of file "
operator|+
name|file
operator|+
literal|" size "
operator|+
name|file
operator|.
name|length
argument_list|()
operator|+
literal|" into file "
operator|+
name|tmpFile
operator|+
literal|" resulted in a size of "
operator|+
name|tmpFile
operator|.
name|length
argument_list|()
argument_list|)
throw|;
block|}
name|fileIoProvider
operator|.
name|replaceFile
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|tmpFile
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fileIoProvider
operator|.
name|delete
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|tmpFile
argument_list|)
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"detachFile failed to delete temporary file "
operator|+
name|tmpFile
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * This function "breaks hardlinks" to the current replica file.    *    * When doing a DataNode upgrade, we create a bunch of hardlinks to each block    * file.  This cleverly ensures that both the old and the new storage    * directories can contain the same block file, without using additional space    * for the data.    *    * However, when we want to append to the replica file, we need to "break" the    * hardlink to ensure that the old snapshot continues to contain the old data    * length.  If we failed to do that, we could roll back to the previous/    * directory during a downgrade, and find that the block contents were longer    * than they were at the time of upgrade.    *    * @return true only if data was copied.    * @throws IOException    */
DECL|method|breakHardLinksIfNeeded ()
specifier|public
name|boolean
name|breakHardLinksIfNeeded
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|File
name|file
init|=
name|getBlockFile
argument_list|()
decl_stmt|;
specifier|final
name|FileIoProvider
name|fileIoProvider
init|=
name|getFileIoProvider
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|null
operator|||
name|getVolume
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"detachBlock:Block not found. "
operator|+
name|this
argument_list|)
throw|;
block|}
name|File
name|meta
init|=
name|getMetaFile
argument_list|()
decl_stmt|;
name|int
name|linkCount
init|=
name|fileIoProvider
operator|.
name|getHardLinkCount
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|linkCount
operator|>
literal|1
condition|)
block|{
name|DataNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Breaking hardlink for "
operator|+
name|linkCount
operator|+
literal|"x-linked "
operator|+
literal|"block "
operator|+
name|this
argument_list|)
expr_stmt|;
name|breakHardlinks
argument_list|(
name|file
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fileIoProvider
operator|.
name|getHardLinkCount
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|meta
argument_list|)
operator|>
literal|1
condition|)
block|{
name|breakHardlinks
argument_list|(
name|meta
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getBlockURI ()
specifier|public
name|URI
name|getBlockURI
parameter_list|()
block|{
return|return
name|getBlockFile
argument_list|()
operator|.
name|toURI
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getDataInputStream (long seekOffset)
specifier|public
name|InputStream
name|getDataInputStream
parameter_list|(
name|long
name|seekOffset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getDataInputStream
argument_list|(
name|getBlockFile
argument_list|()
argument_list|,
name|seekOffset
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getDataOutputStream (boolean append)
specifier|public
name|OutputStream
name|getDataOutputStream
parameter_list|(
name|boolean
name|append
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileIoProvider
argument_list|()
operator|.
name|getFileOutputStream
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|getBlockFile
argument_list|()
argument_list|,
name|append
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|blockDataExists ()
specifier|public
name|boolean
name|blockDataExists
parameter_list|()
block|{
return|return
name|getFileIoProvider
argument_list|()
operator|.
name|exists
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|getBlockFile
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|deleteBlockData ()
specifier|public
name|boolean
name|deleteBlockData
parameter_list|()
block|{
return|return
name|getFileIoProvider
argument_list|()
operator|.
name|fullyDelete
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|getBlockFile
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getBlockDataLength ()
specifier|public
name|long
name|getBlockDataLength
parameter_list|()
block|{
return|return
name|getBlockFile
argument_list|()
operator|.
name|length
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getMetadataURI ()
specifier|public
name|URI
name|getMetadataURI
parameter_list|()
block|{
return|return
name|getMetaFile
argument_list|()
operator|.
name|toURI
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getMetadataInputStream (long offset)
specifier|public
name|LengthInputStream
name|getMetadataInputStream
parameter_list|(
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|meta
init|=
name|getMetaFile
argument_list|()
decl_stmt|;
return|return
operator|new
name|LengthInputStream
argument_list|(
name|getFileIoProvider
argument_list|()
operator|.
name|openAndSeek
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|meta
argument_list|,
name|offset
argument_list|)
argument_list|,
name|meta
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getMetadataOutputStream (boolean append)
specifier|public
name|OutputStream
name|getMetadataOutputStream
parameter_list|(
name|boolean
name|append
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileOutputStream
argument_list|(
name|getMetaFile
argument_list|()
argument_list|,
name|append
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|metadataExists ()
specifier|public
name|boolean
name|metadataExists
parameter_list|()
block|{
return|return
name|getFileIoProvider
argument_list|()
operator|.
name|exists
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|getMetaFile
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|deleteMetadata ()
specifier|public
name|boolean
name|deleteMetadata
parameter_list|()
block|{
return|return
name|getFileIoProvider
argument_list|()
operator|.
name|fullyDelete
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|getMetaFile
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getMetadataLength ()
specifier|public
name|long
name|getMetadataLength
parameter_list|()
block|{
return|return
name|getMetaFile
argument_list|()
operator|.
name|length
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|renameMeta (URI destURI)
specifier|public
name|boolean
name|renameMeta
parameter_list|(
name|URI
name|destURI
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|renameFile
argument_list|(
name|getMetaFile
argument_list|()
argument_list|,
operator|new
name|File
argument_list|(
name|destURI
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|renameData (URI destURI)
specifier|public
name|boolean
name|renameData
parameter_list|(
name|URI
name|destURI
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|renameFile
argument_list|(
name|getBlockFile
argument_list|()
argument_list|,
operator|new
name|File
argument_list|(
name|destURI
argument_list|)
argument_list|)
return|;
block|}
DECL|method|renameFile (File srcfile, File destfile)
specifier|private
name|boolean
name|renameFile
parameter_list|(
name|File
name|srcfile
parameter_list|,
name|File
name|destfile
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|getFileIoProvider
argument_list|()
operator|.
name|rename
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|srcfile
argument_list|,
name|destfile
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move block file for "
operator|+
name|this
operator|+
literal|" from "
operator|+
name|srcfile
operator|+
literal|" to "
operator|+
name|destfile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|updateWithReplica (StorageLocation replicaLocation)
specifier|public
name|void
name|updateWithReplica
parameter_list|(
name|StorageLocation
name|replicaLocation
parameter_list|)
block|{
comment|// for local replicas, the replica location is assumed to be a file.
name|File
name|diskFile
init|=
literal|null
decl_stmt|;
try|try
block|{
name|diskFile
operator|=
operator|new
name|File
argument_list|(
name|replicaLocation
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|diskFile
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|==
name|diskFile
condition|)
block|{
name|setDirInternal
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setDirInternal
argument_list|(
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getPinning (LocalFileSystem localFS)
specifier|public
name|boolean
name|getPinning
parameter_list|(
name|LocalFileSystem
name|localFS
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getPinning
argument_list|(
name|localFS
argument_list|,
operator|new
name|Path
argument_list|(
name|getBlockFile
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setPinning (LocalFileSystem localFS)
specifier|public
name|void
name|setPinning
parameter_list|(
name|LocalFileSystem
name|localFS
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|f
init|=
name|getBlockFile
argument_list|()
decl_stmt|;
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
name|setPinning
argument_list|(
name|localFS
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|bumpReplicaGS (long newGS)
specifier|public
name|void
name|bumpReplicaGS
parameter_list|(
name|long
name|newGS
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|oldGS
init|=
name|getGenerationStamp
argument_list|()
decl_stmt|;
specifier|final
name|File
name|oldmeta
init|=
name|getMetaFile
argument_list|()
decl_stmt|;
name|setGenerationStamp
argument_list|(
name|newGS
argument_list|)
expr_stmt|;
specifier|final
name|File
name|newmeta
init|=
name|getMetaFile
argument_list|()
decl_stmt|;
comment|// rename meta file to new GS
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// calling renameMeta on the ReplicaInfo doesn't work here
name|getFileIoProvider
argument_list|()
operator|.
name|rename
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|oldmeta
argument_list|,
name|newmeta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|setGenerationStamp
argument_list|(
name|oldGS
argument_list|)
expr_stmt|;
comment|// restore old GS
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|this
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move meta file  "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|truncateBlock (long newLength)
specifier|public
name|void
name|truncateBlock
parameter_list|(
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
name|truncateBlock
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|getBlockFile
argument_list|()
argument_list|,
name|getMetaFile
argument_list|()
argument_list|,
name|getNumBytes
argument_list|()
argument_list|,
name|newLength
argument_list|,
name|getFileIoProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compareWith (ScanInfo info)
specifier|public
name|int
name|compareWith
parameter_list|(
name|ScanInfo
name|info
parameter_list|)
block|{
return|return
name|info
operator|.
name|getBlockFile
argument_list|()
operator|.
name|compareTo
argument_list|(
name|getBlockFile
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|copyMetadata (URI destination)
specifier|public
name|void
name|copyMetadata
parameter_list|(
name|URI
name|destination
parameter_list|)
throws|throws
name|IOException
block|{
comment|//for local replicas, we assume the destination URI is file
name|getFileIoProvider
argument_list|()
operator|.
name|nativeCopyFileUnbuffered
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|getMetaFile
argument_list|()
argument_list|,
operator|new
name|File
argument_list|(
name|destination
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|copyBlockdata (URI destination)
specifier|public
name|void
name|copyBlockdata
parameter_list|(
name|URI
name|destination
parameter_list|)
throws|throws
name|IOException
block|{
comment|//for local replicas, we assume the destination URI is file
name|getFileIoProvider
argument_list|()
operator|.
name|nativeCopyFileUnbuffered
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|getBlockFile
argument_list|()
argument_list|,
operator|new
name|File
argument_list|(
name|destination
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get input stream for a local file and optionally seek to the offset.    * @param f path to the file    * @param seekOffset offset to seek    * @return input stream for read    * @throws IOException    */
DECL|method|getDataInputStream (File f, long seekOffset)
specifier|private
name|FileInputStream
name|getDataInputStream
parameter_list|(
name|File
name|f
parameter_list|,
name|long
name|seekOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|FileInputStream
name|fis
decl_stmt|;
specifier|final
name|FileIoProvider
name|fileIoProvider
init|=
name|getFileIoProvider
argument_list|()
decl_stmt|;
if|if
condition|(
name|NativeIO
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
name|fis
operator|=
name|fileIoProvider
operator|.
name|getShareDeleteFileInputStream
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|f
argument_list|,
name|seekOffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|fis
operator|=
name|fileIoProvider
operator|.
name|openAndSeek
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|f
argument_list|,
name|seekOffset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected block file at "
operator|+
name|f
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
block|}
return|return
name|fis
return|;
block|}
comment|/**    *  Get pin status of a file by checking the sticky bit.    * @param localFS local file system    * @param path path to be checked    * @return true if the file is pinned with sticky bit    * @throws IOException    */
DECL|method|getPinning (LocalFileSystem localFS, Path path)
specifier|public
name|boolean
name|getPinning
parameter_list|(
name|LocalFileSystem
name|localFS
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|stickyBit
init|=
name|localFS
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|getPermission
argument_list|()
operator|.
name|getStickyBit
argument_list|()
decl_stmt|;
return|return
name|stickyBit
return|;
block|}
comment|/**    * Set sticky bit on path to pin file.    * @param localFS local file system    * @param path path to be pinned with sticky bit    * @throws IOException    */
DECL|method|setPinning (LocalFileSystem localFS, Path path)
specifier|public
name|void
name|setPinning
parameter_list|(
name|LocalFileSystem
name|localFS
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FsPermission
name|oldPermission
init|=
name|localFS
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|getPermission
argument_list|()
decl_stmt|;
name|FsPermission
name|permission
init|=
operator|new
name|FsPermission
argument_list|(
name|oldPermission
operator|.
name|getUserAction
argument_list|()
argument_list|,
name|oldPermission
operator|.
name|getGroupAction
argument_list|()
argument_list|,
name|oldPermission
operator|.
name|getOtherAction
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|localFS
operator|.
name|setPermission
argument_list|(
name|path
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
DECL|method|truncateBlock ( FsVolumeSpi volume, File blockFile, File metaFile, long oldlen, long newlen, FileIoProvider fileIoProvider)
specifier|public
specifier|static
name|void
name|truncateBlock
parameter_list|(
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|blockFile
parameter_list|,
name|File
name|metaFile
parameter_list|,
name|long
name|oldlen
parameter_list|,
name|long
name|newlen
parameter_list|,
name|FileIoProvider
name|fileIoProvider
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"truncateBlock: blockFile="
operator|+
name|blockFile
operator|+
literal|", metaFile="
operator|+
name|metaFile
operator|+
literal|", oldlen="
operator|+
name|oldlen
operator|+
literal|", newlen="
operator|+
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|==
name|oldlen
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|newlen
operator|>
name|oldlen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot truncate block to from oldlen (="
operator|+
name|oldlen
operator|+
literal|") to newlen (="
operator|+
name|newlen
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// fis is closed by BlockMetadataHeader.readHeader.
specifier|final
name|FileInputStream
name|fis
init|=
name|fileIoProvider
operator|.
name|getFileInputStream
argument_list|(
name|volume
argument_list|,
name|metaFile
argument_list|)
decl_stmt|;
name|DataChecksum
name|dcs
init|=
name|BlockMetadataHeader
operator|.
name|readHeader
argument_list|(
name|fis
argument_list|)
operator|.
name|getChecksum
argument_list|()
decl_stmt|;
name|int
name|checksumsize
init|=
name|dcs
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
name|int
name|bpc
init|=
name|dcs
operator|.
name|getBytesPerChecksum
argument_list|()
decl_stmt|;
name|long
name|n
init|=
operator|(
name|newlen
operator|-
literal|1
operator|)
operator|/
name|bpc
operator|+
literal|1
decl_stmt|;
name|long
name|newmetalen
init|=
name|BlockMetadataHeader
operator|.
name|getHeaderSize
argument_list|()
operator|+
name|n
operator|*
name|checksumsize
decl_stmt|;
name|long
name|lastchunkoffset
init|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
name|bpc
decl_stmt|;
name|int
name|lastchunksize
init|=
call|(
name|int
call|)
argument_list|(
name|newlen
operator|-
name|lastchunkoffset
argument_list|)
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|Math
operator|.
name|max
argument_list|(
name|lastchunksize
argument_list|,
name|checksumsize
argument_list|)
index|]
decl_stmt|;
try|try
init|(
name|RandomAccessFile
name|blockRAF
init|=
name|fileIoProvider
operator|.
name|getRandomAccessFile
argument_list|(
name|volume
argument_list|,
name|blockFile
argument_list|,
literal|"rw"
argument_list|)
init|)
block|{
comment|//truncate blockFile
name|blockRAF
operator|.
name|setLength
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
comment|//read last chunk
name|blockRAF
operator|.
name|seek
argument_list|(
name|lastchunkoffset
argument_list|)
expr_stmt|;
name|blockRAF
operator|.
name|readFully
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|lastchunksize
argument_list|)
expr_stmt|;
block|}
comment|//compute checksum
name|dcs
operator|.
name|update
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|lastchunksize
argument_list|)
expr_stmt|;
name|dcs
operator|.
name|writeValue
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//update metaFile
try|try
init|(
name|RandomAccessFile
name|metaRAF
init|=
name|fileIoProvider
operator|.
name|getRandomAccessFile
argument_list|(
name|volume
argument_list|,
name|metaFile
argument_list|,
literal|"rw"
argument_list|)
init|)
block|{
name|metaRAF
operator|.
name|setLength
argument_list|(
name|newmetalen
argument_list|)
expr_stmt|;
name|metaRAF
operator|.
name|seek
argument_list|(
name|newmetalen
operator|-
name|checksumsize
argument_list|)
expr_stmt|;
name|metaRAF
operator|.
name|write
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|checksumsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sync the parent directory changes to durable device.    * @throws IOException    */
DECL|method|fsyncDirectory ()
specifier|public
name|void
name|fsyncDirectory
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|dir
init|=
name|getDir
argument_list|()
decl_stmt|;
try|try
block|{
name|getFileIoProvider
argument_list|()
operator|.
name|dirSync
argument_list|(
name|getVolume
argument_list|()
argument_list|,
name|getDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to sync "
operator|+
name|dir
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

