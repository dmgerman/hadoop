begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HardLink
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|impl
operator|.
name|FsDatasetUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|SocketOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Flushable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|CopyOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|FileIoProvider
operator|.
name|OPERATION
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * This class abstracts out various file IO operations performed by the  * DataNode and invokes event hooks before and after each file IO.  *  * Behavior can be injected into these events by implementing  * {@link FileIoEvents} and replacing the default implementation  * with {@link DFSConfigKeys#DFS_DATANODE_FILE_IO_EVENTS_CLASS_KEY}.  *  * Most functions accept an optional {@link FsVolumeSpi} parameter for  * instrumentation/logging.  *  * Some methods may look redundant, especially the multiple variations of  * move/rename/list. They exist to retain behavior compatibility for existing  * code.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|FileIoProvider
specifier|public
class|class
name|FileIoProvider
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FileIoProvider
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|eventHooks
specifier|private
specifier|final
name|FileIoEvents
name|eventHooks
decl_stmt|;
comment|/**    * @param conf  Configuration object. May be null. When null,    *              the event handlers are no-ops.    */
DECL|method|FileIoProvider (@ullable Configuration conf)
specifier|public
name|FileIoProvider
parameter_list|(
annotation|@
name|Nullable
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|FileIoEvents
argument_list|>
name|clazz
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FILE_IO_EVENTS_CLASS_KEY
argument_list|,
name|DefaultFileIoEvents
operator|.
name|class
argument_list|,
name|FileIoEvents
operator|.
name|class
argument_list|)
decl_stmt|;
name|eventHooks
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|clazz
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eventHooks
operator|=
operator|new
name|DefaultFileIoEvents
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Lists the types of file system operations. Passed to the    * IO hooks so implementations can choose behavior based on    * specific operations.    */
DECL|enum|OPERATION
specifier|public
enum|enum
name|OPERATION
block|{
DECL|enumConstant|OPEN
name|OPEN
block|,
DECL|enumConstant|EXISTS
name|EXISTS
block|,
DECL|enumConstant|LIST
name|LIST
block|,
DECL|enumConstant|DELETE
name|DELETE
block|,
DECL|enumConstant|MOVE
name|MOVE
block|,
DECL|enumConstant|MKDIRS
name|MKDIRS
block|,
DECL|enumConstant|TRANSFER
name|TRANSFER
block|,
DECL|enumConstant|SYNC
name|SYNC
block|,
DECL|enumConstant|FADVISE
name|FADVISE
block|,
DECL|enumConstant|READ
name|READ
block|,
DECL|enumConstant|WRITE
name|WRITE
block|,
DECL|enumConstant|FLUSH
name|FLUSH
block|,
DECL|enumConstant|NATIVE_COPY
name|NATIVE_COPY
block|}
comment|/**    * Retrieve statistics from the underlying {@link FileIoEvents}    * implementation as a JSON string, if it maintains them.    * @return statistics as a JSON string. May be null.    */
DECL|method|getStatistics ()
specifier|public
annotation|@
name|Nullable
name|String
name|getStatistics
parameter_list|()
block|{
return|return
name|eventHooks
operator|.
name|getStatistics
argument_list|()
return|;
block|}
comment|/**    * See {@link Flushable#flush()}.    *    * @param  volume target volume. null if unavailable.    * @throws IOException    */
DECL|method|flush ( @ullable FsVolumeSpi volume, Flushable f)
specifier|public
name|void
name|flush
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|Flushable
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|FLUSH
argument_list|,
literal|0
argument_list|)
decl_stmt|;
try|try
block|{
name|f
operator|.
name|flush
argument_list|()
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|FLUSH
argument_list|,
name|begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|FLUSH
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Sync the given {@link FileOutputStream}.    *    * @param  volume target volume. null if unavailable.    * @throws IOException    */
DECL|method|sync ( @ullable FsVolumeSpi volume, FileOutputStream fos)
specifier|public
name|void
name|sync
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|FileOutputStream
name|fos
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|SYNC
argument_list|,
literal|0
argument_list|)
decl_stmt|;
try|try
block|{
name|fos
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|SYNC
argument_list|,
name|begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|SYNC
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Call sync_file_range on the given file descriptor.    *    * @param  volume target volume. null if unavailable.    * @throws IOException    */
DECL|method|syncFileRange ( @ullable FsVolumeSpi volume, FileDescriptor outFd, long offset, long numBytes, int flags)
specifier|public
name|void
name|syncFileRange
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|FileDescriptor
name|outFd
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|numBytes
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|NativeIOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|SYNC
argument_list|,
literal|0
argument_list|)
decl_stmt|;
try|try
block|{
name|NativeIO
operator|.
name|POSIX
operator|.
name|syncFileRangeIfPossible
argument_list|(
name|outFd
argument_list|,
name|offset
argument_list|,
name|numBytes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|SYNC
argument_list|,
name|begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|SYNC
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Call posix_fadvise on the given file descriptor.    *    * @param  volume target volume. null if unavailable.    * @throws IOException    */
DECL|method|posixFadvise ( @ullable FsVolumeSpi volume, String identifier, FileDescriptor outFd, long offset, long length, int flags)
specifier|public
name|void
name|posixFadvise
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|String
name|identifier
parameter_list|,
name|FileDescriptor
name|outFd
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|length
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|NativeIOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|FADVISE
argument_list|)
decl_stmt|;
try|try
block|{
name|NativeIO
operator|.
name|POSIX
operator|.
name|getCacheManipulator
argument_list|()
operator|.
name|posixFadviseIfPossible
argument_list|(
name|identifier
argument_list|,
name|outFd
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|FADVISE
argument_list|,
name|begin
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|FADVISE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Delete a file.    * @param volume  target volume. null if unavailable.    * @param f  File to delete.    * @return  true if the file was successfully deleted.    */
DECL|method|delete (@ullable FsVolumeSpi volume, File f)
specifier|public
name|boolean
name|delete
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|)
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|DELETE
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|deleted
init|=
name|f
operator|.
name|delete
argument_list|()
decl_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|DELETE
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|deleted
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|DELETE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Delete a file, first checking to see if it exists.    * @param volume  target volume. null if unavailable.    * @param f  File to delete    * @return  true if the file was successfully deleted or if it never    *          existed.    */
DECL|method|deleteWithExistsCheck (@ullable FsVolumeSpi volume, File f)
specifier|public
name|boolean
name|deleteWithExistsCheck
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|)
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|DELETE
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|deleted
init|=
operator|!
name|f
operator|.
name|exists
argument_list|()
operator|||
name|f
operator|.
name|delete
argument_list|()
decl_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|DELETE
argument_list|,
name|begin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deleted
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete file {}"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|deleted
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|DELETE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Transfer data from a FileChannel to a SocketOutputStream.    *    * @param volume  target volume. null if unavailable.    * @param sockOut  SocketOutputStream to write the data.    * @param fileCh  FileChannel from which to read data.    * @param position  position within the channel where the transfer begins.    * @param count  number of bytes to transfer.    * @param waitTime  returns the nanoseconds spent waiting for the socket    *                  to become writable.    * @param transferTime  returns the nanoseconds spent transferring data.    * @throws IOException    */
DECL|method|transferToSocketFully ( @ullable FsVolumeSpi volume, SocketOutputStream sockOut, FileChannel fileCh, long position, int count, LongWritable waitTime, LongWritable transferTime)
specifier|public
name|void
name|transferToSocketFully
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|SocketOutputStream
name|sockOut
parameter_list|,
name|FileChannel
name|fileCh
parameter_list|,
name|long
name|position
parameter_list|,
name|int
name|count
parameter_list|,
name|LongWritable
name|waitTime
parameter_list|,
name|LongWritable
name|transferTime
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|TRANSFER
argument_list|,
name|count
argument_list|)
decl_stmt|;
try|try
block|{
name|sockOut
operator|.
name|transferToFully
argument_list|(
name|fileCh
argument_list|,
name|position
argument_list|,
name|count
argument_list|,
name|waitTime
argument_list|,
name|transferTime
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|TRANSFER
argument_list|,
name|begin
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|TRANSFER
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Create a file.    * @param volume  target volume. null if unavailable.    * @param f  File to be created.    * @return  true if the file does not exist and was successfully created.    *          false if the file already exists.    * @throws IOException    */
DECL|method|createFile ( @ullable FsVolumeSpi volume, File f)
specifier|public
name|boolean
name|createFile
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|created
init|=
name|f
operator|.
name|createNewFile
argument_list|()
decl_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|created
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Create a FileInputStream using    * {@link FileInputStream#FileInputStream(File)}.    *    * Wraps the created input stream to intercept read calls    * before delegating to the wrapped stream.    *    * @param volume  target volume. null if unavailable.    * @param f  File object.    * @return  FileInputStream to the given file.    * @throws  FileNotFoundException    */
DECL|method|getFileInputStream ( @ullable FsVolumeSpi volume, File f)
specifier|public
name|FileInputStream
name|getFileInputStream
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|)
decl_stmt|;
name|FileInputStream
name|fis
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fis
operator|=
operator|new
name|WrappedFileInputStream
argument_list|(
name|volume
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|fis
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|fis
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Create a FileOutputStream using    * {@link FileOutputStream#FileOutputStream(File, boolean)}.    *    * Wraps the created output stream to intercept write calls    * before delegating to the wrapped stream.    *    * @param volume  target volume. null if unavailable.    * @param f  File object.    * @param append  if true, then bytes will be written to the end of the    *                file rather than the beginning.    * @param  FileOutputStream to the given file object.    * @throws FileNotFoundException    */
DECL|method|getFileOutputStream ( @ullable FsVolumeSpi volume, File f, boolean append)
specifier|public
name|FileOutputStream
name|getFileOutputStream
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|,
name|boolean
name|append
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|)
decl_stmt|;
name|FileOutputStream
name|fos
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fos
operator|=
operator|new
name|WrappedFileOutputStream
argument_list|(
name|volume
argument_list|,
name|f
argument_list|,
name|append
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|fos
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|fos
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Create a FileOutputStream using    * {@link FileOutputStream#FileOutputStream(File, boolean)}.    *    * Wraps the created output stream to intercept write calls    * before delegating to the wrapped stream.    *    * @param volume  target volume. null if unavailable.    * @param f  File object.    * @return  FileOutputStream to the given file object.    * @throws  FileNotFoundException    */
DECL|method|getFileOutputStream ( @ullable FsVolumeSpi volume, File f)
specifier|public
name|FileOutputStream
name|getFileOutputStream
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
return|return
name|getFileOutputStream
argument_list|(
name|volume
argument_list|,
name|f
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Create a FileOutputStream using    * {@link FileOutputStream#FileOutputStream(FileDescriptor)}.    *    * Wraps the created output stream to intercept write calls    * before delegating to the wrapped stream.    *    * @param volume  target volume. null if unavailable.    * @param f  File object.    * @return  FileOutputStream to the given file object.    * @throws  FileNotFoundException    */
DECL|method|getFileOutputStream ( @ullable FsVolumeSpi volume, FileDescriptor fd)
specifier|public
name|FileOutputStream
name|getFileOutputStream
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|FileDescriptor
name|fd
parameter_list|)
block|{
return|return
operator|new
name|WrappedFileOutputStream
argument_list|(
name|volume
argument_list|,
name|fd
argument_list|)
return|;
block|}
comment|/**    * Create a FileInputStream using    * {@link NativeIO#getShareDeleteFileDescriptor}.    * Wraps the created input stream to intercept input calls    * before delegating to the wrapped stream.    *    * @param volume  target volume. null if unavailable.    * @param f  File object.    * @param offset  the offset position, measured in bytes from the    *                beginning of the file, at which to set the file    *                pointer.    * @return FileOutputStream to the given file object.    * @throws FileNotFoundException    */
DECL|method|getShareDeleteFileInputStream ( @ullable FsVolumeSpi volume, File f, long offset)
specifier|public
name|FileInputStream
name|getShareDeleteFileInputStream
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|)
decl_stmt|;
name|FileInputStream
name|fis
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fis
operator|=
operator|new
name|WrappedFileInputStream
argument_list|(
name|volume
argument_list|,
name|NativeIO
operator|.
name|getShareDeleteFileDescriptor
argument_list|(
name|f
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|fis
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|fis
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Create a FileInputStream using    * {@link FileInputStream#FileInputStream(File)} and position    * it at the given offset.    *    * Wraps the created input stream to intercept read calls    * before delegating to the wrapped stream.    *    * @param volume  target volume. null if unavailable.    * @param f  File object.    * @param offset  the offset position, measured in bytes from the    *                beginning of the file, at which to set the file    *                pointer.    * @throws FileNotFoundException    */
DECL|method|openAndSeek ( @ullable FsVolumeSpi volume, File f, long offset)
specifier|public
name|FileInputStream
name|openAndSeek
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|)
decl_stmt|;
name|FileInputStream
name|fis
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fis
operator|=
operator|new
name|WrappedFileInputStream
argument_list|(
name|volume
argument_list|,
name|FsDatasetUtil
operator|.
name|openAndSeek
argument_list|(
name|f
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|fis
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|fis
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Create a RandomAccessFile using    * {@link RandomAccessFile#RandomAccessFile(File, String)}.    *    * Wraps the created input stream to intercept IO calls    * before delegating to the wrapped RandomAccessFile.    *    * @param volume  target volume. null if unavailable.    * @param f  File object.    * @param mode  See {@link RandomAccessFile} for a description    *              of the mode string.    * @return RandomAccessFile representing the given file.    * @throws FileNotFoundException    */
DECL|method|getRandomAccessFile ( @ullable FsVolumeSpi volume, File f, String mode)
specifier|public
name|RandomAccessFile
name|getRandomAccessFile
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|,
name|String
name|mode
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|)
decl_stmt|;
name|RandomAccessFile
name|raf
init|=
literal|null
decl_stmt|;
try|try
block|{
name|raf
operator|=
operator|new
name|WrappedRandomAccessFile
argument_list|(
name|volume
argument_list|,
name|f
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|raf
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|raf
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|OPEN
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Delete the given directory using {@link FileUtil#fullyDelete(File)}.    *    * @param volume  target volume. null if unavailable.    * @param dir  directory to be deleted.    * @return true on success false on failure.    */
DECL|method|fullyDelete (@ullable FsVolumeSpi volume, File dir)
specifier|public
name|boolean
name|fullyDelete
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|dir
parameter_list|)
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|DELETE
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|deleted
init|=
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|DELETE
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|deleted
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|DELETE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Move the src file to the target using    * {@link FileUtil#replaceFile(File, File)}.    *    * @param volume  target volume. null if unavailable.    * @param src  source path.    * @param target  target path.    * @throws IOException    */
DECL|method|replaceFile ( @ullable FsVolumeSpi volume, File src, File target)
specifier|public
name|void
name|replaceFile
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|src
parameter_list|,
name|File
name|target
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|)
decl_stmt|;
try|try
block|{
name|FileUtil
operator|.
name|replaceFile
argument_list|(
name|src
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|,
name|begin
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Move the src file to the target using    * {@link Storage#rename(File, File)}.    *    * @param volume  target volume. null if unavailable.    * @param src  source path.    * @param target  target path.    * @throws IOException    */
DECL|method|rename ( @ullable FsVolumeSpi volume, File src, File target)
specifier|public
name|void
name|rename
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|src
parameter_list|,
name|File
name|target
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|)
decl_stmt|;
try|try
block|{
name|Storage
operator|.
name|rename
argument_list|(
name|src
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|,
name|begin
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Move the src file to the target using    * {@link FileUtils#moveFile(File, File)}.    *    * @param volume  target volume. null if unavailable.    * @param src  source path.    * @param target  target path.    * @throws IOException    */
DECL|method|moveFile ( @ullable FsVolumeSpi volume, File src, File target)
specifier|public
name|void
name|moveFile
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|src
parameter_list|,
name|File
name|target
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|)
decl_stmt|;
try|try
block|{
name|FileUtils
operator|.
name|moveFile
argument_list|(
name|src
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|,
name|begin
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Move the src file to the target using    * {@link Files#move(Path, Path, CopyOption...)}.    *    * @param volume  target volume. null if unavailable.    * @param src  source path.    * @param target  target path.    * @param options  See {@link Files#move} for a description    *                of the options.    * @throws IOException    */
DECL|method|move ( @ullable FsVolumeSpi volume, Path src, Path target, CopyOption... options)
specifier|public
name|void
name|move
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|Path
name|src
parameter_list|,
name|Path
name|target
parameter_list|,
name|CopyOption
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|)
decl_stmt|;
try|try
block|{
name|Files
operator|.
name|move
argument_list|(
name|src
argument_list|,
name|target
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|,
name|begin
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|MOVE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * See {@link Storage#nativeCopyFileUnbuffered(File, File, boolean)}.    *    * @param volume  target volume. null if unavailable.    * @param src  an existing file to copy, must not be {@code null}    * @param target  the new file, must not be {@code null}    * @param preserveFileDate  true if the file date of the copy    *                         should be the same as the original    * @throws IOException    */
DECL|method|nativeCopyFileUnbuffered ( @ullable FsVolumeSpi volume, File src, File target, boolean preserveFileDate)
specifier|public
name|void
name|nativeCopyFileUnbuffered
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|src
parameter_list|,
name|File
name|target
parameter_list|,
name|boolean
name|preserveFileDate
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|length
init|=
name|src
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|NATIVE_COPY
argument_list|,
name|length
argument_list|)
decl_stmt|;
try|try
block|{
name|Storage
operator|.
name|nativeCopyFileUnbuffered
argument_list|(
name|src
argument_list|,
name|target
argument_list|,
name|preserveFileDate
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|NATIVE_COPY
argument_list|,
name|begin
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|NATIVE_COPY
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * See {@link File#mkdirs()}.    *    * @param volume target volume. null if unavailable.    * @param dir  directory to be created.    * @return  true only if the directory was created. false if    *          the directory already exists.    * @throws IOException if a directory with the given name does    *                     not exist and could not be created.    */
DECL|method|mkdirs ( @ullable FsVolumeSpi volume, File dir)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|MKDIRS
argument_list|)
decl_stmt|;
name|boolean
name|created
init|=
literal|false
decl_stmt|;
name|boolean
name|isDirectory
decl_stmt|;
try|try
block|{
name|created
operator|=
name|dir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|isDirectory
operator|=
operator|!
name|created
operator|&&
name|dir
operator|.
name|isDirectory
argument_list|()
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|MKDIRS
argument_list|,
name|begin
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|MKDIRS
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
operator|!
name|created
operator|&&
operator|!
name|isDirectory
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|dir
argument_list|)
throw|;
block|}
return|return
name|created
return|;
block|}
comment|/**    * Create the target directory using {@link File#mkdirs()} only if    * it doesn't exist already.    *    * @param volume  target volume. null if unavailable.    * @param dir  directory to be created.    * @throws IOException  if the directory could not created    */
DECL|method|mkdirsWithExistsCheck ( @ullable FsVolumeSpi volume, File dir)
specifier|public
name|void
name|mkdirsWithExistsCheck
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|MKDIRS
argument_list|)
decl_stmt|;
name|boolean
name|succeeded
init|=
literal|false
decl_stmt|;
try|try
block|{
name|succeeded
operator|=
name|dir
operator|.
name|isDirectory
argument_list|()
operator|||
name|dir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|MKDIRS
argument_list|,
name|begin
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|MKDIRS
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
operator|!
name|succeeded
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|dir
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get a listing of the given directory using    * {@link FileUtil#listFiles(File)}.    *    * @param volume  target volume. null if unavailable.    * @param dir  Directory to be listed.    * @return  array of file objects representing the directory entries.    * @throws IOException    */
DECL|method|listFiles ( @ullable FsVolumeSpi volume, File dir)
specifier|public
name|File
index|[]
name|listFiles
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|)
decl_stmt|;
try|try
block|{
name|File
index|[]
name|children
init|=
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|children
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Get a listing of the given directory using    * {@link FileUtil#listFiles(File)}.    *    * @param volume  target volume. null if unavailable.    * @param   Driectory to be listed.    * @return  array of strings representing the directory entries.    * @throws IOException    */
DECL|method|list ( @ullable FsVolumeSpi volume, File dir)
specifier|public
name|String
index|[]
name|list
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|)
decl_stmt|;
try|try
block|{
name|String
index|[]
name|children
init|=
name|FileUtil
operator|.
name|list
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|children
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Get a listing of the given directory using    * {@link IOUtils#listDirectory(File, FilenameFilter)}.    *    * @param volume target volume. null if unavailable.    * @param dir Directory to list.    * @param filter {@link FilenameFilter} to filter the directory entries.    * @throws IOException    */
DECL|method|listDirectory ( @ullable FsVolumeSpi volume, File dir, FilenameFilter filter)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|listDirectory
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|dir
parameter_list|,
name|FilenameFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|)
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|IOUtils
operator|.
name|listDirectory
argument_list|(
name|dir
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|children
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Retrieves the number of links to the specified file.    *    * @param volume target volume. null if unavailable.    * @param f file whose link count is being queried.    * @return number of hard-links to the given file, including the    *         given path itself.    * @throws IOException    */
DECL|method|getHardLinkCount ( @ullable FsVolumeSpi volume, File f)
specifier|public
name|int
name|getHardLinkCount
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|count
init|=
name|HardLink
operator|.
name|getLinkCount
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|LIST
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Check for file existence using {@link File#exists()}.    *    * @param volume target volume. null if unavailable.    * @param f file object.    * @return true if the file exists.    */
DECL|method|exists (@ullable FsVolumeSpi volume, File f)
specifier|public
name|boolean
name|exists
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|)
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeMetadataOp
argument_list|(
name|volume
argument_list|,
name|EXISTS
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|exists
init|=
name|f
operator|.
name|exists
argument_list|()
decl_stmt|;
name|eventHooks
operator|.
name|afterMetadataOp
argument_list|(
name|volume
argument_list|,
name|EXISTS
argument_list|,
name|begin
argument_list|)
expr_stmt|;
return|return
name|exists
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|EXISTS
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * A thin wrapper over {@link FileInputStream} that allows    * instrumenting disk IO.    */
DECL|class|WrappedFileInputStream
specifier|private
specifier|final
class|class
name|WrappedFileInputStream
extends|extends
name|FileInputStream
block|{
DECL|field|volume
specifier|private
annotation|@
name|Nullable
specifier|final
name|FsVolumeSpi
name|volume
decl_stmt|;
comment|/**      * {@inheritDoc}.      */
DECL|method|WrappedFileInputStream (@ullable FsVolumeSpi volume, File f)
specifier|private
name|WrappedFileInputStream
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|super
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|this
operator|.
name|volume
operator|=
name|volume
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}.      */
DECL|method|WrappedFileInputStream ( @ullable FsVolumeSpi volume, FileDescriptor fd)
specifier|private
name|WrappedFileInputStream
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|FileDescriptor
name|fd
parameter_list|)
block|{
name|super
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|this
operator|.
name|volume
operator|=
name|volume
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}.      */
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|b
init|=
name|super
operator|.
name|read
argument_list|()
decl_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|begin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**      * {@inheritDoc}.      */
annotation|@
name|Override
DECL|method|read (@onnull byte[] b)
specifier|public
name|int
name|read
parameter_list|(
annotation|@
name|Nonnull
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|b
operator|.
name|length
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|numBytesRead
init|=
name|super
operator|.
name|read
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|begin
argument_list|,
name|numBytesRead
argument_list|)
expr_stmt|;
return|return
name|numBytesRead
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**      * {@inheritDoc}.      */
annotation|@
name|Override
DECL|method|read (@onnull byte[] b, int off, int len)
specifier|public
name|int
name|read
parameter_list|(
annotation|@
name|Nonnull
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|len
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|numBytesRead
init|=
name|super
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|begin
argument_list|,
name|numBytesRead
argument_list|)
expr_stmt|;
return|return
name|numBytesRead
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * A thin wrapper over {@link FileOutputStream} that allows    * instrumenting disk IO.    */
DECL|class|WrappedFileOutputStream
specifier|private
specifier|final
class|class
name|WrappedFileOutputStream
extends|extends
name|FileOutputStream
block|{
DECL|field|volume
specifier|private
annotation|@
name|Nullable
specifier|final
name|FsVolumeSpi
name|volume
decl_stmt|;
comment|/**      * {@inheritDoc}.      */
DECL|method|WrappedFileOutputStream ( @ullable FsVolumeSpi volume, File f, boolean append)
specifier|private
name|WrappedFileOutputStream
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|,
name|boolean
name|append
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|super
argument_list|(
name|f
argument_list|,
name|append
argument_list|)
expr_stmt|;
name|this
operator|.
name|volume
operator|=
name|volume
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}.      */
DECL|method|WrappedFileOutputStream ( @ullable FsVolumeSpi volume, FileDescriptor fd)
specifier|private
name|WrappedFileOutputStream
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|FileDescriptor
name|fd
parameter_list|)
block|{
name|super
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|this
operator|.
name|volume
operator|=
name|volume
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}.      */
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|begin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**      * {@inheritDoc}.      */
annotation|@
name|Override
DECL|method|write (@onnull byte[] b)
specifier|public
name|void
name|write
parameter_list|(
annotation|@
name|Nonnull
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|b
operator|.
name|length
argument_list|)
decl_stmt|;
try|try
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|begin
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**      * {@inheritDoc}.      */
annotation|@
name|Override
DECL|method|write (@onnull byte[] b, int off, int len)
specifier|public
name|void
name|write
parameter_list|(
annotation|@
name|Nonnull
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|len
argument_list|)
decl_stmt|;
try|try
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|begin
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * A thin wrapper over {@link FileInputStream} that allows    * instrumenting IO.    */
DECL|class|WrappedRandomAccessFile
specifier|private
specifier|final
class|class
name|WrappedRandomAccessFile
extends|extends
name|RandomAccessFile
block|{
DECL|field|volume
specifier|private
annotation|@
name|Nullable
specifier|final
name|FsVolumeSpi
name|volume
decl_stmt|;
DECL|method|WrappedRandomAccessFile ( @ullable FsVolumeSpi volume, File f, String mode)
specifier|public
name|WrappedRandomAccessFile
parameter_list|(
annotation|@
name|Nullable
name|FsVolumeSpi
name|volume
parameter_list|,
name|File
name|f
parameter_list|,
name|String
name|mode
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|super
argument_list|(
name|f
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|this
operator|.
name|volume
operator|=
name|volume
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|b
init|=
name|super
operator|.
name|read
argument_list|()
decl_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|begin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|read (byte[] b, int off, int len)
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|len
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|numBytesRead
init|=
name|super
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|begin
argument_list|,
name|numBytesRead
argument_list|)
expr_stmt|;
return|return
name|numBytesRead
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|read (byte[] b)
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|b
operator|.
name|length
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|numBytesRead
init|=
name|super
operator|.
name|read
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|begin
argument_list|,
name|numBytesRead
argument_list|)
expr_stmt|;
return|return
name|numBytesRead
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|READ
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|begin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|write (@onnull byte[] b)
specifier|public
name|void
name|write
parameter_list|(
annotation|@
name|Nonnull
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|b
operator|.
name|length
argument_list|)
decl_stmt|;
try|try
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|begin
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|write (byte[] b, int off, int len)
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|begin
init|=
name|eventHooks
operator|.
name|beforeFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|len
argument_list|)
decl_stmt|;
try|try
block|{
name|super
operator|.
name|write
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|eventHooks
operator|.
name|afterFileIo
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|begin
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|eventHooks
operator|.
name|onFailure
argument_list|(
name|volume
argument_list|,
name|WRITE
argument_list|,
name|e
argument_list|,
name|begin
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

