begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LightWeightLinkedSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_comment
comment|/**  * Keep prioritized queues of under replicated blocks.  * Blocks have replication priority, with priority {@link #QUEUE_HIGHEST_PRIORITY}  * indicating the highest priority.  *</p>  * Having a prioritised queue allows the {@link BlockManager} to select  * which blocks to replicate first -it tries to give priority to data  * that is most at risk or considered most valuable.  *  *<p/>  * The policy for choosing which priority to give added blocks  * is implemented in {@link #getPriority(int, int, int)}.  *</p>  *<p>The queue order is as follows:</p>  *<ol>  *<li>{@link #QUEUE_HIGHEST_PRIORITY}: the blocks that must be replicated  *   first. That is blocks with only one copy, or blocks with zero live  *   copies but a copy in a node being decommissioned. These blocks  *   are at risk of loss if the disk or server on which they  *   remain fails.</li>  *<li>{@link #QUEUE_VERY_UNDER_REPLICATED}: blocks that are very  *   under-replicated compared to their expected values. Currently  *   that means the ratio of the ratio of actual:expected means that  *   there is<i>less than</i> 1:3.</li>. These blocks may not be at risk,  *   but they are clearly considered "important".  *<li>{@link #QUEUE_UNDER_REPLICATED}: blocks that are also under  *   replicated, and the ratio of actual:expected is good enough that  *   they do not need to go into the {@link #QUEUE_VERY_UNDER_REPLICATED}  *   queue.</li>  *<li>{@link #QUEUE_REPLICAS_BADLY_DISTRIBUTED}: there are as least as  *   many copies of a block as required, but the blocks are not adequately  *   distributed. Loss of a rack/switch could take all copies off-line.</li>  *<li>{@link #QUEUE_WITH_CORRUPT_BLOCKS} This is for blocks that are corrupt  *   and for which there are no-non-corrupt copies (currently) available.  *   The policy here is to keep those corrupt blocks replicated, but give  *   blocks that are not corrupt higher priority.</li>  *</ol>  */
end_comment

begin_class
DECL|class|UnderReplicatedBlocks
class|class
name|UnderReplicatedBlocks
implements|implements
name|Iterable
argument_list|<
name|BlockInfo
argument_list|>
block|{
comment|/** The total number of queues : {@value} */
DECL|field|LEVEL
specifier|static
specifier|final
name|int
name|LEVEL
init|=
literal|5
decl_stmt|;
comment|/** The queue with the highest priority: {@value} */
DECL|field|QUEUE_HIGHEST_PRIORITY
specifier|static
specifier|final
name|int
name|QUEUE_HIGHEST_PRIORITY
init|=
literal|0
decl_stmt|;
comment|/** The queue for blocks that are way below their expected value : {@value} */
DECL|field|QUEUE_VERY_UNDER_REPLICATED
specifier|static
specifier|final
name|int
name|QUEUE_VERY_UNDER_REPLICATED
init|=
literal|1
decl_stmt|;
comment|/** The queue for "normally" under-replicated blocks: {@value} */
DECL|field|QUEUE_UNDER_REPLICATED
specifier|static
specifier|final
name|int
name|QUEUE_UNDER_REPLICATED
init|=
literal|2
decl_stmt|;
comment|/** The queue for blocks that have the right number of replicas,    * but which the block manager felt were badly distributed: {@value}    */
DECL|field|QUEUE_REPLICAS_BADLY_DISTRIBUTED
specifier|static
specifier|final
name|int
name|QUEUE_REPLICAS_BADLY_DISTRIBUTED
init|=
literal|3
decl_stmt|;
comment|/** The queue for corrupt blocks: {@value} */
DECL|field|QUEUE_WITH_CORRUPT_BLOCKS
specifier|static
specifier|final
name|int
name|QUEUE_WITH_CORRUPT_BLOCKS
init|=
literal|4
decl_stmt|;
comment|/** the queues themselves */
DECL|field|priorityQueues
specifier|private
specifier|final
name|List
argument_list|<
name|LightWeightLinkedSet
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|priorityQueues
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|LEVEL
argument_list|)
decl_stmt|;
comment|/** The number of corrupt blocks with replication factor 1 */
DECL|field|corruptReplOneBlocks
specifier|private
name|int
name|corruptReplOneBlocks
init|=
literal|0
decl_stmt|;
comment|/** Keep timestamp when a block is put into the queue. */
DECL|field|timestampsMap
specifier|private
specifier|final
name|Map
argument_list|<
name|BlockInfo
argument_list|,
name|Long
argument_list|>
name|timestampsMap
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|BlockInfo
argument_list|,
name|Long
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Create an object. */
DECL|method|UnderReplicatedBlocks ()
name|UnderReplicatedBlocks
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|priorityQueues
operator|.
name|add
argument_list|(
operator|new
name|LightWeightLinkedSet
argument_list|<
name|BlockInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Empty the queues and timestamps.    */
DECL|method|clear ()
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|corruptReplOneBlocks
operator|=
literal|0
expr_stmt|;
name|timestampsMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/** Return the total number of under replication blocks */
DECL|method|size ()
specifier|synchronized
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/** Return the number of under replication blocks excluding corrupt blocks */
DECL|method|getUnderReplicatedBlockCount ()
specifier|synchronized
name|int
name|getUnderReplicatedBlockCount
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|QUEUE_WITH_CORRUPT_BLOCKS
condition|)
block|{
name|size
operator|+=
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
comment|/**    * Return the smallest timestamp of the under-replicated/corrupt blocks.    * If there are no under-replicated or corrupt blocks, return 0.    */
DECL|method|getTimeOfTheOldestBlockToBeReplicated ()
name|long
name|getTimeOfTheOldestBlockToBeReplicated
parameter_list|()
block|{
synchronized|synchronized
init|(
name|timestampsMap
init|)
block|{
if|if
condition|(
name|timestampsMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// Since we are using LinkedHashMap, the first value is the smallest.
return|return
name|timestampsMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
comment|/** Return the number of corrupt blocks */
DECL|method|getCorruptBlockSize ()
specifier|synchronized
name|int
name|getCorruptBlockSize
parameter_list|()
block|{
return|return
name|priorityQueues
operator|.
name|get
argument_list|(
name|QUEUE_WITH_CORRUPT_BLOCKS
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Return the number of corrupt blocks with replication factor 1 */
DECL|method|getCorruptReplOneBlockSize ()
specifier|synchronized
name|int
name|getCorruptReplOneBlockSize
parameter_list|()
block|{
return|return
name|corruptReplOneBlocks
return|;
block|}
comment|/** Check if a block is in the neededReplication queue */
DECL|method|contains (BlockInfo block)
specifier|synchronized
name|boolean
name|contains
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
for|for
control|(
name|LightWeightLinkedSet
argument_list|<
name|BlockInfo
argument_list|>
name|set
range|:
name|priorityQueues
control|)
block|{
if|if
condition|(
name|set
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Return the priority of a block    * @param curReplicas current number of replicas of the block    * @param expectedReplicas expected number of replicas of the block    * @return the priority for the blocks, between 0 and ({@link #LEVEL}-1)    */
DECL|method|getPriority (int curReplicas, int decommissionedReplicas, int expectedReplicas)
specifier|private
name|int
name|getPriority
parameter_list|(
name|int
name|curReplicas
parameter_list|,
name|int
name|decommissionedReplicas
parameter_list|,
name|int
name|expectedReplicas
parameter_list|)
block|{
assert|assert
name|curReplicas
operator|>=
literal|0
operator|:
literal|"Negative replicas!"
assert|;
if|if
condition|(
name|curReplicas
operator|>=
name|expectedReplicas
condition|)
block|{
comment|// Block has enough copies, but not enough racks
return|return
name|QUEUE_REPLICAS_BADLY_DISTRIBUTED
return|;
block|}
elseif|else
if|if
condition|(
name|curReplicas
operator|==
literal|0
condition|)
block|{
comment|// If there are zero non-decommissioned replicas but there are
comment|// some decommissioned replicas, then assign them highest priority
if|if
condition|(
name|decommissionedReplicas
operator|>
literal|0
condition|)
block|{
return|return
name|QUEUE_HIGHEST_PRIORITY
return|;
block|}
comment|//all we have are corrupt blocks
return|return
name|QUEUE_WITH_CORRUPT_BLOCKS
return|;
block|}
elseif|else
if|if
condition|(
name|curReplicas
operator|==
literal|1
condition|)
block|{
comment|//only on replica -risk of loss
comment|// highest priority
return|return
name|QUEUE_HIGHEST_PRIORITY
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|curReplicas
operator|*
literal|3
operator|)
operator|<
name|expectedReplicas
condition|)
block|{
comment|//there is less than a third as many blocks as requested;
comment|//this is considered very under-replicated
return|return
name|QUEUE_VERY_UNDER_REPLICATED
return|;
block|}
else|else
block|{
comment|//add to the normal queue for under replicated blocks
return|return
name|QUEUE_UNDER_REPLICATED
return|;
block|}
block|}
comment|/** add a block to a under replication queue according to its priority    * @param block a under replication block    * @param curReplicas current number of replicas of the block    * @param decomissionedReplicas the number of decommissioned replicas    * @param expectedReplicas expected number of replicas of the block    * @return true if the block was added to a queue.    */
DECL|method|add (BlockInfo block, int curReplicas, int decomissionedReplicas, int expectedReplicas)
specifier|synchronized
name|boolean
name|add
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|curReplicas
parameter_list|,
name|int
name|decomissionedReplicas
parameter_list|,
name|int
name|expectedReplicas
parameter_list|)
block|{
assert|assert
name|curReplicas
operator|>=
literal|0
operator|:
literal|"Negative replicas!"
assert|;
name|int
name|priLevel
init|=
name|getPriority
argument_list|(
name|curReplicas
argument_list|,
name|decomissionedReplicas
argument_list|,
name|expectedReplicas
argument_list|)
decl_stmt|;
if|if
condition|(
name|priorityQueues
operator|.
name|get
argument_list|(
name|priLevel
argument_list|)
operator|.
name|add
argument_list|(
name|block
argument_list|)
condition|)
block|{
if|if
condition|(
name|priLevel
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
operator|&&
name|expectedReplicas
operator|==
literal|1
condition|)
block|{
name|corruptReplOneBlocks
operator|++
expr_stmt|;
block|}
name|NameNode
operator|.
name|blockStateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.UnderReplicationBlock.add: {}"
operator|+
literal|" has only {} replicas and need {} replicas so is added to"
operator|+
literal|" neededReplications at priority level {}"
argument_list|,
name|block
argument_list|,
name|curReplicas
argument_list|,
name|expectedReplicas
argument_list|,
name|priLevel
argument_list|)
expr_stmt|;
name|timestampsMap
operator|.
name|put
argument_list|(
name|block
argument_list|,
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** remove a block from a under replication queue */
DECL|method|remove (BlockInfo block, int oldReplicas, int decommissionedReplicas, int oldExpectedReplicas)
specifier|synchronized
name|boolean
name|remove
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|oldReplicas
parameter_list|,
name|int
name|decommissionedReplicas
parameter_list|,
name|int
name|oldExpectedReplicas
parameter_list|)
block|{
name|int
name|priLevel
init|=
name|getPriority
argument_list|(
name|oldReplicas
argument_list|,
name|decommissionedReplicas
argument_list|,
name|oldExpectedReplicas
argument_list|)
decl_stmt|;
name|boolean
name|removedBlock
init|=
name|remove
argument_list|(
name|block
argument_list|,
name|priLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|priLevel
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
operator|&&
name|oldExpectedReplicas
operator|==
literal|1
operator|&&
name|removedBlock
condition|)
block|{
name|corruptReplOneBlocks
operator|--
expr_stmt|;
assert|assert
name|corruptReplOneBlocks
operator|>=
literal|0
operator|:
literal|"Number of corrupt blocks with replication factor 1 "
operator|+
literal|"should be non-negative"
assert|;
block|}
return|return
name|removedBlock
return|;
block|}
comment|/**    * Remove a block from the under replication queues.    *    * The priLevel parameter is a hint of which queue to query    * first: if negative or&gt;= {@link #LEVEL} this shortcutting    * is not attmpted.    *    * If the block is not found in the nominated queue, an attempt is made to    * remove it from all queues.    *    *<i>Warning:</i> This is not a synchronized method.    * @param block block to remove    * @param priLevel expected privilege level    * @return true if the block was found and removed from one of the priority queues    */
DECL|method|remove (BlockInfo block, int priLevel)
name|boolean
name|remove
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|priLevel
parameter_list|)
block|{
if|if
condition|(
name|priLevel
operator|>=
literal|0
operator|&&
name|priLevel
operator|<
name|LEVEL
operator|&&
name|priorityQueues
operator|.
name|get
argument_list|(
name|priLevel
argument_list|)
operator|.
name|remove
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|blockStateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.UnderReplicationBlock.remove: Removing block {}"
operator|+
literal|" from priority queue {}"
argument_list|,
name|block
argument_list|,
name|priLevel
argument_list|)
expr_stmt|;
name|timestampsMap
operator|.
name|remove
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// Try to remove the block from all queues if the block was
comment|// not found in the queue for the given priority level.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|remove
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|blockStateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.UnderReplicationBlock.remove: Removing block"
operator|+
literal|" {} from priority queue {}"
argument_list|,
name|block
argument_list|,
name|priLevel
argument_list|)
expr_stmt|;
name|timestampsMap
operator|.
name|remove
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Recalculate and potentially update the priority level of a block.    *    * If the block priority has changed from before an attempt is made to    * remove it from the block queue. Regardless of whether or not the block    * is in the block queue of (recalculate) priority, an attempt is made    * to add it to that queue. This ensures that the block will be    * in its expected priority queue (and only that queue) by the end of the    * method call.    * @param block a under replicated block    * @param curReplicas current number of replicas of the block    * @param decommissionedReplicas  the number of decommissioned replicas    * @param curExpectedReplicas expected number of replicas of the block    * @param curReplicasDelta the change in the replicate count from before    * @param expectedReplicasDelta the change in the expected replica count from before    */
DECL|method|update (BlockInfo block, int curReplicas, int decommissionedReplicas, int curExpectedReplicas, int curReplicasDelta, int expectedReplicasDelta)
specifier|synchronized
name|void
name|update
parameter_list|(
name|BlockInfo
name|block
parameter_list|,
name|int
name|curReplicas
parameter_list|,
name|int
name|decommissionedReplicas
parameter_list|,
name|int
name|curExpectedReplicas
parameter_list|,
name|int
name|curReplicasDelta
parameter_list|,
name|int
name|expectedReplicasDelta
parameter_list|)
block|{
name|int
name|oldReplicas
init|=
name|curReplicas
operator|-
name|curReplicasDelta
decl_stmt|;
name|int
name|oldExpectedReplicas
init|=
name|curExpectedReplicas
operator|-
name|expectedReplicasDelta
decl_stmt|;
name|int
name|curPri
init|=
name|getPriority
argument_list|(
name|curReplicas
argument_list|,
name|decommissionedReplicas
argument_list|,
name|curExpectedReplicas
argument_list|)
decl_stmt|;
name|int
name|oldPri
init|=
name|getPriority
argument_list|(
name|oldReplicas
argument_list|,
name|decommissionedReplicas
argument_list|,
name|oldExpectedReplicas
argument_list|)
decl_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"UnderReplicationBlocks.update "
operator|+
name|block
operator|+
literal|" curReplicas "
operator|+
name|curReplicas
operator|+
literal|" curExpectedReplicas "
operator|+
name|curExpectedReplicas
operator|+
literal|" oldReplicas "
operator|+
name|oldReplicas
operator|+
literal|" oldExpectedReplicas  "
operator|+
name|oldExpectedReplicas
operator|+
literal|" curPri  "
operator|+
name|curPri
operator|+
literal|" oldPri  "
operator|+
name|oldPri
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldPri
operator|!=
name|curPri
condition|)
block|{
name|remove
argument_list|(
name|block
argument_list|,
name|oldPri
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|priorityQueues
operator|.
name|get
argument_list|(
name|curPri
argument_list|)
operator|.
name|add
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|blockStateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.UnderReplicationBlock.update: {} has only {} "
operator|+
literal|"replicas and needs {} replicas so is added to "
operator|+
literal|"neededReplications at priority level {}"
argument_list|,
name|block
argument_list|,
name|curReplicas
argument_list|,
name|curExpectedReplicas
argument_list|,
name|curPri
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldPri
operator|!=
name|curPri
operator|||
name|expectedReplicasDelta
operator|!=
literal|0
condition|)
block|{
comment|// corruptReplOneBlocks could possibly change
if|if
condition|(
name|curPri
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
operator|&&
name|curExpectedReplicas
operator|==
literal|1
condition|)
block|{
comment|// add a new corrupt block with replication factor 1
name|corruptReplOneBlocks
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldPri
operator|==
name|QUEUE_WITH_CORRUPT_BLOCKS
operator|&&
name|curExpectedReplicas
operator|-
name|expectedReplicasDelta
operator|==
literal|1
condition|)
block|{
comment|// remove an existing corrupt block with replication factor 1
name|corruptReplOneBlocks
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get a list of block lists to be replicated. The index of block lists    * represents its replication priority. Iterates each block list in priority    * order beginning with the highest priority list. Iterators use a bookmark to    * resume where the previous iteration stopped. Returns when the block count    * is met or iteration reaches the end of the lowest priority list, in which    * case bookmarks for each block list are reset to the heads of their    * respective lists.    *    * @param blocksToProcess - number of blocks to fetch from underReplicated    *          blocks.    * @return Return a list of block lists to be replicated. The block list index    *         represents its replication priority.    */
DECL|method|chooseUnderReplicatedBlocks ( int blocksToProcess)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|chooseUnderReplicatedBlocks
parameter_list|(
name|int
name|blocksToProcess
parameter_list|)
block|{
comment|// initialize data structure for the return value
name|List
argument_list|<
name|List
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|blocksToReplicate
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|LEVEL
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|blocksToReplicate
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|BlockInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// There are no blocks to collect.
return|return
name|blocksToReplicate
return|;
block|}
name|int
name|blockCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|priority
init|=
literal|0
init|;
name|priority
operator|<
name|LEVEL
condition|;
name|priority
operator|++
control|)
block|{
comment|// Go through all blocks that need replications with current priority.
name|BlockIterator
name|neededReplicationsIterator
init|=
name|iterator
argument_list|(
name|priority
argument_list|)
decl_stmt|;
comment|// Set the iterator to the first unprocessed block at this priority level.
name|neededReplicationsIterator
operator|.
name|setToBookmark
argument_list|()
expr_stmt|;
name|blocksToProcess
operator|=
name|Math
operator|.
name|min
argument_list|(
name|blocksToProcess
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockCount
operator|==
name|blocksToProcess
condition|)
block|{
break|break;
comment|// break if already expected blocks are obtained
block|}
comment|// Loop through all remaining blocks in the list.
while|while
condition|(
name|blockCount
operator|<
name|blocksToProcess
operator|&&
name|neededReplicationsIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockInfo
name|block
init|=
name|neededReplicationsIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|blocksToReplicate
operator|.
name|get
argument_list|(
name|priority
argument_list|)
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|blockCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|neededReplicationsIterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|neededReplicationsIterator
operator|.
name|getPriority
argument_list|()
operator|==
name|LEVEL
operator|-
literal|1
condition|)
block|{
comment|// Reset all priorities' bookmarks to the beginning because there were
comment|// no recently added blocks in any list.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|resetBookmark
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|blocksToReplicate
return|;
block|}
comment|/** returns an iterator of all blocks in a given priority queue */
DECL|method|iterator (int level)
specifier|synchronized
name|BlockIterator
name|iterator
parameter_list|(
name|int
name|level
parameter_list|)
block|{
return|return
operator|new
name|BlockIterator
argument_list|(
name|level
argument_list|)
return|;
block|}
comment|/** return an iterator of all the under replication blocks */
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
specifier|synchronized
name|BlockIterator
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|BlockIterator
argument_list|()
return|;
block|}
comment|/**    * An iterator over blocks.    */
DECL|class|BlockIterator
class|class
name|BlockIterator
implements|implements
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
block|{
DECL|field|level
specifier|private
name|int
name|level
decl_stmt|;
DECL|field|isIteratorForLevel
specifier|private
name|boolean
name|isIteratorForLevel
init|=
literal|false
decl_stmt|;
DECL|field|iterators
specifier|private
specifier|final
name|List
argument_list|<
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|iterators
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Construct an iterator over all queues.      */
DECL|method|BlockIterator ()
specifier|private
name|BlockIterator
parameter_list|()
block|{
name|level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|iterators
operator|.
name|add
argument_list|(
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Constrict an iterator for a single queue level      * @param l the priority level to iterate over      */
DECL|method|BlockIterator (int l)
specifier|private
name|BlockIterator
parameter_list|(
name|int
name|l
parameter_list|)
block|{
name|level
operator|=
name|l
expr_stmt|;
name|isIteratorForLevel
operator|=
literal|true
expr_stmt|;
name|iterators
operator|.
name|add
argument_list|(
name|priorityQueues
operator|.
name|get
argument_list|(
name|level
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|update ()
specifier|private
name|void
name|update
parameter_list|()
block|{
if|if
condition|(
name|isIteratorForLevel
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|level
operator|<
name|LEVEL
operator|-
literal|1
operator|&&
operator|!
name|iterators
operator|.
name|get
argument_list|(
name|level
argument_list|)
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|level
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|BlockInfo
name|next
parameter_list|()
block|{
if|if
condition|(
name|isIteratorForLevel
condition|)
block|{
return|return
name|iterators
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|next
argument_list|()
return|;
block|}
name|update
argument_list|()
expr_stmt|;
return|return
name|iterators
operator|.
name|get
argument_list|(
name|level
argument_list|)
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|isIteratorForLevel
condition|)
block|{
return|return
name|iterators
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|hasNext
argument_list|()
return|;
block|}
name|update
argument_list|()
expr_stmt|;
return|return
name|iterators
operator|.
name|get
argument_list|(
name|level
argument_list|)
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|isIteratorForLevel
condition|)
block|{
name|iterators
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|iterators
operator|.
name|get
argument_list|(
name|level
argument_list|)
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getPriority ()
name|int
name|getPriority
parameter_list|()
block|{
return|return
name|level
return|;
block|}
comment|/**      * Sets iterator(s) to bookmarked elements.      */
DECL|method|setToBookmark ()
specifier|private
specifier|synchronized
name|void
name|setToBookmark
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|isIteratorForLevel
condition|)
block|{
name|this
operator|.
name|iterators
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|priorityQueues
operator|.
name|get
argument_list|(
name|this
operator|.
name|level
argument_list|)
operator|.
name|getBookmark
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LEVEL
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|iterators
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|priorityQueues
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getBookmark
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

