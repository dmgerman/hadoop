begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|net
operator|.
name|DFSTopologyNodeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|CachedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockECReconstructionCommand
operator|.
name|BlockECReconstructionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|VolumeFailureSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|EnumCounters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LightWeightHashSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|IntrusiveCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class extends the DatanodeInfo class with ephemeral information (eg  * health, capacity, what blocks are associated with the Datanode) that is  * private to the Namenode, ie this class is not exposed to clients.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|DatanodeDescriptor
specifier|public
class|class
name|DatanodeDescriptor
extends|extends
name|DatanodeInfo
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DatanodeDescriptor
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|EMPTY_ARRAY
specifier|public
specifier|static
specifier|final
name|DatanodeDescriptor
index|[]
name|EMPTY_ARRAY
init|=
block|{}
decl_stmt|;
DECL|field|BLOCKS_SCHEDULED_ROLL_INTERVAL
specifier|private
specifier|static
specifier|final
name|int
name|BLOCKS_SCHEDULED_ROLL_INTERVAL
init|=
literal|600
operator|*
literal|1000
decl_stmt|;
comment|//10min
comment|/** Block and targets pair */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|BlockTargetPair
specifier|public
specifier|static
class|class
name|BlockTargetPair
block|{
DECL|field|block
specifier|public
specifier|final
name|Block
name|block
decl_stmt|;
DECL|field|targets
specifier|public
specifier|final
name|DatanodeStorageInfo
index|[]
name|targets
decl_stmt|;
DECL|method|BlockTargetPair (Block block, DatanodeStorageInfo[] targets)
name|BlockTargetPair
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|this
operator|.
name|targets
operator|=
name|targets
expr_stmt|;
block|}
block|}
comment|/** A BlockTargetPair queue. */
DECL|class|BlockQueue
specifier|private
specifier|static
class|class
name|BlockQueue
parameter_list|<
name|E
parameter_list|>
block|{
DECL|field|blockq
specifier|private
specifier|final
name|Queue
argument_list|<
name|E
argument_list|>
name|blockq
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Size of the queue */
DECL|method|size ()
specifier|synchronized
name|int
name|size
parameter_list|()
block|{
return|return
name|blockq
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Enqueue */
DECL|method|offer (E e)
specifier|synchronized
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|blockq
operator|.
name|offer
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/** Dequeue */
DECL|method|poll (int numBlocks)
specifier|synchronized
name|List
argument_list|<
name|E
argument_list|>
name|poll
parameter_list|(
name|int
name|numBlocks
parameter_list|)
block|{
if|if
condition|(
name|numBlocks
operator|<=
literal|0
operator|||
name|blockq
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|E
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
operator|!
name|blockq
operator|.
name|isEmpty
argument_list|()
operator|&&
name|numBlocks
operator|>
literal|0
condition|;
name|numBlocks
operator|--
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|blockq
operator|.
name|poll
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|/**      * Returns<tt>true</tt> if the queue contains the specified element.      */
DECL|method|contains (E e)
specifier|synchronized
name|boolean
name|contains
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|blockq
operator|.
name|contains
argument_list|(
name|e
argument_list|)
return|;
block|}
DECL|method|clear ()
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
name|blockq
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * A list of CachedBlock objects on this datanode.    */
DECL|class|CachedBlocksList
specifier|public
specifier|static
class|class
name|CachedBlocksList
extends|extends
name|IntrusiveCollection
argument_list|<
name|CachedBlock
argument_list|>
block|{
DECL|enum|Type
specifier|public
enum|enum
name|Type
block|{
DECL|enumConstant|PENDING_CACHED
name|PENDING_CACHED
block|,
DECL|enumConstant|CACHED
name|CACHED
block|,
DECL|enumConstant|PENDING_UNCACHED
name|PENDING_UNCACHED
block|}
DECL|field|datanode
specifier|private
specifier|final
name|DatanodeDescriptor
name|datanode
decl_stmt|;
DECL|field|type
specifier|private
specifier|final
name|Type
name|type
decl_stmt|;
DECL|method|CachedBlocksList (DatanodeDescriptor datanode, Type type)
name|CachedBlocksList
parameter_list|(
name|DatanodeDescriptor
name|datanode
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
DECL|method|getDatanode ()
specifier|public
name|DatanodeDescriptor
name|getDatanode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
DECL|method|getType ()
specifier|public
name|Type
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
block|}
comment|// Stores status of decommissioning.
comment|// If node is not decommissioning, do not use this object for anything.
DECL|field|leavingServiceStatus
specifier|private
specifier|final
name|LeavingServiceStatus
name|leavingServiceStatus
init|=
operator|new
name|LeavingServiceStatus
argument_list|()
decl_stmt|;
DECL|field|storageMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|DatanodeStorageInfo
argument_list|>
name|storageMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * The blocks which we want to cache on this DataNode.    */
DECL|field|pendingCached
specifier|private
specifier|final
name|CachedBlocksList
name|pendingCached
init|=
operator|new
name|CachedBlocksList
argument_list|(
name|this
argument_list|,
name|CachedBlocksList
operator|.
name|Type
operator|.
name|PENDING_CACHED
argument_list|)
decl_stmt|;
comment|/**    * The blocks which we know are cached on this datanode.    * This list is updated by periodic cache reports.    */
DECL|field|cached
specifier|private
specifier|final
name|CachedBlocksList
name|cached
init|=
operator|new
name|CachedBlocksList
argument_list|(
name|this
argument_list|,
name|CachedBlocksList
operator|.
name|Type
operator|.
name|CACHED
argument_list|)
decl_stmt|;
comment|/**    * The blocks which we want to uncache on this DataNode.    */
DECL|field|pendingUncached
specifier|private
specifier|final
name|CachedBlocksList
name|pendingUncached
init|=
operator|new
name|CachedBlocksList
argument_list|(
name|this
argument_list|,
name|CachedBlocksList
operator|.
name|Type
operator|.
name|PENDING_UNCACHED
argument_list|)
decl_stmt|;
comment|/**    * The time when the last batch of caching directives was sent, in    * monotonic milliseconds.    */
DECL|field|lastCachingDirectiveSentTimeMs
specifier|private
name|long
name|lastCachingDirectiveSentTimeMs
decl_stmt|;
comment|// isAlive == heartbeats.contains(this)
comment|// This is an optimization, because contains takes O(n) time on Arraylist
DECL|field|isAlive
specifier|private
name|boolean
name|isAlive
init|=
literal|false
decl_stmt|;
DECL|field|needKeyUpdate
specifier|private
name|boolean
name|needKeyUpdate
init|=
literal|false
decl_stmt|;
DECL|field|forceRegistration
specifier|private
name|boolean
name|forceRegistration
init|=
literal|false
decl_stmt|;
comment|// A system administrator can tune the balancer bandwidth parameter
comment|// (dfs.datanode.balance.bandwidthPerSec) dynamically by calling
comment|// "dfsadmin -setBalanacerBandwidth<newbandwidth>", at which point the
comment|// following 'bandwidth' variable gets updated with the new value for each
comment|// node. Once the heartbeat command is issued to update the value on the
comment|// specified datanode, this value will be set back to 0.
DECL|field|bandwidth
specifier|private
name|long
name|bandwidth
decl_stmt|;
comment|/** A queue of blocks to be replicated by this datanode */
DECL|field|replicateBlocks
specifier|private
specifier|final
name|BlockQueue
argument_list|<
name|BlockTargetPair
argument_list|>
name|replicateBlocks
init|=
operator|new
name|BlockQueue
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** A queue of blocks to be erasure coded by this datanode */
DECL|field|erasurecodeBlocks
specifier|private
specifier|final
name|BlockQueue
argument_list|<
name|BlockECReconstructionInfo
argument_list|>
name|erasurecodeBlocks
init|=
operator|new
name|BlockQueue
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** A queue of blocks to be recovered by this datanode */
DECL|field|recoverBlocks
specifier|private
specifier|final
name|BlockQueue
argument_list|<
name|BlockInfo
argument_list|>
name|recoverBlocks
init|=
operator|new
name|BlockQueue
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** A set of blocks to be invalidated by this datanode */
DECL|field|invalidateBlocks
specifier|private
specifier|final
name|LightWeightHashSet
argument_list|<
name|Block
argument_list|>
name|invalidateBlocks
init|=
operator|new
name|LightWeightHashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/* Variables for maintaining number of blocks scheduled to be written to    * this storage. This count is approximate and might be slightly bigger    * in case of errors (e.g. datanode does not report if an error occurs    * while writing the block).    */
DECL|field|currApproxBlocksScheduled
specifier|private
name|EnumCounters
argument_list|<
name|StorageType
argument_list|>
name|currApproxBlocksScheduled
init|=
operator|new
name|EnumCounters
argument_list|<>
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|prevApproxBlocksScheduled
specifier|private
name|EnumCounters
argument_list|<
name|StorageType
argument_list|>
name|prevApproxBlocksScheduled
init|=
operator|new
name|EnumCounters
argument_list|<>
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|lastBlocksScheduledRollTime
specifier|private
name|long
name|lastBlocksScheduledRollTime
init|=
literal|0
decl_stmt|;
DECL|field|volumeFailures
specifier|private
name|int
name|volumeFailures
init|=
literal|0
decl_stmt|;
DECL|field|volumeFailureSummary
specifier|private
name|VolumeFailureSummary
name|volumeFailureSummary
init|=
literal|null
decl_stmt|;
comment|/**     * When set to true, the node is not in include list and is not allowed    * to communicate with the namenode    */
DECL|field|disallowed
specifier|private
name|boolean
name|disallowed
init|=
literal|false
decl_stmt|;
comment|// The number of replication work pending before targets are determined
DECL|field|pendingReplicationWithoutTargets
specifier|private
name|int
name|pendingReplicationWithoutTargets
init|=
literal|0
decl_stmt|;
comment|// HB processing can use it to tell if it is the first HB since DN restarted
DECL|field|heartbeatedSinceRegistration
specifier|private
name|boolean
name|heartbeatedSinceRegistration
init|=
literal|false
decl_stmt|;
comment|/**    * DatanodeDescriptor constructor    * @param nodeID id of the data node    */
DECL|method|DatanodeDescriptor (DatanodeID nodeID)
specifier|public
name|DatanodeDescriptor
parameter_list|(
name|DatanodeID
name|nodeID
parameter_list|)
block|{
name|super
argument_list|(
name|nodeID
argument_list|)
expr_stmt|;
name|updateHeartbeatState
argument_list|(
name|StorageReport
operator|.
name|EMPTY_ARRAY
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * DatanodeDescriptor constructor    * @param nodeID id of the data node    * @param networkLocation location of the data node in network    */
DECL|method|DatanodeDescriptor (DatanodeID nodeID, String networkLocation)
specifier|public
name|DatanodeDescriptor
parameter_list|(
name|DatanodeID
name|nodeID
parameter_list|,
name|String
name|networkLocation
parameter_list|)
block|{
name|super
argument_list|(
name|nodeID
argument_list|,
name|networkLocation
argument_list|)
expr_stmt|;
name|updateHeartbeatState
argument_list|(
name|StorageReport
operator|.
name|EMPTY_ARRAY
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|getPendingCached ()
specifier|public
name|CachedBlocksList
name|getPendingCached
parameter_list|()
block|{
return|return
name|pendingCached
return|;
block|}
DECL|method|getCached ()
specifier|public
name|CachedBlocksList
name|getCached
parameter_list|()
block|{
return|return
name|cached
return|;
block|}
DECL|method|getPendingUncached ()
specifier|public
name|CachedBlocksList
name|getPendingUncached
parameter_list|()
block|{
return|return
name|pendingUncached
return|;
block|}
DECL|method|isAlive ()
specifier|public
name|boolean
name|isAlive
parameter_list|()
block|{
return|return
name|isAlive
return|;
block|}
DECL|method|setAlive (boolean isAlive)
specifier|public
name|void
name|setAlive
parameter_list|(
name|boolean
name|isAlive
parameter_list|)
block|{
name|this
operator|.
name|isAlive
operator|=
name|isAlive
expr_stmt|;
block|}
DECL|method|needKeyUpdate ()
specifier|public
specifier|synchronized
name|boolean
name|needKeyUpdate
parameter_list|()
block|{
return|return
name|needKeyUpdate
return|;
block|}
DECL|method|setNeedKeyUpdate (boolean needKeyUpdate)
specifier|public
specifier|synchronized
name|void
name|setNeedKeyUpdate
parameter_list|(
name|boolean
name|needKeyUpdate
parameter_list|)
block|{
name|this
operator|.
name|needKeyUpdate
operator|=
name|needKeyUpdate
expr_stmt|;
block|}
DECL|method|getLeavingServiceStatus ()
specifier|public
name|LeavingServiceStatus
name|getLeavingServiceStatus
parameter_list|()
block|{
return|return
name|leavingServiceStatus
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|isHeartbeatedSinceRegistration ()
specifier|public
name|boolean
name|isHeartbeatedSinceRegistration
parameter_list|()
block|{
return|return
name|heartbeatedSinceRegistration
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStorageInfo (String storageID)
specifier|public
name|DatanodeStorageInfo
name|getStorageInfo
parameter_list|(
name|String
name|storageID
parameter_list|)
block|{
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
return|return
name|storageMap
operator|.
name|get
argument_list|(
name|storageID
argument_list|)
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStorageInfos ()
specifier|public
name|DatanodeStorageInfo
index|[]
name|getStorageInfos
parameter_list|()
block|{
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
specifier|final
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|storages
init|=
name|storageMap
operator|.
name|values
argument_list|()
decl_stmt|;
return|return
name|storages
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeStorageInfo
index|[
name|storages
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
DECL|method|getStorageTypes ()
specifier|public
name|EnumSet
argument_list|<
name|StorageType
argument_list|>
name|getStorageTypes
parameter_list|()
block|{
name|EnumSet
argument_list|<
name|StorageType
argument_list|>
name|storageTypes
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|StorageType
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|dsi
range|:
name|getStorageInfos
argument_list|()
control|)
block|{
name|storageTypes
operator|.
name|add
argument_list|(
name|dsi
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|storageTypes
return|;
block|}
DECL|method|getStorageReports ()
specifier|public
name|StorageReport
index|[]
name|getStorageReports
parameter_list|()
block|{
specifier|final
name|DatanodeStorageInfo
index|[]
name|infos
init|=
name|getStorageInfos
argument_list|()
decl_stmt|;
specifier|final
name|StorageReport
index|[]
name|reports
init|=
operator|new
name|StorageReport
index|[
name|infos
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|infos
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|reports
index|[
name|i
index|]
operator|=
name|infos
index|[
name|i
index|]
operator|.
name|toStorageReport
argument_list|()
expr_stmt|;
block|}
return|return
name|reports
return|;
block|}
DECL|method|hasStaleStorages ()
name|boolean
name|hasStaleStorages
parameter_list|()
block|{
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|storageMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|storage
operator|.
name|areBlockContentsStale
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|method|resetBlocks ()
specifier|public
name|void
name|resetBlocks
parameter_list|()
block|{
name|setCapacity
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setRemaining
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setBlockPoolUsed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setDfsUsed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setXceiverCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|invalidateBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|volumeFailures
operator|=
literal|0
expr_stmt|;
comment|// pendingCached, cached, and pendingUncached are protected by the
comment|// FSN lock.
name|this
operator|.
name|pendingCached
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|cached
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|pendingUncached
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|clearBlockQueues ()
specifier|public
name|void
name|clearBlockQueues
parameter_list|()
block|{
synchronized|synchronized
init|(
name|invalidateBlocks
init|)
block|{
name|this
operator|.
name|invalidateBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|recoverBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|replicateBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|erasurecodeBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// pendingCached, cached, and pendingUncached are protected by the
comment|// FSN lock.
name|this
operator|.
name|pendingCached
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|cached
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|pendingUncached
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|numBlocks ()
specifier|public
name|int
name|numBlocks
parameter_list|()
block|{
name|int
name|blocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|entry
range|:
name|getStorageInfos
argument_list|()
control|)
block|{
name|blocks
operator|+=
name|entry
operator|.
name|numBlocks
argument_list|()
expr_stmt|;
block|}
return|return
name|blocks
return|;
block|}
comment|/**    * Updates stats from datanode heartbeat.    */
DECL|method|updateHeartbeat (StorageReport[] reports, long cacheCapacity, long cacheUsed, int xceiverCount, int volFailures, VolumeFailureSummary volumeFailureSummary)
specifier|public
name|void
name|updateHeartbeat
parameter_list|(
name|StorageReport
index|[]
name|reports
parameter_list|,
name|long
name|cacheCapacity
parameter_list|,
name|long
name|cacheUsed
parameter_list|,
name|int
name|xceiverCount
parameter_list|,
name|int
name|volFailures
parameter_list|,
name|VolumeFailureSummary
name|volumeFailureSummary
parameter_list|)
block|{
name|updateHeartbeatState
argument_list|(
name|reports
argument_list|,
name|cacheCapacity
argument_list|,
name|cacheUsed
argument_list|,
name|xceiverCount
argument_list|,
name|volFailures
argument_list|,
name|volumeFailureSummary
argument_list|)
expr_stmt|;
name|heartbeatedSinceRegistration
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * process datanode heartbeat or stats initialization.    */
DECL|method|updateHeartbeatState (StorageReport[] reports, long cacheCapacity, long cacheUsed, int xceiverCount, int volFailures, VolumeFailureSummary volumeFailureSummary)
specifier|public
name|void
name|updateHeartbeatState
parameter_list|(
name|StorageReport
index|[]
name|reports
parameter_list|,
name|long
name|cacheCapacity
parameter_list|,
name|long
name|cacheUsed
parameter_list|,
name|int
name|xceiverCount
parameter_list|,
name|int
name|volFailures
parameter_list|,
name|VolumeFailureSummary
name|volumeFailureSummary
parameter_list|)
block|{
name|long
name|totalCapacity
init|=
literal|0
decl_stmt|;
name|long
name|totalRemaining
init|=
literal|0
decl_stmt|;
name|long
name|totalBlockPoolUsed
init|=
literal|0
decl_stmt|;
name|long
name|totalDfsUsed
init|=
literal|0
decl_stmt|;
name|long
name|totalNonDfsUsed
init|=
literal|0
decl_stmt|;
name|Set
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|failedStorageInfos
init|=
literal|null
decl_stmt|;
comment|// Decide if we should check for any missing StorageReport and mark it as
comment|// failed. There are different scenarios.
comment|// 1. When DN is running, a storage failed. Given the current DN
comment|//    implementation doesn't add recovered storage back to its storage list
comment|//    until DN restart, we can assume volFailures won't decrease
comment|//    during the current DN registration session.
comment|//    When volumeFailures == this.volumeFailures, it implies there is no
comment|//    state change. No need to check for failed storage. This is an
comment|//    optimization.  Recent versions of the DataNode report a
comment|//    VolumeFailureSummary containing the date/time of the last volume
comment|//    failure.  If that's available, then we check that instead for greater
comment|//    accuracy.
comment|// 2. After DN restarts, volFailures might not increase and it is possible
comment|//    we still have new failed storage. For example, admins reduce
comment|//    available storages in configuration. Another corner case
comment|//    is the failed volumes might change after restart; a) there
comment|//    is one good storage A, one restored good storage B, so there is
comment|//    one element in storageReports and that is A. b) A failed. c) Before
comment|//    DN sends HB to NN to indicate A has failed, DN restarts. d) After DN
comment|//    restarts, storageReports has one element which is B.
specifier|final
name|boolean
name|checkFailedStorages
decl_stmt|;
if|if
condition|(
name|volumeFailureSummary
operator|!=
literal|null
operator|&&
name|this
operator|.
name|volumeFailureSummary
operator|!=
literal|null
condition|)
block|{
name|checkFailedStorages
operator|=
name|volumeFailureSummary
operator|.
name|getLastVolumeFailureDate
argument_list|()
operator|>
name|this
operator|.
name|volumeFailureSummary
operator|.
name|getLastVolumeFailureDate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|checkFailedStorages
operator|=
operator|(
name|volFailures
operator|>
name|this
operator|.
name|volumeFailures
operator|)
operator|||
operator|!
name|heartbeatedSinceRegistration
expr_stmt|;
block|}
if|if
condition|(
name|checkFailedStorages
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|volumeFailures
operator|!=
name|volFailures
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of failed storages changes from {} to {}"
argument_list|,
name|this
operator|.
name|volumeFailures
argument_list|,
name|volFailures
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
name|failedStorageInfos
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|storageMap
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|setCacheCapacity
argument_list|(
name|cacheCapacity
argument_list|)
expr_stmt|;
name|setCacheUsed
argument_list|(
name|cacheUsed
argument_list|)
expr_stmt|;
name|setXceiverCount
argument_list|(
name|xceiverCount
argument_list|)
expr_stmt|;
name|setLastUpdate
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|setLastUpdateMonotonic
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|volumeFailures
operator|=
name|volFailures
expr_stmt|;
name|this
operator|.
name|volumeFailureSummary
operator|=
name|volumeFailureSummary
expr_stmt|;
for|for
control|(
name|StorageReport
name|report
range|:
name|reports
control|)
block|{
name|DatanodeStorageInfo
name|storage
init|=
name|updateStorage
argument_list|(
name|report
operator|.
name|getStorage
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkFailedStorages
condition|)
block|{
name|failedStorageInfos
operator|.
name|remove
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
name|storage
operator|.
name|receivedHeartbeat
argument_list|(
name|report
argument_list|)
expr_stmt|;
name|totalCapacity
operator|+=
name|report
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
name|totalRemaining
operator|+=
name|report
operator|.
name|getRemaining
argument_list|()
expr_stmt|;
name|totalBlockPoolUsed
operator|+=
name|report
operator|.
name|getBlockPoolUsed
argument_list|()
expr_stmt|;
name|totalDfsUsed
operator|+=
name|report
operator|.
name|getDfsUsed
argument_list|()
expr_stmt|;
name|totalNonDfsUsed
operator|+=
name|report
operator|.
name|getNonDfsUsed
argument_list|()
expr_stmt|;
block|}
name|rollBlocksScheduled
argument_list|(
name|getLastUpdateMonotonic
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update total metrics for the node.
name|setCapacity
argument_list|(
name|totalCapacity
argument_list|)
expr_stmt|;
name|setRemaining
argument_list|(
name|totalRemaining
argument_list|)
expr_stmt|;
name|setBlockPoolUsed
argument_list|(
name|totalBlockPoolUsed
argument_list|)
expr_stmt|;
name|setDfsUsed
argument_list|(
name|totalDfsUsed
argument_list|)
expr_stmt|;
name|setNonDfsUsed
argument_list|(
name|totalNonDfsUsed
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkFailedStorages
condition|)
block|{
name|updateFailedStorage
argument_list|(
name|failedStorageInfos
argument_list|)
expr_stmt|;
block|}
name|long
name|storageMapSize
decl_stmt|;
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
name|storageMapSize
operator|=
name|storageMap
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|storageMapSize
operator|!=
name|reports
operator|.
name|length
condition|)
block|{
name|pruneStorageMap
argument_list|(
name|reports
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove stale storages from storageMap. We must not remove any storages    * as long as they have associated block replicas.    */
DECL|method|pruneStorageMap (final StorageReport[] reports)
specifier|private
name|void
name|pruneStorageMap
parameter_list|(
specifier|final
name|StorageReport
index|[]
name|reports
parameter_list|)
block|{
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Number of storages reported in heartbeat={};"
operator|+
literal|" Number of storages in storageMap={}"
argument_list|,
name|reports
operator|.
name|length
argument_list|,
name|storageMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|DatanodeStorageInfo
argument_list|>
name|excessStorages
decl_stmt|;
comment|// Init excessStorages with all known storages.
name|excessStorages
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|storageMap
argument_list|)
expr_stmt|;
comment|// Remove storages that the DN reported in the heartbeat.
for|for
control|(
specifier|final
name|StorageReport
name|report
range|:
name|reports
control|)
block|{
name|excessStorages
operator|.
name|remove
argument_list|(
name|report
operator|.
name|getStorage
argument_list|()
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// For each remaining storage, remove it if there are no associated
comment|// blocks.
for|for
control|(
specifier|final
name|DatanodeStorageInfo
name|storageInfo
range|:
name|excessStorages
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|storageInfo
operator|.
name|numBlocks
argument_list|()
operator|==
literal|0
condition|)
block|{
name|DatanodeStorageInfo
name|info
init|=
name|storageMap
operator|.
name|remove
argument_list|(
name|storageInfo
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasStorageType
argument_list|(
name|info
operator|.
name|getStorageType
argument_list|()
argument_list|)
condition|)
block|{
comment|// we removed a storage, and as result there is no more such storage
comment|// type, inform the parent about this.
if|if
condition|(
name|getParent
argument_list|()
operator|instanceof
name|DFSTopologyNodeImpl
condition|)
block|{
operator|(
operator|(
name|DFSTopologyNodeImpl
operator|)
name|getParent
argument_list|()
operator|)
operator|.
name|childRemoveStorage
argument_list|(
name|getName
argument_list|()
argument_list|,
name|info
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed storage {} from DataNode {}"
argument_list|,
name|storageInfo
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This can occur until all block reports are received.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deferring removal of stale storage {} with {} blocks"
argument_list|,
name|storageInfo
argument_list|,
name|storageInfo
operator|.
name|numBlocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|updateFailedStorage ( Set<DatanodeStorageInfo> failedStorageInfos)
specifier|private
name|void
name|updateFailedStorage
parameter_list|(
name|Set
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|failedStorageInfos
parameter_list|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|storageInfo
range|:
name|failedStorageInfos
control|)
block|{
if|if
condition|(
name|storageInfo
operator|.
name|getState
argument_list|()
operator|!=
name|DatanodeStorage
operator|.
name|State
operator|.
name|FAILED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} failed."
argument_list|,
name|storageInfo
argument_list|)
expr_stmt|;
name|storageInfo
operator|.
name|setState
argument_list|(
name|DatanodeStorage
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|BlockIterator
specifier|private
specifier|static
class|class
name|BlockIterator
implements|implements
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
block|{
DECL|field|index
specifier|private
name|int
name|index
init|=
literal|0
decl_stmt|;
DECL|field|iterators
specifier|private
specifier|final
name|List
argument_list|<
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|iterators
decl_stmt|;
DECL|method|BlockIterator (final int startBlock, final DatanodeStorageInfo... storages)
specifier|private
name|BlockIterator
parameter_list|(
specifier|final
name|int
name|startBlock
parameter_list|,
specifier|final
name|DatanodeStorageInfo
modifier|...
name|storages
parameter_list|)
block|{
if|if
condition|(
name|startBlock
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal value startBlock = "
operator|+
name|startBlock
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|iterators
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|s
init|=
name|startBlock
decl_stmt|;
name|int
name|sumBlocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|e
range|:
name|storages
control|)
block|{
name|int
name|numBlocks
init|=
name|e
operator|.
name|numBlocks
argument_list|()
decl_stmt|;
name|sumBlocks
operator|+=
name|numBlocks
expr_stmt|;
if|if
condition|(
name|sumBlocks
operator|<=
name|startBlock
condition|)
block|{
name|s
operator|-=
name|numBlocks
expr_stmt|;
block|}
else|else
block|{
name|iterators
operator|.
name|add
argument_list|(
name|e
operator|.
name|getBlockIterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|iterators
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|iterators
argument_list|)
expr_stmt|;
comment|// skip to the storage containing startBlock
for|for
control|(
init|;
name|s
operator|>
literal|0
operator|&&
name|hasNext
argument_list|()
condition|;
name|s
operator|--
control|)
block|{
name|next
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|update
argument_list|()
expr_stmt|;
return|return
name|index
operator|<
name|iterators
operator|.
name|size
argument_list|()
operator|&&
name|iterators
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|BlockInfo
name|next
parameter_list|()
block|{
name|update
argument_list|()
expr_stmt|;
return|return
name|iterators
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Remove unsupported."
argument_list|)
throw|;
block|}
DECL|method|update ()
specifier|private
name|void
name|update
parameter_list|()
block|{
while|while
condition|(
name|index
operator|<
name|iterators
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|&&
operator|!
name|iterators
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
block|}
DECL|method|getBlockIterator ()
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|getBlockIterator
parameter_list|()
block|{
return|return
name|getBlockIterator
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Get iterator, which starts iterating from the specified block.    */
DECL|method|getBlockIterator (final int startBlock)
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|getBlockIterator
parameter_list|(
specifier|final
name|int
name|startBlock
parameter_list|)
block|{
return|return
operator|new
name|BlockIterator
argument_list|(
name|startBlock
argument_list|,
name|getStorageInfos
argument_list|()
argument_list|)
return|;
block|}
DECL|method|incrementPendingReplicationWithoutTargets ()
name|void
name|incrementPendingReplicationWithoutTargets
parameter_list|()
block|{
name|pendingReplicationWithoutTargets
operator|++
expr_stmt|;
block|}
DECL|method|decrementPendingReplicationWithoutTargets ()
name|void
name|decrementPendingReplicationWithoutTargets
parameter_list|()
block|{
name|pendingReplicationWithoutTargets
operator|--
expr_stmt|;
block|}
comment|/**    * Store block replication work.    */
DECL|method|addBlockToBeReplicated (Block block, DatanodeStorageInfo[] targets)
name|void
name|addBlockToBeReplicated
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
block|{
assert|assert
operator|(
name|block
operator|!=
literal|null
operator|&&
name|targets
operator|!=
literal|null
operator|&&
name|targets
operator|.
name|length
operator|>
literal|0
operator|)
assert|;
name|replicateBlocks
operator|.
name|offer
argument_list|(
operator|new
name|BlockTargetPair
argument_list|(
name|block
argument_list|,
name|targets
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Store block erasure coding work.    */
DECL|method|addBlockToBeErasureCoded (ExtendedBlock block, DatanodeDescriptor[] sources, DatanodeStorageInfo[] targets, byte[] liveBlockIndices, ErasureCodingPolicy ecPolicy)
name|void
name|addBlockToBeErasureCoded
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|DatanodeDescriptor
index|[]
name|sources
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|,
name|byte
index|[]
name|liveBlockIndices
parameter_list|,
name|ErasureCodingPolicy
name|ecPolicy
parameter_list|)
block|{
assert|assert
operator|(
name|block
operator|!=
literal|null
operator|&&
name|sources
operator|!=
literal|null
operator|&&
name|sources
operator|.
name|length
operator|>
literal|0
operator|)
assert|;
name|BlockECReconstructionInfo
name|task
init|=
operator|new
name|BlockECReconstructionInfo
argument_list|(
name|block
argument_list|,
name|sources
argument_list|,
name|targets
argument_list|,
name|liveBlockIndices
argument_list|,
name|ecPolicy
argument_list|)
decl_stmt|;
name|erasurecodeBlocks
operator|.
name|offer
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|BlockManager
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding block reconstruction task "
operator|+
name|task
operator|+
literal|"to "
operator|+
name|getName
argument_list|()
operator|+
literal|", current queue size is "
operator|+
name|erasurecodeBlocks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Store block recovery work.    */
DECL|method|addBlockToBeRecovered (BlockInfo block)
name|void
name|addBlockToBeRecovered
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
if|if
condition|(
name|recoverBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|// this prevents adding the same block twice to the recovery queue
name|BlockManager
operator|.
name|LOG
operator|.
name|info
argument_list|(
name|block
operator|+
literal|" is already in the recovery queue"
argument_list|)
expr_stmt|;
return|return;
block|}
name|recoverBlocks
operator|.
name|offer
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/**    * Store block invalidation work.    */
DECL|method|addBlocksToBeInvalidated (List<Block> blocklist)
name|void
name|addBlocksToBeInvalidated
parameter_list|(
name|List
argument_list|<
name|Block
argument_list|>
name|blocklist
parameter_list|)
block|{
assert|assert
operator|(
name|blocklist
operator|!=
literal|null
operator|&&
name|blocklist
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
assert|;
synchronized|synchronized
init|(
name|invalidateBlocks
init|)
block|{
for|for
control|(
name|Block
name|blk
range|:
name|blocklist
control|)
block|{
name|invalidateBlocks
operator|.
name|add
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The number of work items that are pending to be replicated.    */
DECL|method|getNumberOfBlocksToBeReplicated ()
name|int
name|getNumberOfBlocksToBeReplicated
parameter_list|()
block|{
return|return
name|pendingReplicationWithoutTargets
operator|+
name|replicateBlocks
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * The number of work items that are pending to be reconstructed.    */
annotation|@
name|VisibleForTesting
DECL|method|getNumberOfBlocksToBeErasureCoded ()
specifier|public
name|int
name|getNumberOfBlocksToBeErasureCoded
parameter_list|()
block|{
return|return
name|erasurecodeBlocks
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getReplicationCommand (int maxTransfers)
specifier|public
name|List
argument_list|<
name|BlockTargetPair
argument_list|>
name|getReplicationCommand
parameter_list|(
name|int
name|maxTransfers
parameter_list|)
block|{
return|return
name|replicateBlocks
operator|.
name|poll
argument_list|(
name|maxTransfers
argument_list|)
return|;
block|}
DECL|method|getErasureCodeCommand ( int maxTransfers)
specifier|public
name|List
argument_list|<
name|BlockECReconstructionInfo
argument_list|>
name|getErasureCodeCommand
parameter_list|(
name|int
name|maxTransfers
parameter_list|)
block|{
return|return
name|erasurecodeBlocks
operator|.
name|poll
argument_list|(
name|maxTransfers
argument_list|)
return|;
block|}
DECL|method|getLeaseRecoveryCommand (int maxTransfers)
specifier|public
name|BlockInfo
index|[]
name|getLeaseRecoveryCommand
parameter_list|(
name|int
name|maxTransfers
parameter_list|)
block|{
name|List
argument_list|<
name|BlockInfo
argument_list|>
name|blocks
init|=
name|recoverBlocks
operator|.
name|poll
argument_list|(
name|maxTransfers
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|blocks
operator|.
name|toArray
argument_list|(
operator|new
name|BlockInfo
index|[
name|blocks
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Remove the specified number of blocks to be invalidated    */
DECL|method|getInvalidateBlocks (int maxblocks)
specifier|public
name|Block
index|[]
name|getInvalidateBlocks
parameter_list|(
name|int
name|maxblocks
parameter_list|)
block|{
synchronized|synchronized
init|(
name|invalidateBlocks
init|)
block|{
name|Block
index|[]
name|deleteList
init|=
name|invalidateBlocks
operator|.
name|pollToArray
argument_list|(
operator|new
name|Block
index|[
name|Math
operator|.
name|min
argument_list|(
name|invalidateBlocks
operator|.
name|size
argument_list|()
argument_list|,
name|maxblocks
argument_list|)
index|]
argument_list|)
decl_stmt|;
return|return
name|deleteList
operator|.
name|length
operator|==
literal|0
condition|?
literal|null
else|:
name|deleteList
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|containsInvalidateBlock (Block block)
specifier|public
name|boolean
name|containsInvalidateBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
synchronized|synchronized
init|(
name|invalidateBlocks
init|)
block|{
return|return
name|invalidateBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
return|;
block|}
block|}
comment|/**    * Find whether the datanode contains good storage of given type to    * place block of size<code>blockSize</code>.    *    *<p>Currently datanode only cares about the storage type, in this    * method, the first storage of given type we see is returned.    *    * @param t requested storage type    * @param blockSize requested block size    */
DECL|method|chooseStorage4Block (StorageType t, long blockSize)
specifier|public
name|DatanodeStorageInfo
name|chooseStorage4Block
parameter_list|(
name|StorageType
name|t
parameter_list|,
name|long
name|blockSize
parameter_list|)
block|{
specifier|final
name|long
name|requiredSize
init|=
name|blockSize
operator|*
name|HdfsServerConstants
operator|.
name|MIN_BLOCKS_FOR_WRITE
decl_stmt|;
specifier|final
name|long
name|scheduledSize
init|=
name|blockSize
operator|*
name|getBlocksScheduled
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|long
name|remaining
init|=
literal|0
decl_stmt|;
name|DatanodeStorageInfo
name|storage
init|=
literal|null
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|s
range|:
name|getStorageInfos
argument_list|()
control|)
block|{
if|if
condition|(
name|s
operator|.
name|getState
argument_list|()
operator|==
name|State
operator|.
name|NORMAL
operator|&&
name|s
operator|.
name|getStorageType
argument_list|()
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|storage
operator|==
literal|null
condition|)
block|{
name|storage
operator|=
name|s
expr_stmt|;
block|}
name|long
name|r
init|=
name|s
operator|.
name|getRemaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|>=
name|requiredSize
condition|)
block|{
name|remaining
operator|+=
name|r
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|requiredSize
operator|>
name|remaining
operator|-
name|scheduledSize
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The node {} does not have enough {} space (required={},"
operator|+
literal|" scheduled={}, remaining={})."
argument_list|,
name|this
argument_list|,
name|t
argument_list|,
name|requiredSize
argument_list|,
name|scheduledSize
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|storage
return|;
block|}
comment|/**    * @return Approximate number of blocks currently scheduled to be written     * to the given storage type of this datanode.    */
DECL|method|getBlocksScheduled (StorageType t)
specifier|public
name|int
name|getBlocksScheduled
parameter_list|(
name|StorageType
name|t
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|currApproxBlocksScheduled
operator|.
name|get
argument_list|(
name|t
argument_list|)
operator|+
name|prevApproxBlocksScheduled
operator|.
name|get
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return Approximate number of blocks currently scheduled to be written     * to this datanode.    */
DECL|method|getBlocksScheduled ()
specifier|public
name|int
name|getBlocksScheduled
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|currApproxBlocksScheduled
operator|.
name|sum
argument_list|()
operator|+
name|prevApproxBlocksScheduled
operator|.
name|sum
argument_list|()
argument_list|)
return|;
block|}
comment|/** Increment the number of blocks scheduled. */
DECL|method|incrementBlocksScheduled (StorageType t)
name|void
name|incrementBlocksScheduled
parameter_list|(
name|StorageType
name|t
parameter_list|)
block|{
name|currApproxBlocksScheduled
operator|.
name|add
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/** Decrement the number of blocks scheduled. */
DECL|method|decrementBlocksScheduled (StorageType t)
name|void
name|decrementBlocksScheduled
parameter_list|(
name|StorageType
name|t
parameter_list|)
block|{
if|if
condition|(
name|prevApproxBlocksScheduled
operator|.
name|get
argument_list|(
name|t
argument_list|)
operator|>
literal|0
condition|)
block|{
name|prevApproxBlocksScheduled
operator|.
name|subtract
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currApproxBlocksScheduled
operator|.
name|get
argument_list|(
name|t
argument_list|)
operator|>
literal|0
condition|)
block|{
name|currApproxBlocksScheduled
operator|.
name|subtract
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// its ok if both counters are zero.
block|}
comment|/** Adjusts curr and prev number of blocks scheduled every few minutes. */
DECL|method|rollBlocksScheduled (long now)
specifier|private
name|void
name|rollBlocksScheduled
parameter_list|(
name|long
name|now
parameter_list|)
block|{
if|if
condition|(
name|now
operator|-
name|lastBlocksScheduledRollTime
operator|>
name|BLOCKS_SCHEDULED_ROLL_INTERVAL
condition|)
block|{
name|prevApproxBlocksScheduled
operator|.
name|set
argument_list|(
name|currApproxBlocksScheduled
argument_list|)
expr_stmt|;
name|currApproxBlocksScheduled
operator|.
name|reset
argument_list|()
expr_stmt|;
name|lastBlocksScheduledRollTime
operator|=
name|now
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Super implementation is sufficient
return|return
name|super
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
comment|// Sufficient to use super equality as datanodes are uniquely identified
comment|// by DatanodeID
return|return
operator|(
name|this
operator|==
name|obj
operator|)
operator|||
name|super
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
comment|/** Leaving service status. */
DECL|class|LeavingServiceStatus
specifier|public
class|class
name|LeavingServiceStatus
block|{
DECL|field|underReplicatedBlocks
specifier|private
name|int
name|underReplicatedBlocks
decl_stmt|;
DECL|field|outOfServiceOnlyReplicas
specifier|private
name|int
name|outOfServiceOnlyReplicas
decl_stmt|;
DECL|field|underReplicatedInOpenFiles
specifier|private
name|int
name|underReplicatedInOpenFiles
decl_stmt|;
DECL|field|startTime
specifier|private
name|long
name|startTime
decl_stmt|;
DECL|method|set (int underRepInOpenFiles, int underRepBlocks, int outOfServiceOnlyRep)
specifier|synchronized
name|void
name|set
parameter_list|(
name|int
name|underRepInOpenFiles
parameter_list|,
name|int
name|underRepBlocks
parameter_list|,
name|int
name|outOfServiceOnlyRep
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|isEnteringMaintenance
argument_list|()
condition|)
block|{
return|return;
block|}
name|underReplicatedInOpenFiles
operator|=
name|underRepInOpenFiles
expr_stmt|;
name|underReplicatedBlocks
operator|=
name|underRepBlocks
expr_stmt|;
name|outOfServiceOnlyReplicas
operator|=
name|outOfServiceOnlyRep
expr_stmt|;
block|}
comment|/** @return the number of under-replicated blocks */
DECL|method|getUnderReplicatedBlocks ()
specifier|public
specifier|synchronized
name|int
name|getUnderReplicatedBlocks
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|isEnteringMaintenance
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|underReplicatedBlocks
return|;
block|}
comment|/** @return the number of blocks with out-of-service-only replicas */
DECL|method|getOutOfServiceOnlyReplicas ()
specifier|public
specifier|synchronized
name|int
name|getOutOfServiceOnlyReplicas
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|isEnteringMaintenance
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|outOfServiceOnlyReplicas
return|;
block|}
comment|/** @return the number of under-replicated blocks in open files */
DECL|method|getUnderReplicatedInOpenFiles ()
specifier|public
specifier|synchronized
name|int
name|getUnderReplicatedInOpenFiles
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|isEnteringMaintenance
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|underReplicatedInOpenFiles
return|;
block|}
comment|/** Set start time */
DECL|method|setStartTime (long time)
specifier|public
specifier|synchronized
name|void
name|setStartTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|isEnteringMaintenance
argument_list|()
condition|)
block|{
return|return;
block|}
name|startTime
operator|=
name|time
expr_stmt|;
block|}
comment|/** @return start time */
DECL|method|getStartTime ()
specifier|public
specifier|synchronized
name|long
name|getStartTime
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|isEnteringMaintenance
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|startTime
return|;
block|}
block|}
comment|// End of class DecommissioningStatus
comment|/**    * Set the flag to indicate if this datanode is disallowed from communicating    * with the namenode.    */
DECL|method|setDisallowed (boolean flag)
specifier|public
name|void
name|setDisallowed
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|disallowed
operator|=
name|flag
expr_stmt|;
block|}
comment|/** Is the datanode disallowed from communicating with the namenode? */
DECL|method|isDisallowed ()
specifier|public
name|boolean
name|isDisallowed
parameter_list|()
block|{
return|return
name|disallowed
return|;
block|}
comment|/**    * @return number of failed volumes in the datanode.    */
DECL|method|getVolumeFailures ()
specifier|public
name|int
name|getVolumeFailures
parameter_list|()
block|{
return|return
name|volumeFailures
return|;
block|}
comment|/**    * Returns info about volume failures.    *    * @return info about volume failures, possibly null    */
DECL|method|getVolumeFailureSummary ()
specifier|public
name|VolumeFailureSummary
name|getVolumeFailureSummary
parameter_list|()
block|{
return|return
name|volumeFailureSummary
return|;
block|}
comment|/**    * @param nodeReg DatanodeID to update registration for.    */
annotation|@
name|Override
DECL|method|updateRegInfo (DatanodeID nodeReg)
specifier|public
name|void
name|updateRegInfo
parameter_list|(
name|DatanodeID
name|nodeReg
parameter_list|)
block|{
name|super
operator|.
name|updateRegInfo
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
comment|// must re-process IBR after re-registration
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|getStorageInfos
argument_list|()
control|)
block|{
name|storage
operator|.
name|setBlockReportCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|heartbeatedSinceRegistration
operator|=
literal|false
expr_stmt|;
name|forceRegistration
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * @return balancer bandwidth in bytes per second for this datanode    */
DECL|method|getBalancerBandwidth ()
specifier|public
specifier|synchronized
name|long
name|getBalancerBandwidth
parameter_list|()
block|{
return|return
name|this
operator|.
name|bandwidth
return|;
block|}
comment|/**    * @param bandwidth balancer bandwidth in bytes per second for this datanode    */
DECL|method|setBalancerBandwidth (long bandwidth)
specifier|public
specifier|synchronized
name|void
name|setBalancerBandwidth
parameter_list|(
name|long
name|bandwidth
parameter_list|)
block|{
name|this
operator|.
name|bandwidth
operator|=
name|bandwidth
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|dumpDatanode ()
specifier|public
name|String
name|dumpDatanode
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|super
operator|.
name|dumpDatanode
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|repl
init|=
name|replicateBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|repl
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|repl
argument_list|)
operator|.
name|append
argument_list|(
literal|" blocks to be replicated;"
argument_list|)
expr_stmt|;
block|}
name|int
name|ec
init|=
name|erasurecodeBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|ec
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|ec
argument_list|)
operator|.
name|append
argument_list|(
literal|" blocks to be erasure coded;"
argument_list|)
expr_stmt|;
block|}
name|int
name|inval
init|=
name|invalidateBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|inval
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|inval
argument_list|)
operator|.
name|append
argument_list|(
literal|" blocks to be invalidated;"
argument_list|)
expr_stmt|;
block|}
name|int
name|recover
init|=
name|recoverBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|recover
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|recover
argument_list|)
operator|.
name|append
argument_list|(
literal|" blocks to be recovered;"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|updateStorage (DatanodeStorage s)
name|DatanodeStorageInfo
name|updateStorage
parameter_list|(
name|DatanodeStorage
name|s
parameter_list|)
block|{
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
name|DatanodeStorageInfo
name|storage
init|=
name|storageMap
operator|.
name|get
argument_list|(
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
name|DFSTopologyNodeImpl
name|parent
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|getParent
argument_list|()
operator|instanceof
name|DFSTopologyNodeImpl
condition|)
block|{
name|parent
operator|=
operator|(
name|DFSTopologyNodeImpl
operator|)
name|getParent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|storage
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding new storage ID {} for DN {}"
argument_list|,
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|getXferAddr
argument_list|()
argument_list|)
expr_stmt|;
name|StorageType
name|type
init|=
name|s
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasStorageType
argument_list|(
name|type
argument_list|)
operator|&&
name|parent
operator|!=
literal|null
condition|)
block|{
comment|// we are about to add a type this node currently does not have,
comment|// inform the parent that a new type is added to this datanode
name|parent
operator|.
name|childAddStorage
argument_list|(
name|getName
argument_list|()
argument_list|,
name|s
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|storage
operator|=
operator|new
name|DatanodeStorageInfo
argument_list|(
name|this
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|storageMap
operator|.
name|put
argument_list|(
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|storage
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storage
operator|.
name|getState
argument_list|()
operator|!=
name|s
operator|.
name|getState
argument_list|()
operator|||
name|storage
operator|.
name|getStorageType
argument_list|()
operator|!=
name|s
operator|.
name|getStorageType
argument_list|()
condition|)
block|{
comment|// For backwards compatibility, make sure that the type and
comment|// state are updated. Some reports from older datanodes do
comment|// not include these fields so we may have assumed defaults.
name|StorageType
name|oldType
init|=
name|storage
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
name|StorageType
name|newType
init|=
name|s
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldType
operator|!=
name|newType
operator|&&
operator|!
name|hasStorageType
argument_list|(
name|newType
argument_list|)
operator|&&
name|parent
operator|!=
literal|null
condition|)
block|{
comment|// we are about to add a type this node currently does not have
comment|// inform the parent that a new type is added to this datanode
comment|// if old == new, nothing's changed. don't bother
name|parent
operator|.
name|childAddStorage
argument_list|(
name|getName
argument_list|()
argument_list|,
name|newType
argument_list|)
expr_stmt|;
block|}
name|storage
operator|.
name|updateFromStorage
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|storageMap
operator|.
name|put
argument_list|(
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldType
operator|!=
name|newType
operator|&&
operator|!
name|hasStorageType
argument_list|(
name|oldType
argument_list|)
operator|&&
name|parent
operator|!=
literal|null
condition|)
block|{
comment|// there is no more old type storage on this datanode, inform parent
comment|// about this change.
name|parent
operator|.
name|childRemoveStorage
argument_list|(
name|getName
argument_list|()
argument_list|,
name|oldType
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|storage
return|;
block|}
block|}
comment|/**    * @return   The time at which we last sent caching directives to this     *           DataNode, in monotonic milliseconds.    */
DECL|method|getLastCachingDirectiveSentTimeMs ()
specifier|public
name|long
name|getLastCachingDirectiveSentTimeMs
parameter_list|()
block|{
return|return
name|this
operator|.
name|lastCachingDirectiveSentTimeMs
return|;
block|}
comment|/**    * @param time  The time at which we last sent caching directives to this     *              DataNode, in monotonic milliseconds.    */
DECL|method|setLastCachingDirectiveSentTimeMs (long time)
specifier|public
name|void
name|setLastCachingDirectiveSentTimeMs
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|lastCachingDirectiveSentTimeMs
operator|=
name|time
expr_stmt|;
block|}
comment|/**    * @return whether at least first block report has been received    */
DECL|method|checkBlockReportReceived ()
specifier|public
name|boolean
name|checkBlockReportReceived
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|getStorageInfos
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|DatanodeStorageInfo
name|storageInfo
range|:
name|this
operator|.
name|getStorageInfos
argument_list|()
control|)
block|{
if|if
condition|(
name|storageInfo
operator|.
name|getBlockReportCount
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|setForceRegistration (boolean force)
specifier|public
name|void
name|setForceRegistration
parameter_list|(
name|boolean
name|force
parameter_list|)
block|{
name|forceRegistration
operator|=
name|force
expr_stmt|;
block|}
DECL|method|isRegistered ()
specifier|public
name|boolean
name|isRegistered
parameter_list|()
block|{
return|return
name|isAlive
argument_list|()
operator|&&
operator|!
name|forceRegistration
return|;
block|}
DECL|method|hasStorageType (StorageType type)
specifier|public
name|boolean
name|hasStorageType
parameter_list|(
name|StorageType
name|type
parameter_list|)
block|{
for|for
control|(
name|DatanodeStorageInfo
name|dnStorage
range|:
name|getStorageInfos
argument_list|()
control|)
block|{
if|if
condition|(
name|dnStorage
operator|.
name|getStorageType
argument_list|()
operator|==
name|type
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

