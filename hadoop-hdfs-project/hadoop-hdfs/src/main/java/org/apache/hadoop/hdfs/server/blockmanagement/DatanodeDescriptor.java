begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|CachedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LightWeightHashSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|IntrusiveCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_comment
comment|/**  * This class extends the DatanodeInfo class with ephemeral information (eg  * health, capacity, what blocks are associated with the Datanode) that is  * private to the Namenode, ie this class is not exposed to clients.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|DatanodeDescriptor
specifier|public
class|class
name|DatanodeDescriptor
extends|extends
name|DatanodeInfo
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DatanodeDescriptor
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|EMPTY_ARRAY
specifier|public
specifier|static
specifier|final
name|DatanodeDescriptor
index|[]
name|EMPTY_ARRAY
init|=
block|{}
decl_stmt|;
comment|// Stores status of decommissioning.
comment|// If node is not decommissioning, do not use this object for anything.
DECL|field|decommissioningStatus
specifier|public
name|DecommissioningStatus
name|decommissioningStatus
init|=
operator|new
name|DecommissioningStatus
argument_list|()
decl_stmt|;
comment|/** Block and targets pair */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|BlockTargetPair
specifier|public
specifier|static
class|class
name|BlockTargetPair
block|{
DECL|field|block
specifier|public
specifier|final
name|Block
name|block
decl_stmt|;
DECL|field|targets
specifier|public
specifier|final
name|DatanodeStorageInfo
index|[]
name|targets
decl_stmt|;
DECL|method|BlockTargetPair (Block block, DatanodeStorageInfo[] targets)
name|BlockTargetPair
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|this
operator|.
name|targets
operator|=
name|targets
expr_stmt|;
block|}
block|}
comment|/** A BlockTargetPair queue. */
DECL|class|BlockQueue
specifier|private
specifier|static
class|class
name|BlockQueue
parameter_list|<
name|E
parameter_list|>
block|{
DECL|field|blockq
specifier|private
specifier|final
name|Queue
argument_list|<
name|E
argument_list|>
name|blockq
init|=
operator|new
name|LinkedList
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Size of the queue */
DECL|method|size ()
specifier|synchronized
name|int
name|size
parameter_list|()
block|{
return|return
name|blockq
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Enqueue */
DECL|method|offer (E e)
specifier|synchronized
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|blockq
operator|.
name|offer
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/** Dequeue */
DECL|method|poll (int numBlocks)
specifier|synchronized
name|List
argument_list|<
name|E
argument_list|>
name|poll
parameter_list|(
name|int
name|numBlocks
parameter_list|)
block|{
if|if
condition|(
name|numBlocks
operator|<=
literal|0
operator|||
name|blockq
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|E
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
operator|!
name|blockq
operator|.
name|isEmpty
argument_list|()
operator|&&
name|numBlocks
operator|>
literal|0
condition|;
name|numBlocks
operator|--
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|blockq
operator|.
name|poll
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|/**      * Returns<tt>true</tt> if the queue contains the specified element.      */
DECL|method|contains (E e)
name|boolean
name|contains
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|blockq
operator|.
name|contains
argument_list|(
name|e
argument_list|)
return|;
block|}
DECL|method|clear ()
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
name|blockq
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|storageMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|DatanodeStorageInfo
argument_list|>
name|storageMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|DatanodeStorageInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * A list of CachedBlock objects on this datanode.    */
DECL|class|CachedBlocksList
specifier|public
specifier|static
class|class
name|CachedBlocksList
extends|extends
name|IntrusiveCollection
argument_list|<
name|CachedBlock
argument_list|>
block|{
DECL|enum|Type
specifier|public
enum|enum
name|Type
block|{
DECL|enumConstant|PENDING_CACHED
name|PENDING_CACHED
block|,
DECL|enumConstant|CACHED
name|CACHED
block|,
DECL|enumConstant|PENDING_UNCACHED
name|PENDING_UNCACHED
block|}
DECL|field|datanode
specifier|private
specifier|final
name|DatanodeDescriptor
name|datanode
decl_stmt|;
DECL|field|type
specifier|private
specifier|final
name|Type
name|type
decl_stmt|;
DECL|method|CachedBlocksList (DatanodeDescriptor datanode, Type type)
name|CachedBlocksList
parameter_list|(
name|DatanodeDescriptor
name|datanode
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
DECL|method|getDatanode ()
specifier|public
name|DatanodeDescriptor
name|getDatanode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
DECL|method|getType ()
specifier|public
name|Type
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
block|}
comment|/**    * The blocks which we want to cache on this DataNode.    */
DECL|field|pendingCached
specifier|private
specifier|final
name|CachedBlocksList
name|pendingCached
init|=
operator|new
name|CachedBlocksList
argument_list|(
name|this
argument_list|,
name|CachedBlocksList
operator|.
name|Type
operator|.
name|PENDING_CACHED
argument_list|)
decl_stmt|;
comment|/**    * The blocks which we know are cached on this datanode.    * This list is updated by periodic cache reports.    */
DECL|field|cached
specifier|private
specifier|final
name|CachedBlocksList
name|cached
init|=
operator|new
name|CachedBlocksList
argument_list|(
name|this
argument_list|,
name|CachedBlocksList
operator|.
name|Type
operator|.
name|CACHED
argument_list|)
decl_stmt|;
comment|/**    * The blocks which we want to uncache on this DataNode.    */
DECL|field|pendingUncached
specifier|private
specifier|final
name|CachedBlocksList
name|pendingUncached
init|=
operator|new
name|CachedBlocksList
argument_list|(
name|this
argument_list|,
name|CachedBlocksList
operator|.
name|Type
operator|.
name|PENDING_UNCACHED
argument_list|)
decl_stmt|;
DECL|method|getPendingCached ()
specifier|public
name|CachedBlocksList
name|getPendingCached
parameter_list|()
block|{
return|return
name|pendingCached
return|;
block|}
DECL|method|getCached ()
specifier|public
name|CachedBlocksList
name|getCached
parameter_list|()
block|{
return|return
name|cached
return|;
block|}
DECL|method|getPendingUncached ()
specifier|public
name|CachedBlocksList
name|getPendingUncached
parameter_list|()
block|{
return|return
name|pendingUncached
return|;
block|}
comment|// isAlive == heartbeats.contains(this)
comment|// This is an optimization, because contains takes O(n) time on Arraylist
DECL|field|isAlive
specifier|public
name|boolean
name|isAlive
init|=
literal|false
decl_stmt|;
DECL|field|needKeyUpdate
specifier|public
name|boolean
name|needKeyUpdate
init|=
literal|false
decl_stmt|;
comment|// A system administrator can tune the balancer bandwidth parameter
comment|// (dfs.balance.bandwidthPerSec) dynamically by calling
comment|// "dfsadmin -setBalanacerBandwidth<newbandwidth>", at which point the
comment|// following 'bandwidth' variable gets updated with the new value for each
comment|// node. Once the heartbeat command is issued to update the value on the
comment|// specified datanode, this value will be set back to 0.
DECL|field|bandwidth
specifier|private
name|long
name|bandwidth
decl_stmt|;
comment|/** A queue of blocks to be replicated by this datanode */
DECL|field|replicateBlocks
specifier|private
name|BlockQueue
argument_list|<
name|BlockTargetPair
argument_list|>
name|replicateBlocks
init|=
operator|new
name|BlockQueue
argument_list|<
name|BlockTargetPair
argument_list|>
argument_list|()
decl_stmt|;
comment|/** A queue of blocks to be recovered by this datanode */
DECL|field|recoverBlocks
specifier|private
name|BlockQueue
argument_list|<
name|BlockInfoUnderConstruction
argument_list|>
name|recoverBlocks
init|=
operator|new
name|BlockQueue
argument_list|<
name|BlockInfoUnderConstruction
argument_list|>
argument_list|()
decl_stmt|;
comment|/** A set of blocks to be invalidated by this datanode */
DECL|field|invalidateBlocks
specifier|private
name|LightWeightHashSet
argument_list|<
name|Block
argument_list|>
name|invalidateBlocks
init|=
operator|new
name|LightWeightHashSet
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|volumeFailures
specifier|private
name|int
name|volumeFailures
init|=
literal|0
decl_stmt|;
comment|/**     * When set to true, the node is not in include list and is not allowed    * to communicate with the namenode    */
DECL|field|disallowed
specifier|private
name|boolean
name|disallowed
init|=
literal|false
decl_stmt|;
comment|/**    * DatanodeDescriptor constructor    * @param nodeID id of the data node    */
DECL|method|DatanodeDescriptor (DatanodeID nodeID)
specifier|public
name|DatanodeDescriptor
parameter_list|(
name|DatanodeID
name|nodeID
parameter_list|)
block|{
name|super
argument_list|(
name|nodeID
argument_list|)
expr_stmt|;
block|}
comment|/**    * DatanodeDescriptor constructor    * @param nodeID id of the data node    * @param networkLocation location of the data node in network    */
DECL|method|DatanodeDescriptor (DatanodeID nodeID, String networkLocation)
specifier|public
name|DatanodeDescriptor
parameter_list|(
name|DatanodeID
name|nodeID
parameter_list|,
name|String
name|networkLocation
parameter_list|)
block|{
name|super
argument_list|(
name|nodeID
argument_list|,
name|networkLocation
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add data-node to the block. Add block to the head of the list of blocks    * belonging to the data-node.    */
DECL|method|addBlock (String storageID, BlockInfo b)
specifier|public
name|boolean
name|addBlock
parameter_list|(
name|String
name|storageID
parameter_list|,
name|BlockInfo
name|b
parameter_list|)
block|{
name|DatanodeStorageInfo
name|s
init|=
name|getStorageInfo
argument_list|(
name|storageID
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
return|return
name|s
operator|.
name|addBlock
argument_list|(
name|b
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|getStorageInfo (String storageID)
name|DatanodeStorageInfo
name|getStorageInfo
parameter_list|(
name|String
name|storageID
parameter_list|)
block|{
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
return|return
name|storageMap
operator|.
name|get
argument_list|(
name|storageID
argument_list|)
return|;
block|}
block|}
DECL|method|getStorageInfos ()
name|DatanodeStorageInfo
index|[]
name|getStorageInfos
parameter_list|()
block|{
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
specifier|final
name|Collection
argument_list|<
name|DatanodeStorageInfo
argument_list|>
name|storages
init|=
name|storageMap
operator|.
name|values
argument_list|()
decl_stmt|;
return|return
name|storages
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeStorageInfo
index|[
name|storages
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/**    * Remove block from the list of blocks belonging to the data-node. Remove    * data-node from the block.    */
DECL|method|removeBlock (BlockInfo b)
name|boolean
name|removeBlock
parameter_list|(
name|BlockInfo
name|b
parameter_list|)
block|{
name|int
name|index
init|=
name|b
operator|.
name|findStorageInfo
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// if block exists on this datanode
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|DatanodeStorageInfo
name|s
init|=
name|b
operator|.
name|getStorageInfo
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
return|return
name|s
operator|.
name|removeBlock
argument_list|(
name|b
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Remove block from the list of blocks belonging to the data-node. Remove    * data-node from the block.    */
DECL|method|removeBlock (String storageID, BlockInfo b)
name|boolean
name|removeBlock
parameter_list|(
name|String
name|storageID
parameter_list|,
name|BlockInfo
name|b
parameter_list|)
block|{
name|DatanodeStorageInfo
name|s
init|=
name|getStorageInfo
argument_list|(
name|storageID
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
return|return
name|s
operator|.
name|removeBlock
argument_list|(
name|b
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Replace specified old block with a new one in the DataNodeDescriptor.    *    * @param oldBlock - block to be replaced    * @param newBlock - a replacement block    * @return the new block    */
DECL|method|replaceBlock (BlockInfo oldBlock, BlockInfo newBlock)
specifier|public
name|BlockInfo
name|replaceBlock
parameter_list|(
name|BlockInfo
name|oldBlock
parameter_list|,
name|BlockInfo
name|newBlock
parameter_list|)
block|{
name|int
name|index
init|=
name|oldBlock
operator|.
name|findStorageInfo
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|DatanodeStorageInfo
name|s
init|=
name|oldBlock
operator|.
name|getStorageInfo
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|boolean
name|done
init|=
name|s
operator|.
name|removeBlock
argument_list|(
name|oldBlock
argument_list|)
decl_stmt|;
assert|assert
name|done
operator|:
literal|"Old block should belong to the data-node when replacing"
assert|;
name|done
operator|=
name|s
operator|.
name|addBlock
argument_list|(
name|newBlock
argument_list|)
expr_stmt|;
assert|assert
name|done
operator|:
literal|"New block should not belong to the data-node when replacing"
assert|;
return|return
name|newBlock
return|;
block|}
DECL|method|resetBlocks ()
specifier|public
name|void
name|resetBlocks
parameter_list|()
block|{
name|setCapacity
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setRemaining
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setBlockPoolUsed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setDfsUsed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setXceiverCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|invalidateBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|volumeFailures
operator|=
literal|0
expr_stmt|;
comment|// pendingCached, cached, and pendingUncached are protected by the
comment|// FSN lock.
name|this
operator|.
name|pendingCached
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|cached
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|pendingUncached
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|clearBlockQueues ()
specifier|public
name|void
name|clearBlockQueues
parameter_list|()
block|{
synchronized|synchronized
init|(
name|invalidateBlocks
init|)
block|{
name|this
operator|.
name|invalidateBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|recoverBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|replicateBlocks
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// pendingCached, cached, and pendingUncached are protected by the
comment|// FSN lock.
name|this
operator|.
name|pendingCached
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|cached
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|pendingUncached
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|numBlocks ()
specifier|public
name|int
name|numBlocks
parameter_list|()
block|{
name|int
name|blocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|entry
range|:
name|getStorageInfos
argument_list|()
control|)
block|{
name|blocks
operator|+=
name|entry
operator|.
name|numBlocks
argument_list|()
expr_stmt|;
block|}
return|return
name|blocks
return|;
block|}
comment|/**    * Updates stats from datanode heartbeat.    */
DECL|method|updateHeartbeat (StorageReport[] reports, long cacheCapacity, long cacheUsed, int xceiverCount, int volFailures)
specifier|public
name|void
name|updateHeartbeat
parameter_list|(
name|StorageReport
index|[]
name|reports
parameter_list|,
name|long
name|cacheCapacity
parameter_list|,
name|long
name|cacheUsed
parameter_list|,
name|int
name|xceiverCount
parameter_list|,
name|int
name|volFailures
parameter_list|)
block|{
name|long
name|totalCapacity
init|=
literal|0
decl_stmt|;
name|long
name|totalRemaining
init|=
literal|0
decl_stmt|;
name|long
name|totalBlockPoolUsed
init|=
literal|0
decl_stmt|;
name|long
name|totalDfsUsed
init|=
literal|0
decl_stmt|;
name|setCacheCapacity
argument_list|(
name|cacheCapacity
argument_list|)
expr_stmt|;
name|setCacheUsed
argument_list|(
name|cacheUsed
argument_list|)
expr_stmt|;
name|setXceiverCount
argument_list|(
name|xceiverCount
argument_list|)
expr_stmt|;
name|setLastUpdate
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|volumeFailures
operator|=
name|volFailures
expr_stmt|;
for|for
control|(
name|StorageReport
name|report
range|:
name|reports
control|)
block|{
name|DatanodeStorageInfo
name|storage
init|=
name|storageMap
operator|.
name|get
argument_list|(
name|report
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storage
operator|!=
literal|null
condition|)
block|{
name|storage
operator|.
name|receivedHeartbeat
argument_list|(
name|report
argument_list|,
name|getLastUpdate
argument_list|()
argument_list|)
expr_stmt|;
name|totalCapacity
operator|+=
name|report
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
name|totalRemaining
operator|+=
name|report
operator|.
name|getRemaining
argument_list|()
expr_stmt|;
name|totalBlockPoolUsed
operator|+=
name|report
operator|.
name|getBlockPoolUsed
argument_list|()
expr_stmt|;
name|totalDfsUsed
operator|+=
name|report
operator|.
name|getDfsUsed
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// This warning is generally benign during cluster initialization
comment|// when the heartbeat is received before the initial block reports
comment|// from each storage.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unrecognized storage ID "
operator|+
name|report
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Update total metrics for the node.
name|setCapacity
argument_list|(
name|totalCapacity
argument_list|)
expr_stmt|;
name|setRemaining
argument_list|(
name|totalRemaining
argument_list|)
expr_stmt|;
name|setBlockPoolUsed
argument_list|(
name|totalBlockPoolUsed
argument_list|)
expr_stmt|;
name|setDfsUsed
argument_list|(
name|totalDfsUsed
argument_list|)
expr_stmt|;
block|}
DECL|class|BlockIterator
specifier|private
specifier|static
class|class
name|BlockIterator
implements|implements
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
block|{
DECL|field|index
specifier|private
name|int
name|index
init|=
literal|0
decl_stmt|;
DECL|field|iterators
specifier|private
specifier|final
name|List
argument_list|<
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|iterators
decl_stmt|;
DECL|method|BlockIterator (final DatanodeStorageInfo... storages)
specifier|private
name|BlockIterator
parameter_list|(
specifier|final
name|DatanodeStorageInfo
modifier|...
name|storages
parameter_list|)
block|{
name|List
argument_list|<
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
name|iterators
init|=
operator|new
name|ArrayList
argument_list|<
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|e
range|:
name|storages
control|)
block|{
name|iterators
operator|.
name|add
argument_list|(
name|e
operator|.
name|getBlockIterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|iterators
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|iterators
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|update
argument_list|()
expr_stmt|;
return|return
name|iterators
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|BlockInfo
name|next
parameter_list|()
block|{
name|update
argument_list|()
expr_stmt|;
return|return
name|iterators
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Remove unsupported."
argument_list|)
throw|;
block|}
DECL|method|update ()
specifier|private
name|void
name|update
parameter_list|()
block|{
while|while
condition|(
name|index
operator|<
name|iterators
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|&&
operator|!
name|iterators
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
block|}
DECL|method|getBlockIterator ()
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|getBlockIterator
parameter_list|()
block|{
return|return
operator|new
name|BlockIterator
argument_list|(
name|getStorageInfos
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getBlockIterator (final String storageID)
name|Iterator
argument_list|<
name|BlockInfo
argument_list|>
name|getBlockIterator
parameter_list|(
specifier|final
name|String
name|storageID
parameter_list|)
block|{
return|return
operator|new
name|BlockIterator
argument_list|(
name|getStorageInfo
argument_list|(
name|storageID
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Store block replication work.    */
DECL|method|addBlockToBeReplicated (Block block, DatanodeStorageInfo[] targets)
name|void
name|addBlockToBeReplicated
parameter_list|(
name|Block
name|block
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|targets
parameter_list|)
block|{
assert|assert
operator|(
name|block
operator|!=
literal|null
operator|&&
name|targets
operator|!=
literal|null
operator|&&
name|targets
operator|.
name|length
operator|>
literal|0
operator|)
assert|;
name|replicateBlocks
operator|.
name|offer
argument_list|(
operator|new
name|BlockTargetPair
argument_list|(
name|block
argument_list|,
name|targets
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Store block recovery work.    */
DECL|method|addBlockToBeRecovered (BlockInfoUnderConstruction block)
name|void
name|addBlockToBeRecovered
parameter_list|(
name|BlockInfoUnderConstruction
name|block
parameter_list|)
block|{
if|if
condition|(
name|recoverBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|// this prevents adding the same block twice to the recovery queue
name|BlockManager
operator|.
name|LOG
operator|.
name|info
argument_list|(
name|block
operator|+
literal|" is already in the recovery queue"
argument_list|)
expr_stmt|;
return|return;
block|}
name|recoverBlocks
operator|.
name|offer
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/**    * Store block invalidation work.    */
DECL|method|addBlocksToBeInvalidated (List<Block> blocklist)
name|void
name|addBlocksToBeInvalidated
parameter_list|(
name|List
argument_list|<
name|Block
argument_list|>
name|blocklist
parameter_list|)
block|{
assert|assert
operator|(
name|blocklist
operator|!=
literal|null
operator|&&
name|blocklist
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
assert|;
synchronized|synchronized
init|(
name|invalidateBlocks
init|)
block|{
for|for
control|(
name|Block
name|blk
range|:
name|blocklist
control|)
block|{
name|invalidateBlocks
operator|.
name|add
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The number of work items that are pending to be replicated    */
DECL|method|getNumberOfBlocksToBeReplicated ()
name|int
name|getNumberOfBlocksToBeReplicated
parameter_list|()
block|{
return|return
name|replicateBlocks
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * The number of block invalidation items that are pending to     * be sent to the datanode    */
DECL|method|getNumberOfBlocksToBeInvalidated ()
name|int
name|getNumberOfBlocksToBeInvalidated
parameter_list|()
block|{
synchronized|synchronized
init|(
name|invalidateBlocks
init|)
block|{
return|return
name|invalidateBlocks
operator|.
name|size
argument_list|()
return|;
block|}
block|}
DECL|method|getReplicationCommand (int maxTransfers)
specifier|public
name|List
argument_list|<
name|BlockTargetPair
argument_list|>
name|getReplicationCommand
parameter_list|(
name|int
name|maxTransfers
parameter_list|)
block|{
return|return
name|replicateBlocks
operator|.
name|poll
argument_list|(
name|maxTransfers
argument_list|)
return|;
block|}
DECL|method|getLeaseRecoveryCommand (int maxTransfers)
specifier|public
name|BlockInfoUnderConstruction
index|[]
name|getLeaseRecoveryCommand
parameter_list|(
name|int
name|maxTransfers
parameter_list|)
block|{
name|List
argument_list|<
name|BlockInfoUnderConstruction
argument_list|>
name|blocks
init|=
name|recoverBlocks
operator|.
name|poll
argument_list|(
name|maxTransfers
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|blocks
operator|.
name|toArray
argument_list|(
operator|new
name|BlockInfoUnderConstruction
index|[
name|blocks
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Remove the specified number of blocks to be invalidated    */
DECL|method|getInvalidateBlocks (int maxblocks)
specifier|public
name|Block
index|[]
name|getInvalidateBlocks
parameter_list|(
name|int
name|maxblocks
parameter_list|)
block|{
synchronized|synchronized
init|(
name|invalidateBlocks
init|)
block|{
name|Block
index|[]
name|deleteList
init|=
name|invalidateBlocks
operator|.
name|pollToArray
argument_list|(
operator|new
name|Block
index|[
name|Math
operator|.
name|min
argument_list|(
name|invalidateBlocks
operator|.
name|size
argument_list|()
argument_list|,
name|maxblocks
argument_list|)
index|]
argument_list|)
decl_stmt|;
return|return
name|deleteList
operator|.
name|length
operator|==
literal|0
condition|?
literal|null
else|:
name|deleteList
return|;
block|}
block|}
comment|/**    * @return Approximate number of blocks currently scheduled to be written     * to this datanode.    */
DECL|method|getBlocksScheduled ()
specifier|public
name|int
name|getBlocksScheduled
parameter_list|()
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|getStorageInfos
argument_list|()
control|)
block|{
name|n
operator|+=
name|storage
operator|.
name|getBlocksScheduled
argument_list|()
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// Super implementation is sufficient
return|return
name|super
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
comment|// Sufficient to use super equality as datanodes are uniquely identified
comment|// by DatanodeID
return|return
operator|(
name|this
operator|==
name|obj
operator|)
operator|||
name|super
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
comment|/** Decommissioning status */
DECL|class|DecommissioningStatus
specifier|public
class|class
name|DecommissioningStatus
block|{
DECL|field|underReplicatedBlocks
specifier|private
name|int
name|underReplicatedBlocks
decl_stmt|;
DECL|field|decommissionOnlyReplicas
specifier|private
name|int
name|decommissionOnlyReplicas
decl_stmt|;
DECL|field|underReplicatedInOpenFiles
specifier|private
name|int
name|underReplicatedInOpenFiles
decl_stmt|;
DECL|field|startTime
specifier|private
name|long
name|startTime
decl_stmt|;
DECL|method|set (int underRep, int onlyRep, int underConstruction)
specifier|synchronized
name|void
name|set
parameter_list|(
name|int
name|underRep
parameter_list|,
name|int
name|onlyRep
parameter_list|,
name|int
name|underConstruction
parameter_list|)
block|{
if|if
condition|(
name|isDecommissionInProgress
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return;
block|}
name|underReplicatedBlocks
operator|=
name|underRep
expr_stmt|;
name|decommissionOnlyReplicas
operator|=
name|onlyRep
expr_stmt|;
name|underReplicatedInOpenFiles
operator|=
name|underConstruction
expr_stmt|;
block|}
comment|/** @return the number of under-replicated blocks */
DECL|method|getUnderReplicatedBlocks ()
specifier|public
specifier|synchronized
name|int
name|getUnderReplicatedBlocks
parameter_list|()
block|{
if|if
condition|(
name|isDecommissionInProgress
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|underReplicatedBlocks
return|;
block|}
comment|/** @return the number of decommission-only replicas */
DECL|method|getDecommissionOnlyReplicas ()
specifier|public
specifier|synchronized
name|int
name|getDecommissionOnlyReplicas
parameter_list|()
block|{
if|if
condition|(
name|isDecommissionInProgress
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|decommissionOnlyReplicas
return|;
block|}
comment|/** @return the number of under-replicated blocks in open files */
DECL|method|getUnderReplicatedInOpenFiles ()
specifier|public
specifier|synchronized
name|int
name|getUnderReplicatedInOpenFiles
parameter_list|()
block|{
if|if
condition|(
name|isDecommissionInProgress
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|underReplicatedInOpenFiles
return|;
block|}
comment|/** Set start time */
DECL|method|setStartTime (long time)
specifier|public
specifier|synchronized
name|void
name|setStartTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|startTime
operator|=
name|time
expr_stmt|;
block|}
comment|/** @return start time */
DECL|method|getStartTime ()
specifier|public
specifier|synchronized
name|long
name|getStartTime
parameter_list|()
block|{
if|if
condition|(
name|isDecommissionInProgress
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|startTime
return|;
block|}
block|}
comment|// End of class DecommissioningStatus
comment|/**    * Set the flag to indicate if this datanode is disallowed from communicating    * with the namenode.    */
DECL|method|setDisallowed (boolean flag)
specifier|public
name|void
name|setDisallowed
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|disallowed
operator|=
name|flag
expr_stmt|;
block|}
comment|/** Is the datanode disallowed from communicating with the namenode? */
DECL|method|isDisallowed ()
specifier|public
name|boolean
name|isDisallowed
parameter_list|()
block|{
return|return
name|disallowed
return|;
block|}
comment|/**    * @return number of failed volumes in the datanode.    */
DECL|method|getVolumeFailures ()
specifier|public
name|int
name|getVolumeFailures
parameter_list|()
block|{
return|return
name|volumeFailures
return|;
block|}
comment|/**    * @param nodeReg DatanodeID to update registration for.    */
annotation|@
name|Override
DECL|method|updateRegInfo (DatanodeID nodeReg)
specifier|public
name|void
name|updateRegInfo
parameter_list|(
name|DatanodeID
name|nodeReg
parameter_list|)
block|{
name|super
operator|.
name|updateRegInfo
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
comment|// must re-process IBR after re-registration
for|for
control|(
name|DatanodeStorageInfo
name|storage
range|:
name|getStorageInfos
argument_list|()
control|)
block|{
name|storage
operator|.
name|setBlockReportCount
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return balancer bandwidth in bytes per second for this datanode    */
DECL|method|getBalancerBandwidth ()
specifier|public
name|long
name|getBalancerBandwidth
parameter_list|()
block|{
return|return
name|this
operator|.
name|bandwidth
return|;
block|}
comment|/**    * @param bandwidth balancer bandwidth in bytes per second for this datanode    */
DECL|method|setBalancerBandwidth (long bandwidth)
specifier|public
name|void
name|setBalancerBandwidth
parameter_list|(
name|long
name|bandwidth
parameter_list|)
block|{
name|this
operator|.
name|bandwidth
operator|=
name|bandwidth
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|dumpDatanode ()
specifier|public
name|String
name|dumpDatanode
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|super
operator|.
name|dumpDatanode
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|repl
init|=
name|replicateBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|repl
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|repl
argument_list|)
operator|.
name|append
argument_list|(
literal|" blocks to be replicated;"
argument_list|)
expr_stmt|;
block|}
name|int
name|inval
init|=
name|invalidateBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|inval
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|inval
argument_list|)
operator|.
name|append
argument_list|(
literal|" blocks to be invalidated;"
argument_list|)
expr_stmt|;
block|}
name|int
name|recover
init|=
name|recoverBlocks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|recover
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|recover
argument_list|)
operator|.
name|append
argument_list|(
literal|" blocks to be recovered;"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|updateStorage (DatanodeStorage s)
specifier|public
name|DatanodeStorageInfo
name|updateStorage
parameter_list|(
name|DatanodeStorage
name|s
parameter_list|)
block|{
synchronized|synchronized
init|(
name|storageMap
init|)
block|{
name|DatanodeStorageInfo
name|storage
init|=
name|storageMap
operator|.
name|get
argument_list|(
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storage
operator|==
literal|null
condition|)
block|{
name|storage
operator|=
operator|new
name|DatanodeStorageInfo
argument_list|(
name|this
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|storageMap
operator|.
name|put
argument_list|(
name|s
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|storage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storage
operator|.
name|setState
argument_list|(
name|s
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|storage
return|;
block|}
block|}
block|}
end_class

end_unit

