begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.util
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_comment
comment|/**  * A memory efficient implementation of RBTree. Instead of having a Node for  * each entry each node contains an array holding 64 entries.  *  * Based on the Apache Harmony folded TreeMap.  *  * @param<E> Entry type  */
end_comment

begin_class
DECL|class|FoldedTreeSet
specifier|public
class|class
name|FoldedTreeSet
parameter_list|<
name|E
parameter_list|>
implements|implements
name|SortedSet
argument_list|<
name|E
argument_list|>
block|{
DECL|field|RED
specifier|private
specifier|static
specifier|final
name|boolean
name|RED
init|=
literal|true
decl_stmt|;
DECL|field|BLACK
specifier|private
specifier|static
specifier|final
name|boolean
name|BLACK
init|=
literal|false
decl_stmt|;
DECL|field|comparator
specifier|private
specifier|final
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
decl_stmt|;
DECL|field|root
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|root
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
decl_stmt|;
DECL|field|nodeCount
specifier|private
name|int
name|nodeCount
decl_stmt|;
DECL|field|modCount
specifier|private
name|int
name|modCount
decl_stmt|;
DECL|field|cachedNode
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|cachedNode
decl_stmt|;
comment|/**    * Internal tree node that holds a sorted array of entries.    *    * @param<E> type of the elements    */
DECL|class|Node
specifier|private
specifier|static
class|class
name|Node
parameter_list|<
name|E
parameter_list|>
block|{
DECL|field|NODE_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|NODE_SIZE
init|=
literal|64
decl_stmt|;
comment|// Tree structure
DECL|field|parent
DECL|field|left
DECL|field|right
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|parent
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|;
DECL|field|color
specifier|private
name|boolean
name|color
decl_stmt|;
DECL|field|entries
specifier|private
specifier|final
name|E
index|[]
name|entries
decl_stmt|;
DECL|field|leftIndex
DECL|field|rightIndex
specifier|private
name|int
name|leftIndex
init|=
literal|0
decl_stmt|,
name|rightIndex
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|// List for fast ordered iteration
DECL|field|prev
DECL|field|next
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|prev
decl_stmt|,
name|next
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|Node ()
specifier|public
name|Node
parameter_list|()
block|{
name|entries
operator|=
operator|(
name|E
index|[]
operator|)
operator|new
name|Object
index|[
name|NODE_SIZE
index|]
expr_stmt|;
block|}
DECL|method|isRed ()
specifier|public
name|boolean
name|isRed
parameter_list|()
block|{
return|return
name|color
operator|==
name|RED
return|;
block|}
DECL|method|isBlack ()
specifier|public
name|boolean
name|isBlack
parameter_list|()
block|{
return|return
name|color
operator|==
name|BLACK
return|;
block|}
DECL|method|getLeftMostNode ()
specifier|public
name|Node
argument_list|<
name|E
argument_list|>
name|getLeftMostNode
parameter_list|()
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|this
decl_stmt|;
while|while
condition|(
name|node
operator|.
name|left
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|left
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
DECL|method|getRightMostNode ()
specifier|public
name|Node
argument_list|<
name|E
argument_list|>
name|getRightMostNode
parameter_list|()
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|this
decl_stmt|;
while|while
condition|(
name|node
operator|.
name|right
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|right
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
DECL|method|addEntryLeft (E entry)
specifier|public
name|void
name|addEntryLeft
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
assert|assert
name|rightIndex
operator|<
name|entries
operator|.
name|length
assert|;
assert|assert
operator|!
name|isFull
argument_list|()
assert|;
if|if
condition|(
name|leftIndex
operator|==
literal|0
condition|)
block|{
name|rightIndex
operator|++
expr_stmt|;
comment|// Shift entries right/up
name|System
operator|.
name|arraycopy
argument_list|(
name|entries
argument_list|,
literal|0
argument_list|,
name|entries
argument_list|,
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leftIndex
operator|--
expr_stmt|;
block|}
name|size
operator|++
expr_stmt|;
name|entries
index|[
name|leftIndex
index|]
operator|=
name|entry
expr_stmt|;
block|}
DECL|method|addEntryRight (E entry)
specifier|public
name|void
name|addEntryRight
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
assert|assert
operator|!
name|isFull
argument_list|()
assert|;
if|if
condition|(
name|rightIndex
operator|==
name|NODE_SIZE
operator|-
literal|1
condition|)
block|{
assert|assert
name|leftIndex
operator|>
literal|0
assert|;
comment|// Shift entries left/down
name|System
operator|.
name|arraycopy
argument_list|(
name|entries
argument_list|,
name|leftIndex
argument_list|,
name|entries
argument_list|,
operator|--
name|leftIndex
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rightIndex
operator|++
expr_stmt|;
block|}
name|size
operator|++
expr_stmt|;
name|entries
index|[
name|rightIndex
index|]
operator|=
name|entry
expr_stmt|;
block|}
DECL|method|addEntryAt (E entry, int index)
specifier|public
name|void
name|addEntryAt
parameter_list|(
name|E
name|entry
parameter_list|,
name|int
name|index
parameter_list|)
block|{
assert|assert
operator|!
name|isFull
argument_list|()
assert|;
if|if
condition|(
name|leftIndex
operator|==
literal|0
operator|||
operator|(
operator|(
name|rightIndex
operator|!=
name|Node
operator|.
name|NODE_SIZE
operator|-
literal|1
operator|)
operator|&&
operator|(
name|rightIndex
operator|-
name|index
operator|<=
name|index
operator|-
name|leftIndex
operator|)
operator|)
condition|)
block|{
name|rightIndex
operator|++
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|entries
argument_list|,
name|index
argument_list|,
name|entries
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|rightIndex
operator|-
name|index
argument_list|)
expr_stmt|;
name|entries
index|[
name|index
index|]
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|int
name|newLeftIndex
init|=
name|leftIndex
operator|-
literal|1
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|entries
argument_list|,
name|leftIndex
argument_list|,
name|entries
argument_list|,
name|newLeftIndex
argument_list|,
name|index
operator|-
name|leftIndex
argument_list|)
expr_stmt|;
name|leftIndex
operator|=
name|newLeftIndex
expr_stmt|;
name|entries
index|[
name|index
operator|-
literal|1
index|]
operator|=
name|entry
expr_stmt|;
block|}
name|size
operator|++
expr_stmt|;
block|}
DECL|method|addEntriesLeft (Node<E> from)
specifier|public
name|void
name|addEntriesLeft
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|from
parameter_list|)
block|{
name|leftIndex
operator|-=
name|from
operator|.
name|size
expr_stmt|;
name|size
operator|+=
name|from
operator|.
name|size
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|from
operator|.
name|entries
argument_list|,
name|from
operator|.
name|leftIndex
argument_list|,
name|entries
argument_list|,
name|leftIndex
argument_list|,
name|from
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
DECL|method|addEntriesRight (Node<E> from)
specifier|public
name|void
name|addEntriesRight
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|from
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|from
operator|.
name|entries
argument_list|,
name|from
operator|.
name|leftIndex
argument_list|,
name|entries
argument_list|,
name|rightIndex
operator|+
literal|1
argument_list|,
name|from
operator|.
name|size
argument_list|)
expr_stmt|;
name|size
operator|+=
name|from
operator|.
name|size
expr_stmt|;
name|rightIndex
operator|+=
name|from
operator|.
name|size
expr_stmt|;
block|}
DECL|method|insertEntrySlideLeft (E entry, int index)
specifier|public
name|E
name|insertEntrySlideLeft
parameter_list|(
name|E
name|entry
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|E
name|pushedEntry
init|=
name|entries
index|[
literal|0
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|entries
argument_list|,
literal|1
argument_list|,
name|entries
argument_list|,
literal|0
argument_list|,
name|index
operator|-
literal|1
argument_list|)
expr_stmt|;
name|entries
index|[
name|index
operator|-
literal|1
index|]
operator|=
name|entry
expr_stmt|;
return|return
name|pushedEntry
return|;
block|}
DECL|method|insertEntrySlideRight (E entry, int index)
specifier|public
name|E
name|insertEntrySlideRight
parameter_list|(
name|E
name|entry
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|E
name|movedEntry
init|=
name|entries
index|[
name|rightIndex
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|entries
argument_list|,
name|index
argument_list|,
name|entries
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|rightIndex
operator|-
name|index
argument_list|)
expr_stmt|;
name|entries
index|[
name|index
index|]
operator|=
name|entry
expr_stmt|;
return|return
name|movedEntry
return|;
block|}
DECL|method|removeEntryLeft ()
specifier|public
name|E
name|removeEntryLeft
parameter_list|()
block|{
assert|assert
operator|!
name|isEmpty
argument_list|()
assert|;
name|E
name|entry
init|=
name|entries
index|[
name|leftIndex
index|]
decl_stmt|;
name|entries
index|[
name|leftIndex
index|]
operator|=
literal|null
expr_stmt|;
name|leftIndex
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
return|return
name|entry
return|;
block|}
DECL|method|removeEntryRight ()
specifier|public
name|E
name|removeEntryRight
parameter_list|()
block|{
assert|assert
operator|!
name|isEmpty
argument_list|()
assert|;
name|E
name|entry
init|=
name|entries
index|[
name|rightIndex
index|]
decl_stmt|;
name|entries
index|[
name|rightIndex
index|]
operator|=
literal|null
expr_stmt|;
name|rightIndex
operator|--
expr_stmt|;
name|size
operator|--
expr_stmt|;
return|return
name|entry
return|;
block|}
DECL|method|removeEntryAt (int index)
specifier|public
name|E
name|removeEntryAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
assert|assert
operator|!
name|isEmpty
argument_list|()
assert|;
name|E
name|entry
init|=
name|entries
index|[
name|index
index|]
decl_stmt|;
name|int
name|rightSize
init|=
name|rightIndex
operator|-
name|index
decl_stmt|;
name|int
name|leftSize
init|=
name|index
operator|-
name|leftIndex
decl_stmt|;
if|if
condition|(
name|rightSize
operator|<=
name|leftSize
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|entries
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|entries
argument_list|,
name|index
argument_list|,
name|rightSize
argument_list|)
expr_stmt|;
name|entries
index|[
name|rightIndex
index|]
operator|=
literal|null
expr_stmt|;
name|rightIndex
operator|--
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|entries
argument_list|,
name|leftIndex
argument_list|,
name|entries
argument_list|,
name|leftIndex
operator|+
literal|1
argument_list|,
name|leftSize
argument_list|)
expr_stmt|;
name|entries
index|[
name|leftIndex
index|]
operator|=
literal|null
expr_stmt|;
name|leftIndex
operator|++
expr_stmt|;
block|}
name|size
operator|--
expr_stmt|;
return|return
name|entry
return|;
block|}
DECL|method|isFull ()
specifier|public
name|boolean
name|isFull
parameter_list|()
block|{
return|return
name|size
operator|==
name|NODE_SIZE
return|;
block|}
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|size
operator|==
literal|0
return|;
block|}
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|leftIndex
operator|<
name|rightIndex
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|entries
argument_list|,
name|leftIndex
argument_list|,
name|rightIndex
operator|+
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
name|leftIndex
operator|=
literal|0
expr_stmt|;
name|rightIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|prev
operator|=
literal|null
expr_stmt|;
name|next
operator|=
literal|null
expr_stmt|;
name|parent
operator|=
literal|null
expr_stmt|;
name|left
operator|=
literal|null
expr_stmt|;
name|right
operator|=
literal|null
expr_stmt|;
name|color
operator|=
name|BLACK
expr_stmt|;
block|}
block|}
DECL|class|TreeSetIterator
specifier|private
specifier|static
specifier|final
class|class
name|TreeSetIterator
parameter_list|<
name|E
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|tree
specifier|private
specifier|final
name|FoldedTreeSet
argument_list|<
name|E
argument_list|>
name|tree
decl_stmt|;
DECL|field|iteratorModCount
specifier|private
name|int
name|iteratorModCount
decl_stmt|;
DECL|field|node
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|node
decl_stmt|;
DECL|field|index
specifier|private
name|int
name|index
decl_stmt|;
DECL|field|lastEntry
specifier|private
name|E
name|lastEntry
decl_stmt|;
DECL|field|lastIndex
specifier|private
name|int
name|lastIndex
decl_stmt|;
DECL|field|lastNode
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|lastNode
decl_stmt|;
DECL|method|TreeSetIterator (FoldedTreeSet<E> tree)
specifier|private
name|TreeSetIterator
parameter_list|(
name|FoldedTreeSet
argument_list|<
name|E
argument_list|>
name|tree
parameter_list|)
block|{
name|this
operator|.
name|tree
operator|=
name|tree
expr_stmt|;
name|this
operator|.
name|iteratorModCount
operator|=
name|tree
operator|.
name|modCount
expr_stmt|;
if|if
condition|(
operator|!
name|tree
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|node
operator|=
name|tree
operator|.
name|root
operator|.
name|getLeftMostNode
argument_list|()
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|this
operator|.
name|node
operator|.
name|leftIndex
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|checkForModification
argument_list|()
expr_stmt|;
return|return
name|node
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|E
name|next
parameter_list|()
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|lastEntry
operator|=
name|node
operator|.
name|entries
index|[
name|index
index|]
expr_stmt|;
name|lastIndex
operator|=
name|index
expr_stmt|;
name|lastNode
operator|=
name|node
expr_stmt|;
if|if
condition|(
operator|++
name|index
operator|>
name|node
operator|.
name|rightIndex
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|index
operator|=
name|node
operator|.
name|leftIndex
expr_stmt|;
block|}
block|}
return|return
name|lastEntry
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"Iterator exhausted"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|lastEntry
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No current element"
argument_list|)
throw|;
block|}
name|checkForModification
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastNode
operator|.
name|size
operator|==
literal|1
condition|)
block|{
comment|// Safe to remove lastNode, the iterator is on the next node
name|tree
operator|.
name|deleteNode
argument_list|(
name|lastNode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastNode
operator|.
name|leftIndex
operator|==
name|lastIndex
condition|)
block|{
comment|// Safe to remove leftmost entry, the iterator is on the next index
name|lastNode
operator|.
name|removeEntryLeft
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastNode
operator|.
name|rightIndex
operator|==
name|lastIndex
condition|)
block|{
comment|// Safe to remove the rightmost entry, the iterator is on the next node
name|lastNode
operator|.
name|removeEntryRight
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Remove entry in the middle of the array
assert|assert
name|node
operator|==
name|lastNode
assert|;
name|int
name|oldRIndex
init|=
name|lastNode
operator|.
name|rightIndex
decl_stmt|;
name|lastNode
operator|.
name|removeEntryAt
argument_list|(
name|lastIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldRIndex
operator|>
name|lastNode
operator|.
name|rightIndex
condition|)
block|{
comment|// Entries moved to the left in the array so index must be reset
name|index
operator|=
name|lastIndex
expr_stmt|;
block|}
block|}
name|lastEntry
operator|=
literal|null
expr_stmt|;
name|iteratorModCount
operator|++
expr_stmt|;
name|tree
operator|.
name|modCount
operator|++
expr_stmt|;
name|tree
operator|.
name|size
operator|--
expr_stmt|;
block|}
DECL|method|checkForModification ()
specifier|private
name|void
name|checkForModification
parameter_list|()
block|{
if|if
condition|(
name|iteratorModCount
operator|!=
name|tree
operator|.
name|modCount
condition|)
block|{
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|(
literal|"Tree has been modified "
operator|+
literal|"outside of iterator"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Create a new TreeSet that uses the natural ordering of objects. The element    * type must implement Comparable.    */
DECL|method|FoldedTreeSet ()
specifier|public
name|FoldedTreeSet
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new TreeSet that orders the elements using the supplied    * Comparator.    *    * @param comparator Comparator able to compare elements of type E    */
DECL|method|FoldedTreeSet (Comparator<E> comparator)
specifier|public
name|FoldedTreeSet
parameter_list|(
name|Comparator
argument_list|<
name|E
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
block|}
DECL|method|cachedOrNewNode (E entry)
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|cachedOrNewNode
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
operator|(
name|cachedNode
operator|!=
literal|null
operator|)
condition|?
name|cachedNode
else|:
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
name|cachedNode
operator|=
literal|null
expr_stmt|;
name|nodeCount
operator|++
expr_stmt|;
comment|// Since BlockIDs are always increasing for new blocks it is best to
comment|// add values on the left side to enable quicker inserts on the right
name|node
operator|.
name|addEntryLeft
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
DECL|method|cacheAndClear (Node<E> node)
specifier|private
name|void
name|cacheAndClear
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
if|if
condition|(
name|cachedNode
operator|==
literal|null
condition|)
block|{
name|node
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cachedNode
operator|=
name|node
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|comparator ()
specifier|public
name|Comparator
argument_list|<
name|?
super|super
name|E
argument_list|>
name|comparator
parameter_list|()
block|{
return|return
name|comparator
return|;
block|}
annotation|@
name|Override
DECL|method|subSet (E fromElement, E toElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|subSet
parameter_list|(
name|E
name|fromElement
parameter_list|,
name|E
name|toElement
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not supported yet."
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|headSet (E toElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|headSet
parameter_list|(
name|E
name|toElement
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not supported yet."
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|tailSet (E fromElement)
specifier|public
name|SortedSet
argument_list|<
name|E
argument_list|>
name|tailSet
parameter_list|(
name|E
name|fromElement
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not supported yet."
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|first ()
specifier|public
name|E
name|first
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|root
operator|.
name|getLeftMostNode
argument_list|()
decl_stmt|;
return|return
name|node
operator|.
name|entries
index|[
name|node
operator|.
name|leftIndex
index|]
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|last ()
specifier|public
name|E
name|last
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|root
operator|.
name|getRightMostNode
argument_list|()
decl_stmt|;
return|return
name|node
operator|.
name|entries
index|[
name|node
operator|.
name|rightIndex
index|]
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|root
operator|==
literal|null
return|;
block|}
comment|/**    * Lookup and return a stored object using a user provided comparator.    *    * @param obj Lookup key    * @param cmp User provided Comparator. The comparator should expect that the    *            proved obj will always be the first method parameter and any    *            stored object will be the second parameter.    *    * @return A matching stored object or null if non is found    */
DECL|method|get (Object obj, Comparator<?> cmp)
specifier|public
name|E
name|get
parameter_list|(
name|Object
name|obj
parameter_list|,
name|Comparator
argument_list|<
name|?
argument_list|>
name|cmp
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|root
decl_stmt|;
while|while
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|E
index|[]
name|entries
init|=
name|node
operator|.
name|entries
decl_stmt|;
name|int
name|leftIndex
init|=
name|node
operator|.
name|leftIndex
decl_stmt|;
name|int
name|result
init|=
name|compare
argument_list|(
name|obj
argument_list|,
name|entries
index|[
name|leftIndex
index|]
argument_list|,
name|cmp
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
return|return
name|entries
index|[
name|leftIndex
index|]
return|;
block|}
else|else
block|{
name|int
name|rightIndex
init|=
name|node
operator|.
name|rightIndex
decl_stmt|;
if|if
condition|(
name|leftIndex
operator|!=
name|rightIndex
condition|)
block|{
name|result
operator|=
name|compare
argument_list|(
name|obj
argument_list|,
name|entries
index|[
name|rightIndex
index|]
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
return|return
name|entries
index|[
name|rightIndex
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|right
expr_stmt|;
block|}
else|else
block|{
name|int
name|low
init|=
name|leftIndex
operator|+
literal|1
decl_stmt|;
name|int
name|high
init|=
name|rightIndex
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|result
operator|=
name|compare
argument_list|(
name|obj
argument_list|,
name|entries
index|[
name|mid
index|]
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
name|entries
index|[
name|mid
index|]
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Lookup and return a stored object.    *    * @param entry Lookup entry    *    * @return A matching stored object or null if non is found    */
DECL|method|get (E entry)
specifier|public
name|E
name|get
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|entry
argument_list|,
name|comparator
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|contains (Object obj)
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|get
argument_list|(
operator|(
name|E
operator|)
name|obj
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
DECL|method|compare (Object lookup, Object stored, Comparator cmp)
specifier|private
specifier|static
name|int
name|compare
parameter_list|(
name|Object
name|lookup
parameter_list|,
name|Object
name|stored
parameter_list|,
name|Comparator
name|cmp
parameter_list|)
block|{
return|return
name|cmp
operator|!=
literal|null
condition|?
name|cmp
operator|.
name|compare
argument_list|(
name|lookup
argument_list|,
name|stored
argument_list|)
else|:
operator|(
operator|(
name|Comparable
argument_list|<
name|Object
argument_list|>
operator|)
name|lookup
operator|)
operator|.
name|compareTo
argument_list|(
name|stored
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|TreeSetIterator
argument_list|<>
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toArray ()
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
name|Object
index|[]
name|objects
init|=
operator|new
name|Object
index|[
name|size
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|root
operator|.
name|getLeftMostNode
argument_list|()
init|;
name|node
operator|!=
literal|null
condition|;
name|pos
operator|+=
name|node
operator|.
name|size
operator|,
name|node
operator|=
name|node
operator|.
name|next
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|node
operator|.
name|entries
argument_list|,
name|node
operator|.
name|leftIndex
argument_list|,
name|objects
argument_list|,
name|pos
argument_list|,
name|node
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|objects
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|toArray (T[] a)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
name|T
index|[]
name|r
init|=
name|a
operator|.
name|length
operator|>=
name|size
condition|?
name|a
else|:
operator|(
name|T
index|[]
operator|)
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
operator|.
name|newInstance
argument_list|(
name|a
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|root
operator|.
name|getLeftMostNode
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|node
operator|.
name|entries
argument_list|,
name|node
operator|.
name|leftIndex
argument_list|,
name|r
argument_list|,
name|pos
argument_list|,
name|node
operator|.
name|size
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|node
operator|.
name|size
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|length
operator|>
name|pos
condition|)
block|{
name|r
index|[
name|pos
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|a
index|[
literal|0
index|]
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/**    * Add or replace an entry in the TreeSet.    *    * @param entry Entry to add or replace/update.    *    * @return the previous entry, or null if this set did not already contain the    *         specified entry    */
DECL|method|addOrReplace (E entry)
specifier|public
name|E
name|addOrReplace
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
return|return
name|add
argument_list|(
name|entry
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|add (E entry)
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
return|return
name|add
argument_list|(
name|entry
argument_list|,
literal|false
argument_list|)
operator|==
literal|null
return|;
block|}
comment|/**    * Internal add method to add a entry to the set.    *    * @param entry   Entry to add    * @param replace Should the entry replace an old entry which is equal to the    *                new entry    *    * @return null if entry added and didn't exist or the previous value (which    *         might not have been overwritten depending on the replace parameter)    */
DECL|method|add (E entry, boolean replace)
specifier|private
name|E
name|add
parameter_list|(
name|E
name|entry
parameter_list|,
name|boolean
name|replace
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|// Empty tree
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|root
operator|=
name|cachedOrNewNode
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
name|modCount
operator|++
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Compare right entry first since inserts of comperatively larger entries
comment|// is more likely to be inserted. BlockID is always increasing in HDFS.
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|root
decl_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|prevNode
init|=
literal|null
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|prevNode
operator|=
name|node
expr_stmt|;
name|E
index|[]
name|entries
init|=
name|node
operator|.
name|entries
decl_stmt|;
name|int
name|rightIndex
init|=
name|node
operator|.
name|rightIndex
decl_stmt|;
name|result
operator|=
name|compare
argument_list|(
name|entry
argument_list|,
name|entries
index|[
name|rightIndex
index|]
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|E
name|prevEntry
init|=
name|entries
index|[
name|rightIndex
index|]
decl_stmt|;
if|if
condition|(
name|replace
condition|)
block|{
name|entries
index|[
name|rightIndex
index|]
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|prevEntry
return|;
block|}
else|else
block|{
name|int
name|leftIndex
init|=
name|node
operator|.
name|leftIndex
decl_stmt|;
if|if
condition|(
name|leftIndex
operator|!=
name|rightIndex
condition|)
block|{
name|result
operator|=
name|compare
argument_list|(
name|entry
argument_list|,
name|entries
index|[
name|leftIndex
index|]
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|E
name|prevEntry
init|=
name|entries
index|[
name|leftIndex
index|]
decl_stmt|;
if|if
condition|(
name|replace
condition|)
block|{
name|entries
index|[
name|leftIndex
index|]
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|prevEntry
return|;
block|}
else|else
block|{
comment|// Insert in this node
name|int
name|low
init|=
name|leftIndex
operator|+
literal|1
decl_stmt|,
name|high
init|=
name|rightIndex
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|result
operator|=
name|compare
argument_list|(
name|entry
argument_list|,
name|entries
index|[
name|mid
index|]
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|E
name|prevEntry
init|=
name|entries
index|[
name|mid
index|]
decl_stmt|;
if|if
condition|(
name|replace
condition|)
block|{
name|entries
index|[
name|mid
index|]
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|prevEntry
return|;
block|}
else|else
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|addElementInNode
argument_list|(
name|node
argument_list|,
name|entry
argument_list|,
name|low
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
assert|assert
name|prevNode
operator|!=
literal|null
assert|;
name|size
operator|++
expr_stmt|;
name|modCount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|prevNode
operator|.
name|isFull
argument_list|()
condition|)
block|{
comment|// The previous node still has space
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|prevNode
operator|.
name|addEntryLeft
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prevNode
operator|.
name|addEntryRight
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|// The previous node is full, add to adjencent node or a new node
if|if
condition|(
name|prevNode
operator|.
name|prev
operator|!=
literal|null
operator|&&
operator|!
name|prevNode
operator|.
name|prev
operator|.
name|isFull
argument_list|()
condition|)
block|{
name|prevNode
operator|.
name|prev
operator|.
name|addEntryRight
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attachNodeLeft
argument_list|(
name|prevNode
argument_list|,
name|cachedOrNewNode
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prevNode
operator|.
name|next
operator|!=
literal|null
operator|&&
operator|!
name|prevNode
operator|.
name|next
operator|.
name|isFull
argument_list|()
condition|)
block|{
name|prevNode
operator|.
name|next
operator|.
name|addEntryLeft
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attachNodeRight
argument_list|(
name|prevNode
argument_list|,
name|cachedOrNewNode
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Insert an entry last in the sorted tree. The entry must be the considered    * larger than the currently largest entry in the set when doing    * current.compareTo(entry), if entry is not the largest entry the method will    * fall back on the regular add method.    *    * @param entry entry to add    *    * @return True if added, false if already existed in the set    */
DECL|method|addSortedLast (E entry)
specifier|public
name|boolean
name|addSortedLast
parameter_list|(
name|E
name|entry
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|root
operator|=
name|cachedOrNewNode
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
name|modCount
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|root
operator|.
name|getRightMostNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|node
operator|.
name|entries
index|[
name|node
operator|.
name|rightIndex
index|]
argument_list|,
name|entry
argument_list|,
name|comparator
argument_list|)
operator|<
literal|0
condition|)
block|{
name|size
operator|++
expr_stmt|;
name|modCount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|isFull
argument_list|()
condition|)
block|{
name|node
operator|.
name|addEntryRight
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attachNodeRight
argument_list|(
name|node
argument_list|,
name|cachedOrNewNode
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|// Fallback on normal add if entry is unsorted
return|return
name|add
argument_list|(
name|entry
argument_list|)
return|;
block|}
DECL|method|addElementInNode (Node<E> node, E entry, int index)
specifier|private
name|void
name|addElementInNode
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|,
name|E
name|entry
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|size
operator|++
expr_stmt|;
name|modCount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|isFull
argument_list|()
condition|)
block|{
name|node
operator|.
name|addEntryAt
argument_list|(
name|entry
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Node is full, insert and push old entry
name|Node
argument_list|<
name|E
argument_list|>
name|prev
init|=
name|node
operator|.
name|prev
decl_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|next
init|=
name|node
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
comment|// First check if we have space in the the next node
if|if
condition|(
name|next
operator|!=
literal|null
operator|&&
operator|!
name|next
operator|.
name|isFull
argument_list|()
condition|)
block|{
name|E
name|movedEntry
init|=
name|node
operator|.
name|insertEntrySlideRight
argument_list|(
name|entry
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|next
operator|.
name|addEntryLeft
argument_list|(
name|movedEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Since prev is null the left child must be null
assert|assert
name|node
operator|.
name|left
operator|==
literal|null
assert|;
name|E
name|movedEntry
init|=
name|node
operator|.
name|insertEntrySlideLeft
argument_list|(
name|entry
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
init|=
name|cachedOrNewNode
argument_list|(
name|movedEntry
argument_list|)
decl_stmt|;
name|attachNodeLeft
argument_list|(
name|node
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|prev
operator|.
name|isFull
argument_list|()
condition|)
block|{
comment|// Prev has space
name|E
name|movedEntry
init|=
name|node
operator|.
name|insertEntrySlideLeft
argument_list|(
name|entry
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|prev
operator|.
name|addEntryRight
argument_list|(
name|movedEntry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
comment|// Since next is null the right child must be null
assert|assert
name|node
operator|.
name|right
operator|==
literal|null
assert|;
name|E
name|movedEntry
init|=
name|node
operator|.
name|insertEntrySlideRight
argument_list|(
name|entry
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
init|=
name|cachedOrNewNode
argument_list|(
name|movedEntry
argument_list|)
decl_stmt|;
name|attachNodeRight
argument_list|(
name|node
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|next
operator|.
name|isFull
argument_list|()
condition|)
block|{
comment|// Next has space
name|E
name|movedEntry
init|=
name|node
operator|.
name|insertEntrySlideRight
argument_list|(
name|entry
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|next
operator|.
name|addEntryLeft
argument_list|(
name|movedEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Both prev and next nodes exist and are full
name|E
name|movedEntry
init|=
name|node
operator|.
name|insertEntrySlideRight
argument_list|(
name|entry
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
init|=
name|cachedOrNewNode
argument_list|(
name|movedEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|right
operator|==
literal|null
condition|)
block|{
name|attachNodeRight
argument_list|(
name|node
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Since our right node exist,
comment|// the left node of our next node must be empty
assert|assert
name|next
operator|.
name|left
operator|==
literal|null
assert|;
name|attachNodeLeft
argument_list|(
name|next
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|attachNodeLeft (Node<E> node, Node<E> newNode)
specifier|private
name|void
name|attachNodeLeft
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
parameter_list|)
block|{
name|newNode
operator|.
name|parent
operator|=
name|node
expr_stmt|;
name|node
operator|.
name|left
operator|=
name|newNode
expr_stmt|;
name|newNode
operator|.
name|next
operator|=
name|node
expr_stmt|;
name|newNode
operator|.
name|prev
operator|=
name|node
operator|.
name|prev
expr_stmt|;
if|if
condition|(
name|newNode
operator|.
name|prev
operator|!=
literal|null
condition|)
block|{
name|newNode
operator|.
name|prev
operator|.
name|next
operator|=
name|newNode
expr_stmt|;
block|}
name|node
operator|.
name|prev
operator|=
name|newNode
expr_stmt|;
name|balanceInsert
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
block|}
DECL|method|attachNodeRight (Node<E> node, Node<E> newNode)
specifier|private
name|void
name|attachNodeRight
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
parameter_list|)
block|{
name|newNode
operator|.
name|parent
operator|=
name|node
expr_stmt|;
name|node
operator|.
name|right
operator|=
name|newNode
expr_stmt|;
name|newNode
operator|.
name|prev
operator|=
name|node
expr_stmt|;
name|newNode
operator|.
name|next
operator|=
name|node
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|newNode
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
name|newNode
operator|.
name|next
operator|.
name|prev
operator|=
name|newNode
expr_stmt|;
block|}
name|node
operator|.
name|next
operator|=
name|newNode
expr_stmt|;
name|balanceInsert
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Balance the RB Tree after insert.    *    * @param node Added node    */
DECL|method|balanceInsert (Node<E> node)
specifier|private
name|void
name|balanceInsert
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
name|node
operator|.
name|color
operator|=
name|RED
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|root
operator|&&
name|node
operator|.
name|parent
operator|.
name|isRed
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|parent
operator|==
name|node
operator|.
name|parent
operator|.
name|parent
operator|.
name|left
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|uncle
init|=
name|node
operator|.
name|parent
operator|.
name|parent
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|uncle
operator|!=
literal|null
operator|&&
name|uncle
operator|.
name|isRed
argument_list|()
condition|)
block|{
name|node
operator|.
name|parent
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|uncle
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|node
operator|.
name|parent
operator|.
name|parent
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|parent
operator|.
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|==
name|node
operator|.
name|parent
operator|.
name|right
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|parent
expr_stmt|;
name|rotateLeft
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|parent
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|node
operator|.
name|parent
operator|.
name|parent
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|rotateRight
argument_list|(
name|node
operator|.
name|parent
operator|.
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|uncle
init|=
name|node
operator|.
name|parent
operator|.
name|parent
operator|.
name|left
decl_stmt|;
if|if
condition|(
name|uncle
operator|!=
literal|null
operator|&&
name|uncle
operator|.
name|isRed
argument_list|()
condition|)
block|{
name|node
operator|.
name|parent
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|uncle
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|node
operator|.
name|parent
operator|.
name|parent
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|parent
operator|.
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|==
name|node
operator|.
name|parent
operator|.
name|left
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|parent
expr_stmt|;
name|rotateRight
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|parent
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|node
operator|.
name|parent
operator|.
name|parent
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|rotateLeft
argument_list|(
name|node
operator|.
name|parent
operator|.
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|root
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
block|}
DECL|method|rotateRight (Node<E> node)
specifier|private
name|void
name|rotateRight
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|pivot
init|=
name|node
operator|.
name|left
decl_stmt|;
name|node
operator|.
name|left
operator|=
name|pivot
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|pivot
operator|.
name|right
operator|!=
literal|null
condition|)
block|{
name|pivot
operator|.
name|right
operator|.
name|parent
operator|=
name|node
expr_stmt|;
block|}
name|pivot
operator|.
name|parent
operator|=
name|node
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|parent
operator|==
literal|null
condition|)
block|{
name|root
operator|=
name|pivot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|==
name|node
operator|.
name|parent
operator|.
name|right
condition|)
block|{
name|node
operator|.
name|parent
operator|.
name|right
operator|=
name|pivot
expr_stmt|;
block|}
else|else
block|{
name|node
operator|.
name|parent
operator|.
name|left
operator|=
name|pivot
expr_stmt|;
block|}
name|pivot
operator|.
name|right
operator|=
name|node
expr_stmt|;
name|node
operator|.
name|parent
operator|=
name|pivot
expr_stmt|;
block|}
DECL|method|rotateLeft (Node<E> node)
specifier|private
name|void
name|rotateLeft
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|pivot
init|=
name|node
operator|.
name|right
decl_stmt|;
name|node
operator|.
name|right
operator|=
name|pivot
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|pivot
operator|.
name|left
operator|!=
literal|null
condition|)
block|{
name|pivot
operator|.
name|left
operator|.
name|parent
operator|=
name|node
expr_stmt|;
block|}
name|pivot
operator|.
name|parent
operator|=
name|node
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|parent
operator|==
literal|null
condition|)
block|{
name|root
operator|=
name|pivot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|==
name|node
operator|.
name|parent
operator|.
name|left
condition|)
block|{
name|node
operator|.
name|parent
operator|.
name|left
operator|=
name|pivot
expr_stmt|;
block|}
else|else
block|{
name|node
operator|.
name|parent
operator|.
name|right
operator|=
name|pivot
expr_stmt|;
block|}
name|pivot
operator|.
name|left
operator|=
name|node
expr_stmt|;
name|node
operator|.
name|parent
operator|=
name|pivot
expr_stmt|;
block|}
comment|/**    * Remove object using a provided comparator, and return the removed entry.    *    * @param obj Lookup entry    * @param cmp User provided Comparator. The comparator should expect that the    *            proved obj will always be the first method parameter and any    *            stored object will be the second parameter.    *    * @return The removed entry or null if not found    */
DECL|method|removeAndGet (Object obj, Comparator<?> cmp)
specifier|public
name|E
name|removeAndGet
parameter_list|(
name|Object
name|obj
parameter_list|,
name|Comparator
argument_list|<
name|?
argument_list|>
name|cmp
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|root
decl_stmt|;
while|while
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|E
index|[]
name|entries
init|=
name|node
operator|.
name|entries
decl_stmt|;
name|int
name|leftIndex
init|=
name|node
operator|.
name|leftIndex
decl_stmt|;
name|int
name|result
init|=
name|compare
argument_list|(
name|obj
argument_list|,
name|entries
index|[
name|leftIndex
index|]
argument_list|,
name|cmp
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
return|return
name|removeElementLeft
argument_list|(
name|node
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|rightIndex
init|=
name|node
operator|.
name|rightIndex
decl_stmt|;
if|if
condition|(
name|leftIndex
operator|!=
name|rightIndex
condition|)
block|{
name|result
operator|=
name|compare
argument_list|(
name|obj
argument_list|,
name|entries
index|[
name|rightIndex
index|]
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
return|return
name|removeElementRight
argument_list|(
name|node
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|right
expr_stmt|;
block|}
else|else
block|{
name|int
name|low
init|=
name|leftIndex
operator|+
literal|1
decl_stmt|,
name|high
init|=
name|rightIndex
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|result
operator|=
name|compare
argument_list|(
name|obj
argument_list|,
name|entries
index|[
name|mid
index|]
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
return|return
name|removeElementAt
argument_list|(
name|node
argument_list|,
name|mid
argument_list|)
return|;
block|}
else|else
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Remove object and return the removed entry.    *    * @param obj Lookup entry    *    * @return The removed entry or null if not found    */
DECL|method|removeAndGet (Object obj)
specifier|public
name|E
name|removeAndGet
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|removeAndGet
argument_list|(
name|obj
argument_list|,
name|comparator
argument_list|)
return|;
block|}
comment|/**    * Remove object using a provided comparator.    *    * @param obj Lookup entry    * @param cmp User provided Comparator. The comparator should expect that the    *            proved obj will always be the first method parameter and any    *            stored object will be the second parameter.    *    * @return True if found and removed, else false    */
DECL|method|remove (Object obj, Comparator<?> cmp)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|obj
parameter_list|,
name|Comparator
argument_list|<
name|?
argument_list|>
name|cmp
parameter_list|)
block|{
return|return
name|removeAndGet
argument_list|(
name|obj
argument_list|,
name|cmp
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|remove (Object obj)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|removeAndGet
argument_list|(
name|obj
argument_list|,
name|comparator
argument_list|)
operator|!=
literal|null
return|;
block|}
DECL|method|removeElementLeft (Node<E> node)
specifier|private
name|E
name|removeElementLeft
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
name|modCount
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
name|E
name|entry
init|=
name|node
operator|.
name|removeEntryLeft
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|deleteNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|prev
operator|!=
literal|null
operator|&&
operator|(
name|Node
operator|.
name|NODE_SIZE
operator|-
literal|1
operator|-
name|node
operator|.
name|prev
operator|.
name|rightIndex
operator|)
operator|>=
name|node
operator|.
name|size
condition|)
block|{
comment|// Remaining entries fit in the prev node, move them and delete this node
name|node
operator|.
name|prev
operator|.
name|addEntriesRight
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|next
operator|!=
literal|null
operator|&&
name|node
operator|.
name|next
operator|.
name|leftIndex
operator|>=
name|node
operator|.
name|size
condition|)
block|{
comment|// Remaining entries fit in the next node, move them and delete this node
name|node
operator|.
name|next
operator|.
name|addEntriesLeft
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|prev
operator|!=
literal|null
operator|&&
name|node
operator|.
name|prev
operator|.
name|size
operator|<
name|node
operator|.
name|leftIndex
condition|)
block|{
comment|// Entries in prev node will fit in this node, move them and delete prev
name|node
operator|.
name|addEntriesLeft
argument_list|(
name|node
operator|.
name|prev
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
operator|.
name|prev
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
DECL|method|removeElementRight (Node<E> node)
specifier|private
name|E
name|removeElementRight
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
name|modCount
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
name|E
name|entry
init|=
name|node
operator|.
name|removeEntryRight
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|deleteNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|prev
operator|!=
literal|null
operator|&&
operator|(
name|Node
operator|.
name|NODE_SIZE
operator|-
literal|1
operator|-
name|node
operator|.
name|prev
operator|.
name|rightIndex
operator|)
operator|>=
name|node
operator|.
name|size
condition|)
block|{
comment|// Remaining entries fit in the prev node, move them and delete this node
name|node
operator|.
name|prev
operator|.
name|addEntriesRight
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|next
operator|!=
literal|null
operator|&&
name|node
operator|.
name|next
operator|.
name|leftIndex
operator|>=
name|node
operator|.
name|size
condition|)
block|{
comment|// Remaining entries fit in the next node, move them and delete this node
name|node
operator|.
name|next
operator|.
name|addEntriesLeft
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|next
operator|!=
literal|null
operator|&&
name|node
operator|.
name|next
operator|.
name|size
operator|<
operator|(
name|Node
operator|.
name|NODE_SIZE
operator|-
literal|1
operator|-
name|node
operator|.
name|rightIndex
operator|)
condition|)
block|{
comment|// Entries in next node will fit in this node, move them and delete next
name|node
operator|.
name|addEntriesRight
argument_list|(
name|node
operator|.
name|next
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
DECL|method|removeElementAt (Node<E> node, int index)
specifier|private
name|E
name|removeElementAt
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|modCount
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
name|E
name|entry
init|=
name|node
operator|.
name|removeEntryAt
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|prev
operator|!=
literal|null
operator|&&
operator|(
name|Node
operator|.
name|NODE_SIZE
operator|-
literal|1
operator|-
name|node
operator|.
name|prev
operator|.
name|rightIndex
operator|)
operator|>=
name|node
operator|.
name|size
condition|)
block|{
comment|// Remaining entries fit in the prev node, move them and delete this node
name|node
operator|.
name|prev
operator|.
name|addEntriesRight
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|next
operator|!=
literal|null
operator|&&
operator|(
name|node
operator|.
name|next
operator|.
name|leftIndex
operator|)
operator|>=
name|node
operator|.
name|size
condition|)
block|{
comment|// Remaining entries fit in the next node, move them and delete this node
name|node
operator|.
name|next
operator|.
name|addEntriesLeft
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|prev
operator|!=
literal|null
operator|&&
name|node
operator|.
name|prev
operator|.
name|size
operator|<
name|node
operator|.
name|leftIndex
condition|)
block|{
comment|// Entries in prev node will fit in this node, move them and delete prev
name|node
operator|.
name|addEntriesLeft
argument_list|(
name|node
operator|.
name|prev
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
operator|.
name|prev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|next
operator|!=
literal|null
operator|&&
name|node
operator|.
name|next
operator|.
name|size
operator|<
operator|(
name|Node
operator|.
name|NODE_SIZE
operator|-
literal|1
operator|-
name|node
operator|.
name|rightIndex
operator|)
condition|)
block|{
comment|// Entries in next node will fit in this node, move them and delete next
name|node
operator|.
name|addEntriesRight
argument_list|(
name|node
operator|.
name|next
argument_list|)
expr_stmt|;
name|deleteNode
argument_list|(
name|node
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
comment|/**    * Delete the node and ensure the tree is balanced.    *    * @param node node to delete    */
DECL|method|deleteNode (final Node<E> node)
specifier|private
name|void
name|deleteNode
parameter_list|(
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|right
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|left
operator|!=
literal|null
condition|)
block|{
name|attachToParent
argument_list|(
name|node
argument_list|,
name|node
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attachNullToParent
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|left
operator|==
literal|null
condition|)
block|{
name|attachToParent
argument_list|(
name|node
argument_list|,
name|node
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// node.left != null&& node.right != null
comment|// node.next should replace node in tree
comment|// node.next != null guaranteed since node.left != null
comment|// node.next.left == null since node.next.prev is node
comment|// node.next.right may be null or non-null
name|Node
argument_list|<
name|E
argument_list|>
name|toMoveUp
init|=
name|node
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|toMoveUp
operator|.
name|right
operator|==
literal|null
condition|)
block|{
name|attachNullToParent
argument_list|(
name|toMoveUp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attachToParent
argument_list|(
name|toMoveUp
argument_list|,
name|toMoveUp
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
name|toMoveUp
operator|.
name|left
operator|=
name|node
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|toMoveUp
operator|.
name|left
operator|!=
literal|null
condition|)
block|{
name|toMoveUp
operator|.
name|left
operator|.
name|parent
operator|=
name|toMoveUp
expr_stmt|;
block|}
name|toMoveUp
operator|.
name|right
operator|=
name|node
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|toMoveUp
operator|.
name|right
operator|!=
literal|null
condition|)
block|{
name|toMoveUp
operator|.
name|right
operator|.
name|parent
operator|=
name|toMoveUp
expr_stmt|;
block|}
name|attachToParentNoBalance
argument_list|(
name|node
argument_list|,
name|toMoveUp
argument_list|)
expr_stmt|;
name|toMoveUp
operator|.
name|color
operator|=
name|node
operator|.
name|color
expr_stmt|;
block|}
comment|// Remove node from ordered list of nodes
if|if
condition|(
name|node
operator|.
name|prev
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|prev
operator|.
name|next
operator|=
name|node
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|next
operator|.
name|prev
operator|=
name|node
operator|.
name|prev
expr_stmt|;
block|}
name|nodeCount
operator|--
expr_stmt|;
name|cacheAndClear
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
DECL|method|attachToParentNoBalance (Node<E> toDelete, Node<E> toConnect)
specifier|private
name|void
name|attachToParentNoBalance
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|toDelete
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|toConnect
parameter_list|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|parent
init|=
name|toDelete
operator|.
name|parent
decl_stmt|;
name|toConnect
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|root
operator|=
name|toConnect
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toDelete
operator|==
name|parent
operator|.
name|left
condition|)
block|{
name|parent
operator|.
name|left
operator|=
name|toConnect
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|.
name|right
operator|=
name|toConnect
expr_stmt|;
block|}
block|}
DECL|method|attachToParent (Node<E> toDelete, Node<E> toConnect)
specifier|private
name|void
name|attachToParent
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|toDelete
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|toConnect
parameter_list|)
block|{
name|attachToParentNoBalance
argument_list|(
name|toDelete
argument_list|,
name|toConnect
argument_list|)
expr_stmt|;
if|if
condition|(
name|toDelete
operator|.
name|isBlack
argument_list|()
condition|)
block|{
name|balanceDelete
argument_list|(
name|toConnect
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|attachNullToParent (Node<E> toDelete)
specifier|private
name|void
name|attachNullToParent
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|toDelete
parameter_list|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|parent
init|=
name|toDelete
operator|.
name|parent
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|root
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|toDelete
operator|==
name|parent
operator|.
name|left
condition|)
block|{
name|parent
operator|.
name|left
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|.
name|right
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|toDelete
operator|.
name|isBlack
argument_list|()
condition|)
block|{
name|balanceDelete
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Balance tree after removing a node.    *    * @param node Node to balance after deleting another node    */
DECL|method|balanceDelete (Node<E> node)
specifier|private
name|void
name|balanceDelete
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|node
parameter_list|)
block|{
while|while
condition|(
name|node
operator|!=
name|root
operator|&&
name|node
operator|.
name|isBlack
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|==
name|node
operator|.
name|parent
operator|.
name|left
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|sibling
init|=
name|node
operator|.
name|parent
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|sibling
operator|==
literal|null
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|parent
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sibling
operator|.
name|isRed
argument_list|()
condition|)
block|{
name|sibling
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|node
operator|.
name|parent
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|rotateLeft
argument_list|(
name|node
operator|.
name|parent
argument_list|)
expr_stmt|;
name|sibling
operator|=
name|node
operator|.
name|parent
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|sibling
operator|==
literal|null
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|parent
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|sibling
operator|.
name|left
operator|==
literal|null
operator|||
operator|!
name|sibling
operator|.
name|left
operator|.
name|isRed
argument_list|()
operator|)
operator|&&
operator|(
name|sibling
operator|.
name|right
operator|==
literal|null
operator|||
operator|!
name|sibling
operator|.
name|right
operator|.
name|isRed
argument_list|()
operator|)
condition|)
block|{
name|sibling
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sibling
operator|.
name|right
operator|==
literal|null
operator|||
operator|!
name|sibling
operator|.
name|right
operator|.
name|isRed
argument_list|()
condition|)
block|{
name|sibling
operator|.
name|left
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|sibling
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|rotateRight
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
name|sibling
operator|=
name|node
operator|.
name|parent
operator|.
name|right
expr_stmt|;
block|}
name|sibling
operator|.
name|color
operator|=
name|node
operator|.
name|parent
operator|.
name|color
expr_stmt|;
name|node
operator|.
name|parent
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|sibling
operator|.
name|right
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|rotateLeft
argument_list|(
name|node
operator|.
name|parent
argument_list|)
expr_stmt|;
name|node
operator|=
name|root
expr_stmt|;
block|}
block|}
else|else
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|sibling
init|=
name|node
operator|.
name|parent
operator|.
name|left
decl_stmt|;
if|if
condition|(
name|sibling
operator|==
literal|null
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|parent
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sibling
operator|.
name|isRed
argument_list|()
condition|)
block|{
name|sibling
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|node
operator|.
name|parent
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|rotateRight
argument_list|(
name|node
operator|.
name|parent
argument_list|)
expr_stmt|;
name|sibling
operator|=
name|node
operator|.
name|parent
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|sibling
operator|==
literal|null
condition|)
block|{
name|node
operator|=
name|node
operator|.
name|parent
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|sibling
operator|.
name|left
operator|==
literal|null
operator|||
name|sibling
operator|.
name|left
operator|.
name|isBlack
argument_list|()
operator|)
operator|&&
operator|(
name|sibling
operator|.
name|right
operator|==
literal|null
operator|||
name|sibling
operator|.
name|right
operator|.
name|isBlack
argument_list|()
operator|)
condition|)
block|{
name|sibling
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sibling
operator|.
name|left
operator|==
literal|null
operator|||
name|sibling
operator|.
name|left
operator|.
name|isBlack
argument_list|()
condition|)
block|{
name|sibling
operator|.
name|right
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|sibling
operator|.
name|color
operator|=
name|RED
expr_stmt|;
name|rotateLeft
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
name|sibling
operator|=
name|node
operator|.
name|parent
operator|.
name|left
expr_stmt|;
block|}
name|sibling
operator|.
name|color
operator|=
name|node
operator|.
name|parent
operator|.
name|color
expr_stmt|;
name|node
operator|.
name|parent
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|sibling
operator|.
name|left
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
name|rotateRight
argument_list|(
name|node
operator|.
name|parent
argument_list|)
expr_stmt|;
name|node
operator|=
name|root
expr_stmt|;
block|}
block|}
block|}
name|node
operator|.
name|color
operator|=
name|BLACK
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|containsAll (Collection<?> c)
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
for|for
control|(
name|Object
name|entry
range|:
name|c
control|)
block|{
if|if
condition|(
operator|!
name|contains
argument_list|(
name|entry
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|addAll (Collection<? extends E> c)
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|E
name|entry
range|:
name|c
control|)
block|{
if|if
condition|(
name|add
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
annotation|@
name|Override
DECL|method|retainAll (Collection<?> c)
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|E
argument_list|>
name|it
init|=
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|.
name|contains
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
annotation|@
name|Override
DECL|method|removeAll (Collection<?> c)
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Object
name|entry
range|:
name|c
control|)
block|{
if|if
condition|(
name|remove
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
annotation|@
name|Override
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|modCount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
name|nodeCount
operator|=
literal|0
expr_stmt|;
name|cacheAndClear
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Returns the current size divided by the capacity of the tree. A value    * between 0.0 and 1.0, where 1.0 means that every allocated node in the tree    * is completely full.    *    * An empty set will return 1.0    *    * @return the fill ratio of the tree    */
DECL|method|fillRatio ()
specifier|public
name|double
name|fillRatio
parameter_list|()
block|{
if|if
condition|(
name|nodeCount
operator|>
literal|1
condition|)
block|{
comment|// Count the last node as completely full since it can't be compacted
return|return
operator|(
name|size
operator|+
operator|(
name|Node
operator|.
name|NODE_SIZE
operator|-
name|root
operator|.
name|getRightMostNode
argument_list|()
operator|.
name|size
operator|)
operator|)
operator|/
call|(
name|double
call|)
argument_list|(
name|nodeCount
operator|*
name|Node
operator|.
name|NODE_SIZE
argument_list|)
return|;
block|}
return|return
literal|1.0
return|;
block|}
comment|/**    * Compact all the entries to use the fewest number of nodes in the tree.    *    * Having a compact tree minimize memory usage, but can cause inserts to get    * slower due to new nodes needs to be allocated as there is no space in any    * of the existing nodes anymore for entries added in the middle of the set.    *    * Useful to do to reduce memory consumption and if the tree is know to not    * change after compaction or mainly added to at either extreme.    *    * @param timeout Maximum time to spend compacting the tree set in    *                milliseconds.    *    * @return true if compaction completed, false if aborted    */
DECL|method|compact (long timeout)
specifier|public
name|boolean
name|compact
parameter_list|(
name|long
name|timeout
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
name|long
name|start
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|node
init|=
name|root
operator|.
name|getLeftMostNode
argument_list|()
decl_stmt|;
while|while
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|prev
operator|!=
literal|null
operator|&&
operator|!
name|node
operator|.
name|prev
operator|.
name|isFull
argument_list|()
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|prev
init|=
name|node
operator|.
name|prev
decl_stmt|;
name|int
name|count
init|=
name|Math
operator|.
name|min
argument_list|(
name|Node
operator|.
name|NODE_SIZE
operator|-
name|prev
operator|.
name|size
argument_list|,
name|node
operator|.
name|size
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|node
operator|.
name|entries
argument_list|,
name|node
operator|.
name|leftIndex
argument_list|,
name|prev
operator|.
name|entries
argument_list|,
name|prev
operator|.
name|rightIndex
operator|+
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|node
operator|.
name|leftIndex
operator|+=
name|count
expr_stmt|;
name|node
operator|.
name|size
operator|-=
name|count
expr_stmt|;
name|prev
operator|.
name|rightIndex
operator|+=
name|count
expr_stmt|;
name|prev
operator|.
name|size
operator|+=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|temp
init|=
name|node
operator|.
name|next
decl_stmt|;
name|deleteNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|temp
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|node
operator|.
name|isFull
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|leftIndex
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|node
operator|.
name|entries
argument_list|,
name|node
operator|.
name|leftIndex
argument_list|,
name|node
operator|.
name|entries
argument_list|,
literal|0
argument_list|,
name|node
operator|.
name|size
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|node
operator|.
name|entries
argument_list|,
name|node
operator|.
name|size
argument_list|,
name|node
operator|.
name|rightIndex
operator|+
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|node
operator|.
name|leftIndex
operator|=
literal|0
expr_stmt|;
name|node
operator|.
name|rightIndex
operator|=
name|node
operator|.
name|size
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|node
operator|=
name|node
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|start
operator|>
name|timeout
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

