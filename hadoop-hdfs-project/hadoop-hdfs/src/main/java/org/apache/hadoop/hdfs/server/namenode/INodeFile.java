begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoUnderConstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|FileDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|FileDiffList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|FileWithSnapshotFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/** I-node for closed file. */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|INodeFile
specifier|public
class|class
name|INodeFile
extends|extends
name|INodeWithAdditionalFields
implements|implements
name|INodeFileAttributes
implements|,
name|BlockCollection
block|{
comment|/**    * A feature contains specific information for a type of INodeFile. E.g.,    * we can have separate features for Under-Construction and Snapshot.    */
DECL|class|Feature
specifier|public
specifier|static
specifier|abstract
class|class
name|Feature
implements|implements
name|INode
operator|.
name|Feature
argument_list|<
name|Feature
argument_list|>
block|{
DECL|field|nextFeature
specifier|private
name|Feature
name|nextFeature
decl_stmt|;
annotation|@
name|Override
DECL|method|getNextFeature ()
specifier|public
name|Feature
name|getNextFeature
parameter_list|()
block|{
return|return
name|nextFeature
return|;
block|}
annotation|@
name|Override
DECL|method|setNextFeature (Feature next)
specifier|public
name|void
name|setNextFeature
parameter_list|(
name|Feature
name|next
parameter_list|)
block|{
name|this
operator|.
name|nextFeature
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/** The same as valueOf(inode, path, false). */
DECL|method|valueOf (INode inode, String path )
specifier|public
specifier|static
name|INodeFile
name|valueOf
parameter_list|(
name|INode
name|inode
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
return|return
name|valueOf
argument_list|(
name|inode
argument_list|,
name|path
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Cast INode to INodeFile. */
DECL|method|valueOf (INode inode, String path, boolean acceptNull)
specifier|public
specifier|static
name|INodeFile
name|valueOf
parameter_list|(
name|INode
name|inode
parameter_list|,
name|String
name|path
parameter_list|,
name|boolean
name|acceptNull
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|acceptNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Path is not a file: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|inode
operator|.
name|asFile
argument_list|()
return|;
block|}
comment|/** Format: [16 bits for replication][48 bits for PreferredBlockSize] */
DECL|class|HeaderFormat
specifier|static
class|class
name|HeaderFormat
block|{
comment|/** Number of bits for Block size */
DECL|field|BLOCKBITS
specifier|static
specifier|final
name|int
name|BLOCKBITS
init|=
literal|48
decl_stmt|;
comment|/** Header mask 64-bit representation */
DECL|field|HEADERMASK
specifier|static
specifier|final
name|long
name|HEADERMASK
init|=
literal|0xffffL
operator|<<
name|BLOCKBITS
decl_stmt|;
DECL|field|MAX_BLOCK_SIZE
specifier|static
specifier|final
name|long
name|MAX_BLOCK_SIZE
init|=
operator|~
name|HEADERMASK
decl_stmt|;
DECL|method|getReplication (long header)
specifier|static
name|short
name|getReplication
parameter_list|(
name|long
name|header
parameter_list|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
operator|(
name|header
operator|&
name|HEADERMASK
operator|)
operator|>>
name|BLOCKBITS
argument_list|)
return|;
block|}
DECL|method|combineReplication (long header, short replication)
specifier|static
name|long
name|combineReplication
parameter_list|(
name|long
name|header
parameter_list|,
name|short
name|replication
parameter_list|)
block|{
if|if
condition|(
name|replication
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected value for the replication: "
operator|+
name|replication
argument_list|)
throw|;
block|}
return|return
operator|(
operator|(
name|long
operator|)
name|replication
operator|<<
name|BLOCKBITS
operator|)
operator||
operator|(
name|header
operator|&
name|MAX_BLOCK_SIZE
operator|)
return|;
block|}
DECL|method|getPreferredBlockSize (long header)
specifier|static
name|long
name|getPreferredBlockSize
parameter_list|(
name|long
name|header
parameter_list|)
block|{
return|return
name|header
operator|&
name|MAX_BLOCK_SIZE
return|;
block|}
DECL|method|combinePreferredBlockSize (long header, long blockSize)
specifier|static
name|long
name|combinePreferredBlockSize
parameter_list|(
name|long
name|header
parameter_list|,
name|long
name|blockSize
parameter_list|)
block|{
if|if
condition|(
name|blockSize
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Block size< 0: "
operator|+
name|blockSize
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|blockSize
operator|>
name|MAX_BLOCK_SIZE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Block size = "
operator|+
name|blockSize
operator|+
literal|"> MAX_BLOCK_SIZE = "
operator|+
name|MAX_BLOCK_SIZE
argument_list|)
throw|;
block|}
return|return
operator|(
name|header
operator|&
name|HEADERMASK
operator|)
operator||
operator|(
name|blockSize
operator|&
name|MAX_BLOCK_SIZE
operator|)
return|;
block|}
block|}
DECL|field|header
specifier|private
name|long
name|header
init|=
literal|0L
decl_stmt|;
DECL|field|blocks
specifier|private
name|BlockInfo
index|[]
name|blocks
decl_stmt|;
DECL|field|headFeature
specifier|private
name|Feature
name|headFeature
decl_stmt|;
DECL|method|INodeFile (long id, byte[] name, PermissionStatus permissions, long mtime, long atime, BlockInfo[] blklist, short replication, long preferredBlockSize)
name|INodeFile
parameter_list|(
name|long
name|id
parameter_list|,
name|byte
index|[]
name|name
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|BlockInfo
index|[]
name|blklist
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|)
block|{
name|super
argument_list|(
name|id
argument_list|,
name|name
argument_list|,
name|permissions
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
name|header
operator|=
name|HeaderFormat
operator|.
name|combineReplication
argument_list|(
name|header
argument_list|,
name|replication
argument_list|)
expr_stmt|;
name|header
operator|=
name|HeaderFormat
operator|.
name|combinePreferredBlockSize
argument_list|(
name|header
argument_list|,
name|preferredBlockSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|blocks
operator|=
name|blklist
expr_stmt|;
block|}
DECL|method|INodeFile (INodeFile that)
specifier|public
name|INodeFile
parameter_list|(
name|INodeFile
name|that
parameter_list|)
block|{
name|super
argument_list|(
name|that
argument_list|)
expr_stmt|;
name|this
operator|.
name|header
operator|=
name|that
operator|.
name|header
expr_stmt|;
name|this
operator|.
name|blocks
operator|=
name|that
operator|.
name|blocks
expr_stmt|;
name|this
operator|.
name|headFeature
operator|=
name|that
operator|.
name|headFeature
expr_stmt|;
block|}
DECL|method|INodeFile (INodeFile that, FileDiffList diffs)
specifier|public
name|INodeFile
parameter_list|(
name|INodeFile
name|that
parameter_list|,
name|FileDiffList
name|diffs
parameter_list|)
block|{
name|this
argument_list|(
name|that
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|that
operator|.
name|isWithSnapshot
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|addSnapshotFeature
argument_list|(
name|diffs
argument_list|)
expr_stmt|;
block|}
DECL|method|addFeature (Feature f)
specifier|private
name|void
name|addFeature
parameter_list|(
name|Feature
name|f
parameter_list|)
block|{
name|headFeature
operator|=
name|INode
operator|.
name|Feature
operator|.
name|Util
operator|.
name|addFeature
argument_list|(
name|f
argument_list|,
name|headFeature
argument_list|)
expr_stmt|;
block|}
DECL|method|removeFeature (Feature f)
specifier|private
name|void
name|removeFeature
parameter_list|(
name|Feature
name|f
parameter_list|)
block|{
name|headFeature
operator|=
name|INode
operator|.
name|Feature
operator|.
name|Util
operator|.
name|removeFeature
argument_list|(
name|f
argument_list|,
name|headFeature
argument_list|)
expr_stmt|;
block|}
comment|/** @return true unconditionally. */
annotation|@
name|Override
DECL|method|isFile ()
specifier|public
specifier|final
name|boolean
name|isFile
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** @return this object. */
annotation|@
name|Override
DECL|method|asFile ()
specifier|public
specifier|final
name|INodeFile
name|asFile
parameter_list|()
block|{
return|return
name|this
return|;
block|}
comment|/* Start of Under-Construction Feature */
comment|/**    * If the inode contains a {@link FileUnderConstructionFeature}, return it;    * otherwise, return null.    */
DECL|method|getFileUnderConstructionFeature ()
specifier|public
specifier|final
name|FileUnderConstructionFeature
name|getFileUnderConstructionFeature
parameter_list|()
block|{
for|for
control|(
name|Feature
name|f
init|=
name|this
operator|.
name|headFeature
init|;
name|f
operator|!=
literal|null
condition|;
name|f
operator|=
name|f
operator|.
name|nextFeature
control|)
block|{
if|if
condition|(
name|f
operator|instanceof
name|FileUnderConstructionFeature
condition|)
block|{
return|return
operator|(
name|FileUnderConstructionFeature
operator|)
name|f
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** Is this file under construction? */
annotation|@
name|Override
comment|// BlockCollection
DECL|method|isUnderConstruction ()
specifier|public
name|boolean
name|isUnderConstruction
parameter_list|()
block|{
return|return
name|getFileUnderConstructionFeature
argument_list|()
operator|!=
literal|null
return|;
block|}
comment|/** Convert this file to an {@link INodeFileUnderConstruction}. */
DECL|method|toUnderConstruction (String clientName, String clientMachine, DatanodeDescriptor clientNode)
name|INodeFile
name|toUnderConstruction
parameter_list|(
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|,
name|DatanodeDescriptor
name|clientNode
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|isUnderConstruction
argument_list|()
argument_list|,
literal|"file is already under construction"
argument_list|)
expr_stmt|;
name|FileUnderConstructionFeature
name|uc
init|=
operator|new
name|FileUnderConstructionFeature
argument_list|(
name|clientName
argument_list|,
name|clientMachine
argument_list|,
name|clientNode
argument_list|)
decl_stmt|;
name|addFeature
argument_list|(
name|uc
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Convert the file to a complete file, i.e., to remove the Under-Construction    * feature.    */
DECL|method|toCompleteFile (long mtime)
specifier|public
name|INodeFile
name|toCompleteFile
parameter_list|(
name|long
name|mtime
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isUnderConstruction
argument_list|()
argument_list|,
literal|"file is no longer under construction"
argument_list|)
expr_stmt|;
name|FileUnderConstructionFeature
name|uc
init|=
name|getFileUnderConstructionFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|null
condition|)
block|{
name|assertAllBlocksComplete
argument_list|()
expr_stmt|;
name|removeFeature
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|this
operator|.
name|setModificationTime
argument_list|(
name|mtime
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Assert all blocks are complete. */
DECL|method|assertAllBlocksComplete ()
specifier|private
name|void
name|assertAllBlocksComplete
parameter_list|()
block|{
if|if
condition|(
name|blocks
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|blocks
index|[
name|i
index|]
operator|.
name|isComplete
argument_list|()
argument_list|,
literal|"Failed to finalize"
operator|+
literal|" %s %s since blocks[%s] is non-complete, where blocks=%s."
argument_list|,
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|this
argument_list|,
name|i
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// BlockCollection
DECL|method|setBlock (int index, BlockInfo blk)
specifier|public
name|void
name|setBlock
parameter_list|(
name|int
name|index
parameter_list|,
name|BlockInfo
name|blk
parameter_list|)
block|{
name|this
operator|.
name|blocks
index|[
name|index
index|]
operator|=
name|blk
expr_stmt|;
block|}
annotation|@
name|Override
comment|// BlockCollection, the file should be under construction
DECL|method|setLastBlock (BlockInfo lastBlock, DatanodeDescriptor[] locations)
specifier|public
name|BlockInfoUnderConstruction
name|setLastBlock
parameter_list|(
name|BlockInfo
name|lastBlock
parameter_list|,
name|DatanodeDescriptor
index|[]
name|locations
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isUnderConstruction
argument_list|()
argument_list|,
literal|"file is no longer under construction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numBlocks
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to set last block: File is empty."
argument_list|)
throw|;
block|}
name|BlockInfoUnderConstruction
name|ucBlock
init|=
name|lastBlock
operator|.
name|convertToBlockUnderConstruction
argument_list|(
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
argument_list|,
name|locations
argument_list|)
decl_stmt|;
name|ucBlock
operator|.
name|setBlockCollection
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setBlock
argument_list|(
name|numBlocks
argument_list|()
operator|-
literal|1
argument_list|,
name|ucBlock
argument_list|)
expr_stmt|;
return|return
name|ucBlock
return|;
block|}
comment|/**    * Remove a block from the block list. This block should be    * the last one on the list.    */
DECL|method|removeLastBlock (Block oldblock)
name|boolean
name|removeLastBlock
parameter_list|(
name|Block
name|oldblock
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isUnderConstruction
argument_list|()
argument_list|,
literal|"file is no longer under construction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks
operator|==
literal|null
operator|||
name|blocks
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|size_1
init|=
name|blocks
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|blocks
index|[
name|size_1
index|]
operator|.
name|equals
argument_list|(
name|oldblock
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//copy to a new list
name|BlockInfo
index|[]
name|newlist
init|=
operator|new
name|BlockInfo
index|[
name|size_1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|blocks
argument_list|,
literal|0
argument_list|,
name|newlist
argument_list|,
literal|0
argument_list|,
name|size_1
argument_list|)
expr_stmt|;
name|setBlocks
argument_list|(
name|newlist
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/* End of Under-Construction Feature */
comment|/* Start of Snapshot Feature */
DECL|method|addSnapshotFeature (FileDiffList diffs)
specifier|private
name|FileWithSnapshotFeature
name|addSnapshotFeature
parameter_list|(
name|FileDiffList
name|diffs
parameter_list|)
block|{
name|FileWithSnapshotFeature
name|sf
init|=
operator|new
name|FileWithSnapshotFeature
argument_list|(
name|diffs
argument_list|)
decl_stmt|;
name|this
operator|.
name|addFeature
argument_list|(
name|sf
argument_list|)
expr_stmt|;
return|return
name|sf
return|;
block|}
comment|/**    * If feature list contains a {@link FileWithSnapshotFeature}, return it;    * otherwise, return null.    */
DECL|method|getFileWithSnapshotFeature ()
specifier|public
specifier|final
name|FileWithSnapshotFeature
name|getFileWithSnapshotFeature
parameter_list|()
block|{
for|for
control|(
name|Feature
name|f
init|=
name|headFeature
init|;
name|f
operator|!=
literal|null
condition|;
name|f
operator|=
name|f
operator|.
name|nextFeature
control|)
block|{
if|if
condition|(
name|f
operator|instanceof
name|FileWithSnapshotFeature
condition|)
block|{
return|return
operator|(
name|FileWithSnapshotFeature
operator|)
name|f
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** Is this file has the snapshot feature? */
DECL|method|isWithSnapshot ()
specifier|public
specifier|final
name|boolean
name|isWithSnapshot
parameter_list|()
block|{
return|return
name|getFileWithSnapshotFeature
argument_list|()
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|toDetailString ()
specifier|public
name|String
name|toDetailString
parameter_list|()
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
return|return
name|super
operator|.
name|toDetailString
argument_list|()
operator|+
operator|(
name|sf
operator|==
literal|null
condition|?
literal|""
else|:
name|sf
operator|.
name|getDetailedString
argument_list|()
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|getSnapshotINode (final Snapshot snapshot)
specifier|public
name|INodeFileAttributes
name|getSnapshotINode
parameter_list|(
specifier|final
name|Snapshot
name|snapshot
parameter_list|)
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
return|return
name|sf
operator|.
name|getSnapshotINode
argument_list|(
name|this
argument_list|,
name|snapshot
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|this
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|recordModification (final Snapshot latest, final INodeMap inodeMap)
specifier|public
name|INodeFile
name|recordModification
parameter_list|(
specifier|final
name|Snapshot
name|latest
parameter_list|,
specifier|final
name|INodeMap
name|inodeMap
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
if|if
condition|(
name|isInLatestSnapshot
argument_list|(
name|latest
argument_list|)
condition|)
block|{
comment|// the file is in snapshot, create a snapshot feature if it does not have
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|==
literal|null
condition|)
block|{
name|sf
operator|=
name|addSnapshotFeature
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// record self in the diff list if necessary
if|if
condition|(
operator|!
name|shouldRecordInSrcSnapshot
argument_list|(
name|latest
argument_list|)
condition|)
block|{
name|sf
operator|.
name|getDiffs
argument_list|()
operator|.
name|saveSelf2Snapshot
argument_list|(
name|latest
argument_list|,
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|this
return|;
block|}
DECL|method|getDiffs ()
specifier|public
name|FileDiffList
name|getDiffs
parameter_list|()
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
return|return
name|sf
operator|.
name|getDiffs
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/* End of Snapshot Feature */
comment|/** @return the replication factor of the file. */
DECL|method|getFileReplication (Snapshot snapshot)
specifier|public
specifier|final
name|short
name|getFileReplication
parameter_list|(
name|Snapshot
name|snapshot
parameter_list|)
block|{
if|if
condition|(
name|snapshot
operator|!=
literal|null
condition|)
block|{
return|return
name|getSnapshotINode
argument_list|(
name|snapshot
argument_list|)
operator|.
name|getFileReplication
argument_list|()
return|;
block|}
return|return
name|HeaderFormat
operator|.
name|getReplication
argument_list|(
name|header
argument_list|)
return|;
block|}
comment|/** The same as getFileReplication(null). */
annotation|@
name|Override
comment|// INodeFileAttributes
DECL|method|getFileReplication ()
specifier|public
specifier|final
name|short
name|getFileReplication
parameter_list|()
block|{
return|return
name|getFileReplication
argument_list|(
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// BlockCollection
DECL|method|getBlockReplication ()
specifier|public
name|short
name|getBlockReplication
parameter_list|()
block|{
name|short
name|max
init|=
name|getFileReplication
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
name|short
name|maxInSnapshot
init|=
name|sf
operator|.
name|getMaxBlockRepInDiffs
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|.
name|isCurrentFileDeleted
argument_list|()
condition|)
block|{
return|return
name|maxInSnapshot
return|;
block|}
name|max
operator|=
name|maxInSnapshot
operator|>
name|max
condition|?
name|maxInSnapshot
else|:
name|max
expr_stmt|;
block|}
return|return
name|max
return|;
block|}
comment|/** Set the replication factor of this file. */
DECL|method|setFileReplication (short replication)
specifier|public
specifier|final
name|void
name|setFileReplication
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
name|header
operator|=
name|HeaderFormat
operator|.
name|combineReplication
argument_list|(
name|header
argument_list|,
name|replication
argument_list|)
expr_stmt|;
block|}
comment|/** Set the replication factor of this file. */
DECL|method|setFileReplication (short replication, Snapshot latest, final INodeMap inodeMap)
specifier|public
specifier|final
name|INodeFile
name|setFileReplication
parameter_list|(
name|short
name|replication
parameter_list|,
name|Snapshot
name|latest
parameter_list|,
specifier|final
name|INodeMap
name|inodeMap
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
specifier|final
name|INodeFile
name|nodeToUpdate
init|=
name|recordModification
argument_list|(
name|latest
argument_list|,
name|inodeMap
argument_list|)
decl_stmt|;
name|nodeToUpdate
operator|.
name|setFileReplication
argument_list|(
name|replication
argument_list|)
expr_stmt|;
return|return
name|nodeToUpdate
return|;
block|}
comment|/** @return preferred block size (in bytes) of the file. */
annotation|@
name|Override
DECL|method|getPreferredBlockSize ()
specifier|public
name|long
name|getPreferredBlockSize
parameter_list|()
block|{
return|return
name|HeaderFormat
operator|.
name|getPreferredBlockSize
argument_list|(
name|header
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getHeaderLong ()
specifier|public
name|long
name|getHeaderLong
parameter_list|()
block|{
return|return
name|header
return|;
block|}
comment|/** @return the diskspace required for a full block. */
DECL|method|getBlockDiskspace ()
specifier|final
name|long
name|getBlockDiskspace
parameter_list|()
block|{
return|return
name|getPreferredBlockSize
argument_list|()
operator|*
name|getBlockReplication
argument_list|()
return|;
block|}
comment|/** @return the blocks of the file. */
annotation|@
name|Override
DECL|method|getBlocks ()
specifier|public
name|BlockInfo
index|[]
name|getBlocks
parameter_list|()
block|{
return|return
name|this
operator|.
name|blocks
return|;
block|}
DECL|method|updateBlockCollection ()
name|void
name|updateBlockCollection
parameter_list|()
block|{
if|if
condition|(
name|blocks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
control|)
block|{
name|b
operator|.
name|setBlockCollection
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * append array of blocks to this.blocks    */
DECL|method|concatBlocks (INodeFile[] inodes)
name|void
name|concatBlocks
parameter_list|(
name|INodeFile
index|[]
name|inodes
parameter_list|)
block|{
name|int
name|size
init|=
name|this
operator|.
name|blocks
operator|.
name|length
decl_stmt|;
name|int
name|totalAddedBlocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|INodeFile
name|f
range|:
name|inodes
control|)
block|{
name|totalAddedBlocks
operator|+=
name|f
operator|.
name|blocks
operator|.
name|length
expr_stmt|;
block|}
name|BlockInfo
index|[]
name|newlist
init|=
operator|new
name|BlockInfo
index|[
name|size
operator|+
name|totalAddedBlocks
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|blocks
argument_list|,
literal|0
argument_list|,
name|newlist
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|INodeFile
name|in
range|:
name|inodes
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|in
operator|.
name|blocks
argument_list|,
literal|0
argument_list|,
name|newlist
argument_list|,
name|size
argument_list|,
name|in
operator|.
name|blocks
operator|.
name|length
argument_list|)
expr_stmt|;
name|size
operator|+=
name|in
operator|.
name|blocks
operator|.
name|length
expr_stmt|;
block|}
name|setBlocks
argument_list|(
name|newlist
argument_list|)
expr_stmt|;
name|updateBlockCollection
argument_list|()
expr_stmt|;
block|}
comment|/**    * add a block to the block list    */
DECL|method|addBlock (BlockInfo newblock)
name|void
name|addBlock
parameter_list|(
name|BlockInfo
name|newblock
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|blocks
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|setBlocks
argument_list|(
operator|new
name|BlockInfo
index|[]
block|{
name|newblock
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|this
operator|.
name|blocks
operator|.
name|length
decl_stmt|;
name|BlockInfo
index|[]
name|newlist
init|=
operator|new
name|BlockInfo
index|[
name|size
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|blocks
argument_list|,
literal|0
argument_list|,
name|newlist
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|newlist
index|[
name|size
index|]
operator|=
name|newblock
expr_stmt|;
name|this
operator|.
name|setBlocks
argument_list|(
name|newlist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Set the blocks. */
DECL|method|setBlocks (BlockInfo[] blocks)
specifier|public
name|void
name|setBlocks
parameter_list|(
name|BlockInfo
index|[]
name|blocks
parameter_list|)
block|{
name|this
operator|.
name|blocks
operator|=
name|blocks
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|cleanSubtree (final Snapshot snapshot, Snapshot prior, final BlocksMapUpdateInfo collectedBlocks, final List<INode> removedINodes, final boolean countDiffChange)
specifier|public
name|Quota
operator|.
name|Counts
name|cleanSubtree
parameter_list|(
specifier|final
name|Snapshot
name|snapshot
parameter_list|,
name|Snapshot
name|prior
parameter_list|,
specifier|final
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|,
specifier|final
name|boolean
name|countDiffChange
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
return|return
name|sf
operator|.
name|cleanFile
argument_list|(
name|this
argument_list|,
name|snapshot
argument_list|,
name|prior
argument_list|,
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|,
name|countDiffChange
argument_list|)
return|;
block|}
name|Quota
operator|.
name|Counts
name|counts
init|=
name|Quota
operator|.
name|Counts
operator|.
name|newInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshot
operator|==
literal|null
operator|&&
name|prior
operator|==
literal|null
condition|)
block|{
comment|// this only happens when deleting the current file and the file is not
comment|// in any snapshot
name|computeQuotaUsage
argument_list|(
name|counts
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|destroyAndCollectBlocks
argument_list|(
name|collectedBlocks
argument_list|,
name|removedINodes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|snapshot
operator|==
literal|null
operator|&&
name|prior
operator|!=
literal|null
condition|)
block|{
comment|// when deleting the current file and the file is in snapshot, we should
comment|// clean the 0-sized block if the file is UC
name|FileUnderConstructionFeature
name|uc
init|=
name|getFileUnderConstructionFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|null
condition|)
block|{
name|uc
operator|.
name|cleanZeroSizeBlock
argument_list|(
name|this
argument_list|,
name|collectedBlocks
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|counts
return|;
block|}
annotation|@
name|Override
DECL|method|destroyAndCollectBlocks (BlocksMapUpdateInfo collectedBlocks, final List<INode> removedINodes)
specifier|public
name|void
name|destroyAndCollectBlocks
parameter_list|(
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
specifier|final
name|List
argument_list|<
name|INode
argument_list|>
name|removedINodes
parameter_list|)
block|{
if|if
condition|(
name|blocks
operator|!=
literal|null
operator|&&
name|collectedBlocks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|BlockInfo
name|blk
range|:
name|blocks
control|)
block|{
name|collectedBlocks
operator|.
name|addDeleteBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|blk
operator|.
name|setBlockCollection
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
name|setBlocks
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|removedINodes
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
name|sf
operator|.
name|clearDiffs
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
comment|// Get the full path name of this inode.
return|return
name|getFullPathName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|computeQuotaUsage (Quota.Counts counts, boolean useCache, int lastSnapshotId)
specifier|public
specifier|final
name|Quota
operator|.
name|Counts
name|computeQuotaUsage
parameter_list|(
name|Quota
operator|.
name|Counts
name|counts
parameter_list|,
name|boolean
name|useCache
parameter_list|,
name|int
name|lastSnapshotId
parameter_list|)
block|{
name|long
name|nsDelta
init|=
literal|1
decl_stmt|;
specifier|final
name|long
name|dsDelta
decl_stmt|;
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
name|FileDiffList
name|fileDiffList
init|=
name|sf
operator|.
name|getDiffs
argument_list|()
decl_stmt|;
name|Snapshot
name|last
init|=
name|fileDiffList
operator|.
name|getLastSnapshot
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FileDiff
argument_list|>
name|diffs
init|=
name|fileDiffList
operator|.
name|asList
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastSnapshotId
operator|==
name|Snapshot
operator|.
name|INVALID_ID
operator|||
name|last
operator|==
literal|null
condition|)
block|{
name|nsDelta
operator|+=
name|diffs
operator|.
name|size
argument_list|()
expr_stmt|;
name|dsDelta
operator|=
name|diskspaceConsumed
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|.
name|getId
argument_list|()
operator|<
name|lastSnapshotId
condition|)
block|{
name|dsDelta
operator|=
name|computeFileSize
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
operator|*
name|getFileReplication
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Snapshot
name|s
init|=
name|fileDiffList
operator|.
name|getSnapshotById
argument_list|(
name|lastSnapshotId
argument_list|)
decl_stmt|;
name|dsDelta
operator|=
name|diskspaceConsumed
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dsDelta
operator|=
name|diskspaceConsumed
argument_list|()
expr_stmt|;
block|}
name|counts
operator|.
name|add
argument_list|(
name|Quota
operator|.
name|NAMESPACE
argument_list|,
name|nsDelta
argument_list|)
expr_stmt|;
name|counts
operator|.
name|add
argument_list|(
name|Quota
operator|.
name|DISKSPACE
argument_list|,
name|dsDelta
argument_list|)
expr_stmt|;
return|return
name|counts
return|;
block|}
annotation|@
name|Override
DECL|method|computeContentSummary ( final ContentSummaryComputationContext summary)
specifier|public
specifier|final
name|ContentSummaryComputationContext
name|computeContentSummary
parameter_list|(
specifier|final
name|ContentSummaryComputationContext
name|summary
parameter_list|)
block|{
name|computeContentSummary4Snapshot
argument_list|(
name|summary
operator|.
name|getCounts
argument_list|()
argument_list|)
expr_stmt|;
name|computeContentSummary4Current
argument_list|(
name|summary
operator|.
name|getCounts
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|summary
return|;
block|}
DECL|method|computeContentSummary4Snapshot (final Content.Counts counts)
specifier|private
name|void
name|computeContentSummary4Snapshot
parameter_list|(
specifier|final
name|Content
operator|.
name|Counts
name|counts
parameter_list|)
block|{
comment|// file length and diskspace only counted for the latest state of the file
comment|// i.e. either the current state or the last snapshot
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
specifier|final
name|FileDiffList
name|diffs
init|=
name|sf
operator|.
name|getDiffs
argument_list|()
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|diffs
operator|.
name|asList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|counts
operator|.
name|add
argument_list|(
name|Content
operator|.
name|FILE
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|sf
operator|.
name|isCurrentFileDeleted
argument_list|()
condition|)
block|{
name|counts
operator|.
name|add
argument_list|(
name|Content
operator|.
name|LENGTH
argument_list|,
name|diffs
operator|.
name|getLast
argument_list|()
operator|.
name|getFileSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sf
operator|.
name|isCurrentFileDeleted
argument_list|()
condition|)
block|{
specifier|final
name|long
name|lastFileSize
init|=
name|diffs
operator|.
name|getLast
argument_list|()
operator|.
name|getFileSize
argument_list|()
decl_stmt|;
name|counts
operator|.
name|add
argument_list|(
name|Content
operator|.
name|DISKSPACE
argument_list|,
name|lastFileSize
operator|*
name|getBlockReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|computeContentSummary4Current (final Content.Counts counts)
specifier|private
name|void
name|computeContentSummary4Current
parameter_list|(
specifier|final
name|Content
operator|.
name|Counts
name|counts
parameter_list|)
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
operator|&&
name|sf
operator|.
name|isCurrentFileDeleted
argument_list|()
condition|)
block|{
return|return;
block|}
name|counts
operator|.
name|add
argument_list|(
name|Content
operator|.
name|LENGTH
argument_list|,
name|computeFileSize
argument_list|()
argument_list|)
expr_stmt|;
name|counts
operator|.
name|add
argument_list|(
name|Content
operator|.
name|FILE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counts
operator|.
name|add
argument_list|(
name|Content
operator|.
name|DISKSPACE
argument_list|,
name|diskspaceConsumed
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** The same as computeFileSize(null). */
DECL|method|computeFileSize ()
specifier|public
specifier|final
name|long
name|computeFileSize
parameter_list|()
block|{
return|return
name|computeFileSize
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/**    * Compute file size of the current file if the given snapshot is null;    * otherwise, get the file size from the given snapshot.    */
DECL|method|computeFileSize (Snapshot snapshot)
specifier|public
specifier|final
name|long
name|computeFileSize
parameter_list|(
name|Snapshot
name|snapshot
parameter_list|)
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshot
operator|!=
literal|null
operator|&&
name|sf
operator|!=
literal|null
condition|)
block|{
specifier|final
name|FileDiff
name|d
init|=
name|sf
operator|.
name|getDiffs
argument_list|()
operator|.
name|getDiff
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
block|{
return|return
name|d
operator|.
name|getFileSize
argument_list|()
return|;
block|}
block|}
return|return
name|computeFileSize
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Compute file size of the current file size    * but not including the last block if it is under construction.    */
DECL|method|computeFileSizeNotIncludingLastUcBlock ()
specifier|public
specifier|final
name|long
name|computeFileSizeNotIncludingLastUcBlock
parameter_list|()
block|{
return|return
name|computeFileSize
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Compute file size of the current file.    *     * @param includesLastUcBlock    *          If the last block is under construction, should it be included?    * @param usePreferredBlockSize4LastUcBlock    *          If the last block is under construction, should we use actual    *          block size or preferred block size?    *          Note that usePreferredBlockSize4LastUcBlock is ignored    *          if includesLastUcBlock == false.    * @return file size    */
DECL|method|computeFileSize (boolean includesLastUcBlock, boolean usePreferredBlockSize4LastUcBlock)
specifier|public
specifier|final
name|long
name|computeFileSize
parameter_list|(
name|boolean
name|includesLastUcBlock
parameter_list|,
name|boolean
name|usePreferredBlockSize4LastUcBlock
parameter_list|)
block|{
if|if
condition|(
name|blocks
operator|==
literal|null
operator|||
name|blocks
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|int
name|last
init|=
name|blocks
operator|.
name|length
operator|-
literal|1
decl_stmt|;
comment|//check if the last block is BlockInfoUnderConstruction
name|long
name|size
init|=
name|blocks
index|[
name|last
index|]
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|blocks
index|[
name|last
index|]
operator|instanceof
name|BlockInfoUnderConstruction
condition|)
block|{
if|if
condition|(
operator|!
name|includesLastUcBlock
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usePreferredBlockSize4LastUcBlock
condition|)
block|{
name|size
operator|=
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
block|}
block|}
comment|//sum other blocks
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|blocks
index|[
name|i
index|]
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
DECL|method|diskspaceConsumed ()
specifier|public
specifier|final
name|long
name|diskspaceConsumed
parameter_list|()
block|{
comment|// use preferred block size for the last block if it is under construction
return|return
name|computeFileSize
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
operator|*
name|getBlockReplication
argument_list|()
return|;
block|}
DECL|method|diskspaceConsumed (Snapshot lastSnapshot)
specifier|public
specifier|final
name|long
name|diskspaceConsumed
parameter_list|(
name|Snapshot
name|lastSnapshot
parameter_list|)
block|{
if|if
condition|(
name|lastSnapshot
operator|!=
literal|null
condition|)
block|{
return|return
name|computeFileSize
argument_list|(
name|lastSnapshot
argument_list|)
operator|*
name|getFileReplication
argument_list|(
name|lastSnapshot
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|diskspaceConsumed
argument_list|()
return|;
block|}
block|}
comment|/**    * Return the penultimate allocated block for this file.    */
DECL|method|getPenultimateBlock ()
name|BlockInfo
name|getPenultimateBlock
parameter_list|()
block|{
if|if
condition|(
name|blocks
operator|==
literal|null
operator|||
name|blocks
operator|.
name|length
operator|<=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|blocks
index|[
name|blocks
operator|.
name|length
operator|-
literal|2
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|getLastBlock ()
specifier|public
name|BlockInfo
name|getLastBlock
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|blocks
operator|==
literal|null
operator|||
name|blocks
operator|.
name|length
operator|==
literal|0
condition|?
literal|null
else|:
name|blocks
index|[
name|blocks
operator|.
name|length
operator|-
literal|1
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|numBlocks ()
specifier|public
name|int
name|numBlocks
parameter_list|()
block|{
return|return
name|blocks
operator|==
literal|null
condition|?
literal|0
else|:
name|blocks
operator|.
name|length
return|;
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|dumpTreeRecursively (PrintWriter out, StringBuilder prefix, final Snapshot snapshot)
specifier|public
name|void
name|dumpTreeRecursively
parameter_list|(
name|PrintWriter
name|out
parameter_list|,
name|StringBuilder
name|prefix
parameter_list|,
specifier|final
name|Snapshot
name|snapshot
parameter_list|)
block|{
name|super
operator|.
name|dumpTreeRecursively
argument_list|(
name|out
argument_list|,
name|prefix
argument_list|,
name|snapshot
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
literal|", fileSize="
operator|+
name|computeFileSize
argument_list|(
name|snapshot
argument_list|)
argument_list|)
expr_stmt|;
comment|// only compare the first block
name|out
operator|.
name|print
argument_list|(
literal|", blocks="
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
name|blocks
operator|==
literal|null
operator|||
name|blocks
operator|.
name|length
operator|==
literal|0
condition|?
literal|null
else|:
name|blocks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

