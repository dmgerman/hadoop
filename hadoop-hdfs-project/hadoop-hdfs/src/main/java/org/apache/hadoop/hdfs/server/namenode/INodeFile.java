begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
operator|.
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockType
operator|.
name|CONTIGUOUS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockType
operator|.
name|STRIPED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
operator|.
name|CURRENT_STATE_ID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
operator|.
name|NO_SNAPSHOT_ID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|PermissionStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockStoragePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ErasureCodingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|QuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockInfoStriped
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockStoragePolicySuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeStorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|BlockUCState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|FileDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|FileDiffList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|FileWithSnapshotFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|Snapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|snapshot
operator|.
name|DiffList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|LongBitFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|erasurecode
operator|.
name|ErasureCodeConstants
operator|.
name|REPLICATION_POLICY_ID
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/** I-node for closed file. */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|INodeFile
specifier|public
class|class
name|INodeFile
extends|extends
name|INodeWithAdditionalFields
implements|implements
name|INodeFileAttributes
implements|,
name|BlockCollection
block|{
comment|/**    * Erasure Coded striped blocks have replication factor of 1.    */
DECL|field|DEFAULT_REPL_FOR_STRIPED_BLOCKS
specifier|public
specifier|static
specifier|final
name|short
name|DEFAULT_REPL_FOR_STRIPED_BLOCKS
init|=
literal|1
decl_stmt|;
comment|/** The same as valueOf(inode, path, false). */
DECL|method|valueOf (INode inode, String path )
specifier|public
specifier|static
name|INodeFile
name|valueOf
parameter_list|(
name|INode
name|inode
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
return|return
name|valueOf
argument_list|(
name|inode
argument_list|,
name|path
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Cast INode to INodeFile. */
DECL|method|valueOf (INode inode, String path, boolean acceptNull)
specifier|public
specifier|static
name|INodeFile
name|valueOf
parameter_list|(
name|INode
name|inode
parameter_list|,
name|String
name|path
parameter_list|,
name|boolean
name|acceptNull
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
if|if
condition|(
name|inode
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|acceptNull
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File does not exist: "
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|inode
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Path is not a file: "
operator|+
name|path
argument_list|)
throw|;
block|}
return|return
name|inode
operator|.
name|asFile
argument_list|()
return|;
block|}
comment|/**     * Bit format:    * [4-bit storagePolicyID][12-bit BLOCK_LAYOUT_AND_REDUNDANCY]    * [48-bit preferredBlockSize]    *    * BLOCK_LAYOUT_AND_REDUNDANCY contains 12 bits and describes the layout and    * redundancy of a block. We use the highest 1 bit to determine whether the    * block is replica or erasure coded. For replica blocks, the tail 11 bits    * stores the replication factor. For erasure coded blocks, the tail 11 bits    * stores the EC policy ID, and in the future, we may further divide these    * 11 bits to store both the EC policy ID and replication factor for erasure    * coded blocks. The layout of this section is demonstrated as below.    *    * Another possible future extension is for future block types, in which case    * the 'Replica or EC' bit may be extended into the 11 bit field.    *    * +---------------+-------------------------------+    * |     1 bit     |             11 bit            |    * +---------------+-------------------------------+    * | Replica or EC |Replica factor or EC policy ID |    * +---------------+-------------------------------+    *    * BLOCK_LAYOUT_AND_REDUNDANCY format for replicated block:    * 0 [11-bit replication]    *    * BLOCK_LAYOUT_AND_REDUNDANCY format for striped block:    * 1 [11-bit ErasureCodingPolicy ID]    */
DECL|enum|HeaderFormat
enum|enum
name|HeaderFormat
block|{
DECL|enumConstant|PREFERRED_BLOCK_SIZE
name|PREFERRED_BLOCK_SIZE
argument_list|(
literal|null
argument_list|,
literal|48
argument_list|,
literal|1
argument_list|)
block|,
DECL|enumConstant|BLOCK_LAYOUT_AND_REDUNDANCY
name|BLOCK_LAYOUT_AND_REDUNDANCY
argument_list|(
name|PREFERRED_BLOCK_SIZE
operator|.
name|BITS
argument_list|,
name|HeaderFormat
operator|.
name|LAYOUT_BIT_WIDTH
operator|+
literal|11
argument_list|,
literal|0
argument_list|)
block|,
DECL|enumConstant|STORAGE_POLICY_ID
name|STORAGE_POLICY_ID
argument_list|(
name|BLOCK_LAYOUT_AND_REDUNDANCY
operator|.
name|BITS
argument_list|,
name|BlockStoragePolicySuite
operator|.
name|ID_BIT_LENGTH
argument_list|,
literal|0
argument_list|)
block|;
DECL|field|BITS
specifier|private
specifier|final
name|LongBitFormat
name|BITS
decl_stmt|;
comment|/**      * Number of bits used to encode block layout type.      * Different types can be replica or EC      */
DECL|field|LAYOUT_BIT_WIDTH
specifier|private
specifier|static
specifier|final
name|int
name|LAYOUT_BIT_WIDTH
init|=
literal|1
decl_stmt|;
DECL|field|MAX_REDUNDANCY
specifier|private
specifier|static
specifier|final
name|int
name|MAX_REDUNDANCY
init|=
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
literal|1
decl_stmt|;
DECL|method|HeaderFormat (LongBitFormat previous, int length, long min)
name|HeaderFormat
parameter_list|(
name|LongBitFormat
name|previous
parameter_list|,
name|int
name|length
parameter_list|,
name|long
name|min
parameter_list|)
block|{
name|BITS
operator|=
operator|new
name|LongBitFormat
argument_list|(
name|name
argument_list|()
argument_list|,
name|previous
argument_list|,
name|length
argument_list|,
name|min
argument_list|)
expr_stmt|;
block|}
DECL|method|getReplication (long header)
specifier|static
name|short
name|getReplication
parameter_list|(
name|long
name|header
parameter_list|)
block|{
if|if
condition|(
name|isStriped
argument_list|(
name|header
argument_list|)
condition|)
block|{
return|return
name|DEFAULT_REPL_FOR_STRIPED_BLOCKS
return|;
block|}
else|else
block|{
name|long
name|layoutRedundancy
init|=
name|BLOCK_LAYOUT_AND_REDUNDANCY
operator|.
name|BITS
operator|.
name|retrieve
argument_list|(
name|header
argument_list|)
decl_stmt|;
return|return
call|(
name|short
call|)
argument_list|(
name|layoutRedundancy
operator|&
name|MAX_REDUNDANCY
argument_list|)
return|;
block|}
block|}
DECL|method|getECPolicyID (long header)
specifier|static
name|byte
name|getECPolicyID
parameter_list|(
name|long
name|header
parameter_list|)
block|{
name|long
name|layoutRedundancy
init|=
name|BLOCK_LAYOUT_AND_REDUNDANCY
operator|.
name|BITS
operator|.
name|retrieve
argument_list|(
name|header
argument_list|)
decl_stmt|;
return|return
call|(
name|byte
call|)
argument_list|(
name|layoutRedundancy
operator|&
name|MAX_REDUNDANCY
argument_list|)
return|;
block|}
DECL|method|getPreferredBlockSize (long header)
specifier|static
name|long
name|getPreferredBlockSize
parameter_list|(
name|long
name|header
parameter_list|)
block|{
return|return
name|PREFERRED_BLOCK_SIZE
operator|.
name|BITS
operator|.
name|retrieve
argument_list|(
name|header
argument_list|)
return|;
block|}
DECL|method|getStoragePolicyID (long header)
specifier|static
name|byte
name|getStoragePolicyID
parameter_list|(
name|long
name|header
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|STORAGE_POLICY_ID
operator|.
name|BITS
operator|.
name|retrieve
argument_list|(
name|header
argument_list|)
return|;
block|}
comment|// Union of all the block type masks. Currently there is only
comment|// BLOCK_TYPE_MASK_STRIPED
DECL|field|BLOCK_TYPE_MASK
specifier|static
specifier|final
name|long
name|BLOCK_TYPE_MASK
init|=
literal|1
operator|<<
literal|11
decl_stmt|;
comment|// Mask to determine if the block type is striped.
DECL|field|BLOCK_TYPE_MASK_STRIPED
specifier|static
specifier|final
name|long
name|BLOCK_TYPE_MASK_STRIPED
init|=
literal|1
operator|<<
literal|11
decl_stmt|;
DECL|method|isStriped (long header)
specifier|static
name|boolean
name|isStriped
parameter_list|(
name|long
name|header
parameter_list|)
block|{
return|return
name|getBlockType
argument_list|(
name|header
argument_list|)
operator|==
name|STRIPED
return|;
block|}
DECL|method|getBlockType (long header)
specifier|static
name|BlockType
name|getBlockType
parameter_list|(
name|long
name|header
parameter_list|)
block|{
name|long
name|layoutRedundancy
init|=
name|BLOCK_LAYOUT_AND_REDUNDANCY
operator|.
name|BITS
operator|.
name|retrieve
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|long
name|blockType
init|=
name|layoutRedundancy
operator|&
name|BLOCK_TYPE_MASK
decl_stmt|;
if|if
condition|(
name|blockType
operator|==
name|BLOCK_TYPE_MASK_STRIPED
condition|)
block|{
return|return
name|STRIPED
return|;
block|}
else|else
block|{
return|return
name|CONTIGUOUS
return|;
block|}
block|}
comment|/**      * Construct block layout redundancy based on the given BlockType,      * replication factor and EC PolicyID.      */
DECL|method|getBlockLayoutRedundancy (BlockType blockType, Short replication, Byte erasureCodingPolicyID)
specifier|static
name|long
name|getBlockLayoutRedundancy
parameter_list|(
name|BlockType
name|blockType
parameter_list|,
name|Short
name|replication
parameter_list|,
name|Byte
name|erasureCodingPolicyID
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|erasureCodingPolicyID
condition|)
block|{
name|erasureCodingPolicyID
operator|=
name|REPLICATION_POLICY_ID
expr_stmt|;
block|}
name|long
name|layoutRedundancy
init|=
literal|0xFF
operator|&
name|erasureCodingPolicyID
decl_stmt|;
switch|switch
condition|(
name|blockType
condition|)
block|{
case|case
name|STRIPED
case|:
if|if
condition|(
name|replication
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal replication for STRIPED block type"
argument_list|)
throw|;
block|}
if|if
condition|(
name|erasureCodingPolicyID
operator|==
name|REPLICATION_POLICY_ID
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal REPLICATION policy for STRIPED block type"
argument_list|)
throw|;
block|}
if|if
condition|(
literal|null
operator|==
name|ErasureCodingPolicyManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getByID
argument_list|(
name|erasureCodingPolicyID
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not find EC policy with ID 0x%02x"
argument_list|,
name|erasureCodingPolicyID
argument_list|)
argument_list|)
throw|;
block|}
comment|// valid parameters for STRIPED
name|layoutRedundancy
operator||=
name|BLOCK_TYPE_MASK_STRIPED
expr_stmt|;
break|break;
case|case
name|CONTIGUOUS
case|:
if|if
condition|(
name|erasureCodingPolicyID
operator|!=
name|REPLICATION_POLICY_ID
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Illegal EC policy 0x%02x for CONTIGUOUS block type"
argument_list|,
name|erasureCodingPolicyID
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
literal|null
operator|==
name|replication
operator|||
name|replication
argument_list|<
literal|0
operator|||
name|replication
argument_list|>
name|MAX_REDUNDANCY
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid replication value "
operator|+
name|replication
argument_list|)
throw|;
block|}
comment|// valid parameters for CONTIGUOUS
name|layoutRedundancy
operator||=
name|replication
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown blockType: "
operator|+
name|blockType
argument_list|)
throw|;
block|}
return|return
name|layoutRedundancy
return|;
block|}
DECL|method|toLong (long preferredBlockSize, long layoutRedundancy, byte storagePolicyID)
specifier|static
name|long
name|toLong
parameter_list|(
name|long
name|preferredBlockSize
parameter_list|,
name|long
name|layoutRedundancy
parameter_list|,
name|byte
name|storagePolicyID
parameter_list|)
block|{
name|long
name|h
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|preferredBlockSize
operator|==
literal|0
condition|)
block|{
name|preferredBlockSize
operator|=
name|PREFERRED_BLOCK_SIZE
operator|.
name|BITS
operator|.
name|getMin
argument_list|()
expr_stmt|;
block|}
name|h
operator|=
name|PREFERRED_BLOCK_SIZE
operator|.
name|BITS
operator|.
name|combine
argument_list|(
name|preferredBlockSize
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|BLOCK_LAYOUT_AND_REDUNDANCY
operator|.
name|BITS
operator|.
name|combine
argument_list|(
name|layoutRedundancy
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|STORAGE_POLICY_ID
operator|.
name|BITS
operator|.
name|combine
argument_list|(
name|storagePolicyID
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
block|}
DECL|field|header
specifier|private
name|long
name|header
init|=
literal|0L
decl_stmt|;
DECL|field|blocks
specifier|private
name|BlockInfo
index|[]
name|blocks
decl_stmt|;
DECL|method|INodeFile (long id, byte[] name, PermissionStatus permissions, long mtime, long atime, BlockInfo[] blklist, short replication, long preferredBlockSize)
name|INodeFile
parameter_list|(
name|long
name|id
parameter_list|,
name|byte
index|[]
name|name
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|BlockInfo
index|[]
name|blklist
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|)
block|{
name|this
argument_list|(
name|id
argument_list|,
name|name
argument_list|,
name|permissions
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
name|blklist
argument_list|,
name|replication
argument_list|,
literal|null
argument_list|,
name|preferredBlockSize
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
name|CONTIGUOUS
argument_list|)
expr_stmt|;
block|}
DECL|method|INodeFile (long id, byte[] name, PermissionStatus permissions, long mtime, long atime, BlockInfo[] blklist, Short replication, Byte ecPolicyID, long preferredBlockSize, byte storagePolicyID, BlockType blockType)
name|INodeFile
parameter_list|(
name|long
name|id
parameter_list|,
name|byte
index|[]
name|name
parameter_list|,
name|PermissionStatus
name|permissions
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|BlockInfo
index|[]
name|blklist
parameter_list|,
name|Short
name|replication
parameter_list|,
name|Byte
name|ecPolicyID
parameter_list|,
name|long
name|preferredBlockSize
parameter_list|,
name|byte
name|storagePolicyID
parameter_list|,
name|BlockType
name|blockType
parameter_list|)
block|{
name|super
argument_list|(
name|id
argument_list|,
name|name
argument_list|,
name|permissions
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
specifier|final
name|long
name|layoutRedundancy
init|=
name|HeaderFormat
operator|.
name|getBlockLayoutRedundancy
argument_list|(
name|blockType
argument_list|,
name|replication
argument_list|,
name|ecPolicyID
argument_list|)
decl_stmt|;
name|header
operator|=
name|HeaderFormat
operator|.
name|toLong
argument_list|(
name|preferredBlockSize
argument_list|,
name|layoutRedundancy
argument_list|,
name|storagePolicyID
argument_list|)
expr_stmt|;
if|if
condition|(
name|blklist
operator|!=
literal|null
operator|&&
name|blklist
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|BlockInfo
name|b
range|:
name|blklist
control|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|b
operator|.
name|getBlockType
argument_list|()
operator|==
name|blockType
argument_list|)
expr_stmt|;
block|}
block|}
name|setBlocks
argument_list|(
name|blklist
argument_list|)
expr_stmt|;
block|}
DECL|method|INodeFile (INodeFile that)
specifier|public
name|INodeFile
parameter_list|(
name|INodeFile
name|that
parameter_list|)
block|{
name|super
argument_list|(
name|that
argument_list|)
expr_stmt|;
name|this
operator|.
name|header
operator|=
name|that
operator|.
name|header
expr_stmt|;
name|this
operator|.
name|features
operator|=
name|that
operator|.
name|features
expr_stmt|;
name|setBlocks
argument_list|(
name|that
operator|.
name|blocks
argument_list|)
expr_stmt|;
block|}
DECL|method|INodeFile (INodeFile that, FileDiffList diffs)
specifier|public
name|INodeFile
parameter_list|(
name|INodeFile
name|that
parameter_list|,
name|FileDiffList
name|diffs
parameter_list|)
block|{
name|this
argument_list|(
name|that
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|that
operator|.
name|isWithSnapshot
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|addSnapshotFeature
argument_list|(
name|diffs
argument_list|)
expr_stmt|;
block|}
comment|/** @return true unconditionally. */
annotation|@
name|Override
DECL|method|isFile ()
specifier|public
specifier|final
name|boolean
name|isFile
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** @return this object. */
annotation|@
name|Override
DECL|method|asFile ()
specifier|public
specifier|final
name|INodeFile
name|asFile
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|metadataEquals (INodeFileAttributes other)
specifier|public
name|boolean
name|metadataEquals
parameter_list|(
name|INodeFileAttributes
name|other
parameter_list|)
block|{
return|return
name|other
operator|!=
literal|null
operator|&&
name|getHeaderLong
argument_list|()
operator|==
name|other
operator|.
name|getHeaderLong
argument_list|()
operator|&&
name|getPermissionLong
argument_list|()
operator|==
name|other
operator|.
name|getPermissionLong
argument_list|()
operator|&&
name|getAclFeature
argument_list|()
operator|==
name|other
operator|.
name|getAclFeature
argument_list|()
operator|&&
name|getXAttrFeature
argument_list|()
operator|==
name|other
operator|.
name|getXAttrFeature
argument_list|()
return|;
block|}
comment|/* Start of Under-Construction Feature */
comment|/**    * If the inode contains a {@link FileUnderConstructionFeature}, return it;    * otherwise, return null.    */
DECL|method|getFileUnderConstructionFeature ()
specifier|public
specifier|final
name|FileUnderConstructionFeature
name|getFileUnderConstructionFeature
parameter_list|()
block|{
return|return
name|getFeature
argument_list|(
name|FileUnderConstructionFeature
operator|.
name|class
argument_list|)
return|;
block|}
comment|/** Is this file under construction? */
annotation|@
name|Override
comment|// BlockCollection
DECL|method|isUnderConstruction ()
specifier|public
name|boolean
name|isUnderConstruction
parameter_list|()
block|{
return|return
name|getFileUnderConstructionFeature
argument_list|()
operator|!=
literal|null
return|;
block|}
DECL|method|toUnderConstruction (String clientName, String clientMachine)
name|INodeFile
name|toUnderConstruction
parameter_list|(
name|String
name|clientName
parameter_list|,
name|String
name|clientMachine
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|isUnderConstruction
argument_list|()
argument_list|,
literal|"file is already under construction"
argument_list|)
expr_stmt|;
name|FileUnderConstructionFeature
name|uc
init|=
operator|new
name|FileUnderConstructionFeature
argument_list|(
name|clientName
argument_list|,
name|clientMachine
argument_list|)
decl_stmt|;
name|addFeature
argument_list|(
name|uc
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Convert the file to a complete file, i.e., to remove the Under-Construction    * feature.    */
DECL|method|toCompleteFile (long mtime, int numCommittedAllowed, short minReplication)
name|void
name|toCompleteFile
parameter_list|(
name|long
name|mtime
parameter_list|,
name|int
name|numCommittedAllowed
parameter_list|,
name|short
name|minReplication
parameter_list|)
block|{
specifier|final
name|FileUnderConstructionFeature
name|uc
init|=
name|getFileUnderConstructionFeature
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|uc
argument_list|,
literal|"File %s is not under construction"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|assertAllBlocksComplete
argument_list|(
name|numCommittedAllowed
argument_list|,
name|minReplication
argument_list|)
expr_stmt|;
name|removeFeature
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|setModificationTime
argument_list|(
name|mtime
argument_list|)
expr_stmt|;
block|}
comment|/** Assert all blocks are complete. */
DECL|method|assertAllBlocksComplete (int numCommittedAllowed, short minReplication)
specifier|private
name|void
name|assertAllBlocksComplete
parameter_list|(
name|int
name|numCommittedAllowed
parameter_list|,
name|short
name|minReplication
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|String
name|err
init|=
name|checkBlockComplete
argument_list|(
name|blocks
argument_list|,
name|i
argument_list|,
name|numCommittedAllowed
argument_list|,
name|minReplication
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unexpected block state: "
operator|+
literal|"%s, file=%s (%s), blocks=%s (i=%s)"
argument_list|,
name|err
argument_list|,
name|this
argument_list|,
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|blocks
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Check if the i-th block is COMPLETE;    * when the i-th block is the last block, it may be allowed to be COMMITTED.    *    * @return null if the block passes the check;    *              otherwise, return an error message.    */
DECL|method|checkBlockComplete (BlockInfo[] blocks, int i, int numCommittedAllowed, short minReplication)
specifier|static
name|String
name|checkBlockComplete
parameter_list|(
name|BlockInfo
index|[]
name|blocks
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|numCommittedAllowed
parameter_list|,
name|short
name|minReplication
parameter_list|)
block|{
specifier|final
name|BlockInfo
name|b
init|=
name|blocks
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|BlockUCState
name|state
init|=
name|b
operator|.
name|getBlockUCState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|BlockUCState
operator|.
name|COMPLETE
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|b
operator|.
name|isStriped
argument_list|()
operator|||
name|i
operator|<
name|blocks
operator|.
name|length
operator|-
name|numCommittedAllowed
condition|)
block|{
return|return
name|b
operator|+
literal|" is "
operator|+
name|state
operator|+
literal|" but not COMPLETE"
return|;
block|}
if|if
condition|(
name|state
operator|!=
name|BlockUCState
operator|.
name|COMMITTED
condition|)
block|{
return|return
name|b
operator|+
literal|" is "
operator|+
name|state
operator|+
literal|" but neither COMPLETE nor COMMITTED"
return|;
block|}
specifier|final
name|int
name|numExpectedLocations
init|=
name|b
operator|.
name|getUnderConstructionFeature
argument_list|()
operator|.
name|getNumExpectedLocations
argument_list|()
decl_stmt|;
if|if
condition|(
name|numExpectedLocations
operator|<=
name|minReplication
condition|)
block|{
return|return
name|b
operator|+
literal|" is "
operator|+
name|state
operator|+
literal|" but numExpectedLocations = "
operator|+
name|numExpectedLocations
operator|+
literal|"<= minReplication = "
operator|+
name|minReplication
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
comment|// BlockCollection
DECL|method|setBlock (int index, BlockInfo blk)
specifier|public
name|void
name|setBlock
parameter_list|(
name|int
name|index
parameter_list|,
name|BlockInfo
name|blk
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|blk
operator|.
name|isStriped
argument_list|()
operator|==
name|this
operator|.
name|isStriped
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|blocks
index|[
name|index
index|]
operator|=
name|blk
expr_stmt|;
block|}
annotation|@
name|Override
comment|// BlockCollection, the file should be under construction
DECL|method|convertLastBlockToUC (BlockInfo lastBlock, DatanodeStorageInfo[] locations)
specifier|public
name|void
name|convertLastBlockToUC
parameter_list|(
name|BlockInfo
name|lastBlock
parameter_list|,
name|DatanodeStorageInfo
index|[]
name|locations
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isUnderConstruction
argument_list|()
argument_list|,
literal|"file is no longer under construction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numBlocks
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to set last block: File is empty."
argument_list|)
throw|;
block|}
name|lastBlock
operator|.
name|convertToBlockUnderConstruction
argument_list|(
name|BlockUCState
operator|.
name|UNDER_CONSTRUCTION
argument_list|,
name|locations
argument_list|)
expr_stmt|;
block|}
DECL|method|setLastBlock (BlockInfo blk)
name|void
name|setLastBlock
parameter_list|(
name|BlockInfo
name|blk
parameter_list|)
block|{
name|blk
operator|.
name|setBlockCollectionId
argument_list|(
name|this
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|setBlock
argument_list|(
name|numBlocks
argument_list|()
operator|-
literal|1
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove a block from the block list. This block should be    * the last one on the list.    */
DECL|method|removeLastBlock (Block oldblock)
name|BlockInfo
name|removeLastBlock
parameter_list|(
name|Block
name|oldblock
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isUnderConstruction
argument_list|()
argument_list|,
literal|"file is no longer under construction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|size_1
init|=
name|blocks
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|blocks
index|[
name|size_1
index|]
operator|.
name|equals
argument_list|(
name|oldblock
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|BlockInfo
name|lastBlock
init|=
name|blocks
index|[
name|size_1
index|]
decl_stmt|;
comment|//copy to a new list
name|BlockInfo
index|[]
name|newlist
init|=
operator|new
name|BlockInfo
index|[
name|size_1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|blocks
argument_list|,
literal|0
argument_list|,
name|newlist
argument_list|,
literal|0
argument_list|,
name|size_1
argument_list|)
expr_stmt|;
name|setBlocks
argument_list|(
name|newlist
argument_list|)
expr_stmt|;
name|lastBlock
operator|.
name|delete
argument_list|()
expr_stmt|;
return|return
name|lastBlock
return|;
block|}
comment|/* End of Under-Construction Feature */
comment|/* Start of Snapshot Feature */
DECL|method|addSnapshotFeature (FileDiffList diffs)
specifier|public
name|FileWithSnapshotFeature
name|addSnapshotFeature
parameter_list|(
name|FileDiffList
name|diffs
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|isWithSnapshot
argument_list|()
argument_list|,
literal|"File is already with snapshot"
argument_list|)
expr_stmt|;
name|FileWithSnapshotFeature
name|sf
init|=
operator|new
name|FileWithSnapshotFeature
argument_list|(
name|diffs
argument_list|)
decl_stmt|;
name|this
operator|.
name|addFeature
argument_list|(
name|sf
argument_list|)
expr_stmt|;
return|return
name|sf
return|;
block|}
comment|/**    * If feature list contains a {@link FileWithSnapshotFeature}, return it;    * otherwise, return null.    */
DECL|method|getFileWithSnapshotFeature ()
specifier|public
specifier|final
name|FileWithSnapshotFeature
name|getFileWithSnapshotFeature
parameter_list|()
block|{
return|return
name|getFeature
argument_list|(
name|FileWithSnapshotFeature
operator|.
name|class
argument_list|)
return|;
block|}
comment|/** Is this file has the snapshot feature? */
DECL|method|isWithSnapshot ()
specifier|public
specifier|final
name|boolean
name|isWithSnapshot
parameter_list|()
block|{
return|return
name|getFileWithSnapshotFeature
argument_list|()
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|toDetailString ()
specifier|public
name|String
name|toDetailString
parameter_list|()
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
return|return
name|super
operator|.
name|toDetailString
argument_list|()
operator|+
operator|(
name|sf
operator|==
literal|null
condition|?
literal|""
else|:
name|sf
operator|.
name|getDetailedString
argument_list|()
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|getSnapshotINode (final int snapshotId)
specifier|public
name|INodeFileAttributes
name|getSnapshotINode
parameter_list|(
specifier|final
name|int
name|snapshotId
parameter_list|)
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
return|return
name|sf
operator|.
name|getDiffs
argument_list|()
operator|.
name|getSnapshotINode
argument_list|(
name|snapshotId
argument_list|,
name|this
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|this
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|recordModification (final int latestSnapshotId)
specifier|public
name|void
name|recordModification
parameter_list|(
specifier|final
name|int
name|latestSnapshotId
parameter_list|)
block|{
name|recordModification
argument_list|(
name|latestSnapshotId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|recordModification (final int latestSnapshotId, boolean withBlocks)
specifier|public
name|void
name|recordModification
parameter_list|(
specifier|final
name|int
name|latestSnapshotId
parameter_list|,
name|boolean
name|withBlocks
parameter_list|)
block|{
if|if
condition|(
name|isInLatestSnapshot
argument_list|(
name|latestSnapshotId
argument_list|)
operator|&&
operator|!
name|shouldRecordInSrcSnapshot
argument_list|(
name|latestSnapshotId
argument_list|)
condition|)
block|{
comment|// the file is in snapshot, create a snapshot feature if it does not have
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|==
literal|null
condition|)
block|{
name|sf
operator|=
name|addSnapshotFeature
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// record self in the diff list if necessary
name|sf
operator|.
name|getDiffs
argument_list|()
operator|.
name|saveSelf2Snapshot
argument_list|(
name|latestSnapshotId
argument_list|,
name|this
argument_list|,
literal|null
argument_list|,
name|withBlocks
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getDiffs ()
specifier|public
name|FileDiffList
name|getDiffs
parameter_list|()
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
return|return
name|sf
operator|.
name|getDiffs
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/* End of Snapshot Feature */
comment|/** @return the replication factor of the file. */
DECL|method|getFileReplication (int snapshot)
specifier|public
specifier|final
name|short
name|getFileReplication
parameter_list|(
name|int
name|snapshot
parameter_list|)
block|{
if|if
condition|(
name|snapshot
operator|!=
name|CURRENT_STATE_ID
condition|)
block|{
return|return
name|getSnapshotINode
argument_list|(
name|snapshot
argument_list|)
operator|.
name|getFileReplication
argument_list|()
return|;
block|}
return|return
name|HeaderFormat
operator|.
name|getReplication
argument_list|(
name|header
argument_list|)
return|;
block|}
comment|/**    * The same as getFileReplication(null).    * For erasure coded files, this returns the EC policy ID.    * */
annotation|@
name|Override
comment|// INodeFileAttributes
DECL|method|getFileReplication ()
specifier|public
specifier|final
name|short
name|getFileReplication
parameter_list|()
block|{
if|if
condition|(
name|isStriped
argument_list|()
condition|)
block|{
return|return
name|DEFAULT_REPL_FOR_STRIPED_BLOCKS
return|;
block|}
return|return
name|getFileReplication
argument_list|(
name|CURRENT_STATE_ID
argument_list|)
return|;
block|}
DECL|method|getPreferredBlockReplication ()
specifier|public
name|short
name|getPreferredBlockReplication
parameter_list|()
block|{
name|short
name|max
init|=
name|getFileReplication
argument_list|(
name|CURRENT_STATE_ID
argument_list|)
decl_stmt|;
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
name|short
name|maxInSnapshot
init|=
name|sf
operator|.
name|getMaxBlockRepInDiffs
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|sf
operator|.
name|isCurrentFileDeleted
argument_list|()
condition|)
block|{
return|return
name|maxInSnapshot
return|;
block|}
name|max
operator|=
name|maxInSnapshot
operator|>
name|max
condition|?
name|maxInSnapshot
else|:
name|max
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isStriped
argument_list|()
condition|)
block|{
return|return
name|max
return|;
block|}
name|ErasureCodingPolicy
name|ecPolicy
init|=
name|ErasureCodingPolicyManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getByID
argument_list|(
name|getErasureCodingPolicyID
argument_list|()
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|ecPolicy
argument_list|,
literal|"Could not find EC policy with ID 0x"
operator|+
name|StringUtils
operator|.
name|byteToHexString
argument_list|(
name|getErasureCodingPolicyID
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
call|(
name|short
call|)
argument_list|(
name|ecPolicy
operator|.
name|getNumDataUnits
argument_list|()
operator|+
name|ecPolicy
operator|.
name|getNumParityUnits
argument_list|()
argument_list|)
return|;
block|}
comment|/** Set the replication factor of this file. */
DECL|method|setFileReplication (short replication)
specifier|private
name|void
name|setFileReplication
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
name|long
name|layoutRedundancy
init|=
name|HeaderFormat
operator|.
name|BLOCK_LAYOUT_AND_REDUNDANCY
operator|.
name|BITS
operator|.
name|retrieve
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|layoutRedundancy
operator|=
operator|(
name|layoutRedundancy
operator|&
operator|~
name|HeaderFormat
operator|.
name|MAX_REDUNDANCY
operator|)
operator||
name|replication
expr_stmt|;
name|header
operator|=
name|HeaderFormat
operator|.
name|BLOCK_LAYOUT_AND_REDUNDANCY
operator|.
name|BITS
operator|.
name|combine
argument_list|(
name|layoutRedundancy
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
comment|/** Set the replication factor of this file. */
DECL|method|setFileReplication (short replication, int latestSnapshotId)
specifier|public
specifier|final
name|INodeFile
name|setFileReplication
parameter_list|(
name|short
name|replication
parameter_list|,
name|int
name|latestSnapshotId
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|recordModification
argument_list|(
name|latestSnapshotId
argument_list|)
expr_stmt|;
name|setFileReplication
argument_list|(
name|replication
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** @return preferred block size (in bytes) of the file. */
annotation|@
name|Override
DECL|method|getPreferredBlockSize ()
specifier|public
name|long
name|getPreferredBlockSize
parameter_list|()
block|{
return|return
name|HeaderFormat
operator|.
name|getPreferredBlockSize
argument_list|(
name|header
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getLocalStoragePolicyID ()
specifier|public
name|byte
name|getLocalStoragePolicyID
parameter_list|()
block|{
return|return
name|HeaderFormat
operator|.
name|getStoragePolicyID
argument_list|(
name|header
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getStoragePolicyID ()
specifier|public
name|byte
name|getStoragePolicyID
parameter_list|()
block|{
name|byte
name|id
init|=
name|getLocalStoragePolicyID
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
condition|)
block|{
name|id
operator|=
name|this
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
condition|?
name|this
operator|.
name|getParent
argument_list|()
operator|.
name|getStoragePolicyID
argument_list|()
else|:
name|id
expr_stmt|;
block|}
comment|// For Striped EC files, we support only suitable policies. Current
comment|// supported policies are HOT, COLD, ALL_SSD.
comment|// If the file was set with any other policies, then we just treat policy as
comment|// BLOCK_STORAGE_POLICY_ID_UNSPECIFIED.
if|if
condition|(
name|isStriped
argument_list|()
operator|&&
name|id
operator|!=
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
operator|&&
operator|!
name|ErasureCodingPolicyManager
operator|.
name|checkStoragePolicySuitableForECStripedMode
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|id
operator|=
name|HdfsConstants
operator|.
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The current effective storage policy id : "
operator|+
name|id
operator|+
literal|" is not suitable for striped mode EC file : "
operator|+
name|getName
argument_list|()
operator|+
literal|". So, just returning unspecified storage policy id"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|id
return|;
block|}
DECL|method|setStoragePolicyID (byte storagePolicyId)
specifier|private
name|void
name|setStoragePolicyID
parameter_list|(
name|byte
name|storagePolicyId
parameter_list|)
block|{
name|header
operator|=
name|HeaderFormat
operator|.
name|STORAGE_POLICY_ID
operator|.
name|BITS
operator|.
name|combine
argument_list|(
name|storagePolicyId
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
DECL|method|setStoragePolicyID (byte storagePolicyId, int latestSnapshotId)
specifier|public
specifier|final
name|void
name|setStoragePolicyID
parameter_list|(
name|byte
name|storagePolicyId
parameter_list|,
name|int
name|latestSnapshotId
parameter_list|)
throws|throws
name|QuotaExceededException
block|{
name|recordModification
argument_list|(
name|latestSnapshotId
argument_list|)
expr_stmt|;
name|setStoragePolicyID
argument_list|(
name|storagePolicyId
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return The ID of the erasure coding policy on the file.    */
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|getErasureCodingPolicyID ()
specifier|public
name|byte
name|getErasureCodingPolicyID
parameter_list|()
block|{
if|if
condition|(
name|isStriped
argument_list|()
condition|)
block|{
return|return
name|HeaderFormat
operator|.
name|getECPolicyID
argument_list|(
name|header
argument_list|)
return|;
block|}
return|return
name|REPLICATION_POLICY_ID
return|;
block|}
comment|/**    * @return true if the file is in the striping layout.    */
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|isStriped ()
specifier|public
name|boolean
name|isStriped
parameter_list|()
block|{
return|return
name|HeaderFormat
operator|.
name|isStriped
argument_list|(
name|header
argument_list|)
return|;
block|}
comment|/**    * @return The type of the INodeFile based on block id.    */
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|getBlockType ()
specifier|public
name|BlockType
name|getBlockType
parameter_list|()
block|{
return|return
name|HeaderFormat
operator|.
name|getBlockType
argument_list|(
name|header
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// INodeFileAttributes
DECL|method|getHeaderLong ()
specifier|public
name|long
name|getHeaderLong
parameter_list|()
block|{
return|return
name|header
return|;
block|}
comment|/** @return the blocks of the file. */
annotation|@
name|Override
comment|// BlockCollection
DECL|method|getBlocks ()
specifier|public
name|BlockInfo
index|[]
name|getBlocks
parameter_list|()
block|{
return|return
name|this
operator|.
name|blocks
return|;
block|}
comment|/** @return blocks of the file corresponding to the snapshot. */
DECL|method|getBlocks (int snapshot)
specifier|public
name|BlockInfo
index|[]
name|getBlocks
parameter_list|(
name|int
name|snapshot
parameter_list|)
block|{
if|if
condition|(
name|snapshot
operator|==
name|CURRENT_STATE_ID
operator|||
name|getDiffs
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
name|getBlocks
argument_list|()
return|;
block|}
comment|// find blocks stored in snapshot diffs (for truncate)
name|FileDiff
name|diff
init|=
name|getDiffs
argument_list|()
operator|.
name|getDiffById
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
comment|// note that currently FileDiff can only store contiguous blocks
name|BlockInfo
index|[]
name|snapshotBlocks
init|=
name|diff
operator|==
literal|null
condition|?
name|getBlocks
argument_list|()
else|:
name|diff
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshotBlocks
operator|!=
literal|null
condition|)
block|{
return|return
name|snapshotBlocks
return|;
block|}
comment|// Blocks are not in the current snapshot
comment|// Find next snapshot with blocks present or return current file blocks
name|snapshotBlocks
operator|=
name|getDiffs
argument_list|()
operator|.
name|findLaterSnapshotBlocks
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
return|return
operator|(
name|snapshotBlocks
operator|==
literal|null
operator|)
condition|?
name|getBlocks
argument_list|()
else|:
name|snapshotBlocks
return|;
block|}
comment|/**    * append array of blocks to this.blocks    */
DECL|method|concatBlocks (INodeFile[] inodes, BlockManager bm)
name|void
name|concatBlocks
parameter_list|(
name|INodeFile
index|[]
name|inodes
parameter_list|,
name|BlockManager
name|bm
parameter_list|)
block|{
name|int
name|size
init|=
name|this
operator|.
name|blocks
operator|.
name|length
decl_stmt|;
name|int
name|totalAddedBlocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|INodeFile
name|f
range|:
name|inodes
control|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|f
operator|.
name|isStriped
argument_list|()
operator|==
name|this
operator|.
name|isStriped
argument_list|()
argument_list|)
expr_stmt|;
name|totalAddedBlocks
operator|+=
name|f
operator|.
name|blocks
operator|.
name|length
expr_stmt|;
block|}
name|BlockInfo
index|[]
name|newlist
init|=
operator|new
name|BlockInfo
index|[
name|size
operator|+
name|totalAddedBlocks
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|blocks
argument_list|,
literal|0
argument_list|,
name|newlist
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|INodeFile
name|in
range|:
name|inodes
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|in
operator|.
name|blocks
argument_list|,
literal|0
argument_list|,
name|newlist
argument_list|,
name|size
argument_list|,
name|in
operator|.
name|blocks
operator|.
name|length
argument_list|)
expr_stmt|;
name|size
operator|+=
name|in
operator|.
name|blocks
operator|.
name|length
expr_stmt|;
block|}
name|setBlocks
argument_list|(
name|newlist
argument_list|)
expr_stmt|;
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
control|)
block|{
name|b
operator|.
name|setBlockCollectionId
argument_list|(
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|short
name|oldRepl
init|=
name|b
operator|.
name|getReplication
argument_list|()
decl_stmt|;
name|short
name|repl
init|=
name|getPreferredBlockReplication
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldRepl
operator|!=
name|repl
condition|)
block|{
name|bm
operator|.
name|setReplication
argument_list|(
name|oldRepl
argument_list|,
name|repl
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * add a block to the block list    */
DECL|method|addBlock (BlockInfo newblock)
name|void
name|addBlock
parameter_list|(
name|BlockInfo
name|newblock
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|newblock
operator|.
name|isStriped
argument_list|()
operator|==
name|this
operator|.
name|isStriped
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|blocks
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|setBlocks
argument_list|(
operator|new
name|BlockInfo
index|[]
block|{
name|newblock
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|this
operator|.
name|blocks
operator|.
name|length
decl_stmt|;
name|BlockInfo
index|[]
name|newlist
init|=
operator|new
name|BlockInfo
index|[
name|size
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|blocks
argument_list|,
literal|0
argument_list|,
name|newlist
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|newlist
index|[
name|size
index|]
operator|=
name|newblock
expr_stmt|;
name|this
operator|.
name|setBlocks
argument_list|(
name|newlist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Set the blocks. */
DECL|method|setBlocks (BlockInfo[] blocks)
specifier|private
name|void
name|setBlocks
parameter_list|(
name|BlockInfo
index|[]
name|blocks
parameter_list|)
block|{
name|this
operator|.
name|blocks
operator|=
operator|(
name|blocks
operator|!=
literal|null
condition|?
name|blocks
else|:
name|BlockInfo
operator|.
name|EMPTY_ARRAY
operator|)
expr_stmt|;
block|}
comment|/** Clear all blocks of the file. */
DECL|method|clearBlocks ()
specifier|public
name|void
name|clearBlocks
parameter_list|()
block|{
name|this
operator|.
name|blocks
operator|=
name|BlockInfo
operator|.
name|EMPTY_ARRAY
expr_stmt|;
block|}
DECL|method|updateRemovedUnderConstructionFiles ( ReclaimContext reclaimContext)
specifier|private
name|void
name|updateRemovedUnderConstructionFiles
parameter_list|(
name|ReclaimContext
name|reclaimContext
parameter_list|)
block|{
if|if
condition|(
name|isUnderConstruction
argument_list|()
operator|&&
name|reclaimContext
operator|.
name|removedUCFiles
operator|!=
literal|null
condition|)
block|{
name|reclaimContext
operator|.
name|removedUCFiles
operator|.
name|add
argument_list|(
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|cleanSubtree (ReclaimContext reclaimContext, final int snapshot, int priorSnapshotId)
specifier|public
name|void
name|cleanSubtree
parameter_list|(
name|ReclaimContext
name|reclaimContext
parameter_list|,
specifier|final
name|int
name|snapshot
parameter_list|,
name|int
name|priorSnapshotId
parameter_list|)
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
comment|// TODO: avoid calling getStoragePolicyID
name|sf
operator|.
name|cleanFile
argument_list|(
name|reclaimContext
argument_list|,
name|this
argument_list|,
name|snapshot
argument_list|,
name|priorSnapshotId
argument_list|,
name|getStoragePolicyID
argument_list|()
argument_list|)
expr_stmt|;
name|updateRemovedUnderConstructionFiles
argument_list|(
name|reclaimContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|.
name|getDiffs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|removeFeature
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|snapshot
operator|==
name|CURRENT_STATE_ID
condition|)
block|{
if|if
condition|(
name|priorSnapshotId
operator|==
name|NO_SNAPSHOT_ID
condition|)
block|{
comment|// this only happens when deleting the current file and it is not
comment|// in any snapshot
name|destroyAndCollectBlocks
argument_list|(
name|reclaimContext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FileUnderConstructionFeature
name|uc
init|=
name|getFileUnderConstructionFeature
argument_list|()
decl_stmt|;
comment|// when deleting the current file and it is in snapshot, we should
comment|// clean the 0-sized block if the file is UC
if|if
condition|(
name|uc
operator|!=
literal|null
condition|)
block|{
name|uc
operator|.
name|cleanZeroSizeBlock
argument_list|(
name|this
argument_list|,
name|reclaimContext
operator|.
name|collectedBlocks
argument_list|)
expr_stmt|;
name|updateRemovedUnderConstructionFiles
argument_list|(
name|reclaimContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|destroyAndCollectBlocks (ReclaimContext reclaimContext)
specifier|public
name|void
name|destroyAndCollectBlocks
parameter_list|(
name|ReclaimContext
name|reclaimContext
parameter_list|)
block|{
comment|// TODO pass in the storage policy
name|reclaimContext
operator|.
name|quotaDelta
argument_list|()
operator|.
name|add
argument_list|(
name|computeQuotaUsage
argument_list|(
name|reclaimContext
operator|.
name|bsps
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|clearFile
argument_list|(
name|reclaimContext
argument_list|)
expr_stmt|;
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
name|sf
operator|.
name|getDiffs
argument_list|()
operator|.
name|destroyAndCollectSnapshotBlocks
argument_list|(
name|reclaimContext
operator|.
name|collectedBlocks
argument_list|)
expr_stmt|;
name|sf
operator|.
name|clearDiffs
argument_list|()
expr_stmt|;
block|}
name|updateRemovedUnderConstructionFiles
argument_list|(
name|reclaimContext
argument_list|)
expr_stmt|;
block|}
DECL|method|clearFile (ReclaimContext reclaimContext)
specifier|public
name|void
name|clearFile
parameter_list|(
name|ReclaimContext
name|reclaimContext
parameter_list|)
block|{
if|if
condition|(
name|blocks
operator|!=
literal|null
operator|&&
name|reclaimContext
operator|.
name|collectedBlocks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|BlockInfo
name|blk
range|:
name|blocks
control|)
block|{
name|reclaimContext
operator|.
name|collectedBlocks
operator|.
name|addDeleteBlock
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
block|}
name|clearBlocks
argument_list|()
expr_stmt|;
if|if
condition|(
name|getAclFeature
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|AclStorage
operator|.
name|removeAclFeature
argument_list|(
name|getAclFeature
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|clear
argument_list|()
expr_stmt|;
name|reclaimContext
operator|.
name|removedINodes
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
comment|// Get the full path name of this inode.
return|return
name|getFullPathName
argument_list|()
return|;
block|}
comment|// This is the only place that needs to use the BlockStoragePolicySuite to
comment|// derive the intended storage type usage for quota by storage type
annotation|@
name|Override
DECL|method|computeQuotaUsage (BlockStoragePolicySuite bsps, byte blockStoragePolicyId, boolean useCache, int lastSnapshotId)
specifier|public
specifier|final
name|QuotaCounts
name|computeQuotaUsage
parameter_list|(
name|BlockStoragePolicySuite
name|bsps
parameter_list|,
name|byte
name|blockStoragePolicyId
parameter_list|,
name|boolean
name|useCache
parameter_list|,
name|int
name|lastSnapshotId
parameter_list|)
block|{
specifier|final
name|QuotaCounts
name|counts
init|=
operator|new
name|QuotaCounts
operator|.
name|Builder
argument_list|()
operator|.
name|nameSpace
argument_list|(
literal|1
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|BlockStoragePolicy
name|bsp
init|=
operator|(
name|blockStoragePolicyId
operator|==
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
operator|)
condition|?
literal|null
else|:
name|bsps
operator|.
name|getPolicy
argument_list|(
name|blockStoragePolicyId
argument_list|)
decl_stmt|;
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|==
literal|null
condition|)
block|{
name|counts
operator|.
name|add
argument_list|(
name|storagespaceConsumed
argument_list|(
name|bsp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counts
return|;
block|}
name|FileDiffList
name|fileDiffList
init|=
name|sf
operator|.
name|getDiffs
argument_list|()
decl_stmt|;
name|int
name|last
init|=
name|fileDiffList
operator|.
name|getLastSnapshotId
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastSnapshotId
operator|==
name|Snapshot
operator|.
name|CURRENT_STATE_ID
operator|||
name|last
operator|==
name|Snapshot
operator|.
name|CURRENT_STATE_ID
condition|)
block|{
name|counts
operator|.
name|add
argument_list|(
name|storagespaceConsumed
argument_list|(
name|bsp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counts
return|;
block|}
specifier|final
name|long
name|ssDeltaNoReplication
decl_stmt|;
name|short
name|replication
decl_stmt|;
if|if
condition|(
name|isStriped
argument_list|()
condition|)
block|{
return|return
name|computeQuotaUsageWithStriped
argument_list|(
name|bsp
argument_list|,
name|counts
argument_list|)
return|;
block|}
if|if
condition|(
name|last
operator|<
name|lastSnapshotId
condition|)
block|{
name|ssDeltaNoReplication
operator|=
name|computeFileSize
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|replication
operator|=
name|getFileReplication
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|sid
init|=
name|fileDiffList
operator|.
name|getSnapshotById
argument_list|(
name|lastSnapshotId
argument_list|)
decl_stmt|;
name|ssDeltaNoReplication
operator|=
name|computeFileSize
argument_list|(
name|sid
argument_list|)
expr_stmt|;
name|replication
operator|=
name|getFileReplication
argument_list|(
name|sid
argument_list|)
expr_stmt|;
block|}
name|counts
operator|.
name|addStorageSpace
argument_list|(
name|ssDeltaNoReplication
operator|*
name|replication
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsp
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|StorageType
argument_list|>
name|storageTypes
init|=
name|bsp
operator|.
name|chooseStorageTypes
argument_list|(
name|replication
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|storageTypes
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|supportTypeQuota
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|counts
operator|.
name|addTypeSpace
argument_list|(
name|t
argument_list|,
name|ssDeltaNoReplication
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|counts
return|;
block|}
comment|/**    * Compute quota of striped file. Note that currently EC files do not support    * append/hflush/hsync, thus the file length recorded in snapshots should be    * the same with the current file length.    */
DECL|method|computeQuotaUsageWithStriped ( BlockStoragePolicy bsp, QuotaCounts counts)
specifier|public
specifier|final
name|QuotaCounts
name|computeQuotaUsageWithStriped
parameter_list|(
name|BlockStoragePolicy
name|bsp
parameter_list|,
name|QuotaCounts
name|counts
parameter_list|)
block|{
name|counts
operator|.
name|addNameSpace
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|counts
operator|.
name|add
argument_list|(
name|storagespaceConsumed
argument_list|(
name|bsp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counts
return|;
block|}
annotation|@
name|Override
DECL|method|computeContentSummary ( int snapshotId, final ContentSummaryComputationContext summary)
specifier|public
specifier|final
name|ContentSummaryComputationContext
name|computeContentSummary
parameter_list|(
name|int
name|snapshotId
parameter_list|,
specifier|final
name|ContentSummaryComputationContext
name|summary
parameter_list|)
block|{
specifier|final
name|ContentCounts
name|counts
init|=
name|summary
operator|.
name|getCounts
argument_list|()
decl_stmt|;
name|counts
operator|.
name|addContent
argument_list|(
name|Content
operator|.
name|FILE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|long
name|fileLen
init|=
name|computeFileSize
argument_list|(
name|snapshotId
argument_list|)
decl_stmt|;
name|counts
operator|.
name|addContent
argument_list|(
name|Content
operator|.
name|LENGTH
argument_list|,
name|fileLen
argument_list|)
expr_stmt|;
name|counts
operator|.
name|addContent
argument_list|(
name|Content
operator|.
name|DISKSPACE
argument_list|,
name|storagespaceConsumed
argument_list|(
literal|null
argument_list|)
operator|.
name|getStorageSpace
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getStoragePolicyID
argument_list|()
operator|!=
name|BLOCK_STORAGE_POLICY_ID_UNSPECIFIED
condition|)
block|{
name|BlockStoragePolicy
name|bsp
init|=
name|summary
operator|.
name|getBlockStoragePolicySuite
argument_list|()
operator|.
name|getPolicy
argument_list|(
name|getStoragePolicyID
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|StorageType
argument_list|>
name|storageTypes
init|=
name|bsp
operator|.
name|chooseStorageTypes
argument_list|(
name|getFileReplication
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|storageTypes
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|.
name|supportTypeQuota
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|counts
operator|.
name|addTypeSpace
argument_list|(
name|t
argument_list|,
name|fileLen
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|summary
return|;
block|}
comment|/** The same as computeFileSize(null). */
DECL|method|computeFileSize ()
specifier|public
specifier|final
name|long
name|computeFileSize
parameter_list|()
block|{
return|return
name|computeFileSize
argument_list|(
name|CURRENT_STATE_ID
argument_list|)
return|;
block|}
comment|/**    * Compute file size of the current file if the given snapshot is null;    * otherwise, get the file size from the given snapshot.    */
DECL|method|computeFileSize (int snapshotId)
specifier|public
specifier|final
name|long
name|computeFileSize
parameter_list|(
name|int
name|snapshotId
parameter_list|)
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshotId
operator|!=
name|CURRENT_STATE_ID
operator|&&
name|sf
operator|!=
literal|null
condition|)
block|{
specifier|final
name|FileDiff
name|d
init|=
name|sf
operator|.
name|getDiffs
argument_list|()
operator|.
name|getDiffById
argument_list|(
name|snapshotId
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
block|{
return|return
name|d
operator|.
name|getFileSize
argument_list|()
return|;
block|}
block|}
return|return
name|computeFileSize
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Compute file size of the current file size    * but not including the last block if it is under construction.    */
DECL|method|computeFileSizeNotIncludingLastUcBlock ()
specifier|public
specifier|final
name|long
name|computeFileSizeNotIncludingLastUcBlock
parameter_list|()
block|{
return|return
name|computeFileSize
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Compute file size of the current file.    *     * @param includesLastUcBlock    *          If the last block is under construction, should it be included?    * @param usePreferredBlockSize4LastUcBlock    *          If the last block is under construction, should we use actual    *          block size or preferred block size?    *          Note that usePreferredBlockSize4LastUcBlock is ignored    *          if includesLastUcBlock == false.    * @return file size    */
DECL|method|computeFileSize (boolean includesLastUcBlock, boolean usePreferredBlockSize4LastUcBlock)
specifier|public
specifier|final
name|long
name|computeFileSize
parameter_list|(
name|boolean
name|includesLastUcBlock
parameter_list|,
name|boolean
name|usePreferredBlockSize4LastUcBlock
parameter_list|)
block|{
if|if
condition|(
name|blocks
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|int
name|last
init|=
name|blocks
operator|.
name|length
operator|-
literal|1
decl_stmt|;
comment|//check if the last block is BlockInfoUnderConstruction
name|BlockInfo
name|lastBlk
init|=
name|blocks
index|[
name|last
index|]
decl_stmt|;
name|long
name|size
init|=
name|lastBlk
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lastBlk
operator|.
name|isComplete
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|includesLastUcBlock
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usePreferredBlockSize4LastUcBlock
condition|)
block|{
name|size
operator|=
name|isStriped
argument_list|()
condition|?
name|getPreferredBlockSize
argument_list|()
operator|*
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|lastBlk
operator|)
operator|.
name|getDataBlockNum
argument_list|()
else|:
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
block|}
block|}
comment|//sum other blocks
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|blocks
index|[
name|i
index|]
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/**    * Compute size consumed by all blocks of the current file,    * including blocks in its snapshots.    * Use preferred block size for the last block if it is under construction.    */
DECL|method|storagespaceConsumed (BlockStoragePolicy bsp)
specifier|public
specifier|final
name|QuotaCounts
name|storagespaceConsumed
parameter_list|(
name|BlockStoragePolicy
name|bsp
parameter_list|)
block|{
if|if
condition|(
name|isStriped
argument_list|()
condition|)
block|{
return|return
name|storagespaceConsumedStriped
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|storagespaceConsumedContiguous
argument_list|(
name|bsp
argument_list|)
return|;
block|}
block|}
comment|// TODO: support EC with heterogeneous storage
DECL|method|storagespaceConsumedStriped ()
specifier|public
specifier|final
name|QuotaCounts
name|storagespaceConsumedStriped
parameter_list|()
block|{
name|QuotaCounts
name|counts
init|=
operator|new
name|QuotaCounts
operator|.
name|Builder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
control|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|b
operator|.
name|isStriped
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|blockSize
init|=
name|b
operator|.
name|isComplete
argument_list|()
condition|?
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|b
operator|)
operator|.
name|spaceConsumed
argument_list|()
else|:
name|getPreferredBlockSize
argument_list|()
operator|*
operator|(
operator|(
name|BlockInfoStriped
operator|)
name|b
operator|)
operator|.
name|getTotalBlockNum
argument_list|()
decl_stmt|;
name|counts
operator|.
name|addStorageSpace
argument_list|(
name|blockSize
argument_list|)
expr_stmt|;
block|}
return|return
name|counts
return|;
block|}
DECL|method|storagespaceConsumedContiguous ( BlockStoragePolicy bsp)
specifier|public
specifier|final
name|QuotaCounts
name|storagespaceConsumedContiguous
parameter_list|(
name|BlockStoragePolicy
name|bsp
parameter_list|)
block|{
name|QuotaCounts
name|counts
init|=
operator|new
name|QuotaCounts
operator|.
name|Builder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Iterable
argument_list|<
name|BlockInfo
argument_list|>
name|blocks
decl_stmt|;
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|==
literal|null
condition|)
block|{
name|blocks
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|getBlocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Collect all distinct blocks
name|Set
argument_list|<
name|BlockInfo
argument_list|>
name|allBlocks
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getBlocks
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|DiffList
argument_list|<
name|FileDiff
argument_list|>
name|diffs
init|=
name|sf
operator|.
name|getDiffs
argument_list|()
operator|.
name|asList
argument_list|()
decl_stmt|;
for|for
control|(
name|FileDiff
name|diff
range|:
name|diffs
control|)
block|{
name|BlockInfo
index|[]
name|diffBlocks
init|=
name|diff
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|diffBlocks
operator|!=
literal|null
condition|)
block|{
name|allBlocks
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|diffBlocks
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|blocks
operator|=
name|allBlocks
expr_stmt|;
block|}
specifier|final
name|short
name|replication
init|=
name|getPreferredBlockReplication
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
control|)
block|{
name|long
name|blockSize
init|=
name|b
operator|.
name|isComplete
argument_list|()
condition|?
name|b
operator|.
name|getNumBytes
argument_list|()
else|:
name|getPreferredBlockSize
argument_list|()
decl_stmt|;
name|counts
operator|.
name|addStorageSpace
argument_list|(
name|blockSize
operator|*
name|replication
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsp
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|StorageType
argument_list|>
name|types
init|=
name|bsp
operator|.
name|chooseStorageTypes
argument_list|(
name|replication
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|types
control|)
block|{
if|if
condition|(
name|t
operator|.
name|supportTypeQuota
argument_list|()
condition|)
block|{
name|counts
operator|.
name|addTypeSpace
argument_list|(
name|t
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|counts
return|;
block|}
comment|/**    * Return the penultimate allocated block for this file.    */
DECL|method|getPenultimateBlock ()
name|BlockInfo
name|getPenultimateBlock
parameter_list|()
block|{
if|if
condition|(
name|blocks
operator|.
name|length
operator|<=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|blocks
index|[
name|blocks
operator|.
name|length
operator|-
literal|2
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|getLastBlock ()
specifier|public
name|BlockInfo
name|getLastBlock
parameter_list|()
block|{
return|return
name|blocks
operator|.
name|length
operator|==
literal|0
condition|?
literal|null
else|:
name|blocks
index|[
name|blocks
operator|.
name|length
operator|-
literal|1
index|]
return|;
block|}
annotation|@
name|Override
DECL|method|numBlocks ()
specifier|public
name|int
name|numBlocks
parameter_list|()
block|{
return|return
name|blocks
operator|.
name|length
return|;
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|dumpTreeRecursively (PrintWriter out, StringBuilder prefix, final int snapshotId)
specifier|public
name|void
name|dumpTreeRecursively
parameter_list|(
name|PrintWriter
name|out
parameter_list|,
name|StringBuilder
name|prefix
parameter_list|,
specifier|final
name|int
name|snapshotId
parameter_list|)
block|{
name|super
operator|.
name|dumpTreeRecursively
argument_list|(
name|out
argument_list|,
name|prefix
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
literal|", fileSize="
operator|+
name|computeFileSize
argument_list|(
name|snapshotId
argument_list|)
argument_list|)
expr_stmt|;
comment|// only compare the first block
name|out
operator|.
name|print
argument_list|(
literal|", blocks="
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
name|blocks
operator|.
name|length
operator|==
literal|0
condition|?
literal|null
else|:
name|blocks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
specifier|final
name|FileWithSnapshotFeature
name|snapshotFeature
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshotFeature
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prefix
operator|.
name|length
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|prefix
operator|.
name|setLength
argument_list|(
name|prefix
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
name|prefix
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|print
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
name|snapshotFeature
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**    * Remove full blocks at the end file up to newLength    * @return sum of sizes of the remained blocks    */
DECL|method|collectBlocksBeyondMax (final long max, final BlocksMapUpdateInfo collectedBlocks, Set<BlockInfo> toRetain)
specifier|public
name|long
name|collectBlocksBeyondMax
parameter_list|(
specifier|final
name|long
name|max
parameter_list|,
specifier|final
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|,
name|Set
argument_list|<
name|BlockInfo
argument_list|>
name|toRetain
parameter_list|)
block|{
specifier|final
name|BlockInfo
index|[]
name|oldBlocks
init|=
name|getBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldBlocks
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// find the minimum n such that the size of the first n blocks> max
name|int
name|n
init|=
literal|0
decl_stmt|;
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|n
argument_list|<
name|oldBlocks
operator|.
name|length
operator|&&
name|max
argument_list|>
name|size
condition|;
name|n
operator|++
control|)
block|{
name|size
operator|+=
name|oldBlocks
index|[
name|n
index|]
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|oldBlocks
operator|.
name|length
condition|)
block|{
return|return
name|size
return|;
block|}
comment|// starting from block n, the data is beyond max.
comment|// resize the array.
name|truncateBlocksTo
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|// collect the blocks beyond max
if|if
condition|(
name|collectedBlocks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
init|;
name|n
operator|<
name|oldBlocks
operator|.
name|length
condition|;
name|n
operator|++
control|)
block|{
specifier|final
name|BlockInfo
name|del
init|=
name|oldBlocks
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|toRetain
operator|==
literal|null
operator|||
operator|!
name|toRetain
operator|.
name|contains
argument_list|(
name|del
argument_list|)
condition|)
block|{
name|collectedBlocks
operator|.
name|addDeleteBlock
argument_list|(
name|del
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|size
return|;
block|}
comment|/**    * compute the quota usage change for a truncate op    * @param newLength the length for truncation    * TODO: properly handle striped blocks (HDFS-7622)    **/
DECL|method|computeQuotaDeltaForTruncate ( long newLength, BlockStoragePolicy bsps, QuotaCounts delta)
name|void
name|computeQuotaDeltaForTruncate
parameter_list|(
name|long
name|newLength
parameter_list|,
name|BlockStoragePolicy
name|bsps
parameter_list|,
name|QuotaCounts
name|delta
parameter_list|)
block|{
specifier|final
name|BlockInfo
index|[]
name|blocks
init|=
name|getBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|blocks
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockInfo
name|b
range|:
name|blocks
control|)
block|{
name|size
operator|+=
name|b
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
name|BlockInfo
index|[]
name|sblocks
init|=
literal|null
decl_stmt|;
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|null
condition|)
block|{
name|FileDiff
name|diff
init|=
name|sf
operator|.
name|getDiffs
argument_list|()
operator|.
name|getLast
argument_list|()
decl_stmt|;
name|sblocks
operator|=
name|diff
operator|!=
literal|null
condition|?
name|diff
operator|.
name|getBlocks
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|blocks
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|size
operator|>
name|newLength
condition|;
name|size
operator|-=
name|blocks
index|[
name|i
index|]
operator|.
name|getNumBytes
argument_list|()
operator|,
operator|--
name|i
control|)
block|{
name|BlockInfo
name|bi
init|=
name|blocks
index|[
name|i
index|]
decl_stmt|;
name|long
name|truncatedBytes
decl_stmt|;
if|if
condition|(
name|size
operator|-
name|newLength
operator|<
name|bi
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
comment|// Record a full block as the last block will be copied during
comment|// recovery
name|truncatedBytes
operator|=
name|bi
operator|.
name|getNumBytes
argument_list|()
operator|-
name|getPreferredBlockSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|truncatedBytes
operator|=
name|bi
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
comment|// The block exist in snapshot, adding back the truncated bytes in the
comment|// existing files
if|if
condition|(
name|sblocks
operator|!=
literal|null
operator|&&
name|i
operator|<
name|sblocks
operator|.
name|length
operator|&&
name|bi
operator|.
name|equals
argument_list|(
name|sblocks
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|truncatedBytes
operator|-=
name|bi
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
name|delta
operator|.
name|addStorageSpace
argument_list|(
operator|-
name|truncatedBytes
operator|*
name|bi
operator|.
name|getReplication
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsps
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|StorageType
argument_list|>
name|types
init|=
name|bsps
operator|.
name|chooseStorageTypes
argument_list|(
name|bi
operator|.
name|getReplication
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageType
name|t
range|:
name|types
control|)
block|{
if|if
condition|(
name|t
operator|.
name|supportTypeQuota
argument_list|()
condition|)
block|{
name|delta
operator|.
name|addTypeSpace
argument_list|(
name|t
argument_list|,
operator|-
name|truncatedBytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|truncateBlocksTo (int n)
name|void
name|truncateBlocksTo
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|final
name|BlockInfo
index|[]
name|newBlocks
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|newBlocks
operator|=
name|BlockInfo
operator|.
name|EMPTY_ARRAY
expr_stmt|;
block|}
else|else
block|{
name|newBlocks
operator|=
operator|new
name|BlockInfo
index|[
name|n
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|getBlocks
argument_list|()
argument_list|,
literal|0
argument_list|,
name|newBlocks
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|// set new blocks
name|setBlocks
argument_list|(
name|newBlocks
argument_list|)
expr_stmt|;
block|}
comment|/**    * This function is only called when block list is stored in snapshot    * diffs. Note that this can only happen when truncation happens with    * snapshots. Since we do not support truncation with striped blocks,    * we only need to handle contiguous blocks here.    */
DECL|method|collectBlocksBeyondSnapshot (BlockInfo[] snapshotBlocks, BlocksMapUpdateInfo collectedBlocks)
specifier|public
name|void
name|collectBlocksBeyondSnapshot
parameter_list|(
name|BlockInfo
index|[]
name|snapshotBlocks
parameter_list|,
name|BlocksMapUpdateInfo
name|collectedBlocks
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|isStriped
argument_list|()
argument_list|)
expr_stmt|;
name|BlockInfo
index|[]
name|oldBlocks
init|=
name|getBlocks
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshotBlocks
operator|==
literal|null
operator|||
name|oldBlocks
operator|==
literal|null
condition|)
return|return;
comment|// Skip blocks in common between the file and the snapshot
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|oldBlocks
operator|.
name|length
operator|&&
name|n
operator|<
name|snapshotBlocks
operator|.
name|length
operator|&&
name|oldBlocks
index|[
name|n
index|]
operator|==
name|snapshotBlocks
index|[
name|n
index|]
condition|)
block|{
name|n
operator|++
expr_stmt|;
block|}
name|truncateBlocksTo
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|// Collect the remaining blocks of the file
while|while
condition|(
name|n
operator|<
name|oldBlocks
operator|.
name|length
condition|)
block|{
name|collectedBlocks
operator|.
name|addDeleteBlock
argument_list|(
name|oldBlocks
index|[
name|n
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Exclude blocks collected for deletion that belong to a snapshot. */
DECL|method|getSnapshotBlocksToRetain (int snapshotId)
name|Set
argument_list|<
name|BlockInfo
argument_list|>
name|getSnapshotBlocksToRetain
parameter_list|(
name|int
name|snapshotId
parameter_list|)
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|BlockInfo
index|[]
name|snapshotBlocks
init|=
name|getDiffs
argument_list|()
operator|.
name|findEarlierSnapshotBlocks
argument_list|(
name|snapshotId
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotBlocks
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Set
argument_list|<
name|BlockInfo
argument_list|>
name|toRetain
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|snapshotBlocks
operator|.
name|length
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|toRetain
argument_list|,
name|snapshotBlocks
argument_list|)
expr_stmt|;
return|return
name|toRetain
return|;
block|}
comment|/**    * @return true if the block is contained in a snapshot or false otherwise.    */
DECL|method|isBlockInLatestSnapshot (BlockInfo block)
name|boolean
name|isBlockInLatestSnapshot
parameter_list|(
name|BlockInfo
name|block
parameter_list|)
block|{
name|FileWithSnapshotFeature
name|sf
init|=
name|this
operator|.
name|getFileWithSnapshotFeature
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|==
literal|null
operator|||
name|sf
operator|.
name|getDiffs
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|BlockInfo
index|[]
name|snapshotBlocks
init|=
name|getDiffs
argument_list|()
operator|.
name|findEarlierSnapshotBlocks
argument_list|(
name|getDiffs
argument_list|()
operator|.
name|getLastSnapshotId
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|snapshotBlocks
operator|!=
literal|null
operator|&&
name|Arrays
operator|.
name|asList
argument_list|(
name|snapshotBlocks
argument_list|)
operator|.
name|contains
argument_list|(
name|block
argument_list|)
return|;
block|}
block|}
end_class

end_unit

