begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_DEFAULT_NAME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_KEY
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|HAServiceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|StateChangeRequestInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HealthCheckFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|ServiceFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Trash
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|terminate
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
operator|.
name|confirmPrompt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|ActiveState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|BootstrapStandby
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|StandbyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgressMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|JournalProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocols
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|StandbyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|RefreshUserMappingsProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|RefreshAuthorizationPolicyProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|GetUserMappingsProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|ExitException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|GenericOptionsParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|JvmPauseMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ServicePlugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**********************************************************  * NameNode serves as both directory namespace manager and  * "inode table" for the Hadoop DFS.  There is a single NameNode  * running in any DFS deployment.  (Well, except when there  * is a second backup/failover NameNode, or when using federated NameNodes.)  *  * The NameNode controls two critical tables:  *   1)  filename->blocksequence (namespace)  *   2)  block->machinelist ("inodes")  *  * The first table is stored on disk and is very precious.  * The second table is rebuilt every time the NameNode comes up.  *  * 'NameNode' refers to both this class as well as the 'NameNode server'.  * The 'FSNamesystem' class actually performs most of the filesystem  * management.  The majority of the 'NameNode' class itself is concerned  * with exposing the IPC interface and the HTTP server to the outside world,  * plus some configuration management.  *  * NameNode implements the  * {@link org.apache.hadoop.hdfs.protocol.ClientProtocol} interface, which  * allows clients to ask for DFS services.  * {@link org.apache.hadoop.hdfs.protocol.ClientProtocol} is not designed for  * direct use by authors of DFS client code.  End-users should instead use the  * {@link org.apache.hadoop.fs.FileSystem} class.  *  * NameNode also implements the  * {@link org.apache.hadoop.hdfs.server.protocol.DatanodeProtocol} interface,  * used by DataNodes that actually store DFS data blocks.  These  * methods are invoked repeatedly and automatically by all the  * DataNodes in a DFS deployment.  *  * NameNode also implements the  * {@link org.apache.hadoop.hdfs.server.protocol.NamenodeProtocol} interface,  * used by secondary namenodes or rebalancing processes to get partial  * NameNode state, for example partial blocksMap etc.  **********************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|NameNode
specifier|public
class|class
name|NameNode
implements|implements
name|NameNodeStatusMXBean
block|{
static|static
block|{
name|HdfsConfiguration
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
comment|/**    * Categories of operations supported by the namenode.    */
DECL|enum|OperationCategory
specifier|public
specifier|static
enum|enum
name|OperationCategory
block|{
comment|/** Operations that are state agnostic */
DECL|enumConstant|UNCHECKED
name|UNCHECKED
block|,
comment|/** Read operation that does not change the namespace state */
DECL|enumConstant|READ
name|READ
block|,
comment|/** Write operation that changes the namespace state */
DECL|enumConstant|WRITE
name|WRITE
block|,
comment|/** Operations related to checkpointing */
DECL|enumConstant|CHECKPOINT
name|CHECKPOINT
block|,
comment|/** Operations related to {@link JournalProtocol} */
DECL|enumConstant|JOURNAL
name|JOURNAL
block|}
comment|/**    * HDFS configuration can have three types of parameters:    *<ol>    *<li>Parameters that are common for all the name services in the cluster.</li>    *<li>Parameters that are specific to a name service. These keys are suffixed    * with nameserviceId in the configuration. For example,    * "dfs.namenode.rpc-address.nameservice1".</li>    *<li>Parameters that are specific to a single name node. These keys are suffixed    * with nameserviceId and namenodeId in the configuration. for example,    * "dfs.namenode.rpc-address.nameservice1.namenode1"</li>    *</ol>    *     * In the latter cases, operators may specify the configuration without    * any suffix, with a nameservice suffix, or with a nameservice and namenode    * suffix. The more specific suffix will take precedence.    *     * These keys are specific to a given namenode, and thus may be configured    * globally, for a nameservice, or for a specific namenode within a nameservice.    */
DECL|field|NAMENODE_SPECIFIC_KEYS
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|NAMENODE_SPECIFIC_KEYS
init|=
block|{
name|DFS_NAMENODE_RPC_ADDRESS_KEY
block|,
name|DFS_NAMENODE_RPC_BIND_HOST_KEY
block|,
name|DFS_NAMENODE_NAME_DIR_KEY
block|,
name|DFS_NAMENODE_EDITS_DIR_KEY
block|,
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
block|,
name|DFS_NAMENODE_CHECKPOINT_DIR_KEY
block|,
name|DFS_NAMENODE_CHECKPOINT_EDITS_DIR_KEY
block|,
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
block|,
name|DFS_NAMENODE_SERVICE_RPC_BIND_HOST_KEY
block|,
name|DFS_NAMENODE_HTTP_ADDRESS_KEY
block|,
name|DFS_NAMENODE_KEYTAB_FILE_KEY
block|,
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY
block|,
name|DFS_SECONDARY_NAMENODE_KEYTAB_FILE_KEY
block|,
name|DFS_NAMENODE_BACKUP_ADDRESS_KEY
block|,
name|DFS_NAMENODE_BACKUP_HTTP_ADDRESS_KEY
block|,
name|DFS_NAMENODE_BACKUP_SERVICE_RPC_ADDRESS_KEY
block|,
name|DFS_NAMENODE_USER_NAME_KEY
block|,
name|DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY
block|,
name|DFS_HA_FENCE_METHODS_KEY
block|,
name|DFS_HA_ZKFC_PORT_KEY
block|,
name|DFS_HA_FENCE_METHODS_KEY
block|}
decl_stmt|;
comment|/**    * @see #NAMENODE_SPECIFIC_KEYS    * These keys are specific to a nameservice, but may not be overridden    * for a specific namenode.    */
DECL|field|NAMESERVICE_SPECIFIC_KEYS
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|NAMESERVICE_SPECIFIC_KEYS
init|=
block|{
name|DFS_HA_AUTO_FAILOVER_ENABLED_KEY
block|}
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"Usage: java NameNode ["
operator|+
name|StartupOption
operator|.
name|BACKUP
operator|.
name|getName
argument_list|()
operator|+
literal|"] | ["
operator|+
name|StartupOption
operator|.
name|CHECKPOINT
operator|.
name|getName
argument_list|()
operator|+
literal|"] | ["
operator|+
name|StartupOption
operator|.
name|FORMAT
operator|.
name|getName
argument_list|()
operator|+
literal|" ["
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" cid ] ["
operator|+
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
operator|+
literal|"] ["
operator|+
name|StartupOption
operator|.
name|NONINTERACTIVE
operator|.
name|getName
argument_list|()
operator|+
literal|"] ] | ["
operator|+
name|StartupOption
operator|.
name|UPGRADE
operator|.
name|getName
argument_list|()
operator|+
literal|" ["
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" cid]"
operator|+
literal|" ["
operator|+
name|StartupOption
operator|.
name|RENAMERESERVED
operator|.
name|getName
argument_list|()
operator|+
literal|"<k-v pairs>] ] | ["
operator|+
name|StartupOption
operator|.
name|ROLLBACK
operator|.
name|getName
argument_list|()
operator|+
literal|"] | ["
operator|+
name|StartupOption
operator|.
name|FINALIZE
operator|.
name|getName
argument_list|()
operator|+
literal|"] | ["
operator|+
name|StartupOption
operator|.
name|IMPORT
operator|.
name|getName
argument_list|()
operator|+
literal|"] | ["
operator|+
name|StartupOption
operator|.
name|INITIALIZESHAREDEDITS
operator|.
name|getName
argument_list|()
operator|+
literal|"] | ["
operator|+
name|StartupOption
operator|.
name|BOOTSTRAPSTANDBY
operator|.
name|getName
argument_list|()
operator|+
literal|"] | ["
operator|+
name|StartupOption
operator|.
name|RECOVER
operator|.
name|getName
argument_list|()
operator|+
literal|" [ "
operator|+
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
operator|+
literal|" ] ]"
decl_stmt|;
DECL|method|getProtocolVersion (String protocol, long clientVersion)
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|ClientProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ClientProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|DatanodeProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|DatanodeProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|NamenodeProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|NamenodeProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|RefreshAuthorizationPolicyProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|RefreshAuthorizationPolicyProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|RefreshUserMappingsProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|RefreshUserMappingsProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|GetUserMappingsProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|GetUserMappingsProtocol
operator|.
name|versionID
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to name node: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
block|}
DECL|field|DEFAULT_PORT
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_PORT
init|=
literal|8020
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|NameNode
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|stateChangeLog
specifier|public
specifier|static
specifier|final
name|Log
name|stateChangeLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.hdfs.StateChange"
argument_list|)
decl_stmt|;
DECL|field|blockStateChangeLog
specifier|public
specifier|static
specifier|final
name|Log
name|blockStateChangeLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"BlockStateChange"
argument_list|)
decl_stmt|;
DECL|field|ACTIVE_STATE
specifier|public
specifier|static
specifier|final
name|HAState
name|ACTIVE_STATE
init|=
operator|new
name|ActiveState
argument_list|()
decl_stmt|;
DECL|field|STANDBY_STATE
specifier|public
specifier|static
specifier|final
name|HAState
name|STANDBY_STATE
init|=
operator|new
name|StandbyState
argument_list|()
decl_stmt|;
DECL|field|namesystem
specifier|protected
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|conf
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|role
specifier|protected
name|NamenodeRole
name|role
decl_stmt|;
DECL|field|state
specifier|private
specifier|volatile
name|HAState
name|state
decl_stmt|;
DECL|field|haEnabled
specifier|private
specifier|final
name|boolean
name|haEnabled
decl_stmt|;
DECL|field|haContext
specifier|private
specifier|final
name|HAContext
name|haContext
decl_stmt|;
DECL|field|allowStaleStandbyReads
specifier|protected
name|boolean
name|allowStaleStandbyReads
decl_stmt|;
comment|/** httpServer */
DECL|field|httpServer
specifier|protected
name|NameNodeHttpServer
name|httpServer
decl_stmt|;
DECL|field|emptier
specifier|private
name|Thread
name|emptier
decl_stmt|;
comment|/** only used for testing purposes  */
DECL|field|stopRequested
specifier|protected
name|boolean
name|stopRequested
init|=
literal|false
decl_stmt|;
comment|/** Registration information of this name-node  */
DECL|field|nodeRegistration
specifier|protected
name|NamenodeRegistration
name|nodeRegistration
decl_stmt|;
comment|/** Activated plug-ins. */
DECL|field|plugins
specifier|private
name|List
argument_list|<
name|ServicePlugin
argument_list|>
name|plugins
decl_stmt|;
DECL|field|rpcServer
specifier|private
name|NameNodeRpcServer
name|rpcServer
decl_stmt|;
DECL|field|pauseMonitor
specifier|private
name|JvmPauseMonitor
name|pauseMonitor
decl_stmt|;
DECL|field|nameNodeStatusBeanName
specifier|private
name|ObjectName
name|nameNodeStatusBeanName
decl_stmt|;
comment|/** Format a new filesystem.  Destroys any filesystem that may already    * exist at this location.  **/
DECL|method|format (Configuration conf)
specifier|public
specifier|static
name|void
name|format
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|format
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|field|metrics
specifier|static
name|NameNodeMetrics
name|metrics
decl_stmt|;
DECL|field|startupProgress
specifier|private
specifier|static
specifier|final
name|StartupProgress
name|startupProgress
init|=
operator|new
name|StartupProgress
argument_list|()
decl_stmt|;
comment|/** Return the {@link FSNamesystem} object.    * @return {@link FSNamesystem} object.    */
DECL|method|getNamesystem ()
specifier|public
name|FSNamesystem
name|getNamesystem
parameter_list|()
block|{
return|return
name|namesystem
return|;
block|}
DECL|method|getRpcServer ()
specifier|public
name|NamenodeProtocols
name|getRpcServer
parameter_list|()
block|{
return|return
name|rpcServer
return|;
block|}
DECL|method|initMetrics (Configuration conf, NamenodeRole role)
specifier|static
name|void
name|initMetrics
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NamenodeRole
name|role
parameter_list|)
block|{
name|metrics
operator|=
name|NameNodeMetrics
operator|.
name|create
argument_list|(
name|conf
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
DECL|method|getNameNodeMetrics ()
specifier|public
specifier|static
name|NameNodeMetrics
name|getNameNodeMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
comment|/**    * Returns object used for reporting namenode startup progress.    *     * @return StartupProgress for reporting namenode startup progress    */
DECL|method|getStartupProgress ()
specifier|public
specifier|static
name|StartupProgress
name|getStartupProgress
parameter_list|()
block|{
return|return
name|startupProgress
return|;
block|}
DECL|method|getAddress (String address)
specifier|public
specifier|static
name|InetSocketAddress
name|getAddress
parameter_list|(
name|String
name|address
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|address
argument_list|,
name|DEFAULT_PORT
argument_list|)
return|;
block|}
comment|/**    * Set the configuration property for the service rpc address    * to address    */
DECL|method|setServiceAddress (Configuration conf, String address)
specifier|public
specifier|static
name|void
name|setServiceAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|address
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting ADDRESS "
operator|+
name|address
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
comment|/**    * Fetches the address for services to use when connecting to namenode    * based on the value of fallback returns null if the special    * address is not specified or returns the default namenode address    * to be used by both clients and services.    * Services here are datanodes, backup node, any non client connection    */
DECL|method|getServiceAddress (Configuration conf, boolean fallback)
specifier|public
specifier|static
name|InetSocketAddress
name|getServiceAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|fallback
parameter_list|)
block|{
name|String
name|addr
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
operator|||
name|addr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|fallback
condition|?
name|getAddress
argument_list|(
name|conf
argument_list|)
else|:
literal|null
return|;
block|}
return|return
name|getAddress
argument_list|(
name|addr
argument_list|)
return|;
block|}
DECL|method|getAddress (Configuration conf)
specifier|public
specifier|static
name|InetSocketAddress
name|getAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|URI
name|filesystemURI
init|=
name|FileSystem
operator|.
name|getDefaultUri
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|getAddress
argument_list|(
name|filesystemURI
argument_list|)
return|;
block|}
comment|/**    * TODO:FEDERATION    * @param filesystemURI    * @return address of file system    */
DECL|method|getAddress (URI filesystemURI)
specifier|public
specifier|static
name|InetSocketAddress
name|getAddress
parameter_list|(
name|URI
name|filesystemURI
parameter_list|)
block|{
name|String
name|authority
init|=
name|filesystemURI
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
if|if
condition|(
name|authority
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Invalid URI for NameNode address (check %s): %s has no authority."
argument_list|,
name|FileSystem
operator|.
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|filesystemURI
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|HdfsConstants
operator|.
name|HDFS_URI_SCHEME
operator|.
name|equalsIgnoreCase
argument_list|(
name|filesystemURI
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Invalid URI for NameNode address (check %s): %s is not of scheme '%s'."
argument_list|,
name|FileSystem
operator|.
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|filesystemURI
operator|.
name|toString
argument_list|()
argument_list|,
name|HdfsConstants
operator|.
name|HDFS_URI_SCHEME
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|getAddress
argument_list|(
name|authority
argument_list|)
return|;
block|}
DECL|method|getUri (InetSocketAddress namenode)
specifier|public
specifier|static
name|URI
name|getUri
parameter_list|(
name|InetSocketAddress
name|namenode
parameter_list|)
block|{
name|int
name|port
init|=
name|namenode
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|String
name|portString
init|=
name|port
operator|==
name|DEFAULT_PORT
condition|?
literal|""
else|:
operator|(
literal|":"
operator|+
name|port
operator|)
decl_stmt|;
return|return
name|URI
operator|.
name|create
argument_list|(
name|HdfsConstants
operator|.
name|HDFS_URI_SCHEME
operator|+
literal|"://"
operator|+
name|namenode
operator|.
name|getHostName
argument_list|()
operator|+
name|portString
argument_list|)
return|;
block|}
comment|//
comment|// Common NameNode methods implementation for the active name-node role.
comment|//
DECL|method|getRole ()
specifier|public
name|NamenodeRole
name|getRole
parameter_list|()
block|{
return|return
name|role
return|;
block|}
DECL|method|isRole (NamenodeRole that)
name|boolean
name|isRole
parameter_list|(
name|NamenodeRole
name|that
parameter_list|)
block|{
return|return
name|role
operator|.
name|equals
argument_list|(
name|that
argument_list|)
return|;
block|}
comment|/**    * Given a configuration get the address of the service rpc server    * If the service rpc is not configured returns null    */
DECL|method|getServiceRpcServerAddress (Configuration conf)
specifier|protected
name|InetSocketAddress
name|getServiceRpcServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NameNode
operator|.
name|getServiceAddress
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|getRpcServerAddress (Configuration conf)
specifier|protected
name|InetSocketAddress
name|getRpcServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getAddress
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/** Given a configuration get the bind host of the service rpc server    *  If the bind host is not configured returns null.    */
DECL|method|getServiceRpcServerBindHost (Configuration conf)
specifier|protected
name|String
name|getServiceRpcServerBindHost
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|addr
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|DFS_NAMENODE_SERVICE_RPC_BIND_HOST_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
operator|||
name|addr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|addr
return|;
block|}
comment|/** Given a configuration get the bind host of the client rpc server    *  If the bind host is not configured returns null.    */
DECL|method|getRpcServerBindHost (Configuration conf)
specifier|protected
name|String
name|getRpcServerBindHost
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|addr
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|DFS_NAMENODE_RPC_BIND_HOST_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
operator|||
name|addr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|addr
return|;
block|}
comment|/**    * Modifies the configuration passed to contain the service rpc address setting    */
DECL|method|setRpcServiceServerAddress (Configuration conf, InetSocketAddress serviceRPCAddress)
specifier|protected
name|void
name|setRpcServiceServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|InetSocketAddress
name|serviceRPCAddress
parameter_list|)
block|{
name|setServiceAddress
argument_list|(
name|conf
argument_list|,
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|serviceRPCAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|setRpcServerAddress (Configuration conf, InetSocketAddress rpcAddress)
specifier|protected
name|void
name|setRpcServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|InetSocketAddress
name|rpcAddress
parameter_list|)
block|{
name|FileSystem
operator|.
name|setDefaultUri
argument_list|(
name|conf
argument_list|,
name|getUri
argument_list|(
name|rpcAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getHttpServerAddress (Configuration conf)
specifier|protected
name|InetSocketAddress
name|getHttpServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getHttpAddress
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/** @return the NameNode HTTP address. */
DECL|method|getHttpAddress (Configuration conf)
specifier|public
specifier|static
name|InetSocketAddress
name|getHttpAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_HTTP_ADDRESS_KEY
argument_list|,
name|DFS_NAMENODE_HTTP_ADDRESS_DEFAULT
argument_list|)
argument_list|)
return|;
block|}
DECL|method|loadNamesystem (Configuration conf)
specifier|protected
name|void
name|loadNamesystem
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|namesystem
operator|=
name|FSNamesystem
operator|.
name|loadFromDisk
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|getRegistration ()
name|NamenodeRegistration
name|getRegistration
parameter_list|()
block|{
return|return
name|nodeRegistration
return|;
block|}
DECL|method|setRegistration ()
name|NamenodeRegistration
name|setRegistration
parameter_list|()
block|{
name|nodeRegistration
operator|=
operator|new
name|NamenodeRegistration
argument_list|(
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|rpcServer
operator|.
name|getRpcAddress
argument_list|()
argument_list|)
argument_list|,
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|getHttpAddress
argument_list|()
argument_list|)
argument_list|,
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
argument_list|,
name|getRole
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|nodeRegistration
return|;
block|}
comment|/* optimize ugi lookup for RPC operations to avoid a trip through    * UGI.getCurrentUser which is synch'ed    */
DECL|method|getRemoteUser ()
specifier|public
specifier|static
name|UserGroupInformation
name|getRemoteUser
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|ugi
init|=
name|Server
operator|.
name|getRemoteUser
argument_list|()
decl_stmt|;
return|return
operator|(
name|ugi
operator|!=
literal|null
operator|)
condition|?
name|ugi
else|:
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
return|;
block|}
comment|/**    * Login as the configured user for the NameNode.    */
DECL|method|loginAsNameNodeUser (Configuration conf)
name|void
name|loginAsNameNodeUser
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|InetSocketAddress
name|socAddr
init|=
name|getRpcServerAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_KEYTAB_FILE_KEY
argument_list|,
name|DFS_NAMENODE_USER_NAME_KEY
argument_list|,
name|socAddr
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initialize name-node.    *     * @param conf the configuration    */
DECL|method|initialize (Configuration conf)
specifier|protected
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS
argument_list|)
operator|==
literal|null
condition|)
block|{
name|String
name|intervals
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_METRICS_PERCENTILES_INTERVALS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|intervals
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS
argument_list|,
name|intervals
argument_list|)
expr_stmt|;
block|}
block|}
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|loginAsNameNodeUser
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|initMetrics
argument_list|(
name|conf
argument_list|,
name|this
operator|.
name|getRole
argument_list|()
argument_list|)
expr_stmt|;
name|StartupProgressMetrics
operator|.
name|register
argument_list|(
name|startupProgress
argument_list|)
expr_stmt|;
if|if
condition|(
name|NamenodeRole
operator|.
name|NAMENODE
operator|==
name|role
condition|)
block|{
name|startHttpServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|loadNamesystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|rpcServer
operator|=
name|createRpcServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NamenodeRole
operator|.
name|NAMENODE
operator|==
name|role
condition|)
block|{
name|httpServer
operator|.
name|setNameNodeAddress
argument_list|(
name|getNameNodeAddress
argument_list|()
argument_list|)
expr_stmt|;
name|httpServer
operator|.
name|setFSImage
argument_list|(
name|getFSImage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|pauseMonitor
operator|=
operator|new
name|JvmPauseMonitor
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pauseMonitor
operator|.
name|start
argument_list|()
expr_stmt|;
name|startCommonServices
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create the RPC server implementation. Used as an extension point for the    * BackupNode.    */
DECL|method|createRpcServer (Configuration conf)
specifier|protected
name|NameNodeRpcServer
name|createRpcServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|NameNodeRpcServer
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/** Start the services common to active and standby states */
DECL|method|startCommonServices (Configuration conf)
specifier|private
name|void
name|startCommonServices
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|startCommonServices
argument_list|(
name|conf
argument_list|,
name|haContext
argument_list|)
expr_stmt|;
name|registerNNSMXBean
argument_list|()
expr_stmt|;
if|if
condition|(
name|NamenodeRole
operator|.
name|NAMENODE
operator|!=
name|role
condition|)
block|{
name|startHttpServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|httpServer
operator|.
name|setNameNodeAddress
argument_list|(
name|getNameNodeAddress
argument_list|()
argument_list|)
expr_stmt|;
name|httpServer
operator|.
name|setFSImage
argument_list|(
name|getFSImage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rpcServer
operator|.
name|start
argument_list|()
expr_stmt|;
name|plugins
operator|=
name|conf
operator|.
name|getInstances
argument_list|(
name|DFS_NAMENODE_PLUGINS_KEY
argument_list|,
name|ServicePlugin
operator|.
name|class
argument_list|)
expr_stmt|;
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|start
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" could not be started"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getRole
argument_list|()
operator|+
literal|" RPC up at: "
operator|+
name|rpcServer
operator|.
name|getRpcAddress
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpcServer
operator|.
name|getServiceRpcAddress
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getRole
argument_list|()
operator|+
literal|" service RPC up at: "
operator|+
name|rpcServer
operator|.
name|getServiceRpcAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|stopCommonServices ()
specifier|private
name|void
name|stopCommonServices
parameter_list|()
block|{
if|if
condition|(
name|rpcServer
operator|!=
literal|null
condition|)
name|rpcServer
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|namesystem
operator|!=
literal|null
condition|)
name|namesystem
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|pauseMonitor
operator|!=
literal|null
condition|)
name|pauseMonitor
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|plugins
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" could not be stopped"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|stopHttpServer
argument_list|()
expr_stmt|;
block|}
DECL|method|startTrashEmptier (final Configuration conf)
specifier|private
name|void
name|startTrashEmptier
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|trashInterval
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|FS_TRASH_INTERVAL_KEY
argument_list|,
name|FS_TRASH_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|trashInterval
operator|==
literal|0
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|trashInterval
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot start trash emptier with negative interval."
operator|+
literal|" Set "
operator|+
name|FS_TRASH_INTERVAL_KEY
operator|+
literal|" to a positive value."
argument_list|)
throw|;
block|}
comment|// This may be called from the transitionToActive code path, in which
comment|// case the current user is the administrator, not the NN. The trash
comment|// emptier needs to run as the NN. See HDFS-3972.
name|FileSystem
name|fs
init|=
name|SecurityUtil
operator|.
name|doAsLoginUser
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|this
operator|.
name|emptier
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Trash
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|)
operator|.
name|getEmptier
argument_list|()
argument_list|,
literal|"Trash Emptier"
argument_list|)
expr_stmt|;
name|this
operator|.
name|emptier
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|emptier
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|stopTrashEmptier ()
specifier|private
name|void
name|stopTrashEmptier
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|emptier
operator|!=
literal|null
condition|)
block|{
name|emptier
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|emptier
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|startHttpServer (final Configuration conf)
specifier|private
name|void
name|startHttpServer
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|httpServer
operator|=
operator|new
name|NameNodeHttpServer
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|getHttpServerAddress
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|httpServer
operator|.
name|start
argument_list|()
expr_stmt|;
name|httpServer
operator|.
name|setStartupProgress
argument_list|(
name|startupProgress
argument_list|)
expr_stmt|;
block|}
DECL|method|stopHttpServer ()
specifier|private
name|void
name|stopHttpServer
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|httpServer
operator|!=
literal|null
condition|)
name|httpServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while stopping httpserver"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Start NameNode.    *<p>    * The name-node can be started with one of the following startup options:    *<ul>     *<li>{@link StartupOption#REGULAR REGULAR} - normal name node startup</li>    *<li>{@link StartupOption#FORMAT FORMAT} - format name node</li>    *<li>{@link StartupOption#BACKUP BACKUP} - start backup node</li>    *<li>{@link StartupOption#CHECKPOINT CHECKPOINT} - start checkpoint node</li>    *<li>{@link StartupOption#UPGRADE UPGRADE} - start the cluster      * upgrade and create a snapshot of the current file system state</li>     *<li>{@link StartupOption#RECOVER RECOVERY} - recover name node    * metadata</li>    *<li>{@link StartupOption#ROLLBACK ROLLBACK} - roll the      *            cluster back to the previous state</li>    *<li>{@link StartupOption#FINALIZE FINALIZE} - finalize     *            previous upgrade</li>    *<li>{@link StartupOption#IMPORT IMPORT} - import checkpoint</li>    *</ul>    * The option is passed via configuration field:     *<tt>dfs.namenode.startup</tt>    *     * The conf will be modified to reflect the actual ports on which     * the NameNode is up and running if the user passes the port as    *<code>zero</code> in the conf.    *     * @param conf  confirguration    * @throws IOException    */
DECL|method|NameNode (Configuration conf)
specifier|public
name|NameNode
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|NamenodeRole
operator|.
name|NAMENODE
argument_list|)
expr_stmt|;
block|}
DECL|method|NameNode (Configuration conf, NamenodeRole role)
specifier|protected
name|NameNode
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NamenodeRole
name|role
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|role
operator|=
name|role
expr_stmt|;
name|String
name|nsId
init|=
name|getNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|this
operator|.
name|haEnabled
operator|=
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
name|state
operator|=
name|createHAState
argument_list|(
name|getStartupOption
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|allowStaleStandbyReads
operator|=
name|HAUtil
operator|.
name|shouldAllowStandbyReads
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|haContext
operator|=
name|createHAContext
argument_list|()
expr_stmt|;
try|try
block|{
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|haContext
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|state
operator|.
name|prepareToEnterState
argument_list|(
name|haContext
argument_list|)
expr_stmt|;
name|state
operator|.
name|enterState
argument_list|(
name|haContext
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|haContext
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|stop
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|HadoopIllegalArgumentException
name|e
parameter_list|)
block|{
name|this
operator|.
name|stop
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|createHAState (StartupOption startOpt)
specifier|protected
name|HAState
name|createHAState
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|haEnabled
operator|||
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADE
condition|)
block|{
return|return
name|ACTIVE_STATE
return|;
block|}
else|else
block|{
return|return
name|STANDBY_STATE
return|;
block|}
block|}
DECL|method|createHAContext ()
specifier|protected
name|HAContext
name|createHAContext
parameter_list|()
block|{
return|return
operator|new
name|NameNodeHAContext
argument_list|()
return|;
block|}
comment|/**    * Wait for service to finish.    * (Normally, it runs forever.)    */
DECL|method|join ()
specifier|public
name|void
name|join
parameter_list|()
block|{
try|try
block|{
name|rpcServer
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Caught interrupted exception "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Stop all NameNode threads and wait for all to finish.    */
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|stopRequested
condition|)
return|return;
name|stopRequested
operator|=
literal|true
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|exitState
argument_list|(
name|haContext
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ServiceFailedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception while exiting state "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|stopCommonServices
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|namesystem
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nameNodeStatusBeanName
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|nameNodeStatusBeanName
argument_list|)
expr_stmt|;
name|nameNodeStatusBeanName
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
DECL|method|isStopRequested ()
specifier|synchronized
name|boolean
name|isStopRequested
parameter_list|()
block|{
return|return
name|stopRequested
return|;
block|}
comment|/**    * Is the cluster currently in safe mode?    */
DECL|method|isInSafeMode ()
specifier|public
name|boolean
name|isInSafeMode
parameter_list|()
block|{
return|return
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
return|;
block|}
comment|/** get FSImage */
annotation|@
name|VisibleForTesting
DECL|method|getFSImage ()
specifier|public
name|FSImage
name|getFSImage
parameter_list|()
block|{
return|return
name|namesystem
operator|.
name|dir
operator|.
name|fsImage
return|;
block|}
comment|/**    * @return NameNode RPC address    */
DECL|method|getNameNodeAddress ()
specifier|public
name|InetSocketAddress
name|getNameNodeAddress
parameter_list|()
block|{
return|return
name|rpcServer
operator|.
name|getRpcAddress
argument_list|()
return|;
block|}
comment|/**    * @return NameNode RPC address in "host:port" string form    */
DECL|method|getNameNodeAddressHostPortString ()
specifier|public
name|String
name|getNameNodeAddressHostPortString
parameter_list|()
block|{
return|return
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|rpcServer
operator|.
name|getRpcAddress
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return NameNode service RPC address if configured, the    *    NameNode RPC address otherwise    */
DECL|method|getServiceRpcAddress ()
specifier|public
name|InetSocketAddress
name|getServiceRpcAddress
parameter_list|()
block|{
specifier|final
name|InetSocketAddress
name|serviceAddr
init|=
name|rpcServer
operator|.
name|getServiceRpcAddress
argument_list|()
decl_stmt|;
return|return
name|serviceAddr
operator|==
literal|null
condition|?
name|rpcServer
operator|.
name|getRpcAddress
argument_list|()
else|:
name|serviceAddr
return|;
block|}
comment|/**    * @return NameNode HTTP address, used by the Web UI, image transfer,    *    and HTTP-based file system clients like Hftp and WebHDFS    */
DECL|method|getHttpAddress ()
specifier|public
name|InetSocketAddress
name|getHttpAddress
parameter_list|()
block|{
return|return
name|httpServer
operator|.
name|getHttpAddress
argument_list|()
return|;
block|}
comment|/**    * @return NameNode HTTPS address, used by the Web UI, image transfer,    *    and HTTP-based file system clients like Hftp and WebHDFS    */
DECL|method|getHttpsAddress ()
specifier|public
name|InetSocketAddress
name|getHttpsAddress
parameter_list|()
block|{
return|return
name|httpServer
operator|.
name|getHttpsAddress
argument_list|()
return|;
block|}
comment|/**    * Verify that configured directories exist, then    * Interactively confirm that formatting is desired     * for each existing directory and format them.    *     * @param conf    * @param force    * @return true if formatting was aborted, false otherwise    * @throws IOException    */
DECL|method|format (Configuration conf, boolean force, boolean isInteractive)
specifier|private
specifier|static
name|boolean
name|format
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|force
parameter_list|,
name|boolean
name|isInteractive
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
name|checkAllowFormat
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|InetSocketAddress
name|socAddr
init|=
name|getAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_KEYTAB_FILE_KEY
argument_list|,
name|DFS_NAMENODE_USER_NAME_KEY
argument_list|,
name|socAddr
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|URI
argument_list|>
name|nameDirsToFormat
init|=
name|FSNamesystem
operator|.
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|sharedDirs
init|=
name|FSNamesystem
operator|.
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|dirsToPrompt
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
name|dirsToPrompt
operator|.
name|addAll
argument_list|(
name|nameDirsToFormat
argument_list|)
expr_stmt|;
name|dirsToPrompt
operator|.
name|addAll
argument_list|(
name|sharedDirs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|editDirsToFormat
init|=
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// if clusterID is not provided - see if you can find the current one
name|String
name|clusterId
init|=
name|StartupOption
operator|.
name|FORMAT
operator|.
name|getClusterId
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterId
operator|==
literal|null
operator|||
name|clusterId
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|//Generate a new cluster id
name|clusterId
operator|=
name|NNStorage
operator|.
name|newClusterID
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Formatting using clusterid: "
operator|+
name|clusterId
argument_list|)
expr_stmt|;
name|FSImage
name|fsImage
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|nameDirsToFormat
argument_list|,
name|editDirsToFormat
argument_list|)
decl_stmt|;
try|try
block|{
name|FSNamesystem
name|fsn
init|=
operator|new
name|FSNamesystem
argument_list|(
name|conf
argument_list|,
name|fsImage
argument_list|)
decl_stmt|;
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fsImage
operator|.
name|confirmFormat
argument_list|(
name|force
argument_list|,
name|isInteractive
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// aborted
block|}
name|fsImage
operator|.
name|format
argument_list|(
name|fsn
argument_list|,
name|clusterId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception during format: "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|fsImage
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|checkAllowFormat (Configuration conf)
specifier|public
specifier|static
name|void
name|checkAllowFormat
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY
argument_list|,
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_DEFAULT
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The option "
operator|+
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY
operator|+
literal|" is set to false for this filesystem, so it "
operator|+
literal|"cannot be formatted. You will need to set "
operator|+
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY
operator|+
literal|" parameter "
operator|+
literal|"to true in order to format this filesystem"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|initializeSharedEdits (Configuration conf)
specifier|public
specifier|static
name|boolean
name|initializeSharedEdits
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|initializeSharedEdits
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|initializeSharedEdits (Configuration conf, boolean force)
specifier|public
specifier|static
name|boolean
name|initializeSharedEdits
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|initializeSharedEdits
argument_list|(
name|conf
argument_list|,
name|force
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Clone the supplied configuration but remove the shared edits dirs.    *    * @param conf Supplies the original configuration.    * @return Cloned configuration without the shared edit dirs.    * @throws IOException on failure to generate the configuration.    */
DECL|method|getConfigurationWithoutSharedEdits ( Configuration conf)
specifier|private
specifier|static
name|Configuration
name|getConfigurationWithoutSharedEdits
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|String
name|editsDirsString
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|editsDirs
argument_list|)
decl_stmt|;
name|Configuration
name|confWithoutShared
init|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|confWithoutShared
operator|.
name|unset
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
argument_list|)
expr_stmt|;
name|confWithoutShared
operator|.
name|setStrings
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
argument_list|,
name|editsDirsString
argument_list|)
expr_stmt|;
return|return
name|confWithoutShared
return|;
block|}
comment|/**    * Format a new shared edits dir and copy in enough edit log segments so that    * the standby NN can start up.    *     * @param conf configuration    * @param force format regardless of whether or not the shared edits dir exists    * @param interactive prompt the user when a dir exists    * @return true if the command aborts, false otherwise    */
DECL|method|initializeSharedEdits (Configuration conf, boolean force, boolean interactive)
specifier|private
specifier|static
name|boolean
name|initializeSharedEdits
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|force
parameter_list|,
name|boolean
name|interactive
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"No shared edits directory configured for namespace "
operator|+
name|nsId
operator|+
literal|" namenode "
operator|+
name|namenodeId
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|InetSocketAddress
name|socAddr
init|=
name|getAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_KEYTAB_FILE_KEY
argument_list|,
name|DFS_NAMENODE_USER_NAME_KEY
argument_list|,
name|socAddr
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|NNStorage
name|existingStorage
init|=
literal|null
decl_stmt|;
name|FSImage
name|sharedEditsImage
init|=
literal|null
decl_stmt|;
try|try
block|{
name|FSNamesystem
name|fsns
init|=
name|FSNamesystem
operator|.
name|loadFromDisk
argument_list|(
name|getConfigurationWithoutSharedEdits
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|existingStorage
operator|=
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
expr_stmt|;
name|NamespaceInfo
name|nsInfo
init|=
name|existingStorage
operator|.
name|getNamespaceInfo
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|sharedEditsDirs
init|=
name|FSNamesystem
operator|.
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|sharedEditsImage
operator|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|Lists
operator|.
expr|<
name|URI
operator|>
name|newArrayList
argument_list|()
argument_list|,
name|sharedEditsDirs
argument_list|)
expr_stmt|;
name|sharedEditsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sharedEditsImage
operator|.
name|confirmFormat
argument_list|(
name|force
argument_list|,
name|interactive
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// abort
block|}
name|NNStorage
name|newSharedStorage
init|=
name|sharedEditsImage
operator|.
name|getStorage
argument_list|()
decl_stmt|;
comment|// Call Storage.format instead of FSImage.format here, since we don't
comment|// actually want to save a checkpoint - just prime the dirs with
comment|// the existing namespace info
name|newSharedStorage
operator|.
name|format
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
name|sharedEditsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|formatNonFileJournals
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
comment|// Need to make sure the edit log segments are in good shape to initialize
comment|// the shared edits dir.
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
name|copyEditLogSegmentsToSharedDir
argument_list|(
name|fsns
argument_list|,
name|sharedEditsDirs
argument_list|,
name|newSharedStorage
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not initialize shared edits dir"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// aborted
block|}
finally|finally
block|{
if|if
condition|(
name|sharedEditsImage
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|sharedEditsImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not close sharedEditsImage"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Have to unlock storage explicitly for the case when we're running in a
comment|// unit test, which runs in the same JVM as NNs.
if|if
condition|(
name|existingStorage
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|existingStorage
operator|.
name|unlockAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not unlock storage directories"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// aborted
block|}
block|}
block|}
return|return
literal|false
return|;
comment|// did not abort
block|}
DECL|method|copyEditLogSegmentsToSharedDir (FSNamesystem fsns, Collection<URI> sharedEditsDirs, NNStorage newSharedStorage, Configuration conf)
specifier|private
specifier|static
name|void
name|copyEditLogSegmentsToSharedDir
parameter_list|(
name|FSNamesystem
name|fsns
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|sharedEditsDirs
parameter_list|,
name|NNStorage
name|newSharedStorage
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|sharedEditsDirs
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"No shared edits specified"
argument_list|)
expr_stmt|;
comment|// Copy edit log segments into the new shared edits dir.
name|List
argument_list|<
name|URI
argument_list|>
name|sharedEditsUris
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|(
name|sharedEditsDirs
argument_list|)
decl_stmt|;
name|FSEditLog
name|newSharedEditLog
init|=
operator|new
name|FSEditLog
argument_list|(
name|conf
argument_list|,
name|newSharedStorage
argument_list|,
name|sharedEditsUris
argument_list|)
decl_stmt|;
name|newSharedEditLog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|newSharedEditLog
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
name|FSEditLog
name|sourceEditLog
init|=
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|editLog
decl_stmt|;
name|long
name|fromTxId
init|=
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
init|=
literal|null
decl_stmt|;
try|try
block|{
name|streams
operator|=
name|sourceEditLog
operator|.
name|selectInputStreams
argument_list|(
name|fromTxId
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Set the nextTxid to the CheckpointTxId+1
name|newSharedEditLog
operator|.
name|setNextTxId
argument_list|(
name|fromTxId
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Copy all edits after last CheckpointTxId to shared edits dir
for|for
control|(
name|EditLogInputStream
name|stream
range|:
name|streams
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Beginning to copy stream "
operator|+
name|stream
operator|+
literal|" to shared edits"
argument_list|)
expr_stmt|;
name|FSEditLogOp
name|op
decl_stmt|;
name|boolean
name|segmentOpen
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|(
name|op
operator|=
name|stream
operator|.
name|readOp
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"copying op: "
operator|+
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|segmentOpen
condition|)
block|{
name|newSharedEditLog
operator|.
name|startLogSegment
argument_list|(
name|op
operator|.
name|txid
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|segmentOpen
operator|=
literal|true
expr_stmt|;
block|}
name|newSharedEditLog
operator|.
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|opCode
operator|==
name|FSEditLogOpCodes
operator|.
name|OP_END_LOG_SEGMENT
condition|)
block|{
name|newSharedEditLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|newSharedEditLog
operator|.
name|endCurrentLogSegment
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ending log segment because of END_LOG_SEGMENT op in "
operator|+
name|stream
argument_list|)
expr_stmt|;
name|segmentOpen
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|segmentOpen
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ending log segment because of end of stream in "
operator|+
name|stream
argument_list|)
expr_stmt|;
name|newSharedEditLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|newSharedEditLog
operator|.
name|endCurrentLogSegment
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|segmentOpen
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|streams
operator|!=
literal|null
condition|)
block|{
name|FSEditLog
operator|.
name|closeAllStreams
argument_list|(
name|streams
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|doRollback (Configuration conf, boolean isConfirmationNeeded)
specifier|public
specifier|static
name|boolean
name|doRollback
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|isConfirmationNeeded
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
name|FSNamesystem
name|nsys
init|=
operator|new
name|FSNamesystem
argument_list|(
name|conf
argument_list|,
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|System
operator|.
name|err
operator|.
name|print
argument_list|(
literal|"\"rollBack\" will remove the current state of the file system,\n"
operator|+
literal|"returning you to the state prior to initiating your recent.\n"
operator|+
literal|"upgrade. This action is permanent and cannot be undone. If you\n"
operator|+
literal|"are performing a rollback in an HA environment, you should be\n"
operator|+
literal|"certain that no NameNode process is running on any host."
argument_list|)
expr_stmt|;
if|if
condition|(
name|isConfirmationNeeded
condition|)
block|{
if|if
condition|(
operator|!
name|confirmPrompt
argument_list|(
literal|"Roll back file system state?"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Rollback aborted."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|nsys
operator|.
name|dir
operator|.
name|fsImage
operator|.
name|doRollback
argument_list|(
name|nsys
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|printUsage (PrintStream out)
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|USAGE
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|parseArguments (String args[])
specifier|static
name|StartupOption
name|parseArguments
parameter_list|(
name|String
name|args
index|[]
parameter_list|)
block|{
name|int
name|argsLen
init|=
operator|(
name|args
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|args
operator|.
name|length
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|StartupOption
operator|.
name|REGULAR
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argsLen
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cmd
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|StartupOption
operator|.
name|FORMAT
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|FORMAT
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i
operator|+
literal|1
init|;
name|i
operator|<
name|argsLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argsLen
condition|)
block|{
comment|// if no cluster id specified, return null
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Must specify a valid cluster ID after the "
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" flag"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|String
name|clusterId
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
comment|// Make sure an id is specified and not another flag
if|if
condition|(
name|clusterId
operator|.
name|isEmpty
argument_list|()
operator|||
name|clusterId
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
argument_list|)
operator|||
name|clusterId
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|NONINTERACTIVE
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Must specify a valid cluster ID after the "
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" flag"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|startOpt
operator|.
name|setClusterId
argument_list|(
name|clusterId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setForceFormat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|NONINTERACTIVE
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setInteractiveFormat
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|GENCLUSTERID
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|GENCLUSTERID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|REGULAR
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|REGULAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|BACKUP
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|BACKUP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|CHECKPOINT
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|CHECKPOINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|UPGRADE
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|UPGRADE
expr_stmt|;
comment|/* Can be followed by CLUSTERID with a required parameter or          * RENAMERESERVED with an optional parameter          */
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|argsLen
condition|)
block|{
name|String
name|flag
init|=
name|args
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|flag
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|argsLen
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
name|startOpt
operator|.
name|setClusterId
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Must specify a valid cluster ID after the "
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" flag"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|flag
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|RENAMERESERVED
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|argsLen
condition|)
block|{
name|FSImageFormat
operator|.
name|setRenameReservedPairs
argument_list|(
name|args
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|FSImageFormat
operator|.
name|useDefaultRenameReservedPairs
argument_list|()
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Unknown upgrade flag "
operator|+
name|flag
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|ROLLINGUPGRADE
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|ROLLINGUPGRADE
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|startOpt
operator|.
name|setRollingUpgradeStartupOption
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|ROLLBACK
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|ROLLBACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|FINALIZE
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|FINALIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|IMPORT
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|IMPORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|BOOTSTRAPSTANDBY
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|BOOTSTRAPSTANDBY
expr_stmt|;
return|return
name|startOpt
return|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|INITIALIZESHAREDEDITS
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|INITIALIZESHAREDEDITS
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i
operator|+
literal|1
init|;
name|i
operator|<
name|argsLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|StartupOption
operator|.
name|NONINTERACTIVE
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setInteractiveFormat
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setForceFormat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Invalid argument: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|return
name|startOpt
return|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|RECOVER
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
if|if
condition|(
name|startOpt
operator|!=
name|StartupOption
operator|.
name|REGULAR
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can't combine -recover with "
operator|+
literal|"other startup options."
argument_list|)
throw|;
block|}
name|startOpt
operator|=
name|StartupOption
operator|.
name|RECOVER
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|argsLen
condition|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setForce
argument_list|(
name|MetaRecoveryContext
operator|.
name|FORCE_FIRST_CHOICE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error parsing recovery options: "
operator|+
literal|"can't understand option \""
operator|+
name|args
index|[
name|i
index|]
operator|+
literal|"\""
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|startOpt
return|;
block|}
DECL|method|setStartupOption (Configuration conf, StartupOption opt)
specifier|private
specifier|static
name|void
name|setStartupOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|StartupOption
name|opt
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|DFS_NAMENODE_STARTUP_KEY
argument_list|,
name|opt
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getStartupOption (Configuration conf)
specifier|static
name|StartupOption
name|getStartupOption
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|StartupOption
operator|.
name|valueOf
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_STARTUP_KEY
argument_list|,
name|StartupOption
operator|.
name|REGULAR
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|doRecovery (StartupOption startOpt, Configuration conf)
specifier|private
specifier|static
name|void
name|doRecovery
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|startOpt
operator|.
name|getForce
argument_list|()
operator|<
name|MetaRecoveryContext
operator|.
name|FORCE_ALL
condition|)
block|{
if|if
condition|(
operator|!
name|confirmPrompt
argument_list|(
literal|"You have selected Metadata Recovery mode.  "
operator|+
literal|"This mode is intended to recover lost metadata on a corrupt "
operator|+
literal|"filesystem.  Metadata recovery mode often permanently deletes "
operator|+
literal|"data from your HDFS filesystem.  Please back up your edit log "
operator|+
literal|"and fsimage before trying this!\n\n"
operator|+
literal|"Are you ready to proceed? (Y/N)\n"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Recovery aborted at user request.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|MetaRecoveryContext
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"starting recovery..."
argument_list|)
expr_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|initMetrics
argument_list|(
name|conf
argument_list|,
name|startOpt
operator|.
name|toNodeRole
argument_list|()
argument_list|)
expr_stmt|;
name|FSNamesystem
name|fsn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fsn
operator|=
name|FSNamesystem
operator|.
name|loadFromDisk
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|fsn
operator|.
name|getFSImage
argument_list|()
operator|.
name|saveNamespace
argument_list|(
name|fsn
argument_list|)
expr_stmt|;
name|MetaRecoveryContext
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"RECOVERY COMPLETE"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|MetaRecoveryContext
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"RECOVERY FAILED: caught exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|MetaRecoveryContext
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"RECOVERY FAILED: caught exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|fsn
operator|!=
literal|null
condition|)
name|fsn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createNameNode (String argv[], Configuration conf)
specifier|public
specifier|static
name|NameNode
name|createNameNode
parameter_list|(
name|String
name|argv
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"createNameNode "
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|argv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
name|conf
operator|=
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
comment|// Parse out some generic args into Configuration.
name|GenericOptionsParser
name|hParser
init|=
operator|new
name|GenericOptionsParser
argument_list|(
name|conf
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|argv
operator|=
name|hParser
operator|.
name|getRemainingArgs
argument_list|()
expr_stmt|;
comment|// Parse the rest, NN specific args.
name|StartupOption
name|startOpt
init|=
name|parseArguments
argument_list|(
name|argv
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
literal|null
condition|)
block|{
name|printUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|setStartupOption
argument_list|(
name|conf
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|startOpt
condition|)
block|{
case|case
name|FORMAT
case|:
block|{
name|boolean
name|aborted
init|=
name|format
argument_list|(
name|conf
argument_list|,
name|startOpt
operator|.
name|getForceFormat
argument_list|()
argument_list|,
name|startOpt
operator|.
name|getInteractiveFormat
argument_list|()
argument_list|)
decl_stmt|;
name|terminate
argument_list|(
name|aborted
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid javac warning
block|}
case|case
name|GENCLUSTERID
case|:
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Generating new cluster id:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|NNStorage
operator|.
name|newClusterID
argument_list|()
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
case|case
name|FINALIZE
case|:
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Use of the argument '"
operator|+
name|StartupOption
operator|.
name|FINALIZE
operator|+
literal|"' is no longer supported. To finalize an upgrade, start the NN "
operator|+
literal|" and then run `hdfs dfsadmin -finalizeUpgrade'"
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid javac warning
block|}
case|case
name|ROLLBACK
case|:
block|{
name|boolean
name|aborted
init|=
name|doRollback
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|terminate
argument_list|(
name|aborted
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid warning
block|}
case|case
name|BOOTSTRAPSTANDBY
case|:
block|{
name|String
name|toolArgs
index|[]
init|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|argv
argument_list|,
literal|1
argument_list|,
name|argv
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|rc
init|=
name|BootstrapStandby
operator|.
name|run
argument_list|(
name|toolArgs
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|terminate
argument_list|(
name|rc
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid warning
block|}
case|case
name|INITIALIZESHAREDEDITS
case|:
block|{
name|boolean
name|aborted
init|=
name|initializeSharedEdits
argument_list|(
name|conf
argument_list|,
name|startOpt
operator|.
name|getForceFormat
argument_list|()
argument_list|,
name|startOpt
operator|.
name|getInteractiveFormat
argument_list|()
argument_list|)
decl_stmt|;
name|terminate
argument_list|(
name|aborted
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid warning
block|}
case|case
name|BACKUP
case|:
case|case
name|CHECKPOINT
case|:
block|{
name|NamenodeRole
name|role
init|=
name|startOpt
operator|.
name|toNodeRole
argument_list|()
decl_stmt|;
name|DefaultMetricsSystem
operator|.
name|initialize
argument_list|(
name|role
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|BackupNode
argument_list|(
name|conf
argument_list|,
name|role
argument_list|)
return|;
block|}
case|case
name|RECOVER
case|:
block|{
name|NameNode
operator|.
name|doRecovery
argument_list|(
name|startOpt
argument_list|,
name|conf
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
default|default:
block|{
name|DefaultMetricsSystem
operator|.
name|initialize
argument_list|(
literal|"NameNode"
argument_list|)
expr_stmt|;
return|return
operator|new
name|NameNode
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * In federation configuration is set for a set of    * namenode and secondary namenode/backup/checkpointer, which are    * grouped under a logical nameservice ID. The configuration keys specific     * to them have suffix set to configured nameserviceId.    *     * This method copies the value from specific key of format key.nameserviceId    * to key, to set up the generic configuration. Once this is done, only    * generic version of the configuration is read in rest of the code, for    * backward compatibility and simpler code changes.    *     * @param conf    *          Configuration object to lookup specific key and to set the value    *          to the key passed. Note the conf object is modified    * @param nameserviceId name service Id (to distinguish federated NNs)    * @param namenodeId the namenode ID (to distinguish HA NNs)    * @see DFSUtil#setGenericConf(Configuration, String, String, String...)    */
DECL|method|initializeGenericKeys (Configuration conf, String nameserviceId, String namenodeId)
specifier|public
specifier|static
name|void
name|initializeGenericKeys
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|nameserviceId
parameter_list|,
name|String
name|namenodeId
parameter_list|)
block|{
if|if
condition|(
operator|(
name|nameserviceId
operator|!=
literal|null
operator|&&
operator|!
name|nameserviceId
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|namenodeId
operator|!=
literal|null
operator|&&
operator|!
name|namenodeId
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|nameserviceId
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|DFS_NAMESERVICE_ID
argument_list|,
name|nameserviceId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namenodeId
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|DFS_HA_NAMENODE_ID_KEY
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
block|}
name|DFSUtil
operator|.
name|setGenericConf
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|,
name|namenodeId
argument_list|,
name|NAMENODE_SPECIFIC_KEYS
argument_list|)
expr_stmt|;
name|DFSUtil
operator|.
name|setGenericConf
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|,
literal|null
argument_list|,
name|NAMESERVICE_SPECIFIC_KEYS
argument_list|)
expr_stmt|;
block|}
comment|// If the RPC address is set use it to (re-)configure the default FS
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_RPC_ADDRESS_KEY
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|URI
name|defaultUri
init|=
name|URI
operator|.
name|create
argument_list|(
name|HdfsConstants
operator|.
name|HDFS_URI_SCHEME
operator|+
literal|"://"
operator|+
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_RPC_ADDRESS_KEY
argument_list|)
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|defaultUri
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting "
operator|+
name|FS_DEFAULT_NAME_KEY
operator|+
literal|" to "
operator|+
name|defaultUri
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Get the name service Id for the node    * @return name service Id or null if federation is not configured    */
DECL|method|getNameServiceId (Configuration conf)
specifier|protected
name|String
name|getNameServiceId
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/**    */
DECL|method|main (String argv[])
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
name|argv
index|[]
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|DFSUtil
operator|.
name|parseHelpArgument
argument_list|(
name|argv
argument_list|,
name|NameNode
operator|.
name|USAGE
argument_list|,
name|System
operator|.
name|out
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|StringUtils
operator|.
name|startupShutdownMessage
argument_list|(
name|NameNode
operator|.
name|class
argument_list|,
name|argv
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|NameNode
name|namenode
init|=
name|createNameNode
argument_list|(
name|argv
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|namenode
operator|!=
literal|null
condition|)
block|{
name|namenode
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Exception in namenode join"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|monitorHealth ()
specifier|synchronized
name|void
name|monitorHealth
parameter_list|()
throws|throws
name|HealthCheckFailedException
throws|,
name|AccessControlException
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
return|return;
comment|// no-op, if HA is not enabled
block|}
name|getNamesystem
argument_list|()
operator|.
name|checkAvailableResources
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getNamesystem
argument_list|()
operator|.
name|nameNodeHasResourcesAvailable
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|HealthCheckFailedException
argument_list|(
literal|"The NameNode has no resources available"
argument_list|)
throw|;
block|}
block|}
DECL|method|transitionToActive ()
specifier|synchronized
name|void
name|transitionToActive
parameter_list|()
throws|throws
name|ServiceFailedException
throws|,
name|AccessControlException
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
throw|throw
operator|new
name|ServiceFailedException
argument_list|(
literal|"HA for namenode is not enabled"
argument_list|)
throw|;
block|}
name|state
operator|.
name|setState
argument_list|(
name|haContext
argument_list|,
name|ACTIVE_STATE
argument_list|)
expr_stmt|;
block|}
DECL|method|transitionToStandby ()
specifier|synchronized
name|void
name|transitionToStandby
parameter_list|()
throws|throws
name|ServiceFailedException
throws|,
name|AccessControlException
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
throw|throw
operator|new
name|ServiceFailedException
argument_list|(
literal|"HA for namenode is not enabled"
argument_list|)
throw|;
block|}
name|state
operator|.
name|setState
argument_list|(
name|haContext
argument_list|,
name|STANDBY_STATE
argument_list|)
expr_stmt|;
block|}
DECL|method|getServiceStatus ()
specifier|synchronized
name|HAServiceStatus
name|getServiceStatus
parameter_list|()
throws|throws
name|ServiceFailedException
throws|,
name|AccessControlException
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
throw|throw
operator|new
name|ServiceFailedException
argument_list|(
literal|"HA for namenode is not enabled"
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|HAServiceStatus
argument_list|(
name|HAServiceState
operator|.
name|INITIALIZING
argument_list|)
return|;
block|}
name|HAServiceState
name|retState
init|=
name|state
operator|.
name|getServiceState
argument_list|()
decl_stmt|;
name|HAServiceStatus
name|ret
init|=
operator|new
name|HAServiceStatus
argument_list|(
name|retState
argument_list|)
decl_stmt|;
if|if
condition|(
name|retState
operator|==
name|HAServiceState
operator|.
name|STANDBY
condition|)
block|{
name|String
name|safemodeTip
init|=
name|namesystem
operator|.
name|getSafeModeTip
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|safemodeTip
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ret
operator|.
name|setNotReadyToBecomeActive
argument_list|(
literal|"The NameNode is in safemode. "
operator|+
name|safemodeTip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|setReadyToBecomeActive
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|retState
operator|==
name|HAServiceState
operator|.
name|ACTIVE
condition|)
block|{
name|ret
operator|.
name|setReadyToBecomeActive
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|setNotReadyToBecomeActive
argument_list|(
literal|"State is "
operator|+
name|state
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|getServiceState ()
specifier|synchronized
name|HAServiceState
name|getServiceState
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
name|HAServiceState
operator|.
name|INITIALIZING
return|;
block|}
return|return
name|state
operator|.
name|getServiceState
argument_list|()
return|;
block|}
comment|/**    * Register NameNodeStatusMXBean    */
DECL|method|registerNNSMXBean ()
specifier|private
name|void
name|registerNNSMXBean
parameter_list|()
block|{
name|nameNodeStatusBeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"NameNode"
argument_list|,
literal|"NameNodeStatus"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// NameNodeStatusMXBean
DECL|method|getNNRole ()
specifier|public
name|String
name|getNNRole
parameter_list|()
block|{
name|String
name|roleStr
init|=
literal|""
decl_stmt|;
name|NamenodeRole
name|role
init|=
name|getRole
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|role
condition|)
block|{
name|roleStr
operator|=
name|role
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|roleStr
return|;
block|}
annotation|@
name|Override
comment|// NameNodeStatusMXBean
DECL|method|getState ()
specifier|public
name|String
name|getState
parameter_list|()
block|{
name|String
name|servStateStr
init|=
literal|""
decl_stmt|;
name|HAServiceState
name|servState
init|=
name|getServiceState
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|servState
condition|)
block|{
name|servStateStr
operator|=
name|servState
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|servStateStr
return|;
block|}
annotation|@
name|Override
comment|// NameNodeStatusMXBean
DECL|method|getHostAndPort ()
specifier|public
name|String
name|getHostAndPort
parameter_list|()
block|{
return|return
name|getNameNodeAddressHostPortString
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeStatusMXBean
DECL|method|isSecurityEnabled ()
specifier|public
name|boolean
name|isSecurityEnabled
parameter_list|()
block|{
return|return
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
return|;
block|}
comment|/**    * Shutdown the NN immediately in an ungraceful way. Used when it would be    * unsafe for the NN to continue operating, e.g. during a failed HA state    * transition.    *     * @param t exception which warrants the shutdown. Printed to the NN log    *          before exit.    * @throws ExitException thrown only for testing.    */
DECL|method|doImmediateShutdown (Throwable t)
specifier|protected
specifier|synchronized
name|void
name|doImmediateShutdown
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|ExitException
block|{
name|String
name|message
init|=
literal|"Error encountered requiring NN shutdown. "
operator|+
literal|"Shutting down immediately."
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|message
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ignored
parameter_list|)
block|{
comment|// This is unlikely to happen, but there's nothing we can do if it does.
block|}
name|terminate
argument_list|(
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/**    * Class used to expose {@link NameNode} as context to {@link HAState}    */
DECL|class|NameNodeHAContext
specifier|protected
class|class
name|NameNodeHAContext
implements|implements
name|HAContext
block|{
annotation|@
name|Override
DECL|method|setState (HAState s)
specifier|public
name|void
name|setState
parameter_list|(
name|HAState
name|s
parameter_list|)
block|{
name|state
operator|=
name|s
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getState ()
specifier|public
name|HAState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
annotation|@
name|Override
DECL|method|startActiveServices ()
specifier|public
name|void
name|startActiveServices
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|namesystem
operator|.
name|startActiveServices
argument_list|()
expr_stmt|;
name|startTrashEmptier
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|stopActiveServices ()
specifier|public
name|void
name|stopActiveServices
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|namesystem
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|stopActiveServices
argument_list|()
expr_stmt|;
block|}
name|stopTrashEmptier
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|startStandbyServices ()
specifier|public
name|void
name|startStandbyServices
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|namesystem
operator|.
name|startStandbyServices
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|prepareToStopStandbyServices ()
specifier|public
name|void
name|prepareToStopStandbyServices
parameter_list|()
throws|throws
name|ServiceFailedException
block|{
try|try
block|{
name|namesystem
operator|.
name|prepareToStopStandbyServices
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|stopStandbyServices ()
specifier|public
name|void
name|stopStandbyServices
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|namesystem
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|stopStandbyServices
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeLock ()
specifier|public
name|void
name|writeLock
parameter_list|()
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeUnlock ()
specifier|public
name|void
name|writeUnlock
parameter_list|()
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|/** Check if an operation of given category is allowed */
annotation|@
name|Override
DECL|method|checkOperation (final OperationCategory op)
specifier|public
name|void
name|checkOperation
parameter_list|(
specifier|final
name|OperationCategory
name|op
parameter_list|)
throws|throws
name|StandbyException
block|{
name|state
operator|.
name|checkOperation
argument_list|(
name|haContext
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|allowStaleReads ()
specifier|public
name|boolean
name|allowStaleReads
parameter_list|()
block|{
return|return
name|allowStaleStandbyReads
return|;
block|}
block|}
DECL|method|isStandbyState ()
specifier|public
name|boolean
name|isStandbyState
parameter_list|()
block|{
return|return
operator|(
name|state
operator|.
name|equals
argument_list|(
name|STANDBY_STATE
argument_list|)
operator|)
return|;
block|}
comment|/**    * Check that a request to change this node's HA state is valid.    * In particular, verifies that, if auto failover is enabled, non-forced    * requests from the HAAdmin CLI are rejected, and vice versa.    *    * @param req the request to check    * @throws AccessControlException if the request is disallowed    */
DECL|method|checkHaStateChange (StateChangeRequestInfo req)
name|void
name|checkHaStateChange
parameter_list|(
name|StateChangeRequestInfo
name|req
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|boolean
name|autoHaEnabled
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_HA_AUTO_FAILOVER_ENABLED_KEY
argument_list|,
name|DFS_HA_AUTO_FAILOVER_ENABLED_DEFAULT
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|req
operator|.
name|getSource
argument_list|()
condition|)
block|{
case|case
name|REQUEST_BY_USER
case|:
if|if
condition|(
name|autoHaEnabled
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Manual HA control for this NameNode is disallowed, because "
operator|+
literal|"automatic HA is enabled."
argument_list|)
throw|;
block|}
break|break;
case|case
name|REQUEST_BY_USER_FORCED
case|:
if|if
condition|(
name|autoHaEnabled
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Allowing manual HA control from "
operator|+
name|Server
operator|.
name|getRemoteAddress
argument_list|()
operator|+
literal|" even though automatic HA is enabled, because the user "
operator|+
literal|"specified the force flag"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REQUEST_BY_ZKFC
case|:
if|if
condition|(
operator|!
name|autoHaEnabled
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Request from ZK failover controller at "
operator|+
name|Server
operator|.
name|getRemoteAddress
argument_list|()
operator|+
literal|" denied since automatic HA "
operator|+
literal|"is not enabled"
argument_list|)
throw|;
block|}
break|break;
block|}
block|}
block|}
end_class

end_unit

