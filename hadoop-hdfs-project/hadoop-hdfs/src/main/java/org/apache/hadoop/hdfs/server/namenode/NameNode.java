begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|ReconfigurableBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|ReconfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Trash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|HAServiceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceProtocol
operator|.
name|StateChangeRequestInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HAServiceStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|HealthCheckFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
operator|.
name|ServiceFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|RollingUpgradeStartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|MetricsLoggerTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|ActiveState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|BootstrapStandby
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|HAState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|ha
operator|.
name|StandbyState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|startupprogress
operator|.
name|StartupProgressMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|JournalProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocols
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|ExternalCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RefreshCallQueueProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RetriableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|StandbyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|RefreshUserMappingsProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|RefreshAuthorizationPolicyProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tools
operator|.
name|GetUserMappingsProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tracing
operator|.
name|TraceAdminProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tracing
operator|.
name|TraceUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|tracing
operator|.
name|TracerConfigurationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|ExitException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|GenericOptionsParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|JvmPauseMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ServicePlugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Tracer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_DEFAULT_NAME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_TRASH_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsClientConfigKeys
operator|.
name|DFS_NAMENODE_RPC_PORT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_CALLER_CONTEXT_ENABLED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_CALLER_CONTEXT_ENABLED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_AUTO_FAILOVER_ENABLED_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_AUTO_FAILOVER_ENABLED_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_FENCE_METHODS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_NAMENODE_ID_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HA_ZKFC_PORT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_METRICS_PERCENTILES_INTERVALS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_BACKUP_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_BACKUP_HTTP_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_BACKUP_SERVICE_RPC_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_EDITS_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HTTPS_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HTTPS_BIND_HOST_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HTTP_ADDRESS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HTTP_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HTTP_BIND_HOST_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_KEYTAB_FILE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_LIFELINE_RPC_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_LIFELINE_RPC_BIND_HOST_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_METRICS_LOGGER_PERIOD_SECONDS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_METRICS_LOGGER_PERIOD_SECONDS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_PLUGINS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RPC_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_RPC_BIND_HOST_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SECONDARY_HTTPS_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SERVICE_RPC_BIND_HOST_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_STARTUP_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMESERVICE_ID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_SECONDARY_NAMENODE_KEYTAB_FILE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|FS_PROTECTED_DIRECTORIES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
operator|.
name|terminate
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
operator|.
name|confirmPrompt
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|IPC_BACKOFF_ENABLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|IPC_NAMESPACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|IPC_BACKOFF_ENABLE_DEFAULT
import|;
end_import

begin_comment
comment|/**********************************************************  * NameNode serves as both directory namespace manager and  * "inode table" for the Hadoop DFS.  There is a single NameNode  * running in any DFS deployment.  (Well, except when there  * is a second backup/failover NameNode, or when using federated NameNodes.)  *  * The NameNode controls two critical tables:  *   1)  filename->blocksequence (namespace)  *   2)  block->machinelist ("inodes")  *  * The first table is stored on disk and is very precious.  * The second table is rebuilt every time the NameNode comes up.  *  * 'NameNode' refers to both this class as well as the 'NameNode server'.  * The 'FSNamesystem' class actually performs most of the filesystem  * management.  The majority of the 'NameNode' class itself is concerned  * with exposing the IPC interface and the HTTP server to the outside world,  * plus some configuration management.  *  * NameNode implements the  * {@link org.apache.hadoop.hdfs.protocol.ClientProtocol} interface, which  * allows clients to ask for DFS services.  * {@link org.apache.hadoop.hdfs.protocol.ClientProtocol} is not designed for  * direct use by authors of DFS client code.  End-users should instead use the  * {@link org.apache.hadoop.fs.FileSystem} class.  *  * NameNode also implements the  * {@link org.apache.hadoop.hdfs.server.protocol.DatanodeProtocol} interface,  * used by DataNodes that actually store DFS data blocks.  These  * methods are invoked repeatedly and automatically by all the  * DataNodes in a DFS deployment.  *  * NameNode also implements the  * {@link org.apache.hadoop.hdfs.server.protocol.NamenodeProtocol} interface,  * used by secondary namenodes or rebalancing processes to get partial  * NameNode state, for example partial blocksMap etc.  **********************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|NameNode
specifier|public
class|class
name|NameNode
extends|extends
name|ReconfigurableBase
implements|implements
name|NameNodeStatusMXBean
block|{
static|static
block|{
name|HdfsConfiguration
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
comment|/**    * Categories of operations supported by the namenode.    */
DECL|enum|OperationCategory
specifier|public
specifier|static
enum|enum
name|OperationCategory
block|{
comment|/** Operations that are state agnostic */
DECL|enumConstant|UNCHECKED
name|UNCHECKED
block|,
comment|/** Read operation that does not change the namespace state */
DECL|enumConstant|READ
name|READ
block|,
comment|/** Write operation that changes the namespace state */
DECL|enumConstant|WRITE
name|WRITE
block|,
comment|/** Operations related to checkpointing */
DECL|enumConstant|CHECKPOINT
name|CHECKPOINT
block|,
comment|/** Operations related to {@link JournalProtocol} */
DECL|enumConstant|JOURNAL
name|JOURNAL
block|}
comment|/**    * HDFS configuration can have three types of parameters:    *<ol>    *<li>Parameters that are common for all the name services in the cluster.</li>    *<li>Parameters that are specific to a name service. These keys are suffixed    * with nameserviceId in the configuration. For example,    * "dfs.namenode.rpc-address.nameservice1".</li>    *<li>Parameters that are specific to a single name node. These keys are suffixed    * with nameserviceId and namenodeId in the configuration. for example,    * "dfs.namenode.rpc-address.nameservice1.namenode1"</li>    *</ol>    *     * In the latter cases, operators may specify the configuration without    * any suffix, with a nameservice suffix, or with a nameservice and namenode    * suffix. The more specific suffix will take precedence.    *     * These keys are specific to a given namenode, and thus may be configured    * globally, for a nameservice, or for a specific namenode within a nameservice.    */
DECL|field|NAMENODE_SPECIFIC_KEYS
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|NAMENODE_SPECIFIC_KEYS
init|=
block|{
name|DFS_NAMENODE_RPC_ADDRESS_KEY
block|,
name|DFS_NAMENODE_RPC_BIND_HOST_KEY
block|,
name|DFS_NAMENODE_NAME_DIR_KEY
block|,
name|DFS_NAMENODE_EDITS_DIR_KEY
block|,
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
block|,
name|DFS_NAMENODE_CHECKPOINT_DIR_KEY
block|,
name|DFS_NAMENODE_CHECKPOINT_EDITS_DIR_KEY
block|,
name|DFS_NAMENODE_LIFELINE_RPC_ADDRESS_KEY
block|,
name|DFS_NAMENODE_LIFELINE_RPC_BIND_HOST_KEY
block|,
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
block|,
name|DFS_NAMENODE_SERVICE_RPC_BIND_HOST_KEY
block|,
name|DFS_NAMENODE_HTTP_ADDRESS_KEY
block|,
name|DFS_NAMENODE_HTTPS_ADDRESS_KEY
block|,
name|DFS_NAMENODE_HTTP_BIND_HOST_KEY
block|,
name|DFS_NAMENODE_HTTPS_BIND_HOST_KEY
block|,
name|DFS_NAMENODE_KEYTAB_FILE_KEY
block|,
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY
block|,
name|DFS_NAMENODE_SECONDARY_HTTPS_ADDRESS_KEY
block|,
name|DFS_SECONDARY_NAMENODE_KEYTAB_FILE_KEY
block|,
name|DFS_NAMENODE_BACKUP_ADDRESS_KEY
block|,
name|DFS_NAMENODE_BACKUP_HTTP_ADDRESS_KEY
block|,
name|DFS_NAMENODE_BACKUP_SERVICE_RPC_ADDRESS_KEY
block|,
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
block|,
name|DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY
block|,
name|DFS_HA_FENCE_METHODS_KEY
block|,
name|DFS_HA_ZKFC_PORT_KEY
block|,   }
decl_stmt|;
comment|/**    * @see #NAMENODE_SPECIFIC_KEYS    * These keys are specific to a nameservice, but may not be overridden    * for a specific namenode.    */
DECL|field|NAMESERVICE_SPECIFIC_KEYS
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|NAMESERVICE_SPECIFIC_KEYS
init|=
block|{
name|DFS_HA_AUTO_FAILOVER_ENABLED_KEY
block|}
decl_stmt|;
DECL|field|ipcClientRPCBackoffEnable
specifier|private
name|String
name|ipcClientRPCBackoffEnable
decl_stmt|;
comment|/** A list of property that are reconfigurable at runtime. */
DECL|field|reconfigurableProperties
specifier|private
specifier|final
name|TreeSet
argument_list|<
name|String
argument_list|>
name|reconfigurableProperties
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
name|DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY
argument_list|,
name|FS_PROTECTED_DIRECTORIES
argument_list|,
name|HADOOP_CALLER_CONTEXT_ENABLED_KEY
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|USAGE
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"Usage: hdfs namenode ["
operator|+
name|StartupOption
operator|.
name|BACKUP
operator|.
name|getName
argument_list|()
operator|+
literal|"] | \n\t["
operator|+
name|StartupOption
operator|.
name|CHECKPOINT
operator|.
name|getName
argument_list|()
operator|+
literal|"] | \n\t["
operator|+
name|StartupOption
operator|.
name|FORMAT
operator|.
name|getName
argument_list|()
operator|+
literal|" ["
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" cid ] ["
operator|+
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
operator|+
literal|"] ["
operator|+
name|StartupOption
operator|.
name|NONINTERACTIVE
operator|.
name|getName
argument_list|()
operator|+
literal|"] ] | \n\t["
operator|+
name|StartupOption
operator|.
name|UPGRADE
operator|.
name|getName
argument_list|()
operator|+
literal|" ["
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" cid]"
operator|+
literal|" ["
operator|+
name|StartupOption
operator|.
name|RENAMERESERVED
operator|.
name|getName
argument_list|()
operator|+
literal|"<k-v pairs>] ] | \n\t["
operator|+
name|StartupOption
operator|.
name|UPGRADEONLY
operator|.
name|getName
argument_list|()
operator|+
literal|" ["
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" cid]"
operator|+
literal|" ["
operator|+
name|StartupOption
operator|.
name|RENAMERESERVED
operator|.
name|getName
argument_list|()
operator|+
literal|"<k-v pairs>] ] | \n\t["
operator|+
name|StartupOption
operator|.
name|ROLLBACK
operator|.
name|getName
argument_list|()
operator|+
literal|"] | \n\t["
operator|+
name|StartupOption
operator|.
name|ROLLINGUPGRADE
operator|.
name|getName
argument_list|()
operator|+
literal|" "
operator|+
name|RollingUpgradeStartupOption
operator|.
name|getAllOptionString
argument_list|()
operator|+
literal|" ] | \n\t["
operator|+
name|StartupOption
operator|.
name|IMPORT
operator|.
name|getName
argument_list|()
operator|+
literal|"] | \n\t["
operator|+
name|StartupOption
operator|.
name|INITIALIZESHAREDEDITS
operator|.
name|getName
argument_list|()
operator|+
literal|"] | \n\t["
operator|+
name|StartupOption
operator|.
name|BOOTSTRAPSTANDBY
operator|.
name|getName
argument_list|()
operator|+
literal|" ["
operator|+
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
operator|+
literal|"] ["
operator|+
name|StartupOption
operator|.
name|NONINTERACTIVE
operator|.
name|getName
argument_list|()
operator|+
literal|"] ["
operator|+
name|StartupOption
operator|.
name|SKIPSHAREDEDITSCHECK
operator|.
name|getName
argument_list|()
operator|+
literal|"] ] | \n\t["
operator|+
name|StartupOption
operator|.
name|RECOVER
operator|.
name|getName
argument_list|()
operator|+
literal|" [ "
operator|+
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
operator|+
literal|"] ] | \n\t["
operator|+
name|StartupOption
operator|.
name|METADATAVERSION
operator|.
name|getName
argument_list|()
operator|+
literal|" ]"
decl_stmt|;
DECL|method|getProtocolVersion (String protocol, long clientVersion)
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|ClientProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ClientProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|DatanodeProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|DatanodeProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|NamenodeProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|NamenodeProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|RefreshAuthorizationPolicyProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|RefreshAuthorizationPolicyProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|RefreshUserMappingsProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|RefreshUserMappingsProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|RefreshCallQueueProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|RefreshCallQueueProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|GetUserMappingsProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|GetUserMappingsProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|TraceAdminProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|TraceAdminProtocol
operator|.
name|versionID
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to name node: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
block|}
comment|/**    * @deprecated Use {@link HdfsClientConfigKeys#DFS_NAMENODE_RPC_PORT_DEFAULT}    *             instead.    */
annotation|@
name|Deprecated
DECL|field|DEFAULT_PORT
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_PORT
init|=
name|DFS_NAMENODE_RPC_PORT_DEFAULT
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NameNode
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|stateChangeLog
specifier|public
specifier|static
specifier|final
name|Logger
name|stateChangeLog
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"org.apache.hadoop.hdfs.StateChange"
argument_list|)
decl_stmt|;
DECL|field|blockStateChangeLog
specifier|public
specifier|static
specifier|final
name|Logger
name|blockStateChangeLog
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"BlockStateChange"
argument_list|)
decl_stmt|;
DECL|field|ACTIVE_STATE
specifier|public
specifier|static
specifier|final
name|HAState
name|ACTIVE_STATE
init|=
operator|new
name|ActiveState
argument_list|()
decl_stmt|;
DECL|field|STANDBY_STATE
specifier|public
specifier|static
specifier|final
name|HAState
name|STANDBY_STATE
init|=
operator|new
name|StandbyState
argument_list|()
decl_stmt|;
DECL|field|NAMENODE_HTRACE_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|NAMENODE_HTRACE_PREFIX
init|=
literal|"namenode.htrace."
decl_stmt|;
DECL|field|MetricsLog
specifier|public
specifier|static
specifier|final
name|Log
name|MetricsLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"NameNodeMetricsLog"
argument_list|)
decl_stmt|;
DECL|field|namesystem
specifier|protected
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|role
specifier|protected
specifier|final
name|NamenodeRole
name|role
decl_stmt|;
DECL|field|state
specifier|private
specifier|volatile
name|HAState
name|state
decl_stmt|;
DECL|field|haEnabled
specifier|private
specifier|final
name|boolean
name|haEnabled
decl_stmt|;
DECL|field|haContext
specifier|private
specifier|final
name|HAContext
name|haContext
decl_stmt|;
DECL|field|allowStaleStandbyReads
specifier|protected
specifier|final
name|boolean
name|allowStaleStandbyReads
decl_stmt|;
DECL|field|started
specifier|private
name|AtomicBoolean
name|started
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/** httpServer */
DECL|field|httpServer
specifier|protected
name|NameNodeHttpServer
name|httpServer
decl_stmt|;
DECL|field|emptier
specifier|private
name|Thread
name|emptier
decl_stmt|;
comment|/** only used for testing purposes  */
DECL|field|stopRequested
specifier|protected
name|boolean
name|stopRequested
init|=
literal|false
decl_stmt|;
comment|/** Registration information of this name-node  */
DECL|field|nodeRegistration
specifier|protected
name|NamenodeRegistration
name|nodeRegistration
decl_stmt|;
comment|/** Activated plug-ins. */
DECL|field|plugins
specifier|private
name|List
argument_list|<
name|ServicePlugin
argument_list|>
name|plugins
decl_stmt|;
DECL|field|rpcServer
specifier|private
name|NameNodeRpcServer
name|rpcServer
decl_stmt|;
DECL|field|pauseMonitor
specifier|private
name|JvmPauseMonitor
name|pauseMonitor
decl_stmt|;
DECL|field|nameNodeStatusBeanName
specifier|private
name|ObjectName
name|nameNodeStatusBeanName
decl_stmt|;
DECL|field|tracer
specifier|protected
specifier|final
name|Tracer
name|tracer
decl_stmt|;
DECL|field|tracerConfigurationManager
specifier|protected
specifier|final
name|TracerConfigurationManager
name|tracerConfigurationManager
decl_stmt|;
DECL|field|metricsLoggerTimer
name|ScheduledThreadPoolExecutor
name|metricsLoggerTimer
decl_stmt|;
comment|/**    * The namenode address that clients will use to access this namenode    * or the name service. For HA configurations using logical URI, it    * will be the logical address.    */
DECL|field|clientNamenodeAddress
specifier|private
name|String
name|clientNamenodeAddress
decl_stmt|;
comment|/** Format a new filesystem.  Destroys any filesystem that may already    * exist at this location.  **/
DECL|method|format (Configuration conf)
specifier|public
specifier|static
name|void
name|format
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|format
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|field|metrics
specifier|static
name|NameNodeMetrics
name|metrics
decl_stmt|;
DECL|field|startupProgress
specifier|private
specifier|static
specifier|final
name|StartupProgress
name|startupProgress
init|=
operator|new
name|StartupProgress
argument_list|()
decl_stmt|;
comment|/** Return the {@link FSNamesystem} object.    * @return {@link FSNamesystem} object.    */
DECL|method|getNamesystem ()
specifier|public
name|FSNamesystem
name|getNamesystem
parameter_list|()
block|{
return|return
name|namesystem
return|;
block|}
DECL|method|getRpcServer ()
specifier|public
name|NamenodeProtocols
name|getRpcServer
parameter_list|()
block|{
return|return
name|rpcServer
return|;
block|}
DECL|method|queueExternalCall (ExternalCall<?> extCall)
specifier|public
name|void
name|queueExternalCall
parameter_list|(
name|ExternalCall
argument_list|<
name|?
argument_list|>
name|extCall
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|rpcServer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RetriableException
argument_list|(
literal|"Namenode is in startup mode"
argument_list|)
throw|;
block|}
name|rpcServer
operator|.
name|getClientRpcServer
argument_list|()
operator|.
name|queueCall
argument_list|(
name|extCall
argument_list|)
expr_stmt|;
block|}
DECL|method|initMetrics (Configuration conf, NamenodeRole role)
specifier|public
specifier|static
name|void
name|initMetrics
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NamenodeRole
name|role
parameter_list|)
block|{
name|metrics
operator|=
name|NameNodeMetrics
operator|.
name|create
argument_list|(
name|conf
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
DECL|method|getNameNodeMetrics ()
specifier|public
specifier|static
name|NameNodeMetrics
name|getNameNodeMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
comment|/**    * Returns object used for reporting namenode startup progress.    *     * @return StartupProgress for reporting namenode startup progress    */
DECL|method|getStartupProgress ()
specifier|public
specifier|static
name|StartupProgress
name|getStartupProgress
parameter_list|()
block|{
return|return
name|startupProgress
return|;
block|}
comment|/**    * Return the service name of the issued delegation token.    *    * @return The name service id in HA-mode, or the rpc address in non-HA mode    */
DECL|method|getTokenServiceName ()
specifier|public
name|String
name|getTokenServiceName
parameter_list|()
block|{
return|return
name|getClientNamenodeAddress
argument_list|()
return|;
block|}
comment|/**    * Set the namenode address that will be used by clients to access this    * namenode or name service. This needs to be called before the config    * is overriden.    */
DECL|method|setClientNamenodeAddress (Configuration conf)
specifier|public
name|void
name|setClientNamenodeAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|nnAddr
init|=
name|conf
operator|.
name|get
argument_list|(
name|FS_DEFAULT_NAME_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|nnAddr
operator|==
literal|null
condition|)
block|{
comment|// default fs is not set.
name|clientNamenodeAddress
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"{} is {}"
argument_list|,
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|nnAddr
argument_list|)
expr_stmt|;
name|URI
name|nnUri
init|=
name|URI
operator|.
name|create
argument_list|(
name|nnAddr
argument_list|)
decl_stmt|;
name|String
name|nnHost
init|=
name|nnUri
operator|.
name|getHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|nnHost
operator|==
literal|null
condition|)
block|{
name|clientNamenodeAddress
operator|=
literal|null
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DFSUtilClient
operator|.
name|getNameServiceIds
argument_list|(
name|conf
argument_list|)
operator|.
name|contains
argument_list|(
name|nnHost
argument_list|)
condition|)
block|{
comment|// host name is logical
name|clientNamenodeAddress
operator|=
name|nnHost
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nnUri
operator|.
name|getPort
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// physical address with a valid port
name|clientNamenodeAddress
operator|=
name|nnUri
operator|.
name|getAuthority
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// the port is missing or 0. Figure out real bind address later.
name|clientNamenodeAddress
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Clients are to use {} to access"
operator|+
literal|" this namenode/service."
argument_list|,
name|clientNamenodeAddress
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the namenode address to be used by clients.    * @return nn address    */
DECL|method|getClientNamenodeAddress ()
specifier|public
name|String
name|getClientNamenodeAddress
parameter_list|()
block|{
return|return
name|clientNamenodeAddress
return|;
block|}
comment|/**    * Set the configuration property for the service rpc address    * to address    */
DECL|method|setServiceAddress (Configuration conf, String address)
specifier|public
specifier|static
name|void
name|setServiceAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|address
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting ADDRESS {}"
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
comment|/**    * Fetches the address for services to use when connecting to namenode    * based on the value of fallback returns null if the special    * address is not specified or returns the default namenode address    * to be used by both clients and services.    * Services here are datanodes, backup node, any non client connection    */
DECL|method|getServiceAddress (Configuration conf, boolean fallback)
specifier|public
specifier|static
name|InetSocketAddress
name|getServiceAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|fallback
parameter_list|)
block|{
name|String
name|addr
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
operator|||
name|addr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|fallback
condition|?
name|DFSUtilClient
operator|.
name|getNNAddress
argument_list|(
name|conf
argument_list|)
else|:
literal|null
return|;
block|}
return|return
name|DFSUtilClient
operator|.
name|getNNAddress
argument_list|(
name|addr
argument_list|)
return|;
block|}
comment|//
comment|// Common NameNode methods implementation for the active name-node role.
comment|//
DECL|method|getRole ()
specifier|public
name|NamenodeRole
name|getRole
parameter_list|()
block|{
return|return
name|role
return|;
block|}
DECL|method|isRole (NamenodeRole that)
name|boolean
name|isRole
parameter_list|(
name|NamenodeRole
name|that
parameter_list|)
block|{
return|return
name|role
operator|.
name|equals
argument_list|(
name|that
argument_list|)
return|;
block|}
DECL|method|composeNotStartedMessage (NamenodeRole role)
specifier|public
specifier|static
name|String
name|composeNotStartedMessage
parameter_list|(
name|NamenodeRole
name|role
parameter_list|)
block|{
return|return
name|role
operator|+
literal|" still not started"
return|;
block|}
comment|/**    * Given a configuration get the address of the lifeline RPC server.    * If the lifeline RPC is not configured returns null.    *    * @param conf configuration    * @return address or null    */
DECL|method|getLifelineRpcServerAddress (Configuration conf)
name|InetSocketAddress
name|getLifelineRpcServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|addr
init|=
name|getTrimmedOrNull
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_LIFELINE_RPC_ADDRESS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|addr
argument_list|)
return|;
block|}
comment|/**    * Given a configuration get the address of the service rpc server    * If the service rpc is not configured returns null    */
DECL|method|getServiceRpcServerAddress (Configuration conf)
specifier|protected
name|InetSocketAddress
name|getServiceRpcServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NameNode
operator|.
name|getServiceAddress
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|getRpcServerAddress (Configuration conf)
specifier|protected
name|InetSocketAddress
name|getRpcServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|DFSUtilClient
operator|.
name|getNNAddress
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/**    * Given a configuration get the bind host of the lifeline RPC server.    * If the bind host is not configured returns null.    *    * @param conf configuration    * @return bind host or null    */
DECL|method|getLifelineRpcServerBindHost (Configuration conf)
name|String
name|getLifelineRpcServerBindHost
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getTrimmedOrNull
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_LIFELINE_RPC_BIND_HOST_KEY
argument_list|)
return|;
block|}
comment|/** Given a configuration get the bind host of the service rpc server    *  If the bind host is not configured returns null.    */
DECL|method|getServiceRpcServerBindHost (Configuration conf)
specifier|protected
name|String
name|getServiceRpcServerBindHost
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getTrimmedOrNull
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_SERVICE_RPC_BIND_HOST_KEY
argument_list|)
return|;
block|}
comment|/** Given a configuration get the bind host of the client rpc server    *  If the bind host is not configured returns null.    */
DECL|method|getRpcServerBindHost (Configuration conf)
specifier|protected
name|String
name|getRpcServerBindHost
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getTrimmedOrNull
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_RPC_BIND_HOST_KEY
argument_list|)
return|;
block|}
comment|/**    * Gets a trimmed value from configuration, or null if no value is defined.    *    * @param conf configuration    * @param key configuration key to get    * @return trimmed value, or null if no value is defined    */
DECL|method|getTrimmedOrNull (Configuration conf, String key)
specifier|private
specifier|static
name|String
name|getTrimmedOrNull
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|String
name|addr
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
operator|||
name|addr
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|addr
return|;
block|}
comment|/**    * Modifies the configuration to contain the lifeline RPC address setting.    *    * @param conf configuration to modify    * @param lifelineRPCAddress lifeline RPC address    */
DECL|method|setRpcLifelineServerAddress (Configuration conf, InetSocketAddress lifelineRPCAddress)
name|void
name|setRpcLifelineServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|InetSocketAddress
name|lifelineRPCAddress
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting lifeline RPC address {}"
argument_list|,
name|lifelineRPCAddress
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFS_NAMENODE_LIFELINE_RPC_ADDRESS_KEY
argument_list|,
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|lifelineRPCAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modifies the configuration passed to contain the service rpc address setting    */
DECL|method|setRpcServiceServerAddress (Configuration conf, InetSocketAddress serviceRPCAddress)
specifier|protected
name|void
name|setRpcServiceServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|InetSocketAddress
name|serviceRPCAddress
parameter_list|)
block|{
name|setServiceAddress
argument_list|(
name|conf
argument_list|,
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|serviceRPCAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|setRpcServerAddress (Configuration conf, InetSocketAddress rpcAddress)
specifier|protected
name|void
name|setRpcServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|InetSocketAddress
name|rpcAddress
parameter_list|)
block|{
name|FileSystem
operator|.
name|setDefaultUri
argument_list|(
name|conf
argument_list|,
name|DFSUtilClient
operator|.
name|getNNUri
argument_list|(
name|rpcAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getHttpServerAddress (Configuration conf)
specifier|protected
name|InetSocketAddress
name|getHttpServerAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getHttpAddress
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/**    * HTTP server address for binding the endpoint. This method is    * for use by the NameNode and its derivatives. It may return    * a different address than the one that should be used by clients to    * connect to the NameNode. See    * {@link DFSConfigKeys#DFS_NAMENODE_HTTP_BIND_HOST_KEY}    *    * @param conf    * @return    */
DECL|method|getHttpServerBindAddress (Configuration conf)
specifier|protected
name|InetSocketAddress
name|getHttpServerBindAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|InetSocketAddress
name|bindAddress
init|=
name|getHttpServerAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// If DFS_NAMENODE_HTTP_BIND_HOST_KEY exists then it overrides the
comment|// host name portion of DFS_NAMENODE_HTTP_ADDRESS_KEY.
specifier|final
name|String
name|bindHost
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|DFS_NAMENODE_HTTP_BIND_HOST_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|bindHost
operator|!=
literal|null
operator|&&
operator|!
name|bindHost
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bindAddress
operator|=
operator|new
name|InetSocketAddress
argument_list|(
name|bindHost
argument_list|,
name|bindAddress
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|bindAddress
return|;
block|}
comment|/** @return the NameNode HTTP address. */
DECL|method|getHttpAddress (Configuration conf)
specifier|public
specifier|static
name|InetSocketAddress
name|getHttpAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|getTrimmed
argument_list|(
name|DFS_NAMENODE_HTTP_ADDRESS_KEY
argument_list|,
name|DFS_NAMENODE_HTTP_ADDRESS_DEFAULT
argument_list|)
argument_list|)
return|;
block|}
DECL|method|loadNamesystem (Configuration conf)
specifier|protected
name|void
name|loadNamesystem
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|namesystem
operator|=
name|FSNamesystem
operator|.
name|loadFromDisk
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|getRegistration ()
name|NamenodeRegistration
name|getRegistration
parameter_list|()
block|{
return|return
name|nodeRegistration
return|;
block|}
DECL|method|setRegistration ()
name|NamenodeRegistration
name|setRegistration
parameter_list|()
block|{
name|nodeRegistration
operator|=
operator|new
name|NamenodeRegistration
argument_list|(
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|getNameNodeAddress
argument_list|()
argument_list|)
argument_list|,
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|getHttpAddress
argument_list|()
argument_list|)
argument_list|,
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
argument_list|,
name|getRole
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|nodeRegistration
return|;
block|}
comment|/* optimize ugi lookup for RPC operations to avoid a trip through    * UGI.getCurrentUser which is synch'ed    */
DECL|method|getRemoteUser ()
specifier|public
specifier|static
name|UserGroupInformation
name|getRemoteUser
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|ugi
init|=
name|Server
operator|.
name|getRemoteUser
argument_list|()
decl_stmt|;
return|return
operator|(
name|ugi
operator|!=
literal|null
operator|)
condition|?
name|ugi
else|:
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
return|;
block|}
comment|/**    * Login as the configured user for the NameNode.    */
DECL|method|loginAsNameNodeUser (Configuration conf)
name|void
name|loginAsNameNodeUser
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|InetSocketAddress
name|socAddr
init|=
name|getRpcServerAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_KEYTAB_FILE_KEY
argument_list|,
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
argument_list|,
name|socAddr
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initialize name-node.    *     * @param conf the configuration    */
DECL|method|initialize (Configuration conf)
specifier|protected
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS
argument_list|)
operator|==
literal|null
condition|)
block|{
name|String
name|intervals
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_METRICS_PERCENTILES_INTERVALS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|intervals
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS
argument_list|,
name|intervals
argument_list|)
expr_stmt|;
block|}
block|}
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|loginAsNameNodeUser
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|initMetrics
argument_list|(
name|conf
argument_list|,
name|this
operator|.
name|getRole
argument_list|()
argument_list|)
expr_stmt|;
name|StartupProgressMetrics
operator|.
name|register
argument_list|(
name|startupProgress
argument_list|)
expr_stmt|;
name|pauseMonitor
operator|=
operator|new
name|JvmPauseMonitor
argument_list|()
expr_stmt|;
name|pauseMonitor
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pauseMonitor
operator|.
name|start
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|getJvmMetrics
argument_list|()
operator|.
name|setPauseMonitor
argument_list|(
name|pauseMonitor
argument_list|)
expr_stmt|;
if|if
condition|(
name|NamenodeRole
operator|.
name|NAMENODE
operator|==
name|role
condition|)
block|{
name|startHttpServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|loadNamesystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|rpcServer
operator|=
name|createRpcServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initReconfigurableBackoffKey
argument_list|()
expr_stmt|;
if|if
condition|(
name|clientNamenodeAddress
operator|==
literal|null
condition|)
block|{
comment|// This is expected for MiniDFSCluster. Set it now using
comment|// the RPC server's bind address.
name|clientNamenodeAddress
operator|=
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|getNameNodeAddress
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Clients are to use "
operator|+
name|clientNamenodeAddress
operator|+
literal|" to access"
operator|+
literal|" this namenode/service."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NamenodeRole
operator|.
name|NAMENODE
operator|==
name|role
condition|)
block|{
name|httpServer
operator|.
name|setNameNodeAddress
argument_list|(
name|getNameNodeAddress
argument_list|()
argument_list|)
expr_stmt|;
name|httpServer
operator|.
name|setFSImage
argument_list|(
name|getFSImage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|startCommonServices
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|startMetricsLogger
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|initReconfigurableBackoffKey ()
specifier|private
name|void
name|initReconfigurableBackoffKey
parameter_list|()
block|{
name|ipcClientRPCBackoffEnable
operator|=
name|buildBackoffEnableKey
argument_list|(
name|rpcServer
operator|.
name|getClientRpcServer
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
name|reconfigurableProperties
operator|.
name|add
argument_list|(
name|ipcClientRPCBackoffEnable
argument_list|)
expr_stmt|;
block|}
DECL|method|buildBackoffEnableKey (final int port)
specifier|static
name|String
name|buildBackoffEnableKey
parameter_list|(
specifier|final
name|int
name|port
parameter_list|)
block|{
comment|// format used to construct backoff enable key, e.g. ipc.8020.backoff.enable
name|String
name|format
init|=
literal|"%s.%d.%s"
decl_stmt|;
return|return
name|String
operator|.
name|format
argument_list|(
name|format
argument_list|,
name|IPC_NAMESPACE
argument_list|,
name|port
argument_list|,
name|IPC_BACKOFF_ENABLE
argument_list|)
return|;
block|}
comment|/**    * Start a timer to periodically write NameNode metrics to the log    * file. This behavior can be disabled by configuration.    * @param conf    */
DECL|method|startMetricsLogger (Configuration conf)
specifier|protected
name|void
name|startMetricsLogger
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|long
name|metricsLoggerPeriodSec
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_NAMENODE_METRICS_LOGGER_PERIOD_SECONDS_KEY
argument_list|,
name|DFS_NAMENODE_METRICS_LOGGER_PERIOD_SECONDS_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|metricsLoggerPeriodSec
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
name|MetricsLoggerTask
operator|.
name|makeMetricsLoggerAsync
argument_list|(
name|MetricsLog
argument_list|)
expr_stmt|;
comment|// Schedule the periodic logging.
name|metricsLoggerTimer
operator|=
operator|new
name|ScheduledThreadPoolExecutor
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|metricsLoggerTimer
operator|.
name|setExecuteExistingDelayedTasksAfterShutdownPolicy
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|metricsLoggerTimer
operator|.
name|scheduleWithFixedDelay
argument_list|(
operator|new
name|MetricsLoggerTask
argument_list|(
name|MetricsLog
argument_list|,
literal|"NameNode"
argument_list|,
operator|(
name|short
operator|)
literal|128
argument_list|)
argument_list|,
name|metricsLoggerPeriodSec
argument_list|,
name|metricsLoggerPeriodSec
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
DECL|method|stopMetricsLogger ()
specifier|protected
name|void
name|stopMetricsLogger
parameter_list|()
block|{
if|if
condition|(
name|metricsLoggerTimer
operator|!=
literal|null
condition|)
block|{
name|metricsLoggerTimer
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|metricsLoggerTimer
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Create the RPC server implementation. Used as an extension point for the    * BackupNode.    */
DECL|method|createRpcServer (Configuration conf)
specifier|protected
name|NameNodeRpcServer
name|createRpcServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|NameNodeRpcServer
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/** Start the services common to active and standby states */
DECL|method|startCommonServices (Configuration conf)
specifier|private
name|void
name|startCommonServices
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|startCommonServices
argument_list|(
name|conf
argument_list|,
name|haContext
argument_list|)
expr_stmt|;
name|registerNNSMXBean
argument_list|()
expr_stmt|;
if|if
condition|(
name|NamenodeRole
operator|.
name|NAMENODE
operator|!=
name|role
condition|)
block|{
name|startHttpServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|httpServer
operator|.
name|setNameNodeAddress
argument_list|(
name|getNameNodeAddress
argument_list|()
argument_list|)
expr_stmt|;
name|httpServer
operator|.
name|setFSImage
argument_list|(
name|getFSImage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rpcServer
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|plugins
operator|=
name|conf
operator|.
name|getInstances
argument_list|(
name|DFS_NAMENODE_PLUGINS_KEY
argument_list|,
name|ServicePlugin
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|String
name|pluginsValue
init|=
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_PLUGINS_KEY
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to load NameNode plugins. Specified list of plugins: "
operator|+
name|pluginsValue
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|start
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" could not be started"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getRole
argument_list|()
operator|+
literal|" RPC up at: "
operator|+
name|getNameNodeAddress
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpcServer
operator|.
name|getServiceRpcAddress
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getRole
argument_list|()
operator|+
literal|" service RPC up at: "
operator|+
name|rpcServer
operator|.
name|getServiceRpcAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|stopCommonServices ()
specifier|private
name|void
name|stopCommonServices
parameter_list|()
block|{
if|if
condition|(
name|rpcServer
operator|!=
literal|null
condition|)
name|rpcServer
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|namesystem
operator|!=
literal|null
condition|)
name|namesystem
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|pauseMonitor
operator|!=
literal|null
condition|)
name|pauseMonitor
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|plugins
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" could not be stopped"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|stopHttpServer
argument_list|()
expr_stmt|;
block|}
DECL|method|startTrashEmptier (final Configuration conf)
specifier|private
name|void
name|startTrashEmptier
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|trashInterval
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|FS_TRASH_INTERVAL_KEY
argument_list|,
name|FS_TRASH_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|trashInterval
operator|==
literal|0
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|trashInterval
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot start trash emptier with negative interval."
operator|+
literal|" Set "
operator|+
name|FS_TRASH_INTERVAL_KEY
operator|+
literal|" to a positive value."
argument_list|)
throw|;
block|}
comment|// This may be called from the transitionToActive code path, in which
comment|// case the current user is the administrator, not the NN. The trash
comment|// emptier needs to run as the NN. See HDFS-3972.
name|FileSystem
name|fs
init|=
name|SecurityUtil
operator|.
name|doAsLoginUser
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|this
operator|.
name|emptier
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Trash
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|)
operator|.
name|getEmptier
argument_list|()
argument_list|,
literal|"Trash Emptier"
argument_list|)
expr_stmt|;
name|this
operator|.
name|emptier
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|emptier
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|stopTrashEmptier ()
specifier|private
name|void
name|stopTrashEmptier
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|emptier
operator|!=
literal|null
condition|)
block|{
name|emptier
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|emptier
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|startHttpServer (final Configuration conf)
specifier|private
name|void
name|startHttpServer
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|httpServer
operator|=
operator|new
name|NameNodeHttpServer
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|getHttpServerBindAddress
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|httpServer
operator|.
name|start
argument_list|()
expr_stmt|;
name|httpServer
operator|.
name|setStartupProgress
argument_list|(
name|startupProgress
argument_list|)
expr_stmt|;
block|}
DECL|method|stopHttpServer ()
specifier|private
name|void
name|stopHttpServer
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|httpServer
operator|!=
literal|null
condition|)
name|httpServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while stopping httpserver"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Start NameNode.    *<p>    * The name-node can be started with one of the following startup options:    *<ul>     *<li>{@link StartupOption#REGULAR REGULAR} - normal name node startup</li>    *<li>{@link StartupOption#FORMAT FORMAT} - format name node</li>    *<li>{@link StartupOption#BACKUP BACKUP} - start backup node</li>    *<li>{@link StartupOption#CHECKPOINT CHECKPOINT} - start checkpoint node</li>    *<li>{@link StartupOption#UPGRADE UPGRADE} - start the cluster      *<li>{@link StartupOption#UPGRADEONLY UPGRADEONLY} - upgrade the cluster      * upgrade and create a snapshot of the current file system state</li>     *<li>{@link StartupOption#RECOVER RECOVERY} - recover name node    * metadata</li>    *<li>{@link StartupOption#ROLLBACK ROLLBACK} - roll the      *            cluster back to the previous state</li>    *<li>{@link StartupOption#IMPORT IMPORT} - import checkpoint</li>    *</ul>    * The option is passed via configuration field:     *<tt>dfs.namenode.startup</tt>    *     * The conf will be modified to reflect the actual ports on which     * the NameNode is up and running if the user passes the port as    *<code>zero</code> in the conf.    *     * @param conf  confirguration    * @throws IOException    */
DECL|method|NameNode (Configuration conf)
specifier|public
name|NameNode
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|NamenodeRole
operator|.
name|NAMENODE
argument_list|)
expr_stmt|;
block|}
DECL|method|NameNode (Configuration conf, NamenodeRole role)
specifier|protected
name|NameNode
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|NamenodeRole
name|role
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|tracer
operator|=
operator|new
name|Tracer
operator|.
name|Builder
argument_list|(
literal|"NameNode"
argument_list|)
operator|.
name|conf
argument_list|(
name|TraceUtils
operator|.
name|wrapHadoopConf
argument_list|(
name|NAMENODE_HTRACE_PREFIX
argument_list|,
name|conf
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|this
operator|.
name|tracerConfigurationManager
operator|=
operator|new
name|TracerConfigurationManager
argument_list|(
name|NAMENODE_HTRACE_PREFIX
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|role
operator|=
name|role
expr_stmt|;
name|setClientNamenodeAddress
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|String
name|nsId
init|=
name|getNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|this
operator|.
name|haEnabled
operator|=
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
expr_stmt|;
name|state
operator|=
name|createHAState
argument_list|(
name|getStartupOption
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|allowStaleStandbyReads
operator|=
name|HAUtil
operator|.
name|shouldAllowStandbyReads
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|haContext
operator|=
name|createHAContext
argument_list|()
expr_stmt|;
try|try
block|{
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
name|initialize
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|haContext
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|state
operator|.
name|prepareToEnterState
argument_list|(
name|haContext
argument_list|)
expr_stmt|;
name|state
operator|.
name|enterState
argument_list|(
name|haContext
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|haContext
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|stopAtException
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|HadoopIllegalArgumentException
name|e
parameter_list|)
block|{
name|this
operator|.
name|stopAtException
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|this
operator|.
name|started
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|stopAtException (Exception e)
specifier|private
name|void
name|stopAtException
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception when handling exception ("
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|"):"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createHAState (StartupOption startOpt)
specifier|protected
name|HAState
name|createHAState
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|haEnabled
operator|||
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADE
operator|||
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADEONLY
condition|)
block|{
return|return
name|ACTIVE_STATE
return|;
block|}
else|else
block|{
return|return
name|STANDBY_STATE
return|;
block|}
block|}
DECL|method|createHAContext ()
specifier|protected
name|HAContext
name|createHAContext
parameter_list|()
block|{
return|return
operator|new
name|NameNodeHAContext
argument_list|()
return|;
block|}
comment|/**    * Wait for service to finish.    * (Normally, it runs forever.)    */
DECL|method|join ()
specifier|public
name|void
name|join
parameter_list|()
block|{
try|try
block|{
name|rpcServer
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Caught interrupted exception "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Stop all NameNode threads and wait for all to finish.    */
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|stopRequested
condition|)
return|return;
name|stopRequested
operator|=
literal|true
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|exitState
argument_list|(
name|haContext
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ServiceFailedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception while exiting state "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|stopMetricsLogger
argument_list|()
expr_stmt|;
name|stopCommonServices
argument_list|()
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|namesystem
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nameNodeStatusBeanName
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|nameNodeStatusBeanName
argument_list|)
expr_stmt|;
name|nameNodeStatusBeanName
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|tracer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|isStopRequested ()
specifier|synchronized
name|boolean
name|isStopRequested
parameter_list|()
block|{
return|return
name|stopRequested
return|;
block|}
comment|/**    * Is the cluster currently in safe mode?    */
DECL|method|isInSafeMode ()
specifier|public
name|boolean
name|isInSafeMode
parameter_list|()
block|{
return|return
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
return|;
block|}
comment|/** get FSImage */
annotation|@
name|VisibleForTesting
DECL|method|getFSImage ()
specifier|public
name|FSImage
name|getFSImage
parameter_list|()
block|{
return|return
name|namesystem
operator|.
name|getFSImage
argument_list|()
return|;
block|}
comment|/**    * @return NameNode RPC address    */
DECL|method|getNameNodeAddress ()
specifier|public
name|InetSocketAddress
name|getNameNodeAddress
parameter_list|()
block|{
return|return
name|rpcServer
operator|.
name|getRpcAddress
argument_list|()
return|;
block|}
comment|/**    * @return NameNode RPC address in "host:port" string form    */
DECL|method|getNameNodeAddressHostPortString ()
specifier|public
name|String
name|getNameNodeAddressHostPortString
parameter_list|()
block|{
return|return
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|getNameNodeAddress
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return NameNode service RPC address if configured, the    *    NameNode RPC address otherwise    */
DECL|method|getServiceRpcAddress ()
specifier|public
name|InetSocketAddress
name|getServiceRpcAddress
parameter_list|()
block|{
specifier|final
name|InetSocketAddress
name|serviceAddr
init|=
name|rpcServer
operator|.
name|getServiceRpcAddress
argument_list|()
decl_stmt|;
return|return
name|serviceAddr
operator|==
literal|null
condition|?
name|getNameNodeAddress
argument_list|()
else|:
name|serviceAddr
return|;
block|}
comment|/**    * @return NameNode HTTP address, used by the Web UI, image transfer,    *    and HTTP-based file system clients like WebHDFS    */
DECL|method|getHttpAddress ()
specifier|public
name|InetSocketAddress
name|getHttpAddress
parameter_list|()
block|{
return|return
name|httpServer
operator|.
name|getHttpAddress
argument_list|()
return|;
block|}
comment|/**    * @return NameNode HTTPS address, used by the Web UI, image transfer,    *    and HTTP-based file system clients like WebHDFS    */
DECL|method|getHttpsAddress ()
specifier|public
name|InetSocketAddress
name|getHttpsAddress
parameter_list|()
block|{
return|return
name|httpServer
operator|.
name|getHttpsAddress
argument_list|()
return|;
block|}
comment|/**    * @return NameNodeHttpServer, used by unit tests to ensure a full shutdown,    * so that no bind exception is thrown during restart.    */
annotation|@
name|VisibleForTesting
DECL|method|joinHttpServer ()
specifier|public
name|void
name|joinHttpServer
parameter_list|()
block|{
if|if
condition|(
name|httpServer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|httpServer
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Caught InterruptedException joining NameNodeHttpServer"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Verify that configured directories exist, then    * Interactively confirm that formatting is desired     * for each existing directory and format them.    *     * @param conf configuration to use    * @param force if true, format regardless of whether dirs exist    * @return true if formatting was aborted, false otherwise    * @throws IOException    */
DECL|method|format (Configuration conf, boolean force, boolean isInteractive)
specifier|private
specifier|static
name|boolean
name|format
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|force
parameter_list|,
name|boolean
name|isInteractive
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
name|checkAllowFormat
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|InetSocketAddress
name|socAddr
init|=
name|DFSUtilClient
operator|.
name|getNNAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_KEYTAB_FILE_KEY
argument_list|,
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
argument_list|,
name|socAddr
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|URI
argument_list|>
name|nameDirsToFormat
init|=
name|FSNamesystem
operator|.
name|getNamespaceDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|sharedDirs
init|=
name|FSNamesystem
operator|.
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|dirsToPrompt
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
name|dirsToPrompt
operator|.
name|addAll
argument_list|(
name|nameDirsToFormat
argument_list|)
expr_stmt|;
name|dirsToPrompt
operator|.
name|addAll
argument_list|(
name|sharedDirs
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|editDirsToFormat
init|=
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// if clusterID is not provided - see if you can find the current one
name|String
name|clusterId
init|=
name|StartupOption
operator|.
name|FORMAT
operator|.
name|getClusterId
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterId
operator|==
literal|null
operator|||
name|clusterId
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|//Generate a new cluster id
name|clusterId
operator|=
name|NNStorage
operator|.
name|newClusterID
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Formatting using clusterid: "
operator|+
name|clusterId
argument_list|)
expr_stmt|;
name|FSImage
name|fsImage
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|nameDirsToFormat
argument_list|,
name|editDirsToFormat
argument_list|)
decl_stmt|;
try|try
block|{
name|FSNamesystem
name|fsn
init|=
operator|new
name|FSNamesystem
argument_list|(
name|conf
argument_list|,
name|fsImage
argument_list|)
decl_stmt|;
name|fsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fsImage
operator|.
name|confirmFormat
argument_list|(
name|force
argument_list|,
name|isInteractive
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// aborted
block|}
name|fsImage
operator|.
name|format
argument_list|(
name|fsn
argument_list|,
name|clusterId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered exception during format: "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|fsImage
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|checkAllowFormat (Configuration conf)
specifier|public
specifier|static
name|void
name|checkAllowFormat
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY
argument_list|,
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_DEFAULT
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The option "
operator|+
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY
operator|+
literal|" is set to false for this filesystem, so it "
operator|+
literal|"cannot be formatted. You will need to set "
operator|+
name|DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY
operator|+
literal|" parameter "
operator|+
literal|"to true in order to format this filesystem"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|initializeSharedEdits (Configuration conf)
specifier|public
specifier|static
name|boolean
name|initializeSharedEdits
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|initializeSharedEdits
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|initializeSharedEdits (Configuration conf, boolean force)
specifier|public
specifier|static
name|boolean
name|initializeSharedEdits
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|initializeSharedEdits
argument_list|(
name|conf
argument_list|,
name|force
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Clone the supplied configuration but remove the shared edits dirs.    *    * @param conf Supplies the original configuration.    * @return Cloned configuration without the shared edit dirs.    * @throws IOException on failure to generate the configuration.    */
DECL|method|getConfigurationWithoutSharedEdits ( Configuration conf)
specifier|private
specifier|static
name|Configuration
name|getConfigurationWithoutSharedEdits
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
name|FSNamesystem
operator|.
name|getNamespaceEditsDirs
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|String
name|editsDirsString
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|join
argument_list|(
name|editsDirs
argument_list|)
decl_stmt|;
name|Configuration
name|confWithoutShared
init|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|confWithoutShared
operator|.
name|unset
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
argument_list|)
expr_stmt|;
name|confWithoutShared
operator|.
name|setStrings
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_EDITS_DIR_KEY
argument_list|,
name|editsDirsString
argument_list|)
expr_stmt|;
return|return
name|confWithoutShared
return|;
block|}
comment|/**    * Format a new shared edits dir and copy in enough edit log segments so that    * the standby NN can start up.    *     * @param conf configuration    * @param force format regardless of whether or not the shared edits dir exists    * @param interactive prompt the user when a dir exists    * @return true if the command aborts, false otherwise    */
DECL|method|initializeSharedEdits (Configuration conf, boolean force, boolean interactive)
specifier|private
specifier|static
name|boolean
name|initializeSharedEdits
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|force
parameter_list|,
name|boolean
name|interactive
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_SHARED_EDITS_DIR_KEY
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No shared edits directory configured for namespace "
operator|+
name|nsId
operator|+
literal|" namenode "
operator|+
name|namenodeId
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|InetSocketAddress
name|socAddr
init|=
name|DFSUtilClient
operator|.
name|getNNAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_KEYTAB_FILE_KEY
argument_list|,
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
argument_list|,
name|socAddr
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|NNStorage
name|existingStorage
init|=
literal|null
decl_stmt|;
name|FSImage
name|sharedEditsImage
init|=
literal|null
decl_stmt|;
try|try
block|{
name|FSNamesystem
name|fsns
init|=
name|FSNamesystem
operator|.
name|loadFromDisk
argument_list|(
name|getConfigurationWithoutSharedEdits
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|existingStorage
operator|=
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
expr_stmt|;
name|NamespaceInfo
name|nsInfo
init|=
name|existingStorage
operator|.
name|getNamespaceInfo
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|URI
argument_list|>
name|sharedEditsDirs
init|=
name|FSNamesystem
operator|.
name|getSharedEditsDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|sharedEditsImage
operator|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|,
name|Lists
operator|.
expr|<
name|URI
operator|>
name|newArrayList
argument_list|()
argument_list|,
name|sharedEditsDirs
argument_list|)
expr_stmt|;
name|sharedEditsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sharedEditsImage
operator|.
name|confirmFormat
argument_list|(
name|force
argument_list|,
name|interactive
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|// abort
block|}
name|NNStorage
name|newSharedStorage
init|=
name|sharedEditsImage
operator|.
name|getStorage
argument_list|()
decl_stmt|;
comment|// Call Storage.format instead of FSImage.format here, since we don't
comment|// actually want to save a checkpoint - just prime the dirs with
comment|// the existing namespace info
name|newSharedStorage
operator|.
name|format
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
name|sharedEditsImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|formatNonFileJournals
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
comment|// Need to make sure the edit log segments are in good shape to initialize
comment|// the shared edits dir.
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getEditLog
argument_list|()
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
name|copyEditLogSegmentsToSharedDir
argument_list|(
name|fsns
argument_list|,
name|sharedEditsDirs
argument_list|,
name|newSharedStorage
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not initialize shared edits dir"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// aborted
block|}
finally|finally
block|{
if|if
condition|(
name|sharedEditsImage
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|sharedEditsImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not close sharedEditsImage"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Have to unlock storage explicitly for the case when we're running in a
comment|// unit test, which runs in the same JVM as NNs.
if|if
condition|(
name|existingStorage
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|existingStorage
operator|.
name|unlockAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not unlock storage directories"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// aborted
block|}
block|}
block|}
return|return
literal|false
return|;
comment|// did not abort
block|}
DECL|method|copyEditLogSegmentsToSharedDir (FSNamesystem fsns, Collection<URI> sharedEditsDirs, NNStorage newSharedStorage, Configuration conf)
specifier|private
specifier|static
name|void
name|copyEditLogSegmentsToSharedDir
parameter_list|(
name|FSNamesystem
name|fsns
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|sharedEditsDirs
parameter_list|,
name|NNStorage
name|newSharedStorage
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|sharedEditsDirs
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"No shared edits specified"
argument_list|)
expr_stmt|;
comment|// Copy edit log segments into the new shared edits dir.
name|List
argument_list|<
name|URI
argument_list|>
name|sharedEditsUris
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|(
name|sharedEditsDirs
argument_list|)
decl_stmt|;
name|FSEditLog
name|newSharedEditLog
init|=
operator|new
name|FSEditLog
argument_list|(
name|conf
argument_list|,
name|newSharedStorage
argument_list|,
name|sharedEditsUris
argument_list|)
decl_stmt|;
name|newSharedEditLog
operator|.
name|initJournalsForWrite
argument_list|()
expr_stmt|;
name|newSharedEditLog
operator|.
name|recoverUnclosedStreams
argument_list|()
expr_stmt|;
name|FSEditLog
name|sourceEditLog
init|=
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|editLog
decl_stmt|;
name|long
name|fromTxId
init|=
name|fsns
operator|.
name|getFSImage
argument_list|()
operator|.
name|getMostRecentCheckpointTxId
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
init|=
literal|null
decl_stmt|;
try|try
block|{
name|streams
operator|=
name|sourceEditLog
operator|.
name|selectInputStreams
argument_list|(
name|fromTxId
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Set the nextTxid to the CheckpointTxId+1
name|newSharedEditLog
operator|.
name|setNextTxId
argument_list|(
name|fromTxId
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Copy all edits after last CheckpointTxId to shared edits dir
for|for
control|(
name|EditLogInputStream
name|stream
range|:
name|streams
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Beginning to copy stream "
operator|+
name|stream
operator|+
literal|" to shared edits"
argument_list|)
expr_stmt|;
name|FSEditLogOp
name|op
decl_stmt|;
name|boolean
name|segmentOpen
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|(
name|op
operator|=
name|stream
operator|.
name|readOp
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"copying op: "
operator|+
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|segmentOpen
condition|)
block|{
name|newSharedEditLog
operator|.
name|startLogSegment
argument_list|(
name|op
operator|.
name|txid
argument_list|,
literal|false
argument_list|,
name|fsns
operator|.
name|getEffectiveLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
name|segmentOpen
operator|=
literal|true
expr_stmt|;
block|}
name|newSharedEditLog
operator|.
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|opCode
operator|==
name|FSEditLogOpCodes
operator|.
name|OP_END_LOG_SEGMENT
condition|)
block|{
name|newSharedEditLog
operator|.
name|endCurrentLogSegment
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ending log segment because of END_LOG_SEGMENT op in "
operator|+
name|stream
argument_list|)
expr_stmt|;
name|segmentOpen
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|segmentOpen
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ending log segment because of end of stream in "
operator|+
name|stream
argument_list|)
expr_stmt|;
name|newSharedEditLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|newSharedEditLog
operator|.
name|endCurrentLogSegment
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|segmentOpen
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|streams
operator|!=
literal|null
condition|)
block|{
name|FSEditLog
operator|.
name|closeAllStreams
argument_list|(
name|streams
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|doRollback (Configuration conf, boolean isConfirmationNeeded)
specifier|public
specifier|static
name|boolean
name|doRollback
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|isConfirmationNeeded
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
name|FSNamesystem
name|nsys
init|=
operator|new
name|FSNamesystem
argument_list|(
name|conf
argument_list|,
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|System
operator|.
name|err
operator|.
name|print
argument_list|(
literal|"\"rollBack\" will remove the current state of the file system,\n"
operator|+
literal|"returning you to the state prior to initiating your recent.\n"
operator|+
literal|"upgrade. This action is permanent and cannot be undone. If you\n"
operator|+
literal|"are performing a rollback in an HA environment, you should be\n"
operator|+
literal|"certain that no NameNode process is running on any host."
argument_list|)
expr_stmt|;
if|if
condition|(
name|isConfirmationNeeded
condition|)
block|{
if|if
condition|(
operator|!
name|confirmPrompt
argument_list|(
literal|"Roll back file system state?"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Rollback aborted."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|nsys
operator|.
name|getFSImage
argument_list|()
operator|.
name|doRollback
argument_list|(
name|nsys
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|printUsage (PrintStream out)
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|(
name|PrintStream
name|out
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|USAGE
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|parseArguments (String args[])
specifier|static
name|StartupOption
name|parseArguments
parameter_list|(
name|String
name|args
index|[]
parameter_list|)
block|{
name|int
name|argsLen
init|=
operator|(
name|args
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|args
operator|.
name|length
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|StartupOption
operator|.
name|REGULAR
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argsLen
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cmd
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|StartupOption
operator|.
name|FORMAT
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|FORMAT
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i
operator|+
literal|1
init|;
name|i
operator|<
name|argsLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argsLen
condition|)
block|{
comment|// if no cluster id specified, return null
name|LOG
operator|.
name|error
argument_list|(
literal|"Must specify a valid cluster ID after the "
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" flag"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|String
name|clusterId
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
comment|// Make sure an id is specified and not another flag
if|if
condition|(
name|clusterId
operator|.
name|isEmpty
argument_list|()
operator|||
name|clusterId
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
argument_list|)
operator|||
name|clusterId
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|NONINTERACTIVE
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Must specify a valid cluster ID after the "
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" flag"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|startOpt
operator|.
name|setClusterId
argument_list|(
name|clusterId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setForceFormat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|NONINTERACTIVE
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setInteractiveFormat
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|GENCLUSTERID
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|GENCLUSTERID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|REGULAR
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|REGULAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|BACKUP
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|BACKUP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|CHECKPOINT
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|CHECKPOINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|UPGRADE
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
operator|||
name|StartupOption
operator|.
name|UPGRADEONLY
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|UPGRADE
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|?
name|StartupOption
operator|.
name|UPGRADE
else|:
name|StartupOption
operator|.
name|UPGRADEONLY
expr_stmt|;
comment|/* Can be followed by CLUSTERID with a required parameter or          * RENAMERESERVED with an optional parameter          */
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|argsLen
condition|)
block|{
name|String
name|flag
init|=
name|args
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|flag
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|argsLen
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
name|startOpt
operator|.
name|setClusterId
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Must specify a valid cluster ID after the "
operator|+
name|StartupOption
operator|.
name|CLUSTERID
operator|.
name|getName
argument_list|()
operator|+
literal|" flag"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|flag
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|RENAMERESERVED
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|argsLen
condition|)
block|{
name|FSImageFormat
operator|.
name|setRenameReservedPairs
argument_list|(
name|args
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|FSImageFormat
operator|.
name|useDefaultRenameReservedPairs
argument_list|()
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unknown upgrade flag "
operator|+
name|flag
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|ROLLINGUPGRADE
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|ROLLINGUPGRADE
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argsLen
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Must specify a rolling upgrade startup option "
operator|+
name|RollingUpgradeStartupOption
operator|.
name|getAllOptionString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|startOpt
operator|.
name|setRollingUpgradeStartupOption
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|ROLLBACK
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|ROLLBACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|IMPORT
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|IMPORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|BOOTSTRAPSTANDBY
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|BOOTSTRAPSTANDBY
expr_stmt|;
return|return
name|startOpt
return|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|INITIALIZESHAREDEDITS
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|INITIALIZESHAREDEDITS
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i
operator|+
literal|1
init|;
name|i
operator|<
name|argsLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|StartupOption
operator|.
name|NONINTERACTIVE
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setInteractiveFormat
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setForceFormat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid argument: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|return
name|startOpt
return|;
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|RECOVER
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
if|if
condition|(
name|startOpt
operator|!=
name|StartupOption
operator|.
name|REGULAR
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can't combine -recover with "
operator|+
literal|"other startup options."
argument_list|)
throw|;
block|}
name|startOpt
operator|=
name|StartupOption
operator|.
name|RECOVER
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|argsLen
condition|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|StartupOption
operator|.
name|FORCE
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|startOpt
operator|.
name|setForce
argument_list|(
name|MetaRecoveryContext
operator|.
name|FORCE_FIRST_CHOICE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error parsing recovery options: "
operator|+
literal|"can't understand option \""
operator|+
name|args
index|[
name|i
index|]
operator|+
literal|"\""
argument_list|)
throw|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|StartupOption
operator|.
name|METADATAVERSION
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|METADATAVERSION
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|startOpt
return|;
block|}
DECL|method|setStartupOption (Configuration conf, StartupOption opt)
specifier|private
specifier|static
name|void
name|setStartupOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|StartupOption
name|opt
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|DFS_NAMENODE_STARTUP_KEY
argument_list|,
name|opt
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getStartupOption (Configuration conf)
specifier|public
specifier|static
name|StartupOption
name|getStartupOption
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|StartupOption
operator|.
name|valueOf
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_STARTUP_KEY
argument_list|,
name|StartupOption
operator|.
name|REGULAR
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|doRecovery (StartupOption startOpt, Configuration conf)
specifier|private
specifier|static
name|void
name|doRecovery
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|startOpt
operator|.
name|getForce
argument_list|()
operator|<
name|MetaRecoveryContext
operator|.
name|FORCE_ALL
condition|)
block|{
if|if
condition|(
operator|!
name|confirmPrompt
argument_list|(
literal|"You have selected Metadata Recovery mode.  "
operator|+
literal|"This mode is intended to recover lost metadata on a corrupt "
operator|+
literal|"filesystem.  Metadata recovery mode often permanently deletes "
operator|+
literal|"data from your HDFS filesystem.  Please back up your edit log "
operator|+
literal|"and fsimage before trying this!\n\n"
operator|+
literal|"Are you ready to proceed? (Y/N)\n"
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Recovery aborted at user request.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|MetaRecoveryContext
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"starting recovery..."
argument_list|)
expr_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|initMetrics
argument_list|(
name|conf
argument_list|,
name|startOpt
operator|.
name|toNodeRole
argument_list|()
argument_list|)
expr_stmt|;
name|FSNamesystem
name|fsn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fsn
operator|=
name|FSNamesystem
operator|.
name|loadFromDisk
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|fsn
operator|.
name|getFSImage
argument_list|()
operator|.
name|saveNamespace
argument_list|(
name|fsn
argument_list|)
expr_stmt|;
name|MetaRecoveryContext
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"RECOVERY COMPLETE"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|MetaRecoveryContext
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"RECOVERY FAILED: caught exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|MetaRecoveryContext
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"RECOVERY FAILED: caught exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|fsn
operator|!=
literal|null
condition|)
name|fsn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Verify that configured directories exist, then print the metadata versions    * of the software and the image.    *    * @param conf configuration to use    * @throws IOException    */
DECL|method|printMetadataVersion (Configuration conf)
specifier|private
specifier|static
name|boolean
name|printMetadataVersion
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|nsId
init|=
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|String
name|namenodeId
init|=
name|HAUtil
operator|.
name|getNameNodeId
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|)
decl_stmt|;
name|NameNode
operator|.
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|,
name|nsId
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
specifier|final
name|FSImage
name|fsImage
init|=
operator|new
name|FSImage
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|FSNamesystem
name|fs
init|=
operator|new
name|FSNamesystem
argument_list|(
name|conf
argument_list|,
name|fsImage
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|fsImage
operator|.
name|recoverTransitionRead
argument_list|(
name|StartupOption
operator|.
name|METADATAVERSION
argument_list|,
name|fs
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|createNameNode (String argv[], Configuration conf)
specifier|public
specifier|static
name|NameNode
name|createNameNode
parameter_list|(
name|String
name|argv
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"createNameNode "
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|argv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
name|conf
operator|=
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
comment|// Parse out some generic args into Configuration.
name|GenericOptionsParser
name|hParser
init|=
operator|new
name|GenericOptionsParser
argument_list|(
name|conf
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|argv
operator|=
name|hParser
operator|.
name|getRemainingArgs
argument_list|()
expr_stmt|;
comment|// Parse the rest, NN specific args.
name|StartupOption
name|startOpt
init|=
name|parseArguments
argument_list|(
name|argv
argument_list|)
decl_stmt|;
if|if
condition|(
name|startOpt
operator|==
literal|null
condition|)
block|{
name|printUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|setStartupOption
argument_list|(
name|conf
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
name|boolean
name|aborted
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|startOpt
condition|)
block|{
case|case
name|FORMAT
case|:
name|aborted
operator|=
name|format
argument_list|(
name|conf
argument_list|,
name|startOpt
operator|.
name|getForceFormat
argument_list|()
argument_list|,
name|startOpt
operator|.
name|getInteractiveFormat
argument_list|()
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
name|aborted
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid javac warning
case|case
name|GENCLUSTERID
case|:
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Generating new cluster id:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|NNStorage
operator|.
name|newClusterID
argument_list|()
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
case|case
name|ROLLBACK
case|:
name|aborted
operator|=
name|doRollback
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
name|aborted
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid warning
case|case
name|BOOTSTRAPSTANDBY
case|:
name|String
index|[]
name|toolArgs
init|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|argv
argument_list|,
literal|1
argument_list|,
name|argv
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|rc
init|=
name|BootstrapStandby
operator|.
name|run
argument_list|(
name|toolArgs
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|terminate
argument_list|(
name|rc
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid warning
case|case
name|INITIALIZESHAREDEDITS
case|:
name|aborted
operator|=
name|initializeSharedEdits
argument_list|(
name|conf
argument_list|,
name|startOpt
operator|.
name|getForceFormat
argument_list|()
argument_list|,
name|startOpt
operator|.
name|getInteractiveFormat
argument_list|()
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
name|aborted
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid warning
case|case
name|BACKUP
case|:
case|case
name|CHECKPOINT
case|:
name|NamenodeRole
name|role
init|=
name|startOpt
operator|.
name|toNodeRole
argument_list|()
decl_stmt|;
name|DefaultMetricsSystem
operator|.
name|initialize
argument_list|(
name|role
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|BackupNode
argument_list|(
name|conf
argument_list|,
name|role
argument_list|)
return|;
case|case
name|RECOVER
case|:
name|NameNode
operator|.
name|doRecovery
argument_list|(
name|startOpt
argument_list|,
name|conf
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
case|case
name|METADATAVERSION
case|:
name|printMetadataVersion
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// avoid javac warning
case|case
name|UPGRADEONLY
case|:
name|DefaultMetricsSystem
operator|.
name|initialize
argument_list|(
literal|"NameNode"
argument_list|)
expr_stmt|;
operator|new
name|NameNode
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
default|default:
name|DefaultMetricsSystem
operator|.
name|initialize
argument_list|(
literal|"NameNode"
argument_list|)
expr_stmt|;
return|return
operator|new
name|NameNode
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
comment|/**    * In federation configuration is set for a set of    * namenode and secondary namenode/backup/checkpointer, which are    * grouped under a logical nameservice ID. The configuration keys specific     * to them have suffix set to configured nameserviceId.    *     * This method copies the value from specific key of format key.nameserviceId    * to key, to set up the generic configuration. Once this is done, only    * generic version of the configuration is read in rest of the code, for    * backward compatibility and simpler code changes.    *     * @param conf    *          Configuration object to lookup specific key and to set the value    *          to the key passed. Note the conf object is modified    * @param nameserviceId name service Id (to distinguish federated NNs)    * @param namenodeId the namenode ID (to distinguish HA NNs)    * @see DFSUtil#setGenericConf(Configuration, String, String, String...)    */
DECL|method|initializeGenericKeys (Configuration conf, String nameserviceId, String namenodeId)
specifier|public
specifier|static
name|void
name|initializeGenericKeys
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|nameserviceId
parameter_list|,
name|String
name|namenodeId
parameter_list|)
block|{
if|if
condition|(
operator|(
name|nameserviceId
operator|!=
literal|null
operator|&&
operator|!
name|nameserviceId
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|namenodeId
operator|!=
literal|null
operator|&&
operator|!
name|namenodeId
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|nameserviceId
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|DFS_NAMESERVICE_ID
argument_list|,
name|nameserviceId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namenodeId
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|DFS_HA_NAMENODE_ID_KEY
argument_list|,
name|namenodeId
argument_list|)
expr_stmt|;
block|}
name|DFSUtil
operator|.
name|setGenericConf
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|,
name|namenodeId
argument_list|,
name|NAMENODE_SPECIFIC_KEYS
argument_list|)
expr_stmt|;
name|DFSUtil
operator|.
name|setGenericConf
argument_list|(
name|conf
argument_list|,
name|nameserviceId
argument_list|,
literal|null
argument_list|,
name|NAMESERVICE_SPECIFIC_KEYS
argument_list|)
expr_stmt|;
block|}
comment|// If the RPC address is set use it to (re-)configure the default FS
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_RPC_ADDRESS_KEY
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|URI
name|defaultUri
init|=
name|URI
operator|.
name|create
argument_list|(
name|HdfsConstants
operator|.
name|HDFS_URI_SCHEME
operator|+
literal|"://"
operator|+
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_RPC_ADDRESS_KEY
argument_list|)
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|defaultUri
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting "
operator|+
name|FS_DEFAULT_NAME_KEY
operator|+
literal|" to "
operator|+
name|defaultUri
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**     * Get the name service Id for the node    * @return name service Id or null if federation is not configured    */
DECL|method|getNameServiceId (Configuration conf)
specifier|protected
name|String
name|getNameServiceId
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|DFSUtil
operator|.
name|getNamenodeNameServiceId
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/**    */
DECL|method|main (String argv[])
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
name|argv
index|[]
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|DFSUtil
operator|.
name|parseHelpArgument
argument_list|(
name|argv
argument_list|,
name|NameNode
operator|.
name|USAGE
argument_list|,
name|System
operator|.
name|out
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|StringUtils
operator|.
name|startupShutdownMessage
argument_list|(
name|NameNode
operator|.
name|class
argument_list|,
name|argv
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|NameNode
name|namenode
init|=
name|createNameNode
argument_list|(
name|argv
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|namenode
operator|!=
literal|null
condition|)
block|{
name|namenode
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to start namenode."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|monitorHealth ()
specifier|synchronized
name|void
name|monitorHealth
parameter_list|()
throws|throws
name|HealthCheckFailedException
throws|,
name|AccessControlException
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
return|return;
comment|// no-op, if HA is not enabled
block|}
name|getNamesystem
argument_list|()
operator|.
name|checkAvailableResources
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getNamesystem
argument_list|()
operator|.
name|nameNodeHasResourcesAvailable
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|HealthCheckFailedException
argument_list|(
literal|"The NameNode has no resources available"
argument_list|)
throw|;
block|}
block|}
DECL|method|transitionToActive ()
specifier|synchronized
name|void
name|transitionToActive
parameter_list|()
throws|throws
name|ServiceFailedException
throws|,
name|AccessControlException
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
throw|throw
operator|new
name|ServiceFailedException
argument_list|(
literal|"HA for namenode is not enabled"
argument_list|)
throw|;
block|}
name|state
operator|.
name|setState
argument_list|(
name|haContext
argument_list|,
name|ACTIVE_STATE
argument_list|)
expr_stmt|;
block|}
DECL|method|transitionToStandby ()
specifier|synchronized
name|void
name|transitionToStandby
parameter_list|()
throws|throws
name|ServiceFailedException
throws|,
name|AccessControlException
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
throw|throw
operator|new
name|ServiceFailedException
argument_list|(
literal|"HA for namenode is not enabled"
argument_list|)
throw|;
block|}
name|state
operator|.
name|setState
argument_list|(
name|haContext
argument_list|,
name|STANDBY_STATE
argument_list|)
expr_stmt|;
block|}
DECL|method|getServiceStatus ()
specifier|synchronized
name|HAServiceStatus
name|getServiceStatus
parameter_list|()
throws|throws
name|ServiceFailedException
throws|,
name|AccessControlException
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|haEnabled
condition|)
block|{
throw|throw
operator|new
name|ServiceFailedException
argument_list|(
literal|"HA for namenode is not enabled"
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|HAServiceStatus
argument_list|(
name|HAServiceState
operator|.
name|INITIALIZING
argument_list|)
return|;
block|}
name|HAServiceState
name|retState
init|=
name|state
operator|.
name|getServiceState
argument_list|()
decl_stmt|;
name|HAServiceStatus
name|ret
init|=
operator|new
name|HAServiceStatus
argument_list|(
name|retState
argument_list|)
decl_stmt|;
if|if
condition|(
name|retState
operator|==
name|HAServiceState
operator|.
name|STANDBY
condition|)
block|{
if|if
condition|(
name|namesystem
operator|.
name|isInSafeMode
argument_list|()
condition|)
block|{
name|ret
operator|.
name|setNotReadyToBecomeActive
argument_list|(
literal|"The NameNode is in safemode. "
operator|+
name|namesystem
operator|.
name|getSafeModeTip
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|setReadyToBecomeActive
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|retState
operator|==
name|HAServiceState
operator|.
name|ACTIVE
condition|)
block|{
name|ret
operator|.
name|setReadyToBecomeActive
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|setNotReadyToBecomeActive
argument_list|(
literal|"State is "
operator|+
name|state
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|getServiceState ()
specifier|synchronized
name|HAServiceState
name|getServiceState
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
name|HAServiceState
operator|.
name|INITIALIZING
return|;
block|}
return|return
name|state
operator|.
name|getServiceState
argument_list|()
return|;
block|}
comment|/**    * Register NameNodeStatusMXBean    */
DECL|method|registerNNSMXBean ()
specifier|private
name|void
name|registerNNSMXBean
parameter_list|()
block|{
name|nameNodeStatusBeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"NameNode"
argument_list|,
literal|"NameNodeStatus"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// NameNodeStatusMXBean
DECL|method|getNNRole ()
specifier|public
name|String
name|getNNRole
parameter_list|()
block|{
name|String
name|roleStr
init|=
literal|""
decl_stmt|;
name|NamenodeRole
name|role
init|=
name|getRole
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|role
condition|)
block|{
name|roleStr
operator|=
name|role
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|roleStr
return|;
block|}
annotation|@
name|Override
comment|// NameNodeStatusMXBean
DECL|method|getState ()
specifier|public
name|String
name|getState
parameter_list|()
block|{
name|String
name|servStateStr
init|=
literal|""
decl_stmt|;
name|HAServiceState
name|servState
init|=
name|getServiceState
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|servState
condition|)
block|{
name|servStateStr
operator|=
name|servState
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|servStateStr
return|;
block|}
annotation|@
name|Override
comment|// NameNodeStatusMXBean
DECL|method|getHostAndPort ()
specifier|public
name|String
name|getHostAndPort
parameter_list|()
block|{
return|return
name|getNameNodeAddressHostPortString
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeStatusMXBean
DECL|method|isSecurityEnabled ()
specifier|public
name|boolean
name|isSecurityEnabled
parameter_list|()
block|{
return|return
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// NameNodeStatusMXBean
DECL|method|getLastHATransitionTime ()
specifier|public
name|long
name|getLastHATransitionTime
parameter_list|()
block|{
return|return
name|state
operator|.
name|getLastHATransitionTime
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|//NameNodeStatusMXBean
DECL|method|getBytesWithFutureGenerationStamps ()
specifier|public
name|long
name|getBytesWithFutureGenerationStamps
parameter_list|()
block|{
return|return
name|getNamesystem
argument_list|()
operator|.
name|getBytesInFuture
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getSlowPeersReport ()
specifier|public
name|String
name|getSlowPeersReport
parameter_list|()
block|{
return|return
name|namesystem
operator|.
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
operator|.
name|getSlowPeersReport
argument_list|()
return|;
block|}
comment|/**    * Shutdown the NN immediately in an ungraceful way. Used when it would be    * unsafe for the NN to continue operating, e.g. during a failed HA state    * transition.    *     * @param t exception which warrants the shutdown. Printed to the NN log    *          before exit.    * @throws ExitException thrown only for testing.    */
DECL|method|doImmediateShutdown (Throwable t)
specifier|protected
specifier|synchronized
name|void
name|doImmediateShutdown
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|ExitException
block|{
name|String
name|message
init|=
literal|"Error encountered requiring NN shutdown. "
operator|+
literal|"Shutting down immediately."
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|error
argument_list|(
name|message
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ignored
parameter_list|)
block|{
comment|// This is unlikely to happen, but there's nothing we can do if it does.
block|}
name|terminate
argument_list|(
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/**    * Class used to expose {@link NameNode} as context to {@link HAState}    */
DECL|class|NameNodeHAContext
specifier|protected
class|class
name|NameNodeHAContext
implements|implements
name|HAContext
block|{
annotation|@
name|Override
DECL|method|setState (HAState s)
specifier|public
name|void
name|setState
parameter_list|(
name|HAState
name|s
parameter_list|)
block|{
name|state
operator|=
name|s
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getState ()
specifier|public
name|HAState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
annotation|@
name|Override
DECL|method|startActiveServices ()
specifier|public
name|void
name|startActiveServices
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|namesystem
operator|.
name|startActiveServices
argument_list|()
expr_stmt|;
name|startTrashEmptier
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|stopActiveServices ()
specifier|public
name|void
name|stopActiveServices
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|namesystem
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|stopActiveServices
argument_list|()
expr_stmt|;
block|}
name|stopTrashEmptier
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|startStandbyServices ()
specifier|public
name|void
name|startStandbyServices
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|namesystem
operator|.
name|startStandbyServices
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|prepareToStopStandbyServices ()
specifier|public
name|void
name|prepareToStopStandbyServices
parameter_list|()
throws|throws
name|ServiceFailedException
block|{
try|try
block|{
name|namesystem
operator|.
name|prepareToStopStandbyServices
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|stopStandbyServices ()
specifier|public
name|void
name|stopStandbyServices
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|namesystem
operator|!=
literal|null
condition|)
block|{
name|namesystem
operator|.
name|stopStandbyServices
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|doImmediateShutdown
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeLock ()
specifier|public
name|void
name|writeLock
parameter_list|()
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|namesystem
operator|.
name|lockRetryCache
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeUnlock ()
specifier|public
name|void
name|writeUnlock
parameter_list|()
block|{
name|namesystem
operator|.
name|unlockRetryCache
argument_list|()
expr_stmt|;
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
comment|/** Check if an operation of given category is allowed */
annotation|@
name|Override
DECL|method|checkOperation (final OperationCategory op)
specifier|public
name|void
name|checkOperation
parameter_list|(
specifier|final
name|OperationCategory
name|op
parameter_list|)
throws|throws
name|StandbyException
block|{
name|state
operator|.
name|checkOperation
argument_list|(
name|haContext
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|allowStaleReads ()
specifier|public
name|boolean
name|allowStaleReads
parameter_list|()
block|{
return|return
name|allowStaleStandbyReads
return|;
block|}
block|}
DECL|method|isStandbyState ()
specifier|public
name|boolean
name|isStandbyState
parameter_list|()
block|{
return|return
operator|(
name|state
operator|.
name|equals
argument_list|(
name|STANDBY_STATE
argument_list|)
operator|)
return|;
block|}
DECL|method|isActiveState ()
specifier|public
name|boolean
name|isActiveState
parameter_list|()
block|{
return|return
operator|(
name|state
operator|.
name|equals
argument_list|(
name|ACTIVE_STATE
argument_list|)
operator|)
return|;
block|}
comment|/**    * Returns whether the NameNode is completely started    */
DECL|method|isStarted ()
name|boolean
name|isStarted
parameter_list|()
block|{
return|return
name|this
operator|.
name|started
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Check that a request to change this node's HA state is valid.    * In particular, verifies that, if auto failover is enabled, non-forced    * requests from the HAAdmin CLI are rejected, and vice versa.    *    * @param req the request to check    * @throws AccessControlException if the request is disallowed    */
DECL|method|checkHaStateChange (StateChangeRequestInfo req)
name|void
name|checkHaStateChange
parameter_list|(
name|StateChangeRequestInfo
name|req
parameter_list|)
throws|throws
name|AccessControlException
block|{
name|boolean
name|autoHaEnabled
init|=
name|getConf
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|DFS_HA_AUTO_FAILOVER_ENABLED_KEY
argument_list|,
name|DFS_HA_AUTO_FAILOVER_ENABLED_DEFAULT
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|req
operator|.
name|getSource
argument_list|()
condition|)
block|{
case|case
name|REQUEST_BY_USER
case|:
if|if
condition|(
name|autoHaEnabled
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Manual HA control for this NameNode is disallowed, because "
operator|+
literal|"automatic HA is enabled."
argument_list|)
throw|;
block|}
break|break;
case|case
name|REQUEST_BY_USER_FORCED
case|:
if|if
condition|(
name|autoHaEnabled
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Allowing manual HA control from "
operator|+
name|Server
operator|.
name|getRemoteAddress
argument_list|()
operator|+
literal|" even though automatic HA is enabled, because the user "
operator|+
literal|"specified the force flag"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REQUEST_BY_ZKFC
case|:
if|if
condition|(
operator|!
name|autoHaEnabled
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Request from ZK failover controller at "
operator|+
name|Server
operator|.
name|getRemoteAddress
argument_list|()
operator|+
literal|" denied since automatic HA "
operator|+
literal|"is not enabled"
argument_list|)
throw|;
block|}
break|break;
block|}
block|}
comment|/*    * {@inheritDoc}    * */
annotation|@
name|Override
comment|// ReconfigurableBase
DECL|method|getReconfigurableProperties ()
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getReconfigurableProperties
parameter_list|()
block|{
return|return
name|reconfigurableProperties
return|;
block|}
comment|/*    * {@inheritDoc}    * */
annotation|@
name|Override
comment|// ReconfigurableBase
DECL|method|reconfigurePropertyImpl (String property, String newVal)
specifier|protected
name|String
name|reconfigurePropertyImpl
parameter_list|(
name|String
name|property
parameter_list|,
name|String
name|newVal
parameter_list|)
throws|throws
name|ReconfigurationException
block|{
specifier|final
name|DatanodeManager
name|datanodeManager
init|=
name|namesystem
operator|.
name|getBlockManager
argument_list|()
operator|.
name|getDatanodeManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|property
operator|.
name|equals
argument_list|(
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|)
condition|)
block|{
return|return
name|reconfHeartbeatInterval
argument_list|(
name|datanodeManager
argument_list|,
name|property
argument_list|,
name|newVal
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|property
operator|.
name|equals
argument_list|(
name|DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY
argument_list|)
condition|)
block|{
return|return
name|reconfHeartbeatRecheckInterval
argument_list|(
name|datanodeManager
argument_list|,
name|property
argument_list|,
name|newVal
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|property
operator|.
name|equals
argument_list|(
name|FS_PROTECTED_DIRECTORIES
argument_list|)
condition|)
block|{
return|return
name|reconfProtectedDirectories
argument_list|(
name|newVal
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|property
operator|.
name|equals
argument_list|(
name|HADOOP_CALLER_CONTEXT_ENABLED_KEY
argument_list|)
condition|)
block|{
return|return
name|reconfCallerContextEnabled
argument_list|(
name|newVal
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|property
operator|.
name|equals
argument_list|(
name|ipcClientRPCBackoffEnable
argument_list|)
condition|)
block|{
return|return
name|reconfigureIPCBackoffEnabled
argument_list|(
name|newVal
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|ReconfigurationException
argument_list|(
name|property
argument_list|,
name|newVal
argument_list|,
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|property
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|reconfHeartbeatInterval (final DatanodeManager datanodeManager, final String property, final String newVal)
specifier|private
name|String
name|reconfHeartbeatInterval
parameter_list|(
specifier|final
name|DatanodeManager
name|datanodeManager
parameter_list|,
specifier|final
name|String
name|property
parameter_list|,
specifier|final
name|String
name|newVal
parameter_list|)
throws|throws
name|ReconfigurationException
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|newVal
operator|==
literal|null
condition|)
block|{
comment|// set to default
name|datanodeManager
operator|.
name|setHeartbeatInterval
argument_list|(
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
argument_list|)
return|;
block|}
else|else
block|{
name|datanodeManager
operator|.
name|setHeartbeatInterval
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|newVal
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|datanodeManager
operator|.
name|getHeartbeatInterval
argument_list|()
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|ReconfigurationException
argument_list|(
name|property
argument_list|,
name|newVal
argument_list|,
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|property
argument_list|)
argument_list|,
name|nfe
argument_list|)
throw|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"RECONFIGURE* changed heartbeatInterval to "
operator|+
name|datanodeManager
operator|.
name|getHeartbeatInterval
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|reconfHeartbeatRecheckInterval ( final DatanodeManager datanodeManager, final String property, final String newVal)
specifier|private
name|String
name|reconfHeartbeatRecheckInterval
parameter_list|(
specifier|final
name|DatanodeManager
name|datanodeManager
parameter_list|,
specifier|final
name|String
name|property
parameter_list|,
specifier|final
name|String
name|newVal
parameter_list|)
throws|throws
name|ReconfigurationException
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|newVal
operator|==
literal|null
condition|)
block|{
comment|// set to default
name|datanodeManager
operator|.
name|setHeartbeatRecheckInterval
argument_list|(
name|DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_DEFAULT
argument_list|)
return|;
block|}
else|else
block|{
name|datanodeManager
operator|.
name|setHeartbeatRecheckInterval
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|newVal
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|datanodeManager
operator|.
name|getHeartbeatRecheckInterval
argument_list|()
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|ReconfigurationException
argument_list|(
name|property
argument_list|,
name|newVal
argument_list|,
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|property
argument_list|)
argument_list|,
name|nfe
argument_list|)
throw|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"RECONFIGURE* changed heartbeatRecheckInterval to "
operator|+
name|datanodeManager
operator|.
name|getHeartbeatRecheckInterval
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|reconfProtectedDirectories (String newVal)
specifier|private
name|String
name|reconfProtectedDirectories
parameter_list|(
name|String
name|newVal
parameter_list|)
block|{
return|return
name|getNamesystem
argument_list|()
operator|.
name|getFSDirectory
argument_list|()
operator|.
name|setProtectedDirectories
argument_list|(
name|newVal
argument_list|)
return|;
block|}
DECL|method|reconfCallerContextEnabled (String newVal)
specifier|private
name|String
name|reconfCallerContextEnabled
parameter_list|(
name|String
name|newVal
parameter_list|)
block|{
name|Boolean
name|callerContextEnabled
decl_stmt|;
if|if
condition|(
name|newVal
operator|==
literal|null
condition|)
block|{
name|callerContextEnabled
operator|=
name|HADOOP_CALLER_CONTEXT_ENABLED_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|callerContextEnabled
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|newVal
argument_list|)
expr_stmt|;
block|}
name|namesystem
operator|.
name|setCallerContextEnabled
argument_list|(
name|callerContextEnabled
argument_list|)
expr_stmt|;
return|return
name|Boolean
operator|.
name|toString
argument_list|(
name|callerContextEnabled
argument_list|)
return|;
block|}
DECL|method|reconfigureIPCBackoffEnabled (String newVal)
name|String
name|reconfigureIPCBackoffEnabled
parameter_list|(
name|String
name|newVal
parameter_list|)
block|{
name|boolean
name|clientBackoffEnabled
decl_stmt|;
if|if
condition|(
name|newVal
operator|==
literal|null
condition|)
block|{
name|clientBackoffEnabled
operator|=
name|IPC_BACKOFF_ENABLE_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|clientBackoffEnabled
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|newVal
argument_list|)
expr_stmt|;
block|}
name|rpcServer
operator|.
name|getClientRpcServer
argument_list|()
operator|.
name|setClientBackoffEnabled
argument_list|(
name|clientBackoffEnabled
argument_list|)
expr_stmt|;
return|return
name|Boolean
operator|.
name|toString
argument_list|(
name|clientBackoffEnabled
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// ReconfigurableBase
DECL|method|getNewConf ()
specifier|protected
name|Configuration
name|getNewConf
parameter_list|()
block|{
return|return
operator|new
name|HdfsConfiguration
argument_list|()
return|;
block|}
block|}
end_class

end_unit

