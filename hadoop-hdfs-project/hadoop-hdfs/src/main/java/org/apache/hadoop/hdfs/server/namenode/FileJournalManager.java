begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|StorageErrorReporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|StorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorageRetentionManager
operator|.
name|StoragePurger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogLoader
operator|.
name|EditLogValidation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|RemoteEditLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ComparisonChain
import|;
end_import

begin_comment
comment|/**  * Journal manager for the common case of edits files being written  * to a storage directory.  *   * Note: this class is not thread-safe and should be externally  * synchronized.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|FileJournalManager
specifier|public
class|class
name|FileJournalManager
implements|implements
name|JournalManager
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FileJournalManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|sd
specifier|private
specifier|final
name|StorageDirectory
name|sd
decl_stmt|;
DECL|field|errorReporter
specifier|private
specifier|final
name|StorageErrorReporter
name|errorReporter
decl_stmt|;
DECL|field|outputBufferCapacity
specifier|private
name|int
name|outputBufferCapacity
init|=
literal|512
operator|*
literal|1024
decl_stmt|;
DECL|field|EDITS_REGEX
specifier|private
specifier|static
specifier|final
name|Pattern
name|EDITS_REGEX
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|NameNodeFile
operator|.
name|EDITS
operator|.
name|getName
argument_list|()
operator|+
literal|"_(\\d+)-(\\d+)"
argument_list|)
decl_stmt|;
DECL|field|EDITS_INPROGRESS_REGEX
specifier|private
specifier|static
specifier|final
name|Pattern
name|EDITS_INPROGRESS_REGEX
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|NameNodeFile
operator|.
name|EDITS_INPROGRESS
operator|.
name|getName
argument_list|()
operator|+
literal|"_(\\d+)"
argument_list|)
decl_stmt|;
DECL|field|EDITS_INPROGRESS_STALE_REGEX
specifier|private
specifier|static
specifier|final
name|Pattern
name|EDITS_INPROGRESS_STALE_REGEX
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|NameNodeFile
operator|.
name|EDITS_INPROGRESS
operator|.
name|getName
argument_list|()
operator|+
literal|"_(\\d+).*(\\S+)"
argument_list|)
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|currentInProgress
name|File
name|currentInProgress
init|=
literal|null
decl_stmt|;
comment|/**    * A FileJournalManager should maintain the largest Tx ID that has been    * safely written to its edit log files.    * It should limit readers to read beyond this ID to avoid potential race    * with ongoing writers.    * Initial value indicates that all transactions can be read.    */
DECL|field|lastReadableTxId
specifier|private
name|long
name|lastReadableTxId
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|purger
name|StoragePurger
name|purger
init|=
operator|new
name|NNStorageRetentionManager
operator|.
name|DeletionStoragePurger
argument_list|()
decl_stmt|;
DECL|method|FileJournalManager (Configuration conf, StorageDirectory sd, StorageErrorReporter errorReporter)
specifier|public
name|FileJournalManager
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|,
name|StorageErrorReporter
name|errorReporter
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|sd
operator|=
name|sd
expr_stmt|;
name|this
operator|.
name|errorReporter
operator|=
name|errorReporter
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{}
annotation|@
name|Override
DECL|method|format (NamespaceInfo ns, boolean force)
specifier|public
name|void
name|format
parameter_list|(
name|NamespaceInfo
name|ns
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Formatting file journals is done by the StorageDirectory
comment|// format code, since they may share their directory with
comment|// checkpoints, etc.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|hasSomeData ()
specifier|public
name|boolean
name|hasSomeData
parameter_list|()
block|{
comment|// Formatting file journals is done by the StorageDirectory
comment|// format code, since they may share their directory with
comment|// checkpoints, etc.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
DECL|method|startLogSegment (long txid, int layoutVersion)
specifier|synchronized
specifier|public
name|EditLogOutputStream
name|startLogSegment
parameter_list|(
name|long
name|txid
parameter_list|,
name|int
name|layoutVersion
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|currentInProgress
operator|=
name|NNStorage
operator|.
name|getInProgressEditsFile
argument_list|(
name|sd
argument_list|,
name|txid
argument_list|)
expr_stmt|;
name|EditLogOutputStream
name|stm
init|=
operator|new
name|EditLogFileOutputStream
argument_list|(
name|conf
argument_list|,
name|currentInProgress
argument_list|,
name|outputBufferCapacity
argument_list|)
decl_stmt|;
name|stm
operator|.
name|create
argument_list|(
name|layoutVersion
argument_list|)
expr_stmt|;
return|return
name|stm
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to start log segment "
operator|+
name|txid
operator|+
literal|" at "
operator|+
name|currentInProgress
operator|+
literal|": "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|errorReporter
operator|.
name|reportErrorOnFile
argument_list|(
name|currentInProgress
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|finalizeLogSegment (long firstTxId, long lastTxId)
specifier|synchronized
specifier|public
name|void
name|finalizeLogSegment
parameter_list|(
name|long
name|firstTxId
parameter_list|,
name|long
name|lastTxId
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|inprogressFile
init|=
name|NNStorage
operator|.
name|getInProgressEditsFile
argument_list|(
name|sd
argument_list|,
name|firstTxId
argument_list|)
decl_stmt|;
name|File
name|dstFile
init|=
name|NNStorage
operator|.
name|getFinalizedEditsFile
argument_list|(
name|sd
argument_list|,
name|firstTxId
argument_list|,
name|lastTxId
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalizing edits file "
operator|+
name|inprogressFile
operator|+
literal|" -> "
operator|+
name|dstFile
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|dstFile
operator|.
name|exists
argument_list|()
argument_list|,
literal|"Can't finalize edits file "
operator|+
name|inprogressFile
operator|+
literal|" since finalized file "
operator|+
literal|"already exists"
argument_list|)
expr_stmt|;
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|inprogressFile
argument_list|,
name|dstFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|errorReporter
operator|.
name|reportErrorOnFile
argument_list|(
name|dstFile
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to finalize edits file "
operator|+
name|inprogressFile
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|inprogressFile
operator|.
name|equals
argument_list|(
name|currentInProgress
argument_list|)
condition|)
block|{
name|currentInProgress
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStorageDirectory ()
specifier|public
name|StorageDirectory
name|getStorageDirectory
parameter_list|()
block|{
return|return
name|sd
return|;
block|}
annotation|@
name|Override
DECL|method|setOutputBufferCapacity (int size)
specifier|synchronized
specifier|public
name|void
name|setOutputBufferCapacity
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|outputBufferCapacity
operator|=
name|size
expr_stmt|;
block|}
DECL|method|getLastReadableTxId ()
specifier|public
name|long
name|getLastReadableTxId
parameter_list|()
block|{
return|return
name|lastReadableTxId
return|;
block|}
DECL|method|setLastReadableTxId (long id)
specifier|public
name|void
name|setLastReadableTxId
parameter_list|(
name|long
name|id
parameter_list|)
block|{
name|this
operator|.
name|lastReadableTxId
operator|=
name|id
expr_stmt|;
block|}
comment|/**    * Purges the unnecessary edits and edits_inprogress files.    *    * Edits files that are ending before the minTxIdToKeep are purged.    * Edits in progress files that are starting before minTxIdToKeep are purged.    * Edits in progress files that are marked as empty, trash, corrupted or    * stale by file extension and starting before minTxIdToKeep are purged.    * Edits in progress files that are after minTxIdToKeep, but before the    * current edits in progress files are marked as stale for clarity.    *    * In case file removal or rename is failing a warning is logged, but that    * does not fail the operation.    *    * @param minTxIdToKeep the lowest transaction ID that should be retained    * @throws IOException if listing the storage directory fails.    */
annotation|@
name|Override
DECL|method|purgeLogsOlderThan (long minTxIdToKeep)
specifier|public
name|void
name|purgeLogsOlderThan
parameter_list|(
name|long
name|minTxIdToKeep
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Purging logs older than "
operator|+
name|minTxIdToKeep
argument_list|)
expr_stmt|;
name|File
index|[]
name|files
init|=
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|editLogs
init|=
name|matchEditLogs
argument_list|(
name|files
argument_list|,
literal|true
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|EditLogFile
name|log
range|:
name|editLogs
control|)
block|{
if|if
condition|(
name|log
operator|.
name|getFirstTxId
argument_list|()
operator|<
name|minTxIdToKeep
operator|&&
name|log
operator|.
name|getLastTxId
argument_list|()
operator|<
name|minTxIdToKeep
condition|)
block|{
name|purger
operator|.
name|purgeLog
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isStaleInProgressLog
argument_list|(
name|minTxIdToKeep
argument_list|,
name|log
argument_list|)
condition|)
block|{
name|purger
operator|.
name|markStale
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|isStaleInProgressLog (long minTxIdToKeep, EditLogFile log)
specifier|private
name|boolean
name|isStaleInProgressLog
parameter_list|(
name|long
name|minTxIdToKeep
parameter_list|,
name|EditLogFile
name|log
parameter_list|)
block|{
return|return
name|log
operator|.
name|isInProgress
argument_list|()
operator|&&
operator|!
name|log
operator|.
name|getFile
argument_list|()
operator|.
name|equals
argument_list|(
name|currentInProgress
argument_list|)
operator|&&
name|log
operator|.
name|getFirstTxId
argument_list|()
operator|>=
name|minTxIdToKeep
operator|&&
comment|// at last we check if this segment is not already marked as .trash,
comment|// .empty or .corrupted, in which case it does not match the strict
comment|// regex pattern.
name|EDITS_INPROGRESS_REGEX
operator|.
name|matcher
argument_list|(
name|log
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
comment|/**    * Find all editlog segments starting at or above the given txid.    * @param firstTxId the txnid which to start looking    * @param inProgressOk whether or not to include the in-progress edit log     *        segment           * @return a list of remote edit logs    * @throws IOException if edit logs cannot be listed.    */
DECL|method|getRemoteEditLogs (long firstTxId, boolean inProgressOk)
specifier|public
name|List
argument_list|<
name|RemoteEditLog
argument_list|>
name|getRemoteEditLogs
parameter_list|(
name|long
name|firstTxId
parameter_list|,
name|boolean
name|inProgressOk
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|currentDir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|allLogFiles
init|=
name|matchEditLogs
argument_list|(
name|currentDir
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RemoteEditLog
argument_list|>
name|ret
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|allLogFiles
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|EditLogFile
name|elf
range|:
name|allLogFiles
control|)
block|{
if|if
condition|(
name|elf
operator|.
name|hasCorruptHeader
argument_list|()
operator|||
operator|(
operator|!
name|inProgressOk
operator|&&
name|elf
operator|.
name|isInProgress
argument_list|()
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|elf
operator|.
name|isInProgress
argument_list|()
condition|)
block|{
try|try
block|{
name|elf
operator|.
name|scanLog
argument_list|(
name|getLastReadableTxId
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"got IOException while trying to validate header of "
operator|+
name|elf
operator|+
literal|".  Skipping."
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|elf
operator|.
name|getFirstTxId
argument_list|()
operator|>=
name|firstTxId
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
operator|new
name|RemoteEditLog
argument_list|(
name|elf
operator|.
name|firstTxId
argument_list|,
name|elf
operator|.
name|lastTxId
argument_list|,
name|elf
operator|.
name|isInProgress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elf
operator|.
name|getFirstTxId
argument_list|()
operator|<
name|firstTxId
operator|&&
name|firstTxId
operator|<=
name|elf
operator|.
name|getLastTxId
argument_list|()
condition|)
block|{
comment|// If the firstTxId is in the middle of an edit log segment. Return this
comment|// anyway and let the caller figure out whether it wants to use it.
name|ret
operator|.
name|add
argument_list|(
operator|new
name|RemoteEditLog
argument_list|(
name|elf
operator|.
name|firstTxId
argument_list|,
name|elf
operator|.
name|lastTxId
argument_list|,
name|elf
operator|.
name|isInProgress
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Discard all editlog segments whose first txid is greater than or equal to    * the given txid, by renaming them with suffix ".trash".    */
DECL|method|discardEditLogSegments (long startTxId)
specifier|private
name|void
name|discardEditLogSegments
parameter_list|(
name|long
name|startTxId
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|currentDir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|allLogFiles
init|=
name|matchEditLogs
argument_list|(
name|currentDir
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|toTrash
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Discard the EditLog files, the given start txid is "
operator|+
name|startTxId
argument_list|)
expr_stmt|;
comment|// go through the editlog files to make sure the startTxId is right at the
comment|// segment boundary
for|for
control|(
name|EditLogFile
name|elf
range|:
name|allLogFiles
control|)
block|{
if|if
condition|(
name|elf
operator|.
name|getFirstTxId
argument_list|()
operator|>=
name|startTxId
condition|)
block|{
name|toTrash
operator|.
name|add
argument_list|(
name|elf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|elf
operator|.
name|getLastTxId
argument_list|()
operator|<
name|startTxId
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|EditLogFile
name|elf
range|:
name|toTrash
control|)
block|{
comment|// rename these editlog file as .trash
name|elf
operator|.
name|moveAsideTrashFile
argument_list|(
name|startTxId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Trash the EditLog file "
operator|+
name|elf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * returns matching edit logs via the log directory. Simple helper function    * that lists the files in the logDir and calls matchEditLogs(File[])    *     * @param logDir    *          directory to match edit logs in    * @return matched edit logs    * @throws IOException    *           IOException thrown for invalid logDir    */
DECL|method|matchEditLogs (File logDir)
specifier|public
specifier|static
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|matchEditLogs
parameter_list|(
name|File
name|logDir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|matchEditLogs
argument_list|(
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|logDir
argument_list|)
argument_list|)
return|;
block|}
DECL|method|matchEditLogs (File[] filesInStorage)
specifier|static
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|matchEditLogs
parameter_list|(
name|File
index|[]
name|filesInStorage
parameter_list|)
block|{
return|return
name|matchEditLogs
argument_list|(
name|filesInStorage
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|matchEditLogs (File[] filesInStorage, boolean forPurging)
specifier|private
specifier|static
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|matchEditLogs
parameter_list|(
name|File
index|[]
name|filesInStorage
parameter_list|,
name|boolean
name|forPurging
parameter_list|)
block|{
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|ret
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|File
name|f
range|:
name|filesInStorage
control|)
block|{
name|String
name|name
init|=
name|f
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Check for edits
name|Matcher
name|editsMatch
init|=
name|EDITS_REGEX
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|editsMatch
operator|.
name|matches
argument_list|()
condition|)
block|{
try|try
block|{
name|long
name|startTxId
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|editsMatch
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|endTxId
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|editsMatch
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
operator|new
name|EditLogFile
argument_list|(
name|f
argument_list|,
name|startTxId
argument_list|,
name|endTxId
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Edits file "
operator|+
name|f
operator|+
literal|" has improperly formatted "
operator|+
literal|"transaction ID"
argument_list|)
expr_stmt|;
comment|// skip
block|}
block|}
comment|// Check for in-progress edits
name|Matcher
name|inProgressEditsMatch
init|=
name|EDITS_INPROGRESS_REGEX
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|inProgressEditsMatch
operator|.
name|matches
argument_list|()
condition|)
block|{
try|try
block|{
name|long
name|startTxId
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|inProgressEditsMatch
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
operator|new
name|EditLogFile
argument_list|(
name|f
argument_list|,
name|startTxId
argument_list|,
name|HdfsServerConstants
operator|.
name|INVALID_TXID
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"In-progress edits file "
operator|+
name|f
operator|+
literal|" has improperly "
operator|+
literal|"formatted transaction ID"
argument_list|)
expr_stmt|;
comment|// skip
block|}
block|}
if|if
condition|(
name|forPurging
condition|)
block|{
comment|// Check for in-progress stale edits
name|Matcher
name|staleInprogressEditsMatch
init|=
name|EDITS_INPROGRESS_STALE_REGEX
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|staleInprogressEditsMatch
operator|.
name|matches
argument_list|()
condition|)
block|{
try|try
block|{
name|long
name|startTxId
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|staleInprogressEditsMatch
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|.
name|add
argument_list|(
operator|new
name|EditLogFile
argument_list|(
name|f
argument_list|,
name|startTxId
argument_list|,
name|HdfsServerConstants
operator|.
name|INVALID_TXID
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"In-progress stale edits file "
operator|+
name|f
operator|+
literal|" has improperly "
operator|+
literal|"formatted transaction ID"
argument_list|)
expr_stmt|;
comment|// skip
block|}
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
DECL|method|selectInputStreams ( Collection<EditLogInputStream> streams, long fromTxnId, boolean inProgressOk)
specifier|synchronized
specifier|public
name|void
name|selectInputStreams
parameter_list|(
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
parameter_list|,
name|long
name|fromTxnId
parameter_list|,
name|boolean
name|inProgressOk
parameter_list|)
throws|throws
name|IOException
block|{
name|selectInputStreams
argument_list|(
name|streams
argument_list|,
name|fromTxnId
argument_list|,
name|inProgressOk
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|selectInputStreams ( Collection<EditLogInputStream> streams, long fromTxId, boolean inProgressOk, boolean onlyDurableTxns)
specifier|synchronized
specifier|public
name|void
name|selectInputStreams
parameter_list|(
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
parameter_list|,
name|long
name|fromTxId
parameter_list|,
name|boolean
name|inProgressOk
parameter_list|,
name|boolean
name|onlyDurableTxns
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|elfs
init|=
name|matchEditLogs
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|+
literal|": selecting input streams starting at "
operator|+
name|fromTxId
operator|+
operator|(
name|inProgressOk
condition|?
literal|" (inProgress ok) "
else|:
literal|" (excluding inProgress) "
operator|)
operator|+
literal|"from among "
operator|+
name|elfs
operator|.
name|size
argument_list|()
operator|+
literal|" candidate file(s)"
argument_list|)
expr_stmt|;
block|}
name|addStreamsToCollectionFromFiles
argument_list|(
name|elfs
argument_list|,
name|streams
argument_list|,
name|fromTxId
argument_list|,
name|getLastReadableTxId
argument_list|()
argument_list|,
name|inProgressOk
argument_list|)
expr_stmt|;
block|}
DECL|method|addStreamsToCollectionFromFiles (Collection<EditLogFile> elfs, Collection<EditLogInputStream> streams, long fromTxId, long maxTxIdToScan, boolean inProgressOk)
specifier|static
name|void
name|addStreamsToCollectionFromFiles
parameter_list|(
name|Collection
argument_list|<
name|EditLogFile
argument_list|>
name|elfs
parameter_list|,
name|Collection
argument_list|<
name|EditLogInputStream
argument_list|>
name|streams
parameter_list|,
name|long
name|fromTxId
parameter_list|,
name|long
name|maxTxIdToScan
parameter_list|,
name|boolean
name|inProgressOk
parameter_list|)
block|{
for|for
control|(
name|EditLogFile
name|elf
range|:
name|elfs
control|)
block|{
if|if
condition|(
name|elf
operator|.
name|isInProgress
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|inProgressOk
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"passing over "
operator|+
name|elf
operator|+
literal|" because it is in progress "
operator|+
literal|"and we are ignoring in-progress logs."
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
try|try
block|{
name|elf
operator|.
name|scanLog
argument_list|(
name|maxTxIdToScan
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"got IOException while trying to validate header of "
operator|+
name|elf
operator|+
literal|".  Skipping."
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|elf
operator|.
name|lastTxId
operator|<
name|fromTxId
condition|)
block|{
assert|assert
name|elf
operator|.
name|lastTxId
operator|!=
name|HdfsServerConstants
operator|.
name|INVALID_TXID
assert|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"passing over "
operator|+
name|elf
operator|+
literal|" because it ends at "
operator|+
name|elf
operator|.
name|lastTxId
operator|+
literal|", but we only care about transactions "
operator|+
literal|"as new as "
operator|+
name|fromTxId
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|EditLogFileInputStream
name|elfis
init|=
operator|new
name|EditLogFileInputStream
argument_list|(
name|elf
operator|.
name|getFile
argument_list|()
argument_list|,
name|elf
operator|.
name|getFirstTxId
argument_list|()
argument_list|,
name|elf
operator|.
name|getLastTxId
argument_list|()
argument_list|,
name|elf
operator|.
name|isInProgress
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"selecting edit log stream "
operator|+
name|elf
argument_list|)
expr_stmt|;
name|streams
operator|.
name|add
argument_list|(
name|elfis
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|recoverUnfinalizedSegments ()
specifier|synchronized
specifier|public
name|void
name|recoverUnfinalizedSegments
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|currentDir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering unfinalized segments in "
operator|+
name|currentDir
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|allLogFiles
init|=
name|matchEditLogs
argument_list|(
name|currentDir
argument_list|)
decl_stmt|;
for|for
control|(
name|EditLogFile
name|elf
range|:
name|allLogFiles
control|)
block|{
if|if
condition|(
name|elf
operator|.
name|getFile
argument_list|()
operator|.
name|equals
argument_list|(
name|currentInProgress
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|elf
operator|.
name|isInProgress
argument_list|()
condition|)
block|{
comment|// If the file is zero-length, we likely just crashed after opening the
comment|// file, but before writing anything to it. Safe to delete it.
if|if
condition|(
name|elf
operator|.
name|getFile
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting zero-length edit log file "
operator|+
name|elf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf
operator|.
name|getFile
argument_list|()
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to delete file "
operator|+
name|elf
operator|.
name|getFile
argument_list|()
argument_list|)
throw|;
block|}
continue|continue;
block|}
name|elf
operator|.
name|scanLog
argument_list|(
name|getLastReadableTxId
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf
operator|.
name|hasCorruptHeader
argument_list|()
condition|)
block|{
name|elf
operator|.
name|moveAsideCorruptFile
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|CorruptionException
argument_list|(
literal|"In-progress edit log file is corrupt: "
operator|+
name|elf
argument_list|)
throw|;
block|}
if|if
condition|(
name|elf
operator|.
name|getLastTxId
argument_list|()
operator|==
name|HdfsServerConstants
operator|.
name|INVALID_TXID
condition|)
block|{
comment|// If the file has a valid header (isn't corrupt) but contains no
comment|// transactions, we likely just crashed after opening the file and
comment|// writing the header, but before syncing any transactions. Safe to
comment|// delete the file.
name|LOG
operator|.
name|info
argument_list|(
literal|"Moving aside edit log file that seems to have zero "
operator|+
literal|"transactions "
operator|+
name|elf
argument_list|)
expr_stmt|;
name|elf
operator|.
name|moveAsideEmptyFile
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|finalizeLogSegment
argument_list|(
name|elf
operator|.
name|getFirstTxId
argument_list|()
argument_list|,
name|elf
operator|.
name|getLastTxId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getLogFiles (long fromTxId)
specifier|public
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|getLogFiles
parameter_list|(
name|long
name|fromTxId
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|currentDir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|allLogFiles
init|=
name|matchEditLogs
argument_list|(
name|currentDir
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|logFiles
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|EditLogFile
name|elf
range|:
name|allLogFiles
control|)
block|{
if|if
condition|(
name|fromTxId
operator|<=
name|elf
operator|.
name|getFirstTxId
argument_list|()
operator|||
name|elf
operator|.
name|containsTxId
argument_list|(
name|fromTxId
argument_list|)
condition|)
block|{
name|logFiles
operator|.
name|add
argument_list|(
name|elf
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|logFiles
argument_list|,
name|EditLogFile
operator|.
name|COMPARE_BY_START_TXID
argument_list|)
expr_stmt|;
return|return
name|logFiles
return|;
block|}
DECL|method|getLogFile (long startTxId)
specifier|public
name|EditLogFile
name|getLogFile
parameter_list|(
name|long
name|startTxId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getLogFile
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|startTxId
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|getLogFile (long startTxId, boolean inProgressOk)
specifier|public
name|EditLogFile
name|getLogFile
parameter_list|(
name|long
name|startTxId
parameter_list|,
name|boolean
name|inProgressOk
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getLogFile
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|startTxId
argument_list|,
name|inProgressOk
argument_list|)
return|;
block|}
DECL|method|getLogFile (File dir, long startTxId)
specifier|public
specifier|static
name|EditLogFile
name|getLogFile
parameter_list|(
name|File
name|dir
parameter_list|,
name|long
name|startTxId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getLogFile
argument_list|(
name|dir
argument_list|,
name|startTxId
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|getLogFile (File dir, long startTxId, boolean inProgressOk)
specifier|public
specifier|static
name|EditLogFile
name|getLogFile
parameter_list|(
name|File
name|dir
parameter_list|,
name|long
name|startTxId
parameter_list|,
name|boolean
name|inProgressOk
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|files
init|=
name|matchEditLogs
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|EditLogFile
argument_list|>
name|ret
init|=
name|Lists
operator|.
name|newLinkedList
argument_list|()
decl_stmt|;
for|for
control|(
name|EditLogFile
name|elf
range|:
name|files
control|)
block|{
if|if
condition|(
name|elf
operator|.
name|getFirstTxId
argument_list|()
operator|==
name|startTxId
condition|)
block|{
if|if
condition|(
name|inProgressOk
operator|||
operator|!
name|elf
operator|.
name|isInProgress
argument_list|()
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|elf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// no matches
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|ret
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"More than one log segment in "
operator|+
name|dir
operator|+
literal|" starting at txid "
operator|+
name|startTxId
operator|+
literal|": "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|ret
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"FileJournalManager(root=%s)"
argument_list|,
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Record of an edit log that has been located and had its filename parsed.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|EditLogFile
specifier|public
specifier|static
class|class
name|EditLogFile
block|{
DECL|field|file
specifier|private
name|File
name|file
decl_stmt|;
DECL|field|firstTxId
specifier|private
specifier|final
name|long
name|firstTxId
decl_stmt|;
DECL|field|lastTxId
specifier|private
name|long
name|lastTxId
decl_stmt|;
DECL|field|hasCorruptHeader
specifier|private
name|boolean
name|hasCorruptHeader
init|=
literal|false
decl_stmt|;
DECL|field|isInProgress
specifier|private
specifier|final
name|boolean
name|isInProgress
decl_stmt|;
DECL|field|COMPARE_BY_START_TXID
specifier|final
specifier|static
name|Comparator
argument_list|<
name|EditLogFile
argument_list|>
name|COMPARE_BY_START_TXID
init|=
operator|new
name|Comparator
argument_list|<
name|EditLogFile
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|EditLogFile
name|a
parameter_list|,
name|EditLogFile
name|b
parameter_list|)
block|{
return|return
name|ComparisonChain
operator|.
name|start
argument_list|()
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getFirstTxId
argument_list|()
argument_list|,
name|b
operator|.
name|getFirstTxId
argument_list|()
argument_list|)
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getLastTxId
argument_list|()
argument_list|,
name|b
operator|.
name|getLastTxId
argument_list|()
argument_list|)
operator|.
name|result
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|method|EditLogFile (File file, long firstTxId, long lastTxId)
name|EditLogFile
parameter_list|(
name|File
name|file
parameter_list|,
name|long
name|firstTxId
parameter_list|,
name|long
name|lastTxId
parameter_list|)
block|{
name|this
argument_list|(
name|file
argument_list|,
name|firstTxId
argument_list|,
name|lastTxId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|lastTxId
operator|!=
name|HdfsServerConstants
operator|.
name|INVALID_TXID
operator|)
operator|&&
operator|(
name|lastTxId
operator|>=
name|firstTxId
operator|)
assert|;
block|}
DECL|method|EditLogFile (File file, long firstTxId, long lastTxId, boolean isInProgress)
name|EditLogFile
parameter_list|(
name|File
name|file
parameter_list|,
name|long
name|firstTxId
parameter_list|,
name|long
name|lastTxId
parameter_list|,
name|boolean
name|isInProgress
parameter_list|)
block|{
assert|assert
operator|(
name|lastTxId
operator|==
name|HdfsServerConstants
operator|.
name|INVALID_TXID
operator|&&
name|isInProgress
operator|)
operator|||
operator|(
name|lastTxId
operator|!=
name|HdfsServerConstants
operator|.
name|INVALID_TXID
operator|&&
name|lastTxId
operator|>=
name|firstTxId
operator|)
assert|;
assert|assert
operator|(
name|firstTxId
operator|>
literal|0
operator|)
operator|||
operator|(
name|firstTxId
operator|==
name|HdfsServerConstants
operator|.
name|INVALID_TXID
operator|)
assert|;
assert|assert
name|file
operator|!=
literal|null
assert|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|isInProgress
operator|||
name|lastTxId
operator|==
name|HdfsServerConstants
operator|.
name|INVALID_TXID
argument_list|)
expr_stmt|;
name|this
operator|.
name|firstTxId
operator|=
name|firstTxId
expr_stmt|;
name|this
operator|.
name|lastTxId
operator|=
name|lastTxId
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|this
operator|.
name|isInProgress
operator|=
name|isInProgress
expr_stmt|;
block|}
DECL|method|getFirstTxId ()
specifier|public
name|long
name|getFirstTxId
parameter_list|()
block|{
return|return
name|firstTxId
return|;
block|}
DECL|method|getLastTxId ()
specifier|public
name|long
name|getLastTxId
parameter_list|()
block|{
return|return
name|lastTxId
return|;
block|}
DECL|method|containsTxId (long txId)
name|boolean
name|containsTxId
parameter_list|(
name|long
name|txId
parameter_list|)
block|{
return|return
name|firstTxId
operator|<=
name|txId
operator|&&
name|txId
operator|<=
name|lastTxId
return|;
block|}
comment|/**       * Find out where the edit log ends.      * This will update the lastTxId of the EditLogFile or      * mark it as corrupt if it is.      * @param maxTxIdToScan Maximum Tx ID to try to scan.      *                      The scan returns after reading this or a higher ID.      *                      The file portion beyond this ID is potentially being      *                      updated.      * @param verifyVersion Whether the scan should verify the layout version      */
DECL|method|scanLog (long maxTxIdToScan, boolean verifyVersion)
specifier|public
name|void
name|scanLog
parameter_list|(
name|long
name|maxTxIdToScan
parameter_list|,
name|boolean
name|verifyVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|EditLogValidation
name|val
init|=
name|EditLogFileInputStream
operator|.
name|scanEditLog
argument_list|(
name|file
argument_list|,
name|maxTxIdToScan
argument_list|,
name|verifyVersion
argument_list|)
decl_stmt|;
name|this
operator|.
name|lastTxId
operator|=
name|val
operator|.
name|getEndTxId
argument_list|()
expr_stmt|;
name|this
operator|.
name|hasCorruptHeader
operator|=
name|val
operator|.
name|hasCorruptHeader
argument_list|()
expr_stmt|;
block|}
DECL|method|isInProgress ()
specifier|public
name|boolean
name|isInProgress
parameter_list|()
block|{
return|return
name|isInProgress
return|;
block|}
DECL|method|getFile ()
specifier|public
name|File
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
DECL|method|hasCorruptHeader ()
name|boolean
name|hasCorruptHeader
parameter_list|()
block|{
return|return
name|hasCorruptHeader
return|;
block|}
DECL|method|moveAsideCorruptFile ()
name|void
name|moveAsideCorruptFile
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|hasCorruptHeader
assert|;
name|renameSelf
argument_list|(
literal|".corrupt"
argument_list|)
expr_stmt|;
block|}
DECL|method|moveAsideTrashFile (long markerTxid)
name|void
name|moveAsideTrashFile
parameter_list|(
name|long
name|markerTxid
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|this
operator|.
name|getFirstTxId
argument_list|()
operator|>=
name|markerTxid
assert|;
name|renameSelf
argument_list|(
literal|".trash"
argument_list|)
expr_stmt|;
block|}
DECL|method|moveAsideEmptyFile ()
specifier|public
name|void
name|moveAsideEmptyFile
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|lastTxId
operator|==
name|HdfsServerConstants
operator|.
name|INVALID_TXID
assert|;
name|renameSelf
argument_list|(
literal|".empty"
argument_list|)
expr_stmt|;
block|}
DECL|method|moveAsideStaleInprogressFile ()
specifier|public
name|void
name|moveAsideStaleInprogressFile
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|isInProgress
assert|;
name|renameSelf
argument_list|(
literal|".stale"
argument_list|)
expr_stmt|;
block|}
DECL|method|renameSelf (String newSuffix)
specifier|private
name|void
name|renameSelf
parameter_list|(
name|String
name|newSuffix
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|src
init|=
name|file
decl_stmt|;
name|File
name|dst
init|=
operator|new
name|File
argument_list|(
name|src
operator|.
name|getParent
argument_list|()
argument_list|,
name|src
operator|.
name|getName
argument_list|()
operator|+
name|newSuffix
argument_list|)
decl_stmt|;
comment|// renameTo fails on Windows if the destination file already exists.
try|try
block|{
if|if
condition|(
name|dst
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dst
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't delete "
operator|+
name|dst
argument_list|)
throw|;
block|}
block|}
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't rename log "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|file
operator|=
name|dst
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"EditLogFile(file=%s,first=%019d,last=%019d,"
operator|+
literal|"inProgress=%b,hasCorruptHeader=%b)"
argument_list|,
name|file
operator|.
name|toString
argument_list|()
argument_list|,
name|firstTxId
argument_list|,
name|lastTxId
argument_list|,
name|isInProgress
argument_list|()
argument_list|,
name|hasCorruptHeader
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|doPreUpgrade ()
specifier|public
name|void
name|doPreUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting upgrade of edits directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|NNUpgradeUtil
operator|.
name|doPreUpgrade
argument_list|(
name|conf
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to move aside pre-upgrade storage "
operator|+
literal|"in image directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
comment|/**    * This method assumes that the fields of the {@link Storage} object have    * already been updated to the appropriate new values for the upgrade.    */
annotation|@
name|Override
DECL|method|doUpgrade (Storage storage)
specifier|public
name|void
name|doUpgrade
parameter_list|(
name|Storage
name|storage
parameter_list|)
throws|throws
name|IOException
block|{
name|NNUpgradeUtil
operator|.
name|doUpgrade
argument_list|(
name|sd
argument_list|,
name|storage
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doFinalize ()
specifier|public
name|void
name|doFinalize
parameter_list|()
throws|throws
name|IOException
block|{
name|NNUpgradeUtil
operator|.
name|doFinalize
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|canRollBack (StorageInfo storage, StorageInfo prevStorage, int targetLayoutVersion)
specifier|public
name|boolean
name|canRollBack
parameter_list|(
name|StorageInfo
name|storage
parameter_list|,
name|StorageInfo
name|prevStorage
parameter_list|,
name|int
name|targetLayoutVersion
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|NNUpgradeUtil
operator|.
name|canRollBack
argument_list|(
name|sd
argument_list|,
name|storage
argument_list|,
name|prevStorage
argument_list|,
name|targetLayoutVersion
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doRollback ()
specifier|public
name|void
name|doRollback
parameter_list|()
throws|throws
name|IOException
block|{
name|NNUpgradeUtil
operator|.
name|doRollBack
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|discardSegments (long startTxid)
specifier|public
name|void
name|discardSegments
parameter_list|(
name|long
name|startTxid
parameter_list|)
throws|throws
name|IOException
block|{
name|discardEditLogSegments
argument_list|(
name|startTxid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getJournalCTime ()
specifier|public
name|long
name|getJournalCTime
parameter_list|()
throws|throws
name|IOException
block|{
name|StorageInfo
name|sInfo
init|=
operator|new
name|StorageInfo
argument_list|(
operator|(
name|NodeType
operator|)
literal|null
argument_list|)
decl_stmt|;
name|sInfo
operator|.
name|readProperties
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|sInfo
operator|.
name|getCTime
argument_list|()
return|;
block|}
block|}
end_class

end_unit

