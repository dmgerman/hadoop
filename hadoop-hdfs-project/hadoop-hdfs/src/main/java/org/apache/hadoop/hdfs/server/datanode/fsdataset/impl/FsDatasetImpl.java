begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode.fsdataset.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|NotCompliantMBeanException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|StandardMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockLocalPathInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsBlocksMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|GenerationStamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|BlockMetadataHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataBlockScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|FinalizedReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|Replica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaBeingWritten
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaInPipeline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaUnderRecovery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaWaitingToBeRecovered
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|StorageLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsDatasetSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|LengthInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaInputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaOutputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|RollingLogs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|RoundRobinVolumeChoosingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|VolumeChoosingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|metrics
operator|.
name|FSDatasetMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReplicaRecoveryInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskErrorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskOutOfSpaceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_comment
comment|/**************************************************  * FSDataset manages a set of data blocks.  Each block  * has a unique name and an extent on disk.  *  ***************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|FsDatasetImpl
class|class
name|FsDatasetImpl
implements|implements
name|FsDatasetSpi
argument_list|<
name|FsVolumeImpl
argument_list|>
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FsDatasetImpl
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|isNativeIOAvailable
specifier|private
specifier|final
specifier|static
name|boolean
name|isNativeIOAvailable
decl_stmt|;
static|static
block|{
name|isNativeIOAvailable
operator|=
name|NativeIO
operator|.
name|isAvailable
argument_list|()
expr_stmt|;
if|if
condition|(
name|Path
operator|.
name|WINDOWS
operator|&&
operator|!
name|isNativeIOAvailable
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Data node cannot fully support concurrent reading"
operator|+
literal|" and writing without native code extensions on Windows."
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getVolumes ()
specifier|public
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|getVolumes
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|volumes
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getStorageReports (String bpid)
specifier|public
name|StorageReport
index|[]
name|getStorageReports
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|StorageReport
index|[]
name|reports
decl_stmt|;
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
name|reports
operator|=
operator|new
name|StorageReport
index|[
name|volumes
operator|.
name|volumes
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|volumes
operator|.
name|volumes
control|)
block|{
name|reports
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|StorageReport
argument_list|(
name|volume
operator|.
name|getStorageID
argument_list|()
argument_list|,
literal|false
argument_list|,
name|volume
operator|.
name|getCapacity
argument_list|()
argument_list|,
name|volume
operator|.
name|getDfsUsed
argument_list|()
argument_list|,
name|volume
operator|.
name|getAvailable
argument_list|()
argument_list|,
name|volume
operator|.
name|getBlockPoolUsed
argument_list|(
name|bpid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|reports
return|;
block|}
annotation|@
name|Override
DECL|method|getVolume (final ExtendedBlock b)
specifier|public
specifier|synchronized
name|FsVolumeImpl
name|getVolume
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
block|{
specifier|final
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|r
operator|!=
literal|null
condition|?
operator|(
name|FsVolumeImpl
operator|)
name|r
operator|.
name|getVolume
argument_list|()
else|:
literal|null
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getStoredBlock (String bpid, long blkid)
specifier|public
specifier|synchronized
name|Block
name|getStoredBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blkid
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|blockfile
init|=
name|getFile
argument_list|(
name|bpid
argument_list|,
name|blkid
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockfile
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|File
name|metafile
init|=
name|FsDatasetUtil
operator|.
name|findMetaFile
argument_list|(
name|blockfile
argument_list|)
decl_stmt|;
specifier|final
name|long
name|gs
init|=
name|FsDatasetUtil
operator|.
name|parseGenerationStamp
argument_list|(
name|blockfile
argument_list|,
name|metafile
argument_list|)
decl_stmt|;
return|return
operator|new
name|Block
argument_list|(
name|blkid
argument_list|,
name|blockfile
operator|.
name|length
argument_list|()
argument_list|,
name|gs
argument_list|)
return|;
block|}
comment|/**    * Returns a clone of a replica stored in data-node memory.    * Should be primarily used for testing.    * @param blockId    * @return    */
DECL|method|fetchReplicaInfo (String bpid, long blockId)
name|ReplicaInfo
name|fetchReplicaInfo
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
return|return
literal|null
return|;
switch|switch
condition|(
name|r
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|FINALIZED
case|:
return|return
operator|new
name|FinalizedReplica
argument_list|(
operator|(
name|FinalizedReplica
operator|)
name|r
argument_list|)
return|;
case|case
name|RBW
case|:
return|return
operator|new
name|ReplicaBeingWritten
argument_list|(
operator|(
name|ReplicaBeingWritten
operator|)
name|r
argument_list|)
return|;
case|case
name|RWR
case|:
return|return
operator|new
name|ReplicaWaitingToBeRecovered
argument_list|(
operator|(
name|ReplicaWaitingToBeRecovered
operator|)
name|r
argument_list|)
return|;
case|case
name|RUR
case|:
return|return
operator|new
name|ReplicaUnderRecovery
argument_list|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|r
argument_list|)
return|;
case|case
name|TEMPORARY
case|:
return|return
operator|new
name|ReplicaInPipeline
argument_list|(
operator|(
name|ReplicaInPipeline
operator|)
name|r
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getMetaDataInputStream (ExtendedBlock b)
specifier|public
name|LengthInputStream
name|getMetaDataInputStream
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|meta
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|getBlockFile
argument_list|(
name|b
argument_list|)
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|meta
operator|==
literal|null
operator|||
operator|!
name|meta
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|isNativeIOAvailable
condition|)
block|{
return|return
operator|new
name|LengthInputStream
argument_list|(
name|NativeIO
operator|.
name|getShareDeleteFileInputStream
argument_list|(
name|meta
argument_list|)
argument_list|,
name|meta
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|new
name|LengthInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|meta
argument_list|)
argument_list|,
name|meta
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
DECL|field|datanode
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|volumes
specifier|final
name|FsVolumeList
name|volumes
decl_stmt|;
DECL|field|asyncDiskService
specifier|final
name|FsDatasetAsyncDiskService
name|asyncDiskService
decl_stmt|;
DECL|field|cacheManager
specifier|final
name|FsDatasetCache
name|cacheManager
decl_stmt|;
DECL|field|validVolsRequired
specifier|private
specifier|final
name|int
name|validVolsRequired
decl_stmt|;
comment|// TODO HDFS-2832: Consider removing duplicated block info from these
comment|//                 two maps. This might require some refactoring
comment|//                 rewrite of FsDatasetImpl.
DECL|field|volumeMap
specifier|final
name|ReplicaMap
name|volumeMap
decl_stmt|;
comment|// Map from StorageID to ReplicaMap.
DECL|field|perVolumeReplicaMap
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ReplicaMap
argument_list|>
name|perVolumeReplicaMap
decl_stmt|;
comment|// Used for synchronizing access to usage stats
DECL|field|statsLock
specifier|private
specifier|final
name|Object
name|statsLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**    * An FSDataset has a directory where it loads its data files.    */
DECL|method|FsDatasetImpl (DataNode datanode, DataStorage storage, Configuration conf )
name|FsDatasetImpl
parameter_list|(
name|DataNode
name|datanode
parameter_list|,
name|DataStorage
name|storage
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
comment|// The number of volumes required for operation is the total number
comment|// of volumes minus the number of failed volumes we can tolerate.
specifier|final
name|int
name|volFailuresTolerated
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FAILED_VOLUMES_TOLERATED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FAILED_VOLUMES_TOLERATED_DEFAULT
argument_list|)
decl_stmt|;
name|String
index|[]
name|dataDirs
init|=
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_KEY
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataLocations
init|=
name|DataNode
operator|.
name|getStorageLocations
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|int
name|volsConfigured
init|=
operator|(
name|dataDirs
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|dataDirs
operator|.
name|length
decl_stmt|;
name|int
name|volsFailed
init|=
name|volsConfigured
operator|-
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
decl_stmt|;
name|this
operator|.
name|validVolsRequired
operator|=
name|volsConfigured
operator|-
name|volFailuresTolerated
expr_stmt|;
if|if
condition|(
name|volFailuresTolerated
operator|<
literal|0
operator|||
name|volFailuresTolerated
operator|>=
name|volsConfigured
condition|)
block|{
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"Invalid volume failure "
operator|+
literal|" config value: "
operator|+
name|volFailuresTolerated
argument_list|)
throw|;
block|}
if|if
condition|(
name|volsFailed
operator|>
name|volFailuresTolerated
condition|)
block|{
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"Too many failed volumes - "
operator|+
literal|"current valid volumes: "
operator|+
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
operator|+
literal|", volumes configured: "
operator|+
name|volsConfigured
operator|+
literal|", volumes failed: "
operator|+
name|volsFailed
operator|+
literal|", volume failures tolerated: "
operator|+
name|volFailuresTolerated
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|volArray
init|=
operator|new
name|ArrayList
argument_list|<
name|FsVolumeImpl
argument_list|>
argument_list|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
comment|// TODO: getStorageTypeFromLocations() is only a temporary workaround and
comment|// should be replaced with getting storage type from DataStorage (missing
comment|// storage type now) directly.
name|Storage
operator|.
name|StorageDirectory
name|sd
init|=
name|storage
operator|.
name|getStorageDir
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
specifier|final
name|StorageType
name|storageType
init|=
name|getStorageTypeFromLocations
argument_list|(
name|dataLocations
argument_list|,
name|dir
argument_list|)
decl_stmt|;
name|volArray
operator|.
name|add
argument_list|(
operator|new
name|FsVolumeImpl
argument_list|(
name|this
argument_list|,
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|dir
argument_list|,
name|conf
argument_list|,
name|storageType
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added volume - "
operator|+
name|dir
operator|+
literal|", StorageType: "
operator|+
name|storageType
argument_list|)
expr_stmt|;
block|}
name|volumeMap
operator|=
operator|new
name|ReplicaMap
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ReplicaMap
argument_list|>
argument_list|()
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|VolumeChoosingPolicy
argument_list|<
name|FsVolumeImpl
argument_list|>
name|blockChooserImpl
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FSDATASET_VOLUME_CHOOSING_POLICY_KEY
argument_list|,
name|RoundRobinVolumeChoosingPolicy
operator|.
name|class
argument_list|,
name|VolumeChoosingPolicy
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|volumes
operator|=
operator|new
name|FsVolumeList
argument_list|(
name|volArray
argument_list|,
name|volsFailed
argument_list|,
name|blockChooserImpl
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|initializeReplicaMaps
argument_list|(
name|perVolumeReplicaMap
argument_list|,
name|volumeMap
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|File
index|[]
name|roots
init|=
operator|new
name|File
index|[
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|roots
index|[
name|idx
index|]
operator|=
name|storage
operator|.
name|getStorageDir
argument_list|(
name|idx
argument_list|)
operator|.
name|getCurrentDir
argument_list|()
expr_stmt|;
block|}
name|asyncDiskService
operator|=
operator|new
name|FsDatasetAsyncDiskService
argument_list|(
name|datanode
argument_list|,
name|roots
argument_list|)
expr_stmt|;
name|cacheManager
operator|=
operator|new
name|FsDatasetCache
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|registerMBean
argument_list|(
name|datanode
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getStorageTypeFromLocations ( Collection<StorageLocation> dataLocations, File dir)
specifier|private
name|StorageType
name|getStorageTypeFromLocations
parameter_list|(
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataLocations
parameter_list|,
name|File
name|dir
parameter_list|)
block|{
for|for
control|(
name|StorageLocation
name|dataLocation
range|:
name|dataLocations
control|)
block|{
if|if
condition|(
name|dataLocation
operator|.
name|getFile
argument_list|()
operator|.
name|equals
argument_list|(
name|dir
argument_list|)
condition|)
block|{
return|return
name|dataLocation
operator|.
name|getStorageType
argument_list|()
return|;
block|}
block|}
return|return
name|StorageType
operator|.
name|DEFAULT
return|;
block|}
comment|/**    * Return the total space used by dfs datanode    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getDfsUsed ()
specifier|public
name|long
name|getDfsUsed
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getDfsUsed
argument_list|()
return|;
block|}
block|}
comment|/**    * Return the total space used by dfs datanode    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getBlockPoolUsed (String bpid)
specifier|public
name|long
name|getBlockPoolUsed
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getBlockPoolUsed
argument_list|(
name|bpid
argument_list|)
return|;
block|}
block|}
comment|/**    * Return true - if there are still valid volumes on the DataNode.     */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|hasEnoughResource ()
specifier|public
name|boolean
name|hasEnoughResource
parameter_list|()
block|{
return|return
name|getVolumes
argument_list|()
operator|.
name|size
argument_list|()
operator|>=
name|validVolsRequired
return|;
block|}
comment|/**    * Return total capacity, used and unused    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getCapacity ()
specifier|public
name|long
name|getCapacity
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getCapacity
argument_list|()
return|;
block|}
block|}
comment|/**    * Return how many bytes can still be stored in the FSDataset    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getRemaining ()
specifier|public
name|long
name|getRemaining
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getRemaining
argument_list|()
return|;
block|}
block|}
comment|/**    * Return the number of failed volumes in the FSDataset.    */
annotation|@
name|Override
DECL|method|getNumFailedVolumes ()
specifier|public
name|int
name|getNumFailedVolumes
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|numberOfFailedVolumes
argument_list|()
return|;
block|}
comment|/**    * Returns the total cache used by the datanode (in bytes).    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getDnCacheUsed ()
specifier|public
name|long
name|getDnCacheUsed
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getDnCacheUsed
argument_list|()
return|;
block|}
comment|/**    * Returns the total cache capacity of the datanode (in bytes).    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getDnCacheCapacity ()
specifier|public
name|long
name|getDnCacheCapacity
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getDnCacheCapacity
argument_list|()
return|;
block|}
comment|/**    * Find the block's on-disk length    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getLength (ExtendedBlock b)
specifier|public
name|long
name|getLength
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockFile
argument_list|(
name|b
argument_list|)
operator|.
name|length
argument_list|()
return|;
block|}
comment|/**    * Get File name for a given block.    */
DECL|method|getBlockFile (ExtendedBlock b)
specifier|private
name|File
name|getBlockFile
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get File name for a given block.    */
DECL|method|getBlockFile (String bpid, Block b)
name|File
name|getBlockFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|f
init|=
name|validateBlockFile
argument_list|(
name|bpid
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" is not valid."
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
comment|/**    * Return the File associated with a block, without first    * checking that it exists. This should be used when the    * next operation is going to open the file for read anyway,    * and thus the exists check is redundant.    */
DECL|method|getBlockFileNoExistsCheck (ExtendedBlock b)
specifier|private
name|File
name|getBlockFileNoExistsCheck
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|f
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|f
operator|=
name|getFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" is not valid"
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getBlockInputStream (ExtendedBlock b, long seekOffset)
specifier|public
name|InputStream
name|getBlockInputStream
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|seekOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|blockFile
init|=
name|getBlockFileNoExistsCheck
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNativeIOAvailable
condition|)
block|{
return|return
name|NativeIO
operator|.
name|getShareDeleteFileInputStream
argument_list|(
name|blockFile
argument_list|,
name|seekOffset
argument_list|)
return|;
block|}
else|else
block|{
name|RandomAccessFile
name|blockInFile
decl_stmt|;
try|try
block|{
name|blockInFile
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|blockFile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" is not valid. "
operator|+
literal|"Expected block file at "
operator|+
name|blockFile
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
if|if
condition|(
name|seekOffset
operator|>
literal|0
condition|)
block|{
name|blockInFile
operator|.
name|seek
argument_list|(
name|seekOffset
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FileInputStream
argument_list|(
name|blockInFile
operator|.
name|getFD
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Get the meta info of a block stored in volumeMap. To find a block,    * block pool Id, block Id and generation stamp must match.    * @param b extended block    * @return the meta replica information; null if block was not found    * @throws ReplicaNotFoundException if no entry is in the map or     *                        there is a generation stamp mismatch    */
DECL|method|getReplicaInfo (ExtendedBlock b)
name|ReplicaInfo
name|getReplicaInfo
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|ReplicaNotFoundException
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
comment|/**    * Get the meta info of a block stored in volumeMap. Block is looked up    * without matching the generation stamp.    * @param bpid block pool Id    * @param blkid block Id    * @return the meta replica information; null if block was not found    * @throws ReplicaNotFoundException if no entry is in the map or     *                        there is a generation stamp mismatch    */
DECL|method|getReplicaInfo (String bpid, long blkid)
specifier|private
name|ReplicaInfo
name|getReplicaInfo
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blkid
parameter_list|)
throws|throws
name|ReplicaNotFoundException
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blkid
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|bpid
operator|+
literal|":"
operator|+
name|blkid
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
comment|/**    * Returns handles to the block file and its metadata file    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getTmpInputStreams (ExtendedBlock b, long blkOffset, long ckoff)
specifier|public
specifier|synchronized
name|ReplicaInputStreams
name|getTmpInputStreams
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|blkOffset
parameter_list|,
name|long
name|ckoff
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|info
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|File
name|blockFile
init|=
name|info
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
name|RandomAccessFile
name|blockInFile
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|blockFile
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|blkOffset
operator|>
literal|0
condition|)
block|{
name|blockInFile
operator|.
name|seek
argument_list|(
name|blkOffset
argument_list|)
expr_stmt|;
block|}
name|File
name|metaFile
init|=
name|info
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
name|RandomAccessFile
name|metaInFile
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|metaFile
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ckoff
operator|>
literal|0
condition|)
block|{
name|metaInFile
operator|.
name|seek
argument_list|(
name|ckoff
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ReplicaInputStreams
argument_list|(
name|blockInFile
operator|.
name|getFD
argument_list|()
argument_list|,
name|metaInFile
operator|.
name|getFD
argument_list|()
argument_list|)
return|;
block|}
DECL|method|moveBlockFiles (Block b, File srcfile, File destdir )
specifier|static
name|File
name|moveBlockFiles
parameter_list|(
name|Block
name|b
parameter_list|,
name|File
name|srcfile
parameter_list|,
name|File
name|destdir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|dstfile
init|=
operator|new
name|File
argument_list|(
name|destdir
argument_list|,
name|b
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|srcmeta
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|srcfile
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dstmeta
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|dstfile
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|srcmeta
argument_list|,
name|dstmeta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move meta file for "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|srcmeta
operator|+
literal|" to "
operator|+
name|dstmeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|srcfile
argument_list|,
name|dstfile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move block file for "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|srcfile
operator|+
literal|" to "
operator|+
name|dstfile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"addBlock: Moved "
operator|+
name|srcmeta
operator|+
literal|" to "
operator|+
name|dstmeta
operator|+
literal|" and "
operator|+
name|srcfile
operator|+
literal|" to "
operator|+
name|dstfile
argument_list|)
expr_stmt|;
block|}
return|return
name|dstfile
return|;
block|}
DECL|method|truncateBlock (File blockFile, File metaFile, long oldlen, long newlen)
specifier|static
specifier|private
name|void
name|truncateBlock
parameter_list|(
name|File
name|blockFile
parameter_list|,
name|File
name|metaFile
parameter_list|,
name|long
name|oldlen
parameter_list|,
name|long
name|newlen
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"truncateBlock: blockFile="
operator|+
name|blockFile
operator|+
literal|", metaFile="
operator|+
name|metaFile
operator|+
literal|", oldlen="
operator|+
name|oldlen
operator|+
literal|", newlen="
operator|+
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|==
name|oldlen
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|newlen
operator|>
name|oldlen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot truncate block to from oldlen (="
operator|+
name|oldlen
operator|+
literal|") to newlen (="
operator|+
name|newlen
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|DataChecksum
name|dcs
init|=
name|BlockMetadataHeader
operator|.
name|readHeader
argument_list|(
name|metaFile
argument_list|)
operator|.
name|getChecksum
argument_list|()
decl_stmt|;
name|int
name|checksumsize
init|=
name|dcs
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
name|int
name|bpc
init|=
name|dcs
operator|.
name|getBytesPerChecksum
argument_list|()
decl_stmt|;
name|long
name|n
init|=
operator|(
name|newlen
operator|-
literal|1
operator|)
operator|/
name|bpc
operator|+
literal|1
decl_stmt|;
name|long
name|newmetalen
init|=
name|BlockMetadataHeader
operator|.
name|getHeaderSize
argument_list|()
operator|+
name|n
operator|*
name|checksumsize
decl_stmt|;
name|long
name|lastchunkoffset
init|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
name|bpc
decl_stmt|;
name|int
name|lastchunksize
init|=
call|(
name|int
call|)
argument_list|(
name|newlen
operator|-
name|lastchunkoffset
argument_list|)
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|Math
operator|.
name|max
argument_list|(
name|lastchunksize
argument_list|,
name|checksumsize
argument_list|)
index|]
decl_stmt|;
name|RandomAccessFile
name|blockRAF
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|blockFile
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
try|try
block|{
comment|//truncate blockFile
name|blockRAF
operator|.
name|setLength
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
comment|//read last chunk
name|blockRAF
operator|.
name|seek
argument_list|(
name|lastchunkoffset
argument_list|)
expr_stmt|;
name|blockRAF
operator|.
name|readFully
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|lastchunksize
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|blockRAF
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|//compute checksum
name|dcs
operator|.
name|update
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|lastchunksize
argument_list|)
expr_stmt|;
name|dcs
operator|.
name|writeValue
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//update metaFile
name|RandomAccessFile
name|metaRAF
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|metaFile
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
try|try
block|{
name|metaRAF
operator|.
name|setLength
argument_list|(
name|newmetalen
argument_list|)
expr_stmt|;
name|metaRAF
operator|.
name|seek
argument_list|(
name|newmetalen
operator|-
name|checksumsize
argument_list|)
expr_stmt|;
name|metaRAF
operator|.
name|write
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|checksumsize
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|metaRAF
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|append (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
specifier|synchronized
name|ReplicaInPipeline
name|append
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If the block was successfully finalized because all packets
comment|// were successfully processed at the Datanode but the ack for
comment|// some of the packets were not received by the client. The client
comment|// re-opens the connection and retries sending those packets.
comment|// The other reason is that an "append" is occurring to this block.
comment|// check the validity of the parameter
if|if
condition|(
name|newGS
operator|<
name|b
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The new generation stamp "
operator|+
name|newGS
operator|+
literal|" should be greater than the replica "
operator|+
name|b
operator|+
literal|"'s generation stamp"
argument_list|)
throw|;
block|}
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Appending to "
operator|+
name|replicaInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|expectedBlockLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" expected length is "
operator|+
name|expectedBlockLen
argument_list|)
throw|;
block|}
return|return
name|append
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
name|FinalizedReplica
operator|)
name|replicaInfo
argument_list|,
name|newGS
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
return|;
block|}
comment|/** Append to a finalized replica    * Change a finalized replica to be a RBW replica and     * bump its generation stamp to be the newGS    *     * @param bpid block pool Id    * @param replicaInfo a finalized replica    * @param newGS new generation stamp    * @param estimateBlockLen estimate generation stamp    * @return a RBW replica    * @throws IOException if moving the replica from finalized directory     *         to rbw directory fails    */
DECL|method|append (String bpid, FinalizedReplica replicaInfo, long newGS, long estimateBlockLen)
specifier|private
specifier|synchronized
name|ReplicaBeingWritten
name|append
parameter_list|(
name|String
name|bpid
parameter_list|,
name|FinalizedReplica
name|replicaInfo
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|estimateBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
comment|// uncache the block
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
comment|// unlink the finalized replica
name|replicaInfo
operator|.
name|unlinkBlock
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// construct a RBW replica with the new GS
name|File
name|blkfile
init|=
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|replicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|getAvailable
argument_list|()
operator|<
name|estimateBlockLen
operator|-
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DiskOutOfSpaceException
argument_list|(
literal|"Insufficient space for appending to "
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|File
name|newBlkFile
init|=
operator|new
name|File
argument_list|(
name|v
operator|.
name|getRbwDir
argument_list|(
name|bpid
argument_list|)
argument_list|,
name|replicaInfo
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|oldmeta
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
name|ReplicaBeingWritten
name|newReplicaInfo
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|newGS
argument_list|,
name|v
argument_list|,
name|newBlkFile
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|newmeta
init|=
name|newReplicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
comment|// rename meta file to rbw directory
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|oldmeta
argument_list|,
name|newmeta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|replicaInfo
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move meta file  "
operator|+
name|oldmeta
operator|+
literal|" to rbw dir "
operator|+
name|newmeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// rename block file to rbw directory
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|blkfile
operator|+
literal|" to "
operator|+
name|newBlkFile
operator|+
literal|", file length="
operator|+
name|blkfile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|blkfile
argument_list|,
name|newBlkFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|newmeta
argument_list|,
name|oldmeta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot move meta file "
operator|+
name|newmeta
operator|+
literal|"back to the finalized directory "
operator|+
name|oldmeta
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|replicaInfo
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move block file "
operator|+
name|blkfile
operator|+
literal|" to rbw dir "
operator|+
name|newBlkFile
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// Replace finalized replica by a RBW replica in replicas map
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
DECL|method|recoverCheck (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|private
name|ReplicaInfo
name|recoverCheck
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
comment|// check state
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_AND_NONRBW_REPLICA
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
comment|// check generation stamp
name|long
name|replicaGenerationStamp
init|=
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaGenerationStamp
argument_list|<
name|b
operator|.
name|getGenerationStamp
operator|(
operator|)
operator|||
name|replicaGenerationStamp
argument_list|>
name|newGS
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNEXPECTED_GS_REPLICA
operator|+
name|replicaGenerationStamp
operator|+
literal|". Expected GS range is ["
operator|+
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", "
operator|+
name|newGS
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// stop the previous writer before check a replica's length
name|long
name|replicaLen
init|=
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
name|ReplicaBeingWritten
name|rbw
init|=
operator|(
name|ReplicaBeingWritten
operator|)
name|replicaInfo
decl_stmt|;
comment|// kill the previous writer
name|rbw
operator|.
name|stopWriter
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setWriter
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|// check length: bytesRcvd, bytesOnDisk, and bytesAcked should be the same
if|if
condition|(
name|replicaLen
operator|!=
name|rbw
operator|.
name|getBytesOnDisk
argument_list|()
operator|||
name|replicaLen
operator|!=
name|rbw
operator|.
name|getBytesAcked
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"RBW replica "
operator|+
name|replicaInfo
operator|+
literal|"bytesRcvd("
operator|+
name|rbw
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|"), bytesOnDisk("
operator|+
name|rbw
operator|.
name|getBytesOnDisk
argument_list|()
operator|+
literal|"), and bytesAcked("
operator|+
name|rbw
operator|.
name|getBytesAcked
argument_list|()
operator|+
literal|") are not the same."
argument_list|)
throw|;
block|}
block|}
comment|// check block length
if|if
condition|(
name|replicaLen
operator|!=
name|expectedBlockLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaLen
operator|+
literal|" expected length is "
operator|+
name|expectedBlockLen
argument_list|)
throw|;
block|}
return|return
name|replicaInfo
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|recoverAppend (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
specifier|synchronized
name|ReplicaInPipeline
name|recoverAppend
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover failed append to "
operator|+
name|b
argument_list|)
expr_stmt|;
name|ReplicaInfo
name|replicaInfo
init|=
name|recoverCheck
argument_list|(
name|b
argument_list|,
name|newGS
argument_list|,
name|expectedBlockLen
argument_list|)
decl_stmt|;
comment|// change the replica's state/gs etc.
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
return|return
name|append
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
name|FinalizedReplica
operator|)
name|replicaInfo
argument_list|,
name|newGS
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|//RBW
name|bumpReplicaGS
argument_list|(
name|replicaInfo
argument_list|,
name|newGS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ReplicaBeingWritten
operator|)
name|replicaInfo
return|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|recoverClose (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
name|Replica
name|recoverClose
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover failed close "
operator|+
name|b
argument_list|)
expr_stmt|;
comment|// check replica's state
name|ReplicaInfo
name|replicaInfo
init|=
name|recoverCheck
argument_list|(
name|b
argument_list|,
name|newGS
argument_list|,
name|expectedBlockLen
argument_list|)
decl_stmt|;
comment|// bump the replica's GS
name|bumpReplicaGS
argument_list|(
name|replicaInfo
argument_list|,
name|newGS
argument_list|)
expr_stmt|;
comment|// finalize the replica if RBW
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
name|finalizeReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|replicaInfo
return|;
block|}
comment|/**    * Bump a replica's generation stamp to a new one.    * Its on-disk meta file name is renamed to be the new one too.    *     * @param replicaInfo a replica    * @param newGS new generation stamp    * @throws IOException if rename fails    */
DECL|method|bumpReplicaGS (ReplicaInfo replicaInfo, long newGS)
specifier|private
name|void
name|bumpReplicaGS
parameter_list|(
name|ReplicaInfo
name|replicaInfo
parameter_list|,
name|long
name|newGS
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|oldGS
init|=
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
name|File
name|oldmeta
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
name|replicaInfo
operator|.
name|setGenerationStamp
argument_list|(
name|newGS
argument_list|)
expr_stmt|;
name|File
name|newmeta
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
comment|// rename meta file to new GS
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|oldmeta
argument_list|,
name|newmeta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|replicaInfo
operator|.
name|setGenerationStamp
argument_list|(
name|oldGS
argument_list|)
expr_stmt|;
comment|// restore old GS
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|replicaInfo
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move meta file  "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|createRbw (ExtendedBlock b)
specifier|public
specifier|synchronized
name|ReplicaInPipeline
name|createRbw
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" already exists in state "
operator|+
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|+
literal|" and thus cannot be created."
argument_list|)
throw|;
block|}
comment|// create a new block
name|FsVolumeImpl
name|v
init|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
decl_stmt|;
comment|// create a rbw file to hold block in the designated volume
name|File
name|f
init|=
name|v
operator|.
name|createRbwFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
name|ReplicaBeingWritten
name|newReplicaInfo
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|v
argument_list|,
name|f
operator|.
name|getParentFile
argument_list|()
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|recoverRbw (ExtendedBlock b, long newGS, long minBytesRcvd, long maxBytesRcvd)
specifier|public
specifier|synchronized
name|ReplicaInPipeline
name|recoverRbw
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|minBytesRcvd
parameter_list|,
name|long
name|maxBytesRcvd
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover RBW replica "
operator|+
name|b
argument_list|)
expr_stmt|;
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
comment|// check the replica's state
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_RBW_REPLICA
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|ReplicaBeingWritten
name|rbw
init|=
operator|(
name|ReplicaBeingWritten
operator|)
name|replicaInfo
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering "
operator|+
name|rbw
argument_list|)
expr_stmt|;
comment|// Stop the previous writer
name|rbw
operator|.
name|stopWriter
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setWriter
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|// check generation stamp
name|long
name|replicaGenerationStamp
init|=
name|rbw
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaGenerationStamp
argument_list|<
name|b
operator|.
name|getGenerationStamp
operator|(
operator|)
operator|||
name|replicaGenerationStamp
argument_list|>
name|newGS
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNEXPECTED_GS_REPLICA
operator|+
name|b
operator|+
literal|". Expected GS range is ["
operator|+
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", "
operator|+
name|newGS
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// check replica length
name|long
name|bytesAcked
init|=
name|rbw
operator|.
name|getBytesAcked
argument_list|()
decl_stmt|;
name|long
name|numBytes
init|=
name|rbw
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesAcked
argument_list|<
name|minBytesRcvd
operator|||
name|numBytes
argument_list|>
name|maxBytesRcvd
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
literal|"Unmatched length replica "
operator|+
name|replicaInfo
operator|+
literal|": BytesAcked = "
operator|+
name|bytesAcked
operator|+
literal|" BytesRcvd = "
operator|+
name|numBytes
operator|+
literal|" are not in the range of ["
operator|+
name|minBytesRcvd
operator|+
literal|", "
operator|+
name|maxBytesRcvd
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// Truncate the potentially corrupt portion.
comment|// If the source was client and the last node in the pipeline was lost,
comment|// any corrupt data written after the acked length can go unnoticed.
if|if
condition|(
name|numBytes
operator|>
name|bytesAcked
condition|)
block|{
specifier|final
name|File
name|replicafile
init|=
name|rbw
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
name|truncateBlock
argument_list|(
name|replicafile
argument_list|,
name|rbw
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|numBytes
argument_list|,
name|bytesAcked
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setNumBytes
argument_list|(
name|bytesAcked
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setLastChecksumAndDataLen
argument_list|(
name|bytesAcked
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// bump the replica's generation stamp to newGS
name|bumpReplicaGS
argument_list|(
name|rbw
argument_list|,
name|newGS
argument_list|)
expr_stmt|;
return|return
name|rbw
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|convertTemporaryToRbw ( final ExtendedBlock b)
specifier|public
specifier|synchronized
name|ReplicaInPipeline
name|convertTemporaryToRbw
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|blockId
init|=
name|b
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
specifier|final
name|long
name|expectedGs
init|=
name|b
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
specifier|final
name|long
name|visible
init|=
name|b
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Convert "
operator|+
name|b
operator|+
literal|" from Temporary to RBW, visible length="
operator|+
name|visible
argument_list|)
expr_stmt|;
specifier|final
name|ReplicaInPipeline
name|temp
decl_stmt|;
block|{
comment|// get replica
specifier|final
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
comment|// check the replica's state
if|if
condition|(
name|r
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|TEMPORARY
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"r.getState() != ReplicaState.TEMPORARY, r="
operator|+
name|r
argument_list|)
throw|;
block|}
name|temp
operator|=
operator|(
name|ReplicaInPipeline
operator|)
name|r
expr_stmt|;
block|}
comment|// check generation stamp
if|if
condition|(
name|temp
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|expectedGs
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"temp.getGenerationStamp() != expectedGs = "
operator|+
name|expectedGs
operator|+
literal|", temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// TODO: check writer?
comment|// set writer to the current thread
comment|// temp.setWriter(Thread.currentThread());
comment|// check length
specifier|final
name|long
name|numBytes
init|=
name|temp
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBytes
operator|<
name|visible
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|numBytes
operator|+
literal|" = numBytes< visible = "
operator|+
name|visible
operator|+
literal|", temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// check volume
specifier|final
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|temp
operator|.
name|getVolume
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"r.getVolume() = null, temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// move block files to the rbw directory
name|BlockPoolSlice
name|bpslice
init|=
name|v
operator|.
name|getBlockPoolSlice
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dest
init|=
name|moveBlockFiles
argument_list|(
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|temp
operator|.
name|getBlockFile
argument_list|()
argument_list|,
name|bpslice
operator|.
name|getRbwDir
argument_list|()
argument_list|)
decl_stmt|;
comment|// create RBW
specifier|final
name|ReplicaBeingWritten
name|rbw
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|blockId
argument_list|,
name|numBytes
argument_list|,
name|expectedGs
argument_list|,
name|v
argument_list|,
name|dest
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
decl_stmt|;
name|rbw
operator|.
name|setBytesAcked
argument_list|(
name|visible
argument_list|)
expr_stmt|;
comment|// overwrite the RBW in the volume map
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|rbw
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|rbw
argument_list|)
expr_stmt|;
return|return
name|rbw
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|createTemporary (ExtendedBlock b)
specifier|public
specifier|synchronized
name|ReplicaInPipeline
name|createTemporary
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" already exists in state "
operator|+
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|+
literal|" and thus cannot be created."
argument_list|)
throw|;
block|}
name|FsVolumeImpl
name|v
init|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
decl_stmt|;
comment|// create a temporary file to hold block in the designated volume
name|File
name|f
init|=
name|v
operator|.
name|createTmpFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
name|ReplicaInPipeline
name|newReplicaInfo
init|=
operator|new
name|ReplicaInPipeline
argument_list|(
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|v
argument_list|,
name|f
operator|.
name|getParentFile
argument_list|()
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
comment|/**    * Sets the offset in the meta file so that the    * last checksum will be overwritten.    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|adjustCrcChannelPosition (ExtendedBlock b, ReplicaOutputStreams streams, int checksumSize)
specifier|public
name|void
name|adjustCrcChannelPosition
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|ReplicaOutputStreams
name|streams
parameter_list|,
name|int
name|checksumSize
parameter_list|)
throws|throws
name|IOException
block|{
name|FileOutputStream
name|file
init|=
operator|(
name|FileOutputStream
operator|)
name|streams
operator|.
name|getChecksumOut
argument_list|()
decl_stmt|;
name|FileChannel
name|channel
init|=
name|file
operator|.
name|getChannel
argument_list|()
decl_stmt|;
name|long
name|oldPos
init|=
name|channel
operator|.
name|position
argument_list|()
decl_stmt|;
name|long
name|newPos
init|=
name|oldPos
operator|-
name|checksumSize
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Changing meta file offset of block "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|oldPos
operator|+
literal|" to "
operator|+
name|newPos
argument_list|)
expr_stmt|;
block|}
name|channel
operator|.
name|position
argument_list|(
name|newPos
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// REMIND - mjc - eventually we should have a timeout system
comment|// in place to clean up block files left by abandoned clients.
comment|// We should have some timer in place, so that if a blockfile
comment|// is created but non-valid, and has been idle for>48 hours,
comment|// we can GC it safely.
comment|//
comment|/**    * Complete the block write!    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|finalizeBlock (ExtendedBlock b)
specifier|public
specifier|synchronized
name|void
name|finalizeBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// Don't allow data modifications from interrupted threads
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot finalize block from Interrupted Thread"
argument_list|)
throw|;
block|}
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
comment|// this is legal, when recovery happens on a file that has
comment|// been opened for append but never modified
return|return;
block|}
name|finalizeReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|)
expr_stmt|;
block|}
DECL|method|finalizeReplica (String bpid, ReplicaInfo replicaInfo)
specifier|private
specifier|synchronized
name|FinalizedReplica
name|finalizeReplica
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaInfo
name|replicaInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|FinalizedReplica
name|newReplicaInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RUR
operator|&&
operator|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|replicaInfo
operator|)
operator|.
name|getOriginalReplica
argument_list|()
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|newReplicaInfo
operator|=
call|(
name|FinalizedReplica
call|)
argument_list|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|replicaInfo
argument_list|)
operator|.
name|getOriginalReplica
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|replicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
name|File
name|f
init|=
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No volume for temporary file "
operator|+
name|f
operator|+
literal|" for block "
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|File
name|dest
init|=
name|v
operator|.
name|addBlock
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|newReplicaInfo
operator|=
operator|new
name|FinalizedReplica
argument_list|(
name|replicaInfo
argument_list|,
name|v
argument_list|,
name|dest
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|newReplicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
comment|/**    * Remove the temporary block file (if any)    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|unfinalizeBlock (ExtendedBlock b)
specifier|public
specifier|synchronized
name|void
name|unfinalizeBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|TEMPORARY
condition|)
block|{
comment|// remove from volumeMap
name|volumeMap
operator|.
name|remove
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|remove
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
comment|// delete the on-disk temp file
if|if
condition|(
name|delBlockFromDisk
argument_list|(
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" unfinalized and removed. "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove a block from disk    * @param blockFile block file    * @param metaFile block meta file    * @param b a block    * @return true if on-disk files are deleted; false otherwise    */
DECL|method|delBlockFromDisk (File blockFile, File metaFile, Block b)
specifier|private
name|boolean
name|delBlockFromDisk
parameter_list|(
name|File
name|blockFile
parameter_list|,
name|File
name|metaFile
parameter_list|,
name|Block
name|b
parameter_list|)
block|{
if|if
condition|(
name|blockFile
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No file exists for block: "
operator|+
name|b
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|blockFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to delete the block file: "
operator|+
name|blockFile
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// remove the meta file
if|if
condition|(
name|metaFile
operator|!=
literal|null
operator|&&
operator|!
name|metaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to delete the meta block file: "
operator|+
name|metaFile
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|getBlockReportWithReplicaMap ( String bpid, ReplicaMap rMap)
specifier|private
name|BlockListAsLongs
name|getBlockReportWithReplicaMap
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaMap
name|rMap
parameter_list|)
block|{
name|int
name|size
init|=
name|rMap
operator|.
name|size
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ReplicaInfo
argument_list|>
name|finalized
init|=
operator|new
name|ArrayList
argument_list|<
name|ReplicaInfo
argument_list|>
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ReplicaInfo
argument_list|>
name|uc
init|=
operator|new
name|ArrayList
argument_list|<
name|ReplicaInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|BlockListAsLongs
argument_list|(
name|finalized
argument_list|,
name|uc
argument_list|)
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|ReplicaInfo
name|b
range|:
name|rMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
control|)
block|{
switch|switch
condition|(
name|b
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|FINALIZED
case|:
name|finalized
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|RBW
case|:
case|case
name|RWR
case|:
name|uc
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUR
case|:
name|ReplicaUnderRecovery
name|rur
init|=
operator|(
name|ReplicaUnderRecovery
operator|)
name|b
decl_stmt|;
name|uc
operator|.
name|add
argument_list|(
name|rur
operator|.
name|getOriginalReplica
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPORARY
case|:
break|break;
default|default:
assert|assert
literal|false
operator|:
literal|"Illegal ReplicaInfo state."
assert|;
block|}
block|}
return|return
operator|new
name|BlockListAsLongs
argument_list|(
name|finalized
argument_list|,
name|uc
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getCacheReport (String bpid)
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getCacheReport
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
return|return
name|cacheManager
operator|.
name|getCachedBlocks
argument_list|(
name|bpid
argument_list|)
return|;
block|}
comment|/**    * Generates a block report from the in-memory block map.    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getBlockReport (String bpid)
specifier|public
name|BlockListAsLongs
name|getBlockReport
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
return|return
name|getBlockReportWithReplicaMap
argument_list|(
name|bpid
argument_list|,
name|volumeMap
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getBlockReports (String bpid)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|BlockListAsLongs
argument_list|>
name|getBlockReports
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|BlockListAsLongs
argument_list|>
name|blockReportMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BlockListAsLongs
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FsVolumeImpl
name|v
range|:
name|getVolumes
argument_list|()
control|)
block|{
name|ReplicaMap
name|rMap
init|=
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
name|BlockListAsLongs
name|blockList
init|=
name|getBlockReportWithReplicaMap
argument_list|(
name|bpid
argument_list|,
name|rMap
argument_list|)
decl_stmt|;
name|blockReportMap
operator|.
name|put
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|blockList
argument_list|)
expr_stmt|;
block|}
return|return
name|blockReportMap
return|;
block|}
comment|/**    * Get the list of finalized blocks from in-memory blockmap for a block pool.    */
annotation|@
name|Override
DECL|method|getFinalizedBlocks (String bpid)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|FinalizedReplica
argument_list|>
name|getFinalizedBlocks
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|FinalizedReplica
argument_list|>
name|finalized
init|=
operator|new
name|ArrayList
argument_list|<
name|FinalizedReplica
argument_list|>
argument_list|(
name|volumeMap
operator|.
name|size
argument_list|(
name|bpid
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|ReplicaInfo
name|b
range|:
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
control|)
block|{
if|if
condition|(
name|b
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|finalized
operator|.
name|add
argument_list|(
operator|new
name|FinalizedReplica
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|finalized
return|;
block|}
comment|/**    * Check whether the given block is a valid one.    * valid means finalized    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|isValidBlock (ExtendedBlock b)
specifier|public
name|boolean
name|isValidBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
block|{
return|return
name|isValid
argument_list|(
name|b
argument_list|,
name|ReplicaState
operator|.
name|FINALIZED
argument_list|)
return|;
block|}
comment|/**    * Check whether the given block is a valid RBW.    */
annotation|@
name|Override
comment|// {@link FsDatasetSpi}
DECL|method|isValidRbw (final ExtendedBlock b)
specifier|public
name|boolean
name|isValidRbw
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
block|{
return|return
name|isValid
argument_list|(
name|b
argument_list|,
name|ReplicaState
operator|.
name|RBW
argument_list|)
return|;
block|}
comment|/** Does the block exist and have the given state? */
DECL|method|isValid (final ExtendedBlock b, final ReplicaState state)
specifier|private
name|boolean
name|isValid
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|,
specifier|final
name|ReplicaState
name|state
parameter_list|)
block|{
specifier|final
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|replicaInfo
operator|!=
literal|null
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|state
operator|&&
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
operator|.
name|exists
argument_list|()
return|;
block|}
comment|/**    * Find the file corresponding to the block and return it if it exists.    */
DECL|method|validateBlockFile (String bpid, Block b)
name|File
name|validateBlockFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|b
parameter_list|)
block|{
comment|//Should we check for metadata file too?
specifier|final
name|File
name|f
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|f
operator|=
name|getFile
argument_list|(
name|bpid
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
return|return
name|f
return|;
comment|// if file is not null, but doesn't exist - possibly disk failed
name|datanode
operator|.
name|checkDiskError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"b="
operator|+
name|b
operator|+
literal|", f="
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Check the files of a replica. */
DECL|method|checkReplicaFiles (final ReplicaInfo r)
specifier|static
name|void
name|checkReplicaFiles
parameter_list|(
specifier|final
name|ReplicaInfo
name|r
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check replica's file
specifier|final
name|File
name|f
init|=
name|r
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File "
operator|+
name|f
operator|+
literal|" not found, r="
operator|+
name|r
argument_list|)
throw|;
block|}
if|if
condition|(
name|r
operator|.
name|getBytesOnDisk
argument_list|()
operator|!=
name|f
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File length mismatched.  The length of "
operator|+
name|f
operator|+
literal|" is "
operator|+
name|f
operator|.
name|length
argument_list|()
operator|+
literal|" but r="
operator|+
name|r
argument_list|)
throw|;
block|}
comment|//check replica's meta file
specifier|final
name|File
name|metafile
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|f
argument_list|,
name|r
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|metafile
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Metafile "
operator|+
name|metafile
operator|+
literal|" does not exist, r="
operator|+
name|r
argument_list|)
throw|;
block|}
if|if
condition|(
name|metafile
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Metafile "
operator|+
name|metafile
operator|+
literal|" is empty, r="
operator|+
name|r
argument_list|)
throw|;
block|}
block|}
comment|/**    * We're informed that a block is no longer valid.  We    * could lazily garbage-collect the block, but why bother?    * just get rid of it.    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|invalidate (String bpid, Block invalidBlks[])
specifier|public
name|void
name|invalidate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|invalidBlks
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|error
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|invalidBlks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|File
name|f
decl_stmt|;
specifier|final
name|FsVolumeImpl
name|v
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|f
operator|=
name|getFile
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|": ReplicaInfo not found."
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|": GenerationStamp not matched, info="
operator|+
name|info
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|v
operator|=
operator|(
name|FsVolumeImpl
operator|)
name|info
operator|.
name|getVolume
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|": File not found, volume="
operator|+
name|v
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". No volume for this replica, file="
operator|+
name|f
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|File
name|parent
init|=
name|f
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". Parent not found for file "
operator|+
name|f
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|error
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|ReplicaState
name|replicaState
init|=
name|info
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|||
operator|(
name|replicaState
operator|==
name|ReplicaState
operator|.
name|RUR
operator|&&
operator|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|info
operator|)
operator|.
name|getOriginalReplica
argument_list|()
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|)
condition|)
block|{
name|v
operator|.
name|clearPath
argument_list|(
name|bpid
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|volumeMap
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Uncache the block synchronously
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Delete the block asynchronously to make sure we can do it fast enough
name|asyncDiskService
operator|.
name|deleteAsync
argument_list|(
name|v
argument_list|,
name|f
argument_list|,
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|f
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
argument_list|,
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error in deleting blocks."
argument_list|)
throw|;
block|}
block|}
DECL|method|validToCache (String bpid, long blockId)
specifier|synchronized
name|boolean
name|validToCache
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache replica in block pool "
operator|+
name|bpid
operator|+
literal|" with block id "
operator|+
name|blockId
operator|+
literal|": ReplicaInfo not found."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|FsVolumeImpl
name|volume
init|=
operator|(
name|FsVolumeImpl
operator|)
name|info
operator|.
name|getVolume
argument_list|()
decl_stmt|;
if|if
condition|(
name|volume
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache block with id "
operator|+
name|blockId
operator|+
literal|": Volume not found."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to block with id "
operator|+
name|blockId
operator|+
literal|": Replica is not finalized."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Asynchronously attempts to cache a single block via {@link FsDatasetCache}.    */
DECL|method|cacheBlock (String bpid, long blockId)
specifier|private
name|void
name|cacheBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|ReplicaInfo
name|info
decl_stmt|;
name|FsVolumeImpl
name|volume
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|validToCache
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
condition|)
block|{
return|return;
block|}
name|info
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
name|volume
operator|=
operator|(
name|FsVolumeImpl
operator|)
name|info
operator|.
name|getVolume
argument_list|()
expr_stmt|;
block|}
comment|// Try to open block and meta streams
name|FileInputStream
name|blockIn
init|=
literal|null
decl_stmt|;
name|FileInputStream
name|metaIn
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|ExtendedBlock
name|extBlk
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|,
name|info
operator|.
name|getBytesOnDisk
argument_list|()
argument_list|,
name|info
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|blockIn
operator|=
operator|(
name|FileInputStream
operator|)
name|getBlockInputStream
argument_list|(
name|extBlk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|metaIn
operator|=
operator|(
name|FileInputStream
operator|)
name|getMetaDataInputStream
argument_list|(
name|extBlk
argument_list|)
operator|.
name|getWrappedStream
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache replica "
operator|+
name|extBlk
operator|+
literal|": Underlying blocks"
operator|+
literal|" are not backed by files."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache replica "
operator|+
name|extBlk
operator|+
literal|": IOException while"
operator|+
literal|" trying to open block or meta files."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|blockIn
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|metaIn
argument_list|)
expr_stmt|;
return|return;
block|}
name|cacheManager
operator|.
name|cacheBlock
argument_list|(
name|bpid
argument_list|,
name|extBlk
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|volume
argument_list|,
name|blockIn
argument_list|,
name|metaIn
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|cache (String bpid, long[] blockIds)
specifier|public
name|void
name|cache
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
index|[]
name|blockIds
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockIds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cacheBlock
argument_list|(
name|bpid
argument_list|,
name|blockIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|uncache (String bpid, long[] blockIds)
specifier|public
name|void
name|uncache
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
index|[]
name|blockIds
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockIds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|blockIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|contains (final ExtendedBlock block)
specifier|public
specifier|synchronized
name|boolean
name|contains
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
block|{
specifier|final
name|long
name|blockId
init|=
name|block
operator|.
name|getLocalBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
return|return
name|getFile
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blockId
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Turn the block identifier into a filename    * @param bpid Block pool Id    * @param blockId a block's id    * @return on disk data file path; null if the replica does not exist    */
DECL|method|getFile (final String bpid, final long blockId)
name|File
name|getFile
parameter_list|(
specifier|final
name|String
name|bpid
parameter_list|,
specifier|final
name|long
name|blockId
parameter_list|)
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
return|return
name|info
operator|.
name|getBlockFile
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * check if a data directory is healthy    * if some volumes failed - make sure to remove all the blocks that belong    * to these volumes    * @throws DiskErrorException    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|checkDataDir ()
specifier|public
name|void
name|checkDataDir
parameter_list|()
throws|throws
name|DiskErrorException
block|{
name|long
name|totalBlocks
init|=
literal|0
decl_stmt|,
name|removedBlocks
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|failedVols
init|=
name|volumes
operator|.
name|checkDirs
argument_list|()
decl_stmt|;
comment|// If there no failed volumes return
if|if
condition|(
name|failedVols
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// Otherwise remove blocks for the failed volumes
name|long
name|mlsec
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|FsVolumeImpl
name|fv
range|:
name|failedVols
control|)
block|{
for|for
control|(
name|String
name|bpid
range|:
name|fv
operator|.
name|getBlockPoolList
argument_list|()
control|)
block|{
name|Iterator
argument_list|<
name|ReplicaInfo
argument_list|>
name|ib
init|=
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|ib
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ReplicaInfo
name|b
init|=
name|ib
operator|.
name|next
argument_list|()
decl_stmt|;
name|totalBlocks
operator|++
expr_stmt|;
comment|// check if the volume block belongs to still valid
if|if
condition|(
name|b
operator|.
name|getVolume
argument_list|()
operator|==
name|fv
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removing replica "
operator|+
name|bpid
operator|+
literal|":"
operator|+
name|b
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" on failed volume "
operator|+
name|fv
operator|.
name|getCurrentDir
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|ib
operator|.
name|remove
argument_list|()
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|fv
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
name|removedBlocks
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// end of sync
name|mlsec
operator|=
name|Time
operator|.
name|now
argument_list|()
operator|-
name|mlsec
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removed "
operator|+
name|removedBlocks
operator|+
literal|" out of "
operator|+
name|totalBlocks
operator|+
literal|"(took "
operator|+
name|mlsec
operator|+
literal|" millisecs)"
argument_list|)
expr_stmt|;
comment|// report the error
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|FsVolumeImpl
name|fv
range|:
name|failedVols
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|fv
operator|.
name|getCurrentDir
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"DataNode failed volumes:"
operator|+
name|sb
argument_list|)
throw|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSDataset{dirpath='"
operator|+
name|volumes
operator|+
literal|"'}"
return|;
block|}
DECL|field|mbeanName
specifier|private
name|ObjectName
name|mbeanName
decl_stmt|;
comment|/**    * Register the FSDataset MBean using the name    *        "hadoop:service=DataNode,name=FSDatasetState-<datanodeUuid>"    */
DECL|method|registerMBean (final String datanodeUuid)
name|void
name|registerMBean
parameter_list|(
specifier|final
name|String
name|datanodeUuid
parameter_list|)
block|{
comment|// We wrap to bypass standard mbean naming convetion.
comment|// This wraping can be removed in java 6 as it is more flexible in
comment|// package naming for mbeans and their impl.
try|try
block|{
name|StandardMBean
name|bean
init|=
operator|new
name|StandardMBean
argument_list|(
name|this
argument_list|,
name|FSDatasetMBean
operator|.
name|class
argument_list|)
decl_stmt|;
name|mbeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"DataNode"
argument_list|,
literal|"FSDatasetState-"
operator|+
name|datanodeUuid
argument_list|,
name|bean
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotCompliantMBeanException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error registering FSDatasetState MBean"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered FSDatasetState MBean"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|mbeanName
operator|!=
literal|null
condition|)
name|MBeans
operator|.
name|unregister
argument_list|(
name|mbeanName
argument_list|)
expr_stmt|;
if|if
condition|(
name|asyncDiskService
operator|!=
literal|null
condition|)
block|{
name|asyncDiskService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|volumes
operator|!=
literal|null
condition|)
block|{
name|volumes
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getStorageInfo ()
specifier|public
name|String
name|getStorageInfo
parameter_list|()
block|{
return|return
name|toString
argument_list|()
return|;
block|}
comment|/**    * Reconcile the difference between blocks on the disk and blocks in    * volumeMap    *    * Check the given block for inconsistencies. Look at the    * current state of the block and reconcile the differences as follows:    *<ul>    *<li>If the block file is missing, delete the block from volumeMap</li>    *<li>If the block file exists and the block is missing in volumeMap,    * add the block to volumeMap<li>    *<li>If generation stamp does not match, then update the block with right    * generation stamp</li>    *<li>If the block length in memory does not match the actual block file length    * then mark the block as corrupt and update the block length in memory</li>    *<li>If the file in {@link ReplicaInfo} does not match the file on    * the disk, update {@link ReplicaInfo} with the correct file</li>    *</ul>    *    * @param blockId Block that differs    * @param diskFile Block file on the disk    * @param diskMetaFile Metadata file from on the disk    * @param vol Volume of the block file    */
annotation|@
name|Override
DECL|method|checkAndUpdate (String bpid, long blockId, File diskFile, File diskMetaFile, FsVolumeSpi vol)
specifier|public
name|void
name|checkAndUpdate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|,
name|File
name|diskFile
parameter_list|,
name|File
name|diskMetaFile
parameter_list|,
name|FsVolumeSpi
name|vol
parameter_list|)
block|{
name|Block
name|corruptBlock
init|=
literal|null
decl_stmt|;
name|ReplicaInfo
name|memBlockInfo
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|memBlockInfo
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
if|if
condition|(
name|memBlockInfo
operator|!=
literal|null
operator|&&
name|memBlockInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
comment|// Block is not finalized - ignore the difference
return|return;
block|}
specifier|final
name|long
name|diskGS
init|=
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
condition|?
name|Block
operator|.
name|getGenerationStamp
argument_list|(
name|diskMetaFile
operator|.
name|getName
argument_list|()
argument_list|)
else|:
name|GenerationStamp
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
if|if
condition|(
name|diskFile
operator|==
literal|null
operator|||
operator|!
name|diskFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memBlockInfo
operator|==
literal|null
condition|)
block|{
comment|// Block file does not exist and block does not exist in memory
comment|// If metadata file exists then delete it
if|if
condition|(
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deleted a metadata file without a block "
operator|+
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|memBlockInfo
operator|.
name|getBlockFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// Block is in memory and not on the disk
comment|// Remove the block from volumeMap
name|volumeMap
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|vol
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
specifier|final
name|DataBlockScanner
name|blockScanner
init|=
name|datanode
operator|.
name|getBlockScanner
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|deleteBlock
argument_list|(
name|bpid
argument_list|,
operator|new
name|Block
argument_list|(
name|blockId
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removed block "
operator|+
name|blockId
operator|+
literal|" from memory with missing block file on the disk"
argument_list|)
expr_stmt|;
comment|// Finally remove the metadata file
if|if
condition|(
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deleted a metadata file for the deleted block "
operator|+
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/*        * Block file exists on the disk        */
if|if
condition|(
name|memBlockInfo
operator|==
literal|null
condition|)
block|{
comment|// Block is missing in memory - add the block to volumeMap
name|ReplicaInfo
name|diskBlockInfo
init|=
operator|new
name|FinalizedReplica
argument_list|(
name|blockId
argument_list|,
name|diskFile
operator|.
name|length
argument_list|()
argument_list|,
name|diskGS
argument_list|,
name|vol
argument_list|,
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|diskBlockInfo
argument_list|)
expr_stmt|;
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|vol
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|diskBlockInfo
argument_list|)
expr_stmt|;
specifier|final
name|DataBlockScanner
name|blockScanner
init|=
name|datanode
operator|.
name|getBlockScanner
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|addBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|diskBlockInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Added missing block to memory "
operator|+
name|diskBlockInfo
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*        * Block exists in volumeMap and the block file exists on the disk        */
comment|// Compare block files
name|File
name|memFile
init|=
name|memBlockInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|memFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memFile
operator|.
name|compareTo
argument_list|(
name|diskFile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block file "
operator|+
name|memFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" does not match file found by scan "
operator|+
name|diskFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Should the diskFile be deleted?
block|}
block|}
else|else
block|{
comment|// Block refers to a block file that does not exist.
comment|// Update the block with the file found on the disk. Since the block
comment|// file and metadata file are found as a pair on the disk, update
comment|// the block based on the metadata file found on the disk
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block file in volumeMap "
operator|+
name|memFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" does not exist. Updating it to the file found during scan "
operator|+
name|diskFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setDir
argument_list|(
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
name|memFile
operator|=
name|diskFile
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating generation stamp for block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|" to "
operator|+
name|diskGS
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setGenerationStamp
argument_list|(
name|diskGS
argument_list|)
expr_stmt|;
block|}
comment|// Compare generation stamp
if|if
condition|(
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|diskGS
condition|)
block|{
name|File
name|memMetaFile
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|diskFile
argument_list|,
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|memMetaFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memMetaFile
operator|.
name|compareTo
argument_list|(
name|diskMetaFile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Metadata file in memory "
operator|+
name|memMetaFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" does not match file found by scan "
operator|+
operator|(
name|diskMetaFile
operator|==
literal|null
condition|?
literal|null
else|:
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Metadata file corresponding to block in memory is missing
comment|// If metadata file found during the scan is on the same directory
comment|// as the block file, then use the generation stamp from it
name|long
name|gs
init|=
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|getParent
argument_list|()
operator|.
name|equals
argument_list|(
name|memFile
operator|.
name|getParent
argument_list|()
argument_list|)
condition|?
name|diskGS
else|:
name|GenerationStamp
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating generation stamp for block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|" to "
operator|+
name|gs
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setGenerationStamp
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Compare block size
if|if
condition|(
name|memBlockInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|memFile
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// Update the length based on the block file
name|corruptBlock
operator|=
operator|new
name|Block
argument_list|(
name|memBlockInfo
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating size of block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" to "
operator|+
name|memFile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setNumBytes
argument_list|(
name|memFile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Send corrupt block report outside the lock
if|if
condition|(
name|corruptBlock
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reporting the block "
operator|+
name|corruptBlock
operator|+
literal|" as corrupt due to length mismatch"
argument_list|)
expr_stmt|;
try|try
block|{
name|datanode
operator|.
name|reportBadBlocks
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|corruptBlock
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to repot bad block "
operator|+
name|corruptBlock
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @deprecated use {@link #fetchReplicaInfo(String, long)} instead.    */
annotation|@
name|Override
comment|// FsDatasetSpi
annotation|@
name|Deprecated
DECL|method|getReplica (String bpid, long blockId)
specifier|public
name|ReplicaInfo
name|getReplica
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
return|return
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getReplicaString (String bpid, long blockId)
specifier|public
specifier|synchronized
name|String
name|getReplicaString
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
specifier|final
name|Replica
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
return|return
name|r
operator|==
literal|null
condition|?
literal|"null"
else|:
name|r
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|initReplicaRecovery ( RecoveringBlock rBlock)
specifier|public
specifier|synchronized
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|initReplicaRecovery
argument_list|(
name|rBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|volumeMap
argument_list|,
name|rBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
argument_list|,
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
return|;
block|}
comment|/** static version of {@link #initReplicaRecovery(Block, long)}. */
DECL|method|initReplicaRecovery (String bpid, ReplicaMap map, Block block, long recoveryId, long xceiverStopTimeout)
specifier|static
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaMap
name|map
parameter_list|,
name|Block
name|block
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|xceiverStopTimeout
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ReplicaInfo
name|replica
init|=
name|map
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: "
operator|+
name|block
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
expr_stmt|;
comment|//check replica
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//stop writer if there is any
if|if
condition|(
name|replica
operator|instanceof
name|ReplicaInPipeline
condition|)
block|{
specifier|final
name|ReplicaInPipeline
name|rip
init|=
operator|(
name|ReplicaInPipeline
operator|)
name|replica
decl_stmt|;
name|rip
operator|.
name|stopWriter
argument_list|(
name|xceiverStopTimeout
argument_list|)
expr_stmt|;
comment|//check replica bytes on disk.
if|if
condition|(
name|rip
operator|.
name|getBytesOnDisk
argument_list|()
operator|<
name|rip
operator|.
name|getVisibleLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" getBytesOnDisk()< getVisibleLength(), rip="
operator|+
name|rip
argument_list|)
throw|;
block|}
comment|//check the replica's files
name|checkReplicaFiles
argument_list|(
name|rip
argument_list|)
expr_stmt|;
block|}
comment|//check generation stamp
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getGenerationStamp()< block.getGenerationStamp(), block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check recovery id
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|>=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" replica.getGenerationStamp()>= recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check RUR
specifier|final
name|ReplicaUnderRecovery
name|rur
decl_stmt|;
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RUR
condition|)
block|{
name|rur
operator|=
operator|(
name|ReplicaUnderRecovery
operator|)
name|replica
expr_stmt|;
if|if
condition|(
name|rur
operator|.
name|getRecoveryID
argument_list|()
operator|>=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
literal|"rur.getRecoveryID()>= recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", block="
operator|+
name|block
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
specifier|final
name|long
name|oldRecoveryID
init|=
name|rur
operator|.
name|getRecoveryID
argument_list|()
decl_stmt|;
name|rur
operator|.
name|setRecoveryID
argument_list|(
name|recoveryId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: update recovery id for "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|oldRecoveryID
operator|+
literal|" to "
operator|+
name|recoveryId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rur
operator|=
operator|new
name|ReplicaUnderRecovery
argument_list|(
name|replica
argument_list|,
name|recoveryId
argument_list|)
expr_stmt|;
name|map
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|rur
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: changing replica state for "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|replica
operator|.
name|getState
argument_list|()
operator|+
literal|" to "
operator|+
name|rur
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rur
operator|.
name|createInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|updateReplicaUnderRecovery ( final ExtendedBlock oldBlock, final long recoveryId, final long newlength)
specifier|public
specifier|synchronized
name|String
name|updateReplicaUnderRecovery
parameter_list|(
specifier|final
name|ExtendedBlock
name|oldBlock
parameter_list|,
specifier|final
name|long
name|recoveryId
parameter_list|,
specifier|final
name|long
name|newlength
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get replica
specifier|final
name|String
name|bpid
init|=
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
specifier|final
name|ReplicaInfo
name|replica
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|oldBlock
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"updateReplica: "
operator|+
name|oldBlock
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", length="
operator|+
name|newlength
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
expr_stmt|;
comment|//check replica
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|oldBlock
argument_list|)
throw|;
block|}
comment|//check replica state
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RUR
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getState() != "
operator|+
name|ReplicaState
operator|.
name|RUR
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check replica's byte on disk
if|if
condition|(
name|replica
operator|.
name|getBytesOnDisk
argument_list|()
operator|!=
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" replica.getBytesOnDisk() != block.getNumBytes(), block="
operator|+
name|oldBlock
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check replica files before update
name|checkReplicaFiles
argument_list|(
name|replica
argument_list|)
expr_stmt|;
comment|//update replica
specifier|final
name|FinalizedReplica
name|finalized
init|=
name|updateReplicaUnderRecovery
argument_list|(
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
name|ReplicaUnderRecovery
operator|)
name|replica
argument_list|,
name|recoveryId
argument_list|,
name|newlength
argument_list|)
decl_stmt|;
assert|assert
name|finalized
operator|.
name|getBlockId
argument_list|()
operator|==
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|&&
name|finalized
operator|.
name|getGenerationStamp
argument_list|()
operator|==
name|recoveryId
operator|&&
name|finalized
operator|.
name|getNumBytes
argument_list|()
operator|==
name|newlength
operator|:
literal|"Replica information mismatched: oldBlock="
operator|+
name|oldBlock
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", newlength="
operator|+
name|newlength
operator|+
literal|", finalized="
operator|+
name|finalized
assert|;
comment|//check replica files after update
name|checkReplicaFiles
argument_list|(
name|finalized
argument_list|)
expr_stmt|;
comment|//return storage ID
return|return
name|getVolume
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|finalized
argument_list|)
argument_list|)
operator|.
name|getStorageID
argument_list|()
return|;
block|}
DECL|method|updateReplicaUnderRecovery ( String bpid, ReplicaUnderRecovery rur, long recoveryId, long newlength)
specifier|private
name|FinalizedReplica
name|updateReplicaUnderRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaUnderRecovery
name|rur
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|newlength
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check recovery id
if|if
condition|(
name|rur
operator|.
name|getRecoveryID
argument_list|()
operator|!=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rur.getRecoveryID() != recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
comment|// bump rur's GS to be recovery id
name|bumpReplicaGS
argument_list|(
name|rur
argument_list|,
name|recoveryId
argument_list|)
expr_stmt|;
comment|//update length
specifier|final
name|File
name|replicafile
init|=
name|rur
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|rur
operator|.
name|getNumBytes
argument_list|()
operator|<
name|newlength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rur.getNumBytes()< newlength = "
operator|+
name|newlength
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
if|if
condition|(
name|rur
operator|.
name|getNumBytes
argument_list|()
operator|>
name|newlength
condition|)
block|{
name|rur
operator|.
name|unlinkBlock
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|truncateBlock
argument_list|(
name|replicafile
argument_list|,
name|rur
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|rur
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|newlength
argument_list|)
expr_stmt|;
comment|// update RUR with the new length
name|rur
operator|.
name|setNumBytes
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
block|}
comment|// finalize the block
return|return
name|finalizeReplica
argument_list|(
name|bpid
argument_list|,
name|rur
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getReplicaVisibleLength (final ExtendedBlock block)
specifier|public
specifier|synchronized
name|long
name|getReplicaVisibleLength
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Replica
name|replica
init|=
name|getReplicaInfo
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getGenerationStamp()< block.getGenerationStamp(), block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
return|return
name|replica
operator|.
name|getVisibleLength
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|addBlockPool (String bpid, Configuration conf)
specifier|public
specifier|synchronized
name|void
name|addBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding block pool "
operator|+
name|bpid
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|addBlockPool
argument_list|(
name|bpid
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|volumeMap
operator|.
name|initBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|getAllVolumesMap
argument_list|(
name|bpid
argument_list|,
name|volumeMap
argument_list|)
expr_stmt|;
comment|// TODO: Avoid the double scan.
for|for
control|(
name|FsVolumeImpl
name|v
range|:
name|getVolumes
argument_list|()
control|)
block|{
name|ReplicaMap
name|rMap
init|=
name|perVolumeReplicaMap
operator|.
name|get
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
name|rMap
operator|.
name|initBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|getVolumeMap
argument_list|(
name|bpid
argument_list|,
name|v
argument_list|,
name|rMap
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|shutdownBlockPool (String bpid)
specifier|public
specifier|synchronized
name|void
name|shutdownBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing block pool "
operator|+
name|bpid
argument_list|)
expr_stmt|;
name|volumeMap
operator|.
name|cleanUpBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|removeBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
comment|/**    * Class for representing the Datanode volume information    */
DECL|class|VolumeInfo
specifier|private
specifier|static
class|class
name|VolumeInfo
block|{
DECL|field|directory
specifier|final
name|String
name|directory
decl_stmt|;
DECL|field|usedSpace
specifier|final
name|long
name|usedSpace
decl_stmt|;
DECL|field|freeSpace
specifier|final
name|long
name|freeSpace
decl_stmt|;
DECL|field|reservedSpace
specifier|final
name|long
name|reservedSpace
decl_stmt|;
DECL|method|VolumeInfo (FsVolumeImpl v, long usedSpace, long freeSpace)
name|VolumeInfo
parameter_list|(
name|FsVolumeImpl
name|v
parameter_list|,
name|long
name|usedSpace
parameter_list|,
name|long
name|freeSpace
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|v
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|usedSpace
operator|=
name|usedSpace
expr_stmt|;
name|this
operator|.
name|freeSpace
operator|=
name|freeSpace
expr_stmt|;
name|this
operator|.
name|reservedSpace
operator|=
name|v
operator|.
name|getReserved
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getVolumeInfo ()
specifier|private
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|getVolumeInfo
parameter_list|()
block|{
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|info
init|=
operator|new
name|ArrayList
argument_list|<
name|VolumeInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|volumes
operator|.
name|volumes
control|)
block|{
name|long
name|used
init|=
literal|0
decl_stmt|;
name|long
name|free
init|=
literal|0
decl_stmt|;
try|try
block|{
name|used
operator|=
name|volume
operator|.
name|getDfsUsed
argument_list|()
expr_stmt|;
name|free
operator|=
name|volume
operator|.
name|getAvailable
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|free
operator|=
literal|0
expr_stmt|;
block|}
name|info
operator|.
name|add
argument_list|(
operator|new
name|VolumeInfo
argument_list|(
name|volume
argument_list|,
name|used
argument_list|,
name|free
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
annotation|@
name|Override
DECL|method|getVolumeInfoMap ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getVolumeInfoMap
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|volumes
init|=
name|getVolumeInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|VolumeInfo
name|v
range|:
name|volumes
control|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"usedSpace"
argument_list|,
name|v
operator|.
name|usedSpace
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"freeSpace"
argument_list|,
name|v
operator|.
name|freeSpace
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"reservedSpace"
argument_list|,
name|v
operator|.
name|reservedSpace
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
name|v
operator|.
name|directory
argument_list|,
name|innerInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
annotation|@
name|Override
comment|//FsDatasetSpi
DECL|method|deleteBlockPool (String bpid, boolean force)
specifier|public
specifier|synchronized
name|void
name|deleteBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|volumes
operator|.
name|volumes
control|)
block|{
if|if
condition|(
operator|!
name|volume
operator|.
name|isBPDirEmpty
argument_list|(
name|bpid
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|bpid
operator|+
literal|" has some block files, cannot delete unless forced"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot delete block pool, "
operator|+
literal|"it contains some block files"
argument_list|)
throw|;
block|}
block|}
block|}
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|volumes
operator|.
name|volumes
control|)
block|{
name|volume
operator|.
name|deleteBPDirectories
argument_list|(
name|bpid
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getBlockLocalPathInfo (ExtendedBlock block)
specifier|public
name|BlockLocalPathInfo
name|getBlockLocalPathInfo
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|datafile
init|=
name|getBlockFile
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|File
name|metafile
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|datafile
argument_list|,
name|block
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
name|BlockLocalPathInfo
name|info
init|=
operator|new
name|BlockLocalPathInfo
argument_list|(
name|block
argument_list|,
name|datafile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|metafile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|info
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getHdfsBlocksMetadata (List<ExtendedBlock> blocks)
specifier|public
name|HdfsBlocksMetadata
name|getHdfsBlocksMetadata
parameter_list|(
name|List
argument_list|<
name|ExtendedBlock
argument_list|>
name|blocks
parameter_list|)
throws|throws
name|IOException
block|{
comment|// List of VolumeIds, one per volume on the datanode
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|blocksVolumeIds
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|volumes
operator|.
name|volumes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// List of indexes into the list of VolumeIds, pointing at the VolumeId of
comment|// the volume that the block is on
name|List
argument_list|<
name|Integer
argument_list|>
name|blocksVolumeIndexes
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|blocks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Initialize the list of VolumeIds simply by enumerating the volumes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|volumes
operator|.
name|volumes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|blocksVolumeIds
operator|.
name|add
argument_list|(
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
operator|.
name|putInt
argument_list|(
name|i
argument_list|)
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Determine the index of the VolumeId of each block's volume, by comparing
comment|// the block's volume against the enumerated volumes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExtendedBlock
name|block
init|=
name|blocks
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|FsVolumeSpi
name|blockVolume
init|=
name|getReplicaInfo
argument_list|(
name|block
argument_list|)
operator|.
name|getVolume
argument_list|()
decl_stmt|;
name|boolean
name|isValid
init|=
literal|false
decl_stmt|;
name|int
name|volumeIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|volumes
operator|.
name|volumes
control|)
block|{
comment|// This comparison of references should be safe
if|if
condition|(
name|blockVolume
operator|==
name|volume
condition|)
block|{
name|isValid
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|volumeIndex
operator|++
expr_stmt|;
block|}
comment|// Indicates that the block is not present, or not found in a data dir
if|if
condition|(
operator|!
name|isValid
condition|)
block|{
name|volumeIndex
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|blocksVolumeIndexes
operator|.
name|add
argument_list|(
name|volumeIndex
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|HdfsBlocksMetadata
argument_list|(
name|blocks
operator|.
name|toArray
argument_list|(
operator|new
name|ExtendedBlock
index|[]
block|{}
argument_list|)
argument_list|,
name|blocksVolumeIds
argument_list|,
name|blocksVolumeIndexes
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|createRollingLogs (String bpid, String prefix )
specifier|public
name|RollingLogs
name|createRollingLogs
parameter_list|(
name|String
name|bpid
parameter_list|,
name|String
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|dir
init|=
literal|null
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|volumes
init|=
name|getVolumes
argument_list|()
decl_stmt|;
for|for
control|(
name|FsVolumeImpl
name|vol
range|:
name|volumes
control|)
block|{
name|String
name|bpDir
init|=
name|vol
operator|.
name|getPath
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|RollingLogsImpl
operator|.
name|isFilePresent
argument_list|(
name|bpDir
argument_list|,
name|prefix
argument_list|)
condition|)
block|{
name|dir
operator|=
name|bpDir
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dir
operator|==
literal|null
condition|)
block|{
name|dir
operator|=
name|volumes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getPath
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RollingLogsImpl
argument_list|(
name|dir
argument_list|,
name|prefix
argument_list|)
return|;
block|}
block|}
end_class

end_unit

