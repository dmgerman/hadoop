begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode.fsdataset.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|NotCompliantMBeanException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|StandardMBean
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|ExtendedBlockId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|AutoCloseableLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockLocalPathInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|BlockMetadataHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|metrics
operator|.
name|DataNodeMetricHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DatanodeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|Replica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaInPipeline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|StorageLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|UnexpectedReplicaStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsDatasetSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|LengthInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaInputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaOutputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|RoundRobinVolumeChoosingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|VolumeChoosingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|impl
operator|.
name|RamDiskReplicaTracker
operator|.
name|RamDiskReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|metrics
operator|.
name|FSDatasetMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReplicaRecoveryInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|VolumeFailureSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MultipleIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskErrorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskOutOfSpaceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|InstrumentedLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_comment
comment|/**************************************************  * FSDataset manages a set of data blocks.  Each block  * has a unique name and an extent on disk.  *  ***************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|FsDatasetImpl
class|class
name|FsDatasetImpl
implements|implements
name|FsDatasetSpi
argument_list|<
name|FsVolumeImpl
argument_list|>
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FsDatasetImpl
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|isNativeIOAvailable
specifier|private
specifier|final
specifier|static
name|boolean
name|isNativeIOAvailable
decl_stmt|;
DECL|field|timer
specifier|private
name|Timer
name|timer
decl_stmt|;
static|static
block|{
name|isNativeIOAvailable
operator|=
name|NativeIO
operator|.
name|isAvailable
argument_list|()
expr_stmt|;
if|if
condition|(
name|Path
operator|.
name|WINDOWS
operator|&&
operator|!
name|isNativeIOAvailable
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Data node cannot fully support concurrent reading"
operator|+
literal|" and writing without native code extensions on Windows."
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getFsVolumeReferences ()
specifier|public
name|FsVolumeReferences
name|getFsVolumeReferences
parameter_list|()
block|{
return|return
operator|new
name|FsVolumeReferences
argument_list|(
name|volumes
operator|.
name|getVolumes
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getStorage (final String storageUuid)
specifier|public
name|DatanodeStorage
name|getStorage
parameter_list|(
specifier|final
name|String
name|storageUuid
parameter_list|)
block|{
return|return
name|storageMap
operator|.
name|get
argument_list|(
name|storageUuid
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getStorageReports (String bpid)
specifier|public
name|StorageReport
index|[]
name|getStorageReports
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|StorageReport
argument_list|>
name|reports
decl_stmt|;
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|curVolumes
init|=
name|volumes
operator|.
name|getVolumes
argument_list|()
decl_stmt|;
name|reports
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|curVolumes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|curVolumes
control|)
block|{
try|try
init|(
name|FsVolumeReference
name|ref
init|=
name|volume
operator|.
name|obtainReference
argument_list|()
init|)
block|{
name|StorageReport
name|sr
init|=
operator|new
name|StorageReport
argument_list|(
name|volume
operator|.
name|toDatanodeStorage
argument_list|()
argument_list|,
literal|false
argument_list|,
name|volume
operator|.
name|getCapacity
argument_list|()
argument_list|,
name|volume
operator|.
name|getDfsUsed
argument_list|()
argument_list|,
name|volume
operator|.
name|getAvailable
argument_list|()
argument_list|,
name|volume
operator|.
name|getBlockPoolUsed
argument_list|(
name|bpid
argument_list|)
argument_list|,
name|volume
operator|.
name|getNonDfsUsed
argument_list|()
argument_list|)
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|sr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
continue|continue;
block|}
block|}
block|}
return|return
name|reports
operator|.
name|toArray
argument_list|(
operator|new
name|StorageReport
index|[
name|reports
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getVolume (final ExtendedBlock b)
specifier|public
name|FsVolumeImpl
name|getVolume
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
specifier|final
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|r
operator|!=
literal|null
condition|?
operator|(
name|FsVolumeImpl
operator|)
name|r
operator|.
name|getVolume
argument_list|()
else|:
literal|null
return|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getStoredBlock (String bpid, long blkid)
specifier|public
name|Block
name|getStoredBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blkid
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blkid
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|Block
argument_list|(
name|blkid
argument_list|,
name|r
operator|.
name|getBytesOnDisk
argument_list|()
argument_list|,
name|r
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * This should be primarily used for testing.    * @return clone of replica store in datanode memory    */
DECL|method|fetchReplicaInfo (String bpid, long blockId)
name|ReplicaInfo
name|fetchReplicaInfo
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|r
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|FINALIZED
case|:
case|case
name|RBW
case|:
case|case
name|RWR
case|:
case|case
name|RUR
case|:
case|case
name|TEMPORARY
case|:
return|return
operator|new
name|ReplicaBuilder
argument_list|(
name|r
operator|.
name|getState
argument_list|()
argument_list|)
operator|.
name|from
argument_list|(
name|r
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getMetaDataInputStream (ExtendedBlock b)
specifier|public
name|LengthInputStream
name|getMetaDataInputStream
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|info
init|=
name|getBlockReplica
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
operator|||
operator|!
name|info
operator|.
name|metadataExists
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|info
operator|.
name|getMetadataInputStream
argument_list|(
literal|0
argument_list|)
return|;
block|}
DECL|field|datanode
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|dataStorage
specifier|final
name|DataStorage
name|dataStorage
decl_stmt|;
DECL|field|volumes
specifier|private
specifier|final
name|FsVolumeList
name|volumes
decl_stmt|;
DECL|field|storageMap
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|DatanodeStorage
argument_list|>
name|storageMap
decl_stmt|;
DECL|field|asyncDiskService
specifier|final
name|FsDatasetAsyncDiskService
name|asyncDiskService
decl_stmt|;
DECL|field|lazyWriter
specifier|final
name|Daemon
name|lazyWriter
decl_stmt|;
DECL|field|cacheManager
specifier|final
name|FsDatasetCache
name|cacheManager
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|volFailuresTolerated
specifier|private
specifier|final
name|int
name|volFailuresTolerated
decl_stmt|;
DECL|field|fsRunning
specifier|private
specifier|volatile
name|boolean
name|fsRunning
decl_stmt|;
DECL|field|volumeMap
specifier|final
name|ReplicaMap
name|volumeMap
decl_stmt|;
DECL|field|deletingBlock
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Long
argument_list|>
argument_list|>
name|deletingBlock
decl_stmt|;
DECL|field|ramDiskReplicaTracker
specifier|final
name|RamDiskReplicaTracker
name|ramDiskReplicaTracker
decl_stmt|;
DECL|field|asyncLazyPersistService
specifier|final
name|RamDiskAsyncLazyPersistService
name|asyncLazyPersistService
decl_stmt|;
DECL|field|MAX_BLOCK_EVICTIONS_PER_ITERATION
specifier|private
specifier|static
specifier|final
name|int
name|MAX_BLOCK_EVICTIONS_PER_ITERATION
init|=
literal|3
decl_stmt|;
DECL|field|smallBufferSize
specifier|private
specifier|final
name|int
name|smallBufferSize
decl_stmt|;
comment|// Used for synchronizing access to usage stats
DECL|field|statsLock
specifier|private
specifier|final
name|Object
name|statsLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|localFS
specifier|final
name|LocalFileSystem
name|localFS
decl_stmt|;
DECL|field|blockPinningEnabled
specifier|private
name|boolean
name|blockPinningEnabled
decl_stmt|;
DECL|field|maxDataLength
specifier|private
specifier|final
name|int
name|maxDataLength
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|datasetLock
specifier|final
name|AutoCloseableLock
name|datasetLock
decl_stmt|;
DECL|field|datasetLockCondition
specifier|private
specifier|final
name|Condition
name|datasetLockCondition
decl_stmt|;
comment|/**    * An FSDataset has a directory where it loads its data files.    */
DECL|method|FsDatasetImpl (DataNode datanode, DataStorage storage, Configuration conf )
name|FsDatasetImpl
parameter_list|(
name|DataNode
name|datanode
parameter_list|,
name|DataStorage
name|storage
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|fsRunning
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|dataStorage
operator|=
name|storage
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|smallBufferSize
operator|=
name|DFSUtilClient
operator|.
name|getSmallBufferSize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|datasetLock
operator|=
operator|new
name|AutoCloseableLock
argument_list|(
operator|new
name|InstrumentedLock
argument_list|(
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|LOG
argument_list|,
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_LOCK_SUPPRESS_WARNING_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_LOCK_SUPPRESS_WARNING_INTERVAL_DEFAULT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|,
literal|300
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|datasetLockCondition
operator|=
name|datasetLock
operator|.
name|newCondition
argument_list|()
expr_stmt|;
comment|// The number of volumes required for operation is the total number
comment|// of volumes minus the number of failed volumes we can tolerate.
name|volFailuresTolerated
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getVolFailuresTolerated
argument_list|()
expr_stmt|;
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataLocations
init|=
name|DataNode
operator|.
name|getStorageLocations
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|VolumeFailureInfo
argument_list|>
name|volumeFailureInfos
init|=
name|getInitialVolumeFailureInfos
argument_list|(
name|dataLocations
argument_list|,
name|storage
argument_list|)
decl_stmt|;
name|int
name|volsConfigured
init|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getVolsConfigured
argument_list|()
decl_stmt|;
name|int
name|volsFailed
init|=
name|volumeFailureInfos
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|volsFailed
operator|>
name|volFailuresTolerated
condition|)
block|{
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"Too many failed volumes - "
operator|+
literal|"current valid volumes: "
operator|+
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
operator|+
literal|", volumes configured: "
operator|+
name|volsConfigured
operator|+
literal|", volumes failed: "
operator|+
name|volsFailed
operator|+
literal|", volume failures tolerated: "
operator|+
name|volFailuresTolerated
argument_list|)
throw|;
block|}
name|storageMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|DatanodeStorage
argument_list|>
argument_list|()
expr_stmt|;
name|volumeMap
operator|=
operator|new
name|ReplicaMap
argument_list|(
name|datasetLock
argument_list|)
expr_stmt|;
name|ramDiskReplicaTracker
operator|=
name|RamDiskReplicaTracker
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|VolumeChoosingPolicy
argument_list|<
name|FsVolumeImpl
argument_list|>
name|blockChooserImpl
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FSDATASET_VOLUME_CHOOSING_POLICY_KEY
argument_list|,
name|RoundRobinVolumeChoosingPolicy
operator|.
name|class
argument_list|,
name|VolumeChoosingPolicy
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|volumes
operator|=
operator|new
name|FsVolumeList
argument_list|(
name|volumeFailureInfos
argument_list|,
name|datanode
operator|.
name|getBlockScanner
argument_list|()
argument_list|,
name|blockChooserImpl
argument_list|)
expr_stmt|;
name|asyncDiskService
operator|=
operator|new
name|FsDatasetAsyncDiskService
argument_list|(
name|datanode
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|asyncLazyPersistService
operator|=
operator|new
name|RamDiskAsyncLazyPersistService
argument_list|(
name|datanode
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|deletingBlock
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|addVolume
argument_list|(
name|dataLocations
argument_list|,
name|storage
operator|.
name|getStorageDir
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|setupAsyncLazyPersistThreads
argument_list|()
expr_stmt|;
name|cacheManager
operator|=
operator|new
name|FsDatasetCache
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Start the lazy writer once we have built the replica maps.
comment|// We need to start the lazy writer even if MaxLockedMemory is set to
comment|// zero because we may have un-persisted replicas in memory from before
comment|// the process restart. To minimize the chances of data loss we'll
comment|// ensure they get written to disk now.
if|if
condition|(
name|ramDiskReplicaTracker
operator|.
name|numReplicasNotPersisted
argument_list|()
operator|>
literal|0
operator|||
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getMaxLockedMemory
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lazyWriter
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|LazyWriter
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|lazyWriter
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|lazyWriter
operator|=
literal|null
expr_stmt|;
block|}
name|registerMBean
argument_list|(
name|datanode
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add a Metrics2 Source Interface. This is same
comment|// data as MXBean. We can remove the registerMbean call
comment|// in a release where we can break backward compatibility
name|MetricsSystem
name|ms
init|=
name|DefaultMetricsSystem
operator|.
name|instance
argument_list|()
decl_stmt|;
name|ms
operator|.
name|register
argument_list|(
literal|"FSDatasetState"
argument_list|,
literal|"FSDatasetState"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|localFS
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|blockPinningEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_BLOCK_PINNING_ENABLED
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_BLOCK_PINNING_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
name|maxDataLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_MAXIMUM_DATA_LENGTH
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_MAXIMUM_DATA_LENGTH_DEFAULT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|acquireDatasetLock ()
specifier|public
name|AutoCloseableLock
name|acquireDatasetLock
parameter_list|()
block|{
return|return
name|datasetLock
operator|.
name|acquire
argument_list|()
return|;
block|}
comment|/**    * Gets initial volume failure information for all volumes that failed    * immediately at startup.  The method works by determining the set difference    * between all configured storage locations and the actual storage locations in    * use after attempting to put all of them into service.    *    * @return each storage location that has failed    */
DECL|method|getInitialVolumeFailureInfos ( Collection<StorageLocation> dataLocations, DataStorage storage)
specifier|private
specifier|static
name|List
argument_list|<
name|VolumeFailureInfo
argument_list|>
name|getInitialVolumeFailureInfos
parameter_list|(
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataLocations
parameter_list|,
name|DataStorage
name|storage
parameter_list|)
block|{
name|Set
argument_list|<
name|StorageLocation
argument_list|>
name|failedLocationSet
init|=
name|Sets
operator|.
name|newHashSetWithExpectedSize
argument_list|(
name|dataLocations
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageLocation
name|sl
range|:
name|dataLocations
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding to failedLocationSet "
operator|+
name|sl
argument_list|)
expr_stmt|;
name|failedLocationSet
operator|.
name|add
argument_list|(
name|sl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|Storage
operator|.
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Storage
operator|.
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|failedLocationSet
operator|.
name|remove
argument_list|(
name|sd
operator|.
name|getStorageLocation
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing from failedLocationSet "
operator|+
name|sd
operator|.
name|getStorageLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|VolumeFailureInfo
argument_list|>
name|volumeFailureInfos
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|failedLocationSet
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|failureDate
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageLocation
name|failedStorageLocation
range|:
name|failedLocationSet
control|)
block|{
name|volumeFailureInfos
operator|.
name|add
argument_list|(
operator|new
name|VolumeFailureInfo
argument_list|(
name|failedStorageLocation
argument_list|,
name|failureDate
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|volumeFailureInfos
return|;
block|}
comment|/**    * Activate a volume to serve requests.    * @throws IOException if the storage UUID already exists.    */
DECL|method|activateVolume ( ReplicaMap replicaMap, Storage.StorageDirectory sd, StorageType storageType, FsVolumeReference ref)
specifier|private
name|void
name|activateVolume
parameter_list|(
name|ReplicaMap
name|replicaMap
parameter_list|,
name|Storage
operator|.
name|StorageDirectory
name|sd
parameter_list|,
name|StorageType
name|storageType
parameter_list|,
name|FsVolumeReference
name|ref
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|DatanodeStorage
name|dnStorage
init|=
name|storageMap
operator|.
name|get
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnStorage
operator|!=
literal|null
condition|)
block|{
specifier|final
name|String
name|errorMsg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Found duplicated storage UUID: %s in %s."
argument_list|,
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|sd
operator|.
name|getVersionFile
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|errorMsg
argument_list|)
throw|;
block|}
name|volumeMap
operator|.
name|addAll
argument_list|(
name|replicaMap
argument_list|)
expr_stmt|;
name|storageMap
operator|.
name|put
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|DatanodeStorage
operator|.
name|State
operator|.
name|NORMAL
argument_list|,
name|storageType
argument_list|)
argument_list|)
expr_stmt|;
name|asyncDiskService
operator|.
name|addVolume
argument_list|(
operator|(
name|FsVolumeImpl
operator|)
name|ref
operator|.
name|getVolume
argument_list|()
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|addVolume
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addVolume (Collection<StorageLocation> dataLocations, Storage.StorageDirectory sd)
specifier|private
name|void
name|addVolume
parameter_list|(
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataLocations
parameter_list|,
name|Storage
operator|.
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|StorageLocation
name|storageLocation
init|=
name|sd
operator|.
name|getStorageLocation
argument_list|()
decl_stmt|;
comment|// If IOException raises from FsVolumeImpl() or getVolumeMap(), there is
comment|// nothing needed to be rolled back to make various data structures, e.g.,
comment|// storageMap and asyncDiskService, consistent.
name|FsVolumeImpl
name|fsVolume
init|=
operator|new
name|FsVolumeImplBuilder
argument_list|()
operator|.
name|setDataset
argument_list|(
name|this
argument_list|)
operator|.
name|setStorageID
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
operator|.
name|setStorageDirectory
argument_list|(
name|sd
argument_list|)
operator|.
name|setConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|FsVolumeReference
name|ref
init|=
name|fsVolume
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
name|ReplicaMap
name|tempVolumeMap
init|=
operator|new
name|ReplicaMap
argument_list|(
name|datasetLock
argument_list|)
decl_stmt|;
name|fsVolume
operator|.
name|getVolumeMap
argument_list|(
name|tempVolumeMap
argument_list|,
name|ramDiskReplicaTracker
argument_list|)
expr_stmt|;
name|activateVolume
argument_list|(
name|tempVolumeMap
argument_list|,
name|sd
argument_list|,
name|storageLocation
operator|.
name|getStorageType
argument_list|()
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added volume - "
operator|+
name|storageLocation
operator|+
literal|", StorageType: "
operator|+
name|storageLocation
operator|.
name|getStorageType
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|createFsVolume (String storageUuid, Storage.StorageDirectory sd, final StorageLocation location)
specifier|public
name|FsVolumeImpl
name|createFsVolume
parameter_list|(
name|String
name|storageUuid
parameter_list|,
name|Storage
operator|.
name|StorageDirectory
name|sd
parameter_list|,
specifier|final
name|StorageLocation
name|location
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FsVolumeImplBuilder
argument_list|()
operator|.
name|setDataset
argument_list|(
name|this
argument_list|)
operator|.
name|setStorageID
argument_list|(
name|storageUuid
argument_list|)
operator|.
name|setStorageDirectory
argument_list|(
name|sd
argument_list|)
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|addVolume (final StorageLocation location, final List<NamespaceInfo> nsInfos)
specifier|public
name|void
name|addVolume
parameter_list|(
specifier|final
name|StorageLocation
name|location
parameter_list|,
specifier|final
name|List
argument_list|<
name|NamespaceInfo
argument_list|>
name|nsInfos
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Prepare volume in DataStorage
specifier|final
name|DataStorage
operator|.
name|VolumeBuilder
name|builder
decl_stmt|;
try|try
block|{
name|builder
operator|=
name|dataStorage
operator|.
name|prepareVolume
argument_list|(
name|datanode
argument_list|,
name|location
argument_list|,
name|nsInfos
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|volumes
operator|.
name|addVolumeFailureInfo
argument_list|(
operator|new
name|VolumeFailureInfo
argument_list|(
name|location
argument_list|,
name|Time
operator|.
name|now
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
specifier|final
name|Storage
operator|.
name|StorageDirectory
name|sd
init|=
name|builder
operator|.
name|getStorageDirectory
argument_list|()
decl_stmt|;
name|StorageType
name|storageType
init|=
name|location
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
specifier|final
name|FsVolumeImpl
name|fsVolume
init|=
name|createFsVolume
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|sd
argument_list|,
name|location
argument_list|)
decl_stmt|;
specifier|final
name|ReplicaMap
name|tempVolumeMap
init|=
operator|new
name|ReplicaMap
argument_list|(
operator|new
name|AutoCloseableLock
argument_list|()
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|NamespaceInfo
name|nsInfo
range|:
name|nsInfos
control|)
block|{
name|String
name|bpid
init|=
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
decl_stmt|;
try|try
block|{
name|fsVolume
operator|.
name|addBlockPool
argument_list|(
name|bpid
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|timer
argument_list|)
expr_stmt|;
name|fsVolume
operator|.
name|getVolumeMap
argument_list|(
name|bpid
argument_list|,
name|tempVolumeMap
argument_list|,
name|ramDiskReplicaTracker
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception when adding "
operator|+
name|fsVolume
operator|+
literal|". Will throw later."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|exceptions
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|exceptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|MultipleIOException
operator|.
name|createIOException
argument_list|(
name|exceptions
argument_list|)
throw|;
block|}
specifier|final
name|FsVolumeReference
name|ref
init|=
name|fsVolume
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
name|setupAsyncLazyPersistThread
argument_list|(
name|fsVolume
argument_list|)
expr_stmt|;
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
name|activateVolume
argument_list|(
name|tempVolumeMap
argument_list|,
name|sd
argument_list|,
name|storageType
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added volume - "
operator|+
name|location
operator|+
literal|", StorageType: "
operator|+
name|storageType
argument_list|)
expr_stmt|;
block|}
comment|/**    * Removes a set of volumes from FsDataset.    * @param storageLocationsToRemove a set of    * {@link StorageLocation}s for each volume.    * @param clearFailure set true to clear failure information.    */
annotation|@
name|Override
DECL|method|removeVolumes ( Collection<StorageLocation> storageLocationsToRemove, boolean clearFailure)
specifier|public
name|void
name|removeVolumes
parameter_list|(
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|storageLocationsToRemove
parameter_list|,
name|boolean
name|clearFailure
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ReplicaInfo
argument_list|>
argument_list|>
name|blkToInvalidate
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|storageToRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|dataStorage
operator|.
name|getNumStorageDirs
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|Storage
operator|.
name|StorageDirectory
name|sd
init|=
name|dataStorage
operator|.
name|getStorageDir
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|StorageLocation
name|sdLocation
init|=
name|sd
operator|.
name|getStorageLocation
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Checking removing StorageLocation "
operator|+
name|sdLocation
operator|+
literal|" with id "
operator|+
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|storageLocationsToRemove
operator|.
name|contains
argument_list|(
name|sdLocation
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing StorageLocation "
operator|+
name|sdLocation
operator|+
literal|" with id "
operator|+
name|sd
operator|.
name|getStorageUuid
argument_list|()
operator|+
literal|" from FsDataset."
argument_list|)
expr_stmt|;
comment|// Disable the volume from the service.
name|asyncDiskService
operator|.
name|removeVolume
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|removeVolume
argument_list|(
name|sdLocation
argument_list|,
name|clearFailure
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|waitVolumeRemoved
argument_list|(
literal|5000
argument_list|,
name|datasetLockCondition
argument_list|)
expr_stmt|;
comment|// Removed all replica information for the blocks on the volume.
comment|// Unlike updating the volumeMap in addVolume(), this operation does
comment|// not scan disks.
for|for
control|(
name|String
name|bpid
range|:
name|volumeMap
operator|.
name|getBlockPoolList
argument_list|()
control|)
block|{
name|List
argument_list|<
name|ReplicaInfo
argument_list|>
name|blocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ReplicaInfo
argument_list|>
name|it
init|=
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ReplicaInfo
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|StorageLocation
name|blockStorageLocation
init|=
name|block
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageLocation
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"checking for block "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" with storageLocation "
operator|+
name|blockStorageLocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockStorageLocation
operator|.
name|equals
argument_list|(
name|sdLocation
argument_list|)
condition|)
block|{
name|blocks
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|blkToInvalidate
operator|.
name|put
argument_list|(
name|bpid
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
name|storageToRemove
operator|.
name|add
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|setupAsyncLazyPersistThreads
argument_list|()
expr_stmt|;
block|}
comment|// Call this outside the lock.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ReplicaInfo
argument_list|>
argument_list|>
name|entry
range|:
name|blkToInvalidate
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|bpid
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ReplicaInfo
argument_list|>
name|blocks
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|ReplicaInfo
name|block
range|:
name|blocks
control|)
block|{
name|invalidate
argument_list|(
name|bpid
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
block|}
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
for|for
control|(
name|String
name|storageUuid
range|:
name|storageToRemove
control|)
block|{
name|storageMap
operator|.
name|remove
argument_list|(
name|storageUuid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Return the total space used by dfs datanode    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getDfsUsed ()
specifier|public
name|long
name|getDfsUsed
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getDfsUsed
argument_list|()
return|;
block|}
block|}
comment|/**    * Return the total space used by dfs datanode    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getBlockPoolUsed (String bpid)
specifier|public
name|long
name|getBlockPoolUsed
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getBlockPoolUsed
argument_list|(
name|bpid
argument_list|)
return|;
block|}
block|}
comment|/**    * Return true - if there are still valid volumes on the DataNode.     */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|hasEnoughResource ()
specifier|public
name|boolean
name|hasEnoughResource
parameter_list|()
block|{
return|return
name|getNumFailedVolumes
argument_list|()
operator|<=
name|volFailuresTolerated
return|;
block|}
comment|/**    * Return total capacity, used and unused    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getCapacity ()
specifier|public
name|long
name|getCapacity
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getCapacity
argument_list|()
return|;
block|}
block|}
comment|/**    * Return how many bytes can still be stored in the FSDataset    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getRemaining ()
specifier|public
name|long
name|getRemaining
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getRemaining
argument_list|()
return|;
block|}
block|}
comment|/**    * Return the number of failed volumes in the FSDataset.    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getNumFailedVolumes ()
specifier|public
name|int
name|getNumFailedVolumes
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
operator|.
name|length
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getFailedStorageLocations ()
specifier|public
name|String
index|[]
name|getFailedStorageLocations
parameter_list|()
block|{
name|VolumeFailureInfo
index|[]
name|infos
init|=
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|failedStorageLocations
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|infos
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|VolumeFailureInfo
name|info
range|:
name|infos
control|)
block|{
name|failedStorageLocations
operator|.
name|add
argument_list|(
name|info
operator|.
name|getFailedStorageLocation
argument_list|()
operator|.
name|getNormalizedUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|failedStorageLocations
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|failedStorageLocations
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getLastVolumeFailureDate ()
specifier|public
name|long
name|getLastVolumeFailureDate
parameter_list|()
block|{
name|long
name|lastVolumeFailureDate
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VolumeFailureInfo
name|info
range|:
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
control|)
block|{
name|long
name|failureDate
init|=
name|info
operator|.
name|getFailureDate
argument_list|()
decl_stmt|;
if|if
condition|(
name|failureDate
operator|>
name|lastVolumeFailureDate
condition|)
block|{
name|lastVolumeFailureDate
operator|=
name|failureDate
expr_stmt|;
block|}
block|}
return|return
name|lastVolumeFailureDate
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getEstimatedCapacityLostTotal ()
specifier|public
name|long
name|getEstimatedCapacityLostTotal
parameter_list|()
block|{
name|long
name|estimatedCapacityLostTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VolumeFailureInfo
name|info
range|:
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
control|)
block|{
name|estimatedCapacityLostTotal
operator|+=
name|info
operator|.
name|getEstimatedCapacityLost
argument_list|()
expr_stmt|;
block|}
return|return
name|estimatedCapacityLostTotal
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getVolumeFailureSummary ()
specifier|public
name|VolumeFailureSummary
name|getVolumeFailureSummary
parameter_list|()
block|{
name|VolumeFailureInfo
index|[]
name|infos
init|=
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
decl_stmt|;
if|if
condition|(
name|infos
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|failedStorageLocations
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|infos
operator|.
name|length
argument_list|)
decl_stmt|;
name|long
name|lastVolumeFailureDate
init|=
literal|0
decl_stmt|;
name|long
name|estimatedCapacityLostTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VolumeFailureInfo
name|info
range|:
name|infos
control|)
block|{
name|failedStorageLocations
operator|.
name|add
argument_list|(
name|info
operator|.
name|getFailedStorageLocation
argument_list|()
operator|.
name|getNormalizedUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|failureDate
init|=
name|info
operator|.
name|getFailureDate
argument_list|()
decl_stmt|;
if|if
condition|(
name|failureDate
operator|>
name|lastVolumeFailureDate
condition|)
block|{
name|lastVolumeFailureDate
operator|=
name|failureDate
expr_stmt|;
block|}
name|estimatedCapacityLostTotal
operator|+=
name|info
operator|.
name|getEstimatedCapacityLost
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|VolumeFailureSummary
argument_list|(
name|failedStorageLocations
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|failedStorageLocations
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|lastVolumeFailureDate
argument_list|,
name|estimatedCapacityLostTotal
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getCacheUsed ()
specifier|public
name|long
name|getCacheUsed
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getCacheUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getCacheCapacity ()
specifier|public
name|long
name|getCacheCapacity
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getCacheCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getNumBlocksFailedToCache ()
specifier|public
name|long
name|getNumBlocksFailedToCache
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getNumBlocksFailedToCache
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getNumBlocksFailedToUncache ()
specifier|public
name|long
name|getNumBlocksFailedToUncache
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getNumBlocksFailedToUncache
argument_list|()
return|;
block|}
comment|/**    * Get metrics from the metrics source    *    * @param collector to contain the resulting metrics snapshot    * @param all if true, return all metrics even if unchanged.    */
annotation|@
name|Override
DECL|method|getMetrics (MetricsCollector collector, boolean all)
specifier|public
name|void
name|getMetrics
parameter_list|(
name|MetricsCollector
name|collector
parameter_list|,
name|boolean
name|all
parameter_list|)
block|{
try|try
block|{
name|DataNodeMetricHelper
operator|.
name|getMetrics
argument_list|(
name|collector
argument_list|,
name|this
argument_list|,
literal|"FSDatasetState"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception thrown while metric collection. Exception : "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getNumBlocksCached ()
specifier|public
name|long
name|getNumBlocksCached
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getNumBlocksCached
argument_list|()
return|;
block|}
comment|/**    * Find the block's on-disk length    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getLength (ExtendedBlock b)
specifier|public
name|long
name|getLength
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockReplica
argument_list|(
name|b
argument_list|)
operator|.
name|getBlockDataLength
argument_list|()
return|;
block|}
comment|/**    * Get File name for a given block.    */
DECL|method|getBlockReplica (ExtendedBlock b)
specifier|private
name|ReplicaInfo
name|getBlockReplica
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get File name for a given block.    */
DECL|method|getBlockReplica (String bpid, long blockId)
name|ReplicaInfo
name|getBlockReplica
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|r
init|=
name|validateBlockFile
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"BlockId "
operator|+
name|blockId
operator|+
literal|" is not valid."
argument_list|)
throw|;
block|}
return|return
name|r
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getBlockInputStream (ExtendedBlock b, long seekOffset)
specifier|public
name|InputStream
name|getBlockInputStream
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|seekOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|info
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|info
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getVolume
argument_list|()
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|ramDiskReplicaTracker
operator|.
name|touch
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksReadHits
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|blockDataExists
argument_list|()
condition|)
block|{
return|return
name|info
operator|.
name|getDataInputStream
argument_list|(
name|seekOffset
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No data exists for block "
operator|+
name|b
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the meta info of a block stored in volumeMap. To find a block,    * block pool Id, block Id and generation stamp must match.    * @param b extended block    * @return the meta replica information    * @throws ReplicaNotFoundException if no entry is in the map or     *                        there is a generation stamp mismatch    */
DECL|method|getReplicaInfo (ExtendedBlock b)
name|ReplicaInfo
name|getReplicaInfo
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|ReplicaNotFoundException
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNEXPECTED_GS_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
block|}
return|return
name|info
return|;
block|}
comment|/**    * Get the meta info of a block stored in volumeMap. Block is looked up    * without matching the generation stamp.    * @param bpid block pool Id    * @param blkid block Id    * @return the meta replica information; null if block was not found    * @throws ReplicaNotFoundException if no entry is in the map or     *                        there is a generation stamp mismatch    */
annotation|@
name|VisibleForTesting
DECL|method|getReplicaInfo (String bpid, long blkid)
name|ReplicaInfo
name|getReplicaInfo
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blkid
parameter_list|)
throws|throws
name|ReplicaNotFoundException
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blkid
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|bpid
operator|+
literal|":"
operator|+
name|blkid
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
comment|/**    * Returns handles to the block file and its metadata file    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getTmpInputStreams (ExtendedBlock b, long blkOffset, long metaOffset)
specifier|public
name|ReplicaInputStreams
name|getTmpInputStreams
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|blkOffset
parameter_list|,
name|long
name|metaOffset
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ReplicaInfo
name|info
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|FsVolumeReference
name|ref
init|=
name|info
operator|.
name|getVolume
argument_list|()
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
try|try
block|{
name|InputStream
name|blockInStream
init|=
name|info
operator|.
name|getDataInputStream
argument_list|(
name|blkOffset
argument_list|)
decl_stmt|;
try|try
block|{
name|InputStream
name|metaInStream
init|=
name|info
operator|.
name|getMetadataInputStream
argument_list|(
name|metaOffset
argument_list|)
decl_stmt|;
return|return
operator|new
name|ReplicaInputStreams
argument_list|(
name|blockInStream
argument_list|,
name|metaInStream
argument_list|,
name|ref
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|blockInStream
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
DECL|method|moveBlockFiles (Block b, ReplicaInfo replicaInfo, File destdir)
specifier|static
name|File
name|moveBlockFiles
parameter_list|(
name|Block
name|b
parameter_list|,
name|ReplicaInfo
name|replicaInfo
parameter_list|,
name|File
name|destdir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|dstfile
init|=
operator|new
name|File
argument_list|(
name|destdir
argument_list|,
name|b
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dstmeta
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|dstfile
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|replicaInfo
operator|.
name|renameMeta
argument_list|(
name|dstmeta
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move meta file for "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|replicaInfo
operator|.
name|getMetadataURI
argument_list|()
operator|+
literal|" to "
operator|+
name|dstmeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|replicaInfo
operator|.
name|renameData
argument_list|(
name|dstfile
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move block file for "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|replicaInfo
operator|.
name|getBlockURI
argument_list|()
operator|+
literal|" to "
operator|+
name|dstfile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"addFinalizedBlock: Moved "
operator|+
name|replicaInfo
operator|.
name|getMetadataURI
argument_list|()
operator|+
literal|" to "
operator|+
name|dstmeta
operator|+
literal|" and "
operator|+
name|replicaInfo
operator|.
name|getBlockURI
argument_list|()
operator|+
literal|" to "
operator|+
name|dstfile
argument_list|)
expr_stmt|;
block|}
return|return
name|dstfile
return|;
block|}
comment|/**    * Copy the block and meta files for the given block to the given destination.    * @return the new meta and block files.    * @throws IOException    */
DECL|method|copyBlockFiles (long blockId, long genStamp, ReplicaInfo srcReplica, File destRoot, boolean calculateChecksum, int smallBufferSize, final Configuration conf)
specifier|static
name|File
index|[]
name|copyBlockFiles
parameter_list|(
name|long
name|blockId
parameter_list|,
name|long
name|genStamp
parameter_list|,
name|ReplicaInfo
name|srcReplica
parameter_list|,
name|File
name|destRoot
parameter_list|,
name|boolean
name|calculateChecksum
parameter_list|,
name|int
name|smallBufferSize
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|destDir
init|=
name|DatanodeUtil
operator|.
name|idToBlockDir
argument_list|(
name|destRoot
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
comment|// blockName is same as the filename for the block
specifier|final
name|File
name|dstFile
init|=
operator|new
name|File
argument_list|(
name|destDir
argument_list|,
name|srcReplica
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dstMeta
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|dstFile
argument_list|,
name|genStamp
argument_list|)
decl_stmt|;
return|return
name|copyBlockFiles
argument_list|(
name|srcReplica
argument_list|,
name|dstMeta
argument_list|,
name|dstFile
argument_list|,
name|calculateChecksum
argument_list|,
name|smallBufferSize
argument_list|,
name|conf
argument_list|)
return|;
block|}
DECL|method|copyBlockFiles (ReplicaInfo srcReplica, File dstMeta, File dstFile, boolean calculateChecksum, int smallBufferSize, final Configuration conf)
specifier|static
name|File
index|[]
name|copyBlockFiles
parameter_list|(
name|ReplicaInfo
name|srcReplica
parameter_list|,
name|File
name|dstMeta
parameter_list|,
name|File
name|dstFile
parameter_list|,
name|boolean
name|calculateChecksum
parameter_list|,
name|int
name|smallBufferSize
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|calculateChecksum
condition|)
block|{
name|computeChecksum
argument_list|(
name|srcReplica
argument_list|,
name|dstMeta
argument_list|,
name|smallBufferSize
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|srcReplica
operator|.
name|copyMetadata
argument_list|(
name|dstMeta
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to copy "
operator|+
name|srcReplica
operator|+
literal|" metadata to "
operator|+
name|dstMeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|srcReplica
operator|.
name|copyBlockdata
argument_list|(
name|dstFile
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to copy "
operator|+
name|srcReplica
operator|+
literal|" block file to "
operator|+
name|dstFile
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|calculateChecksum
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copied "
operator|+
name|srcReplica
operator|.
name|getMetadataURI
argument_list|()
operator|+
literal|" meta to "
operator|+
name|dstMeta
operator|+
literal|" and calculated checksum"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copied "
operator|+
name|srcReplica
operator|.
name|getBlockURI
argument_list|()
operator|+
literal|" to "
operator|+
name|dstFile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|File
index|[]
block|{
name|dstMeta
block|,
name|dstFile
block|}
return|;
block|}
comment|/**    * Move block files from one storage to another storage.    * @return Returns the Old replicaInfo    * @throws IOException    */
annotation|@
name|Override
DECL|method|moveBlockAcrossStorage (ExtendedBlock block, StorageType targetStorageType)
specifier|public
name|ReplicaInfo
name|moveBlockAcrossStorage
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|StorageType
name|targetStorageType
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_REPLICA
operator|+
name|block
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|block
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" expected length is "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageType
argument_list|()
operator|==
name|targetStorageType
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Replica "
operator|+
name|replicaInfo
operator|+
literal|" already exists on storage "
operator|+
name|targetStorageType
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|isOnTransientStorage
argument_list|()
condition|)
block|{
comment|// Block movement from RAM_DISK will be done by LazyPersist mechanism
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Replica "
operator|+
name|replicaInfo
operator|+
literal|" cannot be moved from storageType : "
operator|+
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageType
argument_list|()
argument_list|)
throw|;
block|}
name|FsVolumeReference
name|volumeRef
init|=
literal|null
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|volumeRef
operator|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|targetStorageType
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|moveBlock
argument_list|(
name|block
argument_list|,
name|replicaInfo
argument_list|,
name|volumeRef
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|volumeRef
operator|!=
literal|null
condition|)
block|{
name|volumeRef
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Replace the old block if any to reschedule the scanning.
return|return
name|replicaInfo
return|;
block|}
comment|/**    * Moves a block from a given volume to another.    *    * @param block       - Extended Block    * @param replicaInfo - ReplicaInfo    * @param volumeRef   - Volume Ref - Closed by caller.    * @return newReplicaInfo    * @throws IOException    */
DECL|method|moveBlock (ExtendedBlock block, ReplicaInfo replicaInfo, FsVolumeReference volumeRef)
specifier|private
name|ReplicaInfo
name|moveBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|ReplicaInfo
name|replicaInfo
parameter_list|,
name|FsVolumeReference
name|volumeRef
parameter_list|)
throws|throws
name|IOException
block|{
name|FsVolumeImpl
name|targetVolume
init|=
operator|(
name|FsVolumeImpl
operator|)
name|volumeRef
operator|.
name|getVolume
argument_list|()
decl_stmt|;
comment|// Copy files to temp dir first
name|ReplicaInfo
name|newReplicaInfo
init|=
name|targetVolume
operator|.
name|moveBlockToTmpLocation
argument_list|(
name|block
argument_list|,
name|replicaInfo
argument_list|,
name|smallBufferSize
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Finalize the copied files
name|newReplicaInfo
operator|=
name|finalizeReplica
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
comment|// Increment numBlocks here as this block moved without knowing to BPS
name|FsVolumeImpl
name|volume
init|=
operator|(
name|FsVolumeImpl
operator|)
name|newReplicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
name|volume
operator|.
name|incrNumBlocks
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|removeOldReplica
argument_list|(
name|replicaInfo
argument_list|,
name|newReplicaInfo
argument_list|,
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
comment|/**    * Moves a given block from one volume to another volume. This is used by disk    * balancer.    *    * @param block       - ExtendedBlock    * @param destination - Destination volume    * @return Old replica info    */
annotation|@
name|Override
DECL|method|moveBlockAcrossVolumes (ExtendedBlock block, FsVolumeSpi destination)
specifier|public
name|ReplicaInfo
name|moveBlockAcrossVolumes
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|FsVolumeSpi
name|destination
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_REPLICA
operator|+
name|block
argument_list|)
throw|;
block|}
name|FsVolumeReference
name|volumeRef
init|=
literal|null
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|volumeRef
operator|=
name|destination
operator|.
name|obtainReference
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|moveBlock
argument_list|(
name|block
argument_list|,
name|replicaInfo
argument_list|,
name|volumeRef
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|volumeRef
operator|!=
literal|null
condition|)
block|{
name|volumeRef
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|replicaInfo
return|;
block|}
comment|/**    * Compute and store the checksum for a block file that does not already have    * its checksum computed.    *    * @param srcReplica source {@link ReplicaInfo}, containing only the checksum    *     header, not a calculated checksum    * @param dstMeta destination meta file, into which this method will write a    *     full computed checksum    * @param smallBufferSize buffer size to use    * @param conf the {@link Configuration}    * @throws IOException    */
DECL|method|computeChecksum (ReplicaInfo srcReplica, File dstMeta, int smallBufferSize, final Configuration conf)
specifier|static
name|void
name|computeChecksum
parameter_list|(
name|ReplicaInfo
name|srcReplica
parameter_list|,
name|File
name|dstMeta
parameter_list|,
name|int
name|smallBufferSize
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|srcMeta
init|=
operator|new
name|File
argument_list|(
name|srcReplica
operator|.
name|getMetadataURI
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DataChecksum
name|checksum
init|=
name|BlockMetadataHeader
operator|.
name|readDataChecksum
argument_list|(
name|srcMeta
argument_list|,
name|DFSUtilClient
operator|.
name|getIoFileBufferSize
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|1
operator|<<
literal|16
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|crcs
init|=
operator|new
name|byte
index|[
name|checksum
operator|.
name|getChecksumSize
argument_list|(
name|data
operator|.
name|length
argument_list|)
index|]
decl_stmt|;
name|DataOutputStream
name|metaOut
init|=
literal|null
decl_stmt|;
try|try
block|{
name|File
name|parentFile
init|=
name|dstMeta
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentFile
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|parentFile
operator|.
name|mkdirs
argument_list|()
operator|&&
operator|!
name|parentFile
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination '"
operator|+
name|parentFile
operator|+
literal|"' directory cannot be created"
argument_list|)
throw|;
block|}
block|}
name|metaOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|dstMeta
argument_list|)
argument_list|,
name|smallBufferSize
argument_list|)
argument_list|)
expr_stmt|;
name|BlockMetadataHeader
operator|.
name|writeHeader
argument_list|(
name|metaOut
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
try|try
init|(
name|InputStream
name|dataIn
init|=
name|srcReplica
operator|.
name|getDataInputStream
argument_list|(
literal|0
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|n
init|;
operator|(
name|n
operator|=
name|dataIn
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|data
operator|.
name|length
operator|-
name|offset
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|;
control|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
name|n
operator|%
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
specifier|final
name|int
name|length
init|=
name|n
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|checksum
operator|.
name|calculateChunkedSums
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
name|crcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|metaOut
operator|.
name|write
argument_list|(
name|crcs
argument_list|,
literal|0
argument_list|,
name|checksum
operator|.
name|getChecksumSize
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// calculate and write the last crc
name|checksum
operator|.
name|calculateChunkedSums
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
name|crcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|metaOut
operator|.
name|write
argument_list|(
name|crcs
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|metaOut
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|append (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
name|ReplicaHandler
name|append
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
comment|// If the block was successfully finalized because all packets
comment|// were successfully processed at the Datanode but the ack for
comment|// some of the packets were not received by the client. The client
comment|// re-opens the connection and retries sending those packets.
comment|// The other reason is that an "append" is occurring to this block.
comment|// check the validity of the parameter
if|if
condition|(
name|newGS
operator|<
name|b
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The new generation stamp "
operator|+
name|newGS
operator|+
literal|" should be greater than the replica "
operator|+
name|b
operator|+
literal|"'s generation stamp"
argument_list|)
throw|;
block|}
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Appending to "
operator|+
name|replicaInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|expectedBlockLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" expected length is "
operator|+
name|expectedBlockLen
argument_list|)
throw|;
block|}
name|FsVolumeReference
name|ref
init|=
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
name|ReplicaInPipeline
name|replica
init|=
literal|null
decl_stmt|;
try|try
block|{
name|replica
operator|=
name|append
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|,
name|newGS
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|replica
argument_list|,
name|ref
argument_list|)
return|;
block|}
block|}
comment|/** Append to a finalized replica    * Change a finalized replica to be a RBW replica and     * bump its generation stamp to be the newGS    *     * @param bpid block pool Id    * @param replicaInfo a finalized replica    * @param newGS new generation stamp    * @param estimateBlockLen estimate block length    * @return a RBW replica    * @throws IOException if moving the replica from finalized directory     *         to rbw directory fails    */
DECL|method|append (String bpid, ReplicaInfo replicaInfo, long newGS, long estimateBlockLen)
specifier|private
name|ReplicaInPipeline
name|append
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaInfo
name|replicaInfo
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|estimateBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
comment|// If the block is cached, start uncaching it.
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Only a Finalized replica can be appended to; "
operator|+
literal|"Replica with blk id "
operator|+
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" has state "
operator|+
name|replicaInfo
operator|.
name|getState
argument_list|()
argument_list|)
throw|;
block|}
comment|// If the block is cached, start uncaching it.
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
comment|// If there are any hardlinks to the block, break them.  This ensures
comment|// we are not appending to a file that is part of a previous/ directory.
name|replicaInfo
operator|.
name|breakHardLinksIfNeeded
argument_list|()
expr_stmt|;
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|replicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
name|ReplicaInPipeline
name|rip
init|=
name|v
operator|.
name|append
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
argument_list|,
name|newGS
argument_list|,
name|estimateBlockLen
argument_list|)
decl_stmt|;
if|if
condition|(
name|rip
operator|.
name|getReplicaInfo
argument_list|()
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Append on block "
operator|+
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" returned a replica of state "
operator|+
name|rip
operator|.
name|getReplicaInfo
argument_list|()
operator|.
name|getState
argument_list|()
operator|+
literal|"; expected RBW"
argument_list|)
throw|;
block|}
comment|// Replace finalized replica by a RBW replica in replicas map
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|rip
operator|.
name|getReplicaInfo
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rip
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MustStopExistingWriter
specifier|private
specifier|static
class|class
name|MustStopExistingWriter
extends|extends
name|Exception
block|{
DECL|field|rip
specifier|private
specifier|final
name|ReplicaInPipeline
name|rip
decl_stmt|;
DECL|method|MustStopExistingWriter (ReplicaInPipeline rip)
name|MustStopExistingWriter
parameter_list|(
name|ReplicaInPipeline
name|rip
parameter_list|)
block|{
name|this
operator|.
name|rip
operator|=
name|rip
expr_stmt|;
block|}
DECL|method|getReplicaInPipeline ()
name|ReplicaInPipeline
name|getReplicaInPipeline
parameter_list|()
block|{
return|return
name|rip
return|;
block|}
block|}
DECL|method|recoverCheck (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|private
name|ReplicaInfo
name|recoverCheck
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
throws|,
name|MustStopExistingWriter
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
comment|// check state
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_AND_NONRBW_REPLICA
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
comment|// check generation stamp
name|long
name|replicaGenerationStamp
init|=
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaGenerationStamp
argument_list|<
name|b
operator|.
name|getGenerationStamp
operator|(
operator|)
operator|||
name|replicaGenerationStamp
argument_list|>
name|newGS
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNEXPECTED_GS_REPLICA
operator|+
name|replicaGenerationStamp
operator|+
literal|". Expected GS range is ["
operator|+
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", "
operator|+
name|newGS
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// stop the previous writer before check a replica's length
name|long
name|replicaLen
init|=
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
name|ReplicaInPipeline
name|rbw
init|=
operator|(
name|ReplicaInPipeline
operator|)
name|replicaInfo
decl_stmt|;
if|if
condition|(
operator|!
name|rbw
operator|.
name|attemptToSetWriter
argument_list|(
literal|null
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MustStopExistingWriter
argument_list|(
name|rbw
argument_list|)
throw|;
block|}
comment|// check length: bytesRcvd, bytesOnDisk, and bytesAcked should be the same
if|if
condition|(
name|replicaLen
operator|!=
name|rbw
operator|.
name|getBytesOnDisk
argument_list|()
operator|||
name|replicaLen
operator|!=
name|rbw
operator|.
name|getBytesAcked
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"RBW replica "
operator|+
name|replicaInfo
operator|+
literal|"bytesRcvd("
operator|+
name|rbw
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|"), bytesOnDisk("
operator|+
name|rbw
operator|.
name|getBytesOnDisk
argument_list|()
operator|+
literal|"), and bytesAcked("
operator|+
name|rbw
operator|.
name|getBytesAcked
argument_list|()
operator|+
literal|") are not the same."
argument_list|)
throw|;
block|}
block|}
comment|// check block length
if|if
condition|(
name|replicaLen
operator|!=
name|expectedBlockLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaLen
operator|+
literal|" expected length is "
operator|+
name|expectedBlockLen
argument_list|)
throw|;
block|}
return|return
name|replicaInfo
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|recoverAppend ( ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
name|ReplicaHandler
name|recoverAppend
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover failed append to "
operator|+
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|recoverCheck
argument_list|(
name|b
argument_list|,
name|newGS
argument_list|,
name|expectedBlockLen
argument_list|)
decl_stmt|;
name|FsVolumeReference
name|ref
init|=
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
name|ReplicaInPipeline
name|replica
decl_stmt|;
try|try
block|{
comment|// change the replica's state/gs etc.
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|replica
operator|=
name|append
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|,
name|newGS
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//RBW
name|replicaInfo
operator|.
name|bumpReplicaGS
argument_list|(
name|newGS
argument_list|)
expr_stmt|;
name|replica
operator|=
operator|(
name|ReplicaInPipeline
operator|)
name|replicaInfo
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|replica
argument_list|,
name|ref
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|MustStopExistingWriter
name|e
parameter_list|)
block|{
name|e
operator|.
name|getReplicaInPipeline
argument_list|()
operator|.
name|stopWriter
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|recoverClose (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
name|Replica
name|recoverClose
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover failed close "
operator|+
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
comment|// check replica's state
name|ReplicaInfo
name|replicaInfo
init|=
name|recoverCheck
argument_list|(
name|b
argument_list|,
name|newGS
argument_list|,
name|expectedBlockLen
argument_list|)
decl_stmt|;
comment|// bump the replica's GS
name|replicaInfo
operator|.
name|bumpReplicaGS
argument_list|(
name|newGS
argument_list|)
expr_stmt|;
comment|// finalize the replica if RBW
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
name|finalizeReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|replicaInfo
return|;
block|}
block|}
catch|catch
parameter_list|(
name|MustStopExistingWriter
name|e
parameter_list|)
block|{
name|e
operator|.
name|getReplicaInPipeline
argument_list|()
operator|.
name|stopWriter
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|createRbw ( StorageType storageType, ExtendedBlock b, boolean allowLazyPersist)
specifier|public
name|ReplicaHandler
name|createRbw
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|,
name|boolean
name|allowLazyPersist
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" already exists in state "
operator|+
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|+
literal|" and thus cannot be created."
argument_list|)
throw|;
block|}
comment|// create a new block
name|FsVolumeReference
name|ref
init|=
literal|null
decl_stmt|;
comment|// Use ramdisk only if block size is a multiple of OS page size.
comment|// This simplifies reservation for partially used replicas
comment|// significantly.
if|if
condition|(
name|allowLazyPersist
operator|&&
name|lazyWriter
operator|!=
literal|null
operator|&&
name|b
operator|.
name|getNumBytes
argument_list|()
operator|%
name|cacheManager
operator|.
name|getOsPageSize
argument_list|()
operator|==
literal|0
operator|&&
name|reserveLockedMemory
argument_list|(
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
comment|// First try to place the block on a transient volume.
name|ref
operator|=
name|volumes
operator|.
name|getNextTransientVolume
argument_list|(
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksWrite
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DiskOutOfSpaceException
name|de
parameter_list|)
block|{
comment|// Ignore the exception since we just fall back to persistent storage.
block|}
finally|finally
block|{
if|if
condition|(
name|ref
operator|==
literal|null
condition|)
block|{
name|cacheManager
operator|.
name|release
argument_list|(
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ref
operator|==
literal|null
condition|)
block|{
name|ref
operator|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|storageType
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|ref
operator|.
name|getVolume
argument_list|()
decl_stmt|;
comment|// create an rbw file to hold block in the designated volume
if|if
condition|(
name|allowLazyPersist
operator|&&
operator|!
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksWriteFallback
argument_list|()
expr_stmt|;
block|}
name|ReplicaInPipeline
name|newReplicaInfo
decl_stmt|;
try|try
block|{
name|newReplicaInfo
operator|=
name|v
operator|.
name|createRbw
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|newReplicaInfo
operator|.
name|getReplicaInfo
argument_list|()
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"CreateRBW returned a replica of state "
operator|+
name|newReplicaInfo
operator|.
name|getReplicaInfo
argument_list|()
operator|.
name|getState
argument_list|()
operator|+
literal|" for block "
operator|+
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
operator|.
name|getReplicaInfo
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|newReplicaInfo
argument_list|,
name|ref
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|recoverRbw ( ExtendedBlock b, long newGS, long minBytesRcvd, long maxBytesRcvd)
specifier|public
name|ReplicaHandler
name|recoverRbw
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|minBytesRcvd
parameter_list|,
name|long
name|maxBytesRcvd
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover RBW replica "
operator|+
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
comment|// check the replica's state
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_RBW_REPLICA
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|ReplicaInPipeline
name|rbw
init|=
operator|(
name|ReplicaInPipeline
operator|)
name|replicaInfo
decl_stmt|;
if|if
condition|(
operator|!
name|rbw
operator|.
name|attemptToSetWriter
argument_list|(
literal|null
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MustStopExistingWriter
argument_list|(
name|rbw
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"At "
operator|+
name|datanode
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|", Recovering "
operator|+
name|rbw
argument_list|)
expr_stmt|;
return|return
name|recoverRbwImpl
argument_list|(
name|rbw
argument_list|,
name|b
argument_list|,
name|newGS
argument_list|,
name|minBytesRcvd
argument_list|,
name|maxBytesRcvd
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|MustStopExistingWriter
name|e
parameter_list|)
block|{
name|e
operator|.
name|getReplicaInPipeline
argument_list|()
operator|.
name|stopWriter
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|recoverRbwImpl (ReplicaInPipeline rbw, ExtendedBlock b, long newGS, long minBytesRcvd, long maxBytesRcvd)
specifier|private
name|ReplicaHandler
name|recoverRbwImpl
parameter_list|(
name|ReplicaInPipeline
name|rbw
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|minBytesRcvd
parameter_list|,
name|long
name|maxBytesRcvd
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
comment|// check generation stamp
name|long
name|replicaGenerationStamp
init|=
name|rbw
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaGenerationStamp
argument_list|<
name|b
operator|.
name|getGenerationStamp
operator|(
operator|)
operator|||
name|replicaGenerationStamp
argument_list|>
name|newGS
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNEXPECTED_GS_REPLICA
operator|+
name|b
operator|+
literal|". Expected GS range is ["
operator|+
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", "
operator|+
name|newGS
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// check replica length
name|long
name|bytesAcked
init|=
name|rbw
operator|.
name|getBytesAcked
argument_list|()
decl_stmt|;
name|long
name|numBytes
init|=
name|rbw
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesAcked
argument_list|<
name|minBytesRcvd
operator|||
name|numBytes
argument_list|>
name|maxBytesRcvd
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
literal|"Unmatched length replica "
operator|+
name|rbw
operator|+
literal|": BytesAcked = "
operator|+
name|bytesAcked
operator|+
literal|" BytesRcvd = "
operator|+
name|numBytes
operator|+
literal|" are not in the range of ["
operator|+
name|minBytesRcvd
operator|+
literal|", "
operator|+
name|maxBytesRcvd
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|FsVolumeReference
name|ref
init|=
name|rbw
operator|.
name|getReplicaInfo
argument_list|()
operator|.
name|getVolume
argument_list|()
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Truncate the potentially corrupt portion.
comment|// If the source was client and the last node in the pipeline was lost,
comment|// any corrupt data written after the acked length can go unnoticed.
if|if
condition|(
name|numBytes
operator|>
name|bytesAcked
condition|)
block|{
name|rbw
operator|.
name|getReplicaInfo
argument_list|()
operator|.
name|truncateBlock
argument_list|(
name|bytesAcked
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setNumBytes
argument_list|(
name|bytesAcked
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setLastChecksumAndDataLen
argument_list|(
name|bytesAcked
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// bump the replica's generation stamp to newGS
name|rbw
operator|.
name|getReplicaInfo
argument_list|()
operator|.
name|bumpReplicaGS
argument_list|(
name|newGS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|rbw
argument_list|,
name|ref
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|convertTemporaryToRbw ( final ExtendedBlock b)
specifier|public
name|ReplicaInPipeline
name|convertTemporaryToRbw
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
specifier|final
name|long
name|blockId
init|=
name|b
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
specifier|final
name|long
name|expectedGs
init|=
name|b
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
specifier|final
name|long
name|visible
init|=
name|b
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Convert "
operator|+
name|b
operator|+
literal|" from Temporary to RBW, visible length="
operator|+
name|visible
argument_list|)
expr_stmt|;
specifier|final
name|ReplicaInfo
name|temp
decl_stmt|;
block|{
comment|// get replica
specifier|final
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
comment|// check the replica's state
if|if
condition|(
name|r
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|TEMPORARY
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"r.getState() != ReplicaState.TEMPORARY, r="
operator|+
name|r
argument_list|)
throw|;
block|}
name|temp
operator|=
name|r
expr_stmt|;
block|}
comment|// check generation stamp
if|if
condition|(
name|temp
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|expectedGs
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"temp.getGenerationStamp() != expectedGs = "
operator|+
name|expectedGs
operator|+
literal|", temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// TODO: check writer?
comment|// set writer to the current thread
comment|// temp.setWriter(Thread.currentThread());
comment|// check length
specifier|final
name|long
name|numBytes
init|=
name|temp
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBytes
operator|<
name|visible
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|numBytes
operator|+
literal|" = numBytes< visible = "
operator|+
name|visible
operator|+
literal|", temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// check volume
specifier|final
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|temp
operator|.
name|getVolume
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"r.getVolume() = null, temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
specifier|final
name|ReplicaInPipeline
name|rbw
init|=
name|v
operator|.
name|convertTemporaryToRbw
argument_list|(
name|b
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|rbw
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected replica state: "
operator|+
name|ReplicaState
operator|.
name|RBW
operator|+
literal|" obtained "
operator|+
name|rbw
operator|.
name|getState
argument_list|()
operator|+
literal|" for converting block "
operator|+
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
throw|;
block|}
comment|// overwrite the RBW in the volume map
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|rbw
operator|.
name|getReplicaInfo
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rbw
return|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|createTemporary ( StorageType storageType, ExtendedBlock b)
specifier|public
name|ReplicaHandler
name|createTemporary
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startTimeMs
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|writerStopTimeoutMs
init|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
decl_stmt|;
name|ReplicaInfo
name|lastFoundReplicaInfo
init|=
literal|null
decl_stmt|;
do|do
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ReplicaInfo
name|currentReplicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentReplicaInfo
operator|==
name|lastFoundReplicaInfo
condition|)
block|{
if|if
condition|(
name|lastFoundReplicaInfo
operator|!=
literal|null
condition|)
block|{
name|invalidate
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|new
name|Block
index|[]
block|{
name|lastFoundReplicaInfo
block|}
argument_list|)
expr_stmt|;
block|}
name|FsVolumeReference
name|ref
init|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|storageType
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
decl_stmt|;
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|ref
operator|.
name|getVolume
argument_list|()
decl_stmt|;
name|ReplicaInPipeline
name|newReplicaInfo
decl_stmt|;
try|try
block|{
name|newReplicaInfo
operator|=
name|v
operator|.
name|createTemporary
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
operator|.
name|getReplicaInfo
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|newReplicaInfo
argument_list|,
name|ref
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|currentReplicaInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
operator|(
name|currentReplicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|TEMPORARY
operator|||
name|currentReplicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" already exists in state "
operator|+
name|currentReplicaInfo
operator|.
name|getState
argument_list|()
operator|+
literal|" and thus cannot be created."
argument_list|)
throw|;
block|}
name|lastFoundReplicaInfo
operator|=
name|currentReplicaInfo
expr_stmt|;
block|}
block|}
comment|// Hang too long, just bail out. This is not supposed to happen.
name|long
name|writerStopMs
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTimeMs
decl_stmt|;
if|if
condition|(
name|writerStopMs
operator|>
name|writerStopTimeoutMs
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to stop existing writer for block "
operator|+
name|b
operator|+
literal|" after "
operator|+
name|writerStopMs
operator|+
literal|" miniseconds."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to stop existing writer for block "
operator|+
name|b
operator|+
literal|" after "
operator|+
name|writerStopMs
operator|+
literal|" miniseconds."
argument_list|)
throw|;
block|}
comment|// Stop the previous writer
operator|(
operator|(
name|ReplicaInPipeline
operator|)
name|lastFoundReplicaInfo
operator|)
operator|.
name|stopWriter
argument_list|(
name|writerStopTimeoutMs
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
comment|/**    * Sets the offset in the meta file so that the    * last checksum will be overwritten.    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|adjustCrcChannelPosition (ExtendedBlock b, ReplicaOutputStreams streams, int checksumSize)
specifier|public
name|void
name|adjustCrcChannelPosition
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|ReplicaOutputStreams
name|streams
parameter_list|,
name|int
name|checksumSize
parameter_list|)
throws|throws
name|IOException
block|{
name|FileOutputStream
name|file
init|=
operator|(
name|FileOutputStream
operator|)
name|streams
operator|.
name|getChecksumOut
argument_list|()
decl_stmt|;
name|FileChannel
name|channel
init|=
name|file
operator|.
name|getChannel
argument_list|()
decl_stmt|;
name|long
name|oldPos
init|=
name|channel
operator|.
name|position
argument_list|()
decl_stmt|;
name|long
name|newPos
init|=
name|oldPos
operator|-
name|checksumSize
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Changing meta file offset of block "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|oldPos
operator|+
literal|" to "
operator|+
name|newPos
argument_list|)
expr_stmt|;
block|}
name|channel
operator|.
name|position
argument_list|(
name|newPos
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// REMIND - mjc - eventually we should have a timeout system
comment|// in place to clean up block files left by abandoned clients.
comment|// We should have some timer in place, so that if a blockfile
comment|// is created but non-valid, and has been idle for>48 hours,
comment|// we can GC it safely.
comment|//
comment|/**    * Complete the block write!    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|finalizeBlock (ExtendedBlock b)
specifier|public
name|void
name|finalizeBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// Don't allow data modifications from interrupted threads
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot finalize block from Interrupted Thread"
argument_list|)
throw|;
block|}
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
comment|// this is legal, when recovery happens on a file that has
comment|// been opened for append but never modified
return|return;
block|}
name|finalizeReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|finalizeReplica (String bpid, ReplicaInfo replicaInfo)
specifier|private
name|ReplicaInfo
name|finalizeReplica
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaInfo
name|replicaInfo
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ReplicaInfo
name|newReplicaInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RUR
operator|&&
name|replicaInfo
operator|.
name|getOriginalReplica
argument_list|()
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|newReplicaInfo
operator|=
name|replicaInfo
operator|.
name|getOriginalReplica
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|replicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No volume for block "
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|newReplicaInfo
operator|=
name|v
operator|.
name|addFinalizedBlock
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
argument_list|,
name|replicaInfo
argument_list|,
name|replicaInfo
operator|.
name|getBytesReserved
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|releaseLockedMemory
argument_list|(
name|replicaInfo
operator|.
name|getOriginalBytesReserved
argument_list|()
operator|-
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|ramDiskReplicaTracker
operator|.
name|addReplica
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|v
argument_list|,
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|addRamDiskBytesWrite
argument_list|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|newReplicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|:
literal|"Replica should be finalized"
assert|;
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
block|}
comment|/**    * Remove the temporary block file (if any)    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|unfinalizeBlock (ExtendedBlock b)
specifier|public
name|void
name|unfinalizeBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|TEMPORARY
condition|)
block|{
comment|// remove from volumeMap
name|volumeMap
operator|.
name|remove
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
comment|// delete the on-disk temp file
if|if
condition|(
name|delBlockFromDisk
argument_list|(
name|replicaInfo
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" unfinalized and removed. "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|ramDiskReplicaTracker
operator|.
name|discardReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Remove a block from disk    * @param info the replica that needs to be deleted    * @return true if data for the replica are deleted; false otherwise    */
DECL|method|delBlockFromDisk (ReplicaInfo info)
specifier|private
name|boolean
name|delBlockFromDisk
parameter_list|(
name|ReplicaInfo
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|info
operator|.
name|deleteBlockData
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to delete the block data for replica "
operator|+
name|info
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// remove the meta file
if|if
condition|(
operator|!
name|info
operator|.
name|deleteMetadata
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to delete the meta data for replica "
operator|+
name|info
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getCacheReport (String bpid)
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getCacheReport
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
return|return
name|cacheManager
operator|.
name|getCachedBlocks
argument_list|(
name|bpid
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getBlockReports (String bpid)
specifier|public
name|Map
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|getBlockReports
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|Map
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|blockReportsMap
init|=
operator|new
name|HashMap
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|BlockListAsLongs
operator|.
name|Builder
argument_list|>
name|builders
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BlockListAsLongs
operator|.
name|Builder
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|curVolumes
init|=
literal|null
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|curVolumes
operator|=
name|volumes
operator|.
name|getVolumes
argument_list|()
expr_stmt|;
for|for
control|(
name|FsVolumeSpi
name|v
range|:
name|curVolumes
control|)
block|{
name|builders
operator|.
name|put
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|BlockListAsLongs
operator|.
name|builder
argument_list|(
name|maxDataLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|missingVolumesReported
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ReplicaInfo
name|b
range|:
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
control|)
block|{
name|String
name|volStorageID
init|=
name|b
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageID
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|builders
operator|.
name|containsKey
argument_list|(
name|volStorageID
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|missingVolumesReported
operator|.
name|contains
argument_list|(
name|volStorageID
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Storage volume: "
operator|+
name|volStorageID
operator|+
literal|" missing for the"
operator|+
literal|" replica block: "
operator|+
name|b
operator|+
literal|". Probably being removed!"
argument_list|)
expr_stmt|;
name|missingVolumesReported
operator|.
name|add
argument_list|(
name|volStorageID
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
switch|switch
condition|(
name|b
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|FINALIZED
case|:
case|case
name|RBW
case|:
case|case
name|RWR
case|:
name|builders
operator|.
name|get
argument_list|(
name|b
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUR
case|:
name|ReplicaInfo
name|orig
init|=
name|b
operator|.
name|getOriginalReplica
argument_list|()
decl_stmt|;
name|builders
operator|.
name|get
argument_list|(
name|b
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|orig
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPORARY
case|:
break|break;
default|default:
assert|assert
literal|false
operator|:
literal|"Illegal ReplicaInfo state."
assert|;
block|}
block|}
block|}
for|for
control|(
name|FsVolumeImpl
name|v
range|:
name|curVolumes
control|)
block|{
name|blockReportsMap
operator|.
name|put
argument_list|(
name|v
operator|.
name|toDatanodeStorage
argument_list|()
argument_list|,
name|builders
operator|.
name|get
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|blockReportsMap
return|;
block|}
comment|/**    * Gets a list of references to the finalized blocks for the given block pool.    *<p>    * Callers of this function should call    * {@link FsDatasetSpi#acquireDatasetLock} to avoid blocks' status being    * changed during list iteration.    *</p>    * @return a list of references to the finalized blocks for the given block    *         pool.    */
annotation|@
name|Override
DECL|method|getFinalizedBlocks (String bpid)
specifier|public
name|List
argument_list|<
name|ReplicaInfo
argument_list|>
name|getFinalizedBlocks
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
specifier|final
name|List
argument_list|<
name|ReplicaInfo
argument_list|>
name|finalized
init|=
operator|new
name|ArrayList
argument_list|<
name|ReplicaInfo
argument_list|>
argument_list|(
name|volumeMap
operator|.
name|size
argument_list|(
name|bpid
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|ReplicaInfo
name|b
range|:
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
control|)
block|{
if|if
condition|(
name|b
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|finalized
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|finalized
return|;
block|}
block|}
comment|/**    * Check if a block is valid.    *    * @param b           The block to check.    * @param minLength   The minimum length that the block must have.  May be 0.    * @param state       If this is null, it is ignored.  If it is non-null, we    *                        will check that the replica has this state.    *    * @throws ReplicaNotFoundException          If the replica is not found     *    * @throws UnexpectedReplicaStateException   If the replica is not in the     *                                             expected state.    * @throws FileNotFoundException             If the block file is not found or there    *                                              was an error locating it.    * @throws EOFException                      If the replica length is too short.    *     * @throws IOException                       May be thrown from the methods called.     */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|checkBlock (ExtendedBlock b, long minLength, ReplicaState state)
specifier|public
name|void
name|checkBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|minLength
parameter_list|,
name|ReplicaState
name|state
parameter_list|)
throws|throws
name|ReplicaNotFoundException
throws|,
name|UnexpectedReplicaStateException
throws|,
name|FileNotFoundException
throws|,
name|EOFException
throws|,
name|IOException
block|{
specifier|final
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|b
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|state
condition|)
block|{
throw|throw
operator|new
name|UnexpectedReplicaStateException
argument_list|(
name|b
argument_list|,
name|state
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|replicaInfo
operator|.
name|blockDataExists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|replicaInfo
operator|.
name|getBlockURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|long
name|onDiskLength
init|=
name|getLength
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|onDiskLength
operator|<
name|minLength
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|b
operator|+
literal|"'s on-disk length "
operator|+
name|onDiskLength
operator|+
literal|" is shorter than minLength "
operator|+
name|minLength
argument_list|)
throw|;
block|}
block|}
comment|/**    * Check whether the given block is a valid one.    * valid means finalized    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|isValidBlock (ExtendedBlock b)
specifier|public
name|boolean
name|isValidBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
block|{
return|return
name|isValid
argument_list|(
name|b
argument_list|,
name|ReplicaState
operator|.
name|FINALIZED
argument_list|)
return|;
block|}
comment|/**    * Check whether the given block is a valid RBW.    */
annotation|@
name|Override
comment|// {@link FsDatasetSpi}
DECL|method|isValidRbw (final ExtendedBlock b)
specifier|public
name|boolean
name|isValidRbw
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
block|{
return|return
name|isValid
argument_list|(
name|b
argument_list|,
name|ReplicaState
operator|.
name|RBW
argument_list|)
return|;
block|}
comment|/** Does the block exist and have the given state? */
DECL|method|isValid (final ExtendedBlock b, final ReplicaState state)
specifier|private
name|boolean
name|isValid
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|,
specifier|final
name|ReplicaState
name|state
parameter_list|)
block|{
try|try
block|{
name|checkBlock
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Find the file corresponding to the block and return it if it exists.    */
DECL|method|validateBlockFile (String bpid, long blockId)
name|ReplicaInfo
name|validateBlockFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
comment|//Should we check for metadata file too?
specifier|final
name|ReplicaInfo
name|r
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|r
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|r
operator|.
name|blockDataExists
argument_list|()
condition|)
block|{
return|return
name|r
return|;
block|}
comment|// if file is not null, but doesn't exist - possibly disk failed
name|datanode
operator|.
name|checkDiskErrorAsync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"blockId="
operator|+
name|blockId
operator|+
literal|", replica="
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Check the files of a replica. */
DECL|method|checkReplicaFiles (final ReplicaInfo r)
specifier|static
name|void
name|checkReplicaFiles
parameter_list|(
specifier|final
name|ReplicaInfo
name|r
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check replica's data exists
if|if
condition|(
operator|!
name|r
operator|.
name|blockDataExists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Block data not found, r="
operator|+
name|r
argument_list|)
throw|;
block|}
if|if
condition|(
name|r
operator|.
name|getBytesOnDisk
argument_list|()
operator|!=
name|r
operator|.
name|getBlockDataLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block length mismatch, len="
operator|+
name|r
operator|.
name|getBlockDataLength
argument_list|()
operator|+
literal|" but r="
operator|+
name|r
argument_list|)
throw|;
block|}
comment|//check replica's meta file
if|if
condition|(
operator|!
name|r
operator|.
name|metadataExists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|r
operator|.
name|getMetadataURI
argument_list|()
operator|+
literal|" does not exist, r="
operator|+
name|r
argument_list|)
throw|;
block|}
if|if
condition|(
name|r
operator|.
name|getMetadataLength
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Metafile is empty, r="
operator|+
name|r
argument_list|)
throw|;
block|}
block|}
comment|/**    * We're informed that a block is no longer valid. Delete it.    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|invalidate (String bpid, Block invalidBlks[])
specifier|public
name|void
name|invalidate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|invalidBlks
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|errors
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|invalidBlks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ReplicaInfo
name|removing
decl_stmt|;
specifier|final
name|FsVolumeImpl
name|v
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
specifier|final
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|ReplicaInfo
name|infoByBlockId
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoByBlockId
operator|==
literal|null
condition|)
block|{
comment|// It is okay if the block is not found -- it
comment|// may be deleted earlier.
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|": ReplicaInfo not found."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errors
operator|.
name|add
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|": GenerationStamp not matched, existing replica is "
operator|+
name|Block
operator|.
name|toString
argument_list|(
name|infoByBlockId
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|v
operator|=
operator|(
name|FsVolumeImpl
operator|)
name|info
operator|.
name|getVolume
argument_list|()
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|errors
operator|.
name|add
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". No volume for replica "
operator|+
name|info
argument_list|)
expr_stmt|;
continue|continue;
block|}
try|try
block|{
name|File
name|blockFile
init|=
operator|new
name|File
argument_list|(
name|info
operator|.
name|getBlockURI
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockFile
operator|!=
literal|null
operator|&&
name|blockFile
operator|.
name|getParentFile
argument_list|()
operator|==
literal|null
condition|)
block|{
name|errors
operator|.
name|add
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". Parent not found for block file: "
operator|+
name|blockFile
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Parent directory check failed; replica "
operator|+
name|info
operator|+
literal|" is not backed by a local file"
argument_list|)
expr_stmt|;
block|}
name|removing
operator|=
name|volumeMap
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|addDeletingBlock
argument_list|(
name|bpid
argument_list|,
name|removing
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block file "
operator|+
name|removing
operator|.
name|getBlockURI
argument_list|()
operator|+
literal|" is to be deleted"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removing
operator|instanceof
name|ReplicaInPipeline
condition|)
block|{
operator|(
operator|(
name|ReplicaInPipeline
operator|)
name|removing
operator|)
operator|.
name|releaseAllBytesReserved
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|RamDiskReplica
name|replicaInfo
init|=
name|ramDiskReplicaTracker
operator|.
name|getReplica
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|replicaInfo
operator|.
name|getIsPersisted
argument_list|()
condition|)
block|{
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksDeletedBeforeLazyPersisted
argument_list|()
expr_stmt|;
block|}
name|ramDiskReplicaTracker
operator|.
name|discardReplica
argument_list|(
name|replicaInfo
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If a DFSClient has the replica in its cache of short-circuit file
comment|// descriptors (and the client is using ShortCircuitShm), invalidate it.
name|datanode
operator|.
name|getShortCircuitRegistry
argument_list|()
operator|.
name|processBlockInvalidation
argument_list|(
operator|new
name|ExtendedBlockId
argument_list|(
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|bpid
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the block is cached, start uncaching it.
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Delete the block asynchronously to make sure we can do it fast enough.
comment|// It's ok to unlink the block file before the uncache operation
comment|// finishes.
try|try
block|{
name|asyncDiskService
operator|.
name|deleteAsync
argument_list|(
name|v
operator|.
name|obtainReference
argument_list|()
argument_list|,
name|removing
argument_list|,
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
argument_list|,
name|dataStorage
operator|.
name|getTrashDirectoryForReplica
argument_list|(
name|bpid
argument_list|,
name|removing
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Volume "
operator|+
name|v
operator|+
literal|" is closed, ignore the deletion task for "
operator|+
literal|"block "
operator|+
name|invalidBlks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|errors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Failed to delete "
argument_list|)
operator|.
name|append
argument_list|(
name|errors
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" (out of "
argument_list|)
operator|.
name|append
argument_list|(
name|invalidBlks
operator|.
name|length
argument_list|)
operator|.
name|append
argument_list|(
literal|") replica(s):"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|errors
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
operator|.
name|append
argument_list|(
literal|") "
argument_list|)
operator|.
name|append
argument_list|(
name|errors
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Invalidate a block but does not delete the actual on-disk block file.    *    * It should only be used when deactivating disks.    *    * @param bpid the block pool ID.    * @param block The block to be invalidated.    */
DECL|method|invalidate (String bpid, ReplicaInfo block)
specifier|public
name|void
name|invalidate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaInfo
name|block
parameter_list|)
block|{
comment|// If a DFSClient has the replica in its cache of short-circuit file
comment|// descriptors (and the client is using ShortCircuitShm), invalidate it.
name|datanode
operator|.
name|getShortCircuitRegistry
argument_list|()
operator|.
name|processBlockInvalidation
argument_list|(
operator|new
name|ExtendedBlockId
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|bpid
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the block is cached, start uncaching it.
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeDeletedBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|block
argument_list|)
argument_list|,
name|block
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Asynchronously attempts to cache a single block via {@link FsDatasetCache}.    */
DECL|method|cacheBlock (String bpid, long blockId)
specifier|private
name|void
name|cacheBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|FsVolumeImpl
name|volume
decl_stmt|;
name|String
name|blockFileName
decl_stmt|;
name|long
name|length
decl_stmt|,
name|genstamp
decl_stmt|;
name|Executor
name|volumeExecutor
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache block with id "
operator|+
name|blockId
operator|+
literal|", pool "
operator|+
name|bpid
operator|+
literal|": ReplicaInfo not found."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache block with id "
operator|+
name|blockId
operator|+
literal|", pool "
operator|+
name|bpid
operator|+
literal|": replica is not finalized; it is in state "
operator|+
name|info
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|volume
operator|=
operator|(
name|FsVolumeImpl
operator|)
name|info
operator|.
name|getVolume
argument_list|()
expr_stmt|;
if|if
condition|(
name|volume
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache block with id "
operator|+
name|blockId
operator|+
literal|", pool "
operator|+
name|bpid
operator|+
literal|": volume not found."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache block with id "
operator|+
name|blockId
operator|+
literal|": volume was not an instance of FsVolumeImpl."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|volume
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caching not supported on block with id "
operator|+
name|blockId
operator|+
literal|" since the volume is backed by RAM."
argument_list|)
expr_stmt|;
return|return;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|cacheManager
operator|.
name|numBlocksFailedToCache
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
name|blockFileName
operator|=
name|info
operator|.
name|getBlockURI
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|length
operator|=
name|info
operator|.
name|getVisibleLength
argument_list|()
expr_stmt|;
name|genstamp
operator|=
name|info
operator|.
name|getGenerationStamp
argument_list|()
expr_stmt|;
name|volumeExecutor
operator|=
name|volume
operator|.
name|getCacheExecutor
argument_list|()
expr_stmt|;
block|}
name|cacheManager
operator|.
name|cacheBlock
argument_list|(
name|blockId
argument_list|,
name|bpid
argument_list|,
name|blockFileName
argument_list|,
name|length
argument_list|,
name|genstamp
argument_list|,
name|volumeExecutor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|cache (String bpid, long[] blockIds)
specifier|public
name|void
name|cache
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
index|[]
name|blockIds
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockIds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cacheBlock
argument_list|(
name|bpid
argument_list|,
name|blockIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|uncache (String bpid, long[] blockIds)
specifier|public
name|void
name|uncache
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
index|[]
name|blockIds
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockIds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|blockIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isCached (String bpid, long blockId)
specifier|public
name|boolean
name|isCached
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
return|return
name|cacheManager
operator|.
name|isCached
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|contains (final ExtendedBlock block)
specifier|public
name|boolean
name|contains
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
specifier|final
name|long
name|blockId
init|=
name|block
operator|.
name|getLocalBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
specifier|final
name|String
name|bpid
init|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
specifier|final
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
return|return
operator|(
name|r
operator|!=
literal|null
operator|&&
name|r
operator|.
name|blockDataExists
argument_list|()
operator|)
return|;
block|}
block|}
comment|/**    * check if a data directory is healthy    *    * if some volumes failed - the caller must emove all the blocks that belong    * to these failed volumes.    * @return the failed volumes. Returns null if no volume failed.    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|checkDataDir ()
specifier|public
name|Set
argument_list|<
name|StorageLocation
argument_list|>
name|checkDataDir
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|checkDirs
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSDataset{dirpath='"
operator|+
name|volumes
operator|+
literal|"'}"
return|;
block|}
DECL|field|mbeanName
specifier|private
name|ObjectName
name|mbeanName
decl_stmt|;
comment|/**    * Register the FSDataset MBean using the name    *        "hadoop:service=DataNode,name=FSDatasetState-<datanodeUuid>"    */
DECL|method|registerMBean (final String datanodeUuid)
name|void
name|registerMBean
parameter_list|(
specifier|final
name|String
name|datanodeUuid
parameter_list|)
block|{
comment|// We wrap to bypass standard mbean naming convetion.
comment|// This wraping can be removed in java 6 as it is more flexible in
comment|// package naming for mbeans and their impl.
try|try
block|{
name|StandardMBean
name|bean
init|=
operator|new
name|StandardMBean
argument_list|(
name|this
argument_list|,
name|FSDatasetMBean
operator|.
name|class
argument_list|)
decl_stmt|;
name|mbeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"DataNode"
argument_list|,
literal|"FSDatasetState-"
operator|+
name|datanodeUuid
argument_list|,
name|bean
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotCompliantMBeanException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error registering FSDatasetState MBean"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered FSDatasetState MBean"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|fsRunning
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|lazyWriter
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|LazyWriter
operator|)
name|lazyWriter
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|stop
argument_list|()
expr_stmt|;
name|lazyWriter
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mbeanName
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|mbeanName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asyncDiskService
operator|!=
literal|null
condition|)
block|{
name|asyncDiskService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|asyncLazyPersistService
operator|!=
literal|null
condition|)
block|{
name|asyncLazyPersistService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|volumes
operator|!=
literal|null
condition|)
block|{
name|volumes
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lazyWriter
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|lazyWriter
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"FsDatasetImpl.shutdown ignoring InterruptedException "
operator|+
literal|"from LazyWriter.join"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getStorageInfo ()
specifier|public
name|String
name|getStorageInfo
parameter_list|()
block|{
return|return
name|toString
argument_list|()
return|;
block|}
comment|/**    * Reconcile the difference between blocks on the disk and blocks in    * volumeMap    *    * Check the given block for inconsistencies. Look at the    * current state of the block and reconcile the differences as follows:    *<ul>    *<li>If the block file is missing, delete the block from volumeMap</li>    *<li>If the block file exists and the block is missing in volumeMap,    * add the block to volumeMap<li>    *<li>If generation stamp does not match, then update the block with right    * generation stamp</li>    *<li>If the block length in memory does not match the actual block file length    * then mark the block as corrupt and update the block length in memory</li>    *<li>If the file in {@link ReplicaInfo} does not match the file on    * the disk, update {@link ReplicaInfo} with the correct file</li>    *</ul>    *    * @param blockId Block that differs    * @param diskFile Block file on the disk    * @param diskMetaFile Metadata file from on the disk    * @param vol Volume of the block file    */
annotation|@
name|Override
DECL|method|checkAndUpdate (String bpid, long blockId, File diskFile, File diskMetaFile, FsVolumeSpi vol)
specifier|public
name|void
name|checkAndUpdate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|,
name|File
name|diskFile
parameter_list|,
name|File
name|diskMetaFile
parameter_list|,
name|FsVolumeSpi
name|vol
parameter_list|)
throws|throws
name|IOException
block|{
name|Block
name|corruptBlock
init|=
literal|null
decl_stmt|;
name|ReplicaInfo
name|memBlockInfo
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|memBlockInfo
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
if|if
condition|(
name|memBlockInfo
operator|!=
literal|null
operator|&&
name|memBlockInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
comment|// Block is not finalized - ignore the difference
return|return;
block|}
specifier|final
name|long
name|diskGS
init|=
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
condition|?
name|Block
operator|.
name|getGenerationStamp
argument_list|(
name|diskMetaFile
operator|.
name|getName
argument_list|()
argument_list|)
else|:
name|HdfsConstants
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
if|if
condition|(
name|diskFile
operator|==
literal|null
operator|||
operator|!
name|diskFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memBlockInfo
operator|==
literal|null
condition|)
block|{
comment|// Block file does not exist and block does not exist in memory
comment|// If metadata file exists then delete it
if|if
condition|(
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deleted a metadata file without a block "
operator|+
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|memBlockInfo
operator|.
name|blockDataExists
argument_list|()
condition|)
block|{
comment|// Block is in memory and not on the disk
comment|// Remove the block from volumeMap
name|volumeMap
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|ramDiskReplicaTracker
operator|.
name|discardReplica
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removed block "
operator|+
name|blockId
operator|+
literal|" from memory with missing block file on the disk"
argument_list|)
expr_stmt|;
comment|// Finally remove the metadata file
if|if
condition|(
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deleted a metadata file for the deleted block "
operator|+
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/*        * Block file exists on the disk        */
if|if
condition|(
name|memBlockInfo
operator|==
literal|null
condition|)
block|{
comment|// Block is missing in memory - add the block to volumeMap
name|ReplicaInfo
name|diskBlockInfo
init|=
operator|new
name|ReplicaBuilder
argument_list|(
name|ReplicaState
operator|.
name|FINALIZED
argument_list|)
operator|.
name|setBlockId
argument_list|(
name|blockId
argument_list|)
operator|.
name|setLength
argument_list|(
name|diskFile
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|setGenerationStamp
argument_list|(
name|diskGS
argument_list|)
operator|.
name|setFsVolume
argument_list|(
name|vol
argument_list|)
operator|.
name|setDirectoryToUse
argument_list|(
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|diskBlockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|long
name|lockedBytesReserved
init|=
name|cacheManager
operator|.
name|reserve
argument_list|(
name|diskBlockInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
operator|>
literal|0
condition|?
name|diskBlockInfo
operator|.
name|getNumBytes
argument_list|()
else|:
literal|0
decl_stmt|;
name|ramDiskReplicaTracker
operator|.
name|addReplica
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|,
operator|(
name|FsVolumeImpl
operator|)
name|vol
argument_list|,
name|lockedBytesReserved
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Added missing block to memory "
operator|+
name|diskBlockInfo
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*        * Block exists in volumeMap and the block file exists on the disk        */
comment|// Compare block files
if|if
condition|(
name|memBlockInfo
operator|.
name|blockDataExists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memBlockInfo
operator|.
name|getBlockURI
argument_list|()
operator|.
name|compareTo
argument_list|(
name|diskFile
operator|.
name|toURI
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|diskMetaFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memBlockInfo
operator|.
name|metadataExists
argument_list|()
condition|)
block|{
comment|// We have two sets of block+meta files. Decide which one to
comment|// keep.
name|ReplicaInfo
name|diskBlockInfo
init|=
operator|new
name|ReplicaBuilder
argument_list|(
name|ReplicaState
operator|.
name|FINALIZED
argument_list|)
operator|.
name|setBlockId
argument_list|(
name|blockId
argument_list|)
operator|.
name|setLength
argument_list|(
name|diskFile
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|setGenerationStamp
argument_list|(
name|diskGS
argument_list|)
operator|.
name|setFsVolume
argument_list|(
name|vol
argument_list|)
operator|.
name|setDirectoryToUse
argument_list|(
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
operator|(
operator|(
name|FsVolumeImpl
operator|)
name|vol
operator|)
operator|.
name|resolveDuplicateReplicas
argument_list|(
name|bpid
argument_list|,
name|memBlockInfo
argument_list|,
name|diskBlockInfo
argument_list|,
name|volumeMap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|diskFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete "
operator|+
name|diskFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Block refers to a block file that does not exist.
comment|// Update the block with the file found on the disk. Since the block
comment|// file and metadata file are found as a pair on the disk, update
comment|// the block based on the metadata file found on the disk
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block file in replica "
operator|+
name|memBlockInfo
operator|.
name|getBlockURI
argument_list|()
operator|+
literal|" does not exist. Updating it to the file found during scan "
operator|+
name|diskFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|updateWithReplica
argument_list|(
name|StorageLocation
operator|.
name|parse
argument_list|(
name|diskFile
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating generation stamp for block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|" to "
operator|+
name|diskGS
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setGenerationStamp
argument_list|(
name|diskGS
argument_list|)
expr_stmt|;
block|}
comment|// Compare generation stamp
if|if
condition|(
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|diskGS
condition|)
block|{
name|File
name|memMetaFile
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|diskFile
argument_list|,
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|memMetaFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memMetaFile
operator|.
name|compareTo
argument_list|(
name|diskMetaFile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Metadata file in memory "
operator|+
name|memMetaFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" does not match file found by scan "
operator|+
operator|(
name|diskMetaFile
operator|==
literal|null
condition|?
literal|null
else|:
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Metadata file corresponding to block in memory is missing
comment|// If metadata file found during the scan is on the same directory
comment|// as the block file, then use the generation stamp from it
try|try
block|{
name|File
name|memFile
init|=
operator|new
name|File
argument_list|(
name|memBlockInfo
operator|.
name|getBlockURI
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|gs
init|=
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|getParent
argument_list|()
operator|.
name|equals
argument_list|(
name|memFile
operator|.
name|getParent
argument_list|()
argument_list|)
condition|?
name|diskGS
else|:
name|HdfsConstants
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating generation stamp for block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|" to "
operator|+
name|gs
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setGenerationStamp
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|//exception arises because the URI cannot be converted to a file
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block URI could not be resolved to a file"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Compare block size
if|if
condition|(
name|memBlockInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|memBlockInfo
operator|.
name|getBlockDataLength
argument_list|()
condition|)
block|{
comment|// Update the length based on the block file
name|corruptBlock
operator|=
operator|new
name|Block
argument_list|(
name|memBlockInfo
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating size of block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" to "
operator|+
name|memBlockInfo
operator|.
name|getBlockDataLength
argument_list|()
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setNumBytes
argument_list|(
name|memBlockInfo
operator|.
name|getBlockDataLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Send corrupt block report outside the lock
if|if
condition|(
name|corruptBlock
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reporting the block "
operator|+
name|corruptBlock
operator|+
literal|" as corrupt due to length mismatch"
argument_list|)
expr_stmt|;
try|try
block|{
name|datanode
operator|.
name|reportBadBlocks
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|corruptBlock
argument_list|)
argument_list|,
name|memBlockInfo
operator|.
name|getVolume
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to repot bad block "
operator|+
name|corruptBlock
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @deprecated use {@link #fetchReplicaInfo(String, long)} instead.    */
annotation|@
name|Override
comment|// FsDatasetSpi
annotation|@
name|Deprecated
DECL|method|getReplica (String bpid, long blockId)
specifier|public
name|ReplicaInfo
name|getReplica
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
return|return
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getReplicaString (String bpid, long blockId)
specifier|public
name|String
name|getReplicaString
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
specifier|final
name|Replica
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
return|return
name|r
operator|==
literal|null
condition|?
literal|"null"
else|:
name|r
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|initReplicaRecovery (RecoveringBlock rBlock)
specifier|public
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|initReplicaRecovery
argument_list|(
name|rBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|volumeMap
argument_list|,
name|rBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
argument_list|,
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
return|;
block|}
comment|/** static version of {@link #initReplicaRecovery(RecoveringBlock)}. */
DECL|method|initReplicaRecovery (String bpid, ReplicaMap map, Block block, long recoveryId, long xceiverStopTimeout)
specifier|static
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaMap
name|map
parameter_list|,
name|Block
name|block
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|xceiverStopTimeout
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|map
operator|.
name|getLock
argument_list|()
operator|.
name|acquire
argument_list|()
init|)
block|{
return|return
name|initReplicaRecoveryImpl
argument_list|(
name|bpid
argument_list|,
name|map
argument_list|,
name|block
argument_list|,
name|recoveryId
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|MustStopExistingWriter
name|e
parameter_list|)
block|{
name|e
operator|.
name|getReplicaInPipeline
argument_list|()
operator|.
name|stopWriter
argument_list|(
name|xceiverStopTimeout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|initReplicaRecoveryImpl (String bpid, ReplicaMap map, Block block, long recoveryId)
specifier|static
name|ReplicaRecoveryInfo
name|initReplicaRecoveryImpl
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaMap
name|map
parameter_list|,
name|Block
name|block
parameter_list|,
name|long
name|recoveryId
parameter_list|)
throws|throws
name|IOException
throws|,
name|MustStopExistingWriter
block|{
specifier|final
name|ReplicaInfo
name|replica
init|=
name|map
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: "
operator|+
name|block
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
expr_stmt|;
comment|//check replica
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//stop writer if there is any
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|TEMPORARY
operator|||
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
specifier|final
name|ReplicaInPipeline
name|rip
init|=
operator|(
name|ReplicaInPipeline
operator|)
name|replica
decl_stmt|;
if|if
condition|(
operator|!
name|rip
operator|.
name|attemptToSetWriter
argument_list|(
literal|null
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MustStopExistingWriter
argument_list|(
name|rip
argument_list|)
throw|;
block|}
comment|//check replica bytes on disk.
if|if
condition|(
name|replica
operator|.
name|getBytesOnDisk
argument_list|()
operator|<
name|replica
operator|.
name|getVisibleLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" getBytesOnDisk()< getVisibleLength(), rip="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check the replica's files
name|checkReplicaFiles
argument_list|(
name|replica
argument_list|)
expr_stmt|;
block|}
comment|//check generation stamp
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getGenerationStamp()< block.getGenerationStamp(), block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check recovery id
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|>=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" replica.getGenerationStamp()>= recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check RUR
specifier|final
name|ReplicaInfo
name|rur
decl_stmt|;
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RUR
condition|)
block|{
name|rur
operator|=
name|replica
expr_stmt|;
if|if
condition|(
name|rur
operator|.
name|getRecoveryID
argument_list|()
operator|>=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
literal|"rur.getRecoveryID()>= recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", block="
operator|+
name|block
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
specifier|final
name|long
name|oldRecoveryID
init|=
name|rur
operator|.
name|getRecoveryID
argument_list|()
decl_stmt|;
name|rur
operator|.
name|setRecoveryID
argument_list|(
name|recoveryId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: update recovery id for "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|oldRecoveryID
operator|+
literal|" to "
operator|+
name|recoveryId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rur
operator|=
operator|new
name|ReplicaBuilder
argument_list|(
name|ReplicaState
operator|.
name|RUR
argument_list|)
operator|.
name|from
argument_list|(
name|replica
argument_list|)
operator|.
name|setRecoveryId
argument_list|(
name|recoveryId
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|map
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|rur
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: changing replica state for "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|replica
operator|.
name|getState
argument_list|()
operator|+
literal|" to "
operator|+
name|rur
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rur
operator|.
name|createInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|updateReplicaUnderRecovery ( final ExtendedBlock oldBlock, final long recoveryId, final long newBlockId, final long newlength)
specifier|public
name|Replica
name|updateReplicaUnderRecovery
parameter_list|(
specifier|final
name|ExtendedBlock
name|oldBlock
parameter_list|,
specifier|final
name|long
name|recoveryId
parameter_list|,
specifier|final
name|long
name|newBlockId
parameter_list|,
specifier|final
name|long
name|newlength
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
comment|//get replica
specifier|final
name|String
name|bpid
init|=
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
specifier|final
name|ReplicaInfo
name|replica
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|oldBlock
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"updateReplica: "
operator|+
name|oldBlock
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", length="
operator|+
name|newlength
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
expr_stmt|;
comment|//check replica
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|oldBlock
argument_list|)
throw|;
block|}
comment|//check replica state
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RUR
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getState() != "
operator|+
name|ReplicaState
operator|.
name|RUR
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check replica's byte on disk
if|if
condition|(
name|replica
operator|.
name|getBytesOnDisk
argument_list|()
operator|!=
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" replica.getBytesOnDisk() != block.getNumBytes(), block="
operator|+
name|oldBlock
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check replica files before update
name|checkReplicaFiles
argument_list|(
name|replica
argument_list|)
expr_stmt|;
comment|//update replica
specifier|final
name|ReplicaInfo
name|finalized
init|=
name|updateReplicaUnderRecovery
argument_list|(
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replica
argument_list|,
name|recoveryId
argument_list|,
name|newBlockId
argument_list|,
name|newlength
argument_list|)
decl_stmt|;
name|boolean
name|copyTruncate
init|=
name|newBlockId
operator|!=
name|oldBlock
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|copyTruncate
condition|)
block|{
assert|assert
name|finalized
operator|.
name|getBlockId
argument_list|()
operator|==
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|&&
name|finalized
operator|.
name|getGenerationStamp
argument_list|()
operator|==
name|recoveryId
operator|&&
name|finalized
operator|.
name|getNumBytes
argument_list|()
operator|==
name|newlength
operator|:
literal|"Replica information mismatched: oldBlock="
operator|+
name|oldBlock
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", newlength="
operator|+
name|newlength
operator|+
literal|", newBlockId="
operator|+
name|newBlockId
operator|+
literal|", finalized="
operator|+
name|finalized
assert|;
block|}
else|else
block|{
assert|assert
name|finalized
operator|.
name|getBlockId
argument_list|()
operator|==
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|&&
name|finalized
operator|.
name|getGenerationStamp
argument_list|()
operator|==
name|oldBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|finalized
operator|.
name|getNumBytes
argument_list|()
operator|==
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
operator|:
literal|"Finalized and old information mismatched: oldBlock="
operator|+
name|oldBlock
operator|+
literal|", genStamp="
operator|+
name|oldBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", len="
operator|+
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|", finalized="
operator|+
name|finalized
assert|;
block|}
comment|//check replica files after update
name|checkReplicaFiles
argument_list|(
name|finalized
argument_list|)
expr_stmt|;
return|return
name|finalized
return|;
block|}
block|}
DECL|method|updateReplicaUnderRecovery ( String bpid, ReplicaInfo rur, long recoveryId, long newBlockId, long newlength)
specifier|private
name|ReplicaInfo
name|updateReplicaUnderRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaInfo
name|rur
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|newBlockId
parameter_list|,
name|long
name|newlength
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check recovery id
if|if
condition|(
name|rur
operator|.
name|getRecoveryID
argument_list|()
operator|!=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rur.getRecoveryID() != recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
name|boolean
name|copyOnTruncate
init|=
name|newBlockId
operator|>
literal|0L
operator|&&
name|rur
operator|.
name|getBlockId
argument_list|()
operator|!=
name|newBlockId
decl_stmt|;
comment|// bump rur's GS to be recovery id
if|if
condition|(
operator|!
name|copyOnTruncate
condition|)
block|{
name|rur
operator|.
name|bumpReplicaGS
argument_list|(
name|recoveryId
argument_list|)
expr_stmt|;
block|}
comment|//update length
if|if
condition|(
name|rur
operator|.
name|getNumBytes
argument_list|()
operator|<
name|newlength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rur.getNumBytes()< newlength = "
operator|+
name|newlength
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
if|if
condition|(
name|rur
operator|.
name|getNumBytes
argument_list|()
operator|>
name|newlength
condition|)
block|{
if|if
condition|(
operator|!
name|copyOnTruncate
condition|)
block|{
name|rur
operator|.
name|breakHardLinksIfNeeded
argument_list|()
expr_stmt|;
name|rur
operator|.
name|truncateBlock
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
comment|// update RUR with the new length
name|rur
operator|.
name|setNumBytes
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Copying block to a new block with new blockId.
comment|// Not truncating original block.
name|FsVolumeImpl
name|volume
init|=
operator|(
name|FsVolumeImpl
operator|)
name|rur
operator|.
name|getVolume
argument_list|()
decl_stmt|;
name|ReplicaInPipeline
name|newReplicaInfo
init|=
name|volume
operator|.
name|updateRURCopyOnTruncate
argument_list|(
name|rur
argument_list|,
name|bpid
argument_list|,
name|newBlockId
argument_list|,
name|recoveryId
argument_list|,
name|newlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|newReplicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Append on block "
operator|+
name|rur
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" returned a replica of state "
operator|+
name|newReplicaInfo
operator|.
name|getState
argument_list|()
operator|+
literal|"; expected RBW"
argument_list|)
throw|;
block|}
name|newReplicaInfo
operator|.
name|setNumBytes
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
operator|.
name|getReplicaInfo
argument_list|()
argument_list|)
expr_stmt|;
name|finalizeReplica
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
operator|.
name|getReplicaInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// finalize the block
return|return
name|finalizeReplica
argument_list|(
name|bpid
argument_list|,
name|rur
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getReplicaVisibleLength (final ExtendedBlock block)
specifier|public
name|long
name|getReplicaVisibleLength
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
specifier|final
name|Replica
name|replica
init|=
name|getReplicaInfo
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getGenerationStamp()< block.getGenerationStamp(), block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
return|return
name|replica
operator|.
name|getVisibleLength
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|addBlockPool (String bpid, Configuration conf)
specifier|public
name|void
name|addBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding block pool "
operator|+
name|bpid
argument_list|)
expr_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|volumes
operator|.
name|addBlockPool
argument_list|(
name|bpid
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|volumeMap
operator|.
name|initBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
name|volumes
operator|.
name|getAllVolumesMap
argument_list|(
name|bpid
argument_list|,
name|volumeMap
argument_list|,
name|ramDiskReplicaTracker
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|shutdownBlockPool (String bpid)
specifier|public
name|void
name|shutdownBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing block pool "
operator|+
name|bpid
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|blocksPerVolume
init|=
name|getBlockReports
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|cleanUpBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|removeBlockPool
argument_list|(
name|bpid
argument_list|,
name|blocksPerVolume
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Class for representing the Datanode volume information    */
DECL|class|VolumeInfo
specifier|private
specifier|static
class|class
name|VolumeInfo
block|{
DECL|field|directory
specifier|final
name|String
name|directory
decl_stmt|;
DECL|field|usedSpace
specifier|final
name|long
name|usedSpace
decl_stmt|;
comment|// size of space used by HDFS
DECL|field|freeSpace
specifier|final
name|long
name|freeSpace
decl_stmt|;
comment|// size of free space excluding reserved space
DECL|field|reservedSpace
specifier|final
name|long
name|reservedSpace
decl_stmt|;
comment|// size of space reserved for non-HDFS
DECL|field|reservedSpaceForReplicas
specifier|final
name|long
name|reservedSpaceForReplicas
decl_stmt|;
comment|// size of space reserved RBW or
comment|// re-replication
DECL|field|numBlocks
specifier|final
name|long
name|numBlocks
decl_stmt|;
DECL|method|VolumeInfo (FsVolumeImpl v, long usedSpace, long freeSpace)
name|VolumeInfo
parameter_list|(
name|FsVolumeImpl
name|v
parameter_list|,
name|long
name|usedSpace
parameter_list|,
name|long
name|freeSpace
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|v
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|usedSpace
operator|=
name|usedSpace
expr_stmt|;
name|this
operator|.
name|freeSpace
operator|=
name|freeSpace
expr_stmt|;
name|this
operator|.
name|reservedSpace
operator|=
name|v
operator|.
name|getReserved
argument_list|()
expr_stmt|;
name|this
operator|.
name|reservedSpaceForReplicas
operator|=
name|v
operator|.
name|getReservedForReplicas
argument_list|()
expr_stmt|;
name|this
operator|.
name|numBlocks
operator|=
name|v
operator|.
name|getNumBlocks
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getVolumeInfo ()
specifier|private
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|getVolumeInfo
parameter_list|()
block|{
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|info
init|=
operator|new
name|ArrayList
argument_list|<
name|VolumeInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|volumes
operator|.
name|getVolumes
argument_list|()
control|)
block|{
name|long
name|used
init|=
literal|0
decl_stmt|;
name|long
name|free
init|=
literal|0
decl_stmt|;
try|try
init|(
name|FsVolumeReference
name|ref
init|=
name|volume
operator|.
name|obtainReference
argument_list|()
init|)
block|{
name|used
operator|=
name|volume
operator|.
name|getDfsUsed
argument_list|()
expr_stmt|;
name|free
operator|=
name|volume
operator|.
name|getAvailable
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
continue|continue;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|free
operator|=
literal|0
expr_stmt|;
block|}
name|info
operator|.
name|add
argument_list|(
operator|new
name|VolumeInfo
argument_list|(
name|volume
argument_list|,
name|used
argument_list|,
name|free
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
annotation|@
name|Override
DECL|method|getVolumeInfoMap ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getVolumeInfoMap
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|volumes
init|=
name|getVolumeInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|VolumeInfo
name|v
range|:
name|volumes
control|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"usedSpace"
argument_list|,
name|v
operator|.
name|usedSpace
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"freeSpace"
argument_list|,
name|v
operator|.
name|freeSpace
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"reservedSpace"
argument_list|,
name|v
operator|.
name|reservedSpace
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"reservedSpaceForReplicas"
argument_list|,
name|v
operator|.
name|reservedSpaceForReplicas
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"numBlocks"
argument_list|,
name|v
operator|.
name|numBlocks
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
name|v
operator|.
name|directory
argument_list|,
name|innerInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
annotation|@
name|Override
comment|//FsDatasetSpi
DECL|method|deleteBlockPool (String bpid, boolean force)
specifier|public
name|void
name|deleteBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|curVolumes
init|=
name|volumes
operator|.
name|getVolumes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
block|{
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|curVolumes
control|)
block|{
try|try
init|(
name|FsVolumeReference
name|ref
init|=
name|volume
operator|.
name|obtainReference
argument_list|()
init|)
block|{
if|if
condition|(
operator|!
name|volume
operator|.
name|isBPDirEmpty
argument_list|(
name|bpid
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|bpid
operator|+
literal|" has some block files, cannot delete unless forced"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot delete block pool, "
operator|+
literal|"it contains some block files"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
comment|// ignore.
block|}
block|}
block|}
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|curVolumes
control|)
block|{
try|try
init|(
name|FsVolumeReference
name|ref
init|=
name|volume
operator|.
name|obtainReference
argument_list|()
init|)
block|{
name|volume
operator|.
name|deleteBPDirectories
argument_list|(
name|bpid
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
comment|// ignore.
block|}
block|}
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getBlockLocalPathInfo (ExtendedBlock block)
specifier|public
name|BlockLocalPathInfo
name|getBlockLocalPathInfo
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
specifier|final
name|Replica
name|replica
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|block
argument_list|)
throw|;
block|}
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Replica generation stamp< block generation stamp, block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|>
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ReplicaInfo
name|r
init|=
name|getBlockReplica
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|File
name|blockFile
init|=
operator|new
name|File
argument_list|(
name|r
operator|.
name|getBlockURI
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|metaFile
init|=
operator|new
name|File
argument_list|(
name|r
operator|.
name|getMetadataURI
argument_list|()
argument_list|)
decl_stmt|;
name|BlockLocalPathInfo
name|info
init|=
operator|new
name|BlockLocalPathInfo
argument_list|(
name|block
argument_list|,
name|blockFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|metaFile
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|info
return|;
block|}
annotation|@
name|Override
DECL|method|enableTrash (String bpid)
specifier|public
name|void
name|enableTrash
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|dataStorage
operator|.
name|enableTrash
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clearTrash (String bpid)
specifier|public
name|void
name|clearTrash
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|dataStorage
operator|.
name|clearTrash
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|trashEnabled (String bpid)
specifier|public
name|boolean
name|trashEnabled
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
return|return
name|dataStorage
operator|.
name|trashEnabled
argument_list|(
name|bpid
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setRollingUpgradeMarker (String bpid)
specifier|public
name|void
name|setRollingUpgradeMarker
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|dataStorage
operator|.
name|setRollingUpgradeMarker
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clearRollingUpgradeMarker (String bpid)
specifier|public
name|void
name|clearRollingUpgradeMarker
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|dataStorage
operator|.
name|clearRollingUpgradeMarker
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onCompleteLazyPersist (String bpId, long blockId, long creationTime, File[] savedFiles, FsVolumeImpl targetVolume)
specifier|public
name|void
name|onCompleteLazyPersist
parameter_list|(
name|String
name|bpId
parameter_list|,
name|long
name|blockId
parameter_list|,
name|long
name|creationTime
parameter_list|,
name|File
index|[]
name|savedFiles
parameter_list|,
name|FsVolumeImpl
name|targetVolume
parameter_list|)
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|ramDiskReplicaTracker
operator|.
name|recordEndLazyPersist
argument_list|(
name|bpId
argument_list|,
name|blockId
argument_list|,
name|savedFiles
argument_list|)
expr_stmt|;
name|targetVolume
operator|.
name|incDfsUsedAndNumBlocks
argument_list|(
name|bpId
argument_list|,
name|savedFiles
index|[
literal|0
index|]
operator|.
name|length
argument_list|()
operator|+
name|savedFiles
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update metrics (ignore the metadata file size)
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksLazyPersisted
argument_list|()
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBytesLazyPersisted
argument_list|(
name|savedFiles
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|addRamDiskBlocksLazyPersistWindowMs
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|creationTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"LazyWriter: Finish persisting RamDisk block: "
operator|+
literal|" block pool Id: "
operator|+
name|bpId
operator|+
literal|" block id: "
operator|+
name|blockId
operator|+
literal|" to block file "
operator|+
name|savedFiles
index|[
literal|1
index|]
operator|+
literal|" and meta file "
operator|+
name|savedFiles
index|[
literal|0
index|]
operator|+
literal|" on target volume "
operator|+
name|targetVolume
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onFailLazyPersist (String bpId, long blockId)
specifier|public
name|void
name|onFailLazyPersist
parameter_list|(
name|String
name|bpId
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|RamDiskReplica
name|block
init|=
literal|null
decl_stmt|;
name|block
operator|=
name|ramDiskReplicaTracker
operator|.
name|getReplica
argument_list|(
name|bpId
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to save replica "
operator|+
name|block
operator|+
literal|". re-enqueueing it."
argument_list|)
expr_stmt|;
name|ramDiskReplicaTracker
operator|.
name|reenqueueReplicaNotPersisted
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|submitBackgroundSyncFileRangeRequest (ExtendedBlock block, FileDescriptor fd, long offset, long nbytes, int flags)
specifier|public
name|void
name|submitBackgroundSyncFileRangeRequest
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|FileDescriptor
name|fd
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|nbytes
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|FsVolumeImpl
name|fsVolumeImpl
init|=
name|this
operator|.
name|getVolume
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|asyncDiskService
operator|.
name|submitSyncFileRangeRequest
argument_list|(
name|fsVolumeImpl
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|,
name|nbytes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
DECL|method|ramDiskConfigured ()
specifier|private
name|boolean
name|ramDiskConfigured
parameter_list|()
block|{
for|for
control|(
name|FsVolumeImpl
name|v
range|:
name|volumes
operator|.
name|getVolumes
argument_list|()
control|)
block|{
if|if
condition|(
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// Add/Remove per DISK volume async lazy persist thread when RamDisk volume is
comment|// added or removed.
comment|// This should only be called when the FsDataSetImpl#volumes list is finalized.
DECL|method|setupAsyncLazyPersistThreads ()
specifier|private
name|void
name|setupAsyncLazyPersistThreads
parameter_list|()
block|{
for|for
control|(
name|FsVolumeImpl
name|v
range|:
name|volumes
operator|.
name|getVolumes
argument_list|()
control|)
block|{
name|setupAsyncLazyPersistThread
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setupAsyncLazyPersistThread (final FsVolumeImpl v)
specifier|private
name|void
name|setupAsyncLazyPersistThread
parameter_list|(
specifier|final
name|FsVolumeImpl
name|v
parameter_list|)
block|{
comment|// Skip transient volumes
if|if
condition|(
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
return|return;
block|}
name|boolean
name|ramDiskConfigured
init|=
name|ramDiskConfigured
argument_list|()
decl_stmt|;
comment|// Add thread for DISK volume if RamDisk is configured
if|if
condition|(
name|ramDiskConfigured
operator|&&
name|asyncLazyPersistService
operator|!=
literal|null
operator|&&
operator|!
name|asyncLazyPersistService
operator|.
name|queryVolume
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|asyncLazyPersistService
operator|.
name|addVolume
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|// Remove thread for DISK volume if RamDisk is not configured
if|if
condition|(
operator|!
name|ramDiskConfigured
operator|&&
name|asyncLazyPersistService
operator|!=
literal|null
operator|&&
name|asyncLazyPersistService
operator|.
name|queryVolume
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|asyncLazyPersistService
operator|.
name|removeVolume
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeOldReplica (ReplicaInfo replicaInfo, ReplicaInfo newReplicaInfo, final String bpid)
specifier|private
name|void
name|removeOldReplica
parameter_list|(
name|ReplicaInfo
name|replicaInfo
parameter_list|,
name|ReplicaInfo
name|newReplicaInfo
parameter_list|,
specifier|final
name|String
name|bpid
parameter_list|)
block|{
comment|// Before deleting the files from old storage we must notify the
comment|// NN that the files are on the new storage. Else a blockReport from
comment|// the transient storage might cause the NN to think the blocks are lost.
comment|// Replicas must be evicted from client short-circuit caches, because the
comment|// storage will no longer be same, and thus will require validating
comment|// checksum.  This also stops a client from holding file descriptors,
comment|// which would prevent the OS from reclaiming the memory.
name|ExtendedBlock
name|extendedBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
decl_stmt|;
name|datanode
operator|.
name|getShortCircuitRegistry
argument_list|()
operator|.
name|processBlockInvalidation
argument_list|(
name|ExtendedBlockId
operator|.
name|fromExtendedBlock
argument_list|(
name|extendedBlock
argument_list|)
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivedBlock
argument_list|(
name|extendedBlock
argument_list|,
literal|null
argument_list|,
name|newReplicaInfo
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|newReplicaInfo
operator|.
name|isOnTransientStorage
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove the old replicas
if|if
condition|(
name|replicaInfo
operator|.
name|deleteBlockData
argument_list|()
operator|||
operator|!
name|replicaInfo
operator|.
name|blockDataExists
argument_list|()
condition|)
block|{
name|FsVolumeImpl
name|volume
init|=
operator|(
name|FsVolumeImpl
operator|)
name|replicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
name|volume
operator|.
name|onBlockFileDeletion
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
operator|.
name|getBytesOnDisk
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|deleteMetadata
argument_list|()
operator|||
operator|!
name|replicaInfo
operator|.
name|metadataExists
argument_list|()
condition|)
block|{
name|volume
operator|.
name|onMetaFileDeletion
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
operator|.
name|getMetadataLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If deletion failed then the directory scanner will cleanup the blocks
comment|// eventually.
block|}
DECL|class|LazyWriter
class|class
name|LazyWriter
implements|implements
name|Runnable
block|{
DECL|field|shouldRun
specifier|private
specifier|volatile
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
DECL|field|checkpointerInterval
specifier|final
name|int
name|checkpointerInterval
decl_stmt|;
DECL|method|LazyWriter (Configuration conf)
specifier|public
name|LazyWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|checkpointerInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_LAZY_WRITER_INTERVAL_SEC
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_LAZY_WRITER_INTERVAL_DEFAULT_SEC
argument_list|)
expr_stmt|;
block|}
comment|/**      * Checkpoint a pending replica to persistent storage now.      * If we fail then move the replica to the end of the queue.      * @return true if there is more work to be done, false otherwise.      */
DECL|method|saveNextReplica ()
specifier|private
name|boolean
name|saveNextReplica
parameter_list|()
block|{
name|RamDiskReplica
name|block
init|=
literal|null
decl_stmt|;
name|FsVolumeReference
name|targetReference
decl_stmt|;
name|FsVolumeImpl
name|targetVolume
decl_stmt|;
name|ReplicaInfo
name|replicaInfo
decl_stmt|;
name|boolean
name|succeeded
init|=
literal|false
decl_stmt|;
try|try
block|{
name|block
operator|=
name|ramDiskReplicaTracker
operator|.
name|dequeueNextReplicaToPersist
argument_list|()
expr_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
condition|)
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|replicaInfo
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
comment|// If replicaInfo is null, the block was either deleted before
comment|// it could be checkpointed or it is already on persistent storage.
comment|// This can occur if a second replica on persistent storage was found
comment|// after the lazy write was scheduled.
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
operator|&&
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
comment|// Pick a target volume to persist the block.
name|targetReference
operator|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|StorageType
operator|.
name|DEFAULT
argument_list|,
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|targetVolume
operator|=
operator|(
name|FsVolumeImpl
operator|)
name|targetReference
operator|.
name|getVolume
argument_list|()
expr_stmt|;
name|ramDiskReplicaTracker
operator|.
name|recordStartLazyPersist
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|targetVolume
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"LazyWriter: Start persisting RamDisk block:"
operator|+
literal|" block pool Id: "
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" block id: "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" on target volume "
operator|+
name|targetVolume
argument_list|)
expr_stmt|;
block|}
name|asyncLazyPersistService
operator|.
name|submitLazyPersistTask
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|block
operator|.
name|getCreationTime
argument_list|()
argument_list|,
name|replicaInfo
argument_list|,
name|targetReference
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|succeeded
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception saving replica "
operator|+
name|block
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|succeeded
operator|&&
name|block
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to save replica "
operator|+
name|block
operator|+
literal|". re-enqueueing it."
argument_list|)
expr_stmt|;
name|onFailLazyPersist
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|succeeded
return|;
block|}
comment|/**      * Attempt to evict one or more transient block replicas until we      * have at least bytesNeeded bytes free.      */
DECL|method|evictBlocks (long bytesNeeded)
specifier|public
name|void
name|evictBlocks
parameter_list|(
name|long
name|bytesNeeded
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|iterations
init|=
literal|0
decl_stmt|;
specifier|final
name|long
name|cacheCapacity
init|=
name|cacheManager
operator|.
name|getCacheCapacity
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterations
operator|++
operator|<
name|MAX_BLOCK_EVICTIONS_PER_ITERATION
operator|&&
operator|(
name|cacheCapacity
operator|-
name|cacheManager
operator|.
name|getCacheUsed
argument_list|()
operator|)
operator|<
name|bytesNeeded
condition|)
block|{
name|RamDiskReplica
name|replicaState
init|=
name|ramDiskReplicaTracker
operator|.
name|getNextCandidateForEviction
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaState
operator|==
literal|null
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Evicting block "
operator|+
name|replicaState
argument_list|)
expr_stmt|;
block|}
name|ReplicaInfo
name|replicaInfo
decl_stmt|,
name|newReplicaInfo
decl_stmt|;
specifier|final
name|String
name|bpid
init|=
name|replicaState
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|replicaInfo
operator|=
name|getReplicaInfo
argument_list|(
name|replicaState
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaState
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|isTransientStorage
argument_list|()
argument_list|)
expr_stmt|;
name|ramDiskReplicaTracker
operator|.
name|discardReplica
argument_list|(
name|replicaState
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaState
operator|.
name|getBlockId
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Move the replica from lazyPersist/ to finalized/ on
comment|// the target volume
name|newReplicaInfo
operator|=
name|replicaState
operator|.
name|getLazyPersistVolume
argument_list|()
operator|.
name|activateSavedReplica
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
argument_list|,
name|replicaState
argument_list|)
expr_stmt|;
comment|// Update the volumeMap entry.
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
comment|// Update metrics
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksEvicted
argument_list|()
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|addRamDiskBlocksEvictionWindowMs
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|replicaState
operator|.
name|getCreationTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicaState
operator|.
name|getNumReads
argument_list|()
operator|==
literal|0
condition|)
block|{
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksEvictedWithoutRead
argument_list|()
expr_stmt|;
block|}
comment|// Delete the block+meta files from RAM disk and release locked
comment|// memory.
name|removeOldReplica
argument_list|(
name|replicaInfo
argument_list|,
name|newReplicaInfo
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|int
name|numSuccessiveFailures
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|fsRunning
operator|&&
name|shouldRun
condition|)
block|{
try|try
block|{
name|numSuccessiveFailures
operator|=
name|saveNextReplica
argument_list|()
condition|?
literal|0
else|:
operator|(
name|numSuccessiveFailures
operator|+
literal|1
operator|)
expr_stmt|;
comment|// Sleep if we have no more work to do or if it looks like we are not
comment|// making any forward progress. This is to ensure that if all persist
comment|// operations are failing we don't keep retrying them in a tight loop.
if|if
condition|(
name|numSuccessiveFailures
operator|>=
name|ramDiskReplicaTracker
operator|.
name|numReplicasNotPersisted
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|checkpointerInterval
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|numSuccessiveFailures
operator|=
literal|0
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"LazyWriter was interrupted, exiting"
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring exception in LazyWriter:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|setPinning (ExtendedBlock block)
specifier|public
name|void
name|setPinning
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockPinningEnabled
condition|)
block|{
return|return;
block|}
name|ReplicaInfo
name|r
init|=
name|getBlockReplica
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|r
operator|.
name|setPinning
argument_list|(
name|localFS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getPinning (ExtendedBlock block)
specifier|public
name|boolean
name|getPinning
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockPinningEnabled
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ReplicaInfo
name|r
init|=
name|getBlockReplica
argument_list|(
name|block
argument_list|)
decl_stmt|;
return|return
name|r
operator|.
name|getPinning
argument_list|(
name|localFS
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isDeletingBlock (String bpid, long blockId)
specifier|public
name|boolean
name|isDeletingBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|deletingBlock
init|)
block|{
name|Set
argument_list|<
name|Long
argument_list|>
name|s
init|=
name|deletingBlock
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
return|return
name|s
operator|!=
literal|null
condition|?
name|s
operator|.
name|contains
argument_list|(
name|blockId
argument_list|)
else|:
literal|false
return|;
block|}
block|}
DECL|method|removeDeletedBlocks (String bpid, Set<Long> blockIds)
specifier|public
name|void
name|removeDeletedBlocks
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Set
argument_list|<
name|Long
argument_list|>
name|blockIds
parameter_list|)
block|{
synchronized|synchronized
init|(
name|deletingBlock
init|)
block|{
name|Set
argument_list|<
name|Long
argument_list|>
name|s
init|=
name|deletingBlock
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Long
name|id
range|:
name|blockIds
control|)
block|{
name|s
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|addDeletingBlock (String bpid, Long blockId)
specifier|private
name|void
name|addDeletingBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Long
name|blockId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|deletingBlock
init|)
block|{
name|Set
argument_list|<
name|Long
argument_list|>
name|s
init|=
name|deletingBlock
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|s
operator|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|deletingBlock
operator|.
name|put
argument_list|(
name|bpid
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|add
argument_list|(
name|blockId
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|releaseLockedMemory (long count, boolean roundup)
name|void
name|releaseLockedMemory
parameter_list|(
name|long
name|count
parameter_list|,
name|boolean
name|roundup
parameter_list|)
block|{
if|if
condition|(
name|roundup
condition|)
block|{
name|cacheManager
operator|.
name|release
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cacheManager
operator|.
name|releaseRoundDown
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Attempt to evict blocks from cache Manager to free the requested    * bytes.    *    * @param bytesNeeded    */
annotation|@
name|VisibleForTesting
DECL|method|evictLazyPersistBlocks (long bytesNeeded)
specifier|public
name|void
name|evictLazyPersistBlocks
parameter_list|(
name|long
name|bytesNeeded
parameter_list|)
block|{
try|try
block|{
operator|(
operator|(
name|LazyWriter
operator|)
name|lazyWriter
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|evictBlocks
argument_list|(
name|bytesNeeded
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring exception "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Attempt to reserve the given amount of memory with the cache Manager.    * @param bytesNeeded    * @return    */
DECL|method|reserveLockedMemory (long bytesNeeded)
name|boolean
name|reserveLockedMemory
parameter_list|(
name|long
name|bytesNeeded
parameter_list|)
block|{
if|if
condition|(
name|cacheManager
operator|.
name|reserve
argument_list|(
name|bytesNeeded
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Round up bytes needed to osPageSize and attempt to evict
comment|// one more more blocks to free up the reservation.
name|bytesNeeded
operator|=
name|cacheManager
operator|.
name|roundUpPageSize
argument_list|(
name|bytesNeeded
argument_list|)
expr_stmt|;
name|evictLazyPersistBlocks
argument_list|(
name|bytesNeeded
argument_list|)
expr_stmt|;
return|return
name|cacheManager
operator|.
name|reserve
argument_list|(
name|bytesNeeded
argument_list|)
operator|>
literal|0
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setTimer (Timer newTimer)
specifier|public
name|void
name|setTimer
parameter_list|(
name|Timer
name|newTimer
parameter_list|)
block|{
name|this
operator|.
name|timer
operator|=
name|newTimer
expr_stmt|;
block|}
DECL|method|stopAllDataxceiverThreads (FsVolumeImpl volume)
name|void
name|stopAllDataxceiverThreads
parameter_list|(
name|FsVolumeImpl
name|volume
parameter_list|)
block|{
try|try
init|(
name|AutoCloseableLock
name|lock
init|=
name|datasetLock
operator|.
name|acquire
argument_list|()
init|)
block|{
for|for
control|(
name|String
name|blockPoolId
range|:
name|volumeMap
operator|.
name|getBlockPoolList
argument_list|()
control|)
block|{
name|Collection
argument_list|<
name|ReplicaInfo
argument_list|>
name|replicas
init|=
name|volumeMap
operator|.
name|replicas
argument_list|(
name|blockPoolId
argument_list|)
decl_stmt|;
for|for
control|(
name|ReplicaInfo
name|replicaInfo
range|:
name|replicas
control|)
block|{
if|if
condition|(
operator|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|TEMPORARY
operator|||
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
operator|)
operator|&&
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|equals
argument_list|(
name|volume
argument_list|)
condition|)
block|{
name|ReplicaInPipeline
name|replicaInPipeline
init|=
operator|(
name|ReplicaInPipeline
operator|)
name|replicaInfo
decl_stmt|;
name|replicaInPipeline
operator|.
name|interruptThread
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

