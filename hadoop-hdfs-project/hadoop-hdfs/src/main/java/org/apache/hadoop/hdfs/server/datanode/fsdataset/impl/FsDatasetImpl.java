begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode.fsdataset.impl
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|NotCompliantMBeanException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|ObjectName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|management
operator|.
name|StandardMBean
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|ExtendedBlockId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockLocalPathInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsBlocksMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|BlockMetadataHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|metrics
operator|.
name|DataNodeMetricHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DatanodeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|FinalizedReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|Replica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaBeingWritten
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaInPipeline
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaUnderRecovery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|ReplicaWaitingToBeRecovered
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|StorageLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|UnexpectedReplicaStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsDatasetSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|FsVolumeSpi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|LengthInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaInputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaOutputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|RoundRobinVolumeChoosingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|VolumeChoosingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|impl
operator|.
name|RamDiskReplicaTracker
operator|.
name|RamDiskReplica
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|metrics
operator|.
name|FSDatasetMBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReplicaRecoveryInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|StorageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|VolumeFailureSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MultipleIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskErrorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskOutOfSpaceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_comment
comment|/**************************************************  * FSDataset manages a set of data blocks.  Each block  * has a unique name and an extent on disk.  *  ***************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|FsDatasetImpl
class|class
name|FsDatasetImpl
implements|implements
name|FsDatasetSpi
argument_list|<
name|FsVolumeImpl
argument_list|>
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FsDatasetImpl
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|isNativeIOAvailable
specifier|private
specifier|final
specifier|static
name|boolean
name|isNativeIOAvailable
decl_stmt|;
static|static
block|{
name|isNativeIOAvailable
operator|=
name|NativeIO
operator|.
name|isAvailable
argument_list|()
expr_stmt|;
if|if
condition|(
name|Path
operator|.
name|WINDOWS
operator|&&
operator|!
name|isNativeIOAvailable
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Data node cannot fully support concurrent reading"
operator|+
literal|" and writing without native code extensions on Windows."
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getFsVolumeReferences ()
specifier|public
name|FsVolumeReferences
name|getFsVolumeReferences
parameter_list|()
block|{
return|return
operator|new
name|FsVolumeReferences
argument_list|(
name|volumes
operator|.
name|getVolumes
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getStorage (final String storageUuid)
specifier|public
name|DatanodeStorage
name|getStorage
parameter_list|(
specifier|final
name|String
name|storageUuid
parameter_list|)
block|{
return|return
name|storageMap
operator|.
name|get
argument_list|(
name|storageUuid
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getStorageReports (String bpid)
specifier|public
name|StorageReport
index|[]
name|getStorageReports
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|StorageReport
argument_list|>
name|reports
decl_stmt|;
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|curVolumes
init|=
name|volumes
operator|.
name|getVolumes
argument_list|()
decl_stmt|;
name|reports
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|curVolumes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|curVolumes
control|)
block|{
try|try
init|(
name|FsVolumeReference
name|ref
init|=
name|volume
operator|.
name|obtainReference
argument_list|()
init|)
block|{
name|StorageReport
name|sr
init|=
operator|new
name|StorageReport
argument_list|(
name|volume
operator|.
name|toDatanodeStorage
argument_list|()
argument_list|,
literal|false
argument_list|,
name|volume
operator|.
name|getCapacity
argument_list|()
argument_list|,
name|volume
operator|.
name|getDfsUsed
argument_list|()
argument_list|,
name|volume
operator|.
name|getAvailable
argument_list|()
argument_list|,
name|volume
operator|.
name|getBlockPoolUsed
argument_list|(
name|bpid
argument_list|)
argument_list|)
decl_stmt|;
name|reports
operator|.
name|add
argument_list|(
name|sr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
continue|continue;
block|}
block|}
block|}
return|return
name|reports
operator|.
name|toArray
argument_list|(
operator|new
name|StorageReport
index|[
name|reports
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getVolume (final ExtendedBlock b)
specifier|public
specifier|synchronized
name|FsVolumeImpl
name|getVolume
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
block|{
specifier|final
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|r
operator|!=
literal|null
condition|?
operator|(
name|FsVolumeImpl
operator|)
name|r
operator|.
name|getVolume
argument_list|()
else|:
literal|null
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getStoredBlock (String bpid, long blkid)
specifier|public
specifier|synchronized
name|Block
name|getStoredBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blkid
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|blockfile
init|=
name|getFile
argument_list|(
name|bpid
argument_list|,
name|blkid
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockfile
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|File
name|metafile
init|=
name|FsDatasetUtil
operator|.
name|findMetaFile
argument_list|(
name|blockfile
argument_list|)
decl_stmt|;
specifier|final
name|long
name|gs
init|=
name|FsDatasetUtil
operator|.
name|parseGenerationStamp
argument_list|(
name|blockfile
argument_list|,
name|metafile
argument_list|)
decl_stmt|;
return|return
operator|new
name|Block
argument_list|(
name|blkid
argument_list|,
name|blockfile
operator|.
name|length
argument_list|()
argument_list|,
name|gs
argument_list|)
return|;
block|}
comment|/**    * This should be primarily used for testing.    * @return clone of replica store in datanode memory    */
DECL|method|fetchReplicaInfo (String bpid, long blockId)
name|ReplicaInfo
name|fetchReplicaInfo
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
return|return
literal|null
return|;
switch|switch
condition|(
name|r
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|FINALIZED
case|:
return|return
operator|new
name|FinalizedReplica
argument_list|(
operator|(
name|FinalizedReplica
operator|)
name|r
argument_list|)
return|;
case|case
name|RBW
case|:
return|return
operator|new
name|ReplicaBeingWritten
argument_list|(
operator|(
name|ReplicaBeingWritten
operator|)
name|r
argument_list|)
return|;
case|case
name|RWR
case|:
return|return
operator|new
name|ReplicaWaitingToBeRecovered
argument_list|(
operator|(
name|ReplicaWaitingToBeRecovered
operator|)
name|r
argument_list|)
return|;
case|case
name|RUR
case|:
return|return
operator|new
name|ReplicaUnderRecovery
argument_list|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|r
argument_list|)
return|;
case|case
name|TEMPORARY
case|:
return|return
operator|new
name|ReplicaInPipeline
argument_list|(
operator|(
name|ReplicaInPipeline
operator|)
name|r
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getMetaDataInputStream (ExtendedBlock b)
specifier|public
name|LengthInputStream
name|getMetaDataInputStream
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|meta
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|getBlockFile
argument_list|(
name|b
argument_list|)
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|meta
operator|==
literal|null
operator|||
operator|!
name|meta
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|isNativeIOAvailable
condition|)
block|{
return|return
operator|new
name|LengthInputStream
argument_list|(
name|NativeIO
operator|.
name|getShareDeleteFileInputStream
argument_list|(
name|meta
argument_list|)
argument_list|,
name|meta
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|new
name|LengthInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|meta
argument_list|)
argument_list|,
name|meta
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
DECL|field|datanode
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|dataStorage
specifier|final
name|DataStorage
name|dataStorage
decl_stmt|;
DECL|field|volumes
specifier|private
specifier|final
name|FsVolumeList
name|volumes
decl_stmt|;
DECL|field|storageMap
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|DatanodeStorage
argument_list|>
name|storageMap
decl_stmt|;
DECL|field|asyncDiskService
specifier|final
name|FsDatasetAsyncDiskService
name|asyncDiskService
decl_stmt|;
DECL|field|lazyWriter
specifier|final
name|Daemon
name|lazyWriter
decl_stmt|;
DECL|field|cacheManager
specifier|final
name|FsDatasetCache
name|cacheManager
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|validVolsRequired
specifier|private
specifier|final
name|int
name|validVolsRequired
decl_stmt|;
DECL|field|fsRunning
specifier|private
specifier|volatile
name|boolean
name|fsRunning
decl_stmt|;
DECL|field|volumeMap
specifier|final
name|ReplicaMap
name|volumeMap
decl_stmt|;
DECL|field|deletingBlock
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Long
argument_list|>
argument_list|>
name|deletingBlock
decl_stmt|;
DECL|field|ramDiskReplicaTracker
specifier|final
name|RamDiskReplicaTracker
name|ramDiskReplicaTracker
decl_stmt|;
DECL|field|asyncLazyPersistService
specifier|final
name|RamDiskAsyncLazyPersistService
name|asyncLazyPersistService
decl_stmt|;
DECL|field|MAX_BLOCK_EVICTIONS_PER_ITERATION
specifier|private
specifier|static
specifier|final
name|int
name|MAX_BLOCK_EVICTIONS_PER_ITERATION
init|=
literal|3
decl_stmt|;
DECL|field|smallBufferSize
specifier|private
specifier|final
name|int
name|smallBufferSize
decl_stmt|;
comment|// Used for synchronizing access to usage stats
DECL|field|statsLock
specifier|private
specifier|final
name|Object
name|statsLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|localFS
specifier|final
name|LocalFileSystem
name|localFS
decl_stmt|;
DECL|field|blockPinningEnabled
specifier|private
name|boolean
name|blockPinningEnabled
decl_stmt|;
comment|/**    * An FSDataset has a directory where it loads its data files.    */
DECL|method|FsDatasetImpl (DataNode datanode, DataStorage storage, Configuration conf )
name|FsDatasetImpl
parameter_list|(
name|DataNode
name|datanode
parameter_list|,
name|DataStorage
name|storage
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|fsRunning
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|dataStorage
operator|=
name|storage
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|smallBufferSize
operator|=
name|DFSUtil
operator|.
name|getSmallBufferSize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// The number of volumes required for operation is the total number
comment|// of volumes minus the number of failed volumes we can tolerate.
specifier|final
name|int
name|volFailuresTolerated
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FAILED_VOLUMES_TOLERATED_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FAILED_VOLUMES_TOLERATED_DEFAULT
argument_list|)
decl_stmt|;
name|String
index|[]
name|dataDirs
init|=
name|conf
operator|.
name|getTrimmedStrings
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_KEY
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataLocations
init|=
name|DataNode
operator|.
name|getStorageLocations
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|VolumeFailureInfo
argument_list|>
name|volumeFailureInfos
init|=
name|getInitialVolumeFailureInfos
argument_list|(
name|dataLocations
argument_list|,
name|storage
argument_list|)
decl_stmt|;
name|int
name|volsConfigured
init|=
operator|(
name|dataDirs
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|dataDirs
operator|.
name|length
decl_stmt|;
name|int
name|volsFailed
init|=
name|volumeFailureInfos
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|.
name|validVolsRequired
operator|=
name|volsConfigured
operator|-
name|volFailuresTolerated
expr_stmt|;
if|if
condition|(
name|volFailuresTolerated
operator|<
literal|0
operator|||
name|volFailuresTolerated
operator|>=
name|volsConfigured
condition|)
block|{
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"Invalid value configured for "
operator|+
literal|"dfs.datanode.failed.volumes.tolerated - "
operator|+
name|volFailuresTolerated
operator|+
literal|". Value configured is either less than 0 or>= "
operator|+
literal|"to the number of configured volumes ("
operator|+
name|volsConfigured
operator|+
literal|")."
argument_list|)
throw|;
block|}
if|if
condition|(
name|volsFailed
operator|>
name|volFailuresTolerated
condition|)
block|{
throw|throw
operator|new
name|DiskErrorException
argument_list|(
literal|"Too many failed volumes - "
operator|+
literal|"current valid volumes: "
operator|+
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
operator|+
literal|", volumes configured: "
operator|+
name|volsConfigured
operator|+
literal|", volumes failed: "
operator|+
name|volsFailed
operator|+
literal|", volume failures tolerated: "
operator|+
name|volFailuresTolerated
argument_list|)
throw|;
block|}
name|storageMap
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|DatanodeStorage
argument_list|>
argument_list|()
expr_stmt|;
name|volumeMap
operator|=
operator|new
name|ReplicaMap
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|ramDiskReplicaTracker
operator|=
name|RamDiskReplicaTracker
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|VolumeChoosingPolicy
argument_list|<
name|FsVolumeImpl
argument_list|>
name|blockChooserImpl
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_FSDATASET_VOLUME_CHOOSING_POLICY_KEY
argument_list|,
name|RoundRobinVolumeChoosingPolicy
operator|.
name|class
argument_list|,
name|VolumeChoosingPolicy
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|volumes
operator|=
operator|new
name|FsVolumeList
argument_list|(
name|volumeFailureInfos
argument_list|,
name|datanode
operator|.
name|getBlockScanner
argument_list|()
argument_list|,
name|blockChooserImpl
argument_list|)
expr_stmt|;
name|asyncDiskService
operator|=
operator|new
name|FsDatasetAsyncDiskService
argument_list|(
name|datanode
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|asyncLazyPersistService
operator|=
operator|new
name|RamDiskAsyncLazyPersistService
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
name|deletingBlock
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Long
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|storage
operator|.
name|getNumStorageDirs
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|addVolume
argument_list|(
name|dataLocations
argument_list|,
name|storage
operator|.
name|getStorageDir
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|setupAsyncLazyPersistThreads
argument_list|()
expr_stmt|;
name|cacheManager
operator|=
operator|new
name|FsDatasetCache
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Start the lazy writer once we have built the replica maps.
name|lazyWriter
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|LazyWriter
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|lazyWriter
operator|.
name|start
argument_list|()
expr_stmt|;
name|registerMBean
argument_list|(
name|datanode
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add a Metrics2 Source Interface. This is same
comment|// data as MXBean. We can remove the registerMbean call
comment|// in a release where we can break backward compatibility
name|MetricsSystem
name|ms
init|=
name|DefaultMetricsSystem
operator|.
name|instance
argument_list|()
decl_stmt|;
name|ms
operator|.
name|register
argument_list|(
literal|"FSDatasetState"
argument_list|,
literal|"FSDatasetState"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|localFS
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|blockPinningEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_BLOCK_PINNING_ENABLED
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_BLOCK_PINNING_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets initial volume failure information for all volumes that failed    * immediately at startup.  The method works by determining the set difference    * between all configured storage locations and the actual storage locations in    * use after attempting to put all of them into service.    *    * @return each storage location that has failed    */
DECL|method|getInitialVolumeFailureInfos ( Collection<StorageLocation> dataLocations, DataStorage storage)
specifier|private
specifier|static
name|List
argument_list|<
name|VolumeFailureInfo
argument_list|>
name|getInitialVolumeFailureInfos
parameter_list|(
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataLocations
parameter_list|,
name|DataStorage
name|storage
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|failedLocationSet
init|=
name|Sets
operator|.
name|newHashSetWithExpectedSize
argument_list|(
name|dataLocations
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|StorageLocation
name|sl
range|:
name|dataLocations
control|)
block|{
name|failedLocationSet
operator|.
name|add
argument_list|(
name|sl
operator|.
name|getFile
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|Storage
operator|.
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Storage
operator|.
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|failedLocationSet
operator|.
name|remove
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|VolumeFailureInfo
argument_list|>
name|volumeFailureInfos
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|failedLocationSet
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|failureDate
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|failedStorageLocation
range|:
name|failedLocationSet
control|)
block|{
name|volumeFailureInfos
operator|.
name|add
argument_list|(
operator|new
name|VolumeFailureInfo
argument_list|(
name|failedStorageLocation
argument_list|,
name|failureDate
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|volumeFailureInfos
return|;
block|}
DECL|method|addVolume (Collection<StorageLocation> dataLocations, Storage.StorageDirectory sd)
specifier|private
name|void
name|addVolume
parameter_list|(
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataLocations
parameter_list|,
name|Storage
operator|.
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|dir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
specifier|final
name|StorageType
name|storageType
init|=
name|getStorageTypeFromLocations
argument_list|(
name|dataLocations
argument_list|,
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
decl_stmt|;
comment|// If IOException raises from FsVolumeImpl() or getVolumeMap(), there is
comment|// nothing needed to be rolled back to make various data structures, e.g.,
comment|// storageMap and asyncDiskService, consistent.
name|FsVolumeImpl
name|fsVolume
init|=
operator|new
name|FsVolumeImpl
argument_list|(
name|this
argument_list|,
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|dir
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|storageType
argument_list|)
decl_stmt|;
name|FsVolumeReference
name|ref
init|=
name|fsVolume
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
name|ReplicaMap
name|tempVolumeMap
init|=
operator|new
name|ReplicaMap
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|fsVolume
operator|.
name|getVolumeMap
argument_list|(
name|tempVolumeMap
argument_list|,
name|ramDiskReplicaTracker
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|volumeMap
operator|.
name|addAll
argument_list|(
name|tempVolumeMap
argument_list|)
expr_stmt|;
name|storageMap
operator|.
name|put
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|DatanodeStorage
operator|.
name|State
operator|.
name|NORMAL
argument_list|,
name|storageType
argument_list|)
argument_list|)
expr_stmt|;
name|asyncDiskService
operator|.
name|addVolume
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|addVolume
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Added volume - "
operator|+
name|dir
operator|+
literal|", StorageType: "
operator|+
name|storageType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|createFsVolume (String storageUuid, File currentDir, StorageType storageType)
specifier|public
name|FsVolumeImpl
name|createFsVolume
parameter_list|(
name|String
name|storageUuid
parameter_list|,
name|File
name|currentDir
parameter_list|,
name|StorageType
name|storageType
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FsVolumeImpl
argument_list|(
name|this
argument_list|,
name|storageUuid
argument_list|,
name|currentDir
argument_list|,
name|conf
argument_list|,
name|storageType
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|addVolume (final StorageLocation location, final List<NamespaceInfo> nsInfos)
specifier|public
name|void
name|addVolume
parameter_list|(
specifier|final
name|StorageLocation
name|location
parameter_list|,
specifier|final
name|List
argument_list|<
name|NamespaceInfo
argument_list|>
name|nsInfos
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|dir
init|=
name|location
operator|.
name|getFile
argument_list|()
decl_stmt|;
comment|// Prepare volume in DataStorage
specifier|final
name|DataStorage
operator|.
name|VolumeBuilder
name|builder
decl_stmt|;
try|try
block|{
name|builder
operator|=
name|dataStorage
operator|.
name|prepareVolume
argument_list|(
name|datanode
argument_list|,
name|location
operator|.
name|getFile
argument_list|()
argument_list|,
name|nsInfos
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|volumes
operator|.
name|addVolumeFailureInfo
argument_list|(
operator|new
name|VolumeFailureInfo
argument_list|(
name|location
operator|.
name|getFile
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|Time
operator|.
name|now
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
specifier|final
name|Storage
operator|.
name|StorageDirectory
name|sd
init|=
name|builder
operator|.
name|getStorageDirectory
argument_list|()
decl_stmt|;
name|StorageType
name|storageType
init|=
name|location
operator|.
name|getStorageType
argument_list|()
decl_stmt|;
specifier|final
name|FsVolumeImpl
name|fsVolume
init|=
name|createFsVolume
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|storageType
argument_list|)
decl_stmt|;
specifier|final
name|ReplicaMap
name|tempVolumeMap
init|=
operator|new
name|ReplicaMap
argument_list|(
name|fsVolume
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|NamespaceInfo
name|nsInfo
range|:
name|nsInfos
control|)
block|{
name|String
name|bpid
init|=
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
decl_stmt|;
try|try
block|{
name|fsVolume
operator|.
name|addBlockPool
argument_list|(
name|bpid
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|fsVolume
operator|.
name|getVolumeMap
argument_list|(
name|bpid
argument_list|,
name|tempVolumeMap
argument_list|,
name|ramDiskReplicaTracker
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception when adding "
operator|+
name|fsVolume
operator|+
literal|". Will throw later."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|exceptions
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|exceptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|MultipleIOException
operator|.
name|createIOException
argument_list|(
name|exceptions
argument_list|)
throw|;
block|}
specifier|final
name|FsVolumeReference
name|ref
init|=
name|fsVolume
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
name|setupAsyncLazyPersistThread
argument_list|(
name|fsVolume
argument_list|)
expr_stmt|;
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|volumeMap
operator|.
name|addAll
argument_list|(
name|tempVolumeMap
argument_list|)
expr_stmt|;
name|storageMap
operator|.
name|put
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
operator|new
name|DatanodeStorage
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|DatanodeStorage
operator|.
name|State
operator|.
name|NORMAL
argument_list|,
name|storageType
argument_list|)
argument_list|)
expr_stmt|;
name|asyncDiskService
operator|.
name|addVolume
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|addVolume
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Added volume - "
operator|+
name|dir
operator|+
literal|", StorageType: "
operator|+
name|storageType
argument_list|)
expr_stmt|;
block|}
comment|/**    * Removes a set of volumes from FsDataset.    * @param volumesToRemove a set of absolute root path of each volume.    * @param clearFailure set true to clear failure information.    *    * DataNode should call this function before calling    * {@link DataStorage#removeVolumes(java.util.Collection)}.    */
annotation|@
name|Override
DECL|method|removeVolumes ( Set<File> volumesToRemove, boolean clearFailure)
specifier|public
specifier|synchronized
name|void
name|removeVolumes
parameter_list|(
name|Set
argument_list|<
name|File
argument_list|>
name|volumesToRemove
parameter_list|,
name|boolean
name|clearFailure
parameter_list|)
block|{
comment|// Make sure that all volumes are absolute path.
for|for
control|(
name|File
name|vol
range|:
name|volumesToRemove
control|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|vol
operator|.
name|isAbsolute
argument_list|()
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"%s is not absolute path."
argument_list|,
name|vol
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|dataStorage
operator|.
name|getNumStorageDirs
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|Storage
operator|.
name|StorageDirectory
name|sd
init|=
name|dataStorage
operator|.
name|getStorageDir
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|File
name|absRoot
init|=
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|volumesToRemove
operator|.
name|contains
argument_list|(
name|absRoot
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing "
operator|+
name|absRoot
operator|+
literal|" from FsDataset."
argument_list|)
expr_stmt|;
comment|// Disable the volume from the service.
name|asyncDiskService
operator|.
name|removeVolume
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|removeVolume
argument_list|(
name|absRoot
argument_list|,
name|clearFailure
argument_list|)
expr_stmt|;
comment|// Removed all replica information for the blocks on the volume. Unlike
comment|// updating the volumeMap in addVolume(), this operation does not scan
comment|// disks.
for|for
control|(
name|String
name|bpid
range|:
name|volumeMap
operator|.
name|getBlockPoolList
argument_list|()
control|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ReplicaInfo
argument_list|>
name|it
init|=
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ReplicaInfo
name|block
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|File
name|absBasePath
init|=
operator|new
name|File
argument_list|(
name|block
operator|.
name|getVolume
argument_list|()
operator|.
name|getBasePath
argument_list|()
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|absBasePath
operator|.
name|equals
argument_list|(
name|absRoot
argument_list|)
condition|)
block|{
name|invalidate
argument_list|(
name|bpid
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|storageMap
operator|.
name|remove
argument_list|(
name|sd
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|setupAsyncLazyPersistThreads
argument_list|()
expr_stmt|;
block|}
DECL|method|getStorageTypeFromLocations ( Collection<StorageLocation> dataLocations, File dir)
specifier|private
name|StorageType
name|getStorageTypeFromLocations
parameter_list|(
name|Collection
argument_list|<
name|StorageLocation
argument_list|>
name|dataLocations
parameter_list|,
name|File
name|dir
parameter_list|)
block|{
for|for
control|(
name|StorageLocation
name|dataLocation
range|:
name|dataLocations
control|)
block|{
if|if
condition|(
name|dataLocation
operator|.
name|getFile
argument_list|()
operator|.
name|equals
argument_list|(
name|dir
argument_list|)
condition|)
block|{
return|return
name|dataLocation
operator|.
name|getStorageType
argument_list|()
return|;
block|}
block|}
return|return
name|StorageType
operator|.
name|DEFAULT
return|;
block|}
comment|/**    * Return the total space used by dfs datanode    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getDfsUsed ()
specifier|public
name|long
name|getDfsUsed
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getDfsUsed
argument_list|()
return|;
block|}
block|}
comment|/**    * Return the total space used by dfs datanode    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getBlockPoolUsed (String bpid)
specifier|public
name|long
name|getBlockPoolUsed
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getBlockPoolUsed
argument_list|(
name|bpid
argument_list|)
return|;
block|}
block|}
comment|/**    * Return true - if there are still valid volumes on the DataNode.     */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|hasEnoughResource ()
specifier|public
name|boolean
name|hasEnoughResource
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|getVolumes
argument_list|()
operator|.
name|size
argument_list|()
operator|>=
name|validVolsRequired
return|;
block|}
comment|/**    * Return total capacity, used and unused    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getCapacity ()
specifier|public
name|long
name|getCapacity
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getCapacity
argument_list|()
return|;
block|}
block|}
comment|/**    * Return how many bytes can still be stored in the FSDataset    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getRemaining ()
specifier|public
name|long
name|getRemaining
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|statsLock
init|)
block|{
return|return
name|volumes
operator|.
name|getRemaining
argument_list|()
return|;
block|}
block|}
comment|/**    * Return the number of failed volumes in the FSDataset.    */
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getNumFailedVolumes ()
specifier|public
name|int
name|getNumFailedVolumes
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
operator|.
name|length
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getFailedStorageLocations ()
specifier|public
name|String
index|[]
name|getFailedStorageLocations
parameter_list|()
block|{
name|VolumeFailureInfo
index|[]
name|infos
init|=
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|failedStorageLocations
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|infos
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|VolumeFailureInfo
name|info
range|:
name|infos
control|)
block|{
name|failedStorageLocations
operator|.
name|add
argument_list|(
name|info
operator|.
name|getFailedStorageLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|failedStorageLocations
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|failedStorageLocations
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getLastVolumeFailureDate ()
specifier|public
name|long
name|getLastVolumeFailureDate
parameter_list|()
block|{
name|long
name|lastVolumeFailureDate
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VolumeFailureInfo
name|info
range|:
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
control|)
block|{
name|long
name|failureDate
init|=
name|info
operator|.
name|getFailureDate
argument_list|()
decl_stmt|;
if|if
condition|(
name|failureDate
operator|>
name|lastVolumeFailureDate
condition|)
block|{
name|lastVolumeFailureDate
operator|=
name|failureDate
expr_stmt|;
block|}
block|}
return|return
name|lastVolumeFailureDate
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getEstimatedCapacityLostTotal ()
specifier|public
name|long
name|getEstimatedCapacityLostTotal
parameter_list|()
block|{
name|long
name|estimatedCapacityLostTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VolumeFailureInfo
name|info
range|:
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
control|)
block|{
name|estimatedCapacityLostTotal
operator|+=
name|info
operator|.
name|getEstimatedCapacityLost
argument_list|()
expr_stmt|;
block|}
return|return
name|estimatedCapacityLostTotal
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getVolumeFailureSummary ()
specifier|public
name|VolumeFailureSummary
name|getVolumeFailureSummary
parameter_list|()
block|{
name|VolumeFailureInfo
index|[]
name|infos
init|=
name|volumes
operator|.
name|getVolumeFailureInfos
argument_list|()
decl_stmt|;
if|if
condition|(
name|infos
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|failedStorageLocations
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|infos
operator|.
name|length
argument_list|)
decl_stmt|;
name|long
name|lastVolumeFailureDate
init|=
literal|0
decl_stmt|;
name|long
name|estimatedCapacityLostTotal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VolumeFailureInfo
name|info
range|:
name|infos
control|)
block|{
name|failedStorageLocations
operator|.
name|add
argument_list|(
name|info
operator|.
name|getFailedStorageLocation
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|failureDate
init|=
name|info
operator|.
name|getFailureDate
argument_list|()
decl_stmt|;
if|if
condition|(
name|failureDate
operator|>
name|lastVolumeFailureDate
condition|)
block|{
name|lastVolumeFailureDate
operator|=
name|failureDate
expr_stmt|;
block|}
name|estimatedCapacityLostTotal
operator|+=
name|info
operator|.
name|getEstimatedCapacityLost
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|VolumeFailureSummary
argument_list|(
name|failedStorageLocations
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|failedStorageLocations
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|lastVolumeFailureDate
argument_list|,
name|estimatedCapacityLostTotal
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getCacheUsed ()
specifier|public
name|long
name|getCacheUsed
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getCacheUsed
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getCacheCapacity ()
specifier|public
name|long
name|getCacheCapacity
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getCacheCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getNumBlocksFailedToCache ()
specifier|public
name|long
name|getNumBlocksFailedToCache
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getNumBlocksFailedToCache
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getNumBlocksFailedToUncache ()
specifier|public
name|long
name|getNumBlocksFailedToUncache
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getNumBlocksFailedToUncache
argument_list|()
return|;
block|}
comment|/**    * Get metrics from the metrics source    *    * @param collector to contain the resulting metrics snapshot    * @param all if true, return all metrics even if unchanged.    */
annotation|@
name|Override
DECL|method|getMetrics (MetricsCollector collector, boolean all)
specifier|public
name|void
name|getMetrics
parameter_list|(
name|MetricsCollector
name|collector
parameter_list|,
name|boolean
name|all
parameter_list|)
block|{
try|try
block|{
name|DataNodeMetricHelper
operator|.
name|getMetrics
argument_list|(
name|collector
argument_list|,
name|this
argument_list|,
literal|"FSDatasetState"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception thrown while metric collection. Exception : "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getNumBlocksCached ()
specifier|public
name|long
name|getNumBlocksCached
parameter_list|()
block|{
return|return
name|cacheManager
operator|.
name|getNumBlocksCached
argument_list|()
return|;
block|}
comment|/**    * Find the block's on-disk length    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getLength (ExtendedBlock b)
specifier|public
name|long
name|getLength
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockFile
argument_list|(
name|b
argument_list|)
operator|.
name|length
argument_list|()
return|;
block|}
comment|/**    * Get File name for a given block.    */
DECL|method|getBlockFile (ExtendedBlock b)
specifier|private
name|File
name|getBlockFile
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getBlockFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get File name for a given block.    */
DECL|method|getBlockFile (String bpid, long blockId)
name|File
name|getBlockFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|f
init|=
name|validateBlockFile
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"BlockId "
operator|+
name|blockId
operator|+
literal|" is not valid."
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
comment|/**    * Return the File associated with a block, without first    * checking that it exists. This should be used when the    * next operation is going to open the file for read anyway,    * and thus the exists check is redundant.    *    * @param touch if true then update the last access timestamp of the    *              block. Currently used for blocks on transient storage.    */
DECL|method|getBlockFileNoExistsCheck (ExtendedBlock b, boolean touch)
specifier|private
name|File
name|getBlockFileNoExistsCheck
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|boolean
name|touch
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|f
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|f
operator|=
name|getFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|touch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" is not valid"
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getBlockInputStream (ExtendedBlock b, long seekOffset)
specifier|public
name|InputStream
name|getBlockInputStream
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|seekOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|blockFile
init|=
name|getBlockFileNoExistsCheck
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNativeIOAvailable
condition|)
block|{
return|return
name|NativeIO
operator|.
name|getShareDeleteFileInputStream
argument_list|(
name|blockFile
argument_list|,
name|seekOffset
argument_list|)
return|;
block|}
else|else
block|{
try|try
block|{
return|return
name|openAndSeek
argument_list|(
name|blockFile
argument_list|,
name|seekOffset
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" is not valid. "
operator|+
literal|"Expected block file at "
operator|+
name|blockFile
operator|+
literal|" does not exist."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Get the meta info of a block stored in volumeMap. To find a block,    * block pool Id, block Id and generation stamp must match.    * @param b extended block    * @return the meta replica information    * @throws ReplicaNotFoundException if no entry is in the map or     *                        there is a generation stamp mismatch    */
DECL|method|getReplicaInfo (ExtendedBlock b)
name|ReplicaInfo
name|getReplicaInfo
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|ReplicaNotFoundException
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
comment|/**    * Get the meta info of a block stored in volumeMap. Block is looked up    * without matching the generation stamp.    * @param bpid block pool Id    * @param blkid block Id    * @return the meta replica information; null if block was not found    * @throws ReplicaNotFoundException if no entry is in the map or     *                        there is a generation stamp mismatch    */
DECL|method|getReplicaInfo (String bpid, long blkid)
specifier|private
name|ReplicaInfo
name|getReplicaInfo
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blkid
parameter_list|)
throws|throws
name|ReplicaNotFoundException
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blkid
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|bpid
operator|+
literal|":"
operator|+
name|blkid
argument_list|)
throw|;
block|}
return|return
name|info
return|;
block|}
comment|/**    * Returns handles to the block file and its metadata file    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getTmpInputStreams (ExtendedBlock b, long blkOffset, long metaOffset)
specifier|public
specifier|synchronized
name|ReplicaInputStreams
name|getTmpInputStreams
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|blkOffset
parameter_list|,
name|long
name|metaOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|info
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|FsVolumeReference
name|ref
init|=
name|info
operator|.
name|getVolume
argument_list|()
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
try|try
block|{
name|InputStream
name|blockInStream
init|=
name|openAndSeek
argument_list|(
name|info
operator|.
name|getBlockFile
argument_list|()
argument_list|,
name|blkOffset
argument_list|)
decl_stmt|;
try|try
block|{
name|InputStream
name|metaInStream
init|=
name|openAndSeek
argument_list|(
name|info
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|metaOffset
argument_list|)
decl_stmt|;
return|return
operator|new
name|ReplicaInputStreams
argument_list|(
name|blockInStream
argument_list|,
name|metaInStream
argument_list|,
name|ref
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|blockInStream
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|openAndSeek (File file, long offset)
specifier|private
specifier|static
name|FileInputStream
name|openAndSeek
parameter_list|(
name|File
name|file
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|RandomAccessFile
name|raf
init|=
literal|null
decl_stmt|;
try|try
block|{
name|raf
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|raf
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FileInputStream
argument_list|(
name|raf
operator|.
name|getFD
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|raf
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
DECL|method|moveBlockFiles (Block b, File srcfile, File destdir)
specifier|static
name|File
name|moveBlockFiles
parameter_list|(
name|Block
name|b
parameter_list|,
name|File
name|srcfile
parameter_list|,
name|File
name|destdir
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|dstfile
init|=
operator|new
name|File
argument_list|(
name|destdir
argument_list|,
name|b
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|srcmeta
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|srcfile
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dstmeta
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|dstfile
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|srcmeta
argument_list|,
name|dstmeta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move meta file for "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|srcmeta
operator|+
literal|" to "
operator|+
name|dstmeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|srcfile
argument_list|,
name|dstfile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move block file for "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|srcfile
operator|+
literal|" to "
operator|+
name|dstfile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"addFinalizedBlock: Moved "
operator|+
name|srcmeta
operator|+
literal|" to "
operator|+
name|dstmeta
operator|+
literal|" and "
operator|+
name|srcfile
operator|+
literal|" to "
operator|+
name|dstfile
argument_list|)
expr_stmt|;
block|}
return|return
name|dstfile
return|;
block|}
comment|/**    * Copy the block and meta files for the given block to the given destination.    * @return the new meta and block files.    * @throws IOException    */
DECL|method|copyBlockFiles (long blockId, long genStamp, File srcMeta, File srcFile, File destRoot, boolean calculateChecksum, int smallBufferSize)
specifier|static
name|File
index|[]
name|copyBlockFiles
parameter_list|(
name|long
name|blockId
parameter_list|,
name|long
name|genStamp
parameter_list|,
name|File
name|srcMeta
parameter_list|,
name|File
name|srcFile
parameter_list|,
name|File
name|destRoot
parameter_list|,
name|boolean
name|calculateChecksum
parameter_list|,
name|int
name|smallBufferSize
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|File
name|destDir
init|=
name|DatanodeUtil
operator|.
name|idToBlockDir
argument_list|(
name|destRoot
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dstFile
init|=
operator|new
name|File
argument_list|(
name|destDir
argument_list|,
name|srcFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dstMeta
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|dstFile
argument_list|,
name|genStamp
argument_list|)
decl_stmt|;
return|return
name|copyBlockFiles
argument_list|(
name|srcMeta
argument_list|,
name|srcFile
argument_list|,
name|dstMeta
argument_list|,
name|dstFile
argument_list|,
name|calculateChecksum
argument_list|,
name|smallBufferSize
argument_list|)
return|;
block|}
DECL|method|copyBlockFiles (File srcMeta, File srcFile, File dstMeta, File dstFile, boolean calculateChecksum, int smallBufferSize)
specifier|static
name|File
index|[]
name|copyBlockFiles
parameter_list|(
name|File
name|srcMeta
parameter_list|,
name|File
name|srcFile
parameter_list|,
name|File
name|dstMeta
parameter_list|,
name|File
name|dstFile
parameter_list|,
name|boolean
name|calculateChecksum
parameter_list|,
name|int
name|smallBufferSize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|calculateChecksum
condition|)
block|{
name|computeChecksum
argument_list|(
name|srcMeta
argument_list|,
name|dstMeta
argument_list|,
name|srcFile
argument_list|,
name|smallBufferSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|Storage
operator|.
name|nativeCopyFileUnbuffered
argument_list|(
name|srcMeta
argument_list|,
name|dstMeta
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to copy "
operator|+
name|srcMeta
operator|+
literal|" to "
operator|+
name|dstMeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|Storage
operator|.
name|nativeCopyFileUnbuffered
argument_list|(
name|srcFile
argument_list|,
name|dstFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to copy "
operator|+
name|srcFile
operator|+
literal|" to "
operator|+
name|dstFile
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|calculateChecksum
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copied "
operator|+
name|srcMeta
operator|+
literal|" to "
operator|+
name|dstMeta
operator|+
literal|" and calculated checksum"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copied "
operator|+
name|srcFile
operator|+
literal|" to "
operator|+
name|dstFile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|File
index|[]
block|{
name|dstMeta
block|,
name|dstFile
block|}
return|;
block|}
comment|/**    * Move block files from one storage to another storage.    * @return Returns the Old replicaInfo    * @throws IOException    */
annotation|@
name|Override
DECL|method|moveBlockAcrossStorage (ExtendedBlock block, StorageType targetStorageType)
specifier|public
name|ReplicaInfo
name|moveBlockAcrossStorage
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|StorageType
name|targetStorageType
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_REPLICA
operator|+
name|block
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|block
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" expected length is "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageType
argument_list|()
operator|==
name|targetStorageType
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Replica "
operator|+
name|replicaInfo
operator|+
literal|" already exists on storage "
operator|+
name|targetStorageType
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|isOnTransientStorage
argument_list|()
condition|)
block|{
comment|// Block movement from RAM_DISK will be done by LazyPersist mechanism
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Replica "
operator|+
name|replicaInfo
operator|+
literal|" cannot be moved from storageType : "
operator|+
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageType
argument_list|()
argument_list|)
throw|;
block|}
try|try
init|(
name|FsVolumeReference
name|volumeRef
init|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|targetStorageType
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
init|)
block|{
name|File
name|oldBlockFile
init|=
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
name|File
name|oldMetaFile
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
name|FsVolumeImpl
name|targetVolume
init|=
operator|(
name|FsVolumeImpl
operator|)
name|volumeRef
operator|.
name|getVolume
argument_list|()
decl_stmt|;
comment|// Copy files to temp dir first
name|File
index|[]
name|blockFiles
init|=
name|copyBlockFiles
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|block
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|oldMetaFile
argument_list|,
name|oldBlockFile
argument_list|,
name|targetVolume
operator|.
name|getTmpDir
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
argument_list|,
name|replicaInfo
operator|.
name|isOnTransientStorage
argument_list|()
argument_list|,
name|smallBufferSize
argument_list|)
decl_stmt|;
name|ReplicaInfo
name|newReplicaInfo
init|=
operator|new
name|ReplicaInPipeline
argument_list|(
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|targetVolume
argument_list|,
name|blockFiles
index|[
literal|0
index|]
operator|.
name|getParentFile
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|newReplicaInfo
operator|.
name|setNumBytes
argument_list|(
name|blockFiles
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// Finalize the copied files
name|newReplicaInfo
operator|=
name|finalizeReplica
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
name|removeOldReplica
argument_list|(
name|replicaInfo
argument_list|,
name|newReplicaInfo
argument_list|,
name|oldBlockFile
argument_list|,
name|oldMetaFile
argument_list|,
name|oldBlockFile
operator|.
name|length
argument_list|()
argument_list|,
name|oldMetaFile
operator|.
name|length
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Replace the old block if any to reschedule the scanning.
return|return
name|replicaInfo
return|;
block|}
comment|/**    * Compute and store the checksum for a block file that does not already have    * its checksum computed.    *    * @param srcMeta source meta file, containing only the checksum header, not a    *     calculated checksum    * @param dstMeta destination meta file, into which this method will write a    *     full computed checksum    * @param blockFile block file for which the checksum will be computed    * @throws IOException    */
DECL|method|computeChecksum (File srcMeta, File dstMeta, File blockFile, int smallBufferSize)
specifier|private
specifier|static
name|void
name|computeChecksum
parameter_list|(
name|File
name|srcMeta
parameter_list|,
name|File
name|dstMeta
parameter_list|,
name|File
name|blockFile
parameter_list|,
name|int
name|smallBufferSize
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DataChecksum
name|checksum
init|=
name|BlockMetadataHeader
operator|.
name|readDataChecksum
argument_list|(
name|srcMeta
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|1
operator|<<
literal|16
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|crcs
init|=
operator|new
name|byte
index|[
name|checksum
operator|.
name|getChecksumSize
argument_list|(
name|data
operator|.
name|length
argument_list|)
index|]
decl_stmt|;
name|DataOutputStream
name|metaOut
init|=
literal|null
decl_stmt|;
try|try
block|{
name|File
name|parentFile
init|=
name|dstMeta
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentFile
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|parentFile
operator|.
name|mkdirs
argument_list|()
operator|&&
operator|!
name|parentFile
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination '"
operator|+
name|parentFile
operator|+
literal|"' directory cannot be created"
argument_list|)
throw|;
block|}
block|}
name|metaOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|dstMeta
argument_list|)
argument_list|,
name|smallBufferSize
argument_list|)
argument_list|)
expr_stmt|;
name|BlockMetadataHeader
operator|.
name|writeHeader
argument_list|(
name|metaOut
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
try|try
init|(
name|InputStream
name|dataIn
init|=
name|isNativeIOAvailable
condition|?
name|NativeIO
operator|.
name|getShareDeleteFileInputStream
argument_list|(
name|blockFile
argument_list|)
else|:
operator|new
name|FileInputStream
argument_list|(
name|blockFile
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|n
init|;
operator|(
name|n
operator|=
name|dataIn
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|data
operator|.
name|length
operator|-
name|offset
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|;
control|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
name|n
operator|%
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
specifier|final
name|int
name|length
init|=
name|n
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|checksum
operator|.
name|calculateChunkedSums
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
name|crcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|metaOut
operator|.
name|write
argument_list|(
name|crcs
argument_list|,
literal|0
argument_list|,
name|checksum
operator|.
name|getChecksumSize
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// calculate and write the last crc
name|checksum
operator|.
name|calculateChunkedSums
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
name|crcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|metaOut
operator|.
name|write
argument_list|(
name|crcs
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|metaOut
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|truncateBlock (File blockFile, File metaFile, long oldlen, long newlen)
specifier|static
specifier|private
name|void
name|truncateBlock
parameter_list|(
name|File
name|blockFile
parameter_list|,
name|File
name|metaFile
parameter_list|,
name|long
name|oldlen
parameter_list|,
name|long
name|newlen
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"truncateBlock: blockFile="
operator|+
name|blockFile
operator|+
literal|", metaFile="
operator|+
name|metaFile
operator|+
literal|", oldlen="
operator|+
name|oldlen
operator|+
literal|", newlen="
operator|+
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|==
name|oldlen
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|newlen
operator|>
name|oldlen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot truncate block to from oldlen (="
operator|+
name|oldlen
operator|+
literal|") to newlen (="
operator|+
name|newlen
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|DataChecksum
name|dcs
init|=
name|BlockMetadataHeader
operator|.
name|readHeader
argument_list|(
name|metaFile
argument_list|)
operator|.
name|getChecksum
argument_list|()
decl_stmt|;
name|int
name|checksumsize
init|=
name|dcs
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
name|int
name|bpc
init|=
name|dcs
operator|.
name|getBytesPerChecksum
argument_list|()
decl_stmt|;
name|long
name|n
init|=
operator|(
name|newlen
operator|-
literal|1
operator|)
operator|/
name|bpc
operator|+
literal|1
decl_stmt|;
name|long
name|newmetalen
init|=
name|BlockMetadataHeader
operator|.
name|getHeaderSize
argument_list|()
operator|+
name|n
operator|*
name|checksumsize
decl_stmt|;
name|long
name|lastchunkoffset
init|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
name|bpc
decl_stmt|;
name|int
name|lastchunksize
init|=
call|(
name|int
call|)
argument_list|(
name|newlen
operator|-
name|lastchunkoffset
argument_list|)
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|Math
operator|.
name|max
argument_list|(
name|lastchunksize
argument_list|,
name|checksumsize
argument_list|)
index|]
decl_stmt|;
name|RandomAccessFile
name|blockRAF
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|blockFile
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
try|try
block|{
comment|//truncate blockFile
name|blockRAF
operator|.
name|setLength
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
comment|//read last chunk
name|blockRAF
operator|.
name|seek
argument_list|(
name|lastchunkoffset
argument_list|)
expr_stmt|;
name|blockRAF
operator|.
name|readFully
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|lastchunksize
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|blockRAF
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|//compute checksum
name|dcs
operator|.
name|update
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|lastchunksize
argument_list|)
expr_stmt|;
name|dcs
operator|.
name|writeValue
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//update metaFile
name|RandomAccessFile
name|metaRAF
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|metaFile
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
try|try
block|{
name|metaRAF
operator|.
name|setLength
argument_list|(
name|newmetalen
argument_list|)
expr_stmt|;
name|metaRAF
operator|.
name|seek
argument_list|(
name|newmetalen
operator|-
name|checksumsize
argument_list|)
expr_stmt|;
name|metaRAF
operator|.
name|write
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|checksumsize
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|metaRAF
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|append (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
specifier|synchronized
name|ReplicaHandler
name|append
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If the block was successfully finalized because all packets
comment|// were successfully processed at the Datanode but the ack for
comment|// some of the packets were not received by the client. The client
comment|// re-opens the connection and retries sending those packets.
comment|// The other reason is that an "append" is occurring to this block.
comment|// check the validity of the parameter
if|if
condition|(
name|newGS
operator|<
name|b
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The new generation stamp "
operator|+
name|newGS
operator|+
literal|" should be greater than the replica "
operator|+
name|b
operator|+
literal|"'s generation stamp"
argument_list|)
throw|;
block|}
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Appending to "
operator|+
name|replicaInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|expectedBlockLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" expected length is "
operator|+
name|expectedBlockLen
argument_list|)
throw|;
block|}
name|FsVolumeReference
name|ref
init|=
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
name|ReplicaBeingWritten
name|replica
init|=
literal|null
decl_stmt|;
try|try
block|{
name|replica
operator|=
name|append
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
name|FinalizedReplica
operator|)
name|replicaInfo
argument_list|,
name|newGS
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|replica
argument_list|,
name|ref
argument_list|)
return|;
block|}
comment|/** Append to a finalized replica    * Change a finalized replica to be a RBW replica and     * bump its generation stamp to be the newGS    *     * @param bpid block pool Id    * @param replicaInfo a finalized replica    * @param newGS new generation stamp    * @param estimateBlockLen estimate block length    * @return a RBW replica    * @throws IOException if moving the replica from finalized directory     *         to rbw directory fails    */
DECL|method|append (String bpid, FinalizedReplica replicaInfo, long newGS, long estimateBlockLen)
specifier|private
specifier|synchronized
name|ReplicaBeingWritten
name|append
parameter_list|(
name|String
name|bpid
parameter_list|,
name|FinalizedReplica
name|replicaInfo
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|estimateBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If the block is cached, start uncaching it.
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
comment|// unlink the finalized replica
name|replicaInfo
operator|.
name|unlinkBlock
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// construct a RBW replica with the new GS
name|File
name|blkfile
init|=
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|replicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|getAvailable
argument_list|()
operator|<
name|estimateBlockLen
operator|-
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DiskOutOfSpaceException
argument_list|(
literal|"Insufficient space for appending to "
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|File
name|newBlkFile
init|=
operator|new
name|File
argument_list|(
name|v
operator|.
name|getRbwDir
argument_list|(
name|bpid
argument_list|)
argument_list|,
name|replicaInfo
operator|.
name|getBlockName
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|oldmeta
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
name|ReplicaBeingWritten
name|newReplicaInfo
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|newGS
argument_list|,
name|v
argument_list|,
name|newBlkFile
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|estimateBlockLen
argument_list|)
decl_stmt|;
name|File
name|newmeta
init|=
name|newReplicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
comment|// rename meta file to rbw directory
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|oldmeta
argument_list|,
name|newmeta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|replicaInfo
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move meta file  "
operator|+
name|oldmeta
operator|+
literal|" to rbw dir "
operator|+
name|newmeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// rename block file to rbw directory
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|blkfile
operator|+
literal|" to "
operator|+
name|newBlkFile
operator|+
literal|", file length="
operator|+
name|blkfile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|blkfile
argument_list|,
name|newBlkFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|newmeta
argument_list|,
name|oldmeta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot move meta file "
operator|+
name|newmeta
operator|+
literal|"back to the finalized directory "
operator|+
name|oldmeta
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|replicaInfo
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move block file "
operator|+
name|blkfile
operator|+
literal|" to rbw dir "
operator|+
name|newBlkFile
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// Replace finalized replica by a RBW replica in replicas map
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
name|v
operator|.
name|reserveSpaceForRbw
argument_list|(
name|estimateBlockLen
operator|-
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
DECL|method|recoverCheck (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|private
name|ReplicaInfo
name|recoverCheck
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
comment|// check state
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNFINALIZED_AND_NONRBW_REPLICA
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
comment|// check generation stamp
name|long
name|replicaGenerationStamp
init|=
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaGenerationStamp
argument_list|<
name|b
operator|.
name|getGenerationStamp
operator|(
operator|)
operator|||
name|replicaGenerationStamp
argument_list|>
name|newGS
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNEXPECTED_GS_REPLICA
operator|+
name|replicaGenerationStamp
operator|+
literal|". Expected GS range is ["
operator|+
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", "
operator|+
name|newGS
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// stop the previous writer before check a replica's length
name|long
name|replicaLen
init|=
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
name|ReplicaBeingWritten
name|rbw
init|=
operator|(
name|ReplicaBeingWritten
operator|)
name|replicaInfo
decl_stmt|;
comment|// kill the previous writer
name|rbw
operator|.
name|stopWriter
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setWriter
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|// check length: bytesRcvd, bytesOnDisk, and bytesAcked should be the same
if|if
condition|(
name|replicaLen
operator|!=
name|rbw
operator|.
name|getBytesOnDisk
argument_list|()
operator|||
name|replicaLen
operator|!=
name|rbw
operator|.
name|getBytesAcked
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"RBW replica "
operator|+
name|replicaInfo
operator|+
literal|"bytesRcvd("
operator|+
name|rbw
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|"), bytesOnDisk("
operator|+
name|rbw
operator|.
name|getBytesOnDisk
argument_list|()
operator|+
literal|"), and bytesAcked("
operator|+
name|rbw
operator|.
name|getBytesAcked
argument_list|()
operator|+
literal|") are not the same."
argument_list|)
throw|;
block|}
block|}
comment|// check block length
if|if
condition|(
name|replicaLen
operator|!=
name|expectedBlockLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupted replica "
operator|+
name|replicaInfo
operator|+
literal|" with a length of "
operator|+
name|replicaLen
operator|+
literal|" expected length is "
operator|+
name|expectedBlockLen
argument_list|)
throw|;
block|}
return|return
name|replicaInfo
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|recoverAppend ( ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
specifier|synchronized
name|ReplicaHandler
name|recoverAppend
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover failed append to "
operator|+
name|b
argument_list|)
expr_stmt|;
name|ReplicaInfo
name|replicaInfo
init|=
name|recoverCheck
argument_list|(
name|b
argument_list|,
name|newGS
argument_list|,
name|expectedBlockLen
argument_list|)
decl_stmt|;
name|FsVolumeReference
name|ref
init|=
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
name|ReplicaBeingWritten
name|replica
decl_stmt|;
try|try
block|{
comment|// change the replica's state/gs etc.
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|replica
operator|=
name|append
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
name|FinalizedReplica
operator|)
name|replicaInfo
argument_list|,
name|newGS
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//RBW
name|bumpReplicaGS
argument_list|(
name|replicaInfo
argument_list|,
name|newGS
argument_list|)
expr_stmt|;
name|replica
operator|=
operator|(
name|ReplicaBeingWritten
operator|)
name|replicaInfo
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|replica
argument_list|,
name|ref
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|recoverClose (ExtendedBlock b, long newGS, long expectedBlockLen)
specifier|public
specifier|synchronized
name|String
name|recoverClose
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|expectedBlockLen
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover failed close "
operator|+
name|b
argument_list|)
expr_stmt|;
comment|// check replica's state
name|ReplicaInfo
name|replicaInfo
init|=
name|recoverCheck
argument_list|(
name|b
argument_list|,
name|newGS
argument_list|,
name|expectedBlockLen
argument_list|)
decl_stmt|;
comment|// bump the replica's GS
name|bumpReplicaGS
argument_list|(
name|replicaInfo
argument_list|,
name|newGS
argument_list|)
expr_stmt|;
comment|// finalize the replica if RBW
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
name|finalizeReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|replicaInfo
operator|.
name|getStorageUuid
argument_list|()
return|;
block|}
comment|/**    * Bump a replica's generation stamp to a new one.    * Its on-disk meta file name is renamed to be the new one too.    *     * @param replicaInfo a replica    * @param newGS new generation stamp    * @throws IOException if rename fails    */
DECL|method|bumpReplicaGS (ReplicaInfo replicaInfo, long newGS)
specifier|private
name|void
name|bumpReplicaGS
parameter_list|(
name|ReplicaInfo
name|replicaInfo
parameter_list|,
name|long
name|newGS
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|oldGS
init|=
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
name|File
name|oldmeta
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
name|replicaInfo
operator|.
name|setGenerationStamp
argument_list|(
name|newGS
argument_list|)
expr_stmt|;
name|File
name|newmeta
init|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
decl_stmt|;
comment|// rename meta file to new GS
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|NativeIO
operator|.
name|renameTo
argument_list|(
name|oldmeta
argument_list|,
name|newmeta
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|replicaInfo
operator|.
name|setGenerationStamp
argument_list|(
name|oldGS
argument_list|)
expr_stmt|;
comment|// restore old GS
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block "
operator|+
name|replicaInfo
operator|+
literal|" reopen failed. "
operator|+
literal|" Unable to move meta file  "
operator|+
name|oldmeta
operator|+
literal|" to "
operator|+
name|newmeta
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|createRbw ( StorageType storageType, ExtendedBlock b, boolean allowLazyPersist)
specifier|public
specifier|synchronized
name|ReplicaHandler
name|createRbw
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|,
name|boolean
name|allowLazyPersist
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" already exists in state "
operator|+
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|+
literal|" and thus cannot be created."
argument_list|)
throw|;
block|}
comment|// create a new block
name|FsVolumeReference
name|ref
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
if|if
condition|(
name|allowLazyPersist
condition|)
block|{
comment|// First try to place the block on a transient volume.
name|ref
operator|=
name|volumes
operator|.
name|getNextTransientVolume
argument_list|(
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksWrite
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ref
operator|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|storageType
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DiskOutOfSpaceException
name|de
parameter_list|)
block|{
if|if
condition|(
name|allowLazyPersist
condition|)
block|{
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksWriteFallback
argument_list|()
expr_stmt|;
name|allowLazyPersist
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
throw|throw
name|de
throw|;
block|}
break|break;
block|}
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|ref
operator|.
name|getVolume
argument_list|()
decl_stmt|;
comment|// create an rbw file to hold block in the designated volume
name|File
name|f
decl_stmt|;
try|try
block|{
name|f
operator|=
name|v
operator|.
name|createRbwFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|ReplicaBeingWritten
name|newReplicaInfo
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|v
argument_list|,
name|f
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|newReplicaInfo
argument_list|,
name|ref
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|recoverRbw ( ExtendedBlock b, long newGS, long minBytesRcvd, long maxBytesRcvd)
specifier|public
specifier|synchronized
name|ReplicaHandler
name|recoverRbw
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|newGS
parameter_list|,
name|long
name|minBytesRcvd
parameter_list|,
name|long
name|maxBytesRcvd
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recover RBW replica "
operator|+
name|b
argument_list|)
expr_stmt|;
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
comment|// check the replica's state
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RBW
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_RBW_REPLICA
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|ReplicaBeingWritten
name|rbw
init|=
operator|(
name|ReplicaBeingWritten
operator|)
name|replicaInfo
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Recovering "
operator|+
name|rbw
argument_list|)
expr_stmt|;
comment|// Stop the previous writer
name|rbw
operator|.
name|stopWriter
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setWriter
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|// check generation stamp
name|long
name|replicaGenerationStamp
init|=
name|rbw
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaGenerationStamp
argument_list|<
name|b
operator|.
name|getGenerationStamp
operator|(
operator|)
operator|||
name|replicaGenerationStamp
argument_list|>
name|newGS
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|UNEXPECTED_GS_REPLICA
operator|+
name|b
operator|+
literal|". Expected GS range is ["
operator|+
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", "
operator|+
name|newGS
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// check replica length
name|long
name|bytesAcked
init|=
name|rbw
operator|.
name|getBytesAcked
argument_list|()
decl_stmt|;
name|long
name|numBytes
init|=
name|rbw
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesAcked
argument_list|<
name|minBytesRcvd
operator|||
name|numBytes
argument_list|>
name|maxBytesRcvd
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
literal|"Unmatched length replica "
operator|+
name|replicaInfo
operator|+
literal|": BytesAcked = "
operator|+
name|bytesAcked
operator|+
literal|" BytesRcvd = "
operator|+
name|numBytes
operator|+
literal|" are not in the range of ["
operator|+
name|minBytesRcvd
operator|+
literal|", "
operator|+
name|maxBytesRcvd
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|FsVolumeReference
name|ref
init|=
name|rbw
operator|.
name|getVolume
argument_list|()
operator|.
name|obtainReference
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Truncate the potentially corrupt portion.
comment|// If the source was client and the last node in the pipeline was lost,
comment|// any corrupt data written after the acked length can go unnoticed.
if|if
condition|(
name|numBytes
operator|>
name|bytesAcked
condition|)
block|{
specifier|final
name|File
name|replicafile
init|=
name|rbw
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
name|truncateBlock
argument_list|(
name|replicafile
argument_list|,
name|rbw
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|numBytes
argument_list|,
name|bytesAcked
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setNumBytes
argument_list|(
name|bytesAcked
argument_list|)
expr_stmt|;
name|rbw
operator|.
name|setLastChecksumAndDataLen
argument_list|(
name|bytesAcked
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// bump the replica's generation stamp to newGS
name|bumpReplicaGS
argument_list|(
name|rbw
argument_list|,
name|newGS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|rbw
argument_list|,
name|ref
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|convertTemporaryToRbw ( final ExtendedBlock b)
specifier|public
specifier|synchronized
name|ReplicaInPipeline
name|convertTemporaryToRbw
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|blockId
init|=
name|b
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
specifier|final
name|long
name|expectedGs
init|=
name|b
operator|.
name|getGenerationStamp
argument_list|()
decl_stmt|;
specifier|final
name|long
name|visible
init|=
name|b
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Convert "
operator|+
name|b
operator|+
literal|" from Temporary to RBW, visible length="
operator|+
name|visible
argument_list|)
expr_stmt|;
specifier|final
name|ReplicaInPipeline
name|temp
decl_stmt|;
block|{
comment|// get replica
specifier|final
name|ReplicaInfo
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|ReplicaNotFoundException
operator|.
name|NON_EXISTENT_REPLICA
operator|+
name|b
argument_list|)
throw|;
block|}
comment|// check the replica's state
if|if
condition|(
name|r
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|TEMPORARY
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"r.getState() != ReplicaState.TEMPORARY, r="
operator|+
name|r
argument_list|)
throw|;
block|}
name|temp
operator|=
operator|(
name|ReplicaInPipeline
operator|)
name|r
expr_stmt|;
block|}
comment|// check generation stamp
if|if
condition|(
name|temp
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|expectedGs
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"temp.getGenerationStamp() != expectedGs = "
operator|+
name|expectedGs
operator|+
literal|", temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// TODO: check writer?
comment|// set writer to the current thread
comment|// temp.setWriter(Thread.currentThread());
comment|// check length
specifier|final
name|long
name|numBytes
init|=
name|temp
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBytes
operator|<
name|visible
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|numBytes
operator|+
literal|" = numBytes< visible = "
operator|+
name|visible
operator|+
literal|", temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// check volume
specifier|final
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|temp
operator|.
name|getVolume
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"r.getVolume() = null, temp="
operator|+
name|temp
argument_list|)
throw|;
block|}
comment|// move block files to the rbw directory
name|BlockPoolSlice
name|bpslice
init|=
name|v
operator|.
name|getBlockPoolSlice
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dest
init|=
name|moveBlockFiles
argument_list|(
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|temp
operator|.
name|getBlockFile
argument_list|()
argument_list|,
name|bpslice
operator|.
name|getRbwDir
argument_list|()
argument_list|)
decl_stmt|;
comment|// create RBW
specifier|final
name|ReplicaBeingWritten
name|rbw
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|blockId
argument_list|,
name|numBytes
argument_list|,
name|expectedGs
argument_list|,
name|v
argument_list|,
name|dest
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rbw
operator|.
name|setBytesAcked
argument_list|(
name|visible
argument_list|)
expr_stmt|;
comment|// overwrite the RBW in the volume map
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|rbw
argument_list|)
expr_stmt|;
return|return
name|rbw
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|createTemporary ( StorageType storageType, ExtendedBlock b)
specifier|public
name|ReplicaHandler
name|createTemporary
parameter_list|(
name|StorageType
name|storageType
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startTimeMs
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|writerStopTimeoutMs
init|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
decl_stmt|;
name|ReplicaInfo
name|lastFoundReplicaInfo
init|=
literal|null
decl_stmt|;
do|do
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|ReplicaInfo
name|currentReplicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentReplicaInfo
operator|==
name|lastFoundReplicaInfo
condition|)
block|{
if|if
condition|(
name|lastFoundReplicaInfo
operator|!=
literal|null
condition|)
block|{
name|invalidate
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|new
name|Block
index|[]
block|{
name|lastFoundReplicaInfo
block|}
argument_list|)
expr_stmt|;
block|}
name|FsVolumeReference
name|ref
init|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|storageType
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|)
decl_stmt|;
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|ref
operator|.
name|getVolume
argument_list|()
decl_stmt|;
comment|// create a temporary file to hold block in the designated volume
name|File
name|f
decl_stmt|;
try|try
block|{
name|f
operator|=
name|v
operator|.
name|createTmpFile
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|ReplicaInPipeline
name|newReplicaInfo
init|=
operator|new
name|ReplicaInPipeline
argument_list|(
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|b
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|v
argument_list|,
name|f
operator|.
name|getParentFile
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
operator|new
name|ReplicaHandler
argument_list|(
name|newReplicaInfo
argument_list|,
name|ref
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|currentReplicaInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|b
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|currentReplicaInfo
operator|instanceof
name|ReplicaInPipeline
operator|)
condition|)
block|{
throw|throw
operator|new
name|ReplicaAlreadyExistsException
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" already exists in state "
operator|+
name|currentReplicaInfo
operator|.
name|getState
argument_list|()
operator|+
literal|" and thus cannot be created."
argument_list|)
throw|;
block|}
name|lastFoundReplicaInfo
operator|=
name|currentReplicaInfo
expr_stmt|;
block|}
block|}
comment|// Hang too long, just bail out. This is not supposed to happen.
name|long
name|writerStopMs
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTimeMs
decl_stmt|;
if|if
condition|(
name|writerStopMs
operator|>
name|writerStopTimeoutMs
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to stop existing writer for block "
operator|+
name|b
operator|+
literal|" after "
operator|+
name|writerStopMs
operator|+
literal|" miniseconds."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to stop existing writer for block "
operator|+
name|b
operator|+
literal|" after "
operator|+
name|writerStopMs
operator|+
literal|" miniseconds."
argument_list|)
throw|;
block|}
comment|// Stop the previous writer
operator|(
operator|(
name|ReplicaInPipeline
operator|)
name|lastFoundReplicaInfo
operator|)
operator|.
name|stopWriter
argument_list|(
name|writerStopTimeoutMs
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
comment|/**    * Sets the offset in the meta file so that the    * last checksum will be overwritten.    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|adjustCrcChannelPosition (ExtendedBlock b, ReplicaOutputStreams streams, int checksumSize)
specifier|public
name|void
name|adjustCrcChannelPosition
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|ReplicaOutputStreams
name|streams
parameter_list|,
name|int
name|checksumSize
parameter_list|)
throws|throws
name|IOException
block|{
name|FileOutputStream
name|file
init|=
operator|(
name|FileOutputStream
operator|)
name|streams
operator|.
name|getChecksumOut
argument_list|()
decl_stmt|;
name|FileChannel
name|channel
init|=
name|file
operator|.
name|getChannel
argument_list|()
decl_stmt|;
name|long
name|oldPos
init|=
name|channel
operator|.
name|position
argument_list|()
decl_stmt|;
name|long
name|newPos
init|=
name|oldPos
operator|-
name|checksumSize
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Changing meta file offset of block "
operator|+
name|b
operator|+
literal|" from "
operator|+
name|oldPos
operator|+
literal|" to "
operator|+
name|newPos
argument_list|)
expr_stmt|;
block|}
name|channel
operator|.
name|position
argument_list|(
name|newPos
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// REMIND - mjc - eventually we should have a timeout system
comment|// in place to clean up block files left by abandoned clients.
comment|// We should have some timer in place, so that if a blockfile
comment|// is created but non-valid, and has been idle for>48 hours,
comment|// we can GC it safely.
comment|//
comment|/**    * Complete the block write!    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|finalizeBlock (ExtendedBlock b)
specifier|public
specifier|synchronized
name|void
name|finalizeBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// Don't allow data modifications from interrupted threads
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot finalize block from Interrupted Thread"
argument_list|)
throw|;
block|}
name|ReplicaInfo
name|replicaInfo
init|=
name|getReplicaInfo
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
comment|// this is legal, when recovery happens on a file that has
comment|// been opened for append but never modified
return|return;
block|}
name|finalizeReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
argument_list|)
expr_stmt|;
block|}
DECL|method|finalizeReplica (String bpid, ReplicaInfo replicaInfo)
specifier|private
specifier|synchronized
name|FinalizedReplica
name|finalizeReplica
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaInfo
name|replicaInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|FinalizedReplica
name|newReplicaInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RUR
operator|&&
operator|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|replicaInfo
operator|)
operator|.
name|getOriginalReplica
argument_list|()
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|newReplicaInfo
operator|=
call|(
name|FinalizedReplica
call|)
argument_list|(
operator|(
name|ReplicaUnderRecovery
operator|)
name|replicaInfo
argument_list|)
operator|.
name|getOriginalReplica
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|replicaInfo
operator|.
name|getVolume
argument_list|()
decl_stmt|;
name|File
name|f
init|=
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No volume for temporary file "
operator|+
name|f
operator|+
literal|" for block "
operator|+
name|replicaInfo
argument_list|)
throw|;
block|}
name|File
name|dest
init|=
name|v
operator|.
name|addFinalizedBlock
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
argument_list|,
name|f
argument_list|,
name|replicaInfo
operator|.
name|getBytesReserved
argument_list|()
argument_list|)
decl_stmt|;
name|newReplicaInfo
operator|=
operator|new
name|FinalizedReplica
argument_list|(
name|replicaInfo
argument_list|,
name|v
argument_list|,
name|dest
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|ramDiskReplicaTracker
operator|.
name|addReplica
argument_list|(
name|bpid
argument_list|,
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|addRamDiskBytesWrite
argument_list|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
return|return
name|newReplicaInfo
return|;
block|}
comment|/**    * Remove the temporary block file (if any)    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|unfinalizeBlock (ExtendedBlock b)
specifier|public
specifier|synchronized
name|void
name|unfinalizeBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
operator|&&
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|TEMPORARY
condition|)
block|{
comment|// remove from volumeMap
name|volumeMap
operator|.
name|remove
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
comment|// delete the on-disk temp file
if|if
condition|(
name|delBlockFromDisk
argument_list|(
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block "
operator|+
name|b
operator|+
literal|" unfinalized and removed. "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|ramDiskReplicaTracker
operator|.
name|discardReplica
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove a block from disk    * @param blockFile block file    * @param metaFile block meta file    * @param b a block    * @return true if on-disk files are deleted; false otherwise    */
DECL|method|delBlockFromDisk (File blockFile, File metaFile, Block b)
specifier|private
name|boolean
name|delBlockFromDisk
parameter_list|(
name|File
name|blockFile
parameter_list|,
name|File
name|metaFile
parameter_list|,
name|Block
name|b
parameter_list|)
block|{
if|if
condition|(
name|blockFile
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No file exists for block: "
operator|+
name|b
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|blockFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to delete the block file: "
operator|+
name|blockFile
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// remove the meta file
if|if
condition|(
name|metaFile
operator|!=
literal|null
operator|&&
operator|!
name|metaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to delete the meta block file: "
operator|+
name|metaFile
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getCacheReport (String bpid)
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getCacheReport
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
return|return
name|cacheManager
operator|.
name|getCachedBlocks
argument_list|(
name|bpid
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getBlockReports (String bpid)
specifier|public
name|Map
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|getBlockReports
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|Map
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|blockReportsMap
init|=
operator|new
name|HashMap
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|BlockListAsLongs
operator|.
name|Builder
argument_list|>
name|builders
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BlockListAsLongs
operator|.
name|Builder
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|curVolumes
init|=
name|volumes
operator|.
name|getVolumes
argument_list|()
decl_stmt|;
for|for
control|(
name|FsVolumeSpi
name|v
range|:
name|curVolumes
control|)
block|{
name|builders
operator|.
name|put
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|BlockListAsLongs
operator|.
name|builder
argument_list|()
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|ReplicaInfo
name|b
range|:
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
control|)
block|{
switch|switch
condition|(
name|b
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|FINALIZED
case|:
case|case
name|RBW
case|:
case|case
name|RWR
case|:
name|builders
operator|.
name|get
argument_list|(
name|b
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUR
case|:
name|ReplicaUnderRecovery
name|rur
init|=
operator|(
name|ReplicaUnderRecovery
operator|)
name|b
decl_stmt|;
name|builders
operator|.
name|get
argument_list|(
name|rur
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|rur
operator|.
name|getOriginalReplica
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPORARY
case|:
break|break;
default|default:
assert|assert
literal|false
operator|:
literal|"Illegal ReplicaInfo state."
assert|;
block|}
block|}
block|}
for|for
control|(
name|FsVolumeImpl
name|v
range|:
name|curVolumes
control|)
block|{
name|blockReportsMap
operator|.
name|put
argument_list|(
name|v
operator|.
name|toDatanodeStorage
argument_list|()
argument_list|,
name|builders
operator|.
name|get
argument_list|(
name|v
operator|.
name|getStorageID
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|blockReportsMap
return|;
block|}
comment|/**    * Get the list of finalized blocks from in-memory blockmap for a block pool.    */
annotation|@
name|Override
DECL|method|getFinalizedBlocks (String bpid)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|FinalizedReplica
argument_list|>
name|getFinalizedBlocks
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|FinalizedReplica
argument_list|>
name|finalized
init|=
operator|new
name|ArrayList
argument_list|<
name|FinalizedReplica
argument_list|>
argument_list|(
name|volumeMap
operator|.
name|size
argument_list|(
name|bpid
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|ReplicaInfo
name|b
range|:
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
control|)
block|{
if|if
condition|(
name|b
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|finalized
operator|.
name|add
argument_list|(
operator|new
name|FinalizedReplica
argument_list|(
operator|(
name|FinalizedReplica
operator|)
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|finalized
return|;
block|}
comment|/**    * Get the list of finalized blocks from in-memory blockmap for a block pool.    */
annotation|@
name|Override
DECL|method|getFinalizedBlocksOnPersistentStorage (String bpid)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|FinalizedReplica
argument_list|>
name|getFinalizedBlocksOnPersistentStorage
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|FinalizedReplica
argument_list|>
name|finalized
init|=
operator|new
name|ArrayList
argument_list|<
name|FinalizedReplica
argument_list|>
argument_list|(
name|volumeMap
operator|.
name|size
argument_list|(
name|bpid
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|ReplicaInfo
name|b
range|:
name|volumeMap
operator|.
name|replicas
argument_list|(
name|bpid
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|b
operator|.
name|getVolume
argument_list|()
operator|.
name|isTransientStorage
argument_list|()
operator|&&
name|b
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|finalized
operator|.
name|add
argument_list|(
operator|new
name|FinalizedReplica
argument_list|(
operator|(
name|FinalizedReplica
operator|)
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|finalized
return|;
block|}
comment|/**    * Check if a block is valid.    *    * @param b           The block to check.    * @param minLength   The minimum length that the block must have.  May be 0.    * @param state       If this is null, it is ignored.  If it is non-null, we    *                        will check that the replica has this state.    *    * @throws ReplicaNotFoundException          If the replica is not found     *    * @throws UnexpectedReplicaStateException   If the replica is not in the     *                                             expected state.    * @throws FileNotFoundException             If the block file is not found or there    *                                              was an error locating it.    * @throws EOFException                      If the replica length is too short.    *     * @throws IOException                       May be thrown from the methods called.     */
DECL|method|checkBlock (ExtendedBlock b, long minLength, ReplicaState state)
specifier|public
name|void
name|checkBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|,
name|long
name|minLength
parameter_list|,
name|ReplicaState
name|state
parameter_list|)
throws|throws
name|ReplicaNotFoundException
throws|,
name|UnexpectedReplicaStateException
throws|,
name|FileNotFoundException
throws|,
name|EOFException
throws|,
name|IOException
block|{
specifier|final
name|ReplicaInfo
name|replicaInfo
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|b
argument_list|)
throw|;
block|}
if|if
condition|(
name|replicaInfo
operator|.
name|getState
argument_list|()
operator|!=
name|state
condition|)
block|{
throw|throw
operator|new
name|UnexpectedReplicaStateException
argument_list|(
name|b
argument_list|,
name|state
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
name|long
name|onDiskLength
init|=
name|getLength
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|onDiskLength
operator|<
name|minLength
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|b
operator|+
literal|"'s on-disk length "
operator|+
name|onDiskLength
operator|+
literal|" is shorter than minLength "
operator|+
name|minLength
argument_list|)
throw|;
block|}
block|}
comment|/**    * Check whether the given block is a valid one.    * valid means finalized    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|isValidBlock (ExtendedBlock b)
specifier|public
name|boolean
name|isValidBlock
parameter_list|(
name|ExtendedBlock
name|b
parameter_list|)
block|{
return|return
name|isValid
argument_list|(
name|b
argument_list|,
name|ReplicaState
operator|.
name|FINALIZED
argument_list|)
return|;
block|}
comment|/**    * Check whether the given block is a valid RBW.    */
annotation|@
name|Override
comment|// {@link FsDatasetSpi}
DECL|method|isValidRbw (final ExtendedBlock b)
specifier|public
name|boolean
name|isValidRbw
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|)
block|{
return|return
name|isValid
argument_list|(
name|b
argument_list|,
name|ReplicaState
operator|.
name|RBW
argument_list|)
return|;
block|}
comment|/** Does the block exist and have the given state? */
DECL|method|isValid (final ExtendedBlock b, final ReplicaState state)
specifier|private
name|boolean
name|isValid
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|,
specifier|final
name|ReplicaState
name|state
parameter_list|)
block|{
try|try
block|{
name|checkBlock
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Find the file corresponding to the block and return it if it exists.    */
DECL|method|validateBlockFile (String bpid, long blockId)
name|File
name|validateBlockFile
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
comment|//Should we check for metadata file too?
specifier|final
name|File
name|f
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|f
operator|=
name|getFile
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
return|return
name|f
return|;
comment|// if file is not null, but doesn't exist - possibly disk failed
name|datanode
operator|.
name|checkDiskErrorAsync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"blockId="
operator|+
name|blockId
operator|+
literal|", f="
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Check the files of a replica. */
DECL|method|checkReplicaFiles (final ReplicaInfo r)
specifier|static
name|void
name|checkReplicaFiles
parameter_list|(
specifier|final
name|ReplicaInfo
name|r
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check replica's file
specifier|final
name|File
name|f
init|=
name|r
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"File "
operator|+
name|f
operator|+
literal|" not found, r="
operator|+
name|r
argument_list|)
throw|;
block|}
if|if
condition|(
name|r
operator|.
name|getBytesOnDisk
argument_list|()
operator|!=
name|f
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File length mismatched.  The length of "
operator|+
name|f
operator|+
literal|" is "
operator|+
name|f
operator|.
name|length
argument_list|()
operator|+
literal|" but r="
operator|+
name|r
argument_list|)
throw|;
block|}
comment|//check replica's meta file
specifier|final
name|File
name|metafile
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|f
argument_list|,
name|r
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|metafile
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Metafile "
operator|+
name|metafile
operator|+
literal|" does not exist, r="
operator|+
name|r
argument_list|)
throw|;
block|}
if|if
condition|(
name|metafile
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Metafile "
operator|+
name|metafile
operator|+
literal|" is empty, r="
operator|+
name|r
argument_list|)
throw|;
block|}
block|}
comment|/**    * We're informed that a block is no longer valid.  We    * could lazily garbage-collect the block, but why bother?    * just get rid of it.    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|invalidate (String bpid, Block invalidBlks[])
specifier|public
name|void
name|invalidate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Block
name|invalidBlks
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|errors
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|invalidBlks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|File
name|f
decl_stmt|;
specifier|final
name|FsVolumeImpl
name|v
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
specifier|final
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
comment|// It is okay if the block is not found -- it may be deleted earlier.
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|": ReplicaInfo not found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
name|errors
operator|.
name|add
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|": GenerationStamp not matched, info="
operator|+
name|info
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|f
operator|=
name|info
operator|.
name|getBlockFile
argument_list|()
expr_stmt|;
name|v
operator|=
operator|(
name|FsVolumeImpl
operator|)
name|info
operator|.
name|getVolume
argument_list|()
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|errors
operator|.
name|add
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". No volume for this replica, file="
operator|+
name|f
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|File
name|parent
init|=
name|f
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
name|errors
operator|.
name|add
argument_list|(
literal|"Failed to delete replica "
operator|+
name|invalidBlks
index|[
name|i
index|]
operator|+
literal|". Parent not found for file "
operator|+
name|f
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ReplicaInfo
name|removing
init|=
name|volumeMap
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|addDeletingBlock
argument_list|(
name|bpid
argument_list|,
name|removing
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block file "
operator|+
name|removing
operator|.
name|getBlockFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is to be deleted"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|RamDiskReplica
name|replicaInfo
init|=
name|ramDiskReplicaTracker
operator|.
name|getReplica
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|replicaInfo
operator|.
name|getIsPersisted
argument_list|()
condition|)
block|{
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksDeletedBeforeLazyPersisted
argument_list|()
expr_stmt|;
block|}
name|ramDiskReplicaTracker
operator|.
name|discardReplica
argument_list|(
name|replicaInfo
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If a DFSClient has the replica in its cache of short-circuit file
comment|// descriptors (and the client is using ShortCircuitShm), invalidate it.
name|datanode
operator|.
name|getShortCircuitRegistry
argument_list|()
operator|.
name|processBlockInvalidation
argument_list|(
operator|new
name|ExtendedBlockId
argument_list|(
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|bpid
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the block is cached, start uncaching it.
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Delete the block asynchronously to make sure we can do it fast enough.
comment|// It's ok to unlink the block file before the uncache operation
comment|// finishes.
try|try
block|{
name|asyncDiskService
operator|.
name|deleteAsync
argument_list|(
name|v
operator|.
name|obtainReference
argument_list|()
argument_list|,
name|f
argument_list|,
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|f
argument_list|,
name|invalidBlks
index|[
name|i
index|]
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
argument_list|,
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|invalidBlks
index|[
name|i
index|]
argument_list|)
argument_list|,
name|dataStorage
operator|.
name|getTrashDirectoryForBlockFile
argument_list|(
name|bpid
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Volume "
operator|+
name|v
operator|+
literal|" is closed, ignore the deletion task for "
operator|+
literal|"block "
operator|+
name|invalidBlks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|errors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Failed to delete "
argument_list|)
operator|.
name|append
argument_list|(
name|errors
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" (out of "
argument_list|)
operator|.
name|append
argument_list|(
name|invalidBlks
operator|.
name|length
argument_list|)
operator|.
name|append
argument_list|(
literal|") replica(s):"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|errors
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
operator|.
name|append
argument_list|(
literal|") "
argument_list|)
operator|.
name|append
argument_list|(
name|errors
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|b
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Invalidate a block but does not delete the actual on-disk block file.    *    * It should only be used when deactivating disks.    *    * @param bpid the block pool ID.    * @param block The block to be invalidated.    */
DECL|method|invalidate (String bpid, ReplicaInfo block)
specifier|public
name|void
name|invalidate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaInfo
name|block
parameter_list|)
block|{
comment|// If a DFSClient has the replica in its cache of short-circuit file
comment|// descriptors (and the client is using ShortCircuitShm), invalidate it.
comment|// The short-circuit registry is null in the unit tests, because the
comment|// datanode is mock object.
if|if
condition|(
name|datanode
operator|.
name|getShortCircuitRegistry
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|getShortCircuitRegistry
argument_list|()
operator|.
name|processBlockInvalidation
argument_list|(
operator|new
name|ExtendedBlockId
argument_list|(
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|bpid
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the block is cached, start uncaching it.
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|datanode
operator|.
name|notifyNamenodeDeletedBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|block
argument_list|)
argument_list|,
name|block
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Asynchronously attempts to cache a single block via {@link FsDatasetCache}.    */
DECL|method|cacheBlock (String bpid, long blockId)
specifier|private
name|void
name|cacheBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|FsVolumeImpl
name|volume
decl_stmt|;
name|String
name|blockFileName
decl_stmt|;
name|long
name|length
decl_stmt|,
name|genstamp
decl_stmt|;
name|Executor
name|volumeExecutor
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache block with id "
operator|+
name|blockId
operator|+
literal|", pool "
operator|+
name|bpid
operator|+
literal|": ReplicaInfo not found."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache block with id "
operator|+
name|blockId
operator|+
literal|", pool "
operator|+
name|bpid
operator|+
literal|": replica is not finalized; it is in state "
operator|+
name|info
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|volume
operator|=
operator|(
name|FsVolumeImpl
operator|)
name|info
operator|.
name|getVolume
argument_list|()
expr_stmt|;
if|if
condition|(
name|volume
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache block with id "
operator|+
name|blockId
operator|+
literal|", pool "
operator|+
name|bpid
operator|+
literal|": volume not found."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to cache block with id "
operator|+
name|blockId
operator|+
literal|": volume was not an instance of FsVolumeImpl."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|volume
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caching not supported on block with id "
operator|+
name|blockId
operator|+
literal|" since the volume is backed by RAM."
argument_list|)
expr_stmt|;
return|return;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|cacheManager
operator|.
name|numBlocksFailedToCache
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
name|blockFileName
operator|=
name|info
operator|.
name|getBlockFile
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
name|length
operator|=
name|info
operator|.
name|getVisibleLength
argument_list|()
expr_stmt|;
name|genstamp
operator|=
name|info
operator|.
name|getGenerationStamp
argument_list|()
expr_stmt|;
name|volumeExecutor
operator|=
name|volume
operator|.
name|getCacheExecutor
argument_list|()
expr_stmt|;
block|}
name|cacheManager
operator|.
name|cacheBlock
argument_list|(
name|blockId
argument_list|,
name|bpid
argument_list|,
name|blockFileName
argument_list|,
name|length
argument_list|,
name|genstamp
argument_list|,
name|volumeExecutor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|cache (String bpid, long[] blockIds)
specifier|public
name|void
name|cache
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
index|[]
name|blockIds
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockIds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cacheBlock
argument_list|(
name|bpid
argument_list|,
name|blockIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|uncache (String bpid, long[] blockIds)
specifier|public
name|void
name|uncache
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
index|[]
name|blockIds
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockIds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cacheManager
operator|.
name|uncacheBlock
argument_list|(
name|bpid
argument_list|,
name|blockIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isCached (String bpid, long blockId)
specifier|public
name|boolean
name|isCached
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
return|return
name|cacheManager
operator|.
name|isCached
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|contains (final ExtendedBlock block)
specifier|public
specifier|synchronized
name|boolean
name|contains
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
block|{
specifier|final
name|long
name|blockId
init|=
name|block
operator|.
name|getLocalBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
return|return
name|getFile
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|blockId
argument_list|,
literal|false
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Turn the block identifier into a filename    * @param bpid Block pool Id    * @param blockId a block's id    * @return on disk data file path; null if the replica does not exist    */
DECL|method|getFile (final String bpid, final long blockId, boolean touch)
name|File
name|getFile
parameter_list|(
specifier|final
name|String
name|bpid
parameter_list|,
specifier|final
name|long
name|blockId
parameter_list|,
name|boolean
name|touch
parameter_list|)
block|{
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|touch
operator|&&
name|info
operator|.
name|getVolume
argument_list|()
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|ramDiskReplicaTracker
operator|.
name|touch
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksReadHits
argument_list|()
expr_stmt|;
block|}
return|return
name|info
operator|.
name|getBlockFile
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * check if a data directory is healthy    *    * if some volumes failed - the caller must emove all the blocks that belong    * to these failed volumes.    * @return the failed volumes. Returns null if no volume failed.    */
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|checkDataDir ()
specifier|public
name|Set
argument_list|<
name|File
argument_list|>
name|checkDataDir
parameter_list|()
block|{
return|return
name|volumes
operator|.
name|checkDirs
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSDataset{dirpath='"
operator|+
name|volumes
operator|+
literal|"'}"
return|;
block|}
DECL|field|mbeanName
specifier|private
name|ObjectName
name|mbeanName
decl_stmt|;
comment|/**    * Register the FSDataset MBean using the name    *        "hadoop:service=DataNode,name=FSDatasetState-<datanodeUuid>"    */
DECL|method|registerMBean (final String datanodeUuid)
name|void
name|registerMBean
parameter_list|(
specifier|final
name|String
name|datanodeUuid
parameter_list|)
block|{
comment|// We wrap to bypass standard mbean naming convetion.
comment|// This wraping can be removed in java 6 as it is more flexible in
comment|// package naming for mbeans and their impl.
try|try
block|{
name|StandardMBean
name|bean
init|=
operator|new
name|StandardMBean
argument_list|(
name|this
argument_list|,
name|FSDatasetMBean
operator|.
name|class
argument_list|)
decl_stmt|;
name|mbeanName
operator|=
name|MBeans
operator|.
name|register
argument_list|(
literal|"DataNode"
argument_list|,
literal|"FSDatasetState-"
operator|+
name|datanodeUuid
argument_list|,
name|bean
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotCompliantMBeanException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error registering FSDatasetState MBean"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered FSDatasetState MBean"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|fsRunning
operator|=
literal|false
expr_stmt|;
operator|(
operator|(
name|LazyWriter
operator|)
name|lazyWriter
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|stop
argument_list|()
expr_stmt|;
name|lazyWriter
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|mbeanName
operator|!=
literal|null
condition|)
block|{
name|MBeans
operator|.
name|unregister
argument_list|(
name|mbeanName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asyncDiskService
operator|!=
literal|null
condition|)
block|{
name|asyncDiskService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|asyncLazyPersistService
operator|!=
literal|null
condition|)
block|{
name|asyncLazyPersistService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|volumes
operator|!=
literal|null
condition|)
block|{
name|volumes
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|lazyWriter
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"FsDatasetImpl.shutdown ignoring InterruptedException "
operator|+
literal|"from LazyWriter.join"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// FSDatasetMBean
DECL|method|getStorageInfo ()
specifier|public
name|String
name|getStorageInfo
parameter_list|()
block|{
return|return
name|toString
argument_list|()
return|;
block|}
comment|/**    * Reconcile the difference between blocks on the disk and blocks in    * volumeMap    *    * Check the given block for inconsistencies. Look at the    * current state of the block and reconcile the differences as follows:    *<ul>    *<li>If the block file is missing, delete the block from volumeMap</li>    *<li>If the block file exists and the block is missing in volumeMap,    * add the block to volumeMap<li>    *<li>If generation stamp does not match, then update the block with right    * generation stamp</li>    *<li>If the block length in memory does not match the actual block file length    * then mark the block as corrupt and update the block length in memory</li>    *<li>If the file in {@link ReplicaInfo} does not match the file on    * the disk, update {@link ReplicaInfo} with the correct file</li>    *</ul>    *    * @param blockId Block that differs    * @param diskFile Block file on the disk    * @param diskMetaFile Metadata file from on the disk    * @param vol Volume of the block file    */
annotation|@
name|Override
DECL|method|checkAndUpdate (String bpid, long blockId, File diskFile, File diskMetaFile, FsVolumeSpi vol)
specifier|public
name|void
name|checkAndUpdate
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|,
name|File
name|diskFile
parameter_list|,
name|File
name|diskMetaFile
parameter_list|,
name|FsVolumeSpi
name|vol
parameter_list|)
throws|throws
name|IOException
block|{
name|Block
name|corruptBlock
init|=
literal|null
decl_stmt|;
name|ReplicaInfo
name|memBlockInfo
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|memBlockInfo
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
if|if
condition|(
name|memBlockInfo
operator|!=
literal|null
operator|&&
name|memBlockInfo
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
comment|// Block is not finalized - ignore the difference
return|return;
block|}
specifier|final
name|long
name|diskGS
init|=
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
condition|?
name|Block
operator|.
name|getGenerationStamp
argument_list|(
name|diskMetaFile
operator|.
name|getName
argument_list|()
argument_list|)
else|:
name|HdfsConstants
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
if|if
condition|(
name|diskFile
operator|==
literal|null
operator|||
operator|!
name|diskFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memBlockInfo
operator|==
literal|null
condition|)
block|{
comment|// Block file does not exist and block does not exist in memory
comment|// If metadata file exists then delete it
if|if
condition|(
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deleted a metadata file without a block "
operator|+
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|memBlockInfo
operator|.
name|getBlockFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// Block is in memory and not on the disk
comment|// Remove the block from volumeMap
name|volumeMap
operator|.
name|remove
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|ramDiskReplicaTracker
operator|.
name|discardReplica
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removed block "
operator|+
name|blockId
operator|+
literal|" from memory with missing block file on the disk"
argument_list|)
expr_stmt|;
comment|// Finally remove the metadata file
if|if
condition|(
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Deleted a metadata file for the deleted block "
operator|+
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/*        * Block file exists on the disk        */
if|if
condition|(
name|memBlockInfo
operator|==
literal|null
condition|)
block|{
comment|// Block is missing in memory - add the block to volumeMap
name|ReplicaInfo
name|diskBlockInfo
init|=
operator|new
name|FinalizedReplica
argument_list|(
name|blockId
argument_list|,
name|diskFile
operator|.
name|length
argument_list|()
argument_list|,
name|diskGS
argument_list|,
name|vol
argument_list|,
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|diskBlockInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|ramDiskReplicaTracker
operator|.
name|addReplica
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|,
operator|(
name|FsVolumeImpl
operator|)
name|vol
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Added missing block to memory "
operator|+
name|diskBlockInfo
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*        * Block exists in volumeMap and the block file exists on the disk        */
comment|// Compare block files
name|File
name|memFile
init|=
name|memBlockInfo
operator|.
name|getBlockFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|memFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memFile
operator|.
name|compareTo
argument_list|(
name|diskFile
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|diskMetaFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memBlockInfo
operator|.
name|getMetaFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// We have two sets of block+meta files. Decide which one to
comment|// keep.
name|ReplicaInfo
name|diskBlockInfo
init|=
operator|new
name|FinalizedReplica
argument_list|(
name|blockId
argument_list|,
name|diskFile
operator|.
name|length
argument_list|()
argument_list|,
name|diskGS
argument_list|,
name|vol
argument_list|,
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
decl_stmt|;
operator|(
operator|(
name|FsVolumeImpl
operator|)
name|vol
operator|)
operator|.
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
operator|.
name|resolveDuplicateReplicas
argument_list|(
name|memBlockInfo
argument_list|,
name|diskBlockInfo
argument_list|,
name|volumeMap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|diskFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to delete "
operator|+
name|diskFile
operator|+
literal|". Will retry on next scan"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Block refers to a block file that does not exist.
comment|// Update the block with the file found on the disk. Since the block
comment|// file and metadata file are found as a pair on the disk, update
comment|// the block based on the metadata file found on the disk
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block file in volumeMap "
operator|+
name|memFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" does not exist. Updating it to the file found during scan "
operator|+
name|diskFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setDir
argument_list|(
name|diskFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
name|memFile
operator|=
name|diskFile
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating generation stamp for block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|" to "
operator|+
name|diskGS
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setGenerationStamp
argument_list|(
name|diskGS
argument_list|)
expr_stmt|;
block|}
comment|// Compare generation stamp
if|if
condition|(
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|!=
name|diskGS
condition|)
block|{
name|File
name|memMetaFile
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|diskFile
argument_list|,
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|memMetaFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|memMetaFile
operator|.
name|compareTo
argument_list|(
name|diskMetaFile
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Metadata file in memory "
operator|+
name|memMetaFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" does not match file found by scan "
operator|+
operator|(
name|diskMetaFile
operator|==
literal|null
condition|?
literal|null
else|:
name|diskMetaFile
operator|.
name|getAbsolutePath
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Metadata file corresponding to block in memory is missing
comment|// If metadata file found during the scan is on the same directory
comment|// as the block file, then use the generation stamp from it
name|long
name|gs
init|=
name|diskMetaFile
operator|!=
literal|null
operator|&&
name|diskMetaFile
operator|.
name|exists
argument_list|()
operator|&&
name|diskMetaFile
operator|.
name|getParent
argument_list|()
operator|.
name|equals
argument_list|(
name|memFile
operator|.
name|getParent
argument_list|()
argument_list|)
condition|?
name|diskGS
else|:
name|HdfsConstants
operator|.
name|GRANDFATHER_GENERATION_STAMP
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating generation stamp for block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|" to "
operator|+
name|gs
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setGenerationStamp
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Compare block size
if|if
condition|(
name|memBlockInfo
operator|.
name|getNumBytes
argument_list|()
operator|!=
name|memFile
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// Update the length based on the block file
name|corruptBlock
operator|=
operator|new
name|Block
argument_list|(
name|memBlockInfo
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Updating size of block "
operator|+
name|blockId
operator|+
literal|" from "
operator|+
name|memBlockInfo
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" to "
operator|+
name|memFile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|memBlockInfo
operator|.
name|setNumBytes
argument_list|(
name|memFile
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Send corrupt block report outside the lock
if|if
condition|(
name|corruptBlock
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reporting the block "
operator|+
name|corruptBlock
operator|+
literal|" as corrupt due to length mismatch"
argument_list|)
expr_stmt|;
try|try
block|{
name|datanode
operator|.
name|reportBadBlocks
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|corruptBlock
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to repot bad block "
operator|+
name|corruptBlock
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @deprecated use {@link #fetchReplicaInfo(String, long)} instead.    */
annotation|@
name|Override
comment|// FsDatasetSpi
annotation|@
name|Deprecated
DECL|method|getReplica (String bpid, long blockId)
specifier|public
name|ReplicaInfo
name|getReplica
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
return|return
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getReplicaString (String bpid, long blockId)
specifier|public
specifier|synchronized
name|String
name|getReplicaString
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
specifier|final
name|Replica
name|r
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
return|return
name|r
operator|==
literal|null
condition|?
literal|"null"
else|:
name|r
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|initReplicaRecovery ( RecoveringBlock rBlock)
specifier|public
specifier|synchronized
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|initReplicaRecovery
argument_list|(
name|rBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|volumeMap
argument_list|,
name|rBlock
operator|.
name|getBlock
argument_list|()
operator|.
name|getLocalBlock
argument_list|()
argument_list|,
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
argument_list|,
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
return|;
block|}
comment|/** static version of {@link #initReplicaRecovery(RecoveringBlock)}. */
DECL|method|initReplicaRecovery (String bpid, ReplicaMap map, Block block, long recoveryId, long xceiverStopTimeout)
specifier|static
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaMap
name|map
parameter_list|,
name|Block
name|block
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|xceiverStopTimeout
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ReplicaInfo
name|replica
init|=
name|map
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: "
operator|+
name|block
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
expr_stmt|;
comment|//check replica
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//stop writer if there is any
if|if
condition|(
name|replica
operator|instanceof
name|ReplicaInPipeline
condition|)
block|{
specifier|final
name|ReplicaInPipeline
name|rip
init|=
operator|(
name|ReplicaInPipeline
operator|)
name|replica
decl_stmt|;
name|rip
operator|.
name|stopWriter
argument_list|(
name|xceiverStopTimeout
argument_list|)
expr_stmt|;
comment|//check replica bytes on disk.
if|if
condition|(
name|rip
operator|.
name|getBytesOnDisk
argument_list|()
operator|<
name|rip
operator|.
name|getVisibleLength
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" getBytesOnDisk()< getVisibleLength(), rip="
operator|+
name|rip
argument_list|)
throw|;
block|}
comment|//check the replica's files
name|checkReplicaFiles
argument_list|(
name|rip
argument_list|)
expr_stmt|;
block|}
comment|//check generation stamp
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getGenerationStamp()< block.getGenerationStamp(), block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check recovery id
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|>=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" replica.getGenerationStamp()>= recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check RUR
specifier|final
name|ReplicaUnderRecovery
name|rur
decl_stmt|;
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|==
name|ReplicaState
operator|.
name|RUR
condition|)
block|{
name|rur
operator|=
operator|(
name|ReplicaUnderRecovery
operator|)
name|replica
expr_stmt|;
if|if
condition|(
name|rur
operator|.
name|getRecoveryID
argument_list|()
operator|>=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|RecoveryInProgressException
argument_list|(
literal|"rur.getRecoveryID()>= recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", block="
operator|+
name|block
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
specifier|final
name|long
name|oldRecoveryID
init|=
name|rur
operator|.
name|getRecoveryID
argument_list|()
decl_stmt|;
name|rur
operator|.
name|setRecoveryID
argument_list|(
name|recoveryId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: update recovery id for "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|oldRecoveryID
operator|+
literal|" to "
operator|+
name|recoveryId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rur
operator|=
operator|new
name|ReplicaUnderRecovery
argument_list|(
name|replica
argument_list|,
name|recoveryId
argument_list|)
expr_stmt|;
name|map
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|rur
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"initReplicaRecovery: changing replica state for "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|replica
operator|.
name|getState
argument_list|()
operator|+
literal|" to "
operator|+
name|rur
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rur
operator|.
name|createInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|updateReplicaUnderRecovery ( final ExtendedBlock oldBlock, final long recoveryId, final long newBlockId, final long newlength)
specifier|public
specifier|synchronized
name|String
name|updateReplicaUnderRecovery
parameter_list|(
specifier|final
name|ExtendedBlock
name|oldBlock
parameter_list|,
specifier|final
name|long
name|recoveryId
parameter_list|,
specifier|final
name|long
name|newBlockId
parameter_list|,
specifier|final
name|long
name|newlength
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get replica
specifier|final
name|String
name|bpid
init|=
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
specifier|final
name|ReplicaInfo
name|replica
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|bpid
argument_list|,
name|oldBlock
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"updateReplica: "
operator|+
name|oldBlock
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", length="
operator|+
name|newlength
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
expr_stmt|;
comment|//check replica
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|oldBlock
argument_list|)
throw|;
block|}
comment|//check replica state
if|if
condition|(
name|replica
operator|.
name|getState
argument_list|()
operator|!=
name|ReplicaState
operator|.
name|RUR
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getState() != "
operator|+
name|ReplicaState
operator|.
name|RUR
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check replica's byte on disk
if|if
condition|(
name|replica
operator|.
name|getBytesOnDisk
argument_list|()
operator|!=
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"THIS IS NOT SUPPOSED TO HAPPEN:"
operator|+
literal|" replica.getBytesOnDisk() != block.getNumBytes(), block="
operator|+
name|oldBlock
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
comment|//check replica files before update
name|checkReplicaFiles
argument_list|(
name|replica
argument_list|)
expr_stmt|;
comment|//update replica
specifier|final
name|FinalizedReplica
name|finalized
init|=
name|updateReplicaUnderRecovery
argument_list|(
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
operator|(
name|ReplicaUnderRecovery
operator|)
name|replica
argument_list|,
name|recoveryId
argument_list|,
name|newBlockId
argument_list|,
name|newlength
argument_list|)
decl_stmt|;
name|boolean
name|copyTruncate
init|=
name|newBlockId
operator|!=
name|oldBlock
operator|.
name|getBlockId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|copyTruncate
condition|)
block|{
assert|assert
name|finalized
operator|.
name|getBlockId
argument_list|()
operator|==
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|&&
name|finalized
operator|.
name|getGenerationStamp
argument_list|()
operator|==
name|recoveryId
operator|&&
name|finalized
operator|.
name|getNumBytes
argument_list|()
operator|==
name|newlength
operator|:
literal|"Replica information mismatched: oldBlock="
operator|+
name|oldBlock
operator|+
literal|", recoveryId="
operator|+
name|recoveryId
operator|+
literal|", newlength="
operator|+
name|newlength
operator|+
literal|", newBlockId="
operator|+
name|newBlockId
operator|+
literal|", finalized="
operator|+
name|finalized
assert|;
block|}
else|else
block|{
assert|assert
name|finalized
operator|.
name|getBlockId
argument_list|()
operator|==
name|oldBlock
operator|.
name|getBlockId
argument_list|()
operator|&&
name|finalized
operator|.
name|getGenerationStamp
argument_list|()
operator|==
name|oldBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|finalized
operator|.
name|getNumBytes
argument_list|()
operator|==
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
operator|:
literal|"Finalized and old information mismatched: oldBlock="
operator|+
name|oldBlock
operator|+
literal|", genStamp="
operator|+
name|oldBlock
operator|.
name|getGenerationStamp
argument_list|()
operator|+
literal|", len="
operator|+
name|oldBlock
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|", finalized="
operator|+
name|finalized
assert|;
block|}
comment|//check replica files after update
name|checkReplicaFiles
argument_list|(
name|finalized
argument_list|)
expr_stmt|;
comment|//return storage ID
return|return
name|getVolume
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|finalized
argument_list|)
argument_list|)
operator|.
name|getStorageID
argument_list|()
return|;
block|}
DECL|method|updateReplicaUnderRecovery ( String bpid, ReplicaUnderRecovery rur, long recoveryId, long newBlockId, long newlength)
specifier|private
name|FinalizedReplica
name|updateReplicaUnderRecovery
parameter_list|(
name|String
name|bpid
parameter_list|,
name|ReplicaUnderRecovery
name|rur
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|newBlockId
parameter_list|,
name|long
name|newlength
parameter_list|)
throws|throws
name|IOException
block|{
comment|//check recovery id
if|if
condition|(
name|rur
operator|.
name|getRecoveryID
argument_list|()
operator|!=
name|recoveryId
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rur.getRecoveryID() != recoveryId = "
operator|+
name|recoveryId
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
name|boolean
name|copyOnTruncate
init|=
name|newBlockId
operator|>
literal|0L
operator|&&
name|rur
operator|.
name|getBlockId
argument_list|()
operator|!=
name|newBlockId
decl_stmt|;
name|File
name|blockFile
decl_stmt|;
name|File
name|metaFile
decl_stmt|;
comment|// bump rur's GS to be recovery id
if|if
condition|(
operator|!
name|copyOnTruncate
condition|)
block|{
name|bumpReplicaGS
argument_list|(
name|rur
argument_list|,
name|recoveryId
argument_list|)
expr_stmt|;
name|blockFile
operator|=
name|rur
operator|.
name|getBlockFile
argument_list|()
expr_stmt|;
name|metaFile
operator|=
name|rur
operator|.
name|getMetaFile
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|File
index|[]
name|copiedReplicaFiles
init|=
name|copyReplicaWithNewBlockIdAndGS
argument_list|(
name|rur
argument_list|,
name|bpid
argument_list|,
name|newBlockId
argument_list|,
name|recoveryId
argument_list|)
decl_stmt|;
name|blockFile
operator|=
name|copiedReplicaFiles
index|[
literal|1
index|]
expr_stmt|;
name|metaFile
operator|=
name|copiedReplicaFiles
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|//update length
if|if
condition|(
name|rur
operator|.
name|getNumBytes
argument_list|()
operator|<
name|newlength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rur.getNumBytes()< newlength = "
operator|+
name|newlength
operator|+
literal|", rur="
operator|+
name|rur
argument_list|)
throw|;
block|}
if|if
condition|(
name|rur
operator|.
name|getNumBytes
argument_list|()
operator|>
name|newlength
condition|)
block|{
name|rur
operator|.
name|unlinkBlock
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|truncateBlock
argument_list|(
name|blockFile
argument_list|,
name|metaFile
argument_list|,
name|rur
operator|.
name|getNumBytes
argument_list|()
argument_list|,
name|newlength
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copyOnTruncate
condition|)
block|{
comment|// update RUR with the new length
name|rur
operator|.
name|setNumBytes
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Copying block to a new block with new blockId.
comment|// Not truncating original block.
name|ReplicaBeingWritten
name|newReplicaInfo
init|=
operator|new
name|ReplicaBeingWritten
argument_list|(
name|newBlockId
argument_list|,
name|recoveryId
argument_list|,
name|rur
operator|.
name|getVolume
argument_list|()
argument_list|,
name|blockFile
operator|.
name|getParentFile
argument_list|()
argument_list|,
name|newlength
argument_list|)
decl_stmt|;
name|newReplicaInfo
operator|.
name|setNumBytes
argument_list|(
name|newlength
argument_list|)
expr_stmt|;
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
name|finalizeReplica
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// finalize the block
return|return
name|finalizeReplica
argument_list|(
name|bpid
argument_list|,
name|rur
argument_list|)
return|;
block|}
DECL|method|copyReplicaWithNewBlockIdAndGS ( ReplicaUnderRecovery replicaInfo, String bpid, long newBlkId, long newGS)
specifier|private
name|File
index|[]
name|copyReplicaWithNewBlockIdAndGS
parameter_list|(
name|ReplicaUnderRecovery
name|replicaInfo
parameter_list|,
name|String
name|bpid
parameter_list|,
name|long
name|newBlkId
parameter_list|,
name|long
name|newGS
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|blockFileName
init|=
name|Block
operator|.
name|BLOCK_FILE_PREFIX
operator|+
name|newBlkId
decl_stmt|;
try|try
init|(
name|FsVolumeReference
name|ref
init|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|getStorageType
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
init|)
block|{
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|ref
operator|.
name|getVolume
argument_list|()
decl_stmt|;
specifier|final
name|File
name|tmpDir
init|=
name|v
operator|.
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
operator|.
name|getTmpDir
argument_list|()
decl_stmt|;
specifier|final
name|File
name|destDir
init|=
name|DatanodeUtil
operator|.
name|idToBlockDir
argument_list|(
name|tmpDir
argument_list|,
name|newBlkId
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dstBlockFile
init|=
operator|new
name|File
argument_list|(
name|destDir
argument_list|,
name|blockFileName
argument_list|)
decl_stmt|;
specifier|final
name|File
name|dstMetaFile
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|dstBlockFile
argument_list|,
name|newGS
argument_list|)
decl_stmt|;
return|return
name|copyBlockFiles
argument_list|(
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
argument_list|,
name|dstMetaFile
argument_list|,
name|dstBlockFile
argument_list|,
literal|true
argument_list|,
name|smallBufferSize
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getReplicaVisibleLength (final ExtendedBlock block)
specifier|public
specifier|synchronized
name|long
name|getReplicaVisibleLength
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Replica
name|replica
init|=
name|getReplicaInfo
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"replica.getGenerationStamp()< block.getGenerationStamp(), block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
return|return
name|replica
operator|.
name|getVisibleLength
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|addBlockPool (String bpid, Configuration conf)
specifier|public
name|void
name|addBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding block pool "
operator|+
name|bpid
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|volumes
operator|.
name|addBlockPool
argument_list|(
name|bpid
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|volumeMap
operator|.
name|initBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
name|volumes
operator|.
name|getAllVolumesMap
argument_list|(
name|bpid
argument_list|,
name|volumeMap
argument_list|,
name|ramDiskReplicaTracker
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|shutdownBlockPool (String bpid)
specifier|public
specifier|synchronized
name|void
name|shutdownBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing block pool "
operator|+
name|bpid
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|DatanodeStorage
argument_list|,
name|BlockListAsLongs
argument_list|>
name|blocksPerVolume
init|=
name|getBlockReports
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|volumeMap
operator|.
name|cleanUpBlockPool
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
name|volumes
operator|.
name|removeBlockPool
argument_list|(
name|bpid
argument_list|,
name|blocksPerVolume
argument_list|)
expr_stmt|;
block|}
comment|/**    * Class for representing the Datanode volume information    */
DECL|class|VolumeInfo
specifier|private
specifier|static
class|class
name|VolumeInfo
block|{
DECL|field|directory
specifier|final
name|String
name|directory
decl_stmt|;
DECL|field|usedSpace
specifier|final
name|long
name|usedSpace
decl_stmt|;
comment|// size of space used by HDFS
DECL|field|freeSpace
specifier|final
name|long
name|freeSpace
decl_stmt|;
comment|// size of free space excluding reserved space
DECL|field|reservedSpace
specifier|final
name|long
name|reservedSpace
decl_stmt|;
comment|// size of space reserved for non-HDFS and RBW
DECL|method|VolumeInfo (FsVolumeImpl v, long usedSpace, long freeSpace)
name|VolumeInfo
parameter_list|(
name|FsVolumeImpl
name|v
parameter_list|,
name|long
name|usedSpace
parameter_list|,
name|long
name|freeSpace
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|v
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|usedSpace
operator|=
name|usedSpace
expr_stmt|;
name|this
operator|.
name|freeSpace
operator|=
name|freeSpace
expr_stmt|;
name|this
operator|.
name|reservedSpace
operator|=
name|v
operator|.
name|getReserved
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getVolumeInfo ()
specifier|private
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|getVolumeInfo
parameter_list|()
block|{
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|info
init|=
operator|new
name|ArrayList
argument_list|<
name|VolumeInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|volumes
operator|.
name|getVolumes
argument_list|()
control|)
block|{
name|long
name|used
init|=
literal|0
decl_stmt|;
name|long
name|free
init|=
literal|0
decl_stmt|;
try|try
init|(
name|FsVolumeReference
name|ref
init|=
name|volume
operator|.
name|obtainReference
argument_list|()
init|)
block|{
name|used
operator|=
name|volume
operator|.
name|getDfsUsed
argument_list|()
expr_stmt|;
name|free
operator|=
name|volume
operator|.
name|getAvailable
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
continue|continue;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|free
operator|=
literal|0
expr_stmt|;
block|}
name|info
operator|.
name|add
argument_list|(
operator|new
name|VolumeInfo
argument_list|(
name|volume
argument_list|,
name|used
argument_list|,
name|free
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
annotation|@
name|Override
DECL|method|getVolumeInfoMap ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getVolumeInfoMap
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|volumes
init|=
name|getVolumeInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|VolumeInfo
name|v
range|:
name|volumes
control|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"usedSpace"
argument_list|,
name|v
operator|.
name|usedSpace
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"freeSpace"
argument_list|,
name|v
operator|.
name|freeSpace
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"reservedSpace"
argument_list|,
name|v
operator|.
name|reservedSpace
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
name|v
operator|.
name|directory
argument_list|,
name|innerInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
annotation|@
name|Override
comment|//FsDatasetSpi
DECL|method|deleteBlockPool (String bpid, boolean force)
specifier|public
specifier|synchronized
name|void
name|deleteBlockPool
parameter_list|(
name|String
name|bpid
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|curVolumes
init|=
name|volumes
operator|.
name|getVolumes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
block|{
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|curVolumes
control|)
block|{
try|try
init|(
name|FsVolumeReference
name|ref
init|=
name|volume
operator|.
name|obtainReference
argument_list|()
init|)
block|{
if|if
condition|(
operator|!
name|volume
operator|.
name|isBPDirEmpty
argument_list|(
name|bpid
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|bpid
operator|+
literal|" has some block files, cannot delete unless forced"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot delete block pool, "
operator|+
literal|"it contains some block files"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
comment|// ignore.
block|}
block|}
block|}
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|curVolumes
control|)
block|{
try|try
init|(
name|FsVolumeReference
name|ref
init|=
name|volume
operator|.
name|obtainReference
argument_list|()
init|)
block|{
name|volume
operator|.
name|deleteBPDirectories
argument_list|(
name|bpid
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
comment|// ignore.
block|}
block|}
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getBlockLocalPathInfo (ExtendedBlock block)
specifier|public
name|BlockLocalPathInfo
name|getBlockLocalPathInfo
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
specifier|final
name|Replica
name|replica
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replica
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicaNotFoundException
argument_list|(
name|block
argument_list|)
throw|;
block|}
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|<
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Replica generation stamp< block generation stamp, block="
operator|+
name|block
operator|+
literal|", replica="
operator|+
name|replica
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
operator|>
name|block
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|replica
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|File
name|datafile
init|=
name|getBlockFile
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|File
name|metafile
init|=
name|FsDatasetUtil
operator|.
name|getMetaFile
argument_list|(
name|datafile
argument_list|,
name|block
operator|.
name|getGenerationStamp
argument_list|()
argument_list|)
decl_stmt|;
name|BlockLocalPathInfo
name|info
init|=
operator|new
name|BlockLocalPathInfo
argument_list|(
name|block
argument_list|,
name|datafile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|metafile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|info
return|;
block|}
annotation|@
name|Override
comment|// FsDatasetSpi
DECL|method|getHdfsBlocksMetadata (String poolId, long[] blockIds)
specifier|public
name|HdfsBlocksMetadata
name|getHdfsBlocksMetadata
parameter_list|(
name|String
name|poolId
parameter_list|,
name|long
index|[]
name|blockIds
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FsVolumeImpl
argument_list|>
name|curVolumes
init|=
name|volumes
operator|.
name|getVolumes
argument_list|()
decl_stmt|;
comment|// List of VolumeIds, one per volume on the datanode
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|blocksVolumeIds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|curVolumes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// List of indexes into the list of VolumeIds, pointing at the VolumeId of
comment|// the volume that the block is on
name|List
argument_list|<
name|Integer
argument_list|>
name|blocksVolumeIndexes
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|blockIds
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// Initialize the list of VolumeIds simply by enumerating the volumes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|curVolumes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|blocksVolumeIds
operator|.
name|add
argument_list|(
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
operator|.
name|putInt
argument_list|(
name|i
argument_list|)
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Determine the index of the VolumeId of each block's volume, by comparing
comment|// the block's volume against the enumerated volumes
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockIds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|blockId
init|=
name|blockIds
index|[
name|i
index|]
decl_stmt|;
name|boolean
name|isValid
init|=
literal|false
decl_stmt|;
name|ReplicaInfo
name|info
init|=
name|volumeMap
operator|.
name|get
argument_list|(
name|poolId
argument_list|,
name|blockId
argument_list|)
decl_stmt|;
name|int
name|volumeIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|FsVolumeSpi
name|blockVolume
init|=
name|info
operator|.
name|getVolume
argument_list|()
decl_stmt|;
for|for
control|(
name|FsVolumeImpl
name|volume
range|:
name|curVolumes
control|)
block|{
comment|// This comparison of references should be safe
if|if
condition|(
name|blockVolume
operator|==
name|volume
condition|)
block|{
name|isValid
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|volumeIndex
operator|++
expr_stmt|;
block|}
block|}
comment|// Indicates that the block is not present, or not found in a data dir
if|if
condition|(
operator|!
name|isValid
condition|)
block|{
name|volumeIndex
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|blocksVolumeIndexes
operator|.
name|add
argument_list|(
name|volumeIndex
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|HdfsBlocksMetadata
argument_list|(
name|poolId
argument_list|,
name|blockIds
argument_list|,
name|blocksVolumeIds
argument_list|,
name|blocksVolumeIndexes
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|enableTrash (String bpid)
specifier|public
name|void
name|enableTrash
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|dataStorage
operator|.
name|enableTrash
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clearTrash (String bpid)
specifier|public
name|void
name|clearTrash
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|dataStorage
operator|.
name|clearTrash
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|trashEnabled (String bpid)
specifier|public
name|boolean
name|trashEnabled
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
return|return
name|dataStorage
operator|.
name|trashEnabled
argument_list|(
name|bpid
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setRollingUpgradeMarker (String bpid)
specifier|public
name|void
name|setRollingUpgradeMarker
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|dataStorage
operator|.
name|setRollingUpgradeMarker
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clearRollingUpgradeMarker (String bpid)
specifier|public
name|void
name|clearRollingUpgradeMarker
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|dataStorage
operator|.
name|clearRollingUpgradeMarker
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onCompleteLazyPersist (String bpId, long blockId, long creationTime, File[] savedFiles, FsVolumeImpl targetVolume)
specifier|public
name|void
name|onCompleteLazyPersist
parameter_list|(
name|String
name|bpId
parameter_list|,
name|long
name|blockId
parameter_list|,
name|long
name|creationTime
parameter_list|,
name|File
index|[]
name|savedFiles
parameter_list|,
name|FsVolumeImpl
name|targetVolume
parameter_list|)
block|{
synchronized|synchronized
init|(
name|FsDatasetImpl
operator|.
name|this
init|)
block|{
name|ramDiskReplicaTracker
operator|.
name|recordEndLazyPersist
argument_list|(
name|bpId
argument_list|,
name|blockId
argument_list|,
name|savedFiles
argument_list|)
expr_stmt|;
name|targetVolume
operator|.
name|incDfsUsed
argument_list|(
name|bpId
argument_list|,
name|savedFiles
index|[
literal|0
index|]
operator|.
name|length
argument_list|()
operator|+
name|savedFiles
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update metrics (ignore the metadata file size)
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksLazyPersisted
argument_list|()
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBytesLazyPersisted
argument_list|(
name|savedFiles
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|addRamDiskBlocksLazyPersistWindowMs
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|creationTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"LazyWriter: Finish persisting RamDisk block: "
operator|+
literal|" block pool Id: "
operator|+
name|bpId
operator|+
literal|" block id: "
operator|+
name|blockId
operator|+
literal|" to block file "
operator|+
name|savedFiles
index|[
literal|1
index|]
operator|+
literal|" and meta file "
operator|+
name|savedFiles
index|[
literal|0
index|]
operator|+
literal|" on target volume "
operator|+
name|targetVolume
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onFailLazyPersist (String bpId, long blockId)
specifier|public
name|void
name|onFailLazyPersist
parameter_list|(
name|String
name|bpId
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
name|RamDiskReplica
name|block
init|=
literal|null
decl_stmt|;
name|block
operator|=
name|ramDiskReplicaTracker
operator|.
name|getReplica
argument_list|(
name|bpId
argument_list|,
name|blockId
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to save replica "
operator|+
name|block
operator|+
literal|". re-enqueueing it."
argument_list|)
expr_stmt|;
name|ramDiskReplicaTracker
operator|.
name|reenqueueReplicaNotPersisted
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|submitBackgroundSyncFileRangeRequest (ExtendedBlock block, FileDescriptor fd, long offset, long nbytes, int flags)
specifier|public
name|void
name|submitBackgroundSyncFileRangeRequest
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|FileDescriptor
name|fd
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|nbytes
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|FsVolumeImpl
name|fsVolumeImpl
init|=
name|this
operator|.
name|getVolume
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|asyncDiskService
operator|.
name|submitSyncFileRangeRequest
argument_list|(
name|fsVolumeImpl
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|,
name|nbytes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
DECL|method|ramDiskConfigured ()
specifier|private
name|boolean
name|ramDiskConfigured
parameter_list|()
block|{
for|for
control|(
name|FsVolumeImpl
name|v
range|:
name|volumes
operator|.
name|getVolumes
argument_list|()
control|)
block|{
if|if
condition|(
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// Add/Remove per DISK volume async lazy persist thread when RamDisk volume is
comment|// added or removed.
comment|// This should only be called when the FsDataSetImpl#volumes list is finalized.
DECL|method|setupAsyncLazyPersistThreads ()
specifier|private
name|void
name|setupAsyncLazyPersistThreads
parameter_list|()
block|{
for|for
control|(
name|FsVolumeImpl
name|v
range|:
name|volumes
operator|.
name|getVolumes
argument_list|()
control|)
block|{
name|setupAsyncLazyPersistThread
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setupAsyncLazyPersistThread (final FsVolumeImpl v)
specifier|private
name|void
name|setupAsyncLazyPersistThread
parameter_list|(
specifier|final
name|FsVolumeImpl
name|v
parameter_list|)
block|{
comment|// Skip transient volumes
if|if
condition|(
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
return|return;
block|}
name|boolean
name|ramDiskConfigured
init|=
name|ramDiskConfigured
argument_list|()
decl_stmt|;
comment|// Add thread for DISK volume if RamDisk is configured
if|if
condition|(
name|ramDiskConfigured
operator|&&
operator|!
name|asyncLazyPersistService
operator|.
name|queryVolume
argument_list|(
name|v
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
condition|)
block|{
name|asyncLazyPersistService
operator|.
name|addVolume
argument_list|(
name|v
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Remove thread for DISK volume if RamDisk is not configured
if|if
condition|(
operator|!
name|ramDiskConfigured
operator|&&
name|asyncLazyPersistService
operator|.
name|queryVolume
argument_list|(
name|v
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
condition|)
block|{
name|asyncLazyPersistService
operator|.
name|removeVolume
argument_list|(
name|v
operator|.
name|getCurrentDir
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeOldReplica (ReplicaInfo replicaInfo, ReplicaInfo newReplicaInfo, File blockFile, File metaFile, long blockFileUsed, long metaFileUsed, final String bpid)
specifier|private
name|void
name|removeOldReplica
parameter_list|(
name|ReplicaInfo
name|replicaInfo
parameter_list|,
name|ReplicaInfo
name|newReplicaInfo
parameter_list|,
name|File
name|blockFile
parameter_list|,
name|File
name|metaFile
parameter_list|,
name|long
name|blockFileUsed
parameter_list|,
name|long
name|metaFileUsed
parameter_list|,
specifier|final
name|String
name|bpid
parameter_list|)
block|{
comment|// Before deleting the files from old storage we must notify the
comment|// NN that the files are on the new storage. Else a blockReport from
comment|// the transient storage might cause the NN to think the blocks are lost.
comment|// Replicas must be evicted from client short-circuit caches, because the
comment|// storage will no longer be same, and thus will require validating
comment|// checksum.  This also stops a client from holding file descriptors,
comment|// which would prevent the OS from reclaiming the memory.
name|ExtendedBlock
name|extendedBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
decl_stmt|;
name|datanode
operator|.
name|getShortCircuitRegistry
argument_list|()
operator|.
name|processBlockInvalidation
argument_list|(
name|ExtendedBlockId
operator|.
name|fromExtendedBlock
argument_list|(
name|extendedBlock
argument_list|)
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivedBlock
argument_list|(
name|extendedBlock
argument_list|,
literal|null
argument_list|,
name|newReplicaInfo
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove the old replicas
if|if
condition|(
name|blockFile
operator|.
name|delete
argument_list|()
operator|||
operator|!
name|blockFile
operator|.
name|exists
argument_list|()
condition|)
block|{
operator|(
operator|(
name|FsVolumeImpl
operator|)
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|)
operator|.
name|decDfsUsed
argument_list|(
name|bpid
argument_list|,
name|blockFileUsed
argument_list|)
expr_stmt|;
if|if
condition|(
name|metaFile
operator|.
name|delete
argument_list|()
operator|||
operator|!
name|metaFile
operator|.
name|exists
argument_list|()
condition|)
block|{
operator|(
operator|(
name|FsVolumeImpl
operator|)
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|)
operator|.
name|decDfsUsed
argument_list|(
name|bpid
argument_list|,
name|metaFileUsed
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If deletion failed then the directory scanner will cleanup the blocks
comment|// eventually.
block|}
DECL|class|LazyWriter
class|class
name|LazyWriter
implements|implements
name|Runnable
block|{
DECL|field|shouldRun
specifier|private
specifier|volatile
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
DECL|field|checkpointerInterval
specifier|final
name|int
name|checkpointerInterval
decl_stmt|;
DECL|field|lowWatermarkFreeSpacePercentage
specifier|final
name|float
name|lowWatermarkFreeSpacePercentage
decl_stmt|;
DECL|field|lowWatermarkFreeSpaceBytes
specifier|final
name|long
name|lowWatermarkFreeSpaceBytes
decl_stmt|;
DECL|method|LazyWriter (Configuration conf)
specifier|public
name|LazyWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|checkpointerInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_LAZY_WRITER_INTERVAL_SEC
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_LAZY_WRITER_INTERVAL_DEFAULT_SEC
argument_list|)
expr_stmt|;
name|this
operator|.
name|lowWatermarkFreeSpacePercentage
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_RAM_DISK_LOW_WATERMARK_PERCENT
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_RAM_DISK_LOW_WATERMARK_PERCENT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|lowWatermarkFreeSpaceBytes
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_RAM_DISK_LOW_WATERMARK_BYTES
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_RAM_DISK_LOW_WATERMARK_BYTES_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Checkpoint a pending replica to persistent storage now.      * If we fail then move the replica to the end of the queue.      * @return true if there is more work to be done, false otherwise.      */
DECL|method|saveNextReplica ()
specifier|private
name|boolean
name|saveNextReplica
parameter_list|()
block|{
name|RamDiskReplica
name|block
init|=
literal|null
decl_stmt|;
name|FsVolumeReference
name|targetReference
decl_stmt|;
name|FsVolumeImpl
name|targetVolume
decl_stmt|;
name|ReplicaInfo
name|replicaInfo
decl_stmt|;
name|boolean
name|succeeded
init|=
literal|false
decl_stmt|;
try|try
block|{
name|block
operator|=
name|ramDiskReplicaTracker
operator|.
name|dequeueNextReplicaToPersist
argument_list|()
expr_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|FsDatasetImpl
operator|.
name|this
init|)
block|{
name|replicaInfo
operator|=
name|volumeMap
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
comment|// If replicaInfo is null, the block was either deleted before
comment|// it could be checkpointed or it is already on persistent storage.
comment|// This can occur if a second replica on persistent storage was found
comment|// after the lazy write was scheduled.
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
operator|&&
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
comment|// Pick a target volume to persist the block.
name|targetReference
operator|=
name|volumes
operator|.
name|getNextVolume
argument_list|(
name|StorageType
operator|.
name|DEFAULT
argument_list|,
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|targetVolume
operator|=
operator|(
name|FsVolumeImpl
operator|)
name|targetReference
operator|.
name|getVolume
argument_list|()
expr_stmt|;
name|ramDiskReplicaTracker
operator|.
name|recordStartLazyPersist
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|targetVolume
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"LazyWriter: Start persisting RamDisk block:"
operator|+
literal|" block pool Id: "
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" block id: "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" on target volume "
operator|+
name|targetVolume
argument_list|)
expr_stmt|;
block|}
name|asyncLazyPersistService
operator|.
name|submitLazyPersistTask
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|block
operator|.
name|getCreationTime
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
argument_list|,
name|targetReference
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|succeeded
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception saving replica "
operator|+
name|block
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|succeeded
operator|&&
name|block
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to save replica "
operator|+
name|block
operator|+
literal|". re-enqueueing it."
argument_list|)
expr_stmt|;
name|onFailLazyPersist
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|succeeded
return|;
block|}
DECL|method|transientFreeSpaceBelowThreshold ()
specifier|private
name|boolean
name|transientFreeSpaceBelowThreshold
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|free
init|=
literal|0
decl_stmt|;
name|long
name|capacity
init|=
literal|0
decl_stmt|;
name|float
name|percentFree
init|=
literal|0.0f
decl_stmt|;
comment|// Don't worry about fragmentation for now. We don't expect more than one
comment|// transient volume per DN.
try|try
init|(
name|FsVolumeReferences
name|volumes
init|=
name|getFsVolumeReferences
argument_list|()
init|)
block|{
for|for
control|(
name|FsVolumeSpi
name|fvs
range|:
name|volumes
control|)
block|{
name|FsVolumeImpl
name|v
init|=
operator|(
name|FsVolumeImpl
operator|)
name|fvs
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
name|capacity
operator|+=
name|v
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
name|free
operator|+=
name|v
operator|.
name|getAvailable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|capacity
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|percentFree
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
name|double
operator|)
name|free
operator|*
literal|100
operator|/
name|capacity
argument_list|)
expr_stmt|;
return|return
operator|(
name|percentFree
operator|<
name|lowWatermarkFreeSpacePercentage
operator|)
operator|||
operator|(
name|free
operator|<
name|lowWatermarkFreeSpaceBytes
operator|)
return|;
block|}
comment|/**      * Attempt to evict one or more transient block replicas we have at least      * spaceNeeded bytes free.      */
DECL|method|evictBlocks ()
specifier|private
name|void
name|evictBlocks
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|iterations
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iterations
operator|++
operator|<
name|MAX_BLOCK_EVICTIONS_PER_ITERATION
operator|&&
name|transientFreeSpaceBelowThreshold
argument_list|()
condition|)
block|{
name|RamDiskReplica
name|replicaState
init|=
name|ramDiskReplicaTracker
operator|.
name|getNextCandidateForEviction
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaState
operator|==
literal|null
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Evicting block "
operator|+
name|replicaState
argument_list|)
expr_stmt|;
block|}
name|ReplicaInfo
name|replicaInfo
decl_stmt|,
name|newReplicaInfo
decl_stmt|;
name|File
name|blockFile
decl_stmt|,
name|metaFile
decl_stmt|;
name|long
name|blockFileUsed
decl_stmt|,
name|metaFileUsed
decl_stmt|;
specifier|final
name|String
name|bpid
init|=
name|replicaState
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|FsDatasetImpl
operator|.
name|this
init|)
block|{
name|replicaInfo
operator|=
name|getReplicaInfo
argument_list|(
name|replicaState
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaState
operator|.
name|getBlockId
argument_list|()
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|replicaInfo
operator|.
name|getVolume
argument_list|()
operator|.
name|isTransientStorage
argument_list|()
argument_list|)
expr_stmt|;
name|blockFile
operator|=
name|replicaInfo
operator|.
name|getBlockFile
argument_list|()
expr_stmt|;
name|metaFile
operator|=
name|replicaInfo
operator|.
name|getMetaFile
argument_list|()
expr_stmt|;
name|blockFileUsed
operator|=
name|blockFile
operator|.
name|length
argument_list|()
expr_stmt|;
name|metaFileUsed
operator|=
name|metaFile
operator|.
name|length
argument_list|()
expr_stmt|;
name|ramDiskReplicaTracker
operator|.
name|discardReplica
argument_list|(
name|replicaState
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|replicaState
operator|.
name|getBlockId
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Move the replica from lazyPersist/ to finalized/ on target volume
name|BlockPoolSlice
name|bpSlice
init|=
name|replicaState
operator|.
name|getLazyPersistVolume
argument_list|()
operator|.
name|getBlockPoolSlice
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
name|File
name|newBlockFile
init|=
name|bpSlice
operator|.
name|activateSavedReplica
argument_list|(
name|replicaInfo
argument_list|,
name|replicaState
operator|.
name|getSavedMetaFile
argument_list|()
argument_list|,
name|replicaState
operator|.
name|getSavedBlockFile
argument_list|()
argument_list|)
decl_stmt|;
name|newReplicaInfo
operator|=
operator|new
name|FinalizedReplica
argument_list|(
name|replicaInfo
operator|.
name|getBlockId
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getBytesOnDisk
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|replicaState
operator|.
name|getLazyPersistVolume
argument_list|()
argument_list|,
name|newBlockFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update the volumeMap entry.
name|volumeMap
operator|.
name|add
argument_list|(
name|bpid
argument_list|,
name|newReplicaInfo
argument_list|)
expr_stmt|;
comment|// Update metrics
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksEvicted
argument_list|()
expr_stmt|;
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|addRamDiskBlocksEvictionWindowMs
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|replicaState
operator|.
name|getCreationTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicaState
operator|.
name|getNumReads
argument_list|()
operator|==
literal|0
condition|)
block|{
name|datanode
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrRamDiskBlocksEvictedWithoutRead
argument_list|()
expr_stmt|;
block|}
block|}
name|removeOldReplica
argument_list|(
name|replicaInfo
argument_list|,
name|newReplicaInfo
argument_list|,
name|blockFile
argument_list|,
name|metaFile
argument_list|,
name|blockFileUsed
argument_list|,
name|metaFileUsed
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|int
name|numSuccessiveFailures
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|fsRunning
operator|&&
name|shouldRun
condition|)
block|{
try|try
block|{
name|numSuccessiveFailures
operator|=
name|saveNextReplica
argument_list|()
condition|?
literal|0
else|:
operator|(
name|numSuccessiveFailures
operator|+
literal|1
operator|)
expr_stmt|;
name|evictBlocks
argument_list|()
expr_stmt|;
comment|// Sleep if we have no more work to do or if it looks like we are not
comment|// making any forward progress. This is to ensure that if all persist
comment|// operations are failing we don't keep retrying them in a tight loop.
if|if
condition|(
name|numSuccessiveFailures
operator|>=
name|ramDiskReplicaTracker
operator|.
name|numReplicasNotPersisted
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|checkpointerInterval
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|numSuccessiveFailures
operator|=
literal|0
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"LazyWriter was interrupted, exiting"
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring exception in LazyWriter:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|setPinning (ExtendedBlock block)
specifier|public
name|void
name|setPinning
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockPinningEnabled
condition|)
block|{
return|return;
block|}
name|File
name|f
init|=
name|getBlockFile
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
name|FsPermission
name|oldPermission
init|=
name|localFS
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|)
operator|.
name|getPermission
argument_list|()
decl_stmt|;
comment|//sticky bit is used for pinning purpose
name|FsPermission
name|permission
init|=
operator|new
name|FsPermission
argument_list|(
name|oldPermission
operator|.
name|getUserAction
argument_list|()
argument_list|,
name|oldPermission
operator|.
name|getGroupAction
argument_list|()
argument_list|,
name|oldPermission
operator|.
name|getOtherAction
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|localFS
operator|.
name|setPermission
argument_list|(
name|p
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getPinning (ExtendedBlock block)
specifier|public
name|boolean
name|getPinning
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockPinningEnabled
condition|)
block|{
return|return
literal|false
return|;
block|}
name|File
name|f
init|=
name|getBlockFile
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|FileStatus
name|fss
init|=
name|localFS
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|fss
operator|.
name|getPermission
argument_list|()
operator|.
name|getStickyBit
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isDeletingBlock (String bpid, long blockId)
specifier|public
name|boolean
name|isDeletingBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|long
name|blockId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|deletingBlock
init|)
block|{
name|Set
argument_list|<
name|Long
argument_list|>
name|s
init|=
name|deletingBlock
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
return|return
name|s
operator|!=
literal|null
condition|?
name|s
operator|.
name|contains
argument_list|(
name|blockId
argument_list|)
else|:
literal|false
return|;
block|}
block|}
DECL|method|removeDeletedBlocks (String bpid, Set<Long> blockIds)
specifier|public
name|void
name|removeDeletedBlocks
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Set
argument_list|<
name|Long
argument_list|>
name|blockIds
parameter_list|)
block|{
synchronized|synchronized
init|(
name|deletingBlock
init|)
block|{
name|Set
argument_list|<
name|Long
argument_list|>
name|s
init|=
name|deletingBlock
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Long
name|id
range|:
name|blockIds
control|)
block|{
name|s
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|addDeletingBlock (String bpid, Long blockId)
specifier|private
name|void
name|addDeletingBlock
parameter_list|(
name|String
name|bpid
parameter_list|,
name|Long
name|blockId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|deletingBlock
init|)
block|{
name|Set
argument_list|<
name|Long
argument_list|>
name|s
init|=
name|deletingBlock
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|s
operator|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|deletingBlock
operator|.
name|put
argument_list|(
name|bpid
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|add
argument_list|(
name|blockId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

