begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
operator|.
name|DN_CLIENTTRACE_FORMAT
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Checksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSOutputSummer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|BlockConstructionStage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PacketHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PipelineAck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaInputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaOutputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|DataTransferThrottler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_comment
comment|/** A class that receives a block and writes to its own disk, meanwhile  * may copies it to another site. If a throttler is provided,  * streaming throttling is also supported.  **/
end_comment

begin_class
DECL|class|BlockReceiver
class|class
name|BlockReceiver
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|ClientTraceLog
specifier|static
specifier|final
name|Log
name|ClientTraceLog
init|=
name|DataNode
operator|.
name|ClientTraceLog
decl_stmt|;
DECL|field|CACHE_DROP_LAG_BYTES
specifier|private
specifier|static
specifier|final
name|long
name|CACHE_DROP_LAG_BYTES
init|=
literal|8
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
DECL|field|in
specifier|private
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
comment|// from where data are read
DECL|field|clientChecksum
specifier|private
name|DataChecksum
name|clientChecksum
decl_stmt|;
comment|// checksum used by client
DECL|field|diskChecksum
specifier|private
name|DataChecksum
name|diskChecksum
decl_stmt|;
comment|// checksum we write to disk
comment|/**    * In the case that the client is writing with a different    * checksum polynomial than the block is stored with on disk,    * the DataNode needs to recalculate checksums before writing.    */
DECL|field|needsChecksumTranslation
specifier|private
name|boolean
name|needsChecksumTranslation
decl_stmt|;
DECL|field|out
specifier|private
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
comment|// to block file at local disk
DECL|field|outFd
specifier|private
name|FileDescriptor
name|outFd
decl_stmt|;
DECL|field|cout
specifier|private
name|OutputStream
name|cout
init|=
literal|null
decl_stmt|;
comment|// output stream for cehcksum file
DECL|field|checksumOut
specifier|private
name|DataOutputStream
name|checksumOut
init|=
literal|null
decl_stmt|;
comment|// to crc file at local disk
DECL|field|bytesPerChecksum
specifier|private
name|int
name|bytesPerChecksum
decl_stmt|;
DECL|field|checksumSize
specifier|private
name|int
name|checksumSize
decl_stmt|;
DECL|field|buf
specifier|private
name|ByteBuffer
name|buf
decl_stmt|;
comment|// contains one full packet.
DECL|field|bufRead
specifier|private
name|int
name|bufRead
decl_stmt|;
comment|//amount of valid data in the buf
DECL|field|maxPacketReadLen
specifier|private
name|int
name|maxPacketReadLen
decl_stmt|;
DECL|field|inAddr
specifier|protected
specifier|final
name|String
name|inAddr
decl_stmt|;
DECL|field|myAddr
specifier|protected
specifier|final
name|String
name|myAddr
decl_stmt|;
DECL|field|mirrorAddr
specifier|private
name|String
name|mirrorAddr
decl_stmt|;
DECL|field|mirrorOut
specifier|private
name|DataOutputStream
name|mirrorOut
decl_stmt|;
DECL|field|responder
specifier|private
name|Daemon
name|responder
init|=
literal|null
decl_stmt|;
DECL|field|throttler
specifier|private
name|DataTransferThrottler
name|throttler
decl_stmt|;
DECL|field|streams
specifier|private
name|ReplicaOutputStreams
name|streams
decl_stmt|;
DECL|field|srcDataNode
specifier|private
name|DatanodeInfo
name|srcDataNode
init|=
literal|null
decl_stmt|;
DECL|field|partialCrc
specifier|private
name|Checksum
name|partialCrc
init|=
literal|null
decl_stmt|;
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|mirrorError
specifier|volatile
specifier|private
name|boolean
name|mirrorError
decl_stmt|;
comment|// Cache management state
DECL|field|dropCacheBehindWrites
specifier|private
name|boolean
name|dropCacheBehindWrites
decl_stmt|;
DECL|field|syncBehindWrites
specifier|private
name|boolean
name|syncBehindWrites
decl_stmt|;
DECL|field|lastCacheDropOffset
specifier|private
name|long
name|lastCacheDropOffset
init|=
literal|0
decl_stmt|;
comment|/** The client name.  It is empty if a datanode is the client */
DECL|field|clientname
specifier|private
specifier|final
name|String
name|clientname
decl_stmt|;
DECL|field|isClient
specifier|private
specifier|final
name|boolean
name|isClient
decl_stmt|;
DECL|field|isDatanode
specifier|private
specifier|final
name|boolean
name|isDatanode
decl_stmt|;
comment|/** the block to receive */
DECL|field|block
specifier|private
specifier|final
name|ExtendedBlock
name|block
decl_stmt|;
comment|/** the replica to write */
DECL|field|replicaInfo
specifier|private
specifier|final
name|ReplicaInPipelineInterface
name|replicaInfo
decl_stmt|;
comment|/** pipeline stage */
DECL|field|stage
specifier|private
specifier|final
name|BlockConstructionStage
name|stage
decl_stmt|;
DECL|field|isTransfer
specifier|private
specifier|final
name|boolean
name|isTransfer
decl_stmt|;
DECL|field|syncOnClose
specifier|private
name|boolean
name|syncOnClose
decl_stmt|;
DECL|method|BlockReceiver (final ExtendedBlock block, final DataInputStream in, final String inAddr, final String myAddr, final BlockConstructionStage stage, final long newGs, final long minBytesRcvd, final long maxBytesRcvd, final String clientname, final DatanodeInfo srcDataNode, final DataNode datanode, DataChecksum requestedChecksum)
name|BlockReceiver
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|,
specifier|final
name|DataInputStream
name|in
parameter_list|,
specifier|final
name|String
name|inAddr
parameter_list|,
specifier|final
name|String
name|myAddr
parameter_list|,
specifier|final
name|BlockConstructionStage
name|stage
parameter_list|,
specifier|final
name|long
name|newGs
parameter_list|,
specifier|final
name|long
name|minBytesRcvd
parameter_list|,
specifier|final
name|long
name|maxBytesRcvd
parameter_list|,
specifier|final
name|String
name|clientname
parameter_list|,
specifier|final
name|DatanodeInfo
name|srcDataNode
parameter_list|,
specifier|final
name|DataNode
name|datanode
parameter_list|,
name|DataChecksum
name|requestedChecksum
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|inAddr
operator|=
name|inAddr
expr_stmt|;
name|this
operator|.
name|myAddr
operator|=
name|myAddr
expr_stmt|;
name|this
operator|.
name|srcDataNode
operator|=
name|srcDataNode
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|clientname
operator|=
name|clientname
expr_stmt|;
name|this
operator|.
name|isDatanode
operator|=
name|clientname
operator|.
name|length
argument_list|()
operator|==
literal|0
expr_stmt|;
name|this
operator|.
name|isClient
operator|=
operator|!
name|this
operator|.
name|isDatanode
expr_stmt|;
comment|//for datanode, we have
comment|//1: clientName.length() == 0, and
comment|//2: stage == null or PIPELINE_SETUP_CREATE
name|this
operator|.
name|stage
operator|=
name|stage
expr_stmt|;
name|this
operator|.
name|isTransfer
operator|=
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_RBW
operator|||
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_FINALIZED
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
operator|+
name|block
operator|+
literal|"\n  isClient  ="
operator|+
name|isClient
operator|+
literal|", clientname="
operator|+
name|clientname
operator|+
literal|"\n  isDatanode="
operator|+
name|isDatanode
operator|+
literal|", srcDataNode="
operator|+
name|srcDataNode
operator|+
literal|"\n  inAddr="
operator|+
name|inAddr
operator|+
literal|", myAddr="
operator|+
name|myAddr
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Open local disk out
comment|//
if|if
condition|(
name|isDatanode
condition|)
block|{
comment|//replication or move
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|createTemporary
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|stage
condition|)
block|{
case|case
name|PIPELINE_SETUP_CREATE
case|:
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|createRbw
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIPELINE_SETUP_STREAMING_RECOVERY
case|:
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|recoverRbw
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|,
name|maxBytesRcvd
argument_list|)
expr_stmt|;
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIPELINE_SETUP_APPEND
case|:
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|append
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanode
operator|.
name|blockScanner
operator|!=
literal|null
condition|)
block|{
comment|// remove from block scanner
name|datanode
operator|.
name|blockScanner
operator|.
name|deleteBlock
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIPELINE_SETUP_APPEND_RECOVERY
case|:
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|recoverAppend
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanode
operator|.
name|blockScanner
operator|!=
literal|null
condition|)
block|{
comment|// remove from block scanner
name|datanode
operator|.
name|blockScanner
operator|.
name|deleteBlock
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRANSFER_RBW
case|:
case|case
name|TRANSFER_FINALIZED
case|:
comment|// this is a transfer destination
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|createTemporary
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unsupported stage "
operator|+
name|stage
operator|+
literal|" while receiving block "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|dropCacheBehindWrites
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|dropCacheBehindWrites
expr_stmt|;
name|this
operator|.
name|syncBehindWrites
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|syncBehindWrites
expr_stmt|;
specifier|final
name|boolean
name|isCreate
init|=
name|isDatanode
operator|||
name|isTransfer
operator|||
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|PIPELINE_SETUP_CREATE
decl_stmt|;
name|streams
operator|=
name|replicaInfo
operator|.
name|createStreams
argument_list|(
name|isCreate
argument_list|,
name|requestedChecksum
argument_list|)
expr_stmt|;
assert|assert
name|streams
operator|!=
literal|null
operator|:
literal|"null streams!"
assert|;
comment|// read checksum meta information
name|this
operator|.
name|clientChecksum
operator|=
name|requestedChecksum
expr_stmt|;
name|this
operator|.
name|diskChecksum
operator|=
name|streams
operator|.
name|getChecksum
argument_list|()
expr_stmt|;
name|this
operator|.
name|needsChecksumTranslation
operator|=
operator|!
name|clientChecksum
operator|.
name|equals
argument_list|(
name|diskChecksum
argument_list|)
expr_stmt|;
name|this
operator|.
name|bytesPerChecksum
operator|=
name|diskChecksum
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
name|this
operator|.
name|checksumSize
operator|=
name|diskChecksum
operator|.
name|getChecksumSize
argument_list|()
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|streams
operator|.
name|getDataOut
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|instanceof
name|FileOutputStream
condition|)
block|{
name|this
operator|.
name|outFd
operator|=
operator|(
operator|(
name|FileOutputStream
operator|)
name|out
operator|)
operator|.
name|getFD
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not get file descriptor for outputstream of class "
operator|+
name|out
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|cout
operator|=
name|streams
operator|.
name|getChecksumOut
argument_list|()
expr_stmt|;
name|this
operator|.
name|checksumOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|cout
argument_list|,
name|HdfsConstants
operator|.
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|// write data chunk header if creating a new replica
if|if
condition|(
name|isCreate
condition|)
block|{
name|BlockMetadataHeader
operator|.
name|writeHeader
argument_list|(
name|checksumOut
argument_list|,
name|diskChecksum
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReplicaAlreadyExistsException
name|bae
parameter_list|)
block|{
throw|throw
name|bae
throw|;
block|}
catch|catch
parameter_list|(
name|ReplicaNotFoundException
name|bne
parameter_list|)
block|{
throw|throw
name|bne
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|cleanupBlock
argument_list|()
expr_stmt|;
comment|// check if there is a disk error
name|IOException
name|cause
init|=
name|DatanodeUtil
operator|.
name|getCauseIfDiskError
argument_list|(
name|ioe
argument_list|)
decl_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in BlockReceiver constructor. Cause is "
argument_list|,
name|cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
comment|// possible disk error
name|ioe
operator|=
name|cause
expr_stmt|;
name|datanode
operator|.
name|checkDiskError
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
comment|// may throw an exception here
block|}
throw|throw
name|ioe
throw|;
block|}
block|}
comment|/** Return the datanode object. */
DECL|method|getDataNode ()
name|DataNode
name|getDataNode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
comment|/**    * close files.    */
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|IOException
name|ioe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|syncOnClose
operator|&&
operator|(
name|out
operator|!=
literal|null
operator|||
name|checksumOut
operator|!=
literal|null
operator|)
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|incrFsyncCount
argument_list|()
expr_stmt|;
block|}
name|long
name|flushTotalNanos
init|=
literal|0
decl_stmt|;
name|boolean
name|measuredFlushTime
init|=
literal|false
decl_stmt|;
comment|// close checksum file
try|try
block|{
if|if
condition|(
name|checksumOut
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|checksumOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|syncOnClose
operator|&&
operator|(
name|cout
operator|instanceof
name|FileOutputStream
operator|)
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
operator|(
operator|(
name|FileOutputStream
operator|)
name|cout
operator|)
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
name|measuredFlushTime
operator|=
literal|true
expr_stmt|;
name|checksumOut
operator|.
name|close
argument_list|()
expr_stmt|;
name|checksumOut
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ioe
operator|=
name|e
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|checksumOut
argument_list|)
expr_stmt|;
block|}
comment|// close block file
try|try
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|syncOnClose
operator|&&
operator|(
name|out
operator|instanceof
name|FileOutputStream
operator|)
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
operator|(
operator|(
name|FileOutputStream
operator|)
name|out
operator|)
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
name|measuredFlushTime
operator|=
literal|true
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ioe
operator|=
name|e
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|measuredFlushTime
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|addFlushNanos
argument_list|(
name|flushTotalNanos
argument_list|)
expr_stmt|;
block|}
comment|// disk check
if|if
condition|(
name|ioe
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|checkDiskError
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
comment|/**    * Flush block data and metadata files to disk.    * @throws IOException    */
DECL|method|flushOrSync (boolean isSync)
name|void
name|flushOrSync
parameter_list|(
name|boolean
name|isSync
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isSync
operator|&&
operator|(
name|out
operator|!=
literal|null
operator|||
name|checksumOut
operator|!=
literal|null
operator|)
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|incrFsyncCount
argument_list|()
expr_stmt|;
block|}
name|long
name|flushTotalNanos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|checksumOut
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|checksumOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSync
operator|&&
operator|(
name|cout
operator|instanceof
name|FileOutputStream
operator|)
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
operator|(
operator|(
name|FileOutputStream
operator|)
name|cout
operator|)
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSync
operator|&&
operator|(
name|out
operator|instanceof
name|FileOutputStream
operator|)
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
operator|(
operator|(
name|FileOutputStream
operator|)
name|out
operator|)
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
block|}
if|if
condition|(
name|checksumOut
operator|!=
literal|null
operator|||
name|out
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|addFlushNanos
argument_list|(
name|flushTotalNanos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * While writing to mirrorOut, failure to write to mirror should not    * affect this datanode unless it is caused by interruption.    */
DECL|method|handleMirrorOutError (IOException ioe)
specifier|private
name|void
name|handleMirrorOutError
parameter_list|(
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|bpid
init|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|datanode
operator|.
name|getDNRegistrationForBP
argument_list|(
name|bpid
argument_list|)
operator|+
literal|":Exception writing block "
operator|+
name|block
operator|+
literal|" to mirror "
operator|+
name|mirrorAddr
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// shut down if the thread is interrupted
throw|throw
name|ioe
throw|;
block|}
else|else
block|{
comment|// encounter an error while writing to mirror
comment|// continue to run even if can not write to mirror
comment|// notify client of the error
comment|// and wait for the client to shut down the pipeline
name|mirrorError
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**    * Verify multiple CRC chunks.     */
DECL|method|verifyChunks ( byte[] dataBuf, int dataOff, int len, byte[] checksumBuf, int checksumOff )
specifier|private
name|void
name|verifyChunks
parameter_list|(
name|byte
index|[]
name|dataBuf
parameter_list|,
name|int
name|dataOff
parameter_list|,
name|int
name|len
parameter_list|,
name|byte
index|[]
name|checksumBuf
parameter_list|,
name|int
name|checksumOff
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|chunkLen
init|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|bytesPerChecksum
argument_list|)
decl_stmt|;
name|clientChecksum
operator|.
name|update
argument_list|(
name|dataBuf
argument_list|,
name|dataOff
argument_list|,
name|chunkLen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clientChecksum
operator|.
name|compare
argument_list|(
name|checksumBuf
argument_list|,
name|checksumOff
argument_list|)
condition|)
block|{
if|if
condition|(
name|srcDataNode
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"report corrupt block "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|srcDataNode
operator|+
literal|" to namenode"
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|reportRemoteBadBlock
argument_list|(
name|srcDataNode
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to report bad block "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|srcDataNode
operator|+
literal|" to namenode"
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected checksum mismatch "
operator|+
literal|"while writing "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|)
throw|;
block|}
name|clientChecksum
operator|.
name|reset
argument_list|()
expr_stmt|;
name|dataOff
operator|+=
name|chunkLen
expr_stmt|;
name|checksumOff
operator|+=
name|checksumSize
expr_stmt|;
name|len
operator|-=
name|chunkLen
expr_stmt|;
block|}
block|}
comment|/**    * Translate CRC chunks from the client's checksum implementation    * to the disk checksum implementation.    *     * This does not verify the original checksums, under the assumption    * that they have already been validated.    */
DECL|method|translateChunks ( byte[] dataBuf, int dataOff, int len, byte[] checksumBuf, int checksumOff )
specifier|private
name|void
name|translateChunks
parameter_list|(
name|byte
index|[]
name|dataBuf
parameter_list|,
name|int
name|dataOff
parameter_list|,
name|int
name|len
parameter_list|,
name|byte
index|[]
name|checksumBuf
parameter_list|,
name|int
name|checksumOff
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
name|int
name|numChunks
init|=
operator|(
name|len
operator|-
literal|1
operator|)
operator|/
name|bytesPerChecksum
operator|+
literal|1
decl_stmt|;
name|diskChecksum
operator|.
name|calculateChunkedSums
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|dataBuf
argument_list|,
name|dataOff
argument_list|,
name|len
argument_list|)
argument_list|,
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|checksumBuf
argument_list|,
name|checksumOff
argument_list|,
name|numChunks
operator|*
name|checksumSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Makes sure buf.position() is zero without modifying buf.remaining().    * It moves the data if position needs to be changed.    */
DECL|method|shiftBufData ()
specifier|private
name|void
name|shiftBufData
parameter_list|()
block|{
if|if
condition|(
name|bufRead
operator|!=
name|buf
operator|.
name|limit
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"bufRead should be same as "
operator|+
literal|"buf.limit()"
argument_list|)
throw|;
block|}
comment|//shift the remaining data on buf to the front
if|if
condition|(
name|buf
operator|.
name|position
argument_list|()
operator|>
literal|0
condition|)
block|{
name|int
name|dataLeft
init|=
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataLeft
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|b
init|=
name|buf
operator|.
name|array
argument_list|()
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|dataLeft
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bufRead
operator|=
name|dataLeft
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|bufRead
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * reads upto toRead byte to buf at buf.limit() and increments the limit.    * throws an IOException if read does not succeed.    */
DECL|method|readToBuf (int toRead)
specifier|private
name|int
name|readToBuf
parameter_list|(
name|int
name|toRead
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|toRead
operator|<
literal|0
condition|)
block|{
name|toRead
operator|=
operator|(
name|maxPacketReadLen
operator|>
literal|0
condition|?
name|maxPacketReadLen
else|:
name|buf
operator|.
name|capacity
argument_list|()
operator|)
operator|-
name|buf
operator|.
name|limit
argument_list|()
expr_stmt|;
block|}
name|int
name|nRead
init|=
name|in
operator|.
name|read
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|limit
argument_list|()
argument_list|,
name|toRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|nRead
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"while trying to read "
operator|+
name|toRead
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
name|bufRead
operator|=
name|buf
operator|.
name|limit
argument_list|()
operator|+
name|nRead
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|bufRead
argument_list|)
expr_stmt|;
return|return
name|nRead
return|;
block|}
comment|/**    * Reads (at least) one packet and returns the packet length.    * buf.position() points to the start of the packet and     * buf.limit() point to the end of the packet. There could     * be more data from next packet in buf.<br><br>    *     * It tries to read a full packet with single read call.    * Consecutive packets are usually of the same length.    */
DECL|method|readNextPacket ()
specifier|private
name|void
name|readNextPacket
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* This dances around buf a little bit, mainly to read       * full packet with single read and to accept arbitrary size        * for next packet at the same time.      */
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
comment|/* initialize buffer to the best guess size:        * 'chunksPerPacket' calculation here should match the same         * calculation in DFSClient to make the guess accurate.        */
name|int
name|chunkSize
init|=
name|bytesPerChecksum
operator|+
name|checksumSize
decl_stmt|;
name|int
name|chunksPerPacket
init|=
operator|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|writePacketSize
operator|-
name|PacketHeader
operator|.
name|PKT_HEADER_LEN
operator|+
name|chunkSize
operator|-
literal|1
operator|)
operator|/
name|chunkSize
decl_stmt|;
name|buf
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|PacketHeader
operator|.
name|PKT_HEADER_LEN
operator|+
name|Math
operator|.
name|max
argument_list|(
name|chunksPerPacket
argument_list|,
literal|1
argument_list|)
operator|*
name|chunkSize
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// See if there is data left in the buffer :
if|if
condition|(
name|bufRead
operator|>
name|buf
operator|.
name|limit
argument_list|()
condition|)
block|{
name|buf
operator|.
name|limit
argument_list|(
name|bufRead
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|<
name|HdfsConstants
operator|.
name|BYTES_IN_INTEGER
condition|)
block|{
if|if
condition|(
name|buf
operator|.
name|position
argument_list|()
operator|>
literal|0
condition|)
block|{
name|shiftBufData
argument_list|()
expr_stmt|;
block|}
name|readToBuf
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We mostly have the full packet or at least enough for an int      */
name|buf
operator|.
name|mark
argument_list|()
expr_stmt|;
name|int
name|payloadLen
init|=
name|buf
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|buf
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// check corrupt values for pktLen, 100MB upper limit should be ok?
if|if
condition|(
name|payloadLen
argument_list|<
literal|0
operator|||
name|payloadLen
argument_list|>
argument_list|(
literal|100
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incorrect value for packet payload : "
operator|+
name|payloadLen
argument_list|)
throw|;
block|}
comment|// Subtract BYTES_IN_INTEGER since that accounts for the payloadLen that
comment|// we read above.
name|int
name|pktSize
init|=
name|payloadLen
operator|+
name|PacketHeader
operator|.
name|PKT_HEADER_LEN
operator|-
name|HdfsConstants
operator|.
name|BYTES_IN_INTEGER
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|<
name|pktSize
condition|)
block|{
comment|//we need to read more data
name|int
name|toRead
init|=
name|pktSize
operator|-
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
comment|// first make sure buf has enough space.
name|int
name|spaceLeft
init|=
name|buf
operator|.
name|capacity
argument_list|()
operator|-
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
if|if
condition|(
name|toRead
operator|>
name|spaceLeft
operator|&&
name|buf
operator|.
name|position
argument_list|()
operator|>
literal|0
condition|)
block|{
name|shiftBufData
argument_list|()
expr_stmt|;
name|spaceLeft
operator|=
name|buf
operator|.
name|capacity
argument_list|()
operator|-
name|buf
operator|.
name|limit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|toRead
operator|>
name|spaceLeft
condition|)
block|{
name|byte
name|oldBuf
index|[]
init|=
name|buf
operator|.
name|array
argument_list|()
decl_stmt|;
name|int
name|toCopy
init|=
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|buf
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|toCopy
operator|+
name|toRead
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|oldBuf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|array
argument_list|()
argument_list|,
literal|0
argument_list|,
name|toCopy
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|toCopy
argument_list|)
expr_stmt|;
block|}
comment|//now read:
while|while
condition|(
name|toRead
operator|>
literal|0
condition|)
block|{
name|toRead
operator|-=
name|readToBuf
argument_list|(
name|toRead
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>
name|pktSize
condition|)
block|{
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|pktSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pktSize
operator|>
name|maxPacketReadLen
condition|)
block|{
name|maxPacketReadLen
operator|=
name|pktSize
expr_stmt|;
block|}
block|}
comment|/**     * Receives and processes a packet. It can contain many chunks.    * returns the number of data bytes that the packet has.    */
DECL|method|receivePacket ()
specifier|private
name|int
name|receivePacket
parameter_list|()
throws|throws
name|IOException
block|{
comment|// read the next packet
name|readNextPacket
argument_list|()
expr_stmt|;
name|buf
operator|.
name|mark
argument_list|()
expr_stmt|;
name|PacketHeader
name|header
init|=
operator|new
name|PacketHeader
argument_list|()
decl_stmt|;
name|header
operator|.
name|readFields
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|int
name|endOfHeader
init|=
name|buf
operator|.
name|position
argument_list|()
decl_stmt|;
name|buf
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Sanity check the header
if|if
condition|(
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|>
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Received an out-of-sequence packet for "
operator|+
name|block
operator|+
literal|"from "
operator|+
name|inAddr
operator|+
literal|" at offset "
operator|+
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
literal|". Expecting packet starting at "
operator|+
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|header
operator|.
name|getDataLen
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got wrong length during writeBlock("
operator|+
name|block
operator|+
literal|") from "
operator|+
name|inAddr
operator|+
literal|" at offset "
operator|+
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
literal|": "
operator|+
name|header
operator|.
name|getDataLen
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|receivePacket
argument_list|(
name|header
operator|.
name|getOffsetInBlock
argument_list|()
argument_list|,
name|header
operator|.
name|getSeqno
argument_list|()
argument_list|,
name|header
operator|.
name|isLastPacketInBlock
argument_list|()
argument_list|,
name|header
operator|.
name|getDataLen
argument_list|()
argument_list|,
name|header
operator|.
name|getSyncBlock
argument_list|()
argument_list|,
name|endOfHeader
argument_list|)
return|;
block|}
comment|/**    * Write the received packet to disk (data only)    */
DECL|method|writePacketToDisk (byte[] pktBuf, int startByteToDisk, int numBytesToDisk)
specifier|private
name|void
name|writePacketToDisk
parameter_list|(
name|byte
index|[]
name|pktBuf
parameter_list|,
name|int
name|startByteToDisk
parameter_list|,
name|int
name|numBytesToDisk
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|pktBuf
argument_list|,
name|startByteToDisk
argument_list|,
name|numBytesToDisk
argument_list|)
expr_stmt|;
block|}
comment|/**     * Receives and processes a packet. It can contain many chunks.    * returns the number of data bytes that the packet has.    */
DECL|method|receivePacket (long offsetInBlock, long seqno, boolean lastPacketInBlock, int len, boolean syncBlock, int endOfHeader)
specifier|private
name|int
name|receivePacket
parameter_list|(
name|long
name|offsetInBlock
parameter_list|,
name|long
name|seqno
parameter_list|,
name|boolean
name|lastPacketInBlock
parameter_list|,
name|int
name|len
parameter_list|,
name|boolean
name|syncBlock
parameter_list|,
name|int
name|endOfHeader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Receiving one packet for block "
operator|+
name|block
operator|+
literal|" of length "
operator|+
name|len
operator|+
literal|" seqno "
operator|+
name|seqno
operator|+
literal|" offsetInBlock "
operator|+
name|offsetInBlock
operator|+
literal|" syncBlock "
operator|+
name|syncBlock
operator|+
literal|" lastPacketInBlock "
operator|+
name|lastPacketInBlock
argument_list|)
expr_stmt|;
block|}
comment|// make sure the block gets sync'ed upon close
name|this
operator|.
name|syncOnClose
operator||=
name|syncBlock
operator|&&
name|lastPacketInBlock
expr_stmt|;
comment|// update received bytes
name|long
name|firstByteInBlock
init|=
name|offsetInBlock
decl_stmt|;
name|offsetInBlock
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|<
name|offsetInBlock
condition|)
block|{
name|replicaInfo
operator|.
name|setNumBytes
argument_list|(
name|offsetInBlock
argument_list|)
expr_stmt|;
block|}
comment|// put in queue for pending acks
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|enqueue
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|)
expr_stmt|;
block|}
comment|//First write the packet to the mirror:
if|if
condition|(
name|mirrorOut
operator|!=
literal|null
operator|&&
operator|!
name|mirrorError
condition|)
block|{
try|try
block|{
name|mirrorOut
operator|.
name|write
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
name|mirrorOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|handleMirrorOutError
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|position
argument_list|(
name|endOfHeader
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastPacketInBlock
operator|||
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Receiving an empty packet or the end of the block "
operator|+
name|block
argument_list|)
expr_stmt|;
block|}
comment|// flush unless close() would flush anyway
if|if
condition|(
name|syncBlock
operator|&&
operator|!
name|lastPacketInBlock
condition|)
block|{
name|flushOrSync
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|checksumLen
init|=
operator|(
operator|(
name|len
operator|+
name|bytesPerChecksum
operator|-
literal|1
operator|)
operator|/
name|bytesPerChecksum
operator|)
operator|*
name|checksumSize
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|!=
operator|(
name|checksumLen
operator|+
name|len
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Data remaining in packet does not match"
operator|+
literal|"sum of checksumLen and dataLen "
operator|+
literal|" size remaining: "
operator|+
name|buf
operator|.
name|remaining
argument_list|()
operator|+
literal|" data len: "
operator|+
name|len
operator|+
literal|" checksum Len: "
operator|+
name|checksumLen
argument_list|)
throw|;
block|}
name|int
name|checksumOff
init|=
name|buf
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|dataOff
init|=
name|checksumOff
operator|+
name|checksumLen
decl_stmt|;
name|byte
name|pktBuf
index|[]
init|=
name|buf
operator|.
name|array
argument_list|()
decl_stmt|;
name|buf
operator|.
name|position
argument_list|(
name|buf
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
comment|// move to the end of the data.
comment|/* skip verifying checksum iff this is not the last one in the         * pipeline and clientName is non-null. i.e. Checksum is verified        * on all the datanodes when the data is being written by a         * datanode rather than a client. Whe client is writing the data,         * protocol includes acks and only the last datanode needs to verify         * checksum.        */
if|if
condition|(
name|mirrorOut
operator|==
literal|null
operator|||
name|isDatanode
operator|||
name|needsChecksumTranslation
condition|)
block|{
name|verifyChunks
argument_list|(
name|pktBuf
argument_list|,
name|dataOff
argument_list|,
name|len
argument_list|,
name|pktBuf
argument_list|,
name|checksumOff
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsChecksumTranslation
condition|)
block|{
comment|// overwrite the checksums in the packet buffer with the
comment|// appropriate polynomial for the disk storage.
name|translateChunks
argument_list|(
name|pktBuf
argument_list|,
name|dataOff
argument_list|,
name|len
argument_list|,
name|pktBuf
argument_list|,
name|checksumOff
argument_list|)
expr_stmt|;
block|}
block|}
comment|// by this point, the data in the buffer uses the disk checksum
name|byte
index|[]
name|lastChunkChecksum
decl_stmt|;
try|try
block|{
name|long
name|onDiskLen
init|=
name|replicaInfo
operator|.
name|getBytesOnDisk
argument_list|()
decl_stmt|;
if|if
condition|(
name|onDiskLen
operator|<
name|offsetInBlock
condition|)
block|{
comment|//finally write to the disk :
if|if
condition|(
name|onDiskLen
operator|%
name|bytesPerChecksum
operator|!=
literal|0
condition|)
block|{
comment|// prepare to overwrite last checksum
name|adjustCrcFilePosition
argument_list|()
expr_stmt|;
block|}
comment|// If this is a partial chunk, then read in pre-existing checksum
if|if
condition|(
name|firstByteInBlock
operator|%
name|bytesPerChecksum
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Packet starts at "
operator|+
name|firstByteInBlock
operator|+
literal|" for block "
operator|+
name|block
operator|+
literal|" which is not a multiple of bytesPerChecksum "
operator|+
name|bytesPerChecksum
argument_list|)
expr_stmt|;
name|long
name|offsetInChecksum
init|=
name|BlockMetadataHeader
operator|.
name|getHeaderSize
argument_list|()
operator|+
name|onDiskLen
operator|/
name|bytesPerChecksum
operator|*
name|checksumSize
decl_stmt|;
name|computePartialChunkCrc
argument_list|(
name|onDiskLen
argument_list|,
name|offsetInChecksum
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
block|}
name|int
name|startByteToDisk
init|=
name|dataOff
operator|+
call|(
name|int
call|)
argument_list|(
name|onDiskLen
operator|-
name|firstByteInBlock
argument_list|)
decl_stmt|;
name|int
name|numBytesToDisk
init|=
call|(
name|int
call|)
argument_list|(
name|offsetInBlock
operator|-
name|onDiskLen
argument_list|)
decl_stmt|;
name|writePacketToDisk
argument_list|(
name|pktBuf
argument_list|,
name|startByteToDisk
argument_list|,
name|numBytesToDisk
argument_list|)
expr_stmt|;
comment|// If this is a partial chunk, then verify that this is the only
comment|// chunk in the packet. Calculate new crc for this chunk.
if|if
condition|(
name|partialCrc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|bytesPerChecksum
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got wrong length during writeBlock("
operator|+
name|block
operator|+
literal|") from "
operator|+
name|inAddr
operator|+
literal|" "
operator|+
literal|"A packet can have only one partial chunk."
operator|+
literal|" len = "
operator|+
name|len
operator|+
literal|" bytesPerChecksum "
operator|+
name|bytesPerChecksum
argument_list|)
throw|;
block|}
name|partialCrc
operator|.
name|update
argument_list|(
name|pktBuf
argument_list|,
name|startByteToDisk
argument_list|,
name|numBytesToDisk
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
name|FSOutputSummer
operator|.
name|convertToByteStream
argument_list|(
name|partialCrc
argument_list|,
name|checksumSize
argument_list|)
decl_stmt|;
name|lastChunkChecksum
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buf
argument_list|,
name|buf
operator|.
name|length
operator|-
name|checksumSize
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|checksumOut
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Writing out partial crc for data len "
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
name|partialCrc
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|lastChunkChecksum
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|pktBuf
argument_list|,
name|checksumOff
operator|+
name|checksumLen
operator|-
name|checksumSize
argument_list|,
name|checksumOff
operator|+
name|checksumLen
argument_list|)
expr_stmt|;
name|checksumOut
operator|.
name|write
argument_list|(
name|pktBuf
argument_list|,
name|checksumOff
argument_list|,
name|checksumLen
argument_list|)
expr_stmt|;
block|}
comment|/// flush entire packet, sync unless close() will sync
name|flushOrSync
argument_list|(
name|syncBlock
operator|&&
operator|!
name|lastPacketInBlock
argument_list|)
expr_stmt|;
name|replicaInfo
operator|.
name|setLastChecksumAndDataLen
argument_list|(
name|offsetInBlock
argument_list|,
name|lastChunkChecksum
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|incrBytesWritten
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|dropOsCacheBehindWriter
argument_list|(
name|offsetInBlock
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{
name|datanode
operator|.
name|checkDiskError
argument_list|(
name|iex
argument_list|)
expr_stmt|;
throw|throw
name|iex
throw|;
block|}
block|}
if|if
condition|(
name|throttler
operator|!=
literal|null
condition|)
block|{
comment|// throttle I/O
name|throttler
operator|.
name|throttle
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|lastPacketInBlock
condition|?
operator|-
literal|1
else|:
name|len
return|;
block|}
DECL|method|dropOsCacheBehindWriter (long offsetInBlock)
specifier|private
name|void
name|dropOsCacheBehindWriter
parameter_list|(
name|long
name|offsetInBlock
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|outFd
operator|!=
literal|null
operator|&&
name|offsetInBlock
operator|>
name|lastCacheDropOffset
operator|+
name|CACHE_DROP_LAG_BYTES
condition|)
block|{
name|long
name|twoWindowsAgo
init|=
name|lastCacheDropOffset
operator|-
name|CACHE_DROP_LAG_BYTES
decl_stmt|;
if|if
condition|(
name|twoWindowsAgo
operator|>
literal|0
operator|&&
name|dropCacheBehindWrites
condition|)
block|{
name|NativeIO
operator|.
name|posixFadviseIfPossible
argument_list|(
name|outFd
argument_list|,
literal|0
argument_list|,
name|lastCacheDropOffset
argument_list|,
name|NativeIO
operator|.
name|POSIX_FADV_DONTNEED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|syncBehindWrites
condition|)
block|{
name|NativeIO
operator|.
name|syncFileRangeIfPossible
argument_list|(
name|outFd
argument_list|,
name|lastCacheDropOffset
argument_list|,
name|CACHE_DROP_LAG_BYTES
argument_list|,
name|NativeIO
operator|.
name|SYNC_FILE_RANGE_WRITE
argument_list|)
expr_stmt|;
block|}
name|lastCacheDropOffset
operator|+=
name|CACHE_DROP_LAG_BYTES
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't drop os cache behind writer for "
operator|+
name|block
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|receiveBlock ( DataOutputStream mirrOut, DataInputStream mirrIn, DataOutputStream replyOut, String mirrAddr, DataTransferThrottler throttlerArg, DatanodeInfo[] downstreams)
name|void
name|receiveBlock
parameter_list|(
name|DataOutputStream
name|mirrOut
parameter_list|,
comment|// output to next datanode
name|DataInputStream
name|mirrIn
parameter_list|,
comment|// input from next datanode
name|DataOutputStream
name|replyOut
parameter_list|,
comment|// output to previous datanode
name|String
name|mirrAddr
parameter_list|,
name|DataTransferThrottler
name|throttlerArg
parameter_list|,
name|DatanodeInfo
index|[]
name|downstreams
parameter_list|)
throws|throws
name|IOException
block|{
name|syncOnClose
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|syncOnClose
expr_stmt|;
name|boolean
name|responderClosed
init|=
literal|false
decl_stmt|;
name|mirrorOut
operator|=
name|mirrOut
expr_stmt|;
name|mirrorAddr
operator|=
name|mirrAddr
expr_stmt|;
name|throttler
operator|=
name|throttlerArg
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isClient
operator|&&
operator|!
name|isTransfer
condition|)
block|{
name|responder
operator|=
operator|new
name|Daemon
argument_list|(
name|datanode
operator|.
name|threadGroup
argument_list|,
operator|new
name|PacketResponder
argument_list|(
name|replyOut
argument_list|,
name|mirrIn
argument_list|,
name|downstreams
argument_list|)
argument_list|)
expr_stmt|;
name|responder
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// start thread to processes responses
block|}
comment|/*         * Receive until the last packet.        */
while|while
condition|(
name|receivePacket
argument_list|()
operator|>=
literal|0
condition|)
block|{}
comment|// wait for all outstanding packet responses. And then
comment|// indicate responder to gracefully shutdown.
comment|// Mark that responder has been closed for future processing
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|responderClosed
operator|=
literal|true
expr_stmt|;
block|}
comment|// If this write is for a replication or transfer-RBW/Finalized,
comment|// then finalize block or convert temporary to RBW.
comment|// For client-writes, the block is finalized in the PacketResponder.
if|if
condition|(
name|isDatanode
operator|||
name|isTransfer
condition|)
block|{
comment|// close the block/crc files
name|close
argument_list|()
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_RBW
condition|)
block|{
comment|// for TRANSFER_RBW, convert temporary to RBW
name|datanode
operator|.
name|data
operator|.
name|convertTemporaryToRbw
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for isDatnode or TRANSFER_FINALIZED
comment|// Finalize the block.
name|datanode
operator|.
name|data
operator|.
name|finalizeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
name|datanode
operator|.
name|metrics
operator|.
name|incrBlocksWritten
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception in receiveBlock for "
operator|+
name|block
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|responderClosed
condition|)
block|{
comment|// Abnormal termination of the flow above
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|cleanupBlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|responder
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted receiveBlock"
argument_list|)
throw|;
block|}
name|responder
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/** Cleanup a partial block     * if this write is for a replication request (and not from a client)    */
DECL|method|cleanupBlock ()
specifier|private
name|void
name|cleanupBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isDatanode
condition|)
block|{
name|datanode
operator|.
name|data
operator|.
name|unfinalizeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adjust the file pointer in the local meta file so that the last checksum    * will be overwritten.    */
DECL|method|adjustCrcFilePosition ()
specifier|private
name|void
name|adjustCrcFilePosition
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|checksumOut
operator|!=
literal|null
condition|)
block|{
name|checksumOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|// rollback the position of the meta file
name|datanode
operator|.
name|data
operator|.
name|adjustCrcChannelPosition
argument_list|(
name|block
argument_list|,
name|streams
argument_list|,
name|checksumSize
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convert a checksum byte array to a long    */
DECL|method|checksum2long (byte[] checksum)
specifier|static
specifier|private
name|long
name|checksum2long
parameter_list|(
name|byte
index|[]
name|checksum
parameter_list|)
block|{
name|long
name|crc
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|checksum
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator||=
operator|(
literal|0xffL
operator|&
operator|(
name|long
operator|)
name|checksum
index|[
name|i
index|]
operator|)
operator|<<
operator|(
operator|(
name|checksum
operator|.
name|length
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
block|}
return|return
name|crc
return|;
block|}
comment|/**    * reads in the partial crc chunk and computes checksum    * of pre-existing data in partial chunk.    */
DECL|method|computePartialChunkCrc (long blkoff, long ckoff, int bytesPerChecksum)
specifier|private
name|void
name|computePartialChunkCrc
parameter_list|(
name|long
name|blkoff
parameter_list|,
name|long
name|ckoff
parameter_list|,
name|int
name|bytesPerChecksum
parameter_list|)
throws|throws
name|IOException
block|{
comment|// find offset of the beginning of partial chunk.
comment|//
name|int
name|sizePartialChunk
init|=
call|(
name|int
call|)
argument_list|(
name|blkoff
operator|%
name|bytesPerChecksum
argument_list|)
decl_stmt|;
name|int
name|checksumSize
init|=
name|diskChecksum
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
name|blkoff
operator|=
name|blkoff
operator|-
name|sizePartialChunk
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"computePartialChunkCrc sizePartialChunk "
operator|+
name|sizePartialChunk
operator|+
literal|" block "
operator|+
name|block
operator|+
literal|" offset in block "
operator|+
name|blkoff
operator|+
literal|" offset in metafile "
operator|+
name|ckoff
argument_list|)
expr_stmt|;
comment|// create an input stream from the block file
comment|// and read in partial crc chunk into temporary buffer
comment|//
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|sizePartialChunk
index|]
decl_stmt|;
name|byte
index|[]
name|crcbuf
init|=
operator|new
name|byte
index|[
name|checksumSize
index|]
decl_stmt|;
name|ReplicaInputStreams
name|instr
init|=
literal|null
decl_stmt|;
try|try
block|{
name|instr
operator|=
name|datanode
operator|.
name|data
operator|.
name|getTmpInputStreams
argument_list|(
name|block
argument_list|,
name|blkoff
argument_list|,
name|ckoff
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|instr
operator|.
name|getDataIn
argument_list|()
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|sizePartialChunk
argument_list|)
expr_stmt|;
comment|// open meta file and read in crc value computer earlier
name|IOUtils
operator|.
name|readFully
argument_list|(
name|instr
operator|.
name|getChecksumIn
argument_list|()
argument_list|,
name|crcbuf
argument_list|,
literal|0
argument_list|,
name|crcbuf
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|instr
argument_list|)
expr_stmt|;
block|}
comment|// compute crc of partial chunk from data read in the block file.
name|partialCrc
operator|=
name|DataChecksum
operator|.
name|newDataChecksum
argument_list|(
name|diskChecksum
operator|.
name|getChecksumType
argument_list|()
argument_list|,
name|diskChecksum
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
expr_stmt|;
name|partialCrc
operator|.
name|update
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|sizePartialChunk
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Read in partial CRC chunk from disk for block "
operator|+
name|block
argument_list|)
expr_stmt|;
comment|// paranoia! verify that the pre-computed crc matches what we
comment|// recalculated just now
if|if
condition|(
name|partialCrc
operator|.
name|getValue
argument_list|()
operator|!=
name|checksum2long
argument_list|(
name|crcbuf
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Partial CRC "
operator|+
name|partialCrc
operator|.
name|getValue
argument_list|()
operator|+
literal|" does not match value computed the "
operator|+
literal|" last time file was closed "
operator|+
name|checksum2long
argument_list|(
name|crcbuf
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
DECL|enum|PacketResponderType
specifier|private
specifier|static
enum|enum
name|PacketResponderType
block|{
DECL|enumConstant|NON_PIPELINE
DECL|enumConstant|LAST_IN_PIPELINE
DECL|enumConstant|HAS_DOWNSTREAM_IN_PIPELINE
name|NON_PIPELINE
block|,
name|LAST_IN_PIPELINE
block|,
name|HAS_DOWNSTREAM_IN_PIPELINE
block|}
comment|/**    * Processed responses from downstream datanodes in the pipeline    * and sends back replies to the originator.    */
DECL|class|PacketResponder
class|class
name|PacketResponder
implements|implements
name|Runnable
implements|,
name|Closeable
block|{
comment|/** queue for packets waiting for ack */
DECL|field|ackQueue
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|Packet
argument_list|>
name|ackQueue
init|=
operator|new
name|LinkedList
argument_list|<
name|Packet
argument_list|>
argument_list|()
decl_stmt|;
comment|/** the thread that spawns this responder */
DECL|field|receiverThread
specifier|private
specifier|final
name|Thread
name|receiverThread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
comment|/** is this responder running? */
DECL|field|running
specifier|private
specifier|volatile
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|/** input from the next downstream datanode */
DECL|field|downstreamIn
specifier|private
specifier|final
name|DataInputStream
name|downstreamIn
decl_stmt|;
comment|/** output to upstream datanode/client */
DECL|field|upstreamOut
specifier|private
specifier|final
name|DataOutputStream
name|upstreamOut
decl_stmt|;
comment|/** The type of this responder */
DECL|field|type
specifier|private
specifier|final
name|PacketResponderType
name|type
decl_stmt|;
comment|/** for log and error messages */
DECL|field|myString
specifier|private
specifier|final
name|String
name|myString
decl_stmt|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|myString
return|;
block|}
DECL|method|PacketResponder (final DataOutputStream upstreamOut, final DataInputStream downstreamIn, final DatanodeInfo[] downstreams)
name|PacketResponder
parameter_list|(
specifier|final
name|DataOutputStream
name|upstreamOut
parameter_list|,
specifier|final
name|DataInputStream
name|downstreamIn
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|downstreams
parameter_list|)
block|{
name|this
operator|.
name|downstreamIn
operator|=
name|downstreamIn
expr_stmt|;
name|this
operator|.
name|upstreamOut
operator|=
name|upstreamOut
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|downstreams
operator|==
literal|null
condition|?
name|PacketResponderType
operator|.
name|NON_PIPELINE
else|:
name|downstreams
operator|.
name|length
operator|==
literal|0
condition|?
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
else|:
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
expr_stmt|;
specifier|final
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
operator|.
name|append
argument_list|(
name|block
argument_list|)
operator|.
name|append
argument_list|(
literal|", type="
argument_list|)
operator|.
name|append
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|", downstreams="
argument_list|)
operator|.
name|append
argument_list|(
name|downstreams
operator|.
name|length
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|downstreams
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|myString
operator|=
name|b
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|/**      * enqueue the seqno that is still be to acked by the downstream datanode.      * @param seqno      * @param lastPacketInBlock      * @param offsetInBlock      */
DECL|method|enqueue (final long seqno, final boolean lastPacketInBlock, final long offsetInBlock)
specifier|synchronized
name|void
name|enqueue
parameter_list|(
specifier|final
name|long
name|seqno
parameter_list|,
specifier|final
name|boolean
name|lastPacketInBlock
parameter_list|,
specifier|final
name|long
name|offsetInBlock
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
specifier|final
name|Packet
name|p
init|=
operator|new
name|Packet
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|": enqueue "
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
name|ackQueue
operator|.
name|addLast
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * wait for all pending packets to be acked. Then shutdown thread.      */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
while|while
condition|(
name|running
operator|&&
name|ackQueue
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|&&
name|datanode
operator|.
name|shouldRun
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|running
operator|=
literal|false
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|": closing"
argument_list|)
expr_stmt|;
block|}
name|running
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/**      * Thread to process incoming acks.      * @see java.lang.Runnable#run()      */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|boolean
name|lastPacketInBlock
init|=
literal|false
decl_stmt|;
specifier|final
name|long
name|startTime
init|=
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|running
operator|&&
name|datanode
operator|.
name|shouldRun
operator|&&
operator|!
name|lastPacketInBlock
condition|)
block|{
name|long
name|totalAckTimeNanos
init|=
literal|0
decl_stmt|;
name|boolean
name|isInterrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Packet
name|pkt
init|=
literal|null
decl_stmt|;
name|long
name|expected
init|=
operator|-
literal|2
decl_stmt|;
name|PipelineAck
name|ack
init|=
operator|new
name|PipelineAck
argument_list|()
decl_stmt|;
name|long
name|seqno
init|=
name|PipelineAck
operator|.
name|UNKOWN_SEQNO
decl_stmt|;
name|long
name|ackRecvNanoTime
init|=
literal|0
decl_stmt|;
try|try
block|{
if|if
condition|(
name|type
operator|!=
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
operator|&&
operator|!
name|mirrorError
condition|)
block|{
comment|// read an ack from downstream datanode
name|ack
operator|.
name|readFields
argument_list|(
name|downstreamIn
argument_list|)
expr_stmt|;
name|ackRecvNanoTime
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|" got "
operator|+
name|ack
argument_list|)
expr_stmt|;
block|}
name|seqno
operator|=
name|ack
operator|.
name|getSeqno
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|seqno
operator|!=
name|PipelineAck
operator|.
name|UNKOWN_SEQNO
operator|||
name|type
operator|==
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
while|while
condition|(
name|running
operator|&&
name|datanode
operator|.
name|shouldRun
operator|&&
name|ackQueue
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|": seqno="
operator|+
name|seqno
operator|+
literal|" waiting for local datanode to finish write."
argument_list|)
expr_stmt|;
block|}
name|wait
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|running
operator|||
operator|!
name|datanode
operator|.
name|shouldRun
condition|)
block|{
break|break;
block|}
name|pkt
operator|=
name|ackQueue
operator|.
name|getFirst
argument_list|()
expr_stmt|;
name|expected
operator|=
name|pkt
operator|.
name|seqno
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
operator|&&
name|seqno
operator|!=
name|expected
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|myString
operator|+
literal|"seqno: expected="
operator|+
name|expected
operator|+
literal|", received="
operator|+
name|seqno
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|==
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
condition|)
block|{
comment|// The total ack time includes the ack times of downstream nodes.
comment|// The value is 0 if this responder doesn't have a downstream
comment|// DN in the pipeline.
name|totalAckTimeNanos
operator|=
name|ackRecvNanoTime
operator|-
name|pkt
operator|.
name|ackEnqueueNanoTime
expr_stmt|;
comment|// Report the elapsed time from ack send to ack receive minus
comment|// the downstream ack time.
name|long
name|ackTimeNanos
init|=
name|totalAckTimeNanos
operator|-
name|ack
operator|.
name|getDownstreamAckTimeNanos
argument_list|()
decl_stmt|;
if|if
condition|(
name|ackTimeNanos
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Calculated invalid ack time: "
operator|+
name|ackTimeNanos
operator|+
literal|"ns."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|datanode
operator|.
name|metrics
operator|.
name|addPacketAckRoundTripTimeNanos
argument_list|(
name|ackTimeNanos
argument_list|)
expr_stmt|;
block|}
block|}
name|lastPacketInBlock
operator|=
name|pkt
operator|.
name|lastPacketInBlock
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ine
parameter_list|)
block|{
name|isInterrupted
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|isInterrupted
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// continue to run even if can not read from mirror
comment|// notify client of the error
comment|// and wait for the client to shut down the pipeline
name|mirrorError
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|myString
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
operator|||
name|isInterrupted
condition|)
block|{
comment|/* The receiver thread cancelled this thread.                 * We could also check any other status updates from the                 * receiver thread (e.g. if it is ok to write to replyOut).                 * It is prudent to not send any more status back to the client                * because this datanode has a problem. The upstream datanode                * will detect that this datanode is bad, and rightly so.                */
name|LOG
operator|.
name|info
argument_list|(
name|myString
operator|+
literal|": Thread is interrupted."
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
comment|// If this is the last packet in block, then close block
comment|// file and finalize the block before responding success
if|if
condition|(
name|lastPacketInBlock
condition|)
block|{
name|BlockReceiver
operator|.
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|long
name|endTime
init|=
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|data
operator|.
name|finalizeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|closeBlock
argument_list|(
name|block
argument_list|,
name|DataNode
operator|.
name|EMPTY_DEL_HINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isClient
condition|)
block|{
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|DatanodeRegistration
name|dnR
init|=
name|datanode
operator|.
name|getDNRegistrationForBP
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|ClientTraceLog
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|DN_CLIENTTRACE_FORMAT
argument_list|,
name|inAddr
argument_list|,
name|myAddr
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|"HDFS_WRITE"
argument_list|,
name|clientname
argument_list|,
name|offset
argument_list|,
name|dnR
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|block
argument_list|,
name|endTime
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received block "
operator|+
name|block
operator|+
literal|" of size "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// construct my ack message
name|Status
index|[]
name|replies
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|mirrorError
condition|)
block|{
comment|// ack read error
name|replies
operator|=
operator|new
name|Status
index|[
literal|2
index|]
expr_stmt|;
name|replies
index|[
literal|0
index|]
operator|=
name|Status
operator|.
name|SUCCESS
expr_stmt|;
name|replies
index|[
literal|1
index|]
operator|=
name|Status
operator|.
name|ERROR
expr_stmt|;
block|}
else|else
block|{
name|short
name|ackLen
init|=
name|type
operator|==
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
condition|?
literal|0
else|:
name|ack
operator|.
name|getNumOfReplies
argument_list|()
decl_stmt|;
name|replies
operator|=
operator|new
name|Status
index|[
literal|1
operator|+
name|ackLen
index|]
expr_stmt|;
name|replies
index|[
literal|0
index|]
operator|=
name|Status
operator|.
name|SUCCESS
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ackLen
condition|;
name|i
operator|++
control|)
block|{
name|replies
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|ack
operator|.
name|getReply
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|PipelineAck
name|replyAck
init|=
operator|new
name|PipelineAck
argument_list|(
name|expected
argument_list|,
name|replies
argument_list|,
name|totalAckTimeNanos
argument_list|)
decl_stmt|;
if|if
condition|(
name|replyAck
operator|.
name|isSuccess
argument_list|()
operator|&&
name|pkt
operator|.
name|offsetInBlock
operator|>
name|replicaInfo
operator|.
name|getBytesAcked
argument_list|()
condition|)
name|replicaInfo
operator|.
name|setBytesAcked
argument_list|(
name|pkt
operator|.
name|offsetInBlock
argument_list|)
expr_stmt|;
comment|// send my ack back to upstream datanode
name|replyAck
operator|.
name|write
argument_list|(
name|upstreamOut
argument_list|)
expr_stmt|;
name|upstreamOut
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|", replyAck="
operator|+
name|replyAck
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pkt
operator|!=
literal|null
condition|)
block|{
comment|// remove the packet from the ack queue
name|removeAckHead
argument_list|()
expr_stmt|;
comment|// update bytes acked
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in BlockReceiver.run(): "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|running
condition|)
block|{
try|try
block|{
name|datanode
operator|.
name|checkDiskError
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// may throw an exception here
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DataNode.checkDiskError failed in run() with: "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|myString
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// failure not caused by interruption
name|receiverThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|myString
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
name|receiverThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|myString
operator|+
literal|" terminating"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove a packet from the head of the ack queue      *       * This should be called only when the ack queue is not empty      */
DECL|method|removeAckHead ()
specifier|private
specifier|synchronized
name|void
name|removeAckHead
parameter_list|()
block|{
name|ackQueue
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This information is cached by the Datanode in the ackQueue.    */
DECL|class|Packet
specifier|private
specifier|static
class|class
name|Packet
block|{
DECL|field|seqno
specifier|final
name|long
name|seqno
decl_stmt|;
DECL|field|lastPacketInBlock
specifier|final
name|boolean
name|lastPacketInBlock
decl_stmt|;
DECL|field|offsetInBlock
specifier|final
name|long
name|offsetInBlock
decl_stmt|;
DECL|field|ackEnqueueNanoTime
specifier|final
name|long
name|ackEnqueueNanoTime
decl_stmt|;
DECL|method|Packet (long seqno, boolean lastPacketInBlock, long offsetInBlock, long ackEnqueueNanoTime)
name|Packet
parameter_list|(
name|long
name|seqno
parameter_list|,
name|boolean
name|lastPacketInBlock
parameter_list|,
name|long
name|offsetInBlock
parameter_list|,
name|long
name|ackEnqueueNanoTime
parameter_list|)
block|{
name|this
operator|.
name|seqno
operator|=
name|seqno
expr_stmt|;
name|this
operator|.
name|lastPacketInBlock
operator|=
name|lastPacketInBlock
expr_stmt|;
name|this
operator|.
name|offsetInBlock
operator|=
name|offsetInBlock
expr_stmt|;
name|this
operator|.
name|ackEnqueueNanoTime
operator|=
name|ackEnqueueNanoTime
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(seqno="
operator|+
name|seqno
operator|+
literal|", lastPacketInBlock="
operator|+
name|lastPacketInBlock
operator|+
literal|", offsetInBlock="
operator|+
name|offsetInBlock
operator|+
literal|", ackEnqueueNanoTime="
operator|+
name|ackEnqueueNanoTime
operator|+
literal|")"
return|;
block|}
block|}
block|}
end_class

end_unit

