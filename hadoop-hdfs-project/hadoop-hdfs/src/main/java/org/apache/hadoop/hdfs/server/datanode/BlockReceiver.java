begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
operator|.
name|DN_CLIENTTRACE_FORMAT
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Checksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ChecksumException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSOutputSummer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|BlockConstructionStage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PacketHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PacketReceiver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PipelineAck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaInputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaOutputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|DataTransferThrottler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/** A class that receives a block and writes to its own disk, meanwhile  * may copies it to another site. If a throttler is provided,  * streaming throttling is also supported.  **/
end_comment

begin_class
DECL|class|BlockReceiver
class|class
name|BlockReceiver
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|ClientTraceLog
specifier|static
specifier|final
name|Log
name|ClientTraceLog
init|=
name|DataNode
operator|.
name|ClientTraceLog
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|CACHE_DROP_LAG_BYTES
specifier|static
name|long
name|CACHE_DROP_LAG_BYTES
init|=
literal|8
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
DECL|field|in
specifier|private
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
comment|// from where data are read
DECL|field|clientChecksum
specifier|private
name|DataChecksum
name|clientChecksum
decl_stmt|;
comment|// checksum used by client
DECL|field|diskChecksum
specifier|private
name|DataChecksum
name|diskChecksum
decl_stmt|;
comment|// checksum we write to disk
comment|/**    * In the case that the client is writing with a different    * checksum polynomial than the block is stored with on disk,    * the DataNode needs to recalculate checksums before writing.    */
DECL|field|needsChecksumTranslation
specifier|private
name|boolean
name|needsChecksumTranslation
decl_stmt|;
DECL|field|out
specifier|private
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
comment|// to block file at local disk
DECL|field|outFd
specifier|private
name|FileDescriptor
name|outFd
decl_stmt|;
DECL|field|cout
specifier|private
name|OutputStream
name|cout
init|=
literal|null
decl_stmt|;
comment|// output stream for cehcksum file
DECL|field|checksumOut
specifier|private
name|DataOutputStream
name|checksumOut
init|=
literal|null
decl_stmt|;
comment|// to crc file at local disk
DECL|field|bytesPerChecksum
specifier|private
name|int
name|bytesPerChecksum
decl_stmt|;
DECL|field|checksumSize
specifier|private
name|int
name|checksumSize
decl_stmt|;
DECL|field|packetReceiver
specifier|private
name|PacketReceiver
name|packetReceiver
init|=
operator|new
name|PacketReceiver
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|inAddr
specifier|protected
specifier|final
name|String
name|inAddr
decl_stmt|;
DECL|field|myAddr
specifier|protected
specifier|final
name|String
name|myAddr
decl_stmt|;
DECL|field|mirrorAddr
specifier|private
name|String
name|mirrorAddr
decl_stmt|;
DECL|field|mirrorOut
specifier|private
name|DataOutputStream
name|mirrorOut
decl_stmt|;
DECL|field|responder
specifier|private
name|Daemon
name|responder
init|=
literal|null
decl_stmt|;
DECL|field|throttler
specifier|private
name|DataTransferThrottler
name|throttler
decl_stmt|;
DECL|field|streams
specifier|private
name|ReplicaOutputStreams
name|streams
decl_stmt|;
DECL|field|srcDataNode
specifier|private
name|DatanodeInfo
name|srcDataNode
init|=
literal|null
decl_stmt|;
DECL|field|partialCrc
specifier|private
name|Checksum
name|partialCrc
init|=
literal|null
decl_stmt|;
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|mirrorError
specifier|volatile
specifier|private
name|boolean
name|mirrorError
decl_stmt|;
comment|// Cache management state
DECL|field|dropCacheBehindWrites
specifier|private
name|boolean
name|dropCacheBehindWrites
decl_stmt|;
DECL|field|lastCacheManagementOffset
specifier|private
name|long
name|lastCacheManagementOffset
init|=
literal|0
decl_stmt|;
DECL|field|syncBehindWrites
specifier|private
name|boolean
name|syncBehindWrites
decl_stmt|;
comment|/** The client name.  It is empty if a datanode is the client */
DECL|field|clientname
specifier|private
specifier|final
name|String
name|clientname
decl_stmt|;
DECL|field|isClient
specifier|private
specifier|final
name|boolean
name|isClient
decl_stmt|;
DECL|field|isDatanode
specifier|private
specifier|final
name|boolean
name|isDatanode
decl_stmt|;
comment|/** the block to receive */
DECL|field|block
specifier|private
specifier|final
name|ExtendedBlock
name|block
decl_stmt|;
comment|/** the replica to write */
DECL|field|replicaInfo
specifier|private
specifier|final
name|ReplicaInPipelineInterface
name|replicaInfo
decl_stmt|;
comment|/** pipeline stage */
DECL|field|stage
specifier|private
specifier|final
name|BlockConstructionStage
name|stage
decl_stmt|;
DECL|field|isTransfer
specifier|private
specifier|final
name|boolean
name|isTransfer
decl_stmt|;
DECL|field|syncOnClose
specifier|private
name|boolean
name|syncOnClose
decl_stmt|;
DECL|method|BlockReceiver (final ExtendedBlock block, final DataInputStream in, final String inAddr, final String myAddr, final BlockConstructionStage stage, final long newGs, final long minBytesRcvd, final long maxBytesRcvd, final String clientname, final DatanodeInfo srcDataNode, final DataNode datanode, DataChecksum requestedChecksum, CachingStrategy cachingStrategy)
name|BlockReceiver
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|,
specifier|final
name|DataInputStream
name|in
parameter_list|,
specifier|final
name|String
name|inAddr
parameter_list|,
specifier|final
name|String
name|myAddr
parameter_list|,
specifier|final
name|BlockConstructionStage
name|stage
parameter_list|,
specifier|final
name|long
name|newGs
parameter_list|,
specifier|final
name|long
name|minBytesRcvd
parameter_list|,
specifier|final
name|long
name|maxBytesRcvd
parameter_list|,
specifier|final
name|String
name|clientname
parameter_list|,
specifier|final
name|DatanodeInfo
name|srcDataNode
parameter_list|,
specifier|final
name|DataNode
name|datanode
parameter_list|,
name|DataChecksum
name|requestedChecksum
parameter_list|,
name|CachingStrategy
name|cachingStrategy
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|inAddr
operator|=
name|inAddr
expr_stmt|;
name|this
operator|.
name|myAddr
operator|=
name|myAddr
expr_stmt|;
name|this
operator|.
name|srcDataNode
operator|=
name|srcDataNode
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|clientname
operator|=
name|clientname
expr_stmt|;
name|this
operator|.
name|isDatanode
operator|=
name|clientname
operator|.
name|length
argument_list|()
operator|==
literal|0
expr_stmt|;
name|this
operator|.
name|isClient
operator|=
operator|!
name|this
operator|.
name|isDatanode
expr_stmt|;
comment|//for datanode, we have
comment|//1: clientName.length() == 0, and
comment|//2: stage == null or PIPELINE_SETUP_CREATE
name|this
operator|.
name|stage
operator|=
name|stage
expr_stmt|;
name|this
operator|.
name|isTransfer
operator|=
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_RBW
operator|||
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_FINALIZED
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
operator|+
name|block
operator|+
literal|"\n  isClient  ="
operator|+
name|isClient
operator|+
literal|", clientname="
operator|+
name|clientname
operator|+
literal|"\n  isDatanode="
operator|+
name|isDatanode
operator|+
literal|", srcDataNode="
operator|+
name|srcDataNode
operator|+
literal|"\n  inAddr="
operator|+
name|inAddr
operator|+
literal|", myAddr="
operator|+
name|myAddr
operator|+
literal|"\n  cachingStrategy = "
operator|+
name|cachingStrategy
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Open local disk out
comment|//
if|if
condition|(
name|isDatanode
condition|)
block|{
comment|//replication or move
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|createTemporary
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|stage
condition|)
block|{
case|case
name|PIPELINE_SETUP_CREATE
case|:
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|createRbw
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIPELINE_SETUP_STREAMING_RECOVERY
case|:
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|recoverRbw
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|,
name|maxBytesRcvd
argument_list|)
expr_stmt|;
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIPELINE_SETUP_APPEND
case|:
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|append
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanode
operator|.
name|blockScanner
operator|!=
literal|null
condition|)
block|{
comment|// remove from block scanner
name|datanode
operator|.
name|blockScanner
operator|.
name|deleteBlock
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIPELINE_SETUP_APPEND_RECOVERY
case|:
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|recoverAppend
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanode
operator|.
name|blockScanner
operator|!=
literal|null
condition|)
block|{
comment|// remove from block scanner
name|datanode
operator|.
name|blockScanner
operator|.
name|deleteBlock
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRANSFER_RBW
case|:
case|case
name|TRANSFER_FINALIZED
case|:
comment|// this is a transfer destination
name|replicaInfo
operator|=
name|datanode
operator|.
name|data
operator|.
name|createTemporary
argument_list|(
name|block
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unsupported stage "
operator|+
name|stage
operator|+
literal|" while receiving block "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|dropCacheBehindWrites
operator|=
operator|(
name|cachingStrategy
operator|.
name|getDropBehind
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|dropCacheBehindWrites
else|:
name|cachingStrategy
operator|.
name|getDropBehind
argument_list|()
expr_stmt|;
name|this
operator|.
name|syncBehindWrites
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|syncBehindWrites
expr_stmt|;
specifier|final
name|boolean
name|isCreate
init|=
name|isDatanode
operator|||
name|isTransfer
operator|||
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|PIPELINE_SETUP_CREATE
decl_stmt|;
name|streams
operator|=
name|replicaInfo
operator|.
name|createStreams
argument_list|(
name|isCreate
argument_list|,
name|requestedChecksum
argument_list|)
expr_stmt|;
assert|assert
name|streams
operator|!=
literal|null
operator|:
literal|"null streams!"
assert|;
comment|// read checksum meta information
name|this
operator|.
name|clientChecksum
operator|=
name|requestedChecksum
expr_stmt|;
name|this
operator|.
name|diskChecksum
operator|=
name|streams
operator|.
name|getChecksum
argument_list|()
expr_stmt|;
name|this
operator|.
name|needsChecksumTranslation
operator|=
operator|!
name|clientChecksum
operator|.
name|equals
argument_list|(
name|diskChecksum
argument_list|)
expr_stmt|;
name|this
operator|.
name|bytesPerChecksum
operator|=
name|diskChecksum
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
name|this
operator|.
name|checksumSize
operator|=
name|diskChecksum
operator|.
name|getChecksumSize
argument_list|()
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|streams
operator|.
name|getDataOut
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|instanceof
name|FileOutputStream
condition|)
block|{
name|this
operator|.
name|outFd
operator|=
operator|(
operator|(
name|FileOutputStream
operator|)
name|out
operator|)
operator|.
name|getFD
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not get file descriptor for outputstream of class "
operator|+
name|out
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|cout
operator|=
name|streams
operator|.
name|getChecksumOut
argument_list|()
expr_stmt|;
name|this
operator|.
name|checksumOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|cout
argument_list|,
name|HdfsConstants
operator|.
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|// write data chunk header if creating a new replica
if|if
condition|(
name|isCreate
condition|)
block|{
name|BlockMetadataHeader
operator|.
name|writeHeader
argument_list|(
name|checksumOut
argument_list|,
name|diskChecksum
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReplicaAlreadyExistsException
name|bae
parameter_list|)
block|{
throw|throw
name|bae
throw|;
block|}
catch|catch
parameter_list|(
name|ReplicaNotFoundException
name|bne
parameter_list|)
block|{
throw|throw
name|bne
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|cleanupBlock
argument_list|()
expr_stmt|;
comment|// check if there is a disk error
name|IOException
name|cause
init|=
name|DatanodeUtil
operator|.
name|getCauseIfDiskError
argument_list|(
name|ioe
argument_list|)
decl_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in BlockReceiver constructor. Cause is "
argument_list|,
name|cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
comment|// possible disk error
name|ioe
operator|=
name|cause
expr_stmt|;
name|datanode
operator|.
name|checkDiskError
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
comment|// may throw an exception here
block|}
throw|throw
name|ioe
throw|;
block|}
block|}
comment|/** Return the datanode object. */
DECL|method|getDataNode ()
name|DataNode
name|getDataNode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
comment|/**    * close files.    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|packetReceiver
operator|!=
literal|null
condition|)
block|{
name|packetReceiver
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|IOException
name|ioe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|syncOnClose
operator|&&
operator|(
name|out
operator|!=
literal|null
operator|||
name|checksumOut
operator|!=
literal|null
operator|)
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|incrFsyncCount
argument_list|()
expr_stmt|;
block|}
name|long
name|flushTotalNanos
init|=
literal|0
decl_stmt|;
name|boolean
name|measuredFlushTime
init|=
literal|false
decl_stmt|;
comment|// close checksum file
try|try
block|{
if|if
condition|(
name|checksumOut
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|checksumOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|syncOnClose
operator|&&
operator|(
name|cout
operator|instanceof
name|FileOutputStream
operator|)
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
operator|(
operator|(
name|FileOutputStream
operator|)
name|cout
operator|)
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
name|measuredFlushTime
operator|=
literal|true
expr_stmt|;
name|checksumOut
operator|.
name|close
argument_list|()
expr_stmt|;
name|checksumOut
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ioe
operator|=
name|e
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|checksumOut
argument_list|)
expr_stmt|;
block|}
comment|// close block file
try|try
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|syncOnClose
operator|&&
operator|(
name|out
operator|instanceof
name|FileOutputStream
operator|)
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
operator|(
operator|(
name|FileOutputStream
operator|)
name|out
operator|)
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
name|measuredFlushTime
operator|=
literal|true
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ioe
operator|=
name|e
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|measuredFlushTime
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|addFlushNanos
argument_list|(
name|flushTotalNanos
argument_list|)
expr_stmt|;
block|}
comment|// disk check
if|if
condition|(
name|ioe
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|checkDiskError
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
comment|/**    * Flush block data and metadata files to disk.    * @throws IOException    */
DECL|method|flushOrSync (boolean isSync)
name|void
name|flushOrSync
parameter_list|(
name|boolean
name|isSync
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|flushTotalNanos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|checksumOut
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|checksumOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSync
operator|&&
operator|(
name|cout
operator|instanceof
name|FileOutputStream
operator|)
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
operator|(
operator|(
name|FileOutputStream
operator|)
name|cout
operator|)
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSync
operator|&&
operator|(
name|out
operator|instanceof
name|FileOutputStream
operator|)
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
operator|(
operator|(
name|FileOutputStream
operator|)
name|out
operator|)
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
block|}
if|if
condition|(
name|checksumOut
operator|!=
literal|null
operator|||
name|out
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|addFlushNanos
argument_list|(
name|flushTotalNanos
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSync
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|incrFsyncCount
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * While writing to mirrorOut, failure to write to mirror should not    * affect this datanode unless it is caused by interruption.    */
DECL|method|handleMirrorOutError (IOException ioe)
specifier|private
name|void
name|handleMirrorOutError
parameter_list|(
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|bpid
init|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|datanode
operator|.
name|getDNRegistrationForBP
argument_list|(
name|bpid
argument_list|)
operator|+
literal|":Exception writing "
operator|+
name|block
operator|+
literal|" to mirror "
operator|+
name|mirrorAddr
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// shut down if the thread is interrupted
throw|throw
name|ioe
throw|;
block|}
else|else
block|{
comment|// encounter an error while writing to mirror
comment|// continue to run even if can not write to mirror
comment|// notify client of the error
comment|// and wait for the client to shut down the pipeline
name|mirrorError
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**    * Verify multiple CRC chunks.     */
DECL|method|verifyChunks (ByteBuffer dataBuf, ByteBuffer checksumBuf)
specifier|private
name|void
name|verifyChunks
parameter_list|(
name|ByteBuffer
name|dataBuf
parameter_list|,
name|ByteBuffer
name|checksumBuf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|clientChecksum
operator|.
name|verifyChunkedSums
argument_list|(
name|dataBuf
argument_list|,
name|checksumBuf
argument_list|,
name|clientname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|ce
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Checksum error in block "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|,
name|ce
argument_list|)
expr_stmt|;
comment|// No need to report to namenode when client is writing.
if|if
condition|(
name|srcDataNode
operator|!=
literal|null
operator|&&
name|isDatanode
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"report corrupt "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|srcDataNode
operator|+
literal|" to namenode"
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|reportRemoteBadBlock
argument_list|(
name|srcDataNode
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to report bad "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|srcDataNode
operator|+
literal|" to namenode"
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected checksum mismatch while writing "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|)
throw|;
block|}
block|}
comment|/**    * Translate CRC chunks from the client's checksum implementation    * to the disk checksum implementation.    *     * This does not verify the original checksums, under the assumption    * that they have already been validated.    */
DECL|method|translateChunks (ByteBuffer dataBuf, ByteBuffer checksumBuf)
specifier|private
name|void
name|translateChunks
parameter_list|(
name|ByteBuffer
name|dataBuf
parameter_list|,
name|ByteBuffer
name|checksumBuf
parameter_list|)
block|{
name|diskChecksum
operator|.
name|calculateChunkedSums
argument_list|(
name|dataBuf
argument_list|,
name|checksumBuf
argument_list|)
expr_stmt|;
block|}
comment|/**     * Check whether checksum needs to be verified.    * Skip verifying checksum iff this is not the last one in the     * pipeline and clientName is non-null. i.e. Checksum is verified    * on all the datanodes when the data is being written by a     * datanode rather than a client. Whe client is writing the data,     * protocol includes acks and only the last datanode needs to verify     * checksum.    * @return true if checksum verification is needed, otherwise false.    */
DECL|method|shouldVerifyChecksum ()
specifier|private
name|boolean
name|shouldVerifyChecksum
parameter_list|()
block|{
return|return
operator|(
name|mirrorOut
operator|==
literal|null
operator|||
name|isDatanode
operator|||
name|needsChecksumTranslation
operator|)
return|;
block|}
comment|/**     * Receives and processes a packet. It can contain many chunks.    * returns the number of data bytes that the packet has.    */
DECL|method|receivePacket ()
specifier|private
name|int
name|receivePacket
parameter_list|()
throws|throws
name|IOException
block|{
comment|// read the next packet
name|packetReceiver
operator|.
name|receiveNextPacket
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|PacketHeader
name|header
init|=
name|packetReceiver
operator|.
name|getHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Receiving one packet for block "
operator|+
name|block
operator|+
literal|": "
operator|+
name|header
argument_list|)
expr_stmt|;
block|}
comment|// Sanity check the header
if|if
condition|(
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|>
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Received an out-of-sequence packet for "
operator|+
name|block
operator|+
literal|"from "
operator|+
name|inAddr
operator|+
literal|" at offset "
operator|+
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
literal|". Expecting packet starting at "
operator|+
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|header
operator|.
name|getDataLen
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got wrong length during writeBlock("
operator|+
name|block
operator|+
literal|") from "
operator|+
name|inAddr
operator|+
literal|" at offset "
operator|+
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
literal|": "
operator|+
name|header
operator|.
name|getDataLen
argument_list|()
argument_list|)
throw|;
block|}
name|long
name|offsetInBlock
init|=
name|header
operator|.
name|getOffsetInBlock
argument_list|()
decl_stmt|;
name|long
name|seqno
init|=
name|header
operator|.
name|getSeqno
argument_list|()
decl_stmt|;
name|boolean
name|lastPacketInBlock
init|=
name|header
operator|.
name|isLastPacketInBlock
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|header
operator|.
name|getDataLen
argument_list|()
decl_stmt|;
name|boolean
name|syncBlock
init|=
name|header
operator|.
name|getSyncBlock
argument_list|()
decl_stmt|;
comment|// avoid double sync'ing on close
if|if
condition|(
name|syncBlock
operator|&&
name|lastPacketInBlock
condition|)
block|{
name|this
operator|.
name|syncOnClose
operator|=
literal|false
expr_stmt|;
block|}
comment|// update received bytes
name|long
name|firstByteInBlock
init|=
name|offsetInBlock
decl_stmt|;
name|offsetInBlock
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|<
name|offsetInBlock
condition|)
block|{
name|replicaInfo
operator|.
name|setNumBytes
argument_list|(
name|offsetInBlock
argument_list|)
expr_stmt|;
block|}
comment|// put in queue for pending acks, unless sync was requested
if|if
condition|(
name|responder
operator|!=
literal|null
operator|&&
operator|!
name|syncBlock
operator|&&
operator|!
name|shouldVerifyChecksum
argument_list|()
condition|)
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|enqueue
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|,
name|Status
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
block|}
comment|//First write the packet to the mirror:
if|if
condition|(
name|mirrorOut
operator|!=
literal|null
operator|&&
operator|!
name|mirrorError
condition|)
block|{
try|try
block|{
name|packetReceiver
operator|.
name|mirrorPacketTo
argument_list|(
name|mirrorOut
argument_list|)
expr_stmt|;
name|mirrorOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|handleMirrorOutError
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|ByteBuffer
name|dataBuf
init|=
name|packetReceiver
operator|.
name|getDataSlice
argument_list|()
decl_stmt|;
name|ByteBuffer
name|checksumBuf
init|=
name|packetReceiver
operator|.
name|getChecksumSlice
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastPacketInBlock
operator|||
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Receiving an empty packet or the end of the block "
operator|+
name|block
argument_list|)
expr_stmt|;
block|}
comment|// sync block if requested
if|if
condition|(
name|syncBlock
condition|)
block|{
name|flushOrSync
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|checksumLen
init|=
operator|(
operator|(
name|len
operator|+
name|bytesPerChecksum
operator|-
literal|1
operator|)
operator|/
name|bytesPerChecksum
operator|)
operator|*
name|checksumSize
decl_stmt|;
if|if
condition|(
name|checksumBuf
operator|.
name|capacity
argument_list|()
operator|!=
name|checksumLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Length of checksums in packet "
operator|+
name|checksumBuf
operator|.
name|capacity
argument_list|()
operator|+
literal|" does not match calculated checksum "
operator|+
literal|"length "
operator|+
name|checksumLen
argument_list|)
throw|;
block|}
if|if
condition|(
name|shouldVerifyChecksum
argument_list|()
condition|)
block|{
try|try
block|{
name|verifyChunks
argument_list|(
name|dataBuf
argument_list|,
name|checksumBuf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// checksum error detected locally. there is no reason to continue.
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
try|try
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|enqueue
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|,
name|Status
operator|.
name|ERROR_CHECKSUM
argument_list|)
expr_stmt|;
comment|// Wait until the responder sends back the response
comment|// and interrupt this thread.
name|Thread
operator|.
name|sleep
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{ }
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Terminating due to a checksum error."
operator|+
name|ioe
argument_list|)
throw|;
block|}
if|if
condition|(
name|needsChecksumTranslation
condition|)
block|{
comment|// overwrite the checksums in the packet buffer with the
comment|// appropriate polynomial for the disk storage.
name|translateChunks
argument_list|(
name|dataBuf
argument_list|,
name|checksumBuf
argument_list|)
expr_stmt|;
block|}
block|}
comment|// by this point, the data in the buffer uses the disk checksum
name|byte
index|[]
name|lastChunkChecksum
decl_stmt|;
try|try
block|{
name|long
name|onDiskLen
init|=
name|replicaInfo
operator|.
name|getBytesOnDisk
argument_list|()
decl_stmt|;
if|if
condition|(
name|onDiskLen
operator|<
name|offsetInBlock
condition|)
block|{
comment|//finally write to the disk :
if|if
condition|(
name|onDiskLen
operator|%
name|bytesPerChecksum
operator|!=
literal|0
condition|)
block|{
comment|// prepare to overwrite last checksum
name|adjustCrcFilePosition
argument_list|()
expr_stmt|;
block|}
comment|// If this is a partial chunk, then read in pre-existing checksum
if|if
condition|(
name|firstByteInBlock
operator|%
name|bytesPerChecksum
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Packet starts at "
operator|+
name|firstByteInBlock
operator|+
literal|" for "
operator|+
name|block
operator|+
literal|" which is not a multiple of bytesPerChecksum "
operator|+
name|bytesPerChecksum
argument_list|)
expr_stmt|;
name|long
name|offsetInChecksum
init|=
name|BlockMetadataHeader
operator|.
name|getHeaderSize
argument_list|()
operator|+
name|onDiskLen
operator|/
name|bytesPerChecksum
operator|*
name|checksumSize
decl_stmt|;
name|computePartialChunkCrc
argument_list|(
name|onDiskLen
argument_list|,
name|offsetInChecksum
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
block|}
name|int
name|startByteToDisk
init|=
call|(
name|int
call|)
argument_list|(
name|onDiskLen
operator|-
name|firstByteInBlock
argument_list|)
operator|+
name|dataBuf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|dataBuf
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|numBytesToDisk
init|=
call|(
name|int
call|)
argument_list|(
name|offsetInBlock
operator|-
name|onDiskLen
argument_list|)
decl_stmt|;
comment|// Write data to disk.
name|out
operator|.
name|write
argument_list|(
name|dataBuf
operator|.
name|array
argument_list|()
argument_list|,
name|startByteToDisk
argument_list|,
name|numBytesToDisk
argument_list|)
expr_stmt|;
comment|// If this is a partial chunk, then verify that this is the only
comment|// chunk in the packet. Calculate new crc for this chunk.
if|if
condition|(
name|partialCrc
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|bytesPerChecksum
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got wrong length during writeBlock("
operator|+
name|block
operator|+
literal|") from "
operator|+
name|inAddr
operator|+
literal|" "
operator|+
literal|"A packet can have only one partial chunk."
operator|+
literal|" len = "
operator|+
name|len
operator|+
literal|" bytesPerChecksum "
operator|+
name|bytesPerChecksum
argument_list|)
throw|;
block|}
name|partialCrc
operator|.
name|update
argument_list|(
name|dataBuf
operator|.
name|array
argument_list|()
argument_list|,
name|startByteToDisk
argument_list|,
name|numBytesToDisk
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
name|FSOutputSummer
operator|.
name|convertToByteStream
argument_list|(
name|partialCrc
argument_list|,
name|checksumSize
argument_list|)
decl_stmt|;
name|lastChunkChecksum
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buf
argument_list|,
name|buf
operator|.
name|length
operator|-
name|checksumSize
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|checksumOut
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Writing out partial crc for data len "
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
name|partialCrc
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|lastChunkChecksum
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|checksumBuf
operator|.
name|array
argument_list|()
argument_list|,
name|checksumBuf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|checksumBuf
operator|.
name|position
argument_list|()
operator|+
name|checksumLen
operator|-
name|checksumSize
argument_list|,
name|checksumBuf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|checksumBuf
operator|.
name|position
argument_list|()
operator|+
name|checksumLen
argument_list|)
expr_stmt|;
name|checksumOut
operator|.
name|write
argument_list|(
name|checksumBuf
operator|.
name|array
argument_list|()
argument_list|,
name|checksumBuf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|checksumBuf
operator|.
name|position
argument_list|()
argument_list|,
name|checksumLen
argument_list|)
expr_stmt|;
block|}
comment|/// flush entire packet, sync if requested
name|flushOrSync
argument_list|(
name|syncBlock
argument_list|)
expr_stmt|;
name|replicaInfo
operator|.
name|setLastChecksumAndDataLen
argument_list|(
name|offsetInBlock
argument_list|,
name|lastChunkChecksum
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|incrBytesWritten
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|manageWriterOsCache
argument_list|(
name|offsetInBlock
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{
name|datanode
operator|.
name|checkDiskError
argument_list|(
name|iex
argument_list|)
expr_stmt|;
throw|throw
name|iex
throw|;
block|}
block|}
comment|// if sync was requested, put in queue for pending acks here
comment|// (after the fsync finished)
if|if
condition|(
name|responder
operator|!=
literal|null
operator|&&
operator|(
name|syncBlock
operator|||
name|shouldVerifyChecksum
argument_list|()
operator|)
condition|)
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|enqueue
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|,
name|Status
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|throttler
operator|!=
literal|null
condition|)
block|{
comment|// throttle I/O
name|throttler
operator|.
name|throttle
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|lastPacketInBlock
condition|?
operator|-
literal|1
else|:
name|len
return|;
block|}
DECL|method|manageWriterOsCache (long offsetInBlock)
specifier|private
name|void
name|manageWriterOsCache
parameter_list|(
name|long
name|offsetInBlock
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|outFd
operator|!=
literal|null
operator|&&
name|offsetInBlock
operator|>
name|lastCacheManagementOffset
operator|+
name|CACHE_DROP_LAG_BYTES
condition|)
block|{
comment|//
comment|// For SYNC_FILE_RANGE_WRITE, we want to sync from
comment|// lastCacheManagementOffset to a position "two windows ago"
comment|//
comment|//<========= sync ===========>
comment|// +-----------------------O--------------------------X
comment|// start                  last                      curPos
comment|// of file
comment|//
if|if
condition|(
name|syncBehindWrites
condition|)
block|{
name|NativeIO
operator|.
name|POSIX
operator|.
name|syncFileRangeIfPossible
argument_list|(
name|outFd
argument_list|,
name|lastCacheManagementOffset
argument_list|,
name|offsetInBlock
operator|-
name|lastCacheManagementOffset
argument_list|,
name|NativeIO
operator|.
name|POSIX
operator|.
name|SYNC_FILE_RANGE_WRITE
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// For POSIX_FADV_DONTNEED, we want to drop from the beginning
comment|// of the file to a position prior to the current position.
comment|//
comment|//<=== drop =====>
comment|//<---W--->
comment|// +--------------+--------O--------------------------X
comment|// start        dropPos   last                      curPos
comment|// of file
comment|//
name|long
name|dropPos
init|=
name|lastCacheManagementOffset
operator|-
name|CACHE_DROP_LAG_BYTES
decl_stmt|;
if|if
condition|(
name|dropPos
operator|>
literal|0
operator|&&
name|dropCacheBehindWrites
condition|)
block|{
name|NativeIO
operator|.
name|POSIX
operator|.
name|posixFadviseIfPossible
argument_list|(
name|block
operator|.
name|getBlockName
argument_list|()
argument_list|,
name|outFd
argument_list|,
literal|0
argument_list|,
name|dropPos
argument_list|,
name|NativeIO
operator|.
name|POSIX
operator|.
name|POSIX_FADV_DONTNEED
argument_list|)
expr_stmt|;
block|}
name|lastCacheManagementOffset
operator|=
name|offsetInBlock
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error managing cache for writer of block "
operator|+
name|block
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|receiveBlock ( DataOutputStream mirrOut, DataInputStream mirrIn, DataOutputStream replyOut, String mirrAddr, DataTransferThrottler throttlerArg, DatanodeInfo[] downstreams)
name|void
name|receiveBlock
parameter_list|(
name|DataOutputStream
name|mirrOut
parameter_list|,
comment|// output to next datanode
name|DataInputStream
name|mirrIn
parameter_list|,
comment|// input from next datanode
name|DataOutputStream
name|replyOut
parameter_list|,
comment|// output to previous datanode
name|String
name|mirrAddr
parameter_list|,
name|DataTransferThrottler
name|throttlerArg
parameter_list|,
name|DatanodeInfo
index|[]
name|downstreams
parameter_list|)
throws|throws
name|IOException
block|{
name|syncOnClose
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|syncOnClose
expr_stmt|;
name|boolean
name|responderClosed
init|=
literal|false
decl_stmt|;
name|mirrorOut
operator|=
name|mirrOut
expr_stmt|;
name|mirrorAddr
operator|=
name|mirrAddr
expr_stmt|;
name|throttler
operator|=
name|throttlerArg
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isClient
operator|&&
operator|!
name|isTransfer
condition|)
block|{
name|responder
operator|=
operator|new
name|Daemon
argument_list|(
name|datanode
operator|.
name|threadGroup
argument_list|,
operator|new
name|PacketResponder
argument_list|(
name|replyOut
argument_list|,
name|mirrIn
argument_list|,
name|downstreams
argument_list|)
argument_list|)
expr_stmt|;
name|responder
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// start thread to processes responses
block|}
while|while
condition|(
name|receivePacket
argument_list|()
operator|>=
literal|0
condition|)
block|{
comment|/* Receive until the last packet */
block|}
comment|// wait for all outstanding packet responses. And then
comment|// indicate responder to gracefully shutdown.
comment|// Mark that responder has been closed for future processing
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|responderClosed
operator|=
literal|true
expr_stmt|;
block|}
comment|// If this write is for a replication or transfer-RBW/Finalized,
comment|// then finalize block or convert temporary to RBW.
comment|// For client-writes, the block is finalized in the PacketResponder.
if|if
condition|(
name|isDatanode
operator|||
name|isTransfer
condition|)
block|{
comment|// close the block/crc files
name|close
argument_list|()
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_RBW
condition|)
block|{
comment|// for TRANSFER_RBW, convert temporary to RBW
name|datanode
operator|.
name|data
operator|.
name|convertTemporaryToRbw
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for isDatnode or TRANSFER_FINALIZED
comment|// Finalize the block.
name|datanode
operator|.
name|data
operator|.
name|finalizeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
name|datanode
operator|.
name|metrics
operator|.
name|incrBlocksWritten
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception for "
operator|+
name|block
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|responderClosed
condition|)
block|{
comment|// Abnormal termination of the flow above
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|cleanupBlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|responder
operator|.
name|join
argument_list|(
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|responder
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"Join on responder thread "
operator|+
name|responder
operator|+
literal|" timed out"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
operator|+
literal|"\n"
operator|+
name|StringUtils
operator|.
name|getStackTrace
argument_list|(
name|responder
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted receiveBlock"
argument_list|)
throw|;
block|}
name|responder
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/** Cleanup a partial block     * if this write is for a replication request (and not from a client)    */
DECL|method|cleanupBlock ()
specifier|private
name|void
name|cleanupBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isDatanode
condition|)
block|{
name|datanode
operator|.
name|data
operator|.
name|unfinalizeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adjust the file pointer in the local meta file so that the last checksum    * will be overwritten.    */
DECL|method|adjustCrcFilePosition ()
specifier|private
name|void
name|adjustCrcFilePosition
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|checksumOut
operator|!=
literal|null
condition|)
block|{
name|checksumOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|// rollback the position of the meta file
name|datanode
operator|.
name|data
operator|.
name|adjustCrcChannelPosition
argument_list|(
name|block
argument_list|,
name|streams
argument_list|,
name|checksumSize
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convert a checksum byte array to a long    */
DECL|method|checksum2long (byte[] checksum)
specifier|static
specifier|private
name|long
name|checksum2long
parameter_list|(
name|byte
index|[]
name|checksum
parameter_list|)
block|{
name|long
name|crc
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|checksum
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator||=
operator|(
literal|0xffL
operator|&
name|checksum
index|[
name|i
index|]
operator|)
operator|<<
operator|(
operator|(
name|checksum
operator|.
name|length
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
block|}
return|return
name|crc
return|;
block|}
comment|/**    * reads in the partial crc chunk and computes checksum    * of pre-existing data in partial chunk.    */
DECL|method|computePartialChunkCrc (long blkoff, long ckoff, int bytesPerChecksum)
specifier|private
name|void
name|computePartialChunkCrc
parameter_list|(
name|long
name|blkoff
parameter_list|,
name|long
name|ckoff
parameter_list|,
name|int
name|bytesPerChecksum
parameter_list|)
throws|throws
name|IOException
block|{
comment|// find offset of the beginning of partial chunk.
comment|//
name|int
name|sizePartialChunk
init|=
call|(
name|int
call|)
argument_list|(
name|blkoff
operator|%
name|bytesPerChecksum
argument_list|)
decl_stmt|;
name|int
name|checksumSize
init|=
name|diskChecksum
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
name|blkoff
operator|=
name|blkoff
operator|-
name|sizePartialChunk
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"computePartialChunkCrc sizePartialChunk "
operator|+
name|sizePartialChunk
operator|+
literal|" "
operator|+
name|block
operator|+
literal|" block offset "
operator|+
name|blkoff
operator|+
literal|" metafile offset "
operator|+
name|ckoff
argument_list|)
expr_stmt|;
comment|// create an input stream from the block file
comment|// and read in partial crc chunk into temporary buffer
comment|//
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|sizePartialChunk
index|]
decl_stmt|;
name|byte
index|[]
name|crcbuf
init|=
operator|new
name|byte
index|[
name|checksumSize
index|]
decl_stmt|;
name|ReplicaInputStreams
name|instr
init|=
literal|null
decl_stmt|;
try|try
block|{
name|instr
operator|=
name|datanode
operator|.
name|data
operator|.
name|getTmpInputStreams
argument_list|(
name|block
argument_list|,
name|blkoff
argument_list|,
name|ckoff
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|instr
operator|.
name|getDataIn
argument_list|()
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|sizePartialChunk
argument_list|)
expr_stmt|;
comment|// open meta file and read in crc value computer earlier
name|IOUtils
operator|.
name|readFully
argument_list|(
name|instr
operator|.
name|getChecksumIn
argument_list|()
argument_list|,
name|crcbuf
argument_list|,
literal|0
argument_list|,
name|crcbuf
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|instr
argument_list|)
expr_stmt|;
block|}
comment|// compute crc of partial chunk from data read in the block file.
name|partialCrc
operator|=
name|DataChecksum
operator|.
name|newDataChecksum
argument_list|(
name|diskChecksum
operator|.
name|getChecksumType
argument_list|()
argument_list|,
name|diskChecksum
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
expr_stmt|;
name|partialCrc
operator|.
name|update
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|sizePartialChunk
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Read in partial CRC chunk from disk for "
operator|+
name|block
argument_list|)
expr_stmt|;
comment|// paranoia! verify that the pre-computed crc matches what we
comment|// recalculated just now
if|if
condition|(
name|partialCrc
operator|.
name|getValue
argument_list|()
operator|!=
name|checksum2long
argument_list|(
name|crcbuf
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Partial CRC "
operator|+
name|partialCrc
operator|.
name|getValue
argument_list|()
operator|+
literal|" does not match value computed the "
operator|+
literal|" last time file was closed "
operator|+
name|checksum2long
argument_list|(
name|crcbuf
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
DECL|enum|PacketResponderType
specifier|private
specifier|static
enum|enum
name|PacketResponderType
block|{
DECL|enumConstant|NON_PIPELINE
DECL|enumConstant|LAST_IN_PIPELINE
DECL|enumConstant|HAS_DOWNSTREAM_IN_PIPELINE
name|NON_PIPELINE
block|,
name|LAST_IN_PIPELINE
block|,
name|HAS_DOWNSTREAM_IN_PIPELINE
block|}
DECL|field|MIRROR_ERROR_STATUS
specifier|private
specifier|static
name|Status
index|[]
name|MIRROR_ERROR_STATUS
init|=
block|{
name|Status
operator|.
name|SUCCESS
block|,
name|Status
operator|.
name|ERROR
block|}
decl_stmt|;
comment|/**    * Processes responses from downstream datanodes in the pipeline    * and sends back replies to the originator.    */
DECL|class|PacketResponder
class|class
name|PacketResponder
implements|implements
name|Runnable
implements|,
name|Closeable
block|{
comment|/** queue for packets waiting for ack - synchronization using monitor lock */
DECL|field|ackQueue
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|Packet
argument_list|>
name|ackQueue
init|=
operator|new
name|LinkedList
argument_list|<
name|Packet
argument_list|>
argument_list|()
decl_stmt|;
comment|/** the thread that spawns this responder */
DECL|field|receiverThread
specifier|private
specifier|final
name|Thread
name|receiverThread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
comment|/** is this responder running? - synchronization using monitor lock */
DECL|field|running
specifier|private
specifier|volatile
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|/** input from the next downstream datanode */
DECL|field|downstreamIn
specifier|private
specifier|final
name|DataInputStream
name|downstreamIn
decl_stmt|;
comment|/** output to upstream datanode/client */
DECL|field|upstreamOut
specifier|private
specifier|final
name|DataOutputStream
name|upstreamOut
decl_stmt|;
comment|/** The type of this responder */
DECL|field|type
specifier|private
specifier|final
name|PacketResponderType
name|type
decl_stmt|;
comment|/** for log and error messages */
DECL|field|myString
specifier|private
specifier|final
name|String
name|myString
decl_stmt|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|myString
return|;
block|}
DECL|method|PacketResponder (final DataOutputStream upstreamOut, final DataInputStream downstreamIn, final DatanodeInfo[] downstreams)
name|PacketResponder
parameter_list|(
specifier|final
name|DataOutputStream
name|upstreamOut
parameter_list|,
specifier|final
name|DataInputStream
name|downstreamIn
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|downstreams
parameter_list|)
block|{
name|this
operator|.
name|downstreamIn
operator|=
name|downstreamIn
expr_stmt|;
name|this
operator|.
name|upstreamOut
operator|=
name|upstreamOut
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|downstreams
operator|==
literal|null
condition|?
name|PacketResponderType
operator|.
name|NON_PIPELINE
else|:
name|downstreams
operator|.
name|length
operator|==
literal|0
condition|?
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
else|:
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
expr_stmt|;
specifier|final
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
operator|.
name|append
argument_list|(
name|block
argument_list|)
operator|.
name|append
argument_list|(
literal|", type="
argument_list|)
operator|.
name|append
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|", downstreams="
argument_list|)
operator|.
name|append
argument_list|(
name|downstreams
operator|.
name|length
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|downstreams
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|myString
operator|=
name|b
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
DECL|method|isRunning ()
specifier|private
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|running
operator|&&
name|datanode
operator|.
name|shouldRun
return|;
block|}
comment|/**      * enqueue the seqno that is still be to acked by the downstream datanode.      * @param seqno      * @param lastPacketInBlock      * @param offsetInBlock      */
DECL|method|enqueue (final long seqno, final boolean lastPacketInBlock, final long offsetInBlock, final Status ackStatus)
name|void
name|enqueue
parameter_list|(
specifier|final
name|long
name|seqno
parameter_list|,
specifier|final
name|boolean
name|lastPacketInBlock
parameter_list|,
specifier|final
name|long
name|offsetInBlock
parameter_list|,
specifier|final
name|Status
name|ackStatus
parameter_list|)
block|{
specifier|final
name|Packet
name|p
init|=
operator|new
name|Packet
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|,
name|ackStatus
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|": enqueue "
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|running
condition|)
block|{
name|ackQueue
operator|.
name|addLast
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Wait for a packet with given {@code seqno} to be enqueued to ackQueue */
DECL|method|waitForAckHead (long seqno)
specifier|synchronized
name|Packet
name|waitForAckHead
parameter_list|(
name|long
name|seqno
parameter_list|)
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|isRunning
argument_list|()
operator|&&
name|ackQueue
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|": seqno="
operator|+
name|seqno
operator|+
literal|" waiting for local datanode to finish write."
argument_list|)
expr_stmt|;
block|}
name|wait
argument_list|()
expr_stmt|;
block|}
return|return
name|isRunning
argument_list|()
condition|?
name|ackQueue
operator|.
name|getFirst
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**      * wait for all pending packets to be acked. Then shutdown thread.      */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
while|while
condition|(
name|isRunning
argument_list|()
operator|&&
name|ackQueue
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|running
operator|=
literal|false
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|": closing"
argument_list|)
expr_stmt|;
block|}
name|running
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/**      * Thread to process incoming acks.      * @see java.lang.Runnable#run()      */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|boolean
name|lastPacketInBlock
init|=
literal|false
decl_stmt|;
specifier|final
name|long
name|startTime
init|=
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|isRunning
argument_list|()
operator|&&
operator|!
name|lastPacketInBlock
condition|)
block|{
name|long
name|totalAckTimeNanos
init|=
literal|0
decl_stmt|;
name|boolean
name|isInterrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Packet
name|pkt
init|=
literal|null
decl_stmt|;
name|long
name|expected
init|=
operator|-
literal|2
decl_stmt|;
name|PipelineAck
name|ack
init|=
operator|new
name|PipelineAck
argument_list|()
decl_stmt|;
name|long
name|seqno
init|=
name|PipelineAck
operator|.
name|UNKOWN_SEQNO
decl_stmt|;
name|long
name|ackRecvNanoTime
init|=
literal|0
decl_stmt|;
try|try
block|{
if|if
condition|(
name|type
operator|!=
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
operator|&&
operator|!
name|mirrorError
condition|)
block|{
comment|// read an ack from downstream datanode
name|ack
operator|.
name|readFields
argument_list|(
name|downstreamIn
argument_list|)
expr_stmt|;
name|ackRecvNanoTime
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|" got "
operator|+
name|ack
argument_list|)
expr_stmt|;
block|}
name|seqno
operator|=
name|ack
operator|.
name|getSeqno
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|seqno
operator|!=
name|PipelineAck
operator|.
name|UNKOWN_SEQNO
operator|||
name|type
operator|==
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
condition|)
block|{
name|pkt
operator|=
name|waitForAckHead
argument_list|(
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
break|break;
block|}
name|expected
operator|=
name|pkt
operator|.
name|seqno
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
operator|&&
name|seqno
operator|!=
name|expected
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|myString
operator|+
literal|"seqno: expected="
operator|+
name|expected
operator|+
literal|", received="
operator|+
name|seqno
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|==
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
condition|)
block|{
comment|// The total ack time includes the ack times of downstream
comment|// nodes.
comment|// The value is 0 if this responder doesn't have a downstream
comment|// DN in the pipeline.
name|totalAckTimeNanos
operator|=
name|ackRecvNanoTime
operator|-
name|pkt
operator|.
name|ackEnqueueNanoTime
expr_stmt|;
comment|// Report the elapsed time from ack send to ack receive minus
comment|// the downstream ack time.
name|long
name|ackTimeNanos
init|=
name|totalAckTimeNanos
operator|-
name|ack
operator|.
name|getDownstreamAckTimeNanos
argument_list|()
decl_stmt|;
if|if
condition|(
name|ackTimeNanos
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Calculated invalid ack time: "
operator|+
name|ackTimeNanos
operator|+
literal|"ns."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|datanode
operator|.
name|metrics
operator|.
name|addPacketAckRoundTripTimeNanos
argument_list|(
name|ackTimeNanos
argument_list|)
expr_stmt|;
block|}
block|}
name|lastPacketInBlock
operator|=
name|pkt
operator|.
name|lastPacketInBlock
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ine
parameter_list|)
block|{
name|isInterrupted
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|isInterrupted
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// continue to run even if can not read from mirror
comment|// notify client of the error
comment|// and wait for the client to shut down the pipeline
name|mirrorError
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|myString
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
operator|||
name|isInterrupted
condition|)
block|{
comment|/*              * The receiver thread cancelled this thread. We could also check              * any other status updates from the receiver thread (e.g. if it is              * ok to write to replyOut). It is prudent to not send any more              * status back to the client because this datanode has a problem.              * The upstream datanode will detect that this datanode is bad, and              * rightly so.              */
name|LOG
operator|.
name|info
argument_list|(
name|myString
operator|+
literal|": Thread is interrupted."
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lastPacketInBlock
condition|)
block|{
comment|// Finalize the block and close the block file
name|finalizeBlock
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
block|}
name|sendAckUpstream
argument_list|(
name|ack
argument_list|,
name|expected
argument_list|,
name|totalAckTimeNanos
argument_list|,
operator|(
name|pkt
operator|!=
literal|null
condition|?
name|pkt
operator|.
name|offsetInBlock
else|:
literal|0
operator|)
argument_list|,
operator|(
name|pkt
operator|!=
literal|null
condition|?
name|pkt
operator|.
name|ackStatus
else|:
name|Status
operator|.
name|SUCCESS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
operator|!=
literal|null
condition|)
block|{
comment|// remove the packet from the ack queue
name|removeAckHead
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in BlockReceiver.run(): "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|running
condition|)
block|{
try|try
block|{
name|datanode
operator|.
name|checkDiskError
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// may throw an exception here
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"DataNode.checkDiskError failed in run() with: "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|myString
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// failure not caused by interruption
name|receiverThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|myString
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
name|receiverThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|myString
operator|+
literal|" terminating"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Finalize the block and close the block file      * @param startTime time when BlockReceiver started receiving the block      */
DECL|method|finalizeBlock (long startTime)
specifier|private
name|void
name|finalizeBlock
parameter_list|(
name|long
name|startTime
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockReceiver
operator|.
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
specifier|final
name|long
name|endTime
init|=
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|data
operator|.
name|finalizeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|closeBlock
argument_list|(
name|block
argument_list|,
name|DataNode
operator|.
name|EMPTY_DEL_HINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isClient
condition|)
block|{
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|DatanodeRegistration
name|dnR
init|=
name|datanode
operator|.
name|getDNRegistrationForBP
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|ClientTraceLog
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|DN_CLIENTTRACE_FORMAT
argument_list|,
name|inAddr
argument_list|,
name|myAddr
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|"HDFS_WRITE"
argument_list|,
name|clientname
argument_list|,
name|offset
argument_list|,
name|dnR
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|block
argument_list|,
name|endTime
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received "
operator|+
name|block
operator|+
literal|" size "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param ack Ack received from downstream      * @param seqno sequence number of ack to be sent upstream      * @param totalAckTimeNanos total ack time including all the downstream      *          nodes      * @param offsetInBlock offset in block for the data in packet      */
DECL|method|sendAckUpstream (PipelineAck ack, long seqno, long totalAckTimeNanos, long offsetInBlock, Status myStatus)
specifier|private
name|void
name|sendAckUpstream
parameter_list|(
name|PipelineAck
name|ack
parameter_list|,
name|long
name|seqno
parameter_list|,
name|long
name|totalAckTimeNanos
parameter_list|,
name|long
name|offsetInBlock
parameter_list|,
name|Status
name|myStatus
parameter_list|)
throws|throws
name|IOException
block|{
name|Status
index|[]
name|replies
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|mirrorError
condition|)
block|{
comment|// ack read error
name|replies
operator|=
name|MIRROR_ERROR_STATUS
expr_stmt|;
block|}
else|else
block|{
name|short
name|ackLen
init|=
name|type
operator|==
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
condition|?
literal|0
else|:
name|ack
operator|.
name|getNumOfReplies
argument_list|()
decl_stmt|;
name|replies
operator|=
operator|new
name|Status
index|[
literal|1
operator|+
name|ackLen
index|]
expr_stmt|;
name|replies
index|[
literal|0
index|]
operator|=
name|myStatus
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ackLen
condition|;
name|i
operator|++
control|)
block|{
name|replies
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|ack
operator|.
name|getReply
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|// If the mirror has reported that it received a corrupt packet,
comment|// do self-destruct to mark myself bad, instead of making the
comment|// mirror node bad. The mirror is guaranteed to be good without
comment|// corrupt data on disk.
if|if
condition|(
name|ackLen
operator|>
literal|0
operator|&&
name|replies
index|[
literal|1
index|]
operator|==
name|Status
operator|.
name|ERROR_CHECKSUM
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Shutting down writer and responder "
operator|+
literal|"since the down streams reported the data sent by this "
operator|+
literal|"thread is corrupt"
argument_list|)
throw|;
block|}
block|}
name|PipelineAck
name|replyAck
init|=
operator|new
name|PipelineAck
argument_list|(
name|seqno
argument_list|,
name|replies
argument_list|,
name|totalAckTimeNanos
argument_list|)
decl_stmt|;
if|if
condition|(
name|replyAck
operator|.
name|isSuccess
argument_list|()
operator|&&
name|offsetInBlock
operator|>
name|replicaInfo
operator|.
name|getBytesAcked
argument_list|()
condition|)
block|{
name|replicaInfo
operator|.
name|setBytesAcked
argument_list|(
name|offsetInBlock
argument_list|)
expr_stmt|;
block|}
comment|// send my ack back to upstream datanode
name|replyAck
operator|.
name|write
argument_list|(
name|upstreamOut
argument_list|)
expr_stmt|;
name|upstreamOut
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|", replyAck="
operator|+
name|replyAck
argument_list|)
expr_stmt|;
block|}
comment|// If a corruption was detected in the received data, terminate after
comment|// sending ERROR_CHECKSUM back.
if|if
condition|(
name|myStatus
operator|==
name|Status
operator|.
name|ERROR_CHECKSUM
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Shutting down writer and responder "
operator|+
literal|"due to a checksum error in received data. The error "
operator|+
literal|"response has been sent upstream."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Remove a packet from the head of the ack queue      *       * This should be called only when the ack queue is not empty      */
DECL|method|removeAckHead ()
specifier|private
specifier|synchronized
name|void
name|removeAckHead
parameter_list|()
block|{
name|ackQueue
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This information is cached by the Datanode in the ackQueue.    */
DECL|class|Packet
specifier|private
specifier|static
class|class
name|Packet
block|{
DECL|field|seqno
specifier|final
name|long
name|seqno
decl_stmt|;
DECL|field|lastPacketInBlock
specifier|final
name|boolean
name|lastPacketInBlock
decl_stmt|;
DECL|field|offsetInBlock
specifier|final
name|long
name|offsetInBlock
decl_stmt|;
DECL|field|ackEnqueueNanoTime
specifier|final
name|long
name|ackEnqueueNanoTime
decl_stmt|;
DECL|field|ackStatus
specifier|final
name|Status
name|ackStatus
decl_stmt|;
DECL|method|Packet (long seqno, boolean lastPacketInBlock, long offsetInBlock, long ackEnqueueNanoTime, Status ackStatus)
name|Packet
parameter_list|(
name|long
name|seqno
parameter_list|,
name|boolean
name|lastPacketInBlock
parameter_list|,
name|long
name|offsetInBlock
parameter_list|,
name|long
name|ackEnqueueNanoTime
parameter_list|,
name|Status
name|ackStatus
parameter_list|)
block|{
name|this
operator|.
name|seqno
operator|=
name|seqno
expr_stmt|;
name|this
operator|.
name|lastPacketInBlock
operator|=
name|lastPacketInBlock
expr_stmt|;
name|this
operator|.
name|offsetInBlock
operator|=
name|offsetInBlock
expr_stmt|;
name|this
operator|.
name|ackEnqueueNanoTime
operator|=
name|ackEnqueueNanoTime
expr_stmt|;
name|this
operator|.
name|ackStatus
operator|=
name|ackStatus
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(seqno="
operator|+
name|seqno
operator|+
literal|", lastPacketInBlock="
operator|+
name|lastPacketInBlock
operator|+
literal|", offsetInBlock="
operator|+
name|offsetInBlock
operator|+
literal|", ackEnqueueNanoTime="
operator|+
name|ackEnqueueNanoTime
operator|+
literal|", ackStatus="
operator|+
name|ackStatus
operator|+
literal|")"
return|;
block|}
block|}
block|}
end_class

end_unit

