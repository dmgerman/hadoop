begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
operator|.
name|DN_CLIENTTRACE_FORMAT
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Checksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ChecksumException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSOutputSummer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StorageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtilClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|BlockConstructionStage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PacketHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PacketReceiver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PipelineAck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|BlockOpResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaInputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|fsdataset
operator|.
name|ReplicaOutputStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|DataTransferThrottler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Tracer
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
operator|.
name|POSIX
operator|.
name|POSIX_FADV_DONTNEED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
operator|.
name|NativeIO
operator|.
name|POSIX
operator|.
name|SYNC_FILE_RANGE_WRITE
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_comment
comment|/** A class that receives a block and writes to its own disk, meanwhile  * may copies it to another site. If a throttler is provided,  * streaming throttling is also supported.  **/
end_comment

begin_class
DECL|class|BlockReceiver
class|class
name|BlockReceiver
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|ClientTraceLog
specifier|static
specifier|final
name|Log
name|ClientTraceLog
init|=
name|DataNode
operator|.
name|ClientTraceLog
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|CACHE_DROP_LAG_BYTES
specifier|static
name|long
name|CACHE_DROP_LAG_BYTES
init|=
literal|8
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
DECL|field|datanodeSlowLogThresholdMs
specifier|private
specifier|final
name|long
name|datanodeSlowLogThresholdMs
decl_stmt|;
DECL|field|in
specifier|private
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
comment|// from where data are read
DECL|field|clientChecksum
specifier|private
name|DataChecksum
name|clientChecksum
decl_stmt|;
comment|// checksum used by client
DECL|field|diskChecksum
specifier|private
name|DataChecksum
name|diskChecksum
decl_stmt|;
comment|// checksum we write to disk
comment|/**    * In the case that the client is writing with a different    * checksum polynomial than the block is stored with on disk,    * the DataNode needs to recalculate checksums before writing.    */
DECL|field|needsChecksumTranslation
specifier|private
specifier|final
name|boolean
name|needsChecksumTranslation
decl_stmt|;
DECL|field|checksumOut
specifier|private
name|DataOutputStream
name|checksumOut
init|=
literal|null
decl_stmt|;
comment|// to crc file at local disk
DECL|field|bytesPerChecksum
specifier|private
specifier|final
name|int
name|bytesPerChecksum
decl_stmt|;
DECL|field|checksumSize
specifier|private
specifier|final
name|int
name|checksumSize
decl_stmt|;
DECL|field|packetReceiver
specifier|private
specifier|final
name|PacketReceiver
name|packetReceiver
init|=
operator|new
name|PacketReceiver
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|inAddr
specifier|protected
specifier|final
name|String
name|inAddr
decl_stmt|;
DECL|field|myAddr
specifier|protected
specifier|final
name|String
name|myAddr
decl_stmt|;
DECL|field|mirrorAddr
specifier|private
name|String
name|mirrorAddr
decl_stmt|;
DECL|field|bracketedMirrorAddr
specifier|private
name|String
name|bracketedMirrorAddr
decl_stmt|;
DECL|field|mirrorOut
specifier|private
name|DataOutputStream
name|mirrorOut
decl_stmt|;
DECL|field|responder
specifier|private
name|Daemon
name|responder
init|=
literal|null
decl_stmt|;
DECL|field|throttler
specifier|private
name|DataTransferThrottler
name|throttler
decl_stmt|;
DECL|field|streams
specifier|private
name|ReplicaOutputStreams
name|streams
decl_stmt|;
DECL|field|srcDataNode
specifier|private
name|DatanodeInfo
name|srcDataNode
init|=
literal|null
decl_stmt|;
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|mirrorError
specifier|volatile
specifier|private
name|boolean
name|mirrorError
decl_stmt|;
comment|// Cache management state
DECL|field|dropCacheBehindWrites
specifier|private
name|boolean
name|dropCacheBehindWrites
decl_stmt|;
DECL|field|lastCacheManagementOffset
specifier|private
name|long
name|lastCacheManagementOffset
init|=
literal|0
decl_stmt|;
DECL|field|syncBehindWrites
specifier|private
name|boolean
name|syncBehindWrites
decl_stmt|;
DECL|field|syncBehindWritesInBackground
specifier|private
name|boolean
name|syncBehindWritesInBackground
decl_stmt|;
comment|/** The client name.  It is empty if a datanode is the client */
DECL|field|clientname
specifier|private
specifier|final
name|String
name|clientname
decl_stmt|;
DECL|field|isClient
specifier|private
specifier|final
name|boolean
name|isClient
decl_stmt|;
DECL|field|isDatanode
specifier|private
specifier|final
name|boolean
name|isDatanode
decl_stmt|;
comment|/** the block to receive */
DECL|field|block
specifier|private
specifier|final
name|ExtendedBlock
name|block
decl_stmt|;
comment|/** the replica to write */
DECL|field|replicaInfo
specifier|private
name|ReplicaInPipeline
name|replicaInfo
decl_stmt|;
comment|/** pipeline stage */
DECL|field|stage
specifier|private
specifier|final
name|BlockConstructionStage
name|stage
decl_stmt|;
DECL|field|isTransfer
specifier|private
specifier|final
name|boolean
name|isTransfer
decl_stmt|;
DECL|field|isPenultimateNode
specifier|private
name|boolean
name|isPenultimateNode
init|=
literal|false
decl_stmt|;
DECL|field|syncOnClose
specifier|private
name|boolean
name|syncOnClose
decl_stmt|;
DECL|field|restartBudget
specifier|private
name|long
name|restartBudget
decl_stmt|;
comment|/** the reference of the volume where the block receiver writes to */
DECL|field|replicaHandler
specifier|private
name|ReplicaHandler
name|replicaHandler
decl_stmt|;
comment|/**    * for replaceBlock response    */
DECL|field|responseInterval
specifier|private
specifier|final
name|long
name|responseInterval
decl_stmt|;
DECL|field|lastResponseTime
specifier|private
name|long
name|lastResponseTime
init|=
literal|0
decl_stmt|;
DECL|field|isReplaceBlock
specifier|private
name|boolean
name|isReplaceBlock
init|=
literal|false
decl_stmt|;
DECL|field|replyOut
specifier|private
name|DataOutputStream
name|replyOut
init|=
literal|null
decl_stmt|;
DECL|field|maxWriteToDiskMs
specifier|private
name|long
name|maxWriteToDiskMs
init|=
literal|0
decl_stmt|;
DECL|field|pinning
specifier|private
name|boolean
name|pinning
decl_stmt|;
DECL|field|lastSentTime
specifier|private
name|long
name|lastSentTime
decl_stmt|;
DECL|field|maxSendIdleTime
specifier|private
name|long
name|maxSendIdleTime
decl_stmt|;
DECL|method|BlockReceiver (final ExtendedBlock block, final StorageType storageType, final DataInputStream in, final String inAddr, final String myAddr, final BlockConstructionStage stage, final long newGs, final long minBytesRcvd, final long maxBytesRcvd, final String clientname, final DatanodeInfo srcDataNode, final DataNode datanode, DataChecksum requestedChecksum, CachingStrategy cachingStrategy, final boolean allowLazyPersist, final boolean pinning)
name|BlockReceiver
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|,
specifier|final
name|StorageType
name|storageType
parameter_list|,
specifier|final
name|DataInputStream
name|in
parameter_list|,
specifier|final
name|String
name|inAddr
parameter_list|,
specifier|final
name|String
name|myAddr
parameter_list|,
specifier|final
name|BlockConstructionStage
name|stage
parameter_list|,
specifier|final
name|long
name|newGs
parameter_list|,
specifier|final
name|long
name|minBytesRcvd
parameter_list|,
specifier|final
name|long
name|maxBytesRcvd
parameter_list|,
specifier|final
name|String
name|clientname
parameter_list|,
specifier|final
name|DatanodeInfo
name|srcDataNode
parameter_list|,
specifier|final
name|DataNode
name|datanode
parameter_list|,
name|DataChecksum
name|requestedChecksum
parameter_list|,
name|CachingStrategy
name|cachingStrategy
parameter_list|,
specifier|final
name|boolean
name|allowLazyPersist
parameter_list|,
specifier|final
name|boolean
name|pinning
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|inAddr
operator|=
name|inAddr
expr_stmt|;
name|this
operator|.
name|myAddr
operator|=
name|myAddr
expr_stmt|;
name|this
operator|.
name|srcDataNode
operator|=
name|srcDataNode
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|clientname
operator|=
name|clientname
expr_stmt|;
name|this
operator|.
name|isDatanode
operator|=
name|clientname
operator|.
name|length
argument_list|()
operator|==
literal|0
expr_stmt|;
name|this
operator|.
name|isClient
operator|=
operator|!
name|this
operator|.
name|isDatanode
expr_stmt|;
name|this
operator|.
name|restartBudget
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|restartReplicaExpiry
expr_stmt|;
name|this
operator|.
name|datanodeSlowLogThresholdMs
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|datanodeSlowIoWarningThresholdMs
expr_stmt|;
comment|// For replaceBlock() calls response should be sent to avoid socketTimeout
comment|// at clients. So sending with the interval of 0.5 * socketTimeout
specifier|final
name|long
name|readTimeout
init|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|socketTimeout
decl_stmt|;
name|this
operator|.
name|responseInterval
operator|=
call|(
name|long
call|)
argument_list|(
name|readTimeout
operator|*
literal|0.5
argument_list|)
expr_stmt|;
comment|//for datanode, we have
comment|//1: clientName.length() == 0, and
comment|//2: stage == null or PIPELINE_SETUP_CREATE
name|this
operator|.
name|stage
operator|=
name|stage
expr_stmt|;
name|this
operator|.
name|isTransfer
operator|=
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_RBW
operator|||
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_FINALIZED
expr_stmt|;
name|this
operator|.
name|pinning
operator|=
name|pinning
expr_stmt|;
name|this
operator|.
name|lastSentTime
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
expr_stmt|;
comment|// Downstream will timeout in readTimeout on receiving the next packet.
comment|// If there is no data traffic, a heartbeat packet is sent at
comment|// the interval of 0.5*readTimeout. Here, we set 0.9*readTimeout to be
comment|// the threshold for detecting congestion.
name|this
operator|.
name|maxSendIdleTime
operator|=
call|(
name|long
call|)
argument_list|(
name|readTimeout
operator|*
literal|0.9
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
operator|+
name|block
operator|+
literal|"\n storageType="
operator|+
name|storageType
operator|+
literal|", inAddr="
operator|+
name|inAddr
operator|+
literal|", myAddr="
operator|+
name|myAddr
operator|+
literal|"\n stage="
operator|+
name|stage
operator|+
literal|", newGs="
operator|+
name|newGs
operator|+
literal|", minBytesRcvd="
operator|+
name|minBytesRcvd
operator|+
literal|", maxBytesRcvd="
operator|+
name|maxBytesRcvd
operator|+
literal|"\n clientname="
operator|+
name|clientname
operator|+
literal|", srcDataNode="
operator|+
name|srcDataNode
operator|+
literal|", datanode="
operator|+
name|datanode
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|"\n requestedChecksum="
operator|+
name|requestedChecksum
operator|+
literal|"\n cachingStrategy="
operator|+
name|cachingStrategy
operator|+
literal|"\n allowLazyPersist="
operator|+
name|allowLazyPersist
operator|+
literal|", pinning="
operator|+
name|pinning
operator|+
literal|", isClient="
operator|+
name|isClient
operator|+
literal|", isDatanode="
operator|+
name|isDatanode
operator|+
literal|", responseInterval="
operator|+
name|responseInterval
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Open local disk out
comment|//
if|if
condition|(
name|isDatanode
condition|)
block|{
comment|//replication or move
name|replicaHandler
operator|=
name|datanode
operator|.
name|data
operator|.
name|createTemporary
argument_list|(
name|storageType
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|stage
condition|)
block|{
case|case
name|PIPELINE_SETUP_CREATE
case|:
name|replicaHandler
operator|=
name|datanode
operator|.
name|data
operator|.
name|createRbw
argument_list|(
name|storageType
argument_list|,
name|block
argument_list|,
name|allowLazyPersist
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|,
name|replicaHandler
operator|.
name|getReplica
argument_list|()
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIPELINE_SETUP_STREAMING_RECOVERY
case|:
name|replicaHandler
operator|=
name|datanode
operator|.
name|data
operator|.
name|recoverRbw
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|,
name|maxBytesRcvd
argument_list|)
expr_stmt|;
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIPELINE_SETUP_APPEND
case|:
name|replicaHandler
operator|=
name|datanode
operator|.
name|data
operator|.
name|append
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|)
expr_stmt|;
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|,
name|replicaHandler
operator|.
name|getReplica
argument_list|()
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIPELINE_SETUP_APPEND_RECOVERY
case|:
name|replicaHandler
operator|=
name|datanode
operator|.
name|data
operator|.
name|recoverAppend
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|)
expr_stmt|;
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|notifyNamenodeReceivingBlock
argument_list|(
name|block
argument_list|,
name|replicaHandler
operator|.
name|getReplica
argument_list|()
operator|.
name|getStorageUuid
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRANSFER_RBW
case|:
case|case
name|TRANSFER_FINALIZED
case|:
comment|// this is a transfer destination
name|replicaHandler
operator|=
name|datanode
operator|.
name|data
operator|.
name|createTemporary
argument_list|(
name|storageType
argument_list|,
name|block
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unsupported stage "
operator|+
name|stage
operator|+
literal|" while receiving block "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|)
throw|;
block|}
block|}
name|replicaInfo
operator|=
name|replicaHandler
operator|.
name|getReplica
argument_list|()
expr_stmt|;
name|this
operator|.
name|dropCacheBehindWrites
operator|=
operator|(
name|cachingStrategy
operator|.
name|getDropBehind
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|dropCacheBehindWrites
else|:
name|cachingStrategy
operator|.
name|getDropBehind
argument_list|()
expr_stmt|;
name|this
operator|.
name|syncBehindWrites
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|syncBehindWrites
expr_stmt|;
name|this
operator|.
name|syncBehindWritesInBackground
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|syncBehindWritesInBackground
expr_stmt|;
specifier|final
name|boolean
name|isCreate
init|=
name|isDatanode
operator|||
name|isTransfer
operator|||
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|PIPELINE_SETUP_CREATE
decl_stmt|;
name|streams
operator|=
name|replicaInfo
operator|.
name|createStreams
argument_list|(
name|isCreate
argument_list|,
name|requestedChecksum
argument_list|)
expr_stmt|;
assert|assert
name|streams
operator|!=
literal|null
operator|:
literal|"null streams!"
assert|;
comment|// read checksum meta information
name|this
operator|.
name|clientChecksum
operator|=
name|requestedChecksum
expr_stmt|;
name|this
operator|.
name|diskChecksum
operator|=
name|streams
operator|.
name|getChecksum
argument_list|()
expr_stmt|;
name|this
operator|.
name|needsChecksumTranslation
operator|=
operator|!
name|clientChecksum
operator|.
name|equals
argument_list|(
name|diskChecksum
argument_list|)
expr_stmt|;
name|this
operator|.
name|bytesPerChecksum
operator|=
name|diskChecksum
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
name|this
operator|.
name|checksumSize
operator|=
name|diskChecksum
operator|.
name|getChecksumSize
argument_list|()
expr_stmt|;
name|this
operator|.
name|checksumOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|streams
operator|.
name|getChecksumOut
argument_list|()
argument_list|,
name|DFSUtilClient
operator|.
name|getSmallBufferSize
argument_list|(
name|datanode
operator|.
name|getConf
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// write data chunk header if creating a new replica
if|if
condition|(
name|isCreate
condition|)
block|{
name|BlockMetadataHeader
operator|.
name|writeHeader
argument_list|(
name|checksumOut
argument_list|,
name|diskChecksum
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ReplicaAlreadyExistsException
name|bae
parameter_list|)
block|{
throw|throw
name|bae
throw|;
block|}
catch|catch
parameter_list|(
name|ReplicaNotFoundException
name|bne
parameter_list|)
block|{
throw|throw
name|bne
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|replicaInfo
operator|!=
literal|null
condition|)
block|{
name|replicaInfo
operator|.
name|releaseAllBytesReserved
argument_list|()
expr_stmt|;
block|}
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|cleanupBlock
argument_list|()
expr_stmt|;
comment|// check if there is a disk error
name|IOException
name|cause
init|=
name|DatanodeUtil
operator|.
name|getCauseIfDiskError
argument_list|(
name|ioe
argument_list|)
decl_stmt|;
name|DataNode
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in BlockReceiver constructor"
operator|+
operator|(
name|cause
operator|==
literal|null
condition|?
literal|""
else|:
literal|". Cause is "
operator|)
argument_list|,
name|cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
comment|// possible disk error
name|ioe
operator|=
name|cause
expr_stmt|;
name|datanode
operator|.
name|checkDiskErrorAsync
argument_list|()
expr_stmt|;
block|}
throw|throw
name|ioe
throw|;
block|}
block|}
comment|/** Return the datanode object. */
DECL|method|getDataNode ()
name|DataNode
name|getDataNode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
DECL|method|getReplica ()
name|Replica
name|getReplica
parameter_list|()
block|{
return|return
name|replicaInfo
return|;
block|}
comment|/**    * close files and release volume reference.    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|Span
name|span
init|=
name|Tracer
operator|.
name|getCurrentSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|span
operator|!=
literal|null
condition|)
block|{
name|span
operator|.
name|addKVAnnotation
argument_list|(
literal|"maxWriteToDiskMs"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|maxWriteToDiskMs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|packetReceiver
operator|.
name|close
argument_list|()
expr_stmt|;
name|IOException
name|ioe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|syncOnClose
operator|&&
operator|(
name|streams
operator|.
name|getDataOut
argument_list|()
operator|!=
literal|null
operator|||
name|checksumOut
operator|!=
literal|null
operator|)
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|incrFsyncCount
argument_list|()
expr_stmt|;
block|}
name|long
name|flushTotalNanos
init|=
literal|0
decl_stmt|;
name|boolean
name|measuredFlushTime
init|=
literal|false
decl_stmt|;
comment|// close checksum file
try|try
block|{
if|if
condition|(
name|checksumOut
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|checksumOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|syncOnClose
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
name|streams
operator|.
name|syncChecksumOut
argument_list|()
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
name|measuredFlushTime
operator|=
literal|true
expr_stmt|;
name|checksumOut
operator|.
name|close
argument_list|()
expr_stmt|;
name|checksumOut
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ioe
operator|=
name|e
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|checksumOut
argument_list|)
expr_stmt|;
block|}
comment|// close block file
try|try
block|{
if|if
condition|(
name|streams
operator|.
name|getDataOut
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|streams
operator|.
name|flushDataOut
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|syncOnClose
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
name|streams
operator|.
name|syncDataOut
argument_list|()
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
name|measuredFlushTime
operator|=
literal|true
expr_stmt|;
name|streams
operator|.
name|closeDataStream
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ioe
operator|=
name|e
expr_stmt|;
block|}
finally|finally
block|{
name|streams
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|replicaHandler
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
literal|null
argument_list|,
name|replicaHandler
argument_list|)
expr_stmt|;
name|replicaHandler
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|measuredFlushTime
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|addFlushNanos
argument_list|(
name|flushTotalNanos
argument_list|)
expr_stmt|;
block|}
comment|// disk check
if|if
condition|(
name|ioe
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|checkDiskErrorAsync
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
DECL|method|setLastSentTime (long sentTime)
specifier|synchronized
name|void
name|setLastSentTime
parameter_list|(
name|long
name|sentTime
parameter_list|)
block|{
name|lastSentTime
operator|=
name|sentTime
expr_stmt|;
block|}
comment|/**    * It can return false if    * - upstream did not send packet for a long time    * - a packet was received but got stuck in local disk I/O.    * - a packet was received but got stuck on send to mirror.    */
DECL|method|packetSentInTime ()
specifier|synchronized
name|boolean
name|packetSentInTime
parameter_list|()
block|{
name|long
name|diff
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|lastSentTime
decl_stmt|;
if|if
condition|(
name|diff
operator|>
name|maxSendIdleTime
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"A packet was last sent "
operator|+
name|diff
operator|+
literal|" milliseconds ago."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Flush block data and metadata files to disk.    * @throws IOException    */
DECL|method|flushOrSync (boolean isSync)
name|void
name|flushOrSync
parameter_list|(
name|boolean
name|isSync
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|flushTotalNanos
init|=
literal|0
decl_stmt|;
name|long
name|begin
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
name|checksumOut
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|checksumOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSync
condition|)
block|{
name|streams
operator|.
name|syncChecksumOut
argument_list|()
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|flushEndNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
block|}
if|if
condition|(
name|streams
operator|.
name|getDataOut
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|long
name|flushStartNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|streams
operator|.
name|flushDataOut
argument_list|()
expr_stmt|;
name|long
name|flushEndNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSync
condition|)
block|{
name|long
name|fsyncStartNanos
init|=
name|flushEndNanos
decl_stmt|;
name|streams
operator|.
name|syncDataOut
argument_list|()
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|addFsyncNanos
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|fsyncStartNanos
argument_list|)
expr_stmt|;
block|}
name|flushTotalNanos
operator|+=
name|flushEndNanos
operator|-
name|flushStartNanos
expr_stmt|;
block|}
if|if
condition|(
name|checksumOut
operator|!=
literal|null
operator|||
name|streams
operator|.
name|getDataOut
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|addFlushNanos
argument_list|(
name|flushTotalNanos
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSync
condition|)
block|{
name|datanode
operator|.
name|metrics
operator|.
name|incrFsyncCount
argument_list|()
expr_stmt|;
block|}
block|}
name|long
name|duration
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|begin
decl_stmt|;
if|if
condition|(
name|duration
operator|>
name|datanodeSlowLogThresholdMs
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Slow flushOrSync took "
operator|+
name|duration
operator|+
literal|"ms (threshold="
operator|+
name|datanodeSlowLogThresholdMs
operator|+
literal|"ms), isSync:"
operator|+
name|isSync
operator|+
literal|", flushTotalNanos="
operator|+
name|flushTotalNanos
operator|+
literal|"ns"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * While writing to mirrorOut, failure to write to mirror should not    * affect this datanode unless it is caused by interruption.    */
DECL|method|handleMirrorOutError (IOException ioe)
specifier|private
name|void
name|handleMirrorOutError
parameter_list|(
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|bpid
init|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|datanode
operator|.
name|getDNRegistrationForBP
argument_list|(
name|bpid
argument_list|)
operator|+
literal|":Exception writing "
operator|+
name|block
operator|+
literal|" to mirror "
operator|+
name|mirrorAddr
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// shut down if the thread is interrupted
throw|throw
name|ioe
throw|;
block|}
else|else
block|{
comment|// encounter an error while writing to mirror
comment|// continue to run even if can not write to mirror
comment|// notify client of the error
comment|// and wait for the client to shut down the pipeline
name|mirrorError
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**    * Verify multiple CRC chunks.     */
DECL|method|verifyChunks (ByteBuffer dataBuf, ByteBuffer checksumBuf)
specifier|private
name|void
name|verifyChunks
parameter_list|(
name|ByteBuffer
name|dataBuf
parameter_list|,
name|ByteBuffer
name|checksumBuf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|clientChecksum
operator|.
name|verifyChunkedSums
argument_list|(
name|dataBuf
argument_list|,
name|checksumBuf
argument_list|,
name|clientname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|ce
parameter_list|)
block|{
name|PacketHeader
name|header
init|=
name|packetReceiver
operator|.
name|getHeader
argument_list|()
decl_stmt|;
name|String
name|specificOffset
init|=
literal|"specific offsets are:"
operator|+
literal|" offsetInBlock = "
operator|+
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
literal|" offsetInPacket = "
operator|+
name|ce
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Checksum error in block "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|inAddr
operator|+
literal|", "
operator|+
name|specificOffset
argument_list|,
name|ce
argument_list|)
expr_stmt|;
comment|// No need to report to namenode when client is writing.
if|if
condition|(
name|srcDataNode
operator|!=
literal|null
operator|&&
name|isDatanode
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"report corrupt "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|srcDataNode
operator|+
literal|" to namenode"
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|reportRemoteBadBlock
argument_list|(
name|srcDataNode
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to report bad "
operator|+
name|block
operator|+
literal|" from datanode "
operator|+
name|srcDataNode
operator|+
literal|" to namenode"
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected checksum mismatch while writing "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|)
throw|;
block|}
block|}
comment|/**    * Translate CRC chunks from the client's checksum implementation    * to the disk checksum implementation.    *     * This does not verify the original checksums, under the assumption    * that they have already been validated.    */
DECL|method|translateChunks (ByteBuffer dataBuf, ByteBuffer checksumBuf)
specifier|private
name|void
name|translateChunks
parameter_list|(
name|ByteBuffer
name|dataBuf
parameter_list|,
name|ByteBuffer
name|checksumBuf
parameter_list|)
block|{
name|diskChecksum
operator|.
name|calculateChunkedSums
argument_list|(
name|dataBuf
argument_list|,
name|checksumBuf
argument_list|)
expr_stmt|;
block|}
comment|/**     * Check whether checksum needs to be verified.    * Skip verifying checksum iff this is not the last one in the     * pipeline and clientName is non-null. i.e. Checksum is verified    * on all the datanodes when the data is being written by a     * datanode rather than a client. Whe client is writing the data,     * protocol includes acks and only the last datanode needs to verify     * checksum.    * @return true if checksum verification is needed, otherwise false.    */
DECL|method|shouldVerifyChecksum ()
specifier|private
name|boolean
name|shouldVerifyChecksum
parameter_list|()
block|{
return|return
operator|(
name|mirrorOut
operator|==
literal|null
operator|||
name|isDatanode
operator|||
name|needsChecksumTranslation
operator|)
return|;
block|}
comment|/**     * Receives and processes a packet. It can contain many chunks.    * returns the number of data bytes that the packet has.    */
DECL|method|receivePacket ()
specifier|private
name|int
name|receivePacket
parameter_list|()
throws|throws
name|IOException
block|{
comment|// read the next packet
name|packetReceiver
operator|.
name|receiveNextPacket
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|PacketHeader
name|header
init|=
name|packetReceiver
operator|.
name|getHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Receiving one packet for block "
operator|+
name|block
operator|+
literal|": "
operator|+
name|header
argument_list|)
expr_stmt|;
block|}
comment|// Sanity check the header
if|if
condition|(
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|>
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Received an out-of-sequence packet for "
operator|+
name|block
operator|+
literal|"from "
operator|+
name|inAddr
operator|+
literal|" at offset "
operator|+
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
literal|". Expecting packet starting at "
operator|+
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|header
operator|.
name|getDataLen
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got wrong length during writeBlock("
operator|+
name|block
operator|+
literal|") from "
operator|+
name|inAddr
operator|+
literal|" at offset "
operator|+
name|header
operator|.
name|getOffsetInBlock
argument_list|()
operator|+
literal|": "
operator|+
name|header
operator|.
name|getDataLen
argument_list|()
argument_list|)
throw|;
block|}
name|long
name|offsetInBlock
init|=
name|header
operator|.
name|getOffsetInBlock
argument_list|()
decl_stmt|;
name|long
name|seqno
init|=
name|header
operator|.
name|getSeqno
argument_list|()
decl_stmt|;
name|boolean
name|lastPacketInBlock
init|=
name|header
operator|.
name|isLastPacketInBlock
argument_list|()
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|header
operator|.
name|getDataLen
argument_list|()
decl_stmt|;
name|boolean
name|syncBlock
init|=
name|header
operator|.
name|getSyncBlock
argument_list|()
decl_stmt|;
comment|// avoid double sync'ing on close
if|if
condition|(
name|syncBlock
operator|&&
name|lastPacketInBlock
condition|)
block|{
name|this
operator|.
name|syncOnClose
operator|=
literal|false
expr_stmt|;
block|}
comment|// update received bytes
specifier|final
name|long
name|firstByteInBlock
init|=
name|offsetInBlock
decl_stmt|;
name|offsetInBlock
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
operator|<
name|offsetInBlock
condition|)
block|{
name|replicaInfo
operator|.
name|setNumBytes
argument_list|(
name|offsetInBlock
argument_list|)
expr_stmt|;
block|}
comment|// put in queue for pending acks, unless sync was requested
if|if
condition|(
name|responder
operator|!=
literal|null
operator|&&
operator|!
name|syncBlock
operator|&&
operator|!
name|shouldVerifyChecksum
argument_list|()
condition|)
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|enqueue
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|,
name|Status
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
block|}
comment|// Drop heartbeat for testing.
if|if
condition|(
name|seqno
operator|<
literal|0
operator|&&
name|len
operator|==
literal|0
operator|&&
name|DataNodeFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|dropHeartbeatPacket
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|//First write the packet to the mirror:
if|if
condition|(
name|mirrorOut
operator|!=
literal|null
operator|&&
operator|!
name|mirrorError
condition|)
block|{
try|try
block|{
name|long
name|begin
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|// For testing. Normally no-op.
name|DataNodeFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|stopSendingPacketDownstream
argument_list|(
name|mirrorAddr
argument_list|)
expr_stmt|;
name|packetReceiver
operator|.
name|mirrorPacketTo
argument_list|(
name|mirrorOut
argument_list|)
expr_stmt|;
name|mirrorOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|setLastSentTime
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|long
name|duration
init|=
name|now
operator|-
name|begin
decl_stmt|;
name|DataNodeFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|logDelaySendingPacketDownstream
argument_list|(
name|mirrorAddr
argument_list|,
name|duration
argument_list|)
expr_stmt|;
name|trackSendPacketToLastNodeInPipeline
argument_list|(
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|duration
operator|>
name|datanodeSlowLogThresholdMs
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Slow BlockReceiver write packet to mirror took "
operator|+
name|duration
operator|+
literal|"ms (threshold="
operator|+
name|datanodeSlowLogThresholdMs
operator|+
literal|"ms)"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|handleMirrorOutError
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|ByteBuffer
name|dataBuf
init|=
name|packetReceiver
operator|.
name|getDataSlice
argument_list|()
decl_stmt|;
name|ByteBuffer
name|checksumBuf
init|=
name|packetReceiver
operator|.
name|getChecksumSlice
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastPacketInBlock
operator|||
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Receiving an empty packet or the end of the block "
operator|+
name|block
argument_list|)
expr_stmt|;
block|}
comment|// sync block if requested
if|if
condition|(
name|syncBlock
condition|)
block|{
name|flushOrSync
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|int
name|checksumLen
init|=
name|diskChecksum
operator|.
name|getChecksumSize
argument_list|(
name|len
argument_list|)
decl_stmt|;
specifier|final
name|int
name|checksumReceivedLen
init|=
name|checksumBuf
operator|.
name|capacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|checksumReceivedLen
operator|>
literal|0
operator|&&
name|checksumReceivedLen
operator|!=
name|checksumLen
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid checksum length: received length is "
operator|+
name|checksumReceivedLen
operator|+
literal|" but expected length is "
operator|+
name|checksumLen
argument_list|)
throw|;
block|}
if|if
condition|(
name|checksumReceivedLen
operator|>
literal|0
operator|&&
name|shouldVerifyChecksum
argument_list|()
condition|)
block|{
try|try
block|{
name|verifyChunks
argument_list|(
name|dataBuf
argument_list|,
name|checksumBuf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// checksum error detected locally. there is no reason to continue.
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
try|try
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|enqueue
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|,
name|Status
operator|.
name|ERROR_CHECKSUM
argument_list|)
expr_stmt|;
comment|// Wait until the responder sends back the response
comment|// and interrupt this thread.
name|Thread
operator|.
name|sleep
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{ }
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Terminating due to a checksum error."
operator|+
name|ioe
argument_list|)
throw|;
block|}
if|if
condition|(
name|needsChecksumTranslation
condition|)
block|{
comment|// overwrite the checksums in the packet buffer with the
comment|// appropriate polynomial for the disk storage.
name|translateChunks
argument_list|(
name|dataBuf
argument_list|,
name|checksumBuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checksumReceivedLen
operator|==
literal|0
operator|&&
operator|!
name|streams
operator|.
name|isTransientStorage
argument_list|()
condition|)
block|{
comment|// checksum is missing, need to calculate it
name|checksumBuf
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|checksumLen
argument_list|)
expr_stmt|;
name|diskChecksum
operator|.
name|calculateChunkedSums
argument_list|(
name|dataBuf
argument_list|,
name|checksumBuf
argument_list|)
expr_stmt|;
block|}
comment|// by this point, the data in the buffer uses the disk checksum
specifier|final
name|boolean
name|shouldNotWriteChecksum
init|=
name|checksumReceivedLen
operator|==
literal|0
operator|&&
name|streams
operator|.
name|isTransientStorage
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|onDiskLen
init|=
name|replicaInfo
operator|.
name|getBytesOnDisk
argument_list|()
decl_stmt|;
if|if
condition|(
name|onDiskLen
operator|<
name|offsetInBlock
condition|)
block|{
comment|// Normally the beginning of an incoming packet is aligned with the
comment|// existing data on disk. If the beginning packet data offset is not
comment|// checksum chunk aligned, the end of packet will not go beyond the
comment|// next chunk boundary.
comment|// When a failure-recovery is involved, the client state and the
comment|// the datanode state may not exactly agree. I.e. the client may
comment|// resend part of data that is already on disk. Correct number of
comment|// bytes should be skipped when writing the data and checksum
comment|// buffers out to disk.
name|long
name|partialChunkSizeOnDisk
init|=
name|onDiskLen
operator|%
name|bytesPerChecksum
decl_stmt|;
name|long
name|lastChunkBoundary
init|=
name|onDiskLen
operator|-
name|partialChunkSizeOnDisk
decl_stmt|;
name|boolean
name|alignedOnDisk
init|=
name|partialChunkSizeOnDisk
operator|==
literal|0
decl_stmt|;
name|boolean
name|alignedInPacket
init|=
name|firstByteInBlock
operator|%
name|bytesPerChecksum
operator|==
literal|0
decl_stmt|;
comment|// If the end of the on-disk data is not chunk-aligned, the last
comment|// checksum needs to be overwritten.
name|boolean
name|overwriteLastCrc
init|=
operator|!
name|alignedOnDisk
operator|&&
operator|!
name|shouldNotWriteChecksum
decl_stmt|;
comment|// If the starting offset of the packat data is at the last chunk
comment|// boundary of the data on disk, the partial checksum recalculation
comment|// can be skipped and the checksum supplied by the client can be used
comment|// instead. This reduces disk reads and cpu load.
name|boolean
name|doCrcRecalc
init|=
name|overwriteLastCrc
operator|&&
operator|(
name|lastChunkBoundary
operator|!=
name|firstByteInBlock
operator|)
decl_stmt|;
comment|// If this is a partial chunk, then verify that this is the only
comment|// chunk in the packet. If the starting offset is not chunk
comment|// aligned, the packet should terminate at or before the next
comment|// chunk boundary.
if|if
condition|(
operator|!
name|alignedInPacket
operator|&&
name|len
operator|>
name|bytesPerChecksum
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected packet data length for "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|inAddr
operator|+
literal|": a partial chunk must be "
operator|+
literal|" sent in an individual packet (data length = "
operator|+
name|len
operator|+
literal|"> bytesPerChecksum = "
operator|+
name|bytesPerChecksum
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// If the last portion of the block file is not a full chunk,
comment|// then read in pre-existing partial data chunk and recalculate
comment|// the checksum so that the checksum calculation can continue
comment|// from the right state. If the client provided the checksum for
comment|// the whole chunk, this is not necessary.
name|Checksum
name|partialCrc
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|doCrcRecalc
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"receivePacket for "
operator|+
name|block
operator|+
literal|": previous write did not end at the chunk boundary."
operator|+
literal|" onDiskLen="
operator|+
name|onDiskLen
argument_list|)
expr_stmt|;
block|}
name|long
name|offsetInChecksum
init|=
name|BlockMetadataHeader
operator|.
name|getHeaderSize
argument_list|()
operator|+
name|onDiskLen
operator|/
name|bytesPerChecksum
operator|*
name|checksumSize
decl_stmt|;
name|partialCrc
operator|=
name|computePartialChunkCrc
argument_list|(
name|onDiskLen
argument_list|,
name|offsetInChecksum
argument_list|)
expr_stmt|;
block|}
comment|// The data buffer position where write will begin. If the packet
comment|// data and on-disk data have no overlap, this will not be at the
comment|// beginning of the buffer.
name|int
name|startByteToDisk
init|=
call|(
name|int
call|)
argument_list|(
name|onDiskLen
operator|-
name|firstByteInBlock
argument_list|)
operator|+
name|dataBuf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|dataBuf
operator|.
name|position
argument_list|()
decl_stmt|;
comment|// Actual number of data bytes to write.
name|int
name|numBytesToDisk
init|=
call|(
name|int
call|)
argument_list|(
name|offsetInBlock
operator|-
name|onDiskLen
argument_list|)
decl_stmt|;
comment|// Write data to disk.
name|long
name|begin
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|streams
operator|.
name|writeDataToDisk
argument_list|(
name|dataBuf
operator|.
name|array
argument_list|()
argument_list|,
name|startByteToDisk
argument_list|,
name|numBytesToDisk
argument_list|)
expr_stmt|;
name|long
name|duration
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|begin
decl_stmt|;
if|if
condition|(
name|duration
operator|>
name|maxWriteToDiskMs
condition|)
block|{
name|maxWriteToDiskMs
operator|=
name|duration
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|lastCrc
decl_stmt|;
if|if
condition|(
name|shouldNotWriteChecksum
condition|)
block|{
name|lastCrc
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|int
name|skip
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|crcBytes
init|=
literal|null
decl_stmt|;
comment|// First, prepare to overwrite the partial crc at the end.
if|if
condition|(
name|overwriteLastCrc
condition|)
block|{
comment|// not chunk-aligned on disk
comment|// prepare to overwrite last checksum
name|adjustCrcFilePosition
argument_list|()
expr_stmt|;
block|}
comment|// The CRC was recalculated for the last partial chunk. Update the
comment|// CRC by reading the rest of the chunk, then write it out.
if|if
condition|(
name|doCrcRecalc
condition|)
block|{
comment|// Calculate new crc for this chunk.
name|int
name|bytesToReadForRecalc
init|=
call|(
name|int
call|)
argument_list|(
name|bytesPerChecksum
operator|-
name|partialChunkSizeOnDisk
argument_list|)
decl_stmt|;
if|if
condition|(
name|numBytesToDisk
operator|<
name|bytesToReadForRecalc
condition|)
block|{
name|bytesToReadForRecalc
operator|=
name|numBytesToDisk
expr_stmt|;
block|}
name|partialCrc
operator|.
name|update
argument_list|(
name|dataBuf
operator|.
name|array
argument_list|()
argument_list|,
name|startByteToDisk
argument_list|,
name|bytesToReadForRecalc
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
name|FSOutputSummer
operator|.
name|convertToByteStream
argument_list|(
name|partialCrc
argument_list|,
name|checksumSize
argument_list|)
decl_stmt|;
name|crcBytes
operator|=
name|copyLastChunkChecksum
argument_list|(
name|buf
argument_list|,
name|checksumSize
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|checksumOut
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Writing out partial crc for data len "
operator|+
name|len
operator|+
literal|", skip="
operator|+
name|skip
argument_list|)
expr_stmt|;
block|}
name|skip
operator|++
expr_stmt|;
comment|//  For the partial chunk that was just read.
block|}
comment|// Determine how many checksums need to be skipped up to the last
comment|// boundary. The checksum after the boundary was already counted
comment|// above. Only count the number of checksums skipped up to the
comment|// boundary here.
name|long
name|skippedDataBytes
init|=
name|lastChunkBoundary
operator|-
name|firstByteInBlock
decl_stmt|;
if|if
condition|(
name|skippedDataBytes
operator|>
literal|0
condition|)
block|{
name|skip
operator|+=
call|(
name|int
call|)
argument_list|(
name|skippedDataBytes
operator|/
name|bytesPerChecksum
argument_list|)
operator|+
operator|(
operator|(
name|skippedDataBytes
operator|%
name|bytesPerChecksum
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
block|}
name|skip
operator|*=
name|checksumSize
expr_stmt|;
comment|// Convert to number of bytes
comment|// write the rest of checksum
specifier|final
name|int
name|offset
init|=
name|checksumBuf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|checksumBuf
operator|.
name|position
argument_list|()
operator|+
name|skip
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|checksumLen
operator|-
name|skip
decl_stmt|;
comment|// If offset>= end, there is no more checksum to write.
comment|// I.e. a partial chunk checksum rewrite happened and there is no
comment|// more to write after that.
if|if
condition|(
name|offset
operator|>=
name|end
operator|&&
name|doCrcRecalc
condition|)
block|{
name|lastCrc
operator|=
name|crcBytes
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|remainingBytes
init|=
name|checksumLen
operator|-
name|skip
decl_stmt|;
name|lastCrc
operator|=
name|copyLastChunkChecksum
argument_list|(
name|checksumBuf
operator|.
name|array
argument_list|()
argument_list|,
name|checksumSize
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|checksumOut
operator|.
name|write
argument_list|(
name|checksumBuf
operator|.
name|array
argument_list|()
argument_list|,
name|offset
argument_list|,
name|remainingBytes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// flush entire packet, sync if requested
name|flushOrSync
argument_list|(
name|syncBlock
argument_list|)
expr_stmt|;
name|replicaInfo
operator|.
name|setLastChecksumAndDataLen
argument_list|(
name|offsetInBlock
argument_list|,
name|lastCrc
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|incrBytesWritten
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|incrTotalWriteTime
argument_list|(
name|duration
argument_list|)
expr_stmt|;
name|manageWriterOsCache
argument_list|(
name|offsetInBlock
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{
name|datanode
operator|.
name|checkDiskErrorAsync
argument_list|()
expr_stmt|;
throw|throw
name|iex
throw|;
block|}
block|}
comment|// if sync was requested, put in queue for pending acks here
comment|// (after the fsync finished)
if|if
condition|(
name|responder
operator|!=
literal|null
operator|&&
operator|(
name|syncBlock
operator|||
name|shouldVerifyChecksum
argument_list|()
operator|)
condition|)
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|enqueue
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|,
name|Status
operator|.
name|SUCCESS
argument_list|)
expr_stmt|;
block|}
comment|/*      * Send in-progress responses for the replaceBlock() calls back to caller to      * avoid timeouts due to balancer throttling. HDFS-6247      */
if|if
condition|(
name|isReplaceBlock
operator|&&
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|lastResponseTime
operator|>
name|responseInterval
operator|)
condition|)
block|{
name|BlockOpResponseProto
operator|.
name|Builder
name|response
init|=
name|BlockOpResponseProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setStatus
argument_list|(
name|Status
operator|.
name|IN_PROGRESS
argument_list|)
decl_stmt|;
name|response
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|replyOut
argument_list|)
expr_stmt|;
name|replyOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|lastResponseTime
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|throttler
operator|!=
literal|null
condition|)
block|{
comment|// throttle I/O
name|throttler
operator|.
name|throttle
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|lastPacketInBlock
condition|?
operator|-
literal|1
else|:
name|len
return|;
block|}
comment|/**    * Only tracks the latency of sending packet to the last node in pipeline.    * This is a conscious design choice.    *<p>    * In the case of pipeline [dn0, dn1, dn2], 5ms latency from dn0 to dn1, 100ms    * from dn1 to dn2, NameNode claims dn2 is slow since it sees 100ms latency to    * dn2. Note that NameNode is not ware of pipeline structure in this context    * and only sees latency between two DataNodes.    *</p>    *<p>    * In another case of the same pipeline, 100ms latency from dn0 to dn1, 5ms    * from dn1 to dn2, NameNode will miss detecting dn1 being slow since it's not    * the last node. However the assumption is that in a busy enough cluster    * there are many other pipelines where dn1 is the last node, e.g. [dn3, dn4,    * dn1]. Also our tracking interval is relatively long enough (at least an    * hour) to improve the chances of the bad DataNodes being the last nodes in    * multiple pipelines.    *</p>    */
DECL|method|trackSendPacketToLastNodeInPipeline (final long elapsedMs)
specifier|private
name|void
name|trackSendPacketToLastNodeInPipeline
parameter_list|(
specifier|final
name|long
name|elapsedMs
parameter_list|)
block|{
if|if
condition|(
name|isPenultimateNode
operator|&&
name|mirrorAddr
operator|!=
literal|null
condition|)
block|{
name|datanode
operator|.
name|getPeerMetrics
argument_list|()
operator|.
name|addSendPacketDownstream
argument_list|(
name|bracketedMirrorAddr
argument_list|,
name|elapsedMs
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|copyLastChunkChecksum (byte[] array, int size, int end)
specifier|private
specifier|static
name|byte
index|[]
name|copyLastChunkChecksum
parameter_list|(
name|byte
index|[]
name|array
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|end
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|array
argument_list|,
name|end
operator|-
name|size
argument_list|,
name|end
argument_list|)
return|;
block|}
DECL|method|manageWriterOsCache (long offsetInBlock)
specifier|private
name|void
name|manageWriterOsCache
parameter_list|(
name|long
name|offsetInBlock
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|streams
operator|.
name|getOutFd
argument_list|()
operator|!=
literal|null
operator|&&
name|offsetInBlock
operator|>
name|lastCacheManagementOffset
operator|+
name|CACHE_DROP_LAG_BYTES
condition|)
block|{
name|long
name|begin
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|//
comment|// For SYNC_FILE_RANGE_WRITE, we want to sync from
comment|// lastCacheManagementOffset to a position "two windows ago"
comment|//
comment|//<========= sync ===========>
comment|// +-----------------------O--------------------------X
comment|// start                  last                      curPos
comment|// of file
comment|//
if|if
condition|(
name|syncBehindWrites
condition|)
block|{
if|if
condition|(
name|syncBehindWritesInBackground
condition|)
block|{
name|this
operator|.
name|datanode
operator|.
name|getFSDataset
argument_list|()
operator|.
name|submitBackgroundSyncFileRangeRequest
argument_list|(
name|block
argument_list|,
name|streams
argument_list|,
name|lastCacheManagementOffset
argument_list|,
name|offsetInBlock
operator|-
name|lastCacheManagementOffset
argument_list|,
name|SYNC_FILE_RANGE_WRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|streams
operator|.
name|syncFileRangeIfPossible
argument_list|(
name|lastCacheManagementOffset
argument_list|,
name|offsetInBlock
operator|-
name|lastCacheManagementOffset
argument_list|,
name|SYNC_FILE_RANGE_WRITE
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// For POSIX_FADV_DONTNEED, we want to drop from the beginning
comment|// of the file to a position prior to the current position.
comment|//
comment|//<=== drop =====>
comment|//<---W--->
comment|// +--------------+--------O--------------------------X
comment|// start        dropPos   last                      curPos
comment|// of file
comment|//
name|long
name|dropPos
init|=
name|lastCacheManagementOffset
operator|-
name|CACHE_DROP_LAG_BYTES
decl_stmt|;
if|if
condition|(
name|dropPos
operator|>
literal|0
operator|&&
name|dropCacheBehindWrites
condition|)
block|{
name|streams
operator|.
name|dropCacheBehindWrites
argument_list|(
name|block
operator|.
name|getBlockName
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dropPos
argument_list|,
name|POSIX_FADV_DONTNEED
argument_list|)
expr_stmt|;
block|}
name|lastCacheManagementOffset
operator|=
name|offsetInBlock
expr_stmt|;
name|long
name|duration
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|begin
decl_stmt|;
if|if
condition|(
name|duration
operator|>
name|datanodeSlowLogThresholdMs
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Slow manageWriterOsCache took "
operator|+
name|duration
operator|+
literal|"ms (threshold="
operator|+
name|datanodeSlowLogThresholdMs
operator|+
literal|"ms)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error managing cache for writer of block "
operator|+
name|block
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sendOOB ()
specifier|public
name|void
name|sendOOB
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|isDatanode
condition|)
block|{
return|return;
block|}
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|sendOOBResponse
argument_list|(
name|PipelineAck
operator|.
name|getRestartOOBStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|receiveBlock ( DataOutputStream mirrOut, DataInputStream mirrIn, DataOutputStream replyOut, String mirrAddr, DataTransferThrottler throttlerArg, DatanodeInfo[] downstreams, boolean isReplaceBlock)
name|void
name|receiveBlock
parameter_list|(
name|DataOutputStream
name|mirrOut
parameter_list|,
comment|// output to next datanode
name|DataInputStream
name|mirrIn
parameter_list|,
comment|// input from next datanode
name|DataOutputStream
name|replyOut
parameter_list|,
comment|// output to previous datanode
name|String
name|mirrAddr
parameter_list|,
name|DataTransferThrottler
name|throttlerArg
parameter_list|,
name|DatanodeInfo
index|[]
name|downstreams
parameter_list|,
name|boolean
name|isReplaceBlock
parameter_list|)
throws|throws
name|IOException
block|{
name|syncOnClose
operator|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|syncOnClose
expr_stmt|;
name|boolean
name|responderClosed
init|=
literal|false
decl_stmt|;
name|mirrorOut
operator|=
name|mirrOut
expr_stmt|;
name|mirrorAddr
operator|=
name|mirrAddr
expr_stmt|;
name|bracketedMirrorAddr
operator|=
literal|"["
operator|+
name|mirrAddr
operator|+
literal|"]"
expr_stmt|;
name|isPenultimateNode
operator|=
operator|(
operator|(
name|downstreams
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|downstreams
operator|.
name|length
operator|==
literal|1
operator|)
operator|)
expr_stmt|;
name|throttler
operator|=
name|throttlerArg
expr_stmt|;
name|this
operator|.
name|replyOut
operator|=
name|replyOut
expr_stmt|;
name|this
operator|.
name|isReplaceBlock
operator|=
name|isReplaceBlock
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isClient
operator|&&
operator|!
name|isTransfer
condition|)
block|{
name|responder
operator|=
operator|new
name|Daemon
argument_list|(
name|datanode
operator|.
name|threadGroup
argument_list|,
operator|new
name|PacketResponder
argument_list|(
name|replyOut
argument_list|,
name|mirrIn
argument_list|,
name|downstreams
argument_list|)
argument_list|)
expr_stmt|;
name|responder
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// start thread to processes responses
block|}
while|while
condition|(
name|receivePacket
argument_list|()
operator|>=
literal|0
condition|)
block|{
comment|/* Receive until the last packet */
block|}
comment|// wait for all outstanding packet responses. And then
comment|// indicate responder to gracefully shutdown.
comment|// Mark that responder has been closed for future processing
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|PacketResponder
operator|)
name|responder
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|responderClosed
operator|=
literal|true
expr_stmt|;
block|}
comment|// If this write is for a replication or transfer-RBW/Finalized,
comment|// then finalize block or convert temporary to RBW.
comment|// For client-writes, the block is finalized in the PacketResponder.
if|if
condition|(
name|isDatanode
operator|||
name|isTransfer
condition|)
block|{
comment|// Hold a volume reference to finalize block.
try|try
init|(
name|ReplicaHandler
name|handler
init|=
name|claimReplicaHandler
argument_list|()
init|)
block|{
comment|// close the block/crc files
name|close
argument_list|()
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_RBW
condition|)
block|{
comment|// for TRANSFER_RBW, convert temporary to RBW
name|datanode
operator|.
name|data
operator|.
name|convertTemporaryToRbw
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for isDatnode or TRANSFER_FINALIZED
comment|// Finalize the block.
name|datanode
operator|.
name|data
operator|.
name|finalizeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
name|datanode
operator|.
name|metrics
operator|.
name|incrBlocksWritten
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|replicaInfo
operator|.
name|releaseAllBytesReserved
argument_list|()
expr_stmt|;
if|if
condition|(
name|datanode
operator|.
name|isRestarting
argument_list|()
condition|)
block|{
comment|// Do not throw if shutting down for restart. Otherwise, it will cause
comment|// premature termination of responder.
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutting down for restart ("
operator|+
name|block
operator|+
literal|")."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception for "
operator|+
name|block
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
finally|finally
block|{
comment|// Clear the previous interrupt state of this thread.
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
comment|// If a shutdown for restart was initiated, upstream needs to be notified.
comment|// There is no need to do anything special if the responder was closed
comment|// normally.
if|if
condition|(
operator|!
name|responderClosed
condition|)
block|{
comment|// Data transfer was not complete.
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
comment|// In case this datanode is shutting down for quick restart,
comment|// send a special ack upstream.
if|if
condition|(
name|datanode
operator|.
name|isRestarting
argument_list|()
operator|&&
name|isClient
operator|&&
operator|!
name|isTransfer
condition|)
block|{
try|try
init|(
name|Writer
name|out
init|=
operator|new
name|OutputStreamWriter
argument_list|(
name|replicaInfo
operator|.
name|createRestartMetaStream
argument_list|()
argument_list|,
literal|"UTF-8"
argument_list|)
init|)
block|{
comment|// write out the current time.
name|out
operator|.
name|write
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|+
name|restartBudget
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// The worst case is not recovering this RBW replica.
comment|// Client will fall back to regular pipeline recovery.
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|streams
operator|.
name|getDataOut
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// Even if the connection is closed after the ack packet is
comment|// flushed, the client can react to the connection closure
comment|// first. Insert a delay to lower the chance of client
comment|// missing the OOB ack.
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// It is already going down. Ignore this.
block|}
block|}
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|cleanupBlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|responder
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// join() on the responder should timeout a bit earlier than the
comment|// configured deadline. Otherwise, the join() on this thread will
comment|// likely timeout as well.
name|long
name|joinTimeout
init|=
name|datanode
operator|.
name|getDnConf
argument_list|()
operator|.
name|getXceiverStopTimeout
argument_list|()
decl_stmt|;
name|joinTimeout
operator|=
name|joinTimeout
operator|>
literal|1
condition|?
name|joinTimeout
operator|*
literal|8
operator|/
literal|10
else|:
name|joinTimeout
expr_stmt|;
name|responder
operator|.
name|join
argument_list|(
name|joinTimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|responder
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|String
name|msg
init|=
literal|"Join on responder thread "
operator|+
name|responder
operator|+
literal|" timed out"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
operator|+
literal|"\n"
operator|+
name|StringUtils
operator|.
name|getStackTrace
argument_list|(
name|responder
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// do not throw if shutting down for restart.
if|if
condition|(
operator|!
name|datanode
operator|.
name|isRestarting
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted receiveBlock"
argument_list|)
throw|;
block|}
block|}
name|responder
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/** Cleanup a partial block     * if this write is for a replication request (and not from a client)    */
DECL|method|cleanupBlock ()
specifier|private
name|void
name|cleanupBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isDatanode
condition|)
block|{
name|datanode
operator|.
name|data
operator|.
name|unfinalizeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adjust the file pointer in the local meta file so that the last checksum    * will be overwritten.    */
DECL|method|adjustCrcFilePosition ()
specifier|private
name|void
name|adjustCrcFilePosition
parameter_list|()
throws|throws
name|IOException
block|{
name|streams
operator|.
name|flushDataOut
argument_list|()
expr_stmt|;
if|if
condition|(
name|checksumOut
operator|!=
literal|null
condition|)
block|{
name|checksumOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|// rollback the position of the meta file
name|datanode
operator|.
name|data
operator|.
name|adjustCrcChannelPosition
argument_list|(
name|block
argument_list|,
name|streams
argument_list|,
name|checksumSize
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convert a checksum byte array to a long    */
DECL|method|checksum2long (byte[] checksum)
specifier|static
specifier|private
name|long
name|checksum2long
parameter_list|(
name|byte
index|[]
name|checksum
parameter_list|)
block|{
name|long
name|crc
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|checksum
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator||=
operator|(
literal|0xffL
operator|&
name|checksum
index|[
name|i
index|]
operator|)
operator|<<
operator|(
operator|(
name|checksum
operator|.
name|length
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
block|}
return|return
name|crc
return|;
block|}
comment|/**    * reads in the partial crc chunk and computes checksum    * of pre-existing data in partial chunk.    */
DECL|method|computePartialChunkCrc (long blkoff, long ckoff)
specifier|private
name|Checksum
name|computePartialChunkCrc
parameter_list|(
name|long
name|blkoff
parameter_list|,
name|long
name|ckoff
parameter_list|)
throws|throws
name|IOException
block|{
comment|// find offset of the beginning of partial chunk.
comment|//
name|int
name|sizePartialChunk
init|=
call|(
name|int
call|)
argument_list|(
name|blkoff
operator|%
name|bytesPerChecksum
argument_list|)
decl_stmt|;
name|blkoff
operator|=
name|blkoff
operator|-
name|sizePartialChunk
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"computePartialChunkCrc for "
operator|+
name|block
operator|+
literal|": sizePartialChunk="
operator|+
name|sizePartialChunk
operator|+
literal|", block offset="
operator|+
name|blkoff
operator|+
literal|", metafile offset="
operator|+
name|ckoff
argument_list|)
expr_stmt|;
block|}
comment|// create an input stream from the block file
comment|// and read in partial crc chunk into temporary buffer
comment|//
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|sizePartialChunk
index|]
decl_stmt|;
name|byte
index|[]
name|crcbuf
init|=
operator|new
name|byte
index|[
name|checksumSize
index|]
decl_stmt|;
try|try
init|(
name|ReplicaInputStreams
name|instr
init|=
name|datanode
operator|.
name|data
operator|.
name|getTmpInputStreams
argument_list|(
name|block
argument_list|,
name|blkoff
argument_list|,
name|ckoff
argument_list|)
init|)
block|{
name|instr
operator|.
name|readDataFully
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|sizePartialChunk
argument_list|)
expr_stmt|;
comment|// open meta file and read in crc value computer earlier
name|instr
operator|.
name|readChecksumFully
argument_list|(
name|crcbuf
argument_list|,
literal|0
argument_list|,
name|crcbuf
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// compute crc of partial chunk from data read in the block file.
specifier|final
name|Checksum
name|partialCrc
init|=
name|DataChecksum
operator|.
name|newDataChecksum
argument_list|(
name|diskChecksum
operator|.
name|getChecksumType
argument_list|()
argument_list|,
name|diskChecksum
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
decl_stmt|;
name|partialCrc
operator|.
name|update
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|sizePartialChunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Read in partial CRC chunk from disk for "
operator|+
name|block
argument_list|)
expr_stmt|;
block|}
comment|// paranoia! verify that the pre-computed crc matches what we
comment|// recalculated just now
if|if
condition|(
name|partialCrc
operator|.
name|getValue
argument_list|()
operator|!=
name|checksum2long
argument_list|(
name|crcbuf
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Partial CRC "
operator|+
name|partialCrc
operator|.
name|getValue
argument_list|()
operator|+
literal|" does not match value computed the "
operator|+
literal|" last time file was closed "
operator|+
name|checksum2long
argument_list|(
name|crcbuf
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
return|return
name|partialCrc
return|;
block|}
comment|/** The caller claims the ownership of the replica handler. */
DECL|method|claimReplicaHandler ()
specifier|private
name|ReplicaHandler
name|claimReplicaHandler
parameter_list|()
block|{
name|ReplicaHandler
name|handler
init|=
name|replicaHandler
decl_stmt|;
name|replicaHandler
operator|=
literal|null
expr_stmt|;
return|return
name|handler
return|;
block|}
DECL|enum|PacketResponderType
specifier|private
specifier|static
enum|enum
name|PacketResponderType
block|{
DECL|enumConstant|NON_PIPELINE
DECL|enumConstant|LAST_IN_PIPELINE
DECL|enumConstant|HAS_DOWNSTREAM_IN_PIPELINE
name|NON_PIPELINE
block|,
name|LAST_IN_PIPELINE
block|,
name|HAS_DOWNSTREAM_IN_PIPELINE
block|}
comment|/**    * Processes responses from downstream datanodes in the pipeline    * and sends back replies to the originator.    */
DECL|class|PacketResponder
class|class
name|PacketResponder
implements|implements
name|Runnable
implements|,
name|Closeable
block|{
comment|/** queue for packets waiting for ack - synchronization using monitor lock */
DECL|field|ackQueue
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|Packet
argument_list|>
name|ackQueue
init|=
operator|new
name|LinkedList
argument_list|<
name|Packet
argument_list|>
argument_list|()
decl_stmt|;
comment|/** the thread that spawns this responder */
DECL|field|receiverThread
specifier|private
specifier|final
name|Thread
name|receiverThread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
comment|/** is this responder running? - synchronization using monitor lock */
DECL|field|running
specifier|private
specifier|volatile
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|/** input from the next downstream datanode */
DECL|field|downstreamIn
specifier|private
specifier|final
name|DataInputStream
name|downstreamIn
decl_stmt|;
comment|/** output to upstream datanode/client */
DECL|field|upstreamOut
specifier|private
specifier|final
name|DataOutputStream
name|upstreamOut
decl_stmt|;
comment|/** The type of this responder */
DECL|field|type
specifier|private
specifier|final
name|PacketResponderType
name|type
decl_stmt|;
comment|/** for log and error messages */
DECL|field|myString
specifier|private
specifier|final
name|String
name|myString
decl_stmt|;
DECL|field|sending
specifier|private
name|boolean
name|sending
init|=
literal|false
decl_stmt|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|myString
return|;
block|}
DECL|method|PacketResponder (final DataOutputStream upstreamOut, final DataInputStream downstreamIn, final DatanodeInfo[] downstreams)
name|PacketResponder
parameter_list|(
specifier|final
name|DataOutputStream
name|upstreamOut
parameter_list|,
specifier|final
name|DataInputStream
name|downstreamIn
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|downstreams
parameter_list|)
block|{
name|this
operator|.
name|downstreamIn
operator|=
name|downstreamIn
expr_stmt|;
name|this
operator|.
name|upstreamOut
operator|=
name|upstreamOut
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|downstreams
operator|==
literal|null
condition|?
name|PacketResponderType
operator|.
name|NON_PIPELINE
else|:
name|downstreams
operator|.
name|length
operator|==
literal|0
condition|?
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
else|:
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
expr_stmt|;
specifier|final
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
operator|.
name|append
argument_list|(
name|block
argument_list|)
operator|.
name|append
argument_list|(
literal|", type="
argument_list|)
operator|.
name|append
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|", downstreams="
argument_list|)
operator|.
name|append
argument_list|(
name|downstreams
operator|.
name|length
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|downstreams
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|myString
operator|=
name|b
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
DECL|method|isRunning ()
specifier|private
name|boolean
name|isRunning
parameter_list|()
block|{
comment|// When preparing for a restart, it should continue to run until
comment|// interrupted by the receiver thread.
return|return
name|running
operator|&&
operator|(
name|datanode
operator|.
name|shouldRun
operator|||
name|datanode
operator|.
name|isRestarting
argument_list|()
operator|)
return|;
block|}
comment|/**      * enqueue the seqno that is still be to acked by the downstream datanode.      * @param seqno sequence number of the packet      * @param lastPacketInBlock if true, this is the last packet in block      * @param offsetInBlock offset of this packet in block      */
DECL|method|enqueue (final long seqno, final boolean lastPacketInBlock, final long offsetInBlock, final Status ackStatus)
name|void
name|enqueue
parameter_list|(
specifier|final
name|long
name|seqno
parameter_list|,
specifier|final
name|boolean
name|lastPacketInBlock
parameter_list|,
specifier|final
name|long
name|offsetInBlock
parameter_list|,
specifier|final
name|Status
name|ackStatus
parameter_list|)
block|{
specifier|final
name|Packet
name|p
init|=
operator|new
name|Packet
argument_list|(
name|seqno
argument_list|,
name|lastPacketInBlock
argument_list|,
name|offsetInBlock
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|,
name|ackStatus
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|": enqueue "
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|ackQueue
init|)
block|{
if|if
condition|(
name|running
condition|)
block|{
name|ackQueue
operator|.
name|addLast
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ackQueue
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Send an OOB response. If all acks have been sent already for the block      * and the responder is about to close, the delivery is not guaranteed.      * This is because the other end can close the connection independently.      * An OOB coming from downstream will be automatically relayed upstream      * by the responder. This method is used only by originating datanode.      *      * @param ackStatus the type of ack to be sent      */
DECL|method|sendOOBResponse (final Status ackStatus)
name|void
name|sendOOBResponse
parameter_list|(
specifier|final
name|Status
name|ackStatus
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|running
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot send OOB response "
operator|+
name|ackStatus
operator|+
literal|". Responder not running."
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|sending
condition|)
block|{
name|wait
argument_list|(
name|datanode
operator|.
name|getOOBTimeout
argument_list|(
name|ackStatus
argument_list|)
argument_list|)
expr_stmt|;
comment|// Didn't get my turn in time. Give up.
if|if
condition|(
name|sending
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not send OOB reponse in time: "
operator|+
name|ackStatus
argument_list|)
throw|;
block|}
block|}
name|sending
operator|=
literal|true
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Sending an out of band ack of type "
operator|+
name|ackStatus
argument_list|)
expr_stmt|;
try|try
block|{
name|sendAckUpstreamUnprotected
argument_list|(
literal|null
argument_list|,
name|PipelineAck
operator|.
name|UNKOWN_SEQNO
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
name|PipelineAck
operator|.
name|combineHeader
argument_list|(
name|datanode
operator|.
name|getECN
argument_list|()
argument_list|,
name|ackStatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Let others send ack. Unless there are miltiple OOB send
comment|// calls, there can be only one waiter, the responder thread.
comment|// In any case, only one needs to be notified.
synchronized|synchronized
init|(
name|this
init|)
block|{
name|sending
operator|=
literal|false
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Wait for a packet with given {@code seqno} to be enqueued to ackQueue */
DECL|method|waitForAckHead (long seqno)
name|Packet
name|waitForAckHead
parameter_list|(
name|long
name|seqno
parameter_list|)
throws|throws
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|ackQueue
init|)
block|{
while|while
condition|(
name|isRunning
argument_list|()
operator|&&
name|ackQueue
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|": seqno="
operator|+
name|seqno
operator|+
literal|" waiting for local datanode to finish write."
argument_list|)
expr_stmt|;
block|}
name|ackQueue
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
return|return
name|isRunning
argument_list|()
condition|?
name|ackQueue
operator|.
name|getFirst
argument_list|()
else|:
literal|null
return|;
block|}
block|}
comment|/**      * wait for all pending packets to be acked. Then shutdown thread.      */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
synchronized|synchronized
init|(
name|ackQueue
init|)
block|{
while|while
condition|(
name|isRunning
argument_list|()
operator|&&
name|ackQueue
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
try|try
block|{
name|ackQueue
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|running
operator|=
literal|false
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|": closing"
argument_list|)
expr_stmt|;
block|}
name|running
operator|=
literal|false
expr_stmt|;
name|ackQueue
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|running
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Thread to process incoming acks.      * @see java.lang.Runnable#run()      */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|boolean
name|lastPacketInBlock
init|=
literal|false
decl_stmt|;
specifier|final
name|long
name|startTime
init|=
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|isRunning
argument_list|()
operator|&&
operator|!
name|lastPacketInBlock
condition|)
block|{
name|long
name|totalAckTimeNanos
init|=
literal|0
decl_stmt|;
name|boolean
name|isInterrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Packet
name|pkt
init|=
literal|null
decl_stmt|;
name|long
name|expected
init|=
operator|-
literal|2
decl_stmt|;
name|PipelineAck
name|ack
init|=
operator|new
name|PipelineAck
argument_list|()
decl_stmt|;
name|long
name|seqno
init|=
name|PipelineAck
operator|.
name|UNKOWN_SEQNO
decl_stmt|;
name|long
name|ackRecvNanoTime
init|=
literal|0
decl_stmt|;
try|try
block|{
if|if
condition|(
name|type
operator|!=
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
operator|&&
operator|!
name|mirrorError
condition|)
block|{
name|DataNodeFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|failPipeline
argument_list|(
name|replicaInfo
argument_list|,
name|mirrorAddr
argument_list|)
expr_stmt|;
comment|// read an ack from downstream datanode
name|ack
operator|.
name|readFields
argument_list|(
name|downstreamIn
argument_list|)
expr_stmt|;
name|ackRecvNanoTime
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|" got "
operator|+
name|ack
argument_list|)
expr_stmt|;
block|}
comment|// Process an OOB ACK.
name|Status
name|oobStatus
init|=
name|ack
operator|.
name|getOOBStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|oobStatus
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Relaying an out of band ack of type "
operator|+
name|oobStatus
argument_list|)
expr_stmt|;
name|sendAckUpstream
argument_list|(
name|ack
argument_list|,
name|PipelineAck
operator|.
name|UNKOWN_SEQNO
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
name|PipelineAck
operator|.
name|combineHeader
argument_list|(
name|datanode
operator|.
name|getECN
argument_list|()
argument_list|,
name|Status
operator|.
name|SUCCESS
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|seqno
operator|=
name|ack
operator|.
name|getSeqno
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|seqno
operator|!=
name|PipelineAck
operator|.
name|UNKOWN_SEQNO
operator|||
name|type
operator|==
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
condition|)
block|{
name|pkt
operator|=
name|waitForAckHead
argument_list|(
name|seqno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
break|break;
block|}
name|expected
operator|=
name|pkt
operator|.
name|seqno
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
operator|&&
name|seqno
operator|!=
name|expected
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|myString
operator|+
literal|"seqno: expected="
operator|+
name|expected
operator|+
literal|", received="
operator|+
name|seqno
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|==
name|PacketResponderType
operator|.
name|HAS_DOWNSTREAM_IN_PIPELINE
condition|)
block|{
comment|// The total ack time includes the ack times of downstream
comment|// nodes.
comment|// The value is 0 if this responder doesn't have a downstream
comment|// DN in the pipeline.
name|totalAckTimeNanos
operator|=
name|ackRecvNanoTime
operator|-
name|pkt
operator|.
name|ackEnqueueNanoTime
expr_stmt|;
comment|// Report the elapsed time from ack send to ack receive minus
comment|// the downstream ack time.
name|long
name|ackTimeNanos
init|=
name|totalAckTimeNanos
operator|-
name|ack
operator|.
name|getDownstreamAckTimeNanos
argument_list|()
decl_stmt|;
if|if
condition|(
name|ackTimeNanos
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Calculated invalid ack time: "
operator|+
name|ackTimeNanos
operator|+
literal|"ns."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|datanode
operator|.
name|metrics
operator|.
name|addPacketAckRoundTripTimeNanos
argument_list|(
name|ackTimeNanos
argument_list|)
expr_stmt|;
block|}
block|}
name|lastPacketInBlock
operator|=
name|pkt
operator|.
name|lastPacketInBlock
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ine
parameter_list|)
block|{
name|isInterrupted
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|isInterrupted
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioe
operator|instanceof
name|EOFException
operator|&&
operator|!
name|packetSentInTime
argument_list|()
condition|)
block|{
comment|// The downstream error was caused by upstream including this
comment|// node not sending packet in time. Let the upstream determine
comment|// who is at fault.  If the immediate upstream node thinks it
comment|// has sent a packet in time, this node will be reported as bad.
comment|// Otherwise, the upstream node will propagate the error up by
comment|// closing the connection.
name|LOG
operator|.
name|warn
argument_list|(
literal|"The downstream error might be due to congestion in "
operator|+
literal|"upstream including this node. Propagating the error: "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
else|else
block|{
comment|// continue to run even if can not read from mirror
comment|// notify client of the error
comment|// and wait for the client to shut down the pipeline
name|mirrorError
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|myString
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
operator|||
name|isInterrupted
condition|)
block|{
comment|/*              * The receiver thread cancelled this thread. We could also check              * any other status updates from the receiver thread (e.g. if it is              * ok to write to replyOut). It is prudent to not send any more              * status back to the client because this datanode has a problem.              * The upstream datanode will detect that this datanode is bad, and              * rightly so.              *              * The receiver thread can also interrupt this thread for sending              * an out-of-band response upstream.              */
name|LOG
operator|.
name|info
argument_list|(
name|myString
operator|+
literal|": Thread is interrupted."
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lastPacketInBlock
condition|)
block|{
comment|// Finalize the block and close the block file
name|finalizeBlock
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
block|}
name|Status
name|myStatus
init|=
name|pkt
operator|!=
literal|null
condition|?
name|pkt
operator|.
name|ackStatus
else|:
name|Status
operator|.
name|SUCCESS
decl_stmt|;
name|sendAckUpstream
argument_list|(
name|ack
argument_list|,
name|expected
argument_list|,
name|totalAckTimeNanos
argument_list|,
operator|(
name|pkt
operator|!=
literal|null
condition|?
name|pkt
operator|.
name|offsetInBlock
else|:
literal|0
operator|)
argument_list|,
name|PipelineAck
operator|.
name|combineHeader
argument_list|(
name|datanode
operator|.
name|getECN
argument_list|()
argument_list|,
name|myStatus
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
operator|!=
literal|null
condition|)
block|{
comment|// remove the packet from the ack queue
name|removeAckHead
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IOException in BlockReceiver.run(): "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|running
condition|)
block|{
name|datanode
operator|.
name|checkDiskErrorAsync
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|myString
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
comment|// failure not caused by interruption
name|receiverThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|myString
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
name|receiverThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|myString
operator|+
literal|" terminating"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Finalize the block and close the block file      * @param startTime time when BlockReceiver started receiving the block      */
DECL|method|finalizeBlock (long startTime)
specifier|private
name|void
name|finalizeBlock
parameter_list|(
name|long
name|startTime
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|endTime
init|=
literal|0
decl_stmt|;
comment|// Hold a volume reference to finalize block.
try|try
init|(
name|ReplicaHandler
name|handler
init|=
name|BlockReceiver
operator|.
name|this
operator|.
name|claimReplicaHandler
argument_list|()
init|)
block|{
name|BlockReceiver
operator|.
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
name|endTime
operator|=
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|replicaInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|data
operator|.
name|finalizeBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pinning
condition|)
block|{
name|datanode
operator|.
name|data
operator|.
name|setPinning
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
name|datanode
operator|.
name|closeBlock
argument_list|(
name|block
argument_list|,
literal|null
argument_list|,
name|replicaInfo
operator|.
name|getStorageUuid
argument_list|()
argument_list|,
name|replicaInfo
operator|.
name|isOnTransientStorage
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
operator|&&
name|isClient
condition|)
block|{
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|DatanodeRegistration
name|dnR
init|=
name|datanode
operator|.
name|getDNRegistrationForBP
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|ClientTraceLog
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|DN_CLIENTTRACE_FORMAT
argument_list|,
name|inAddr
argument_list|,
name|myAddr
argument_list|,
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|"HDFS_WRITE"
argument_list|,
name|clientname
argument_list|,
name|offset
argument_list|,
name|dnR
operator|.
name|getDatanodeUuid
argument_list|()
argument_list|,
name|block
argument_list|,
name|endTime
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received "
operator|+
name|block
operator|+
literal|" size "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|" from "
operator|+
name|inAddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * The wrapper for the unprotected version. This is only called by      * the responder's run() method.      *      * @param ack Ack received from downstream      * @param seqno sequence number of ack to be sent upstream      * @param totalAckTimeNanos total ack time including all the downstream      *          nodes      * @param offsetInBlock offset in block for the data in packet      * @param myHeader the local ack header      */
DECL|method|sendAckUpstream (PipelineAck ack, long seqno, long totalAckTimeNanos, long offsetInBlock, int myHeader)
specifier|private
name|void
name|sendAckUpstream
parameter_list|(
name|PipelineAck
name|ack
parameter_list|,
name|long
name|seqno
parameter_list|,
name|long
name|totalAckTimeNanos
parameter_list|,
name|long
name|offsetInBlock
parameter_list|,
name|int
name|myHeader
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// Wait for other sender to finish. Unless there is an OOB being sent,
comment|// the responder won't have to wait.
synchronized|synchronized
init|(
name|this
init|)
block|{
while|while
condition|(
name|sending
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
name|sending
operator|=
literal|true
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|running
condition|)
return|return;
name|sendAckUpstreamUnprotected
argument_list|(
name|ack
argument_list|,
name|seqno
argument_list|,
name|totalAckTimeNanos
argument_list|,
name|offsetInBlock
argument_list|,
name|myHeader
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|sending
operator|=
literal|false
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// The responder was interrupted. Make it go down without
comment|// interrupting the receiver(writer) thread.
name|running
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**      * @param ack Ack received from downstream      * @param seqno sequence number of ack to be sent upstream      * @param totalAckTimeNanos total ack time including all the downstream      *          nodes      * @param offsetInBlock offset in block for the data in packet      * @param myHeader the local ack header      */
DECL|method|sendAckUpstreamUnprotected (PipelineAck ack, long seqno, long totalAckTimeNanos, long offsetInBlock, int myHeader)
specifier|private
name|void
name|sendAckUpstreamUnprotected
parameter_list|(
name|PipelineAck
name|ack
parameter_list|,
name|long
name|seqno
parameter_list|,
name|long
name|totalAckTimeNanos
parameter_list|,
name|long
name|offsetInBlock
parameter_list|,
name|int
name|myHeader
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
index|[]
name|replies
decl_stmt|;
if|if
condition|(
name|ack
operator|==
literal|null
condition|)
block|{
comment|// A new OOB response is being sent from this node. Regardless of
comment|// downstream nodes, reply should contain one reply.
name|replies
operator|=
operator|new
name|int
index|[]
block|{
name|myHeader
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mirrorError
condition|)
block|{
comment|// ack read error
name|int
name|h
init|=
name|PipelineAck
operator|.
name|combineHeader
argument_list|(
name|datanode
operator|.
name|getECN
argument_list|()
argument_list|,
name|Status
operator|.
name|SUCCESS
argument_list|)
decl_stmt|;
name|int
name|h1
init|=
name|PipelineAck
operator|.
name|combineHeader
argument_list|(
name|datanode
operator|.
name|getECN
argument_list|()
argument_list|,
name|Status
operator|.
name|ERROR
argument_list|)
decl_stmt|;
name|replies
operator|=
operator|new
name|int
index|[]
block|{
name|h
block|,
name|h1
block|}
expr_stmt|;
block|}
else|else
block|{
name|short
name|ackLen
init|=
name|type
operator|==
name|PacketResponderType
operator|.
name|LAST_IN_PIPELINE
condition|?
literal|0
else|:
name|ack
operator|.
name|getNumOfReplies
argument_list|()
decl_stmt|;
name|replies
operator|=
operator|new
name|int
index|[
name|ackLen
operator|+
literal|1
index|]
expr_stmt|;
name|replies
index|[
literal|0
index|]
operator|=
name|myHeader
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ackLen
condition|;
operator|++
name|i
control|)
block|{
name|replies
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|ack
operator|.
name|getHeaderFlag
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|// If the mirror has reported that it received a corrupt packet,
comment|// do self-destruct to mark myself bad, instead of making the
comment|// mirror node bad. The mirror is guaranteed to be good without
comment|// corrupt data on disk.
if|if
condition|(
name|ackLen
operator|>
literal|0
operator|&&
name|PipelineAck
operator|.
name|getStatusFromHeader
argument_list|(
name|replies
index|[
literal|1
index|]
argument_list|)
operator|==
name|Status
operator|.
name|ERROR_CHECKSUM
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Shutting down writer and responder "
operator|+
literal|"since the down streams reported the data sent by this "
operator|+
literal|"thread is corrupt"
argument_list|)
throw|;
block|}
block|}
name|PipelineAck
name|replyAck
init|=
operator|new
name|PipelineAck
argument_list|(
name|seqno
argument_list|,
name|replies
argument_list|,
name|totalAckTimeNanos
argument_list|)
decl_stmt|;
if|if
condition|(
name|replyAck
operator|.
name|isSuccess
argument_list|()
operator|&&
name|offsetInBlock
operator|>
name|replicaInfo
operator|.
name|getBytesAcked
argument_list|()
condition|)
block|{
name|replicaInfo
operator|.
name|setBytesAcked
argument_list|(
name|offsetInBlock
argument_list|)
expr_stmt|;
block|}
comment|// send my ack back to upstream datanode
name|long
name|begin
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|/* for test only, no-op in production system */
name|DataNodeFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|delaySendingAckToUpstream
argument_list|(
name|inAddr
argument_list|)
expr_stmt|;
name|replyAck
operator|.
name|write
argument_list|(
name|upstreamOut
argument_list|)
expr_stmt|;
name|upstreamOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|long
name|duration
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|begin
decl_stmt|;
name|DataNodeFaultInjector
operator|.
name|get
argument_list|()
operator|.
name|logDelaySendingAckToUpstream
argument_list|(
name|inAddr
argument_list|,
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|duration
operator|>
name|datanodeSlowLogThresholdMs
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Slow PacketResponder send ack to upstream took "
operator|+
name|duration
operator|+
literal|"ms (threshold="
operator|+
name|datanodeSlowLogThresholdMs
operator|+
literal|"ms), "
operator|+
name|myString
operator|+
literal|", replyAck="
operator|+
name|replyAck
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|myString
operator|+
literal|", replyAck="
operator|+
name|replyAck
argument_list|)
expr_stmt|;
block|}
comment|// If a corruption was detected in the received data, terminate after
comment|// sending ERROR_CHECKSUM back.
name|Status
name|myStatus
init|=
name|PipelineAck
operator|.
name|getStatusFromHeader
argument_list|(
name|myHeader
argument_list|)
decl_stmt|;
if|if
condition|(
name|myStatus
operator|==
name|Status
operator|.
name|ERROR_CHECKSUM
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Shutting down writer and responder "
operator|+
literal|"due to a checksum error in received data. The error "
operator|+
literal|"response has been sent upstream."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Remove a packet from the head of the ack queue      *       * This should be called only when the ack queue is not empty      */
DECL|method|removeAckHead ()
specifier|private
name|void
name|removeAckHead
parameter_list|()
block|{
synchronized|synchronized
init|(
name|ackQueue
init|)
block|{
name|ackQueue
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|ackQueue
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * This information is cached by the Datanode in the ackQueue.    */
DECL|class|Packet
specifier|private
specifier|static
class|class
name|Packet
block|{
DECL|field|seqno
specifier|final
name|long
name|seqno
decl_stmt|;
DECL|field|lastPacketInBlock
specifier|final
name|boolean
name|lastPacketInBlock
decl_stmt|;
DECL|field|offsetInBlock
specifier|final
name|long
name|offsetInBlock
decl_stmt|;
DECL|field|ackEnqueueNanoTime
specifier|final
name|long
name|ackEnqueueNanoTime
decl_stmt|;
DECL|field|ackStatus
specifier|final
name|Status
name|ackStatus
decl_stmt|;
DECL|method|Packet (long seqno, boolean lastPacketInBlock, long offsetInBlock, long ackEnqueueNanoTime, Status ackStatus)
name|Packet
parameter_list|(
name|long
name|seqno
parameter_list|,
name|boolean
name|lastPacketInBlock
parameter_list|,
name|long
name|offsetInBlock
parameter_list|,
name|long
name|ackEnqueueNanoTime
parameter_list|,
name|Status
name|ackStatus
parameter_list|)
block|{
name|this
operator|.
name|seqno
operator|=
name|seqno
expr_stmt|;
name|this
operator|.
name|lastPacketInBlock
operator|=
name|lastPacketInBlock
expr_stmt|;
name|this
operator|.
name|offsetInBlock
operator|=
name|offsetInBlock
expr_stmt|;
name|this
operator|.
name|ackEnqueueNanoTime
operator|=
name|ackEnqueueNanoTime
expr_stmt|;
name|this
operator|.
name|ackStatus
operator|=
name|ackStatus
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(seqno="
operator|+
name|seqno
operator|+
literal|", lastPacketInBlock="
operator|+
name|lastPacketInBlock
operator|+
literal|", offsetInBlock="
operator|+
name|offsetInBlock
operator|+
literal|", ackEnqueueNanoTime="
operator|+
name|ackEnqueueNanoTime
operator|+
literal|", ackStatus="
operator|+
name|ackStatus
operator|+
literal|")"
return|;
block|}
block|}
block|}
end_class

end_unit

