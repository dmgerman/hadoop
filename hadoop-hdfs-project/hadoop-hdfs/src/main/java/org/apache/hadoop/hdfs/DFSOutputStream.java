begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
operator|.
name|CryptoProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanSetDropBehind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSOutputSummer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileEncryptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ParentNotDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Syncable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|client
operator|.
name|HdfsDataOutputStream
operator|.
name|SyncFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DSQuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|NSQuotaExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|SnapshotAccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnresolvedPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|PacketHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|CachingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|RetryStartFileException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|SafeModeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|util
operator|.
name|ByteArrayManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|EnumSetWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Sampler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/****************************************************************  * DFSOutputStream creates files from a stream of bytes.  *  * The client application writes data that is cached internally by  * this stream. Data is broken up into packets, each packet is  * typically 64K in size. A packet comprises of chunks. Each chunk  * is typically 512 bytes and has an associated checksum with it.  *  * When a client application fills up the currentPacket, it is  * enqueued into the dataQueue of DataStreamer. DataStreamer is a  * thread that picks up packets from the dataQueue and sends it to  * the first datanode in the pipeline.  *  ****************************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|DFSOutputStream
specifier|public
class|class
name|DFSOutputStream
extends|extends
name|FSOutputSummer
implements|implements
name|Syncable
implements|,
name|CanSetDropBehind
block|{
comment|/**    * Number of times to retry creating a file when there are transient     * errors (typically related to encryption zones and KeyProvider operations).    */
annotation|@
name|VisibleForTesting
DECL|field|CREATE_RETRY_COUNT
specifier|static
specifier|final
name|int
name|CREATE_RETRY_COUNT
init|=
literal|10
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|SUPPORTED_CRYPTO_VERSIONS
specifier|static
name|CryptoProtocolVersion
index|[]
name|SUPPORTED_CRYPTO_VERSIONS
init|=
name|CryptoProtocolVersion
operator|.
name|supported
argument_list|()
decl_stmt|;
DECL|field|dfsClient
specifier|protected
specifier|final
name|DFSClient
name|dfsClient
decl_stmt|;
DECL|field|byteArrayManager
specifier|protected
specifier|final
name|ByteArrayManager
name|byteArrayManager
decl_stmt|;
comment|// closed is accessed by different threads under different locks.
DECL|field|closed
specifier|protected
specifier|volatile
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
DECL|field|src
specifier|protected
specifier|final
name|String
name|src
decl_stmt|;
DECL|field|fileId
specifier|protected
specifier|final
name|long
name|fileId
decl_stmt|;
DECL|field|blockSize
specifier|protected
specifier|final
name|long
name|blockSize
decl_stmt|;
DECL|field|bytesPerChecksum
specifier|protected
specifier|final
name|int
name|bytesPerChecksum
decl_stmt|;
DECL|field|currentPacket
specifier|protected
name|DFSPacket
name|currentPacket
init|=
literal|null
decl_stmt|;
DECL|field|streamer
specifier|protected
name|DataStreamer
name|streamer
decl_stmt|;
DECL|field|packetSize
specifier|protected
name|int
name|packetSize
init|=
literal|0
decl_stmt|;
comment|// write packet size, not including the header.
DECL|field|chunksPerPacket
specifier|protected
name|int
name|chunksPerPacket
init|=
literal|0
decl_stmt|;
DECL|field|lastFlushOffset
specifier|protected
name|long
name|lastFlushOffset
init|=
literal|0
decl_stmt|;
comment|// offset when flush was invoked
DECL|field|initialFileSize
specifier|private
name|long
name|initialFileSize
init|=
literal|0
decl_stmt|;
comment|// at time of file open
DECL|field|blockReplication
specifier|private
specifier|final
name|short
name|blockReplication
decl_stmt|;
comment|// replication factor of file
DECL|field|shouldSyncBlock
specifier|protected
name|boolean
name|shouldSyncBlock
init|=
literal|false
decl_stmt|;
comment|// force blocks to disk upon close
DECL|field|cachingStrategy
specifier|protected
specifier|final
name|AtomicReference
argument_list|<
name|CachingStrategy
argument_list|>
name|cachingStrategy
decl_stmt|;
DECL|field|fileEncryptionInfo
specifier|private
name|FileEncryptionInfo
name|fileEncryptionInfo
decl_stmt|;
comment|/** Use {@link ByteArrayManager} to create buffer for non-heartbeat packets.*/
DECL|method|createPacket (int packetSize, int chunksPerPkt, long offsetInBlock, long seqno, boolean lastPacketInBlock)
specifier|protected
name|DFSPacket
name|createPacket
parameter_list|(
name|int
name|packetSize
parameter_list|,
name|int
name|chunksPerPkt
parameter_list|,
name|long
name|offsetInBlock
parameter_list|,
name|long
name|seqno
parameter_list|,
name|boolean
name|lastPacketInBlock
parameter_list|)
throws|throws
name|InterruptedIOException
block|{
specifier|final
name|byte
index|[]
name|buf
decl_stmt|;
specifier|final
name|int
name|bufferSize
init|=
name|PacketHeader
operator|.
name|PKT_MAX_HEADER_LEN
operator|+
name|packetSize
decl_stmt|;
try|try
block|{
name|buf
operator|=
name|byteArrayManager
operator|.
name|newByteArray
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
specifier|final
name|InterruptedIOException
name|iioe
init|=
operator|new
name|InterruptedIOException
argument_list|(
literal|"seqno="
operator|+
name|seqno
argument_list|)
decl_stmt|;
name|iioe
operator|.
name|initCause
argument_list|(
name|ie
argument_list|)
expr_stmt|;
throw|throw
name|iioe
throw|;
block|}
return|return
operator|new
name|DFSPacket
argument_list|(
name|buf
argument_list|,
name|chunksPerPkt
argument_list|,
name|offsetInBlock
argument_list|,
name|seqno
argument_list|,
name|getChecksumSize
argument_list|()
argument_list|,
name|lastPacketInBlock
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|checkClosed ()
specifier|protected
name|void
name|checkClosed
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
name|IOException
name|e
init|=
name|streamer
operator|.
name|getLastException
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
throw|throw
name|e
operator|!=
literal|null
condition|?
name|e
else|:
operator|new
name|ClosedChannelException
argument_list|()
throw|;
block|}
block|}
comment|//
comment|// returns the list of targets, if any, that is being currently used.
comment|//
annotation|@
name|VisibleForTesting
DECL|method|getPipeline ()
specifier|public
specifier|synchronized
name|DatanodeInfo
index|[]
name|getPipeline
parameter_list|()
block|{
if|if
condition|(
name|streamer
operator|.
name|streamerClosed
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|DatanodeInfo
index|[]
name|currentNodes
init|=
name|streamer
operator|.
name|getNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentNodes
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|DatanodeInfo
index|[]
name|value
init|=
operator|new
name|DatanodeInfo
index|[
name|currentNodes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentNodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|value
index|[
name|i
index|]
operator|=
name|currentNodes
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/**     * @return the object for computing checksum.    *         The type is NULL if checksum is not computed.    */
DECL|method|getChecksum4Compute (DataChecksum checksum, HdfsFileStatus stat)
specifier|private
specifier|static
name|DataChecksum
name|getChecksum4Compute
parameter_list|(
name|DataChecksum
name|checksum
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|)
block|{
if|if
condition|(
name|DataStreamer
operator|.
name|isLazyPersist
argument_list|(
name|stat
argument_list|)
operator|&&
name|stat
operator|.
name|getReplication
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// do not compute checksum for writing to single replica to memory
return|return
name|DataChecksum
operator|.
name|newDataChecksum
argument_list|(
name|Type
operator|.
name|NULL
argument_list|,
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
return|;
block|}
return|return
name|checksum
return|;
block|}
DECL|method|DFSOutputStream (DFSClient dfsClient, String src, Progressable progress, HdfsFileStatus stat, DataChecksum checksum)
specifier|private
name|DFSOutputStream
parameter_list|(
name|DFSClient
name|dfsClient
parameter_list|,
name|String
name|src
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|,
name|DataChecksum
name|checksum
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|getChecksum4Compute
argument_list|(
name|checksum
argument_list|,
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|dfsClient
operator|=
name|dfsClient
expr_stmt|;
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fileId
operator|=
name|stat
operator|.
name|getFileId
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockSize
operator|=
name|stat
operator|.
name|getBlockSize
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockReplication
operator|=
name|stat
operator|.
name|getReplication
argument_list|()
expr_stmt|;
name|this
operator|.
name|fileEncryptionInfo
operator|=
name|stat
operator|.
name|getFileEncryptionInfo
argument_list|()
expr_stmt|;
name|this
operator|.
name|cachingStrategy
operator|=
operator|new
name|AtomicReference
argument_list|<
name|CachingStrategy
argument_list|>
argument_list|(
name|dfsClient
operator|.
name|getDefaultWriteCachingStrategy
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|progress
operator|!=
literal|null
operator|)
operator|&&
name|DFSClient
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Set non-null progress callback on DFSOutputStream "
operator|+
name|src
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|bytesPerChecksum
operator|=
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
expr_stmt|;
if|if
condition|(
name|bytesPerChecksum
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Invalid value: bytesPerChecksum = "
operator|+
name|bytesPerChecksum
operator|+
literal|"<= 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|blockSize
operator|%
name|bytesPerChecksum
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Invalid values: "
operator|+
name|DFSConfigKeys
operator|.
name|DFS_BYTES_PER_CHECKSUM_KEY
operator|+
literal|" (="
operator|+
name|bytesPerChecksum
operator|+
literal|") must divide block size (="
operator|+
name|blockSize
operator|+
literal|")."
argument_list|)
throw|;
block|}
name|this
operator|.
name|byteArrayManager
operator|=
name|dfsClient
operator|.
name|getClientContext
argument_list|()
operator|.
name|getByteArrayManager
argument_list|()
expr_stmt|;
block|}
comment|/** Construct a new output stream for creating a file. */
DECL|method|DFSOutputStream (DFSClient dfsClient, String src, HdfsFileStatus stat, EnumSet<CreateFlag> flag, Progressable progress, DataChecksum checksum, String[] favoredNodes)
specifier|protected
name|DFSOutputStream
parameter_list|(
name|DFSClient
name|dfsClient
parameter_list|,
name|String
name|src
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|DataChecksum
name|checksum
parameter_list|,
name|String
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|dfsClient
argument_list|,
name|src
argument_list|,
name|progress
argument_list|,
name|stat
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|this
operator|.
name|shouldSyncBlock
operator|=
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|SYNC_BLOCK
argument_list|)
expr_stmt|;
name|computePacketChunkSize
argument_list|(
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|writePacketSize
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
name|streamer
operator|=
operator|new
name|DataStreamer
argument_list|(
name|stat
argument_list|,
literal|null
argument_list|,
name|dfsClient
argument_list|,
name|src
argument_list|,
name|progress
argument_list|,
name|checksum
argument_list|,
name|cachingStrategy
argument_list|,
name|byteArrayManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|favoredNodes
operator|!=
literal|null
operator|&&
name|favoredNodes
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|streamer
operator|.
name|setFavoredNodes
argument_list|(
name|favoredNodes
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|newStreamForCreate (DFSClient dfsClient, String src, FsPermission masked, EnumSet<CreateFlag> flag, boolean createParent, short replication, long blockSize, Progressable progress, int buffersize, DataChecksum checksum, String[] favoredNodes)
specifier|static
name|DFSOutputStream
name|newStreamForCreate
parameter_list|(
name|DFSClient
name|dfsClient
parameter_list|,
name|String
name|src
parameter_list|,
name|FsPermission
name|masked
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|DataChecksum
name|checksum
parameter_list|,
name|String
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|dfsClient
operator|.
name|getPathTraceScope
argument_list|(
literal|"newStreamForCreate"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|HdfsFileStatus
name|stat
init|=
literal|null
decl_stmt|;
comment|// Retry the create if we get a RetryStartFileException up to a maximum
comment|// number of times
name|boolean
name|shouldRetry
init|=
literal|true
decl_stmt|;
name|int
name|retryCount
init|=
name|CREATE_RETRY_COUNT
decl_stmt|;
while|while
condition|(
name|shouldRetry
condition|)
block|{
name|shouldRetry
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|stat
operator|=
name|dfsClient
operator|.
name|namenode
operator|.
name|create
argument_list|(
name|src
argument_list|,
name|masked
argument_list|,
name|dfsClient
operator|.
name|clientName
argument_list|,
operator|new
name|EnumSetWritable
argument_list|<
name|CreateFlag
argument_list|>
argument_list|(
name|flag
argument_list|)
argument_list|,
name|createParent
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|SUPPORTED_CRYPTO_VERSIONS
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
name|IOException
name|e
init|=
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|AccessControlException
operator|.
name|class
argument_list|,
name|DSQuotaExceededException
operator|.
name|class
argument_list|,
name|FileAlreadyExistsException
operator|.
name|class
argument_list|,
name|FileNotFoundException
operator|.
name|class
argument_list|,
name|ParentNotDirectoryException
operator|.
name|class
argument_list|,
name|NSQuotaExceededException
operator|.
name|class
argument_list|,
name|RetryStartFileException
operator|.
name|class
argument_list|,
name|SafeModeException
operator|.
name|class
argument_list|,
name|UnresolvedPathException
operator|.
name|class
argument_list|,
name|SnapshotAccessControlException
operator|.
name|class
argument_list|,
name|UnknownCryptoProtocolVersionException
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RetryStartFileException
condition|)
block|{
if|if
condition|(
name|retryCount
operator|>
literal|0
condition|)
block|{
name|shouldRetry
operator|=
literal|true
expr_stmt|;
name|retryCount
operator|--
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Too many retries because of encryption"
operator|+
literal|" zone operations"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|stat
argument_list|,
literal|"HdfsFileStatus should not be null!"
argument_list|)
expr_stmt|;
specifier|final
name|DFSOutputStream
name|out
init|=
operator|new
name|DFSOutputStream
argument_list|(
name|dfsClient
argument_list|,
name|src
argument_list|,
name|stat
argument_list|,
name|flag
argument_list|,
name|progress
argument_list|,
name|checksum
argument_list|,
name|favoredNodes
argument_list|)
decl_stmt|;
name|out
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|out
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Construct a new output stream for append. */
DECL|method|DFSOutputStream (DFSClient dfsClient, String src, EnumSet<CreateFlag> flags, Progressable progress, LocatedBlock lastBlock, HdfsFileStatus stat, DataChecksum checksum)
specifier|private
name|DFSOutputStream
parameter_list|(
name|DFSClient
name|dfsClient
parameter_list|,
name|String
name|src
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flags
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|LocatedBlock
name|lastBlock
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|,
name|DataChecksum
name|checksum
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|dfsClient
argument_list|,
name|src
argument_list|,
name|progress
argument_list|,
name|stat
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|initialFileSize
operator|=
name|stat
operator|.
name|getLen
argument_list|()
expr_stmt|;
comment|// length of file when opened
name|this
operator|.
name|shouldSyncBlock
operator|=
name|flags
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|SYNC_BLOCK
argument_list|)
expr_stmt|;
name|boolean
name|toNewBlock
init|=
name|flags
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|NEW_BLOCK
argument_list|)
decl_stmt|;
name|this
operator|.
name|fileEncryptionInfo
operator|=
name|stat
operator|.
name|getFileEncryptionInfo
argument_list|()
expr_stmt|;
comment|// The last partial block of the file has to be filled.
if|if
condition|(
operator|!
name|toNewBlock
operator|&&
name|lastBlock
operator|!=
literal|null
condition|)
block|{
comment|// indicate that we are appending to an existing block
name|streamer
operator|=
operator|new
name|DataStreamer
argument_list|(
name|lastBlock
argument_list|,
name|stat
argument_list|,
name|dfsClient
argument_list|,
name|src
argument_list|,
name|progress
argument_list|,
name|checksum
argument_list|,
name|cachingStrategy
argument_list|,
name|byteArrayManager
argument_list|)
expr_stmt|;
name|streamer
operator|.
name|setBytesCurBlock
argument_list|(
name|lastBlock
operator|.
name|getBlockSize
argument_list|()
argument_list|)
expr_stmt|;
name|adjustPacketChunkSize
argument_list|(
name|stat
argument_list|)
expr_stmt|;
name|streamer
operator|.
name|setPipelineInConstruction
argument_list|(
name|lastBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|computePacketChunkSize
argument_list|(
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|writePacketSize
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
name|streamer
operator|=
operator|new
name|DataStreamer
argument_list|(
name|stat
argument_list|,
name|lastBlock
operator|!=
literal|null
condition|?
name|lastBlock
operator|.
name|getBlock
argument_list|()
else|:
literal|null
argument_list|,
name|dfsClient
argument_list|,
name|src
argument_list|,
name|progress
argument_list|,
name|checksum
argument_list|,
name|cachingStrategy
argument_list|,
name|byteArrayManager
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|adjustPacketChunkSize (HdfsFileStatus stat)
specifier|private
name|void
name|adjustPacketChunkSize
parameter_list|(
name|HdfsFileStatus
name|stat
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|usedInLastBlock
init|=
name|stat
operator|.
name|getLen
argument_list|()
operator|%
name|blockSize
decl_stmt|;
name|int
name|freeInLastBlock
init|=
call|(
name|int
call|)
argument_list|(
name|blockSize
operator|-
name|usedInLastBlock
argument_list|)
decl_stmt|;
comment|// calculate the amount of free space in the pre-existing
comment|// last crc chunk
name|int
name|usedInCksum
init|=
call|(
name|int
call|)
argument_list|(
name|stat
operator|.
name|getLen
argument_list|()
operator|%
name|bytesPerChecksum
argument_list|)
decl_stmt|;
name|int
name|freeInCksum
init|=
name|bytesPerChecksum
operator|-
name|usedInCksum
decl_stmt|;
comment|// if there is space in the last block, then we have to
comment|// append to that block
if|if
condition|(
name|freeInLastBlock
operator|==
name|blockSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The last block for file "
operator|+
name|src
operator|+
literal|" is full."
argument_list|)
throw|;
block|}
if|if
condition|(
name|usedInCksum
operator|>
literal|0
operator|&&
name|freeInCksum
operator|>
literal|0
condition|)
block|{
comment|// if there is space in the last partial chunk, then
comment|// setup in such a way that the next packet will have only
comment|// one chunk that fills up the partial chunk.
comment|//
name|computePacketChunkSize
argument_list|(
literal|0
argument_list|,
name|freeInCksum
argument_list|)
expr_stmt|;
name|setChecksumBufSize
argument_list|(
name|freeInCksum
argument_list|)
expr_stmt|;
name|streamer
operator|.
name|setAppendChunk
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if the remaining space in the block is smaller than
comment|// that expected size of of a packet, then create
comment|// smaller size packet.
comment|//
name|computePacketChunkSize
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|writePacketSize
argument_list|,
name|freeInLastBlock
argument_list|)
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|newStreamForAppend (DFSClient dfsClient, String src, EnumSet<CreateFlag> flags, int bufferSize, Progressable progress, LocatedBlock lastBlock, HdfsFileStatus stat, DataChecksum checksum, String[] favoredNodes)
specifier|static
name|DFSOutputStream
name|newStreamForAppend
parameter_list|(
name|DFSClient
name|dfsClient
parameter_list|,
name|String
name|src
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flags
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|LocatedBlock
name|lastBlock
parameter_list|,
name|HdfsFileStatus
name|stat
parameter_list|,
name|DataChecksum
name|checksum
parameter_list|,
name|String
index|[]
name|favoredNodes
parameter_list|)
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|dfsClient
operator|.
name|getPathTraceScope
argument_list|(
literal|"newStreamForAppend"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|DFSOutputStream
name|out
init|=
operator|new
name|DFSOutputStream
argument_list|(
name|dfsClient
argument_list|,
name|src
argument_list|,
name|flags
argument_list|,
name|progress
argument_list|,
name|lastBlock
argument_list|,
name|stat
argument_list|,
name|checksum
argument_list|)
decl_stmt|;
if|if
condition|(
name|favoredNodes
operator|!=
literal|null
operator|&&
name|favoredNodes
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|streamer
operator|.
name|setFavoredNodes
argument_list|(
name|favoredNodes
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|out
return|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|computePacketChunkSize (int psize, int csize)
specifier|protected
name|void
name|computePacketChunkSize
parameter_list|(
name|int
name|psize
parameter_list|,
name|int
name|csize
parameter_list|)
block|{
specifier|final
name|int
name|bodySize
init|=
name|psize
operator|-
name|PacketHeader
operator|.
name|PKT_MAX_HEADER_LEN
decl_stmt|;
specifier|final
name|int
name|chunkSize
init|=
name|csize
operator|+
name|getChecksumSize
argument_list|()
decl_stmt|;
name|chunksPerPacket
operator|=
name|Math
operator|.
name|max
argument_list|(
name|bodySize
operator|/
name|chunkSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|packetSize
operator|=
name|chunkSize
operator|*
name|chunksPerPacket
expr_stmt|;
if|if
condition|(
name|DFSClient
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"computePacketChunkSize: src="
operator|+
name|src
operator|+
literal|", chunkSize="
operator|+
name|chunkSize
operator|+
literal|", chunksPerPacket="
operator|+
name|chunksPerPacket
operator|+
literal|", packetSize="
operator|+
name|packetSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createWriteTraceScope ()
specifier|protected
name|TraceScope
name|createWriteTraceScope
parameter_list|()
block|{
return|return
name|dfsClient
operator|.
name|getPathTraceScope
argument_list|(
literal|"DFSOutputStream#write"
argument_list|,
name|src
argument_list|)
return|;
block|}
comment|// @see FSOutputSummer#writeChunk()
annotation|@
name|Override
DECL|method|writeChunk (byte[] b, int offset, int len, byte[] checksum, int ckoff, int cklen)
specifier|protected
specifier|synchronized
name|void
name|writeChunk
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|byte
index|[]
name|checksum
parameter_list|,
name|int
name|ckoff
parameter_list|,
name|int
name|cklen
parameter_list|)
throws|throws
name|IOException
block|{
name|dfsClient
operator|.
name|checkOpen
argument_list|()
expr_stmt|;
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|bytesPerChecksum
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"writeChunk() buffer size is "
operator|+
name|len
operator|+
literal|" is larger than supported  bytesPerChecksum "
operator|+
name|bytesPerChecksum
argument_list|)
throw|;
block|}
if|if
condition|(
name|cklen
operator|!=
literal|0
operator|&&
name|cklen
operator|!=
name|getChecksumSize
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"writeChunk() checksum size is supposed to be "
operator|+
name|getChecksumSize
argument_list|()
operator|+
literal|" but found to be "
operator|+
name|cklen
argument_list|)
throw|;
block|}
if|if
condition|(
name|currentPacket
operator|==
literal|null
condition|)
block|{
name|currentPacket
operator|=
name|createPacket
argument_list|(
name|packetSize
argument_list|,
name|chunksPerPacket
argument_list|,
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|,
name|streamer
operator|.
name|getAndIncCurrentSeqno
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|DFSClient
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"DFSClient writeChunk allocating new packet seqno="
operator|+
name|currentPacket
operator|.
name|getSeqno
argument_list|()
operator|+
literal|", src="
operator|+
name|src
operator|+
literal|", packetSize="
operator|+
name|packetSize
operator|+
literal|", chunksPerPacket="
operator|+
name|chunksPerPacket
operator|+
literal|", bytesCurBlock="
operator|+
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|currentPacket
operator|.
name|writeChecksum
argument_list|(
name|checksum
argument_list|,
name|ckoff
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|currentPacket
operator|.
name|writeData
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|currentPacket
operator|.
name|incNumChunks
argument_list|()
expr_stmt|;
name|streamer
operator|.
name|incBytesCurBlock
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|// If packet is full, enqueue it for transmission
comment|//
if|if
condition|(
name|currentPacket
operator|.
name|getNumChunks
argument_list|()
operator|==
name|currentPacket
operator|.
name|getMaxChunks
argument_list|()
operator|||
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|==
name|blockSize
condition|)
block|{
if|if
condition|(
name|DFSClient
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"DFSClient writeChunk packet full seqno="
operator|+
name|currentPacket
operator|.
name|getSeqno
argument_list|()
operator|+
literal|", src="
operator|+
name|src
operator|+
literal|", bytesCurBlock="
operator|+
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|+
literal|", blockSize="
operator|+
name|blockSize
operator|+
literal|", appendChunk="
operator|+
name|streamer
operator|.
name|getAppendChunk
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|streamer
operator|.
name|waitAndQueuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
name|adjustChunkBoundary
argument_list|()
expr_stmt|;
name|endBlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * If the reopened file did not end at chunk boundary and the above    * write filled up its partial chunk. Tell the summer to generate full    * crc chunks from now on.    */
DECL|method|adjustChunkBoundary ()
specifier|protected
name|void
name|adjustChunkBoundary
parameter_list|()
block|{
if|if
condition|(
name|streamer
operator|.
name|getAppendChunk
argument_list|()
operator|&&
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|%
name|bytesPerChecksum
operator|==
literal|0
condition|)
block|{
name|streamer
operator|.
name|setAppendChunk
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|resetChecksumBufSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|streamer
operator|.
name|getAppendChunk
argument_list|()
condition|)
block|{
name|int
name|psize
init|=
name|Math
operator|.
name|min
argument_list|(
call|(
name|int
call|)
argument_list|(
name|blockSize
operator|-
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|)
argument_list|,
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|writePacketSize
argument_list|)
decl_stmt|;
name|computePacketChunkSize
argument_list|(
name|psize
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * if encountering a block boundary, send an empty packet to    * indicate the end of block and reset bytesCurBlock.    *    * @throws IOException    */
DECL|method|endBlock ()
specifier|protected
name|void
name|endBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|==
name|blockSize
condition|)
block|{
name|currentPacket
operator|=
name|createPacket
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|,
name|streamer
operator|.
name|getAndIncCurrentSeqno
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|currentPacket
operator|.
name|setSyncBlock
argument_list|(
name|shouldSyncBlock
argument_list|)
expr_stmt|;
name|streamer
operator|.
name|waitAndQueuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
name|streamer
operator|.
name|setBytesCurBlock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lastFlushOffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * Flushes out to all replicas of the block. The data is in the buffers    * of the DNs but not necessarily in the DN's OS buffers.    *    * It is a synchronous operation. When it returns,    * it guarantees that flushed data become visible to new readers.     * It is not guaranteed that data has been flushed to     * persistent store on the datanode.     * Block allocations are persisted on namenode.    */
annotation|@
name|Override
DECL|method|hflush ()
specifier|public
name|void
name|hflush
parameter_list|()
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|dfsClient
operator|.
name|getPathTraceScope
argument_list|(
literal|"hflush"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|flushOrSync
argument_list|(
literal|false
argument_list|,
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SyncFlag
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hsync ()
specifier|public
name|void
name|hsync
parameter_list|()
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|dfsClient
operator|.
name|getPathTraceScope
argument_list|(
literal|"hsync"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|flushOrSync
argument_list|(
literal|true
argument_list|,
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SyncFlag
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * The expected semantics is all data have flushed out to all replicas     * and all replicas have done posix fsync equivalent - ie the OS has     * flushed it to the disk device (but the disk may have it in its cache).    *     * Note that only the current block is flushed to the disk device.    * To guarantee durable sync across block boundaries the stream should    * be created with {@link CreateFlag#SYNC_BLOCK}.    *     * @param syncFlags    *          Indicate the semantic of the sync. Currently used to specify    *          whether or not to update the block length in NameNode.    */
DECL|method|hsync (EnumSet<SyncFlag> syncFlags)
specifier|public
name|void
name|hsync
parameter_list|(
name|EnumSet
argument_list|<
name|SyncFlag
argument_list|>
name|syncFlags
parameter_list|)
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|dfsClient
operator|.
name|getPathTraceScope
argument_list|(
literal|"hsync"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|flushOrSync
argument_list|(
literal|true
argument_list|,
name|syncFlags
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Flush/Sync buffered data to DataNodes.    *     * @param isSync    *          Whether or not to require all replicas to flush data to the disk    *          device    * @param syncFlags    *          Indicate extra detailed semantic of the flush/sync. Currently    *          mainly used to specify whether or not to update the file length in    *          the NameNode    * @throws IOException    */
DECL|method|flushOrSync (boolean isSync, EnumSet<SyncFlag> syncFlags)
specifier|private
name|void
name|flushOrSync
parameter_list|(
name|boolean
name|isSync
parameter_list|,
name|EnumSet
argument_list|<
name|SyncFlag
argument_list|>
name|syncFlags
parameter_list|)
throws|throws
name|IOException
block|{
name|dfsClient
operator|.
name|checkOpen
argument_list|()
expr_stmt|;
name|checkClosed
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|toWaitFor
decl_stmt|;
name|long
name|lastBlockLength
init|=
operator|-
literal|1L
decl_stmt|;
name|boolean
name|updateLength
init|=
name|syncFlags
operator|.
name|contains
argument_list|(
name|SyncFlag
operator|.
name|UPDATE_LENGTH
argument_list|)
decl_stmt|;
name|boolean
name|endBlock
init|=
name|syncFlags
operator|.
name|contains
argument_list|(
name|SyncFlag
operator|.
name|END_BLOCK
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// flush checksum buffer, but keep checksum buffer intact if we do not
comment|// need to end the current block
name|int
name|numKept
init|=
name|flushBuffer
argument_list|(
operator|!
name|endBlock
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// bytesCurBlock potentially incremented if there was buffered data
if|if
condition|(
name|DFSClient
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"DFSClient flush(): "
operator|+
literal|" bytesCurBlock="
operator|+
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|+
literal|" lastFlushOffset="
operator|+
name|lastFlushOffset
operator|+
literal|" createNewBlock="
operator|+
name|endBlock
argument_list|)
expr_stmt|;
block|}
comment|// Flush only if we haven't already flushed till this offset.
if|if
condition|(
name|lastFlushOffset
operator|!=
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
condition|)
block|{
assert|assert
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|>
name|lastFlushOffset
assert|;
comment|// record the valid offset of this flush
name|lastFlushOffset
operator|=
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|isSync
operator|&&
name|currentPacket
operator|==
literal|null
operator|&&
operator|!
name|endBlock
condition|)
block|{
comment|// Nothing to send right now,
comment|// but sync was requested.
comment|// Send an empty packet if we do not end the block right now
name|currentPacket
operator|=
name|createPacket
argument_list|(
name|packetSize
argument_list|,
name|chunksPerPacket
argument_list|,
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|,
name|streamer
operator|.
name|getAndIncCurrentSeqno
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isSync
operator|&&
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|endBlock
condition|)
block|{
comment|// Nothing to send right now,
comment|// and the block was partially written,
comment|// and sync was requested.
comment|// So send an empty sync packet if we do not end the block right now
name|currentPacket
operator|=
name|createPacket
argument_list|(
name|packetSize
argument_list|,
name|chunksPerPacket
argument_list|,
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|,
name|streamer
operator|.
name|getAndIncCurrentSeqno
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentPacket
operator|!=
literal|null
condition|)
block|{
comment|// just discard the current packet since it is already been sent.
name|currentPacket
operator|.
name|releaseBuffer
argument_list|(
name|byteArrayManager
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentPacket
operator|!=
literal|null
condition|)
block|{
name|currentPacket
operator|.
name|setSyncBlock
argument_list|(
name|isSync
argument_list|)
expr_stmt|;
name|streamer
operator|.
name|waitAndQueuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|endBlock
operator|&&
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Need to end the current block, thus send an empty packet to
comment|// indicate this is the end of the block and reset bytesCurBlock
name|currentPacket
operator|=
name|createPacket
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|,
name|streamer
operator|.
name|getAndIncCurrentSeqno
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|currentPacket
operator|.
name|setSyncBlock
argument_list|(
name|shouldSyncBlock
operator|||
name|isSync
argument_list|)
expr_stmt|;
name|streamer
operator|.
name|waitAndQueuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
name|streamer
operator|.
name|setBytesCurBlock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lastFlushOffset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Restore state of stream. Record the last flush offset
comment|// of the last full chunk that was flushed.
name|streamer
operator|.
name|setBytesCurBlock
argument_list|(
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|-
name|numKept
argument_list|)
expr_stmt|;
block|}
name|toWaitFor
operator|=
name|streamer
operator|.
name|getLastQueuedSeqno
argument_list|()
expr_stmt|;
block|}
comment|// end synchronized
name|streamer
operator|.
name|waitForAckedSeqno
argument_list|(
name|toWaitFor
argument_list|)
expr_stmt|;
comment|// update the block length first time irrespective of flag
if|if
condition|(
name|updateLength
operator|||
name|streamer
operator|.
name|getPersistBlocks
argument_list|()
operator|.
name|get
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|streamer
operator|.
name|streamerClosed
argument_list|()
operator|&&
name|streamer
operator|.
name|getBlock
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|lastBlockLength
operator|=
name|streamer
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// If 1) any new blocks were allocated since the last flush, or 2) to
comment|// update length in NN is required, then persist block locations on
comment|// namenode.
if|if
condition|(
name|streamer
operator|.
name|getPersistBlocks
argument_list|()
operator|.
name|getAndSet
argument_list|(
literal|false
argument_list|)
operator|||
name|updateLength
condition|)
block|{
try|try
block|{
name|dfsClient
operator|.
name|namenode
operator|.
name|fsync
argument_list|(
name|src
argument_list|,
name|fileId
argument_list|,
name|dfsClient
operator|.
name|clientName
argument_list|,
name|lastBlockLength
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to persist blocks in hflush for "
operator|+
name|src
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
comment|// If we got an error here, it might be because some other thread called
comment|// close before our hflush completed. In that case, we should throw an
comment|// exception that the stream is closed.
name|checkClosed
argument_list|()
expr_stmt|;
comment|// If we aren't closed but failed to sync, we should expose that to the
comment|// caller.
throw|throw
name|ioe
throw|;
block|}
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|streamer
operator|.
name|streamerClosed
argument_list|()
condition|)
block|{
name|streamer
operator|.
name|setHflush
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedIOException
name|interrupt
parameter_list|)
block|{
comment|// This kind of error doesn't mean that the stream itself is broken - just the
comment|// flushing thread got interrupted. So, we shouldn't close down the writer,
comment|// but instead just propagate the error
throw|throw
name|interrupt
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error while syncing"
argument_list|,
name|e
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|isClosed
argument_list|()
condition|)
block|{
name|streamer
operator|.
name|getLastException
argument_list|()
operator|.
name|set
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"IOException flush: "
operator|+
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|closeThreads
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * @deprecated use {@link HdfsDataOutputStream#getCurrentBlockReplication()}.    */
annotation|@
name|Deprecated
DECL|method|getNumCurrentReplicas ()
specifier|public
specifier|synchronized
name|int
name|getNumCurrentReplicas
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getCurrentBlockReplication
argument_list|()
return|;
block|}
comment|/**    * Note that this is not a public API;    * use {@link HdfsDataOutputStream#getCurrentBlockReplication()} instead.    *     * @return the number of valid replicas of the current block    */
DECL|method|getCurrentBlockReplication ()
specifier|public
specifier|synchronized
name|int
name|getCurrentBlockReplication
parameter_list|()
throws|throws
name|IOException
block|{
name|dfsClient
operator|.
name|checkOpen
argument_list|()
expr_stmt|;
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|streamer
operator|.
name|streamerClosed
argument_list|()
condition|)
block|{
return|return
name|blockReplication
return|;
comment|// no pipeline, return repl factor of file
block|}
name|DatanodeInfo
index|[]
name|currentNodes
init|=
name|streamer
operator|.
name|getNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentNodes
operator|==
literal|null
condition|)
block|{
return|return
name|blockReplication
return|;
comment|// no pipeline, return repl factor of file
block|}
return|return
name|currentNodes
operator|.
name|length
return|;
block|}
comment|/**    * Waits till all existing data is flushed and confirmations     * received from datanodes.     */
DECL|method|flushInternal ()
specifier|protected
name|void
name|flushInternal
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|toWaitFor
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|dfsClient
operator|.
name|checkOpen
argument_list|()
expr_stmt|;
name|checkClosed
argument_list|()
expr_stmt|;
comment|//
comment|// If there is data in the current buffer, send it across
comment|//
name|streamer
operator|.
name|queuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
name|toWaitFor
operator|=
name|streamer
operator|.
name|getLastQueuedSeqno
argument_list|()
expr_stmt|;
block|}
name|streamer
operator|.
name|waitForAckedSeqno
argument_list|(
name|toWaitFor
argument_list|)
expr_stmt|;
block|}
DECL|method|start ()
specifier|protected
specifier|synchronized
name|void
name|start
parameter_list|()
block|{
name|streamer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Aborts this output stream and releases any system     * resources associated with this stream.    */
DECL|method|abort ()
specifier|synchronized
name|void
name|abort
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
return|return;
block|}
name|streamer
operator|.
name|setLastException
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Lease timeout of "
operator|+
operator|(
name|dfsClient
operator|.
name|getHdfsTimeout
argument_list|()
operator|/
literal|1000
operator|)
operator|+
literal|" seconds expired."
argument_list|)
argument_list|)
expr_stmt|;
name|closeThreads
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|dfsClient
operator|.
name|endFileLease
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
block|}
DECL|method|isClosed ()
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|closed
operator|||
name|streamer
operator|.
name|streamerClosed
argument_list|()
return|;
block|}
DECL|method|setClosed ()
name|void
name|setClosed
parameter_list|()
block|{
name|closed
operator|=
literal|true
expr_stmt|;
name|streamer
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|// shutdown datastreamer and responseprocessor threads.
comment|// interrupt datastreamer if force is true
DECL|method|closeThreads (boolean force)
specifier|protected
name|void
name|closeThreads
parameter_list|(
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|streamer
operator|.
name|close
argument_list|(
name|force
argument_list|)
expr_stmt|;
name|streamer
operator|.
name|join
argument_list|()
expr_stmt|;
name|streamer
operator|.
name|closeSocket
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to shutdown streamer"
argument_list|)
throw|;
block|}
finally|finally
block|{
name|streamer
operator|.
name|setSocketToNull
argument_list|()
expr_stmt|;
name|setClosed
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Closes this output stream and releases any system     * resources associated with this stream.    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|TraceScope
name|scope
init|=
name|dfsClient
operator|.
name|getPathTraceScope
argument_list|(
literal|"DFSOutputStream#close"
argument_list|,
name|src
argument_list|)
decl_stmt|;
try|try
block|{
name|closeImpl
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|closeImpl ()
specifier|protected
specifier|synchronized
name|void
name|closeImpl
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
name|IOException
name|e
init|=
name|streamer
operator|.
name|getLastException
argument_list|()
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
return|return;
else|else
throw|throw
name|e
throw|;
block|}
try|try
block|{
name|flushBuffer
argument_list|()
expr_stmt|;
comment|// flush from all upper layers
if|if
condition|(
name|currentPacket
operator|!=
literal|null
condition|)
block|{
name|streamer
operator|.
name|waitAndQueuePacket
argument_list|(
name|currentPacket
argument_list|)
expr_stmt|;
name|currentPacket
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// send an empty packet to mark the end of the block
name|currentPacket
operator|=
name|createPacket
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|streamer
operator|.
name|getBytesCurBlock
argument_list|()
argument_list|,
name|streamer
operator|.
name|getAndIncCurrentSeqno
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|currentPacket
operator|.
name|setSyncBlock
argument_list|(
name|shouldSyncBlock
argument_list|)
expr_stmt|;
block|}
name|flushInternal
argument_list|()
expr_stmt|;
comment|// flush all data to Datanodes
comment|// get last block before destroying the streamer
name|ExtendedBlock
name|lastBlock
init|=
name|streamer
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|closeThreads
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TraceScope
name|scope
init|=
name|Trace
operator|.
name|startSpan
argument_list|(
literal|"completeFile"
argument_list|,
name|Sampler
operator|.
name|NEVER
argument_list|)
decl_stmt|;
try|try
block|{
name|completeFile
argument_list|(
name|lastBlock
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|dfsClient
operator|.
name|endFileLease
argument_list|(
name|fileId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{     }
finally|finally
block|{
name|setClosed
argument_list|()
expr_stmt|;
block|}
block|}
comment|// should be called holding (this) lock since setTestFilename() may
comment|// be called during unit tests
DECL|method|completeFile (ExtendedBlock last)
specifier|protected
name|void
name|completeFile
parameter_list|(
name|ExtendedBlock
name|last
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|localstart
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|sleeptime
init|=
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|blockWriteLocateFollowingInitialDelayMs
decl_stmt|;
name|boolean
name|fileComplete
init|=
literal|false
decl_stmt|;
name|int
name|retries
init|=
name|dfsClient
operator|.
name|getConf
argument_list|()
operator|.
name|nBlockWriteLocateFollowingRetry
decl_stmt|;
while|while
condition|(
operator|!
name|fileComplete
condition|)
block|{
name|fileComplete
operator|=
name|dfsClient
operator|.
name|namenode
operator|.
name|complete
argument_list|(
name|src
argument_list|,
name|dfsClient
operator|.
name|clientName
argument_list|,
name|last
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileComplete
condition|)
block|{
specifier|final
name|int
name|hdfsTimeout
init|=
name|dfsClient
operator|.
name|getHdfsTimeout
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dfsClient
operator|.
name|clientRunning
operator|||
operator|(
name|hdfsTimeout
operator|>
literal|0
operator|&&
name|localstart
operator|+
name|hdfsTimeout
operator|<
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Unable to close file because dfsclient "
operator|+
literal|" was unable to contact the HDFS servers."
operator|+
literal|" clientRunning "
operator|+
name|dfsClient
operator|.
name|clientRunning
operator|+
literal|" hdfsTimeout "
operator|+
name|hdfsTimeout
decl_stmt|;
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|retries
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to close file because the last block"
operator|+
literal|" does not have enough number of replicas."
argument_list|)
throw|;
block|}
name|retries
operator|--
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleeptime
argument_list|)
expr_stmt|;
name|sleeptime
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|localstart
operator|>
literal|5000
condition|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"Could not complete "
operator|+
name|src
operator|+
literal|" retrying..."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|DFSClient
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|setArtificialSlowdown (long period)
specifier|public
name|void
name|setArtificialSlowdown
parameter_list|(
name|long
name|period
parameter_list|)
block|{
name|streamer
operator|.
name|setArtificialSlowdown
argument_list|(
name|period
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setChunksPerPacket (int value)
specifier|public
specifier|synchronized
name|void
name|setChunksPerPacket
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|chunksPerPacket
operator|=
name|Math
operator|.
name|min
argument_list|(
name|chunksPerPacket
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|packetSize
operator|=
operator|(
name|bytesPerChecksum
operator|+
name|getChecksumSize
argument_list|()
operator|)
operator|*
name|chunksPerPacket
expr_stmt|;
block|}
comment|/**    * Returns the size of a file as it was when this stream was opened    */
DECL|method|getInitialLen ()
specifier|public
name|long
name|getInitialLen
parameter_list|()
block|{
return|return
name|initialFileSize
return|;
block|}
comment|/**    * @return the FileEncryptionInfo for this stream, or null if not encrypted.    */
DECL|method|getFileEncryptionInfo ()
specifier|public
name|FileEncryptionInfo
name|getFileEncryptionInfo
parameter_list|()
block|{
return|return
name|fileEncryptionInfo
return|;
block|}
comment|/**    * Returns the access token currently used by streamer, for testing only    */
DECL|method|getBlockToken ()
specifier|synchronized
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|getBlockToken
parameter_list|()
block|{
return|return
name|streamer
operator|.
name|getBlockToken
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|setDropBehind (Boolean dropBehind)
specifier|public
name|void
name|setDropBehind
parameter_list|(
name|Boolean
name|dropBehind
parameter_list|)
throws|throws
name|IOException
block|{
name|CachingStrategy
name|prevStrategy
decl_stmt|,
name|nextStrategy
decl_stmt|;
comment|// CachingStrategy is immutable.  So build a new CachingStrategy with the
comment|// modifications we want, and compare-and-swap it in.
do|do
block|{
name|prevStrategy
operator|=
name|this
operator|.
name|cachingStrategy
operator|.
name|get
argument_list|()
expr_stmt|;
name|nextStrategy
operator|=
operator|new
name|CachingStrategy
operator|.
name|Builder
argument_list|(
name|prevStrategy
argument_list|)
operator|.
name|setDropBehind
argument_list|(
name|dropBehind
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|this
operator|.
name|cachingStrategy
operator|.
name|compareAndSet
argument_list|(
name|prevStrategy
argument_list|,
name|nextStrategy
argument_list|)
condition|)
do|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getBlock ()
name|ExtendedBlock
name|getBlock
parameter_list|()
block|{
return|return
name|streamer
operator|.
name|getBlock
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getFileId ()
specifier|public
name|long
name|getFileId
parameter_list|()
block|{
return|return
name|fileId
return|;
block|}
block|}
end_class

end_unit

